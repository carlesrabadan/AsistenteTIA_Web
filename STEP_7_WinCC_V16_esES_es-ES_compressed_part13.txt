ásicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)
Ejemplos de programación AWL (Página 8102)

T STW: Transferir acumulador 1 a palabra de estado
Descripción
La instrucción "Transferir acumulador 1 a palabra de estado" transfiere los bits 0 a 8 del
acumulador 1 a la palabra de estado.

Programación del PLC
Manual de programación y manejo, 11/2019

1665

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra los bits del acumulador 1 con los que se sobrescriben los bits de
estado después de ejecutar la instrucción:
Acumulador 1
Número de bit

8

7

6

5

4

3

2

1

0

Bits de estado

BR

CC 1

CC 0

OV

OS

0

0

RLO

0

Esta instrucción se ejecuta independientemente del estado lógico del bit de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_STW"

// Cargar el valor del operando "Tag_STW" en el acumulador 1.

T STW

// Transferir los bits 0 a 8 del acumulador 1 a la palabra de estado.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

CAR: Intercambiar AR1 y AR2
Descripción
La instrucción "Intercambiar AR1 y AR2" intercambia los contenidos de los registros de
direcciones 1 (AR1) y 2 (AR2).
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.
Los contenidos de los acumuladores no cambian debido a la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1666

AWL

Explicación

LAR1 P#10.0

// Cargar el contenido del puntero intraárea P#10.0 en
el registro de direcciones 1.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

LAR2 P#20.0

// Cargar el contenido del puntero intraárea P#20.0 en
el registro de direcciones 2.

CAR

// Intercambiar el contenido de los registros de direcciones.

L MD [AR1,P#2.0]

// Cargar MD22 en el acumulador 1.

T MD [AR2,P#2.0]

// Transferir MD12 al acumulador 2.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

TAR1: Transferir AR1 a acumulador 1
Descripción
La instrucción "Transferir AR1 a acumulador 1" transfiere el contenido del registro de
direcciones 1 (AR1) al acumulador 1. El contenido del acumulador 1 se desplaza al
acumulador 2.
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

LAR1 P#15.0

// Cargar el contenido del puntero intraárea P#15.0 en
el registro de direcciones 1.

TAR1

// Transferir el contenido del registro de direcciones
1 (P#15.0) al acumulador 1.

T "Tag_Pointer"

// Transferir el contenido del acumulador 1 al operando "Tag_Pointer".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)

Programación del PLC
Manual de programación y manejo, 11/2019

1667

Instrucciones
4.1 Instrucciones
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

TAR1 <D>: Transferir AR1 a palabra doble
Descripción
La instrucción "Transferir AR1 a palabra doble" transfiere el contenido del registro de
direcciones 1 (AR1) a una palabra doble. La palabra doble debe estar direccionada en una de
las áreas de memoria siguientes:
● Marcas (M)
● Datos locales temporales (L)
● Bloques de datos (DB, DI)
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.
Los contenidos de los acumuladores no cambian debido a la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Transferir AR1 a palabra doble":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<D>

Output

DWORD

D, M, L

Operando al que se transfie‐
re el contenido del registro de
direcciones 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

TAR1 %DBD20

// Transferir el contenido del registro de direcciones
1 a la doble palabra de datos DBD20.

TAR1 %DID30

// Transferir el contenido del registro de direcciones
1 a la doble palabra de instancia DID30.

TAR1 %LD18

// Transferir el contenido del registro de direcciones
1 a la doble palabra de datos locales LD18.

TAR1 %MD24

// Transferir el contenido del registro de direcciones
1 a la doble palabra de marcas MD24.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)

1668

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

TAR1 AR2: Transferir AR1 a AR2
Descripción
La instrucción "Transferir AR1 a AR2" copia el contenido del registro de direcciones 1 (AR1) en
el registro de direcciones 2 (AR2).
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.
Los contenidos de los acumuladores no cambian debido a la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

LAR1 P#10.4

// Cargar el contenido del puntero intraárea P#10.4 en
el registro de direcciones 1.

TAR1 AR2

// Transferir el contenido del registro de direcciones
1 al registro de direcciones 2.

A I [AR2,P#3.2]

// Consultar si el estado lógico del bit I13.6 es "1"
y combinar el resultado lógicamente con Y con el RLO
actual.

= "Tag1"

// Poner el operando "Tag_1" a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Programación del PLC
Manual de programación y manejo, 11/2019

1669

Instrucciones
4.1 Instrucciones

TAR2: Transferir AR2 a acumulador 1
Descripción
La instrucción "Transferir AR2 a acumulador 1" transfiere el contenido del registro de
direcciones 2 (AR2) al acumulador 1. El contenido del acumulador 1 se desplaza al
acumulador 2.
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

LAR2 P#20.0

// Cargar el contenido del puntero intraárea P#20.0 al
registro de direcciones 2.

TAR2

// Transferir el contenido del registro de direcciones
2 (P#20.0) al acumulador 1.

T "Tag_Pointer"

// Transferir el contenido del acumulador 1 al operando "Tag_Pointer".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

TAR2 <D>: Transferir AR2 a palabra doble
Descripción
La instrucción "Transferir AR2 a palabra doble" transfiere el contenido del registro de
direcciones 2 (AR2) a una palabra doble. La palabra doble debe estar direccionada en una de
las áreas de memoria siguientes:
● Marcas (M)
● Datos locales temporales (L)
● Bloques de datos (DB, DI)
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.

1670

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los contenidos de los acumuladores no cambian debido a la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Transferir AR2 a palabra doble":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<D>

Output

DWORD

D, M, L

Operando al que se transfie‐
re el contenido del registro de
direcciones 2.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

TAR2 %DBD20

// Transferir el contenido del registro de direcciones
2 a la doble palabra de datos DBD20.

TAR2 %DID30

// Transferir el contenido del registro de direcciones
2 a la doble palabra de instancia DID30.

TAR2 %LD18

// Transferir el contenido del registro de direcciones
2 a la doble palabra de datos locales LD18.

TAR2 %MD24

// Transferir el contenido del registro de direcciones
2 a la doble palabra de marcas MD24.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Conversión
BTI: Convertir BCD en entero (16 bits)
Descripción
La instrucción "Convertir BCD en entero (16 bits)" convierte el valor que está en la palabra
derecha del acumulador 1 en un entero (de 16 bits). La instrucción interpreta el valor que debe
convertirse como número decimal codificado en binario de tres dígitos (BCD).
Los bits 1 a 11 del acumulador 1 indican el valor que se convertirá. Se admiten valores dentro
del rango "-999" a "+999".
Programación del PLC
Manual de programación y manejo, 11/2019

1671

Instrucciones
4.1 Instrucciones
El signo del valor del resultado se lee del bit 15 del acumulador 1. Si el estado lógico del bit es
"0", el signo es positivo. Si el estado lógico del bit es "1", el signo es negativo. Los bits 12 a 14
no se utilizan en la conversión.
Si el código BCD contiene un error BCD, la CPU activa los bits OV y OS de la palabra de estado.
El resultado de la conversión se guarda en la palabra derecha del acumulador 1. El contenido
de la palabra izquierda del acumulador 1 no se ve influido por la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar BCD en el acumulador 1.

BTI

// Convertir BCD en entero de 16 bits.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La figura siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
ಯಯ

ಯಯ



ಯ7DJB,QSXWಯ



%7,
ಯ7DJB2XWSXWಯ

ಯಯ



ಯಯ







ಯಯ%&'



ಯಯHQWHUR

&RQYHUWLU%&'HQHQWHUR ELWV






Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

ITB: Convertir entero en BCD (16 bits)
Descripción
La instrucción "Convertir entero en BCD (16 bits)" convierte el valor que se encuentra en la
palabra derecha del acumulador 1 en un número decimal en código binario de tres dígitos
(BCD). La instrucción interpreta el valor que debe convertirse como un entero de 16 bits.

1672

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los bits 0 a 11 del acumulador 1 indican el valor que se convertirá. Se admiten valores dentro
del rango "-999" a "+999". Si el valor que debe convertirse está fuera de este rango, los bits OV
y OS se ponen al estado lógico "1". En este caso no se lleva a cabo la conversión.
El signo del valor del resultado se lee de los bits 12 a 15 del acumulador 1. Si el estado lógico
de los bits es "0", el signo es positivo. Si el estado lógico de los cuatro bits es "1", el signo es
negativo.
El resultado de la conversión se guarda en la palabra derecha del acumulador 1. El contenido
de la palabra izquierda del acumulador 1 no se ve influido por la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar entero (16 bits) en el acumulador 1.

ITB

// Convertir entero en BCD.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La figura siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:



ಯ7DJB,QSXWಯ



,7%
ಯ7DJB2XWSXWಯ











ಯಯHQWHUR



ಯಯ%&'

&RQYHUWLUHQWHURHQ%&' ELWV




ಯಯ

ಯಯ


ಯಯ

ಯಯ

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Programación del PLC
Manual de programación y manejo, 11/2019

1673

Instrucciones
4.1 Instrucciones

BTD: Convertir BCD en entero doble (32 bits)
Descripción
La instrucción "Convertir BCD en entero doble (32 bits)" convierte el valor que está en el
acumulador 1 en un entero doble (de 32 bits). La instrucción interpreta el valor que debe
convertirse como número decimal codificado en binario de siete dígitos (BCD).
Los bits 0 a 27 del acumulador 1 indican el valor que se convertirá. Se admiten valores dentro
del rango "-9999999" a "+9999999".
El signo del valor del resultado se lee del bit 31 del acumulador 1. Si el estado lógico del bit es
"0", el signo es positivo. Si el estado lógico del bit es "1", el signo es negativo. Los bits 28 a 30
no se utilizan en la conversión.
El resultado de la instrucción se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.
Si el código BCD contiene un error BCD, la CPU activa los bits OV y OS de la palabra de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar BCD en el acumulador 1.

BTD

// Convertir BCD en un entero de 32 bits.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La figura siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
ಯಯ

ಯಯ

ಯಯ

ಯಯ

ಯಯ

ಯಯ


        ಯಯ

%7'
ಯ7DJB2XWSXWಯ

ಯಯ

 


ಯ7DJB,QSXWಯ

ಯಯ

&RQYHUWLU%&'HQHQWHUR ELWV
        ಯಯ

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

1674

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

ITD: Convertir entero (16 bits) en entero doble (32 bits)
Descripción
La instrucción "Convertir entero (16 bits) en entero doble (32 bits)" convierte el valor que se
encuentra en la palabra derecha del acumulador 1 en un entero doble (de 32 bits). La
instrucción interpreta el valor que debe convertirse como un entero de 16 bits.
Los bits 0 a 15 se aplican sin cambios en la conversión. Los bits 16 a 31 del valor del resultado
se rellenan con el estado lógico del bit 15.
El valor del resultado se guarda en el acumulador 1. El contenido del acumulador 2 no cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar entero (16 bits) en el acumulador 1.

ITD

// Convertir entero de 16 bits en entero doble de 32
bits.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el contenido del acumulador 1 antes y después de ejecutar la
instrucción:
Estado

Acumulador 1
31 . . .

....

....

. . . 16

15 . . .

....

....

...0

Antes de la
ejecución

XXXX

XXXX

XXXX

XXXX

1111

1111

1111

0110

Después de
la ejecución

1111

1111

1111

1111

1111

1111

1111

0110

X : el estado lógico de los bits no es relevante para la conversión

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Programación del PLC
Manual de programación y manejo, 11/2019

1675

Instrucciones
4.1 Instrucciones

DTB: Convertir entero doble (32 bits) en BCD
Descripción
La instrucción "Convertir entero doble (32 bits) en BCD" convierte el valor que está en el
acumulador 1 en un número decimal en código binario de siete dígitos (BCD). La instrucción
interpreta el valor que debe convertirse como un entero de 32 bits.
Los bits 0 a 27 del acumulador 1 indican el valor que se convertirá. Se admiten valores dentro
del rango "-9999999" a "+9999999". Si el valor que debe convertirse está fuera de este rango,
los bits OV y OS se ponen al estado lógico "1". En este caso no se lleva a cabo la conversión.
El signo del valor del resultado se lee de los bits 28 a 31 del acumulador 1. Si el estado lógico
de los bits es "0", el signo es positivo. Si el estado lógico de los cuatro bits es "1", el signo es
negativo.
El resultado de la instrucción se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar entero de 32 bits en el acumulador 1.

DTB

// Convertir entero de 32 bits en BCD

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La figura siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
 


ಯ7DJB,QSXWಯ

       

'7%
ಯ7DJB2XWSXWಯ



ಯಯHQWHUR

&RQYHUWLUHQWHURHQ%&' ELWV

       
ಯಯ

ಯಯ

ಯಯ

ಯಯ

ಯಯ

ಯಯ

ಯಯ
ಯಯ
ಯಯ%&'

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)

1676

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

DTR: Convertir entero doble (32 bits) en número en coma flotante
Descripción
La instrucción "Convertir entero doble (32 bits) en número en coma flotante" convierte el valor
que está en el acumulador 1 en un número en coma flotante. La instrucción interpreta el valor
que debe convertirse como un entero de 32 bits.
Puesto que un entero de 32 bits es más exacto que un número en coma flotante, el resultado
de la conversión se redondea al siguiente número representable.
El resultado de la instrucción se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar entero de 32 bits en el acumulador 1.

DTR

// Convertir entero de 32 bits en número en coma flotante.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La figura siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
ಯ7DJB,QSXWಯ
'75

       
&RQYHUWLUHQWHURGREOH ELWV HQQ¼PHURHQFRPDIORWDQWH


7DJB2XWSXW

ಯಯHQWHUR




       
([SRQHQWHELWV

0DQWLVDELWV

ELW
6LJQRGHODPDQWLVD

ಯಯ,((()3

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)

Programación del PLC
Manual de programación y manejo, 11/2019

1677

Instrucciones
4.1 Instrucciones
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

INVI: Generar complemento a uno de un entero (16 bits)
Descripción
La instrucción "Generar complemento a uno de un entero (16 bits)" niega bit por bit el valor que
se encuentra en la palabra derecha del acumulador 1.
Al ejecutarse, la instrucción invierte el estado lógico de cada uno de los bits de la palabra
derecha del acumulador 1. Los unos son sustituidos por ceros y viceversa.
El resultado se guarda en la palabra derecha del acumulador 1. El contenido de la palabra
izquierda del acumulador 1 no se ve influido por la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar el valor en el acumulador 1.

INVI

// Generar un complemento a 1

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor
15 . . .

....

....

...0

Tag_Input

0110

0011

1010

1110

Tag_Output

1001

1100

0101

0001

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

1678

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

INVD: Generar complemento a uno de un entero doble (32 bits)
Descripción
La instrucción "Generar complemento a uno de un entero doble (32 bits)" niega bit por bit el
valor que se encuentra en el acumulador 1.
Al ejecutarse, la instrucción invierte el estado lógico de cada uno de los bits del acumulador 1.
Los unos son sustituidos por ceros y viceversa.
El resultado de la instrucción se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar el valor en el acumulador 1.

INVD

// Generar un complemento a 1

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor
31 . . .

....

....

. . . 16

15 . . .

....

....

...0

Tag_Input

0110

1111

1000

1100

0110

0011

1010

1110

Tag_Output

1001

0000

0111

0011

1001

1100

0101

0001

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

NEGI: Negar entero (16 bits)
Descripción
La instrucción "Negar entero (16 bits)" invierte el signo del valor que está en la palabra derecha
del acumulador 1 por una formación de complemento a dos. La instrucción interpreta el valor
del acumulador 1 como un entero de 16 bits.

Programación del PLC
Manual de programación y manejo, 11/2019

1679

Instrucciones
4.1 Instrucciones
La ejecución de la instrucción es equivalente a una multiplicación por "-1". El resultado de la
instrucción se guarda en la palabra derecha del acumulador 1. El contenido de la palabra
izquierda del acumulador 1 no se ve influido por la instrucción.
La instrucción "Negar entero (16 bits)" influye en los bits de estado CC 0, CC 1, OV y OS. La
tabla siguiente muestra cómo la instrucción influye en los bits de estado en función del
resultado:
Resultado:

CC 1

CC 0

OV

OS

de +1 a +32 767

1

0

0

-

0

0

0

0

-

de -1 a -32 767

0

1

0

-

(-) 32 768

0

1

1

1

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar el valor en el acumulador 1.

NEGI

// Negar entero de 16 bits

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor
15 . . .

....

....

...0

Tag_Input

0101

1101

0011

1000

Tag_Output

1010

0010

1100

1000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

1680

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

NEGD: Negar entero doble (32 bits)
Descripción
La instrucción "Negar entero doble (32 bits)" invierte el signo del valor que se encuentra en el
acumulador 1 por una formación de complemento a dos. La instrucción interpreta el valor del
acumulador 1 como un entero de 32 bits.
La ejecución de la instrucción es equivalente a una multiplicación por "-1". El resultado de la
instrucción se guarda en el acumulador 1. El contenido del acumulador 2 no cambia.
La instrucción "Negar entero doble (32 bits)" influye en los bits de estado CC 0, CC 1, OV y OS.
La tabla siguiente muestra cómo la instrucción influye en los bits de estado en función del
resultado:
Resultado

CC 1

CC 0

OV

OS

de +1 a +2147483647

1

0

0

-

0

0

0

0

-

de -1 a -2147483647

0

1

0

-

(-) 2147483648

0

1

1

1

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar el valor en el acumulador 1.

NEGD

// Negar entero doble de 32 bits.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Estado

Valor
31 . . .

....

....

. . . 16

15 . . .

....

....

...0

Tag_Input

0101

1111

0110

0100

0101

1101

0011

1000

Tag_Output

1010

0000

1001

1011

1010

0010

1100

1000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Programación del PLC
Manual de programación y manejo, 11/2019

1681

Instrucciones
4.1 Instrucciones

NEGR: Negar número en coma flotante
Descripción
La instrucción "Negar número en coma flotante" invierte el signo de la mantisa y es equivalente
a una multiplicación por "-1".
La instrucción interpreta el valor del acumulador 1 como un número en coma flotante. El bit 31
del número en coma flotante contiene el signo de la mantisa.
El resultado de la instrucción se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.
La instrucción no influye en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar el número en coma flotante en el acumulador
1.

NEGR

// Negar número en coma flotante.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Input

1.5E+02

Tag_Output

-1.5E+02

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

CAW: Invertir orden de los bytes en la palabra derecha del acumulador 1
Descripción
La instrucción "Invertir orden de los bytes en la palabra derecha del acumulador 1" invierte el
orden de los dos bytes derechos en la palabra derecha del acumulador 1.

1682

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el contenido del acumulador 1 antes y después de ejecutar la
instrucción:
Estado

Bytes del acumulador 1

Antes de la ejecución

Valor A

Valor B

Valor C

Valor D

Después de la ejecución

Valor A

Valor B

Valor D

Valor C

El resultado de la instrucción se guarda en la palabra derecha del acumulador 1. Los bytes de
la palabra izquierda del acumulador 1 no se ven influidos por la instrucción y no cambian.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar el valor en el acumulador.

CAW

// Invertir orden de los bytes en la palabra derecha
del acumulador 1.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Input

0000

1111

0000

1111

Tag_Output

0000

1111

1111

0000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

CAD: Invertir orden de los bytes en todo el acumulador 1
Descripción
La instrucción "Invertir orden de los bytes en todo el acumulador 1" invierte el orden de los
bytes en el acumulador 1.

Programación del PLC
Manual de programación y manejo, 11/2019

1683

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el contenido del acumulador 1 antes y después de ejecutar la
instrucción:
Estado

Bytes del acumulador 1

Antes de la ejecución

Valor A

Valor B

Valor C

Valor D

Después de la ejecución

Valor D

Valor C

Valor B

Valor A

El resultado de la instrucción se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar el valor del operando en el acumulador 1.

CAD

// Invertir orden de los bytes del acumulador 1.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Input

1111

0000

0000

1111

0000

0000

1111

1111

Tag_Output

1111

1111

0000

0000

0000

1111

1111

0000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

RND: Redondear número
Descripción
La instrucción "Redondear número" convierte el valor que se encuentra en el acumulador 1 en
un entero doble (de 32 bits). La instrucción interpreta el valor que debe convertirse como un
número en coma flotante y lo redondea al siguiente entero.
Si el número en coma flotante se encuentra exactamente entre un número par y uno impar, se
selecciona el número par como resultado.
El resultado de la instrucción se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.

1684

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La conversión no se ejecuta y los bits de estado OV y OS se activan si se cumple una de las
condiciones siguientes:
● El valor que se encuentra en el acumulador 1 no es un número en coma flotante válido.
● El resultado está fuera del rango permitido para un entero del tipo de datos DINT.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar el número en coma flotante en el acumulador
1.

RND

// Redondear un número en coma flotante a un entero.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valores

Tag_Input

101.5

-101.5

Tag_Output

102

-102

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

TRUNC: Truncar a entero
Descripción
La instrucción "Truncar a entero" convierte el valor que se encuentra en el acumulador 1 en un
entero doble (de 32 bits). La instrucción interpreta el valor que debe convertirse como número
en coma flotante y devuelve como resultado su parte entera.
El resultado de la instrucción se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.
La conversión no se ejecuta y los bits de estado OV y OS se activan si se cumple una de las
condiciones siguientes:
● El valor que se encuentra en el acumulador 1 no es un número en coma flotante válido.
● El resultado está fuera del rango permitido para un entero del tipo de datos DINT.
Programación del PLC
Manual de programación y manejo, 11/2019

1685

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar el número en coma flotante en el acumulador
1.

TRUNC

// Convertir el número en coma flotante en un entero
del tipo de datos DINT.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valores

Tag_Input

101.5

-101.5

Tag_Output

101

-101

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

RND+: Redondear un número en coma flotante al siguiente entero superior
Descripción
La instrucción "Redondear un número en coma flotante al siguiente entero superior" convierte
el valor que se encuentra en el acumulador 1 en un entero doble (de 32 bits). La instrucción
interpreta el valor que debe convertirse como número en coma flotante y lo redondea al
siguiente entero superior. El resultado de la instrucción es un número del tipo de datos DINT,
mayor o igual al número en coma flotante que se ha convertido.
El resultado de la instrucción se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.
La conversión no se ejecuta y los bits de estado OV y OS se activan si se cumple una de las
condiciones siguientes:
● El valor que se encuentra en el acumulador 1 no es un número en coma flotante válido.
● El resultado está fuera del rango permitido para un entero del tipo de datos DINT.

1686

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar el número en coma flotante en el acumulador
1.

RND+

// Redondear el número en coma flotante al siguiente
entero superior.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valores

Tag_Input

100.5

-100.5

Tag_Output

101

-100

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

RND-: Redondear un número en coma flotante al siguiente entero inferior
Descripción
La instrucción "Redondear un número en coma flotante al siguiente entero inferior" convierte
el valor que se encuentra en el acumulador 1 en un entero doble (de 32 bits). La instrucción
interpreta el valor que debe convertirse como número en coma flotante y lo redondea al
siguiente entero inferior. El resultado de la instrucción es un número del tipo de datos DINT,
menor o igual al número en coma flotante que se ha convertido.
El resultado de la instrucción se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.
La conversión no se ejecuta y los bits de estado OV y OS se activan si se cumple una de las
condiciones siguientes:
● El valor que se encuentra en el acumulador 1 no es un número en coma flotante válido.
● El resultado está fuera del rango permitido para un entero del tipo de datos DINT.

Programación del PLC
Manual de programación y manejo, 11/2019

1687

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input"

// Cargar el número en coma flotante en el acumulador
1.

RND-

// Redondear el número en coma flotante al siguiente
entero inferior.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valores

Tag_Input

100.5

-100.5

Tag_Output

100

-101

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Control del programa
Operaciones de salto
Etiqueta
Descripción
Una etiqueta sirve para identificar el punto del programa en el que debe continuar la ejecución
tras un salto. El nombre de la etiqueta puede comprender un máximo de 128 letras, cifras o
caracteres de subrayado.
La etiqueta y la instrucción en la que se indica la etiqueta como destino del salto deben
encontrarse en el mismo bloque. El nombre de una etiqueta debe ser único en el bloque. A toda
etiqueta se puede acceder desde distintas posiciones. Se pueden declarar como máximo 256
etiquetas.
Es posible saltar hacia delante y hacia atrás.

1688

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para la etiqueta deben observarse las siguientes reglas gramaticales:
● Letras (a - z, A - Z)
● Una combinación de letras y números. Es importante observar el orden, es decir, primero
las letras y después los números (a - z, A - Z, 0 - 9).
● No pueden utilizarse caracteres especiales o una combinación de letras y números en
orden inverso, es decir, primero los números y después las letras (0 - 9, a - z, A - Z).

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input_1"

// Cargar el primer valor de comparación.

L "Tag_Input_2"

// Cargar el segundo valor de comparación.

>I

// Consultar si el valor del operando "Tag_Input_1" es
mayor que el valor del operando "Tag_Input_2".

JC MyLABEL

// Si el resultado de la consulta es "1", saltar a la
etiqueta "MyLABEL" y continuar allí el procesamiento
del programa
// Si el resultado de la consulta es "0", procesar la
instrucción siguiente.

L "Tag_Input_3"

// Cargar el contenido del operando "Tag_Input_3" en
el acumulador 1.

T "Tag_Output"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output".

MyLABEL: A "Tag_Input_4"

// Continuar la ejecución del programa en este punto
en caso de haberse ejecutado un salto.
// Consultar si el operando "Tag_Input_4" está a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

JU: Salto incondicional
Descripción
La instrucción "Salto incondicional" interrumpe la ejecución lineal del programa y continuarla
en el punto marcado por la etiqueta indicada. Esta instrucción se ejecuta siempre,
independientemente de las condiciones.

Programación del PLC
Manual de programación y manejo, 11/2019

1689

Instrucciones
4.1 Instrucciones
La instrucción "Salto incondicional" no influye en los bits de estado.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Salto incondicional":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input_1"

// Cargar el primer valor de comparación.

L "Tag_Input_2"

// Cargar el segundo valor de comparación.

>I

// Consultar si el valor del operando "Tag_Input_1" es
mayor que el valor del operando "Tag_Input_2".

JC MyLABEL_1

// Si el resultado de la consulta es "1", saltar a la
etiqueta "MyLABEL_1" y continuar allí el procesamiento del programa
// Si el resultado de la consulta es "0", continuar
con la ejecución lineal del programa.

L "Tag_Input_3"

// Cargar el contenido del operando "Tag_Input_3" en
el acumulador 1.

T "Tag_Output_1"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output_1".

JU MyLABEL_2

// Saltar a la etiqueta "MyLABEL_2" y continuar allí
con la ejecución del programa.

MyLABEL_1:

// Etiqueta

L "Tag_Input_4"

// Cargar el contenido del operando "Tag_Input_4" en
el acumulador 1.

T "Tag_Output_2"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output_2".

MyLABEL_2: A "Tag_Input_5"

// Etiqueta "MyLABEL_2"
// Consultar si el operando "Tag_Input_5" está a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)
Ejemplos de programación AWL (Página 8102)

1690

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

JC: Saltar si RLO = 1
Descripción
La instrucción "Saltar si RLO = 1" interrumpe la ejecución lineal del programa en función del
resultado lógico y continuarla en el punto marcado por la etiqueta indicada.
El salto a la etiqueta indicada se ejecuta solo si el RLO actual es "1". Si el RLO actual antes de
la instrucción es "0", el salto no se ejecuta y la ejecución del programa continúa con la
instrucción siguiente.
La instrucción "Saltar si RLO = 1" pone el RLO a "1" tanto si la condición se cumple como si no.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si RLO = 1":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input_1"

// Cargar el primer valor de comparación.

L "Tag_Input_2"

// Cargar el segundo valor de comparación.

>I

// Consultar si el valor del operando "Tag_Input_1" es
mayor que el valor del operando "Tag_Input_2".

JC MyLABEL

// Si el RLO ="1", saltar a la etiqueta "MyLABEL" y
continuar allí la ejecución del programa.
// Si el RLO ="0", procesar la instrucción siguiente.

L "Tag_Input_3"

// Cargar el contenido del operando "Tag_Input_3" en
el acumulador 1.

T "Tag_Output_1"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output_1".

MyLABEL: L "Tag_Input_4"

// Continuar la ejecución del programa en este punto
en caso de haberse ejecutado un salto.
// Cargar el contenido del operando "Tag_Input_4" en
el acumulador 1.

T "Tag_Output_2"

// Transferir el contenido del acumulador 1 al operando "Tag_Output_2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)

Programación del PLC
Manual de programación y manejo, 11/2019

1691

Instrucciones
4.1 Instrucciones
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)
Ejemplos de programación AWL (Página 8102)

JCN: Saltar si RLO = 0
Descripción
La instrucción "Saltar si RLO = 0" interrumpe la ejecución lineal del programa en función del
resultado lógico (RLO) y continuarla en el punto marcado por la etiqueta indicada.
El salto a la etiqueta indicada se ejecuta solo si el RLO actual es "0". Si el RLO actual antes de
la instrucción es "1", el salto no se ejecuta y la ejecución del programa continúa con la
instrucción siguiente.
La instrucción "Saltar si RLO = 0" pone el RLO a "1" tanto si la condición se cumple como si no.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si RLO = 0":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input_1"

// Consultar si el operando "Tag_Input_1" es "1" y
combinar el resultado lógicamente con Y.

A "Tag_Input_2"

// Consultar si el operando "Tag_Input_2" es "1" y
combinar el resultado lógicamente con Y.

JCN MyLABEL

// Si el RLO = "0", saltar a la etiqueta "MyLABEL" y
continuar allí la ejecución del programa.
// Si el RLO ="1", procesar la instrucción siguiente.

L "Tag_Input_3"

// Cargar el contenido del operando "Tag_Input_3" en
el acumulador 1.

T "Tag_Output"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output".

MyLABEL: A "Tag_Input_4"

// Continuar la ejecución del programa en este punto
en caso de haberse ejecutado un salto.
// Consultar si el operando "Tag_Input_4" es "1" y
combinar el resultado lógicamente con Y con el RLO.

1692

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)
Ejemplos de programación AWL (Página 8102)

JCB: Saltar si RLO = 1 y guardar RLO
Descripción
La instrucción "Saltar si RLO = 1 y guardar RLO" interrumpe la ejecución lineal del programa
en función del resultado lógico (RLO) y continuarla en el punto marcado por la etiqueta
indicada. Paralelamente, el estado lógico del RLO actual se copia en el resultado binario (BR).
El salto a la etiqueta indicada se ejecuta solo si el RLO actual es "1". En este caso, la
instrucción pone el resultado binario a "1".
Si el RLO actual antes de la instrucción es "0", el salto no se ejecuta y la ejecución del programa
continúa con la instrucción siguiente. En tal caso, la instrucción asigna el estado lógico "0" al
resultado binario.
La instrucción "Saltar si RLO = 1 y guardar RLO" pone el RLO a "1" tanto si la condición se
cumple como si no.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si RLO = 1 y guardar RLO":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input_1"

// Cargar el primer valor de comparación.

L "Tag_Input_2"

// Cargar el segundo valor de comparación.

>I

// Consultar si el valor del operando "Tag_Input_1" es
mayor que el valor del operando "Tag_Input_2".

Programación del PLC
Manual de programación y manejo, 11/2019

1693

Instrucciones
4.1 Instrucciones
AWL

Explicación

JCB MyLABEL

// Copiar RLO actual en BR.
// Si el RLO ="1", saltar a la etiqueta "MyLABEL" y
continuar allí la ejecución del programa.
// Si el RLO es "0", procesar la instrucción siguiente.

L "Tag_Input_3"

// Cargar el contenido del operando "Tag_Input_3" en
el acumulador 1.

T "Tag_Output_1"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output_1".

MyLABEL: L "Tag_Input_4"

// Continuar la ejecución del programa en este punto
en caso de haberse ejecutado un salto.
// Cargar el contenido del operando "Tag_Input_4" en
el acumulador 1.

T "Tag_Output_2"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output_2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

JNB: Saltar si RLO = 0 y guardar RLO
Descripción
La instrucción "Saltar si RLO = 0 y guardar RLO" interrumpe la ejecución lineal del programa
en función del resultado lógico (RLO) y continuarla en el punto marcado por la etiqueta
indicada. Paralelamente, el estado del resultado lógico actual se copia en el resultado binario
(BR).
El salto a la etiqueta indicada se ejecuta solo si el RLO actual es "0". En tal caso, la instrucción
pone el resultado binario a "0".
Si el RLO actual antes de la instrucción es "1", el salto no se ejecuta y la ejecución del programa
continúa con la instrucción siguiente. En tal caso, la instrucción asigna el estado lógico "1" al
resultado binario.
La instrucción "Saltar si RLO = 0 y guardar RLO" pone el RLO a "1" tanto si la condición se
cumple como si no.

1694

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si RLO = 0 y guardar RLO":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input_1"

// Consultar si el operando "Tag_Input_1" es "1" y
combinar el resultado lógicamente con Y.

A "Tag_Input_2"

// Consultar si el operando "Tag_Input_2" es "1" y
combinar el resultado lógicamente con Y.

JNB MyLABEL

// Copiar RLO actual en BR.
// Si el RLO = "0", saltar a la etiqueta "MyLABEL" y
continuar allí la ejecución del programa.
// Si el RLO ="1", procesar la instrucción siguiente.

L "Tag_Input_3"

// Cargar el contenido del operando "Tag_Input_3" en
el acumulador 1.

T "Tag_Output"

// Transferir el contenido del acumulador 1 al operando "Tag_Output".

MyLABEL: A "Tag_Input_4"

// Continuar la ejecución del programa en este punto
en caso de haberse ejecutado un salto.
// Consultar si el operando "Tag_Input_4" es "1" y
combinar el resultado lógicamente con Y con el RLO.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

JBI: Saltar si BR = 1
Descripción
La instrucción "Saltar si BR = 1" interrumpe la ejecución lineal del programa en función del
resultado binario y continuarla en el punto marcado por la etiqueta indicada.
El salto a la etiqueta se ejecuta solo si el bit de estado BR es "1". Si el bit de estado BR es "0",
el salto no se ejecuta y la ejecución del programa continúa con la instrucción siguiente.

Programación del PLC
Manual de programación y manejo, 11/2019

1695

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si BR = 1":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

SET

// Poner el RLO a "1" al principio del bloque.

SAVE

// Transferir el estado lógico del RLO al bit BR.

....

// Cualquier programa

AN OV

// Consultar el bit OV al final del bloque.

SAVE

// En caso de desbordamiento, poner el bit BR a "0".
// Poner BR a "1" si no se produce desbordamiento.

JBI END

// Si BR = "1", saltar a la etiqueta END.
// Si BR = "0", procesar la instrucción siguiente.

R "Tag_Output_1"

// Poner el operando "Tag_Output_1" a "0".

END: S "Tag_Output_2"

// Poner el operando "Tag_Output_2" a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

JNBI: Saltar si BR = 0
Descripción
La instrucción "Saltar si BR = 0" interrumpe la ejecución lineal del programa en función del
resultado binario (BR) y la continúa en el punto marcado por la etiqueta indicada.
El salto a la etiqueta se ejecuta solo si el bit de estado BR es "0". Si el bit de estado BR antes
de la instrucción es "1", el salto no se ejecuta y la ejecución del programa continúa con la
instrucción siguiente.

1696

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si BR = 0":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

SET

// Poner el RLO a "1" al principio del bloque.

SAVE

// Transferir el estado lógico del RLO al bit BR.

....

// Cualquier programa

AN OV

// Consultar el bit OV al final del bloque.

SAVE

// En caso de desbordamiento, poner el bit BR a "0".
// Poner BR a "1" si no se produce desbordamiento.

JNBI END

// Si BR = "0", saltar a la etiqueta END.
// Si BR = "1", procesar la instrucción siguiente.

S "Tag_Output"

// Poner el operando "Tag_Output" a "1".

END: BE

// Finalizar bloque

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

JO: Saltar si OV = 1
Descripción
La instrucción "Saltar si OV = 1" interrumpe la ejecución lineal del programa en función del bit
de estado OV y la continúa en el punto marcado por la etiqueta indicada.
El salto a la etiqueta se ejecuta solo si el bit de estado OV es "1". El bit de estado OV se activa
si, p. ej., el resultado de un cálculo está fuera del rango permitido o si al comparar números en
coma flotante hay un valor no válido.
Si el bit de estado OV es "0", el salto no se ejecuta y la ejecución del programa continúa con
la instrucción siguiente.

Programación del PLC
Manual de programación y manejo, 11/2019

1697

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si OV = 1":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar valor

L "Tag_Value_2"

// Cargar valor

*I

// Multiplicar valores

JO OVER

// Si el estado lógico del bit de estado OV es "1",
saltar a la etiqueta "OVER" y continuar allí la ejecución del programa.
// Si el estado lógico del bit de estado OV es "0",
procesar la instrucción siguiente.

T "Tag_Result"

// Transferir el resultado de la multiplicación al
operando "Tag_Result".

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar allí con la
ejecución del programa.

OVER: SET

// Continuar la ejecución del programa en este punto
si se cumple la condición (OV = "1").
// Poner el RLO al estado lógico "1".

R "Tag_Output"

// Poner el operando "Tag_Output" a "0".

NEXT: A "MyTag_1"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_1" es "1" y combinar el resultado lógicamente con Y.

A "MyTag_2"

// Consultar si el operando "MyTag_2" es "1" y combinar el resultado lógicamente con Y.

S "Tag_Output_2"

// Si el RLO = 1, poner el operando "Tag_Output_2" a
"1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

1698

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

JOS: Saltar si OS = 1
Descripción
La instrucción "Saltar si OS = 1" interrumpe la ejecución lineal del programa en función del bit
de estado OS y la continúa en el punto marcado por la etiqueta indicada.
El salto a la etiqueta se ejecuta solo si el bit de estado OS es "1". El bit de estado OS se activa
siempre que un desbordamiento del rango numérico pone el bit de estado OV a "1". Al contrario
que el bit de estado OV, el bit OS se mantiene activado aunque posteriormente haya un
resultado que esté dentro del rango numérico permitido.
Si el bit de estado OS es "0", el salto no se ejecuta y la ejecución del programa continúa con
la instrucción siguiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si OS = 1":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar valor

L "Tag_Value_2"

// Cargar valor

*I

// Multiplicar valores cargados.
// Guardar el producto en el acumulador 1.

L "Tag_Value_3"

// Cargar valor

+I

// Sumar el valor cargado al producto.
// Guardar el producto en el acumulador 1.

L "Tag_Value_4"

// Cargar valor

-I

// Restar el valor cargado de la suma calculada.
// Guardar el producto en el acumulador 1.

JOS OVER

// En caso de desbordamiento en una de las tres instrucciones precedentes, el bit de estado OS se pone a
"1".
// Si el estado lógico del bit de estado OS es "1" la
ejecución del programa continúa en la posición de la
etiqueta "OVER".
// Si el estado lógico del bit de estado OS es "0",
procesar la instrucción siguiente.

T "Tag_Result"

// Transferir el resultado de todo el cálculo al operando "Tag_Result".

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar allí con la
ejecución del programa.

Programación del PLC
Manual de programación y manejo, 11/2019

1699

Instrucciones
4.1 Instrucciones
AWL

Explicación

OVER: SET

// Continuar la ejecución del programa en este punto
si se cumple la condición (OV = "1").
// Poner el RLO al estado lógico "1".

R "Tag_Output"

// Poner el operando "Tag_Output" a "0".

NEXT: A "MyTag_1"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_1" es "1" y combinar el resultado lógicamente con Y.

A "MyTag_2"

// Consultar si el operando "MyTag_2" es "1" y combinar el resultado lógicamente con Y.

S "Tag_Output_2"

// Si el RLO = 1, poner el operando "Tag_Output_2" a
"1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

JZ: Saltar si el resultado es cero
Descripción
La instrucción "Saltar si el resultado es cero" interrumpe la ejecución lineal del programa en
función de los bits de estado CC 0 y CC 1 y continuarla en el punto marcado por la etiqueta
indicada.
El salto a la etiqueta indicada se ejecuta solo si el estado lógico de los bits de estado CC 0 y
CC 1 es "0". Esto sucede cuando se cumple una de las condiciones siguientes:
● Después de ejecutar una instrucción aritmética sin desbordamiento, el acumulador 1 tiene
el valor "0".
● Al ejecutar la instrucción "Sumar enteros (16 bits)" (+I) o "Sumar enteros dobles (32 bits)"
(+D) se produce un desbordamiento en el rango negativo.
● Al ejecutar una instrucción aritmética (aritmética de punto flotante) con desbordamiento se
produce un rebasamiento inferior gradual del rango permitido.
● El contenido del acumulador 2 es igual al contenido del acumulador 1 después de ejecutar
una instrucción de comparación.
● El contenido del acumulador 1 es cero después de ejecutar una operación lógica con
palabras.
● Tras ejecutar una instrucción de desplazamiento, el valor del último bit desplazado es "0".

1700

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En los restantes casos, el salto no se ejecuta y la ejecución del programa continúa con la
instrucción siguiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si el resultado es cero":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value"

// Cargar el valor del operando "Tag_Value".

SRW 1

// Desplazar el contenido de la palabra derecha del
acumulador 1 una posición a la derecha.

JZ ZERO

// Si el estado lógico del último bit desplazado hacia
fuera es "0", saltar a la etiqueta "OVER" y continuar
allí el procesamiento del programa
// Si el estado lógico del último bit desplazado hacia
fuera es "1", procesar la instrucción siguiente.

L "MyTag_1"

// Cargar el valor del operando "MyTag_1" en el acumulador 1.

INC 1

// Sumar el valor "1" al byte derecho del acumulador 1.

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar allí con la
ejecución del programa.

ZERO: L "MyTag_2"

// Etiqueta "ZERO"
// Cargar el valor del operando "MyTag_2" en el acumulador 1.

INC 1

// Sumar el valor "1" al byte derecho del acumulador 1.

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado lógicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado lógicamente con Y.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)

Programación del PLC
Manual de programación y manejo, 11/2019

1701

Instrucciones
4.1 Instrucciones
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

JN: Saltar si el resultado no es cero
Descripción
La instrucción "Saltar si el resultado no es cero" interrumpe la ejecución lineal del programa en
función de los bits de estado CC 0 y CC 1 y la continúa en el punto marcado por la etiqueta
indicada.
El salto a la etiqueta indicada se ejecuta solo si el estado lógico de los bits de estado CC 0 y
CC 1 es distinto. Esto sucede cuando se cumple una de las condiciones siguientes:
● Después de ejecutar una instrucción aritmética sin desbordamiento, el valor del
acumulador 1 es distinto de cero.
● Al ejecutar una instrucción aritmética con enteros (+I, -I, *I, +D, -D, *D) se produce un
desbordamiento en el rango negativo.
● Al ejecutar una instrucción aritmética con enteros (+I, -I, *I, /I, +D, -D, *D, /D, NEGI, NEGD)
se produce un desbordamiento en el rango positivo.
● Al ejecutar una instrucción aritmética con números en coma flotante se produce un
desbordamiento en el rango positivo o negativo.
● El contenido del acumulador 2 es distinto al contenido del acumulador 1 después de
ejecutar una instrucción de comparación.
● El contenido del acumulador 1 no es cero después de ejecutar una operación lógica con
palabras.
● Tras ejecutar una instrucción de desplazamiento, el valor del último bit desplazado es "1".
En los restantes casos, el salto no se ejecuta y la ejecución del programa continúa con la
instrucción siguiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si el resultado no es cero":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1702

AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Valu_1".

L "Tag_Value_2"

// Cargar el valor del operando "Tag_Value_2".

XOW

// Combinar lógicamente con O-exclusiva

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

JN NOZERO

// Cuando el valor del acumulador 1 no es cero, se
salta a la etiqueta "NOZERO" donde se continúa ejecutando el programa.
// Cuando el valor en el acumulador 1 es igual a cero
se ejecuta la siguiente instrucción.

AN "MyTag_1"

// Consultar si el operando "MyTag_1" es "0" y combinar el resultado lógicamente con Y.

S "Tag_Output_1"

// Si el RLO = "1", poner el operando "Tag_Output_1" a
"1"

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar allí con la
ejecución del programa.

NOZERO: AN "MyTag_2"

// Etiqueta "NOZERO"
// Consultar si el operando "MyTag_2" es "0" y combinar el resultado lógicamente con Y.

S "Tag_Output_2"

// Si el RLO es "1", poner el operando "Tag_Output_2"
a "1".

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado lógicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado lógicamente con Y.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

JP: Saltar si el resultado es mayor que cero
Descripción
La instrucción "Saltar si el resultado es mayor que cero" interrumpe la ejecución lineal del
programa en función de los bits de estado CC 0 y CC 1 y la continúa en el punto marcado por
la etiqueta indicada.

Programación del PLC
Manual de programación y manejo, 11/2019

1703

Instrucciones
4.1 Instrucciones
El salto a la etiqueta indicada se ejecuta solo si el estado lógico del bit de estado CC 0 es "0"
y el del bit de estado CC 1 es "1". Esto sucede cuando se cumple una de las condiciones
siguientes:
● Después de ejecutar una instrucción aritmética sin desbordamiento, el valor del
acumulador 1 es mayor que cero.
● Al ejecutar una instrucción aritmética con enteros (+I, -I, +D, -D) se produce un
desbordamiento en el rango negativo.
● Al ejecutar una instrucción aritmética con enteros (*I, /I, *D, /D) se produce un
desbordamiento en el rango positivo.
● Al ejecutar una instrucción aritmética con números en coma flotante se produce un
desbordamiento en el rango positivo.
● Tras ejecutar una instrucción de comparación, el contenido del acumulador 2 es mayor que
el contenido del acumulador 1.
● Tras ejecutar una operación lógica con palabras, el contenido del acumulador 1 no es cero.
● Tras ejecutar una instrucción de desplazamiento, el valor del último bit desplazado es "1".
En los restantes casos, el salto no se ejecuta y la ejecución del programa continúa con la
instrucción siguiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si el resultado es mayor que
cero":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1".

L "Tag_Value_2"

// Cargar el valor del operando "Tag_Value_2".

-I

// Restar el valor del operando "Tag_Value_2" del valor del operando "Tag_Value_1".

JP POSITIVE

// Si el valor del resultado en el acumulador 1 es positivo, saltar a la etiqueta "POSITIVE" y continuar
allí el procesamiento del programa
// Si el valor del resultado en el acumulador 1 es negativo, procesar la instrucción siguiente.

1704

AN "MyTag_1"

// Consultar si el operando "MyTag_1" es "0" y combinar el resultado lógicamente con Y.

S "Tag_Output_1"

// Si el RLO = "1", poner el operando "Tag_Output_1" a
"1"

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar allí con la
ejecución del programa.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

POSITIVE: AN "MyTag_2"

// Etiqueta "POSITIVE"
// Consultar si el operando "MyTag_2" es "0" y combinar el resultado lógicamente con Y.

S "Tag_Output_2"

// Si el RLO = "1", poner el operando "Tag_Output_2" a
"1"

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado lógicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado lógicamente con Y.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

JM: Saltar si el resultado es menor que cero
Descripción
La instrucción "Saltar si el resultado es menor que cero" interrumpe la ejecución lineal del
programa en función de los bits de estado CC 0 y CC 1 y la continúa en el punto marcado por
la etiqueta indicada.
El salto a la etiqueta indicada se ejecuta solo si el estado lógico del bit de estado CC 0 es "1"
y el del bit de estado CC 1 es "0". Esto sucede cuando se cumple una de las condiciones
siguientes:
● Después de ejecutar una instrucción aritmética sin desbordamiento, el valor del
acumulador 1 es menor que cero.
● Al ejecutar una instrucción aritmética con enteros (*I, *D) se produce un desbordamiento en
el rango negativo.
● Al ejecutar una instrucción aritmética con enteros (+I, -I, +D, -D, NEGI, NEGD) se produce
un desbordamiento en el rango positivo.
● Al ejecutar una instrucción aritmética con números en coma flotante se produce un
desbordamiento en el rango negativo.
● Tras ejecutar una instrucción de comparación, el contenido del acumulador 2 es menor que
el contenido del acumulador 1.
En los restantes casos, el salto no se ejecuta y la ejecución del programa continúa con la
instrucción siguiente.

Programación del PLC
Manual de programación y manejo, 11/2019

1705

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si el resultado es menor que
cero":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1".

L "Tag_Value_2"

// Cargar el valor del operando "Tag_Value_2".

-I

// Restar el valor del operando "Tag_Value_2" del valor del operando "Tag_Value_1".

JM NEGATIVE

// Si el valor del resultado en el acumulador 1 es negativo, saltar a la etiqueta "NEGATIVE" y continuar
allí el procesamiento del programa
// Si el valor del resultado en el acumulador 1 es positivo, procesar la instrucción siguiente.

AN "MyTag_1"

// Consultar si el operando "MyTag_1" es "0" y combinar el resultado lógicamente con Y.

S "Tag_Output_1"

// Si el RLO = "1", poner el operando "Tag_Output_1" a
"1"

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar allí con la
ejecución del programa.

NEGATIVE: AN "MyTag_2"

// Etiqueta "NEGATIVE"
// Consultar si el operando "MyTag_2" es "0" y combinar el resultado lógicamente con Y.

S "Tag_Output_2"

// Si el RLO = "1", poner el operando "Tag_Output_2" a
"1"

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado lógicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado lógicamente con Y.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

1706

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

JPZ: Saltar si el resultado es mayor o igual a cero
Descripción
La instrucción "Saltar si el resultado es mayor o igual a cero" interrumpe la ejecución lineal del
programa en función del bit de estado CC 0 y la continúa en el punto marcado por la etiqueta
indicada.
El salto a la etiqueta indicada se ejecuta solo si el estado lógico del bit de estado CC 0 es "0".
Esto sucede cuando se cumple una de las condiciones siguientes:
● Después de ejecutar una instrucción aritmética sin desbordamiento, el valor del
acumulador 1 es mayor o igual que cero.
● Al ejecutar una instrucción aritmética con enteros (+I, -I, +D, -D) se produce un
desbordamiento en el rango negativo.
● Al ejecutar una instrucción aritmética con enteros (*I, /I, *D, /D) se produce un
desbordamiento en el rango positivo.
● Al ejecutar una instrucción aritmética con números en coma flotante se produce un
desbordamiento en el rango positivo.
● Al ejecutar una instrucción aritmética (aritmética de punto flotante) con desbordamiento se
produce un rebasamiento inferior gradual del rango permitido.
● Tras ejecutar una instrucción de comparación, el contenido del acumulador 2 es mayor o
igual al contenido del acumulador 1.
● Se ha ejecutado una instrucción de operación lógica por palabras.
● Se ha ejecutado una instrucción de desplazamiento.
En los restantes casos, el salto no se ejecuta y la ejecución del programa continúa con la
instrucción siguiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si el resultado es mayor o
igual a cero":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1".

L "Tag_Value_2"

// Cargar el valor del operando "Tag_Value_2".

-I

// Restar el valor del operando "Tag_Value_2" del valor del operando "Tag_Value_1".

Programación del PLC
Manual de programación y manejo, 11/2019

1707

Instrucciones
4.1 Instrucciones
AWL

Explicación

JPZ REGULAR

// Si el valor del resultado en el acumulador 1 es positivo, saltar a la etiqueta "REGULAR" y continuar
allí el procesamiento del programa
// Si el valor del resultado en el acumulador 1 es negativo, procesar la instrucción siguiente.

AN "MyTag_1"

// Consultar si el operando "MyTag_1" es "0" y combinar el resultado lógicamente con Y.

S "Tag_Output_1"

// Si el RLO = "1", poner el operando "Tag_Output_1" a
"1"

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar allí con la
ejecución del programa.

REGULAR: AN "MyTag_2"

// Etiqueta "REGULAR"
// Consultar si el operando "MyTag_2" es "0" y combinar el resultado lógicamente con Y.

S "Tag_Output_2"

// Si el RLO ="1", poner el operando "Tag_Output_2" a
"1"

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado lógicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado lógicamente con Y.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

JMZ: Saltar si el resultado es menor o igual a cero
Descripción
La instrucción "Saltar si el resultado es menor o igual a cero" interrumpe la ejecución lineal del
programa en función del bit de estado CC 1 y la continúa en el punto marcado por la etiqueta
indicada.
El salto a la etiqueta indicada se ejecuta solo si el estado lógico del bit de estado CC 1 es "0".
Esto sucede cuando se cumple una de las condiciones siguientes:
● Después de ejecutar una instrucción aritmética sin desbordamiento, el valor del
acumulador 1 es menor o igual que cero.
● Al ejecutar una instrucción aritmética con enteros (+I, *I, +D, *D) se produce un
desbordamiento en el rango negativo.

1708

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● Al ejecutar una instrucción aritmética con enteros (+I, -I, +D, -D, NEGI, NEGD) se produce
un desbordamiento en el rango positivo.
● Al ejecutar una instrucción aritmética con números en coma flotante se produce un
desbordamiento en el rango negativo.
● Al ejecutar una instrucción aritmética (aritmética de punto flotante) con desbordamiento se
produce un rebasamiento inferior gradual del rango permitido.
● Tras ejecutar una instrucción de comparación, el contenido del acumulador 2 es menor o
igual al contenido del acumulador 1.
● Tras ejecutar una operación lógica con palabras, el valor del acumulador 1 es cero.
● Tras ejecutar una instrucción de desplazamiento, el valor del último bit desplazado es cero.
En los restantes casos, el salto no se ejecuta y la ejecución del programa continúa con la
instrucción siguiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si el resultado es menor o
igual a cero":
Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1".

L "Tag_Value_2"

// Cargar el valor del operando "Tag_Value_2".

-I

// Restar el valor del operando "Tag_Value_2" del valor del operando "Tag_Value_1".

JMZ MyLABEL

// Si el valor del resultado en el acumulador 1 es negativo, saltar a la etiqueta "MyLABEL" y continuar
allí el procesamiento del programa
// Si el valor del resultado en el acumulador 1 es positivo, procesar la instrucción siguiente.

AN "MyTag_1"

// Consultar si el operando "MyTag_1" es "0" y combinar el resultado lógicamente con Y.

S "Tag_Output_1"

// Si el RLO = "1", poner el operando "Tag_Output_1" a
"1"

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar allí con la
ejecución del programa.

MyLABEL: AN "MyTag_2"

// Etiqueta "MyLABEL"
// Consultar si el operando "MyTag_2" es "0" y combinar el resultado lógicamente con Y.

S "Tag_Output_2"

Programación del PLC
Manual de programación y manejo, 11/2019

// Si RLO="1", poner el operando "Tag_Output_2" a "1"

1709

Instrucciones
4.1 Instrucciones
AWL

Explicación

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado lógicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado lógicamente con Y.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

JUO: Saltar si el resultado no es válido
Descripción
La instrucción "Saltar si el resultado no es válido" interrumpe la ejecución lineal del programa
en función de los bits de estado CC 0 y CC 1 y la continúa en el punto marcado por la etiqueta
indicada.
El salto a la etiqueta indicada se ejecuta solo si el estado lógico de los bits de estado CC 0 y
CC 1 es "1". Esto sucede cuando se cumple una de las condiciones siguientes:
● En una instrucción matemática (/I, /D, MOD) se divide entre cero.
● En la ejecución de una instrucción matemática con números en coma flotante se produce
un desbordamiento y el resultado es un número en coma flotante no válido.
● En la ejecución de una instrucción de comparación con números en coma flotante se ha
empleado un número en coma flotante no válido o ha dado como resultado.
En los restantes casos, el salto no se ejecuta y la ejecución del programa continúa con la
instrucción siguiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Saltar si el resultado no es válido":

1710

Parámetro

Descripción

<Etiqueta>

Nombre simbólico del destino del salto

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1".

L "Tag_Value_2"

// Cargar el valor del operando "Tag_Value_2".

/I

// Dividir el valor del operando "Tag_Value_1" por el
valor del operando "Tag_Value_2".

JUO ERROR

// En una división por cero, saltar a la etiqueta
"ERROR" y continuar allí el procesamiento del programa
// En otro caso, procesar la instrucción siguiente.

T "Tag_Result"

// Transferir el contenido del acumulador 1 al operando "Tag_Result".

A "MyTag_1"

// Consultar si el operando "MyTag_1" es "1" y combinar el resultado lógicamente con Y.

R "MyTag_1"

// Si el RLO = "1", poner el operando "MyTag_1" a "0".

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar allí con la
ejecución del programa.

ERROR: AN "MyTag_1"

// Etiqueta "ERROR"
// Consultar si el operando "MyTag_1" es "0" y combinar el resultado lógicamente con Y.

S "MyTag_1"

// Si el RLO = "1", poner el operando "MyTag_1" a "1"

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado lógicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado lógicamente con Y.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Programación del PLC
Manual de programación y manejo, 11/2019

1711

Instrucciones
4.1 Instrucciones

JL: Definir lista de saltos
Descripción
La instrucción "Definir lista de saltos" permite programar una lista compuesta por varias
entradas de la instrucción "Salto incondicional" (JU). La lista empieza inmediatamente
después de la instrucción "Definir lista de saltos" y puede contener un máximo de 255
entradas. La numeración de las funciones de salto de la lista empieza por cero. La lista de
saltos debe programarse sin huecos. El final de la lista de saltos se marca con una etiqueta que
se indica en la instrucción "Definir lista de saltos".
La función de salto de la lista que se ejecutará depende del valor del byte derecho del
acumulador 1. Si, p. ej., en el acumulador 1 hay el valor "0", se ejecutará la primera función de
salto. Si el valor del acumulador 1 es "1", se ejecutará la segunda función de salto. Si el valor
del acumulador "1" es mayor que el número de entradas de la lista, la instrucción "Definir lista
de saltos" remite al final de la lista.
La instrucción "Distribuidor de saltos" se ejecuta independientemente de las condiciones y no
influye en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value"

// Cargar el número de salto en el acumulador 1.

JL END

// Principio de la lista de saltos

JU MyLABEL_1

// Si el valor del acumulador 1 es "0", ejecutar y
saltar a la etiqueta "MyLABEL_1".

JU MyLABEL_2

// Si el valor del acumulador 1 es "1", ejecutar y
saltar a la etiqueta "MyLABEL_2".

JU MyLABEL_3

// Ejecutar con un valor "2" en el acumulador 1 y saltar a la etiqueta "MyLABEL_3".

END: L "MyTag_1"

// Fin de la lista de saltos
// Cargar el contenido del operando "MyTag_1" en el
acumulador 1.

1712

L "MyTag_2"

// Cargar el contenido del operando "MyTag_2" en el
acumulador 1.

+I

// Sumar valores

T "Tag_Output_2"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output_2".

MyLABEL_1: ...

// Etiqueta "MyLABEL_1"

....

// Cualquier programa

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar allí con la
ejecución del programa.

MyLABEL_2: ...

// Etiqueta "MyLABEL_2"

....

// Cualquier programa

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar allí con la
ejecución del programa.

MyLABEL_3: ...

// Etiqueta "MyLABEL_3"

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

....

// Cualquier programa

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar allí con la
ejecución del programa.

NEXT: ...

// Etiqueta "NEXT"

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)
Ejemplos de programación AWL (Página 8102)

LOOP: Bucle
Descripción
La instrucción "Bucle" permite programar bucles.
La instrucción interpreta la palabra derecha del acumulador 1 como un entero de 16 bits sin
signo en el rango de 0 a 65535. Al ejecutarse, la instrucción reduce primero en uno el contenido
del acumulador 1. Si el valor del acumulador 1 no es cero después de decrementar, se ejecuta
el salto hasta la etiqueta indicada. Si el valor es cero, el salto no se ejecuta y la ejecución del
programa continúa con la instrucción siguiente. Por consiguiente, el valor del acumulador 1
determina el número de bucles que se ejecutarán. Dicho número debe guardarse en un
contador de bucles.
El operando <Número> contiene el número de bucles ejecutados. El operando <Contador de
bucles> contiene el número de bucles pendientes de ser ejecutados. Al final del bucle, el
contenido del contador de bucles se carga en el acumulador 1 y es decrementado en uno por
la instrucción. El salto hasta la etiqueta al principio del bucle se ejecuta si el valor del
acumulador no es cero después de decrementar.
La instrucción "Bucle" no influye en los bits de estado.
ADVERTENCIA
Asignación inicial del contador de bucles
Si al contador de bucles no se le ha asignado ningún valor inicial o se le ha asignado el valor
inicial "0", se va reduciendo hacia el negativo, lo que resulta en un bucle sin fin que puede
provocar el estado operativo STOP de la CPU.

Programación del PLC
Manual de programación y manejo, 11/2019

1713

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value"

// Cargar el número de ejecuciones de bucle pendientes
en la palabra derecha del acumulador 1.

START: T "Tag_Counter"

// Principio de la lista de saltos
// Transferir el contenido del acumulador 1 al contador de bucles.

L "MyTag_1"

// Cargar el valor del operando "MyTag_1".

L "MyTag_2"

// Cargar el valor del operando "MyTag_2".

*D

// Multiplicar valores

T "MyTag_1"

// Transferir el resultado de la multiplicación al
operando "MyTag_1".

L "Tag_Counter"

// Cargar el contenido del contador de bucles en el
acumulador 1.

LOOP START

// Decrementar en uno el valor del acumulador 1.
// Si el valor es distinto de cero, saltar al principio del bucle.
// Si el valor es cero, procesar la instrucción siguiente.

L "MyTag_2"

// Cargar el valor del operando "MyTag_2".

L 100

// Cargar el valor 100.

>I

// Comparar si el valor del operando "MyTag_2" es mayor que 200.

= "MyTag_3"

// Escribir el resultado de la comparación en el operando "MyTag_3".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

1714

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Bloques de datos
OPN: Abrir bloque de datos en el registro DB
Descripción
La instrucción "Abrir bloque de datos en el registro DB" permite abrir un bloque de datos global
(DB). El número del bloque de datos se transmite al registro del DB. Los siguientes comandos
de DB acceden a los bloques correspondientes en función de los contenidos del registro.
La instrucción "Abrir bloque de datos en el registro DB" se ejecuta independientemente de las
condiciones y no influye en el resultado lógico ni en los contenidos de los acumuladores.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Abrir bloque de datos en el registro
DB":
Operando

Declaración

Tipo del bloque de
datos

Descripción

<Bloque de
datos>

-

DB

Bloque de datos que se abrirá.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

OPN "GlobalDataBlock"

// Abrir bloque de datos y transferir número
del bloque al registro DB.

L %DBW0

// Cargar palabra de datos DBW0 del bloque de
datos global abierto en acumulador 1.

T "MyTag"

// Transferir el contenido del acumulador 1 al
operando "MyTag_1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

Programación del PLC
Manual de programación y manejo, 11/2019

1715

Instrucciones
4.1 Instrucciones

OPNDI: Abrir bloque de datos en el registro DI
Descripción
La instrucción "Abrir bloque de datos en el registro DI" permite abrir un bloque de datos
cualquiera. El número del bloque de datos se transmite al registro del DI. Los siguientes
comandos del DI acceden a los bloques correspondientes en función de los contenidos del
registro.
Para el direccionamiento simbólico de un parámetro formal local de la interfaz de bloque,
acceda siempre al bloque de datos cuyo número haya indicado al efectuar la llamada de
bloque.
La instrucción "Abrir bloque de datos en el registro DI" se ejecuta independientemente de las
condiciones y no influye en el resultado lógico ni en los contenidos de los acumuladores.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Abrir bloque de datos en el registro
DI":
Operando

Declaración

Tipo del bloque de
datos

Descripción

<Bloque de
datos>

-

DI

Bloque de datos que se abrirá.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

OPNDI "DataBlock"

// Abrir bloque de datos y transferir número
del bloque de datos al registro DI.

L %DIW0

// Cargar palabra de datos DIW0 del bloque de
datos abierto en acumulador 1.

T "MyTag"

// Transferir el contenido del acumulador 1 al
operando "MyTag".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

1716

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CDB: Intercambiar registros de bloques de datos
Descripción
La instrucción "Intercambiar registros de bloques de datos" cambia los contenidos de los
registros de los bloques de datos. La instrucción se ejecuta independientemente de las
condiciones y no influye en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

OPN "GlobalDataBlock"

// Abrir bloque de datos global y transferir
número del bloque de datos al registro DB.

OPNDI "DataBlock"

// Abrir bloque de datos y transferir número
del bloque de datos al registro DI.

CDB

// Intercambiar registros de bloques de datos
// El registro DB remite a "DataBlock" y el
registro DI remite a "GlobalDataBlock".

L %DIW0

// Cargar DW0 de "GlobalDataBlock" en el acumulador 1.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

L DBLG: Cargar longitud de un bloque de datos global en acumulador 1
Descripción
La instrucción "Cargar longitud del bloque de datos global en acumulador 1" carga en el
acumulador 1 la longitud de un bloque de datos global abierto mediante el registro del bloque
de datos. El contenido anterior del acumulador 1 se desplaza al acumulador 2.
Si antes de ejecutar la instrucción no se ha abierto ningún bloque de datos global mediante el
registro del bloque de datos, se carga el valor "0" en el acumulador 1. La longitud del bloque
de datos es equivalente al número de bytes de datos.
La instrucción no modifica los bits de estado.

Programación del PLC
Manual de programación y manejo, 11/2019

1717

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

OPN "GlobalDataBlock"

// Abrir bloque de datos global y transferir
número del bloque de datos al registro DB.

L DBLG

// Cargar la longitud de un bloque de datos
abierto en el acumulador 1.

L "MyTag_1"

// Cargar el valor de comparación

<D

// Comparar si la longitud del bloque de datos
es menor que el valor del operando "MyTag_1".

= "MyTag_2"

// Escribir el resultado de la consulta en el
operando "MyTag_2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

L DBNO: Cargar número de un bloque de datos global en acumulador 1
Descripción
La instrucción "Cargar número del bloque de datos global en acumulador 1" carga en el
acumulador 1 el número de un bloque de datos global abierto mediante el registro del bloque
de datos. El contenido anterior del acumulador 1 se desplaza al acumulador 2.
Si antes de ejecutar la instrucción no se ha abierto ningún bloque de datos global mediante el
registro del bloque de datos, se carga el valor "0" en el acumulador 1.
La instrucción no modifica los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1718

AWL

Explicación

OPN "GlobalDataBlock"

// Abrir bloque de datos global y transferir
número del bloque de datos al registro DB.

L DBNO

// Cargar número de un bloque de datos abierto
en acumulador 1.

L "MyTag_1"

// Cargar el valor de comparación

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

==I

// Comparar si el número del bloque de datos
es igual al valor del operando "MyTag_1".

= "MyTag_2"

// Escribir el resultado de la consulta en el
operando "MyTag_2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

L DILG: Cargar longitud de un bloque de datos de instancia en acumulador 1
Descripción
La instrucción "Cargar longitud del bloque de datos de instancia en acumulador 1" carga en el
acumulador 1 la longitud de un bloque de datos de instancia abierto mediante el registro del
bloque de datos. El contenido anterior del acumulador 1 se desplaza al acumulador 2.
Si antes de ejecutar la instrucción no se ha abierto ningún bloque de datos de instancia
mediante el registro del bloque de datos, se carga el valor "0" en el acumulador 1. La longitud
del bloque de datos es equivalente al número de bytes de datos.
La instrucción no modifica los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

OPNDI "InstanceDataBlock"

// Abrir bloque de datos y transferir número
del bloque de datos al registro DI.

L DILG

// Cargar la longitud de un bloque de datos
abierto en el acumulador 1.

L "MyTag_1"

// Cargar el valor de comparación

<I

// Comparar si la longitud del bloque de datos
es menor que el valor del operando "MyTag_1".

= "MyTag_2"

// Escribir el resultado de la consulta en el
operando "MyTag_2".

Programación del PLC
Manual de programación y manejo, 11/2019

1719

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

L DINO: Cargar número de un bloque de datos de instancia en acumulador 1
Descripción
La instrucción "Cargar número del bloque de datos de instancia en acumulador 1" carga en el
acumulador 1 el número de un bloque de datos de instancia abierto mediante el registro del
bloque de datos. El contenido anterior del acumulador 1 se desplaza al acumulador 2.
Si antes de ejecutar la instrucción no se ha abierto ningún bloque de datos de instancia
mediante el registro del bloque de datos, se carga el valor "0" en el acumulador 1.
La instrucción no modifica los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

OPNDI "InstanceDataBlock"

// Abrir bloque de datos y transferir número
del bloque de datos al registro DI.

L DINO

// Cargar número de un bloque de datos abierto
en acumulador 1.

L "MyTag_1"

// Cargar el valor de comparación

==I

// Comparar si el número del bloque de datos
es igual al valor del operando "MyTag_1".

= "MyTag_2"

// Asignar el resultado de la consulta al operando "MyTag_2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

1720

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Bloques lógicos
BE: Fin de bloque
Descripción
La instrucción "Fin de bloque" finaliza el procesamiento del bloque actual y pasa al punto del
programa en el que se llama el bloque. El procesamiento del programa continúa con la
instrucción que se encuentra justo después de la llamada del bloque.
La instrucción "Fin de bloque" se ejecuta siempre, independientemente de las condiciones. Si
el procesamiento de la instrucción se salta debido a una instrucción de salto, la ejecución
actual del programa no finaliza, sino que continúa en el destino del salto dentro del bloque.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

SIN

// Calcular el seno
// Guardar el resultado en el acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

*R

// Multiplicar los valores de los acumuladores 1 y 2.
// Guardar el producto en el acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en el
acumulador 1.

*R

// Multiplicar los valores de los acumuladores 1 y 2.
// Guardar el producto en el acumulador 1.

T "Tag_Result"

// Transferir el contenido del acumulador 1 al operando "Tag_Result".

BE

// Finalizar bloque

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)

Programación del PLC
Manual de programación y manejo, 11/2019

1721

Instrucciones
4.1 Instrucciones
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

BEC: Fin de bloque condicional
Descripción
La instrucción "Fin de bloque condicional" finaliza el procesamiento del bloque actual en
función del resultado lógico (RLO) y pasa al punto del programa en el que se llama el bloque.
Si el RLO es "1", se ejecuta la instrucción. El bloque actual se finaliza y la ejecución del
programa continúa en el bloque que efectúa la llamada. El procesamiento del programa
continúa con la instrucción que se encuentra justo después de la llamada del bloque.
Si el RLO es "0" al procesar la instrucción, esta no se ejecuta. En este caso, la CPU pone el
RLO a "1" y procesa la instrucción siguiente.
Si el procesamiento de la instrucción se salta debido a una instrucción de salto, la ejecución
actual del programa no finaliza, sino que continúa en el destino del salto dentro del bloque.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

>I

// Comparar si el valor del acumulador 2 es mayor que
el valor del acumulador 1.

A "Tag_Input"

// Consultar si el operando "Tag_Input" es "1" y combinar el resultado lógicamente con Y con el RLO.

BEC

// Si la condición se cumple (RLO = "1"), finalizar el
bloque.
// Si la condición no se cumple (RLO = "0"), procesar
la instrucción siguiente.

T "Tag_Result"

// Transferir el contenido del acumulador 1 al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)

1722

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

BEU: Fin de bloque incondicional
Descripción
La instrucción "Fin de bloque incondicional" finaliza el procesamiento del bloque actual y pasa
al punto del programa en el que se llama el bloque. El procesamiento del programa continúa
con la instrucción que se encuentra justo después de la llamada del bloque.
La instrucción "Fin de bloque incondicional" se ejecuta siempre, independientemente de las
condiciones, y se puede programar varias veces dentro de un bloque. Si el procesamiento de
la instrucción se salta debido a una instrucción de salto, la ejecución actual del programa no
finaliza, sino que continúa en el destino del salto dentro del bloque.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

>I

// Comparar si el valor del acumulador 2 es mayor que
el valor del acumulador 1.

A "Tag_Input"

// Consultar si el operando "Tag_Input" es "1" y combinar el resultado lógicamente con Y con el RLO.

JC NEXT

// Si la condición se cumple (RLO = "1"), continuar el
procesamiento del programa a partir de la etiqueta
"NEXT".
// Si la condición no se cumple (RLO = "0"), procesar
la instrucción siguiente.

BEU

// Finalizar bloque

NEXT: T "Tag_Result"

// Etiqueta "NEXT"
// Transferir el contenido del acumulador 1 al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)

Programación del PLC
Manual de programación y manejo, 11/2019

1723

Instrucciones
4.1 Instrucciones
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)
Ejemplos de programación AWL (Página 8102)

CALL: Llamar bloque
Descripción
La instrucción "Llamar bloque" llama los siguientes tipos de bloque en el programa:
● Funciones
● Bloques de función
La instrucción "Llamar bloque" se ejecuta siempre, independientemente de las condiciones.
Tras ejecutar la instrucción, el procesamiento del programa continúa en el bloque llamado.
Existe la posibilidad de suministrar datos a un bloque llamado. Los datos se transfieren
mediante los parámetros del bloque. Los parámetros del bloque llamado se listan en el bloque
que efectúa la llamada después de la instrucción de llamada. Es posible asignarles los
parámetros actuales necesarios. Al ejecutar la instrucción "Llamar bloque", los datos se
transfieren al bloque llamado. Con la transmisión de los datos se modifican los contenidos
tanto de la palabra de estado como del registro de direcciones y del de los bloques de datos.
Los parámetros de un bloque de función que no reciben valores nuevos conservan su valor
actual. Al llamar funciones deben suministrarse valores a todos los parámetros. Si un bloque
llamado no tiene parámetros, no se muestra la lista de parámetros.
Si el bloque llamado requiere un bloque de datos de instancia, éste debe indicarse en la
llamada, separado por una coma. El bloque de datos indicado debe haberse creado antes de
la llamada.
Una vez procesado el bloque llamado, la CPU vuelve al bloque que efectúa la llamada y
continúa con el procesamiento de dicho bloque después de la instrucción de llamada.
Nota
La instrucción "Llamar bloque" solo puede utilizarse si está activada la propiedad del bloque
"Alimentación de parámetros a través de registros".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL "MyFunction"

// Llamar la función "MyFunction"

Input_1 := "Tag_Input_1",

// Asignar parámetros actuales

Input_2 := "Tag_Input_2"
Output_1 := "Tag_Output_1"
Output_2 := "Tag_Output_1"

1724

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

CALL "MyFunctionBlock", "MyFB_DB"
Value_1 := "Tag_Value_1"

// Llamar el bloque de función "MyFunctionBlock"

Value_2 := "Tag_Value_2"

// Asignar parámetros actuales

Output := "Tag_Output"
CALL "LIMIT"
MN := "Tag_LowLimit"

// Llamar la instrucción "Ajustar valor límite"

IN := "Tag_InputValue"

// Asignar parámetros actuales

MX := "Tag_HighLimit"
OUT := "Tag_Output"
CALL "CTU", "CTU_DB"
CU := "Tag_StartCTU"

// Llamar el contador "Contador ascendente"
// Asignar parámetros actuales

R := "Tag_ResetCounter"
PV := "Tag_PresetValue"
Q := "Tag_CounterStatus"
CV := "Tag_CounterValue"

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

CC: Llamada condicional
Descripción
La instrucción "Llamada condicional" llama en función del resultado lógico (RLO) funciones
(FC) y bloques de función (FB) que no tienen parámetros ni bloques de datos de instancia.
La instrucción solo se ejecuta si el resultado lógico (RLO) actual antes de procesar la
instrucción es "1". Tras ejecutar la instrucción, el procesamiento del programa continúa en el
bloque llamado. Una vez procesado el bloque llamado, la CPU vuelve al bloque que efectúa la
llamada y continúa con el procesamiento de dicho bloque después de la instrucción de llamada.

Programación del PLC
Manual de programación y manejo, 11/2019

1725

Instrucciones
4.1 Instrucciones
Al cambiar el bloque, el bit de estado OS se pone a "0". Los bits de estado CC 0, CC 1 y OV
se ven influidos en función del bloque invocante.
Nota
La instrucción "Llamada condicional" solo puede utilizarse cuando está activada la propiedad
del bloque "Alimentación de parámetros a través de registros". Sin embargo, de este modo se
reduce el rendimiento.
La instrucción "Llamada condicional" no modifica el contenido de los acumuladores ni los
registros de direcciones.
Si el RLO actual es "0", la instrucción y, por consiguiente, la llamada de bloque no se ejecutan
y el RLO se pone a "1".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input_1"

// Consultar si el operando "Tag_Input_1" es
"1" y combinar el resultado lógicamente con Y
con el RLO actual.

CC "MyFunction"

// Si la condición se cumple (RLO = "1"), llamar la función "MyFunction".
// Si la condición no se cumple (RLO = "0"),
procesar la instrucción siguiente.

A "Tag_Input_2"

// Consultar si el operando "Tag_Input_2" es
"1" y combinar el resultado lógicamente con Y
con el RLO actual.

CC "MyFunctionBlock"

// Si la condición se cumple (RLO = "1"), llamar el bloque de función "MyFunctionBlock".
// Si la condición no se cumple (RLO = "0"),
procesar la instrucción siguiente.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Sinopsis de las propiedades de bloques (Página 7740)
Alimentación de parámetros a través de registros en la llamada de bloques en AWL
(Página 8067)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

1726

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

UC: Llamada incondicional
Descripción
La instrucción "Llamada incondicional" llama funciones (FC) y bloques de función (FB) que no
tienen parámetros ni bloques de datos de instancia.
Esta instrucción se ejecuta independientemente de las condiciones. Tras ejecutar la
instrucción, el procesamiento del programa continúa en el bloque llamado. Una vez procesado
el bloque llamado, la CPU vuelve al bloque que efectúa la llamada y continúa con el
procesamiento de dicho bloque después de la instrucción de llamada.
Al cambiar el bloque, el bit de estado OS se pone a "0". Los bits de estado CC 0, CC 1 y OV
se ven influidos en función del bloque invocante.
Nota
La instrucción "Llamada incondicional" solo puede utilizarse cuando está activada la propiedad
del bloque "Alimentación de parámetros a través de registros". Sin embargo, de este modo se
reduce el rendimiento.
La instrucción "Llamada incondicional" no modifica el contenido de los acumuladores ni los
registros de direcciones.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input_1"

// Consultar si el operando "Tag_Input_1" es
"1" y combinar el resultado lógicamente con Y
con el RLO actual.

UC "MyFunction"

// Llamar la función "MyFunction".

A "Tag_Input_2"

// Consultar si el operando "Tag_Input_2" es
"1" y combinar el resultado lógicamente con Y
con el RLO actual.

UC "MyFunctionBlock"

// Llamar el bloque de función "MyFunctionBlock".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Sinopsis de las propiedades de bloques (Página 7740)
Alimentación de parámetros a través de registros en la llamada de bloques en AWL
(Página 8067)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)

Programación del PLC
Manual de programación y manejo, 11/2019

1727

Instrucciones
4.1 Instrucciones
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Operaciones lógicas con palabras
AW: Operación lógica Y por palabras
Descripción
La instrucción "Operación lógica Y por palabras" combina lógicamente con Y por bits el valor
de la palabra derecha del acumulador 1 con el valor de la palabra derecha del acumulador 2
o una constante concreta. El resultado se guarda en la palabra derecha del acumulador 1. El
contenido de la palabra izquierda del acumulador 1 no cambia.
La instrucción combina el bit 0 del acumulador 1 con el bit 0 del acumulador 2 o una constante
y guarda el resultado en el bit 0 del acumulador 1. Los bits 1 a 15 se combinan del mismo modo.
El estado lógico del bit de resultado es "1" si el estado lógico de los dos bits que deben
combinarse lógicamente también es "1". Si el estado lógico de uno de los bits que deben
combinarse lógicamente es "0", se desactivará el bit de resultado correspondiente.
La tabla siguiente muestra cómo se forma el resultado en una operación lógica Y por palabras:
Acumulador 2 /
constante

0

0

1

1

Acumulador 1

0

1

0

1

Resultado

0

0

0

1

La instrucción se ejecuta independientemente de las condiciones y no influye en el resultado
lógico.
La instrucción influye en los bits de estado CC 0, CC 1 y OV.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica Y por palabras":
Parámetro

Tipo de datos Descripción

<Constante>

WORD

Valor que se combina lógicamente con Y con el valor que se encuentra
en la palabra derecha del acumulador 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1728

AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en la palabra derecha
del acumulador 1.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

AW W#16#F6B5

// Combinar lógicamente con Y el valor de la palabra
derecha del acumulador 1 con la constante (W#16#F6B5).
// El resultado se guarda en la palabra derecha del
acumulador 1.

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

L "Tag_Value_2"

// Cargar el valor del operando en la palabra derecha
del acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en la
palabra derecha del acumulador 1.

AW

// Combinar lógicamente con Y el valor de la palabra
derecha del acumulador 2 ("Tag_Value_2") con el valor
de la palabra derecha del acumulador 1 ("Tag_Value_3").
// El resultado se guarda en la palabra derecha del
acumulador 1.

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando
Tag_Value_1

Valor
0101

1001

0011

1011

Constante (W#16#F6B5) 1111

0110

1011

0101

Tag_Result_1

0000

0011

0001

0101

Tag_Value_2

0110

1100

0010

1010

Tag_Value_3

1101

1010

1001

0011

Tag_Result_2

0100

1000

0000

0010

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Activar el bit de estado en operaciones lógicas con palabras (Página 202)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)
Ejemplos de programación AWL (Página 8102)

Programación del PLC
Manual de programación y manejo, 11/2019

1729

Instrucciones
4.1 Instrucciones

OW: Operación lógica O por palabras
Descripción
La instrucción "Operación lógica O por palabras" combina lógicamente con O por bits el valor
de la palabra derecha del acumulador 1 con el valor de la palabra derecha del acumulador 2
o una constante concreta. El resultado se guarda en la palabra derecha del acumulador 1. El
contenido de la palabra izquierda del acumulador 1 no cambia.
La instrucción combina el bit 0 del acumulador 1 con el bit 0 del acumulador 2 o una constante
y guarda el resultado en el bit 0 del acumulador 1. Los bits 1 a 15 se combinan del mismo modo.
El estado lógico del bit de resultado es "1" si el estado lógico de como mínimo uno de los dos
bits que deben combinarse lógicamente también es "1". Si el estado lógico de los dos bits que
deben combinarse lógicamente es "0", el bit de resultado correspondiente se pondrá a "0".
La tabla siguiente muestra cómo se forma el resultado en una operación lógica O por palabras:
Acumulador 2 /
constante

0

0

1

1

Acumulador 1

0

1

0

1

Resultado

0

1

1

1

La instrucción se ejecuta independientemente de las condiciones y no influye en el resultado
lógico.
La instrucción influye en los bits de estado CC 0, CC 1 y OV.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica O por palabras":
Parámetro

Tipo de datos Descripción

<Constante>

WORD

Valor que se combina lógicamente con O con el valor que se encuentra
en la palabra derecha del acumulador 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en la palabra derecha
del acumulador 1.

OW W#16#F6B5

// Combinar lógicamente con O el valor de la palabra
derecha del acumulador 1 con la constante (W#16#F6B5).
// El resultado se guarda en la palabra derecha del
acumulador 1.

1730

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

L "Tag_Value_2"

// Cargar el valor del operando en la palabra derecha
del acumulador 1.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en la
palabra derecha del acumulador 1.

OW

// Combinar lógicamente con O el valor de la palabra
derecha del acumulador 2 ("Tag_Value_2") con el valor
de la palabra derecha del acumulador 1 ("Tag_Value_3").
// El resultado se guarda en la palabra derecha del
acumulador 1.

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando
Tag_Value_1

Valor
0101

1001

0011

1011

Constante (W#16#F6B5) 1111

0110

1011

0101

Tag_Result_1

1111

1111

1011

1111

Tag_Value_2

0110

1100

0010

1010

Tag_Value_3

1101

1010

1001

0011

Tag_Result_2

1111

1110

1011

1011

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Activar el bit de estado en operaciones lógicas con palabras (Página 202)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)
Ejemplos de programación AWL (Página 8102)

XOW: Operación lógica O-exclusiva por palabras
Descripción
La instrucción "Operación lógica O-exclusiva por palabras" combina lógicamente con Oexclusiva por bits el valor de la palabra derecha del acumulador 1 con el valor de la palabra
derecha del acumulador 2 o una constante concreta. El resultado se guarda en la palabra
derecha del acumulador 1. El contenido de la palabra izquierda del acumulador 1 no cambia.

Programación del PLC
Manual de programación y manejo, 11/2019

1731

Instrucciones
4.1 Instrucciones
La instrucción combina el bit 0 del acumulador 1 con el bit 0 del acumulador 2 o una constante
y guarda el resultado en el bit 0 del acumulador 1. Los bits 1 a 15 se combinan del mismo modo.
El estado lógico del bit de resultado es "1" si el estado lógico de los dos bits que deben
combinarse lógicamente es diferente. Si el estado lógico de los dos bits que deben combinarse
lógicamente es el mismo, el bit de resultado correspondiente se pondrá a "0".
La tabla siguiente muestra cómo se forma el resultado en una operación lógica O-exclusiva por
palabras:
Acumulador 2 /
constante

0

0

1

1

Acumulador 1

0

1

0

1

Resultado

0

1

1

0

La instrucción se ejecuta independientemente de las condiciones y no influye en el resultado
lógico.
La instrucción influye en los bits de estado CC 0, CC 1 y OV.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica O-exclusiva por
palabras":
Parámetro

Tipo de datos Descripción

<Constante>

WORD

Valor que se combina lógicamente con O-exclusiva con el valor que se
encuentra en la palabra derecha del acumulador 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en la palabra derecha
del acumulador 1.

XOW W#16#F6B5

// Combinar lógicamente con O-exclusiva el valor de la
palabra derecha del acumulador 1 con la constante
(W#16#F6B5).
// El resultado se guarda en la palabra derecha del
acumulador 1.

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

L "Tag_Value_2"

// Cargar el valor del operando en la palabra derecha
del acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en la
palabra derecha del acumulador 1.

1732

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

XOW

// Combinar lógicamente con O-exclusiva el valor de la
palabra derecha del acumulador 2 ("Tag_Value_2") con
el valor de la palabra derecha del acumulador 1
("Tag_Value_3").
// El resultado se guarda en la palabra derecha del
acumulador 1.

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando
Tag_Value_1

Valor
0101

1001

0011

1011

Constante (W#16#F6B5) 1111

0110

1011

0101

Tag_Result_1

1010

1111

1000

1110

Tag_Value_2

0110

1100

0010

1010

Tag_Value_3

1101

1010

1001

0011

Tag_Result_2

1011

0110

1011

1001

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Activar el bit de estado en operaciones lógicas con palabras (Página 202)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

AD: Operación lógica Y por palabras dobles
Descripción
La instrucción "Operación lógica Y por palabras dobles" combina lógicamente con Y por bits el
contenido del acumulador 1 con el contenido del acumulador 2 o el valor de una constante
concreta. El resultado se guarda en el acumulador 1.
La instrucción combina el bit 0 del acumulador 1 con el bit 0 del acumulador 2 o una constante
y guarda el resultado en el bit 0 del acumulador 1. Los bits 1 a 31 se combinan del mismo modo.
El estado lógico del bit de resultado es "1" si el estado lógico de los dos bits que deben
combinarse lógicamente también es "1". Si el estado lógico de uno de los bits que deben
combinarse lógicamente es "0", se desactivará el bit de resultado correspondiente.

Programación del PLC
Manual de programación y manejo, 11/2019

1733

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo se forma el resultado en una operación lógica Y por palabras:
Acumulador 2 /
constante

0

0

1

1

Acumulador 1

0

1

0

1

Resultado

0

0

0

1

La instrucción se ejecuta independientemente de las condiciones y no influye en el resultado
lógico.
La instrucción influye en los bits de estado CC 0, CC 1 y OV.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica Y por palabras
dobles":
Parámetro

Tipo de datos Descripción

<Constante>

DWORD

Valor que se combina lógicamente con Y con el valor que está en el
acumulador 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

AD DW#16#39C657AC

// Combinar lógicamente con Y el valor del acumulador
1 con la constante (DW#16#39C657AC).
// Guardar el resultado en el acumulador 1.

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

L "Tag_Value_2"

// Cargar el valor del operando en el acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en el
acumulador 1.

AD

// Combinar lógicamente con Y el valor del acumulador
2 ("Tag_Value_2") con el valor del acumulador 1
("Tag_Value_3").
// Guardar el resultado en el acumulador 1.

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

1734

Valor

Tag_Value_1 0101

1111

0110

0100

1001

1101

0011

1011

Constante
(DW#16#39
C657AC)

1001

1100

0110

0101

0111

1010

1100

0011

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Operando
Tag_Re‐
sult_1

Valor
0001

1001

0100

0100

0001

0101

0010

1000

Tag_Value_2 0110

0101

0100

0011

0101

1101

0010

1011

Tag_Value_3 0011

1001

1100

0110

0101

0111

1010

1100

Tag_Re‐
sult_2

0001

0100

0010

0101

0101

0010

1010

0010

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Activar el bit de estado en operaciones lógicas con palabras (Página 202)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

OD: Operación lógica O por palabras dobles
Descripción
La instrucción "Operación lógica O por palabras dobles" combina lógicamente con O por bits
el contenido del acumulador 1 con el contenido del acumulador 2 o el valor de una constante
concreta. El resultado se guarda en el acumulador 1.
La instrucción combina el bit 0 del acumulador 1 con el bit 0 del acumulador 2 o una constante
y guarda el resultado en el bit 0 del acumulador 1. Los bits 1 a 31 se combinan del mismo modo.
El estado lógico del bit de resultado es "1" si el estado lógico de como mínimo uno de los dos
bits que deben combinarse lógicamente también es "1". Si el estado lógico de los dos bits que
deben combinarse lógicamente es "0", el bit de resultado correspondiente se pondrá a "0".
La tabla siguiente muestra cómo se forma el resultado en una operación lógica O por palabras:
Acumulador 2 /
constante

0

0

1

1

Acumulador 1

0

1

0

1

Resultado

0

1

1

1

La instrucción se ejecuta independientemente de las condiciones y no influye en el resultado
lógico.
La instrucción influye en los bits de estado CC 0, CC 1 y OV.

Programación del PLC
Manual de programación y manejo, 11/2019

1735

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica O por palabras
dobles":
Parámetro

Tipo de datos Descripción

<Constante>

DWORD

Valor que se combina lógicamente con O con el valor que está en el
acumulador 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

OD DW#16#39C657AC

// Combinar lógicamente con O el valor del acumulador
1 con la constante (DW#16#39C657AC).
// Guardar el resultado en el acumulador 1.

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

L "Tag_Value_2"

// Cargar el valor del operando en el acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en el
acumulador 1.

OD

// Combinar lógicamente con O el valor del acumulador
2 ("Tag_Value_2") con el valor del acumulador 1
("Tag_Value_3").
// Guardar el resultado en el acumulador 1

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

1736

Valor

Tag_Value_1 0101

1111

0110

0100

1001

1101

0011

1011

Constante
(DW#16#39
C657AC)

0011

1001

1100

0110

0101

0111

1010

1100

Tag_Re‐
sult_1

0111

1111

1110

0110

1101

1111

1011

1111

Tag_Value_2 0110

0101

0100

0011

0101

1101

0010

1011

Tag_Value_3 0011

1001

1100

0110

0101

0111

1010

1100

Tag_Re‐
sult_2

1101

1100

0111

0101

1111

1110

1111

0111

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Activar el bit de estado en operaciones lógicas con palabras (Página 202)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

XOD: Operación lógica O-exclusiva por palabras dobles
Descripción
La instrucción "Operación lógica O-exclusiva por palabras dobles" combina lógicamente con
O-exclusiva por bits el contenido del acumulador 1 con el contenido del acumulador 2 o el valor
de una constante concreta. El resultado se guarda en el acumulador 1.
La instrucción combina el bit 0 del acumulador 1 con el bit 0 del acumulador 2 o una constante
y guarda el resultado en el bit 0 del acumulador 1. Los bits 1 a 31 se combinan del mismo modo.
El estado lógico del bit de resultado es "1" si el estado lógico de los dos bits que deben
combinarse lógicamente es diferente. Si el estado lógico de los dos bits que deben combinarse
lógicamente es el mismo, el bit de resultado correspondiente se pondrá a "0".
La tabla siguiente muestra cómo se forma el resultado en una operación lógica O-exclusiva por
palabras:
Acumulador 2 /
constante

0

0

1

1

Acumulador 1

0

1

0

1

Resultado

0

1

1

0

La instrucción se ejecuta independientemente de las condiciones y no influye en el resultado
lógico.
La instrucción influye en los bits de estado CC 0, CC 1 y OV.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica O-exclusiva por
palabras dobles":
Parámetro

Tipo de datos Descripción

<Constante>

DWORD

Programación del PLC
Manual de programación y manejo, 11/2019

Valor que se combina lógicamente con O-exclusiva con el valor que
está en el acumulador 1.

1737

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

XOD DW#16#39C657AC

// Combinar lógicamente con O-exclusiva el valor del
acumulador 1 con la constante (DW#16#39C657AC).
// Guardar el resultado en el acumulador 1.

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

L "Tag_Value_2"

// Cargar el valor del operando en el acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en el
acumulador 1.

XOD

// Combinar lógicamente con O-exclusiva el valor del
acumulador 2 ("Tag_Value_2") con el valor del acumulador 1 ("Tag_Value_3").
// Guardar el resultado en el acumulador 1.

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

1001

1101

0011

1011

Constante
(DW#16#39
C657AC)

0011

1001

1100

0110

0101

0111

1010

1100

Tag_Re‐
sult_1

0110

0110

1010

0010

1100

1010

1001

0111

Tag_Value_2 0110

0101

0100

0011

0101

1101

0010

1011

Tag_Value_3 0011

1001

1100

0110

0101

0111

1010

1100

Tag_Re‐
sult_2

1100

1000

0101

0000

1010

1000

0111

0101

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Activar el bit de estado en operaciones lógicas con palabras (Página 202)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

1738

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Desplazamiento y rotación
Desplazar
SSI: Desplazar con signo por palabras
Descripción
La instrucción "Desplazar con signo por palabras" desplaza bit por bit la palabra derecha (bits
de 0 a 15) del acumulador 1 hacia la derecha. Las posiciones que quedan libres al desplazar
se rellenan con el estado lógico del bit 15 (bit con signo en números INT). Los bits 16 a 31 del
acumulador 1 no cambian. Esta instrucción se ejecuta independientemente del RLO. El bit de
estado A1 se ajusta al estado lógico del último bit desplazado.
Para indicar el número de posiciones de bit que se desplazarán existen las posibilidades
siguientes:
● Indicación de un entero positivo como parámetro de la instrucción. (<Número>)
● Indicación mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
● SSI <Número>: El operando <Número> indica el número de desplazamiento. Se permiten
valores entre 0 y 15. Los bits de estado A0 y OV se ponen a "0" si <Número> es mayor que
cero.
● SSI: El valor del acumulador 2 indica el número de desplazamiento. Se permiten valores
entre 0 y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2
es mayor que cero.
Si el número de desplazamiento indicado es mayor que 15, todos los bits de la palabra
derecha del acumulador 1 se rellenarán con el estado lógico del bit 15.
Aunque el número de desplazamiento indicado sea cero, la instrucción se ejecuta. El bit de
estado CC 1 se pone a "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Formato

Descripción

<Número>

Enteros posi‐ Número de posiciones de bit que se desplazarán.
tivos:
SINT, INT,
UINT, USINT

Programación del PLC
Manual de programación y manejo, 11/2019

1739

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

SSI 6

// Desplazar los bits 0 a 15 del acumulador 1 seis posiciones a la derecha.
// Rellenar las posiciones liberadas con el estado del
bit 15.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 3

// Cargar el número de desplazamiento en el acumulador
1.

L "Tag_Value_2"

// Desplazar el número de desplazamiento al byte derecho del acumulador 2.
// Cargar el valor del operando en el acumulador 1.

SSI

// Desplazar los bits 0 a 15 del acumulador 1 tres posiciones a la derecha.
// Rellenar las posiciones liberadas con el estado del
bit 15.

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

1001

1101

0011

1011

Tag_Re‐
sult_1

0101

1111

0110

0100

1111

1110

0111

0100

Tag_Value_2 0101

1111

0110

0100

0101

1101

0010

1011

Tag_Re‐
sult_2

1111

0110

0100

0000

1011

1010

0101

0101

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

1740

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

SSD: Desplazar con signo por palabras dobles
Descripción
La instrucción "Desplazar con signo por palabras dobles" desplaza bit por bit todo el contenido
del acumulador 1 hacia la derecha. Las posiciones que quedan libres al desplazar se rellenan
con el estado lógico del bit 31 (bit con signo en números DINT). Esta instrucción se ejecuta
independientemente del RLO. El bit de estado A1 se ajusta al estado lógico del último bit
desplazado.
Para indicar el número de posiciones de bit que se desplazarán existen las posibilidades
siguientes:
● Indicación de un entero positivo como parámetro de la instrucción. (<Número>)
● Indicación mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
● SSD <Número>: El operando <Número> indica el número de desplazamiento. Se permiten
valores entre 0 y 31. Los bits de estado A0 y OV se ponen a "0" si <Número> es mayor que
cero.
● SSD: El valor del acumulador 2 indica el número de desplazamiento. Se permiten valores
entre 0 y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2
es mayor que cero.
Con valores mayores que 31, todos los bits del acumulador 1 se rellenan con el estado
lógico del bit 31.
Aunque el número de desplazamiento indicado sea cero, la instrucción se ejecuta. El bit de
estado CC 1 se pone a "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Desplazar con signo por palabras
dobles":
Parámetro

Formato

Descripción

<Número>

Enteros posi‐ Número de posiciones de bit que se desplazarán.
tivos:
SINT, INT,
UINT,
USINT,

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

Programación del PLC
Manual de programación y manejo, 11/2019

1741

Instrucciones
4.1 Instrucciones
AWL

Explicación

SSD 7

// Desplazar los bits 0 a 31 del acumulador 1 siete
posiciones a la derecha.
// Rellenar las posiciones liberadas con el estado del
bit 31.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 4

// Cargar el número de desplazamiento en el acumulador
1.

L "Tag_Value_2"

// Desplazar el número de desplazamiento al byte derecho del acumulador 2.
// Cargar el valor del operando en el acumulador 1.

SSD

// Desplazar los bits 0 a 31 del acumulador 1 cuatro
posiciones a la derecha.
// Rellenar las posiciones liberadas con el estado del
bit 31.

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 1000

1111

0110

0100

0101

1101

0011

1011

Tag_Re‐
sult_1

1111

1111

0001

1110

1100

1000

1011

1010

Tag_Value_2 0010

1000

1010

0010

1001

1011

1100

1101

Tag_Re‐
sult_2

0010

1000

1010

0010

1001

1011

1100

0000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

SLW: Desplazar a la izquierda por palabras
Descripción
La instrucción "Desplazar a la izquierda por palabras" desplaza bit por bit la palabra derecha
(bits 0 a 15) del acumulador 1 hacia la izquierda. Las posiciones que quedan libres al desplazar
se rellenan con ceros. Los bits 16 a 31 del acumulador 1 no cambian. Esta instrucción se
ejecuta independientemente del RLO. El bit de estado A1 se ajusta al estado lógico del último
bit desplazado.

1742

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para indicar el número de posiciones de bit que se desplazarán existen las posibilidades
siguientes:
● Indicación de un entero positivo como parámetro de la instrucción. (<Número>)
● Indicación mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
● SLW <Número>: El operando <Número> indica el número de desplazamiento. Se permiten
valores entre 0 y 15. Los bits de estado A0 y OV se ponen a "0" si <Número> es mayor que
cero.
● SLW: El valor del acumulador 2 indica el número de desplazamiento. Se permiten valores
entre 0 y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2
es mayor que cero.
Si el número de desplazamiento indicado es mayor que 15, todos los bits de la palabra
derecha del acumulador 1 se rellenarán con ceros.
Aunque el número de desplazamiento indicado sea cero, la instrucción se ejecuta. El bit de
estado CC 1 se pone a "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Desplazar a la izquierda por
palabras":
Parámetro

Formato

Descripción

<Número>

Enteros posi‐ Número de posiciones de bit que se desplazarán.
tivos: SINT,
INT, UINT,
USINT

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

SLW 5

// Desplazar los bits 0 a 15 del acumulador 1 cinco
posiciones a la izquierda.
// Rellenar las posiciones liberadas con ceros.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 4

// Cargar el número de desplazamiento en el acumulador
1.

L "Tag_Value_2"

// Desplazar el número de desplazamiento al byte derecho del acumulador 2.
// Cargar el valor del operando en el acumulador 1.

SLW

// Desplazar los bits 0 a 15 del acumulador 1 cuatro
posiciones a la izquierda.
// Rellenar las posiciones liberadas con ceros.

Programación del PLC
Manual de programación y manejo, 11/2019

1743

Instrucciones
4.1 Instrucciones
AWL

Explicación

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‐
sult_1

0101

1111

0110

0100

1010

0111

0110

0000

Tag_Value_2 0101

1111

0110

0100

0101

1101

0010

1011

Tag_Re‐
sult_2

1111

0110

0100

1101

0010

1011

0000

0101

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

SRW: Desplazar a la derecha por palabras
Descripción
La instrucción "Desplazar a la derecha por palabras" desplaza bit por bit la palabra derecha
(bits 0 a 15) del acumulador 1 hacia la derecha. Las posiciones que quedan libres al desplazar
se rellenan con ceros. Los bits 16 a 31 del acumulador 1 no cambian. Esta instrucción se
ejecuta independientemente del RLO. El bit de estado A1 se ajusta al estado lógico del último
bit desplazado.
Para indicar el número de posiciones de bit que se desplazarán existen las posibilidades
siguientes:
● Indicación de un entero positivo como parámetro de la instrucción. (<Número>)
● Indicación mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
● SRW <Número>: El operando <Número> indica el número de desplazamiento. Se permiten
valores entre 0 y 15. Los bits de estado A0 y OV se ponen a "0" si <Número> es mayor que
cero.
● SRW: El valor del acumulador 2 indica el número de desplazamiento. Se permiten valores
entre 0 y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2
es mayor que cero.
Si el número de desplazamiento indicado es mayor que 15, todos los bits de la palabra
derecha del acumulador 1 se rellenarán con ceros.

1744

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Aunque el número de desplazamiento indicado sea cero, la instrucción se ejecuta. El bit de
estado CC 1 se pone a "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Desplazar a la derecha por
palabras":
Parámetro

Formato

Descripción

<Número>

Enteros posi‐ Número de posiciones de bit que se desplazarán.
tivos: SINT,
INT, UINT,
USINT

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

SRW 6

// Desplazar los bits 0 a 15 del acumulador 1 seis posiciones a la derecha.
// Rellenar las posiciones liberadas con ceros.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 4

// Cargar el número de desplazamiento en el acumulador
1.

L "Tag_Value_2"

// Desplazar el número de desplazamiento al byte derecho del acumulador 2.
// Cargar el valor del operando en el acumulador 1.

SRW

// Desplazar los bits 0 a 15 del acumulador 1 cuatro
posiciones a la derecha.
// Rellenar las posiciones liberadas con ceros.

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‐
sult_1

0101

1111

0110

0100

0000

0001

0111

0100

Tag_Value_2 0101

1111

0110

0100

0101

1101

0010

1011

Tag_Re‐
sult_2

1111

0110

0100

0000

0101

1101

0010

0101

Programación del PLC
Manual de programación y manejo, 11/2019

1745

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

SLD: Desplazar a la izquierda por palabras dobles
Descripción
La instrucción "Desplazar a la izquierda por palabras dobles" desplaza bit por bit todo el
contenido del acumulador 1 hacia la izquierda. Las posiciones que quedan libres al desplazar
se rellenan con ceros. Esta instrucción se ejecuta independientemente del RLO. El bit de
estado A1 se ajusta al estado lógico del último bit desplazado.
Para indicar el número de posiciones de bit que se desplazarán existen las posibilidades
siguientes:
● Indicación de un entero positivo como parámetro de la instrucción. (<Número>)
● Indicación mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
● SLD <Número>: El operando <Número> indica el número de desplazamiento. Se permiten
valores entre 0 y 31. Los bits de estado A0 y OV se ponen a "0" si <Número> es mayor que
cero.
● SLD: El valor del acumulador 2 indica el número de desplazamiento. Se permiten valores
entre 0 y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2
es mayor que cero.
Con valores mayores que 31, todos los bits del acumulador 1 se rellenan con ceros.
Aunque el número de desplazamiento indicado sea cero, la instrucción se ejecuta. El bit de
estado CC 1 se pone a "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Desplazar a la izquierda por
palabras dobles":

1746

Parámetro

Formato

Descripción

<Número>

Enteros posi‐ Número de posiciones de bit que se desplazarán.
tivos: SINT,
INT, UINT,
USINT

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

SLD 5

// Desplazar los bits 0 a 31 del acumulador 1 cinco
posiciones a la izquierda.
// Rellenar las posiciones liberadas con ceros.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 4

// Cargar el número de desplazamiento en el acumulador
1.

L "Tag_Value_2"

// Desplazar el número de desplazamiento al byte derecho del acumulador 2.
// Cargar el valor del operando en el acumulador 1.

SLD

// Desplazar los bits 0 a 31 del acumulador 1 cuatro
posiciones a la izquierda.
// Rellenar las posiciones liberadas con ceros.

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‐
sult_1

1110

1100

1000

1011

1010

0111

0110

0000

Tag_Value_2 1010

1000

1010

0010

1001

1011

1100

1101

Tag_Re‐
sult_2

1010

0010

1001

1011

1100

1101

0000

1000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

SRD: Desplazar a la derecha por palabras dobles
Descripción
La instrucción "Desplazar a la derecha por palabras dobles" desplaza bit por bit todo el
contenido del acumulador 1 hacia la derecha. Las posiciones que quedan libres al desplazar
se rellenan con ceros. Esta instrucción se ejecuta independientemente del RLO. El bit de
estado A1 se ajusta al estado lógico del último bit desplazado.

Programación del PLC
Manual de programación y manejo, 11/2019

1747

Instrucciones
4.1 Instrucciones
Para indicar el número de posiciones de bit que se desplazarán existen las posibilidades
siguientes:
● Indicación de un entero positivo como parámetro de la instrucción. (<Número>)
● Indicación mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
● SRD <Número>: El operando <Número> indica el número de desplazamiento. Se permiten
valores entre 0 y 31. Los bits de estado A0 y OV se ponen a "0" si <Número> es mayor que
cero.
● SRD: El valor del acumulador 2 indica el número de desplazamiento. Se permiten valores
entre 0 y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2
es mayor que cero.
Con valores mayores que 31, todos los bits del acumulador 1 se rellenan con ceros.
Aunque el número de desplazamiento indicado sea cero, la instrucción se ejecuta. El bit de
estado CC 1 se pone a "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Desplazar a la derecha por
palabras dobles":
Parámetro

Formato

Descripción

<Número>

Enteros posi‐ Número de posiciones de bit que se desplazarán.
tivos: SINT,
INT, UINT,
USINT

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

SRD 7

// Desplazar los bits 0 a 31 del acumulador 1 siete
posiciones a la derecha.
// Rellenar las posiciones liberadas con ceros.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 4

// Cargar el número de desplazamiento en el acumulador
1.

L "Tag_Value_2"

// Desplazar el número de desplazamiento al byte derecho del acumulador 2.
// Cargar el valor del operando en el acumulador 1.

SRD

// Desplazar los bits 0 a 31 del acumulador 1 cuatro
posiciones a la derecha.
// Rellenar las posiciones liberadas con ceros.

1748

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‐
sult_1

0000

0000

1011

1110

1100

1000

1011

1010

Tag_Value_2 1010

1000

1010

0010

1001

1011

1100

1101

Tag_Re‐
sult_2

1010

1000

1010

0010

1001

1011

1100

0000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

Rotar
RLD: Rotar a la izquierda por palabras dobles
Descripción
La instrucción "Rotar a la izquierda por palabras dobles" rota bit por bit todo el contenido del
acumulador 1 hacia la izquierda. Durante la ejecución, la instrucción desplaza por bits los bits
de 0 a 31 del acumulador 1 hacia la izquierda y rellena las posiciones que han quedado libres
al desplazar con las posiciones de bit desplazadas. Esta instrucción se ejecuta
independientemente del RLO. El bit de estado A1 se ajusta al estado lógico del último bit
desplazado.
Para indicar el número de posiciones de bit que se rotarán existen las posibilidades siguientes:
● Indicación de un entero positivo como parámetro de la instrucción. (<Número>)
● Indicación mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.

Programación del PLC
Manual de programación y manejo, 11/2019

1749

Instrucciones
4.1 Instrucciones
Se pueden utilizar los siguientes formatos:
● RLD <Número>: El operando <Número> indica el número de rotación. Se permiten valores
entre 0 y 32. Los bits de estado A0 y OV se ponen a "0" si <Número> es mayor que cero.
● RLD: El valor del acumulador 2 indica el número de rotación. Se permiten valores entre 0
y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2 es mayor
que cero.
Si el valor es mayor que 32, el número de rotación se calcula con una división módulo entre
32. Si, p. ej., el número de rotación es 34, los bits del acumulador 1 se rotarán 2 posiciones
de bit.
Si el número de rotación indicado es 32, el contenido del acumulador 1 no cambia.
Aunque el número de rotación indicado sea cero, la instrucción se ejecuta. El bit de estado CC
1 se pone a "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Rotar a la izquierda por palabras
dobles":
Parámetro

Formato

Descripción

<Número>

Enteros posi‐ Número de posiciones de bit que se rotarán.
tivos: SINT,
INT, UINT,
USINT

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

RLD 4

// Rotar los bits 0 a 31 del acumulador 1 cuatro posiciones a la izquierda.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 6

// Cargar el número de rotación en el acumulador 1.

L "Tag_Value_2"

// Desplazar el número de rotación al byte derecho del
acumulador 2.
// Cargar el valor del operando en el acumulador 1.

1750

RLD

// Rotar los bits 0 a 31 del acumulador 1 seis posiciones a la izquierda.

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‐
sult_1

1111

0110

0100

0101

1101

0011

1011

0101

Tag_Value_2 1010

1000

1010

0010

1001

1011

1100

1101

Tag_Re‐
sult_2

1000

1010

0110

1111

0011

0110

1010

0010

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

RRD: Rotar a la derecha por palabras dobles
Descripción
La instrucción "Rotar a la derecha por palabras dobles" rota bit por bit todo el contenido del
acumulador 1 hacia la derecha. Durante la ejecución, la instrucción desplaza por bits los bits
0 a 31 del acumulador 1 hacia la derecha y rellena las posiciones que han quedado libres al
desplazar con las posiciones de bit desplazadas. Esta instrucción se ejecuta
independientemente del RLO. El bit de estado CC1 se ajusta al estado lógico del último bit
desplazado.
Para indicar el número de posiciones de bit que se rotarán existen las posibilidades siguientes:
● Indicación de un entero positivo como parámetro de la instrucción. (<Número>)
● Indicación mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
● RRD <Número>: El operando <Número> indica el número de rotación. Se admiten valores
entre 0 y 32. Los bits de estado CC0 y OV se ponen a "0" si <Número> es mayor que cero.
● RRD: El valor del acumulador 2 indica el número de rotación. Se admiten valores entre 0 y
255. Los bits de estado CC0 y OV se ponen a "0" si el contenido del acumulador 2 es mayor
que cero.
Si el valor es mayor que 32, el número de rotación se calcula con una división módulo entre
32. Si, p. ej., el número de rotación es 34, los bits del acumulador 1 se rotarán 2 posiciones
de bit.
Si el número de rotación indicado es 32, el contenido del acumulador 1 no cambia.
Aunque el número de rotación indicado sea cero, la instrucción se ejecuta. El bit de estado CC
1 se pone a "0".

Programación del PLC
Manual de programación y manejo, 11/2019

1751

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Rotar a la derecha por palabras
dobles":
Parámetro

Formato

Descripción

<Número>

Enteros posi‐ Número de posiciones de bit que se rotarán.
tivos: SINT,
INT, UINT,
USINT

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

RRD 4

// Rotar los bits 0 a 31 del acumulador 1 cuatro posiciones a la derecha.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 6

// Cargar el número de rotación en el acumulador 1.

L "Tag_Value_2"

// Desplazar el número de rotación al byte derecho del
acumulador 2.
// Cargar el valor del operando en el acumulador 1.

RRD

// Rotar los bits 0 a 31 del acumulador 1 seis posiciones a la derecha.

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‐
sult_1

1011

0101

1111

0110

0100

0101

1101

0011

Tag_Value_2 1010

1000

1010

0010

1001

1011

1100

1101

Tag_Re‐
sult_2

0110

1010

0010

1000

1010

0110

1111

0011

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

1752

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

RLDA: Rotar a la izquierda vía bit de estado CC 1
Descripción
La instrucción "Rotar a la izquierda vía bit de estado CC 1" desplaza el contenido del
acumulador 1 un bit a la izquierda. La posición de bit que ha quedado libre al desplazar (0) se
rellena con el estado lógico del bit de estado CC 1. El bit de estado CC 1 obtiene el estado
lógico del bit desplazado (31).
Esta instrucción se ejecuta independientemente del RLO. Pone el bit de estado CC 0 a "0".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value"

// Cargar el valor del operando en el acumulador 1.

RLDA

// Rotar los bits 0 a 31 del acumulador 1 una posición
a la izquierda.
// Rellenar el bit 0 con el estado lógico del bit de
estado CC 1.
// Escribir el bit desplazado en el bit de estado CC 1.

T "Tag_Result"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

CC 1

Valor

Tag_Value 1

0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‐
sult

1011

1110

1100

1000

1011

1010

0111

0111

0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

RRDA: Rotar a la derecha vía bit de estado CC 1
Descripción
La instrucción "Rotar a la derecha vía bit de estado CC 1" desplaza el contenido del
acumulador 1 un bit a la derecha. La posición de bit que ha quedado libre al desplazar (31) se
rellena con el estado lógico del bit de estado CC 1. El bit de estado CC 1 obtiene el estado
lógico del bit desplazado (0).

Programación del PLC
Manual de programación y manejo, 11/2019

1753

Instrucciones
4.1 Instrucciones
Esta instrucción se ejecuta independientemente del RLO. Pone los bits de estado CC 0 y OVa
"0".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value"

// Cargar el valor del operando en el acumulador 1.

RRDA

// Rotar los bits 0 a 31 del acumulador 1 una posición
a la derecha.
// Rellenar el bit 31 con el estado lógico del bit de
estado CC 1.
// Escribir el bit desplazado en el bit de estado CC 1.

T "Tag_Result"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

CC 1

Valor

Tag_Value

1

0101

1111

0110

0100

0101

1101

0011

1011

Tag_Result 0

1010

1111

1011

0010

0010

1110

1001

1101

El bit de estado CC 1 tiene el valor "1", ya que el bit 0 del operando "Tag_Value" también tiene
el valor "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

Otras instrucciones
Acumulador
TAK: Intercambiar contenido de los acumuladores 1 y 2
Descripción
La instrucción "Intercambiar contenido de los acumuladores 1 y 2" intercambia el contenido del
acumulador 1 con el contenido del acumulador 2.
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.

1754

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

>I

// Comparar si el valor del acumulador 2 es mayor que
el valor del acumulador 1.

JC NEXT

// Si la condición se cumple (RLO = "1"), saltar a la
etiqueta "NEXT".
// Si la condición no se cumple (RLO = "0"), procesar
la instrucción siguiente.

TAK

// Intercambiar contenido de los acumuladores 1 y 2.

NEXT: -I

// Etiqueta "NEXT"
// Restar el valor del acumulador 1 del valor del acumulador 2.

T "Tag_Output"

// Transferir el contenido del acumulador 1 al operando "Tag_Output".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

PUSH: Desplazar contenido al siguiente acumulador superior
Descripción
La instrucción "Desplazar contenido al siguiente acumulador superior" desplaza el contenido
del acumulador 1 al acumulador 2.
El contenido del acumulador 1 no se ve influido por la instrucción y permanece invariable una
vez ejecutada la misma. El contenido del acumulador 2 se pierde.

Programación del PLC
Manual de programación y manejo, 11/2019

1755

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el contenido de los acumuladores 1 y 2 antes y después de ejecutar
la instrucción:
Estado

Acumulador
1

2

Antes de la ejecución

Valor A

Valor B

Después de la ejecución

Valor A

Valor A

La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

PUSH

// Desplazar el contenido de los acumuladores 1 a 2 al
siguiente acumulador superior en cada caso.

L "Tag_Value_2"

// Cargar el valor del operando en el acumulador 1.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

POP: Desplazar contenido al siguiente acumulador inferior
Descripción
La instrucción "Desplazar contenido al siguiente acumulador inferior" desplaza el contenido del
acumulador 2 al acumulador 1.
El contenido del acumulador 2 no se ve influido por la instrucción y permanece invariable una
vez ejecutada la misma. El contenido del acumulador 1 se pierde.
La tabla siguiente muestra el contenido de los acumuladores 1 y 2 antes y después de ejecutar
la instrucción:
Estado

Acumulador
1

1756

2

Antes de la ejecución

Valor A

Valor B

Después de la ejecución

Valor B

Valor B

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

T "Tag_Value_1"

// Transferir el contenido del acumulador 1 al operando "Tag_Value_1".

POP

// Desplazar el contenido del acumulador 2 al acumulador 1 inferior.

T "Tag_Value_2"

// Transferir el contenido del acumulador 1 al operando "Tag_Value_2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Registro de direcciones
+AR1: Sumar acumulador 1 a AR1
Descripción
La instrucción "Sumar acumulador 1 a AR1" suma un valor al contenido del registro de
direcciones 1. El tipo de puntero que está en el registro de direcciones 1 y el área de operandos
se conservan.
Para indicar el valor que debe sumarse existen las posibilidades siguientes:
● Indicación mediante una constante: La instrucción suma el valor de la constante al registro
de direcciones 1. El valor de la constante debe equivaler al formato de un puntero interno
del área (POINTER).
● Indicación mediante el valor de la palabra derecha del acumulador 1: la instrucción
interpreta el valor de la palabra derecha del acumulador 1 como un entero de 16 bits y lo
amplía a 24 bits con el signo correcto. Seguidamente, la instrucción suma el valor del
acumulador 1 al registro de direcciones 1. Se admiten valores de -32 768 a +32 767.
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.

Programación del PLC
Manual de programación y manejo, 11/2019

1757

Instrucciones
4.1 Instrucciones
Los contenidos de los acumuladores no cambian debido a la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Sumar acumulador 1 a AR1":
Parámetro

Tipo de datos Descripción

<Constante>

POINTER

Valor que se suma al registro de direcciones 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

+AR1 P#10.0

// Sumar el puntero al registro de direcciones 1.

L "Tag_Value"

// Cargar el valor del operando "Tag_Value" en la palabra derecha del acumulador 1.

+AR1

// Sumar el valor del acumulador 1 al registro de direcciones 1.

TAR1 %MD24

// Transferir el contenido del registro de direcciones
1 a la palabra doble MD24.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

+AR2: Sumar acumulador 1 a AR2
Descripción
La instrucción "Sumar acumulador 1 a AR2" suma un valor al contenido del registro de
direcciones 2. El tipo de puntero que está en el registro de direcciones 2 y el área de operandos
se conservan.

1758

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para indicar el valor que debe sumarse existen las posibilidades siguientes:
● Indicación mediante una constante: La instrucción suma el valor de la constante al registro
de direcciones 2. El valor de la constante debe equivaler al formato de un puntero interno
del área (POINTER).
● Indicación mediante el valor de la palabra derecha del acumulador 1: la instrucción
interpreta el valor de la palabra derecha del acumulador 1 como un entero de 16 bits y lo
amplía a 24 bits con el signo correcto. Seguidamente, la instrucción suma el valor del
acumulador 1 al registro de direcciones 2. Se admiten valores de -32 768 a +32 767.
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.
Los contenidos de los acumuladores no cambian debido a la instrucción.
Nota
El registro de direcciones AR2 se utiiza para procesar multiinstancias. Si se programa la
instrucción "Sumar acumulador 1 a AR2", primero debe "salvarse" el contenido del registro de
direcciones 2 y volver a cargarlo después.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Sumar acumulador 1 a AR2":
Parámetro

Tipo de datos Descripción

<Constante>

POINTER

Valor que se suma al registro de direcciones 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

+AR2 P#10.0

// Sumar el puntero al registro de direcciones 2.

L "Tag_Value"

// Cargar el valor del operando "Tag_Value" en la palabra derecha del acumulador 1.

+AR2

// Sumar el valor del acumulador 1 al registro de direcciones 2.

TAR2 %MD24

// Transferir el contenido del registro de direcciones
1 a la palabra doble MD24.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)

Programación del PLC
Manual de programación y manejo, 11/2019

1759

Instrucciones
4.1 Instrucciones
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Instrucciones nulas
BLD: Refresco de imagen (instrucción nula)
Descripción
La instrucción "Refresco de imagen (instrucción nula)" no ejecuta ninguna función y no influye
en los bits de estado. La instrucción sirve para reconocer secuencias de códigos en una
transferencia de parámetros o en los segmentos KOP/FUP. Se genera automáticamente
cuando se visualiza un programa KOP o FUP en AWL. El valor de parámetro es el número de
identificación de la instrucción y es generado por la programadora.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Refresco de imagen (instrucción
nula)":
Parámetro

Tipo de datos Descripción

<número de
identifica‐
ción>

WORD

Número de identificación de la instrucción

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

NOP 0: Instrucción nula
Descripción
La instrucción "Instrucción nula" con un parámetro 0 no ejecuta ninguna función y no influye en
los bits de estado. El código de la instrucción contiene un patrón de bits con 16 ceros. La
instrucción solo es importante para la programadora cuando se visualiza un programa.

1760

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

>I

// Comparar si el valor del acumulador 2 es mayor que
el valor del acumulador 1.

A

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

JC NEXT

// Si la condición se cumple (RLO = "1"), saltar a la
etiqueta "NEXT".
// Si la condición no se cumple (RLO = "0"), procesar
la instrucción siguiente.

TAK

// Intercambiar contenido de los acumuladores 1 y 2.

NEXT: NOP 0

// Etiqueta "NEXT"

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

NOP 1: Instrucción nula
Descripción
La instrucción "Instrucción nula" con un parámetro 1 no ejecuta ninguna función y no influye en
los bits de estado. El código de la instrucción contiene un patrón de bits con 16 unos. La
instrucción solo es importante para la programadora cuando se visualiza un programa.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)

Programación del PLC
Manual de programación y manejo, 11/2019

1761

Instrucciones
4.1 Instrucciones
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

4.1.3.4

SCL

Operaciones lógicas con bits
R_TRIG: Detectar flanco de señal ascendente
Descripción
La instrucción "Detectar flanco de señal ascendente" permite detectar un cambio de estado de
"0" a "1" en la entrada CLK. La instrucción compara el valor actual de la entrada CLK con el
estado de la consulta anterior (marca de flanco), que está almacenada en la instancia indicada.
Cuando la instrucción detecta un cambio de estado de "0" a "1" en la entrada CLK, en la salida
Q se genera un flanco de señal ascendente, es decir, que la señal tiene el valor TRUE o "1"
exactamente durante un ciclo.
En todos los demás casos, el estado lógico de la salida de la instrucción es "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

CLK

Input

BOOL

I, Q, M, D, L

Señal entrante cuyo flanco
se consulta

Q

Output

BOOL

I, Q, M, D, L

Resultado de la evaluación
de flancos

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"R_TRIG_DB"(CLK := "TagIn",
Q => "TagOut");

En la variable "R_TRIG_DB" se guarda el estado anterior de la variable en la entrada CLK. Si
en el operando "TagIn" se detecta un cambio del estado lógico de "0" a "1", la salida "TagOut"
devuelve el estado lógico "1" durante un ciclo.

1762

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

F_TRIG: Detectar flanco de señal descendente
Descripción
La instrucción "Detectar flanco de señal descendente" permite detectar un cambio de estado
de "1" a "0" en la entrada CLK. La instrucción compara el valor actual de la entrada CLK con
el estado de la consulta anterior (marca de flanco), que está almacenada en la instancia
indicada. Cuando la instrucción detecta un cambio de estado de "1" a "0" en la entrada CLK,
en la salida Q se genera un flanco de señal descendente, es decir, que la señal tiene el valor
TRUE o "1" exactamente durante un ciclo.
En todos los demás casos, el estado lógico de la salida de la instrucción es "0".

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

CLK

Input

BOOL

I, Q, M, D, L

Señal entrante cu‐
yo flanco se consul‐
ta

Q

Output

BOOL

I, Q, M, D, L

Resultado de la
evaluación de flan‐
cos

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"F_TRIG_DB"(CLK := "TagIn",
Q => "TagOut");

En la variable "F_TRIG_DB" se guarda el estado anterior de la variable en la entrada CLK. Si
en el operando "TagIn" se detecta un cambio del estado lógico de "1" a "0", la salida "TagOut"
devuelve el estado lógico "1" durante un ciclo.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1763

Instrucciones
4.1 Instrucciones

Temporizadores
Llamada de temporizadores CEI
Descripción
Existe la posibilidad de declarar el temporizador CEI como instancia individual o multiinstancia
y llamarlo en el código del programa.
Están disponibles las siguientes posibilidades sintácticas para la declaración de un
temporizador CEI como multiinstancia dentro de una estructura de la interfaz del bloque:

Temporizador CEI como elemento de ARRAY
Declaración en la interfaz del bloque:

Código del programa:
SCL
#MyARRAY[1].TOF(IN := <Operando>, PT := <Operando>)

Declaración en la interfaz del bloque:

Código del programa:
SCL
#MyARRAY[#index](IN := <Operando>, PT := <Operando>)

Temporizador CEI en una estructura anónima
Declaración en la interfaz del bloque:

1764

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código del programa:
SCL
#MyStruct.FirstTime.TOF(IN := <Operando>, PT := <Operando>)

Declaración en la interfaz del bloque:

Código del programa:
SCL
#MyStruct.FirstTime(IN := <Operando>, PT := <Operando>)

Temporizador CEI en el bloque de datos global
Declaración en el bloque de datos:

Código del programa:
SCL
"MyGlobalDB".Timer.FirstTime.TOF(IN := <Operando>, PT := <Operando>)

Declaración en el bloque de datos:

Programación del PLC
Manual de programación y manejo, 11/2019

1765

Instrucciones
4.1 Instrucciones
Código del programa:
SCL
"MyGlobalDB".Timer.SecondTime(IN := <Operando>, PT := <Operando>)

Temporizador CEI como elemento en la interfaz del bloque
Declaración en la interfaz del bloque:

Código del programa:
SCL
#Timer.FirstTime.TOF(IN := <Operando>, PT := <Operando>)

Declaración en la interfaz del bloque:

Código del programa:
SCL
#Timer.SecondTime(IN := <Operando>, PT := <Operando>)

Temporizador CEI en un DB de ARRAY
Declaración en el DB de ARRAY:

1766

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código del programa:
SCL
"MyARRAYDB"."THIS"[0].FirstTime.TOF(IN := <Operando>, PT := <Operando>)

Declaración en el DB de ARRAY:

Código del programa:
SCL
"MyARRAYDB"."THIS"[0].SecondTime(IN := <Operando>, PT := <Operando>)

TP: Impulso
Descripción
La instrucción "Impulso" activa el parámetro Q por un tiempo programado. La instrucción se
inicia cuando el resultado lógico (RLO) del parámetro IN cambia de "0" a "1" (flanco de señal
ascendente). Cuando se inicia la instrucción, se empieza a contar el tiempo programado PT.
El parámetro Q se activa por el tiempo PT, independientemente de cómo evolucione la señal
de entrada. Durante el tiempo PT la detección de un nuevo flanco de señal ascendente en la
entrada IN no influye en el estado lógico de la salida Q.
El valor actual de tiempo se puede consultar en el parámetro ET. Este valor de tiempo empieza
a contar a partir de T#0s y termina al alcanzarse el valor del tiempo PT. Si cuando se alcanza
el tiempo PT el estado lógico del parámetro IN es "0", se resetea el parámetro ET.
Nota
Si en el programa no se llama la instrucción porque, p. ej., esta se omite, la salida ET devuelve
un valor constante en cuanto transcurre este tiempo.
A cada llamada de la instrucción "Impulso" debe asignársele un temporizador CEI, en el que
se guarden los datos de instancia.
Encontrará información sintáctica sobre la llamada de temporizadores CEI en estructuras
(multiinstancia) aquí: Llamada de temporizadores CEI (Página 1764)

Programación del PLC
Manual de programación y manejo, 11/2019

1767

Instrucciones
4.1 Instrucciones

Para las CPU de la serie S7-1200
El temporizador CEI es una estructura del tipo de datos IEC_TIMER o TP_TIME que se puede
declarar como se indica a continuación:
● Declaración de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER (p.
ej., "MyIEC_TIMER_DB")
● Declaración como variable local del tipo de datos TP_TIME en la sección "Static" de un
bloque de programa (p. ej., #MyIEC_TIMER_Instance)

Para las CPU de la serie S7-1500
El temporizador CEI es una estructura del tipo de datos IEC_TIMER, IEC_LTIMER, TP_TIME
o TP_LTIME que se puede declarar como se indica a continuación:
● Declaración de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER o
IEC_LTIMER (p. ej., "MyIEC_LTIMER_DB")
● Declaración como variable local del tipo de datos TP_TIME o TP_LTIME en la sección
"Static" de un bloque de programa (p. ej., #MyIEC_LTIMER_Instance)

Temporizador CEI como bloque de datos de instancia del tipo de datos de sistema
<Temporizador_CEI> (Shared DB)
Un temporizador CEI se puede declarar como bloque de datos del modo siguiente:
<DB_temporizador_CEI>.TP();

Temporizador CEI como variable local de la interfaz del bloque (multiinstancia)
El temporizador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Timer();

1768

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Actualización de los valores actuales en los datos de instancia
Los datos de instancia de "Impulso" se actualizan siguiendo las reglas indicadas a
continuación:
● Entrada IN
La instrucción "Impulso" compara el RLO actual con el RLO de la consulta anterior, que está
almacenado en el parámetro IN de los datos de instancia. Si la instrucción detecta un
cambio del RLO de "0" a "1", significa que hay un flanco de señal ascendente y se empieza
a medir el tiempo. Una vez procesada la instrucción "Impulso", el valor del parámetro IN se
actualiza en los datos de instancia y se utiliza como marca de flancos para la siguiente
consulta.
Tenga en cuenta que la evaluación de flancos falla cuando el valor actual del parámetro IN
es escrito o inicializado por otras funciones.
● Entrada PT
El valor de la entrada PT se escribe en el parámetro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
● Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
– Al llamar la instrucción, si las salidas ET o Q están interconectadas.
O bien:
– Al acceder a Q o ET.
Si las salidas no están interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucción se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan parámetros internos de la
instrucción "Impulso". Tenga en cuenta que la medición de tiempo falla cuando los valores
actuales de la instrucción son escritos o inicializados por otras funciones.

Programación del PLC
Manual de programación y manejo, 11/2019

1769

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está midiendo el
tiempo, se interfiere en la función del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse daños materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐ Descripción
ria

IN

Input

BOOL

BOOL

I, Q, M, D, L, P

Entrada de
arranque

PT

Input

TIME

TIME, LTI‐
ME

I, Q, M, D, L, P

Duración del
impulso.
El valor del pa‐
rámetro PT de‐
be ser positivo.

1770

Q

Output

BOOL

BOOL

I, Q, M, D, L, P

Operando que
se activa por el
tiempo PT.

ET

Output

TIME

TIME, LTI‐
ME

I, Q, M, D, L, P

Valor de tiempo
actual

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el cronograma de impulsos de la instrucción "Impulso":
,1

4

37

37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"TP_DB".TP(IN := "Tag_Start",
PT := "Tag_PresetTime",
Q => "Tag_Status",
ET => "Tag_ElapsedTime");

Cuando el estado lógico del operando "Tag_Start" cambia de "0" a "1", el tiempo programado
en el parámetro PT empieza a contar y el operando "Tag_Status" se pone a "1". El valor de
tiempo actual se guarda en el operando "Tag_ElapsedTime".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1771

Instrucciones
4.1 Instrucciones

TON: Retardo al conectar
Descripción
La instrucción "Retardo al conectar" permite retardar la activación del parámetro Q por el
tiempo programado PT. La instrucción se inicia cuando el resultado lógico (RLO) del parámetro
IN cambia de "0" a "1" (flanco de señal ascendente). Cuando se inicia la instrucción, se
empieza a contar el tiempo programado PT. Una vez transcurrido el tiempo PT, el parámetro
Q devuelve el estado lógico "1". El parámetro Q permanecerá activado mientras la entrada de
arranque esté puesta a "1". Cuando el estado lógico del parámetro IN cambia de "1" a "0", se
resetea el parámetro Q. La función de temporización se reinicia al detectarse un nuevo flanco
de señal ascendente en el parámetro IN.
El valor de tiempo actual se puede consultar en el parámetro ET. Este valor de tiempo empieza
a contar a partir de T#0s y termina al alcanzarse el valor del tiempo PT. El parámetro ET se
resetea en cuanto el estado lógico del parámetro IN cambia a "0".
Nota
Si en el programa no se llama la instrucción porque, p. ej., esta se omite, la salida ET devuelve
un valor constante en cuanto ha transcurrido el tiempo PT.
A cada llamada de la instrucción "Retardo al conectar" debe asignársele un temporizador CEI,
en el que se guarden los datos de instancia.
Encontrará información sintáctica sobre la llamada de temporizadores CEI en estructuras
(multiinstancia) aquí: Llamada de temporizadores CEI (Página 1764)

Para las CPU de la serie S7-1200
El temporizador CEI es una estructura del tipo de datos IEC_TIMER o TON_TIME que se
puede declarar como se indica a continuación:
● Declaración de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER (p.
ej., "MyIEC_TIMER_DB")
● Declaración como variable local del tipo de datos TON_TIME en la sección "Static" de un
bloque de programa (p. ej., #MyIEC_TIMER_Instance)

Para las CPU de la serie S7-1500
El temporizador CEI es una estructura del tipo de datos IEC_TIMER, IEC_LTIMER, TON_TIME
o TON_LTIME que se puede declarar como se indica a continuación:
● Declaración de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER o
IEC_LTIMER (p. ej., "MyIEC_TIMER_DB")
● Declaración como variable local del tipo de datos TON_TIME o TON_LTIME en la sección
"Static" de un bloque de programa (p. ej., #MyIEC_TIMER_Instance)

1772

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Temporizador CEI como bloque de datos de instancia del tipo de datos de sistema
<Temporizador_CEI> (Shared DB)
Un temporizador CEI se puede declarar como bloque de datos del modo siguiente:
<DB_temporizador_CEI>.TON();

Temporizador CEI como variable local de la interfaz del bloque (multiinstancia)
El temporizador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Timer();

Actualización de los valores actuales en los datos de instancia
Los datos de instancia de "Retardo al conectar" se actualizan siguiendo las reglas indicadas a
continuación:
● Entrada IN
La instrucción "Retardo al conectar" compara el RLO actual con el RLO de la consulta
anterior, que está almacenado en el parámetro IN de los datos de instancia. Si la instrucción
detecta un cambio del RLO de "0" a "1", significa que hay un flanco de señal ascendente y
se empieza a medir el tiempo. Una vez procesada la instrucción "Retardo al conectar", el
valor del parámetro IN se actualiza en los datos de instancia y se utiliza como marca de
flancos para la siguiente consulta.
Tenga en cuenta que la evaluación de flancos falla cuando el valor actual del parámetro IN
es escrito o inicializado por otras funciones.
● Entrada PT
El valor de la entrada PT se escribe en el parámetro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
● Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
– Al llamar la instrucción, si las salidas ET o Q están interconectadas.
O bien:
– Al acceder a Q o ET.
Si las salidas no están interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucción se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan parámetros internos de la
instrucción "Retardo al conectar". Tenga en cuenta que la medición de tiempo falla cuando
los valores actuales de la instrucción son escritos o inicializados por otras funciones.

Programación del PLC
Manual de programación y manejo, 11/2019

1773

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está midiendo el
tiempo, se interfiere en la función del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse daños materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐ Descripción
ria

IN

Input

BOOL

BOOL

I, Q, M, D, L, P

Entrada de
arranque

PT

Input

TIME

TIME, LTI‐
ME

I, Q, M, D, L, P

Tiempo de re‐
tardo al conec‐
tar.
El valor del pa‐
rámetro PT de‐
be ser positivo.

1774

Q

Output

BOOL

BOOL

I, Q, M, D, L, P

Operando que
se activa una
vez transcurri‐
do el tiempo PT.

ET

Output

TIME

TIME, LTI‐
ME

I, Q, M, D, L, P

Valor de tiempo
actual

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el cronograma de impulsos de la instrucción "Retardo al conectar":
,1

4

37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"TON_DB".TON(IN := "Tag_Start",
PT := "Tag_PresetTime",
Q => "Tag_Status",
ET => "Tag_ElapsedTime");

Cuando el estado lógico del operando "Tag_Start" cambia de "0" a "1", el tiempo programado
en el parámetro PT empieza a contar. Una vez transcurrido el tiempo, el operando
"Tag_Status" se pone al estado lógico "1". El operando "Tag_Status" permanece a "1" mientras
el operando "Tag_Start" tenga el estado lógico "1". El valor de tiempo actual se guarda en el
operando "Tag_ElapsedTime". Cuando el estado lógico del operando "Tag_Start" cambia de
"1" a "0", se restablece el operando "Tag_Status".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1775

Instrucciones
4.1 Instrucciones

TOF: Retardo al desconectar
Descripción
La instrucción "Retardo al desconectar" permite retardar el reset del parámetro Q por el tiempo
programado PT. El parámetro Q se activa cuando el resultado lógico (RLO) del parámetro IN
cambia de "1" a "0" (flanco de señal descendente). Cuando el estado lógico del parámetro IN
cambia nuevamente a "1", el tiempo programado PT deja de contar. El parámetro Q
permanecerá activado mientras transcurra el tiempo PT. Una vez transcurrido el tiempo PT se
resetea el parámetro Q. Si el estado lógico del parámetro IN cambia a "1" antes de que
transcurra el tiempo PT, se inicializa el temporizador. El estado lógico del parámetro Q
permanece a "1".
El valor de tiempo actual se puede consultar en el parámetro ET. Este valor de tiempo empieza
a contar a partir de T#0s y termina al alcanzarse el valor del tiempo PT. Una vez transcurrido
el tiempo PT, el valor actual del parámetro ET se conservará hasta que el parámetro IN cambie
nuevamente a "1". Si el parámetro IN cambia a "1" antes de transcurrir el tiempo PT, el
parámetro ET adopta el valor T#0s.
Nota
Si en el programa no se llama la instrucción porque, p. ej., esta se omite, la salida ET devuelve
un valor constante en cuanto transcurre este tiempo.
A cada llamada de la instrucción "Retardo al desconectar" debe asignársele un temporizador
CEI, en el que se guarden los datos de instancia.
Encontrará información sintáctica sobre la llamada de temporizadores CEI en estructuras
(multiinstancia) aquí: Llamada de temporizadores CEI (Página 1764)

Para las CPU de la serie S7-1200
El temporizador CEI es una estructura del tipo de datos IEC_TIMER o TOF_TIME que se
puede declarar como se indica a continuación:
● Declaración de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER (p.
ej., "MyIEC_TIMER_DB")
● Declaración como variable local del tipo de datos TOF_TIME en la sección "Static" de un
bloque de programa (p. ej., #MyIEC_TIMER_Instance)

Para las CPU de la serie S7-1500
El temporizador CEI es una estructura del tipo de datos IEC_TIMER, IEC_LTIMER, TOF_TIME
o TOF_LTIME que se puede declarar como se indica a continuación:
● Declaración de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER o
IEC_LTIMER (p. ej., "MyIEC_TIMER_DB")
● Declaración como variable local del tipo de datos TOF_TIME o TOF_LTIME en la sección
"Static" de un bloque de programa (p. ej., #MyIEC_TIMER_Instance)

1776

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Temporizador CEI como bloque de datos de instancia del tipo de datos de sistema
<Temporizador_CEI> (Shared DB)
Un temporizador CEI se puede declarar como bloque de datos del modo siguiente:
<DB_temporizador_CEI.TOF();

Temporizador CEI como variable local de la interfaz del bloque (multiinstancia)
El temporizador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Timer();

Actualización de los valores actuales en los datos de instancia
Los datos de instancia de "Retardo al desconectar" se actualizan siguiendo las reglas
indicadas a continuación:
● Entrada IN
La instrucción "Retardo al desconectar" compara el RLO actual con el RLO de la consulta
anterior, que está almacenado en el parámetro IN de los datos de instancia. Si la instrucción
detecta un cambio del RLO de "1" a "0", significa que hay un flanco de señal descendente
y se empieza a contar el tiempo. Una vez procesada la instrucción "Retardo al
desconectar", el valor del parámetro IN se actualiza en los datos de instancia y se utiliza
como marca de flancos para la siguiente consulta.
Tenga en cuenta que la evaluación de flancos falla cuando el valor actual del parámetro IN
es escrito o inicializado por otras funciones.
● Entrada PT
El valor de la entrada PT se escribe en el parámetro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
● Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
– Al llamar la instrucción, si las salidas ET o Q están interconectadas.
O bien:
– Al acceder a Q o ET.
Si las salidas no están interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucción se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan parámetros internos de la
instrucción "Retardo al desconectar". Tenga en cuenta que la medición de tiempo falla
cuando los valores actuales de la instrucción son escritos o inicializados por otras
funciones.

Programación del PLC
Manual de programación y manejo, 11/2019

1777

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está midiendo el
tiempo, se interfiere en la función del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse daños materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐ Descripción
ria

IN

Input

BOOL

BOOL

I, Q, M, D, L, P

Entrada de
arranque

PT

Input

TIME

TIME, LTI‐
ME

I, Q, M, D, L, P

Tiempo de re‐
tardo al desco‐
nectar.
El valor del pa‐
rámetro PT de‐
be ser positivo.

1778

Q

Output

BOOL

BOOL

I, Q, M, D, L, P

Operando que
se desactiva
una vez trans‐
currido el tiem‐
po PT.

ET

Output

TIME

TIME, LTI‐
ME

I, Q, M, D, L, P

Valor de tiempo
actual

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el cronograma de impulsos de la instrucción "Retardo al
desconectar":
,1

4
37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"TOF_DB".TOF(IN := "Tag_Start",
PT := "Tag_PresetTime",
Q => "Tag_Status",
ET => "Tag_ElapsedTime");

Si se produce un cambio del estado lógico del operando "Tag_Start" de "0" a "1", el operando
se pone a "Tag_Status". Cuando el estado lógico del operando "Tag_Start" cambia de "1" a "0",
el tiempo programado en el parámetro PT empieza a contar. Mientras transcurra el tiempo,
permanecerá activado el operando "Tag_Status". Una vez transcurrido el tiempo, el operando
"Tag_Status" se desactiva. El valor de tiempo actual se guarda en el operando
"Tag_ElapsedTime".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1779

Instrucciones
4.1 Instrucciones

TONR: Acumulador de tiempo
Descripción
La instrucción "Acumulador de tiempo" acumula valores de tiempo dentro de un periodo
definido por el parámetro PT. Cuando el estado lógico del parámetro IN cambia a "1", se
ejecuta la medición de tiempo y se empieza a contar el tiempo PT. Mientras transcurre el
tiempo PT se van acumulando los valores de tiempo que se leen cuando el estado lógico del
parámetro IN es "1". Si en la entrada "IN" el estado lógico cambia a "0", se interrumpe la
medición de tiempo. Si en la entrada "IN" el estado lógico cambia de nuevo a "1", se reanuda
la medición de tiempo. El tiempo acumulado se devuelve en el parámetro ET y se puede
consultar allí. Una vez se alcanza el tiempo PT, el parámetro Q devolverá el estado lógico "1".
El parámetro Q permanece a "1" aunque el estado lógico del parámetro IN cambie a "0".
El parámetro R desactiva los parámetros ET y Q independientemente del estado lógico del
parámetro IN.
A cada llamada de la instrucción "Acumulador de tiempo" debe asignársele un temporizador
CEI, en el que se guarden los datos de instancia.
Encontrará información sintáctica sobre la llamada de temporizadores CEI en estructuras
(multiinstancia) aquí: Llamada de temporizadores CEI (Página 1764)

Para las CPU de la serie S7-1200
El temporizador CEI es una estructura del tipo de datos IEC_TIMER o TONR_TIME que se
puede declarar como se indica a continuación:
● Declaración de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER (p.
ej., "MyIEC_TIMER_DB")
● Declaración como variable local del tipo de datos TONR_TIME en la sección "Static" de un
bloque de programa (p. ej., #MyIEC_TIMER_Instance)

Para las CPU de la serie S7-1500
El temporizador CEI es una estructura del tipo de datos IEC_TIMER, IEC_LTIMER,
TONR_TIME o TONR_LTIME que se puede declarar como se indica a continuación:
● Declaración de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER o
IEC_LTIMER (p. ej., "MyIEC_TIMER_DB")
● Declaración como variable local del tipo de datos TONR_TIME o TONR_LTIME en la
sección "Static" de un bloque de programa (p. ej., #MyIEC_TIMER_Instance)

Temporizador CEI como bloque de datos de instancia del tipo de datos de sistema
<Temporizador_CEI> (Shared DB)
Un temporizador CEI se puede declarar como bloque de datos del modo siguiente:
<DB_temporizador_CEI>.TONR();

1780

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Temporizador CEI como variable local de la interfaz del bloque (multiinstancia)
El temporizador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Timer();

Actualización de los valores actuales en los datos de instancia
Los datos de instancia de "Acumulador de tiempo" se actualizan siguiendo las reglas indicadas
a continuación:
● Entrada IN
La instrucción "Acumulador de tiempo" compara el RLO actual con el RLO de la consulta
anterior, que está almacenado en el parámetro IN de los datos de instancia. Si la instrucción
detecta un cambio del RLO de "0" a "1", significa que hay un flanco de señal ascendente y
se reanuda la medición de tiempo. Si la instrucción detecta un cambio de "1" a "0" en el
RLO, significa que hay un flanco de señal descendente y la medición de tiempo se
interrumpe. Una vez procesada la instrucción "Acumulador de tiempo", el valor del
parámetro IN se actualiza en los datos de instancia y se utiliza como marca de flancos para
la siguiente consulta.
Tenga en cuenta que la evaluación de flancos falla cuando el valor actual del parámetro IN
es escrito o inicializado por otras funciones.
● Entrada PT
El valor de la entrada PT se escribe en el parámetro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
● Entrada R
La señal "1" en la entrada R inicializa la medición de tiempo y la bloquea. Los flancos en la
entrada IN se ignoran. La señal "0" en la entrada R habilita de nuevo la medición de tiempo.
● Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
– Al llamar la instrucción, si las salidas ET o Q están interconectadas.
O bien:
– Al acceder a Q o ET.
Si las salidas no están interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucción se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan parámetros internos de la
instrucción "Acumulador de tiempo". Tenga en cuenta que la medición de tiempo falla
cuando los valores actuales de la instrucción son escritos o inicializados por otras
funciones.

Programación del PLC
Manual de programación y manejo, 11/2019

1781

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está midiendo el
tiempo, se interfiere en la función del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse daños materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐ Descripción
ria

IN

Input

BOOL

BOOL

I, Q, M, D, L, P

Entrada de
arranque

R

Input

BOOL

BOOL

I, Q, M, D, L, P

Inicializar los
parámetros ET
yQ

PT

Input

TIME

TIME, LTI‐
ME

I, Q, M, D, L, P

Tiempo máxi‐
mo de lectura
del tiempo.
El valor del pa‐
rámetro PT de‐
be ser positivo.

1782

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

S7-1200

Tipo de datos
S7-1500

Área de memo‐ Descripción
ria

Q

Output

BOOL

BOOL

I, Q, M, D, L, P

Operando que
permanece ac‐
tivado una vez
transcurrido el
tiempo PT.

ET

Output

TIME

TIME, LTI‐
ME

I, Q, M, D, L, P

Tiempo acumu‐
lado

Cronograma de impulsos
La figura siguiente muestra el cronograma de impulsos de la instrucción "Acumulador de
tiempo":
,1

5

4

37

(7

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"TONR_DB".TONR(IN := "Tag_Start",
R := "Tag_Reset",
PT := "Tag_PresetTime",
Q => "Tag_Status",
ET => "Tag_Time");

Programación del PLC
Manual de programación y manejo, 11/2019

1783

Instrucciones
4.1 Instrucciones
Cuando el estado lógico del operando "Tag_Start" cambia de "0" a "1", el tiempo programado
en el parámetro PT empieza a contar. Mientras transcurre el tiempo, se van acumulando los
valores de tiempo que se leen cuando el estado lógico del operando "Tag_Start" es "1". El
tiempo acumulado se almacena en el operando "Tag_Time". Una vez alcanzado el valor de
tiempo indicado en el parámetro PT, el operando "Tag_Status" adopta el estado lógico "1". El
valor de tiempo actual se guarda en el operando "Tag_Time".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

RESET_TIMER: Inicializar temporizador
Descripción
La instrucción "Inicializar temporizador" permite poner a "0" un temporizador CEI. Los
componentes de estructura del temporizador en el bloque de datos indicado se ponen a "0".

1784

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Actualización de los valores actuales
La instrucción no afecta al RLO. En el parámetro TIMER se asigna a la instrucción "Inicializar
temporizador" un temporizador CEI declarado en el programa. La instrucción se debe
programar dentro de una instrucción IF. Los datos de la instrucción se actualizan únicamente
al efectuar una llamada de la instrucción, y no cada vez que se accede al temporizador CEI
asignado. La consulta de datos es igual a la llamada de instrucción únicamente hasta la
siguiente llamada de instrucción.
PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está ejecutando
el temporizador, se interfiere en la función del temporizador CEI. Esto puede provocar
incoherencias entre el programa y el proceso real. Como consecuencia pueden producirse
daños materiales y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Programación del PLC
Manual de programación y manejo, 11/2019

1785

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro
<Temporizador
CEI>

Declaración
Output

Tipo de datos

Área de memo‐
ria

S7-1200

S7-1500

IEC_TI‐
MER, TP_TI‐
ME,
TON_TIME,
TOF_TIME,
TONR_TIME

IEC_TI‐
D, L
MER,
IEC_LTI‐
MER, TP_TI‐
ME, TP_LTI‐
ME,
TON_TIME,
TON_LTI‐
ME, TOF_TI‐
ME,
TOF_LTI‐
ME,
TONR_TI‐
ME,
TONR_LTI‐
ME

Descripción
Temporizador
CEI que se ini‐
cializa

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
IF #started = false THEN
"TON_DB".TON(IN := "Tag_Start",
PT := "Tag_PresetTime",
Q => "Tag_Status",
ET => "Tag_ElapsedTime");
#started := true;
END_IF;
IF "TON_DB".ET < T#25s THEN
RESET_TIMER(TIMER := "TON_DB");
#started := false;
END_IF;

Si la variable #started devuelve el estado lógico "0", se ejecuta la instrucción "Retardo al
conectar" cuando se produce un flanco de señal ascendente en el operando "Tag_Start". El
temporizador CEI depositado en el bloque de datos de instancia "TON_DB" arranca con el
tiempo predeterminado por el operando "Tag_PresetTime". El operando "Tag_Status" se
activa una vez transcurrido el tiempo predeterminado por el operando "Tag_PresetTime". El
parámetro Q permanecerá activado mientras el operando "Tag_Start" tenga el estado lógico
"1". Cuando el estado lógico de la entrada de arranque cambia de "1" a "0", se desactiva el
operando en el parámetro Q.

1786

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si el tiempo transcurrido del temporizador CEI "TON_DB" es inferior a 25 s, la instrucción
"Inicializar temporizador" se ejecuta y el temporizador depositado en el bloque de datos
instancia "TON_DB" se inicializa.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

PRESET_TIMER: Cargar tiempo
Descripción
La instrucción "Cargar tiempo" permite ajustar el tiempo de un temporizador CEI. La
instrucción se ejecuta en cada ciclo si el resultado lógico (RLO) de la entrada de la instrucción
tiene el estado lógico "1".
A la instrucción "Cargar tiempo" debe asignársele un temporizador CEI declarado en el
programa. La instrucción escribe el tiempo indicado en la estructura del temporizador CEI
indicado.
La instrucción no afecta al RLO.
Nota
Si el temporizador CEI indicado se ejecuta mientras se ejecuta la instrucción, esta sobrescribe
el tiempo actual del temporizador CEI indicado. Esto puede modificar el estado del
temporizador CEI.

Programación del PLC
Manual de programación y manejo, 11/2019

1787

Instrucciones
4.1 Instrucciones

Actualización de los valores actuales
La actualización de los datos de la instrucción se lleva a cabo cuando se llama la instrucción
y cada vez que se accede al temporizador CEI asignado. La consulta de Q o ET (p. ej.
"MyTimer".Q y "MyTimer".ET) actualiza la estructura de IEC_TIMER.
PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está ejecutando
el temporizador, se interfiere en la función del temporizador CEI. Esto puede provocar
incoherencias entre el programa y el proceso real. Como consecuencia pueden producirse
daños materiales y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

1788

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐
ria

Descripción

I, Q, M, D, L

Tiempo que
cuenta el tempo‐
rizador CEI.

<Tiempo>

Input

TIME

TIME, LTI‐
ME

<Temporizador
CEI>

Output

IEC_TI‐
MER, TP_TI‐
ME,
TON_TIME,
TOF_TIME,
TONR_TIME

D, L
IEC_TI‐
MER,
IEC_LTI‐
MER, TP_TI‐
ME, TP_LTI‐
ME,
TON_TIME,
TON_LTI‐
ME, TOF_TI‐
ME,
TOF_LTI‐
ME,
TONR_TI‐
ME,
TONR_LTI‐
ME

Temporizador
CEI cuyo tiempo
se ajusta.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
IF #started = false THEN
"TON_DB".TON(IN := "Tag_Start",
PT := "Tag_PresetTime",
Q => "Tag_Status",
ET => "Tag_ElapsedTime");
#started := true;
#preset = true
END_IF;
IF "TON_DB".ET < T#10s AND #preset = true THEN
PRESET_TIMER(PT := T#25s,
TIMER := "TON_DB");
#preset := false;
END_IF;

Si la variable #started tiene el estado lógico "0" y el operando "Tag_Start" tiene un flanco de
señal ascendente, se ejecuta la instrucción "Retardo al conectar". El temporizador CEI
depositado en el bloque de datos de instancia "TON_DB" arranca con el tiempo
predeterminado por el operando "Tag_PresetTime". El operando "Tag_Status" se activa una
vez transcurrido el tiempo PT especificado por el operando "Tag_PresetTime". El parámetro Q

Programación del PLC
Manual de programación y manejo, 11/2019

1789

Instrucciones
4.1 Instrucciones
permanecerá activado mientras el operando "Tag_Start" tenga el estado lógico "1". Cuando el
estado lógico de la entrada de arranque cambia de "1" a "0", se desactiva el operando en el
parámetro Q.
Si el tiempo transcurrido del temporizador CEI "TON_DB" es inferior a 10 s y la variable #preset
tiene el estado lógico "1", se ejecuta la instrucción "Cargar tiempo". La instrucción escribe el
tiempo indicado en el parámetro PT en el bloque de datos instancia "TON_DB" y sobrescribe
a la vez el valor de tiempo del operando "Tag_PresetTime" en el bloque de datos instancia.
Esto puede modificar el estado lógico del estado del temporizador en la siguiente consulta o en
el siguiente acceso a "TON_DB".Q o "TON_DB".ET.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Legacy
S_PULSE: Parametrizar y arrancar temporizador como impulso
Descripción
La instrucción "Parametrizar y arrancar temporizador como impulso" arranca el temporizador
programado en el parámetro T_NO cuando se detecta un cambio del resultado lógico (RLO) de
"0" a "1" (flanco de señal ascendente) en el parámetro S. El temporizador cuenta el tiempo
programado TV mientras el estado lógico del parámetro S sea "1".
Si el estado lógico del parámetro S cambia a "0" antes de que transcurra el tiempo programado,
el temporizador se detiene y el parámetro "Q" adopta el estado lógico "0".
El tiempo se compone internamente de un valor de tiempo y una base de tiempo y se programa
en el parámetro TV. Cuando se inicia la instrucción, el valor de tiempo programado se cuenta
hacia atrás hasta cero. La base de tiempo indica con qué periodo de tiempo se modifica el valor
de tiempo. El valor actual de tiempo se deposita en el parámetro BI.
Si el temporizador está contando y el estado lógico de la entrada R cambia a "1", el valor actual
de tiempo y la base de tiempo también se ponen a cero. Si el temporizador no está en marcha,
el estado lógico "1" de la entrada R no provoca ningún efecto.
El parámetro Q devuelve el estado lógico "1" mientras el temporizador está contando y el
estado lógico del parámetro S es "1". Si el estado lógico del parámetro S cambia a "0" antes
de que transcurra el tiempo programado, el parámetro Q devuelve el estado lógico "0". Si el
parámetro R resetea el temporizador o si el tiempo ha transcurrido, el parámetro Q también
devuelve el estado lógico "0".

1790

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los datos de la instrucción se actualizan con cada acceso. Por este motivo es posible que una
consulta de datos al principio del ciclo devuelva valores diferentes en comparación con el fin
del ciclo.
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
Encontrará un ejemplo de la estructura de una célula de temporización en: Consulte también
"L: Cargar valor del temporizador".

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

T_NO

Input

TIMER, INT

T

Temporizador que arranca.
El número de temporizado‐
res depende de la CPU.

S

Input

BOOL

I, Q, M, D, L

Entrada de arranque

TV

Input

S5TIME, WORD

I, Q, M, D, L

Valor de tiempo predetermi‐
nado

R

Input

BOOL

I, Q, M, D, L, P

Entrada de reset

Q

Output

BOOL

I, Q, M, D, L, P

Estado del temporizador

BI

Output

WORD

I, Q, M, D, L, P

Valor actual de tiempo en có‐
digo dual

S5TIME

I, Q, M, D, L

Valor de tiempo actual

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1791

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La imagen siguiente muestra el cronograma de impulsos de la instrucción "Parametrizar y
arrancar temporizador como impulso":
W

W

W

5/2HQODHQWUDGD6

5/2HQODHQWUDGD5

(OWLHPSRWUDQVFXUUH

&RQVXOWDಯಯ

&RQVXOWDಯಯ

W WLHPSRSURJUDPDGR

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := S_PULSE(T_NO := "Timer_1",
S := "Tag_1",
TV := "Tag_Number",
R := "Tag_Reset",
Q => "Tag_Status",
BI => "Tag_Value");

Cuando el estado lógico del operando "Tag_1" cambia de "0" a "1", el temporizador "Timer_1"
se pone en marcha. El temporizador empieza a contar con el valor de tiempo del operando
"Tag_Number" y sigue contando mientras el operando "Tag_1" devuelva el estado lógico "1".
Si el estado lógico del parámetro S cambia a "0" antes de que transcurra el tiempo programado,
el operando "Tag_Status" adopta el estado lógico "0". Si el parámetro R resetea el
temporizador o si el tiempo ha transcurrido, el operando "Tag_Status" también devuelve el
estado lógico "0".

1792

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El valor actual de tiempo se guarda en código dual en el operando "Tag_Value" y se devuelve
como valor de función.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
L: Cargar valor del temporizador (Página 1604)
Principios básicos de SCL (Página 8115)

S_PEXT: Parametrizar y arrancar temporizador como impulso prolongado
Descripción
La instrucción "Parametrizar y arrancar temporizador como impulso prolongado" arranca el
temporizador programado cuando se detecta un flanco de señal ascendente en el parámetro
S. El temporizador deja de contar el tiempo programado TV aunque el estado lógico del
parámetro S cambie a "0". Mientras el temporizador está contando, el parámetro Q devuelve
el estado lógico "1".
Una vez transcurrido el tiempo, el parámetro Q adopta el valor lógico "0". Si el estado lógico del
parámetro S cambia de "0" a "1" mientras el temporizador está contando, el temporizador se
inicia de nuevo con el tiempo programado en el parámetro TV.
El tiempo se compone internamente de un valor de tiempo y una base de tiempo y se programa
en el parámetro TV. Cuando se inicia la instrucción, el valor de tiempo programado se cuenta
hacia atrás hasta cero. La base de tiempo indica con qué periodo de tiempo se modifica el valor
de tiempo. El valor actual de tiempo se deposita en el parámetro BI.
Si el temporizador está contando y el estado lógico del parámetro R cambia a "1", el valor
actual de tiempo y la base de tiempo también se ponen a cero. Si el temporizador no está
contando, el estado lógico "1" en el parámetro R no tiene ningún efecto.
Los datos de la instrucción se actualizan con cada acceso. Por este motivo es posible que una
consulta de datos al principio del ciclo devuelva valores diferentes en comparación con el fin
del ciclo.
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
Encontrará un ejemplo de la estructura de una célula de temporización en: Consulte también
"L: Cargar valor del temporizador".

Programación del PLC
Manual de programación y manejo, 11/2019

1793

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declara‐
ción

Tipo de datos

Área de me‐
moria

Descripción

T_NO

Input

TIMER, INT

T

Temporizador que arranca.
El número de temporizadores de‐
pende de la CPU.

S

Input

BOOL

I, Q, M, D, L

Entrada de arranque

TV

Input

S5TIME,
WORD

I, Q, M, D, L

Valor de tiempo predeterminado

R

Input

BOOL

I, Q, M, D, L, P Entrada de reset

Q

Output

BOOL

I, Q, M, D, L, P Estado del temporizador

BI

Output

WORD

I, Q, M, D, L, P Valor actual de tiempo en código
dual

S5TIME

I, Q, M, D, L

Valor de función

Valor de tiempo actual

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1794

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La imagen siguiente muestra el cronograma de impulsos de la instrucción "Parametrizar y
arrancar temporizador como impulso prolongado":
W

W

W

W

5/2HQODHQWUDGD6

5/2HQODHQWUDGD5

7HPSRUL]DGRUHQPDUFKD

&RQVXOWD

&RQVXOWD
W WLHPSRSURJUDPDGR

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := S_PEXT(T_NO := "Timer_1",
S := "Tag_1",
TV := "Tag_Number",
R := "Tag_Reset",
Q => "Tag_Status",
BI => "Tag_Value");

Cuando el estado lógico del operando "Tag_1" cambia de "0" a "1", el temporizador "Timer_1"
se pone en marcha. Mientras el temporizador está en marcha, el operando "Tag_Status"
devuelve el estado lógico "1". Una vez transcurrido el tiempo, el operando "Tag_Status" adopta
el valor lógico "0". Si el estado lógico de la entrada S cambia de "0" a "1" mientras el
temporizador está contando, el temporizador se inicia de nuevo con el tiempo "Tag_Number".
El valor actual de tiempo se guarda en código dual en el operando "Tag_Value" y se devuelve
como valor de función.

Programación del PLC
Manual de programación y manejo, 11/2019

1795

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
L: Cargar valor del temporizador (Página 1604)
Principios básicos de SCL (Página 8115)

S_ODT: Parametrizar y arrancar temporizador como retardo a la conexión
Descripción
La instrucción "Parametrizar y arrancar temporizador como retardo a la conexión" arranca el
temporizador programado como retardo a la conexión cuando se detecta un flanco de señal
ascendente en el parámetro S. El temporizador cuenta el tiempo programado TV mientras el
estado lógico del parámetro S sea "1".
Si el tiempo ha transcurrido correctamente y el parámetro S sigue presentando el estado lógico
"1", el parámetro Q devuelve el estado lógico "1". Si el estado lógico del parámetro S cambia
de "1" a "0" mientras el temporizador está contando, este se detiene. En este caso, la salida Q
adopta el estado lógico "0".
El tiempo se compone internamente de un valor de tiempo y una base de tiempo y se programa
en el parámetro TV. Cuando se inicia la instrucción, el valor de tiempo programado se cuenta
hacia atrás hasta cero. La base de tiempo indica con qué periodo de tiempo se modifica el valor
de tiempo. El valor actual de tiempo se deposita en el parámetro BI.
Si el temporizador está contando y el estado lógico de la entrada R cambia de "0" a "1", el valor
actual de tiempo y la base de tiempo también se ponen a cero. En este caso, el estado lógico
del parámetro Q es "0". El temporizador se resetea si el parámetro R presenta el estado lógico
"1", aunque el temporizador no esté en marcha y el resultado lógico (RLO) del parámetro S sea
"1".
Los datos de la instrucción se actualizan con cada acceso. Por este motivo es posible que una
consulta de datos al principio del ciclo devuelva valores diferentes en comparación con el fin
del ciclo.
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
Encontrará un ejemplo de la estructura de una célula de temporización en: Consulte también
"L: Cargar valor del temporizador".

1796

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declara‐
ción

Tipo de datos

Área de memoria Descripción

T_NO

Input

TIMER, INT

T

Temporizador que arranca.
El número de temporizadores
depende de la CPU.

S

Input

BOOL

I, Q, M, D, L

Entrada de arranque

TV

Input

S5TIME,
WORD

I, Q, M, D, L

Valor de tiempo predetermina‐
do

R

Input

BOOL

I, Q, M, D, L, P

Entrada de reset

Q

Output

BOOL

I, Q, M, D, L, P

Estado del temporizador

BI

Output

WORD

I, Q, M, D, L, P

Valor actual de tiempo en códi‐
go dual

S5TIME

I, Q, M, D, L

Valor de tiempo actual

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Cronograma de impulsos
La imagen siguiente muestra el cronograma de impulsos de la instrucción "Parametrizar y
arrancar temporizador como retardo a la conexión":
W

W

W

5/2HQODHQWUDGD6

5/2HQODHQWUDGD5

(OWLHPSRWUDQVFXUUH

&RQVXOWDಯಯ

&RQVXOWDಯಯ
W WLHPSRSURJUDPDGR

Programación del PLC
Manual de programación y manejo, 11/2019

1797

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := S_ODT(T_NO := "Timer_1",
S := "Tag_1",
TV := "Tag_Number",
R := "Tag_Reset",
Q => "Tag_Status",
BI => "Tag_Value");

Cuando el estado lógico del operando "Tag_1" cambia de "0" a "1", el temporizador "Timer_1"
se pone en marcha. El temporizador cuenta el tiempo "Tag_Number" mientras el estado lógico
del operando "Tag_1" sea "1".
Si el tiempo ha transcurrido correctamente y el operando "Tag_Status" presenta el estado
lógico "1", el operando "Tag_Status" se pone a "1". Si el estado lógico del operando "Tag_1"
cambia de "1" a "0" mientras el temporizador está contando, este se detiene. El operando
"Tag_Status" devuelve en ese caso el estado lógico "0".
El valor actual de tiempo se guarda en código dual en el operando "Tag_Value" y se devuelve
como valor de función.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
L: Cargar valor del temporizador (Página 1604)
Principios básicos de SCL (Página 8115)

S_ODTS: Parametrizar y arrancar temporizador como retardo a la conexión con memoria
Descripción
La instrucción "Parametrizar y arrancar temporizador como retardo a la conexión con
memoria" arranca el temporizador programado cuando se detecta un flanco de señal
ascendente en el parámetro S. El temporizador deja de contar el tiempo programado TV
aunque el estado lógico del parámetro S cambie a "0".
Una vez transcurrido el tiempo, el parámetro Q devuelve el estado lógico "1"
independientemente del estado lógico del parámetro S. Si el estado lógico del parámetro S
cambia de "0" a "1" mientras el temporizador está contando, el temporizador se inicia de nuevo
con el tiempo programado TV.
El tiempo se compone internamente de un valor de tiempo y una base de tiempo y se programa
en el parámetro TV. Cuando se inicia la instrucción, el valor de tiempo programado se cuenta
hacia atrás hasta cero. La base de tiempo indica con qué periodo de tiempo se modifica el valor
de tiempo. El valor actual de tiempo se deposita en el parámetro BI.
El estado lógico "1" del parámetro R pone a "0" el valor actual de tiempo y la base de tiempo,
independientemente del estado lógico del parámetro S. En este caso, el estado lógico del
parámetro Q es "0".

1798

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los datos de la instrucción se actualizan con cada acceso. Por este motivo es posible que una
consulta de datos al principio del ciclo devuelva valores diferentes en comparación con el fin
del ciclo.
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
Encontrará un ejemplo de la estructura de una célula de temporización en: Consulte también
"L: Cargar valor del temporizador".

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declara‐
ción

Tipo de datos

Área de memoria

Descripción

T_NO

Input

TIMER, INT

T

Temporizador que arranca.
El número de temporizadores
depende de la CPU.

S

Input

BOOL

I, Q, M, D, L

Entrada de arranque

TV

Input

S5TIME,
WORD

I, Q, M, D, L

Valor de tiempo predetermina‐
do

R

Input

BOOL

I, Q, M, D, L, P

Entrada de reset

Q

Output

BOOL

I, Q, M, D, L, P

Estado del temporizador

BI

Output

WORD

I, Q, M, D, L, P

Valor actual de tiempo en có‐
digo dual

S5TIME

I, Q, M, D, L

Valor de tiempo actual

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1799

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La imagen siguiente muestra el cronograma de impulsos de la instrucción "Parametrizar y
arrancar temporizador como retardo a la conexión con memoria":
W

W

W

W

5/2HQODHQWUDGD6

5/2HQODHQWUDGD5

(OWLHPSRWUDQVFXUUH

&RQVXOWDಯಯ
&RQVXOWDಯಯ
W WLHPSRSURJUDPDGR

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := S_ODTS(T_NO := "Timer_1",
S := "Tag_1",
TV := "Tag_Number",
R := "Tag_Reset",
Q => "Tag_Status",
BI => "Tag_Value");

Cuando el estado lógico del operando "Tag_1" cambia de "0" a "1", el temporizador "Timer_1"
se pone en marcha. El temporizador cuenta el tiempo "Tag_Number".
Una vez transcurrido el tiempo, el operando "Tag_Status" devuelve el estado lógico "1"
independientemente del estado lógico del operando "Tag_1". Si el estado lógico del operando
"Tag_1" cambia de "0" a "1" mientras el temporizador está contando, el temporizador se inicia
de nuevo con el tiempo "Tag_Number".
El valor actual de tiempo se guarda en código dual en el operando "Tag_Value" y se devuelve
como valor de función.

1800

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
L: Cargar valor del temporizador (Página 1604)
Principios básicos de SCL (Página 8115)

S_OFFDT: Parametrizar y arrancar temporizador como retardo a la desconexión
Descripción
La instrucción "Parametrizar y arrancar temporizador como retardo a la desconexión" arranca
el temporizador programado cuando se detecta un flanco de señal descendente en el
parámetro S. El temporizador cuenta el tiempo programado TV. Mientras el temporizador está
contando o el parámetro S devuelve el estado lógico "1", el parámetro Q presenta el estado
lógico "1".
Si el tiempo ha transcurrido y el estado lógico es "0", el parámetro Q adopta el valor lógico "0".
Si el estado lógico del parámetro S cambia de "0" a "1" mientras el temporizador está en
marcha, este se detiene. El temporizador solo arranca de nuevo cuando se detecta un flanco
de señal descendente en el parámetro S.
El tiempo se compone internamente de un valor de tiempo y una base de tiempo y se programa
en el parámetro TV. Cuando se inicia la instrucción, el valor de tiempo programado se cuenta
hacia atrás hasta cero. La base de tiempo indica con qué periodo de tiempo se modifica el valor
de tiempo. El valor actual de tiempo se deposita en el parámetro BI.
El estado lógico "1" del parámetro R pone a "0" el valor actual de tiempo y la base de tiempo.
En este caso, el estado lógico del parámetro Q es "0".
Los datos de la instrucción se actualizan con cada acceso. Por este motivo es posible que una
consulta de datos al principio del ciclo devuelva valores diferentes en comparación con el fin
del ciclo.
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
Encontrará un ejemplo de la estructura de una célula de temporización en: Consulte también
"L: Cargar valor del temporizador".

Programación del PLC
Manual de programación y manejo, 11/2019

1801

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declara‐
ción

Tipo de datos

Área de memo‐ Descripción
ria

T_NO

Input

TIMER, INT

T

Temporizador que arranca.
El número de temporizadores
depende de la CPU.

S

Input

BOOL

I, Q, M, D, L

Entrada de arranque

TV

Input

S5TIME,
WORD

I, Q, M, D, L

Valor de tiempo predeterminado

R

Input

BOOL

I, Q, M, D, L, P

Entrada de reset

Q

Output

BOOL

I, Q, M, D, L, P

Estado del temporizador

BI

Output

WORD

I, Q, M, D, L, P

Valor actual de tiempo en códi‐
go dual

S5TIME

I, Q, M, D, L

Valor de tiempo actual

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Cronograma de impulsos
La imagen siguiente muestra el cronograma de impulsos de la instrucción "Parametrizar y
arrancar temporizador como retardo a la desconexión":
W

W

W

W

5/2HQODHQWUDGD6

5/2HQODHQWUDGD5

7HPSRUL]DGRUHQPDUFKD

&RQVXOWD

&RQVXOWD
W WLHPSRSURJUDPDGR

1802

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := S_OFFDT(T_NO := "Timer_1",
S := "Tag_1",
TV := "Tag_Number",
R := "Tag_Reset",
Q => "Tag_Status",
BI => "Tag_Value");

Cuando el estado lógico del operando "Tag_1" cambia de "1" a "0", el temporizador "Timer_1"
arranca. El temporizador cuenta el tiempo "Tag_Number". Mientras el temporizador está
contando o el operando "Tag_1" devuelve el estado lógico "1", el operando "Tag_Status"
presenta el estado lógico "1".
Si el tiempo ha transcurrido y el estado lógico del operando "Tag_1" es "0", el operando
"Tag_Status" adopta el valor lógico "0". Si el estado lógico del operando "Tag_1" cambia de "0"
a "1" mientras el temporizador está en marcha, el temporizador se reinicia. El temporizador
solo arranca de nuevo cuando se detecta un flanco descendente en el parámetro S.
El valor actual de tiempo se guarda en código dual en el operando "Tag_Value" y se devuelve
como valor de función.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
L: Cargar valor del temporizador (Página 1604)
Principios básicos de SCL (Página 8115)

Contadores
Llamada de contadores CEI
Descripción
Existe la posibilidad de declarar el contador CEI como instancia individual o multiinstancia y
llamarlo en el código del programa.
Están disponibles las siguientes posibilidades sintácticas para la declaración de un contador
CEI como multiinstancia dentro de una estructura de la interfaz del bloque:

Programación del PLC
Manual de programación y manejo, 11/2019

1803

Instrucciones
4.1 Instrucciones

Contador CEI como elemento ARRAY
Declaración en la interfaz del bloque:

Código del programa:
SCL
#MyARRAY[1].CTU(CU := <Operando>, PV := <Operando>)

Declaración en la interfaz del bloque:

Código del programa:
SCL
#MyARRAY[#index](CU := <Operando>, PV := <Operando>)

Contador CEI en una estructura anónima
Declaración en la interfaz del bloque:

Código del programa:
SCL
#MyStruct.FirstTime.CTU(CU := <Operando>, PV := <Operando>)

Declaración en la interfaz del bloque:

1804

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Código del programa:
SCL
#MyStruct.FirstTime(CU := <Operando>, PV := <Operando>)

Contador CEI en el bloque de datos global
Declaración en el bloque de datos:

Código del programa:
SCL
"MyGlobalDB".Counter.FirstCount.CTU(CU := <Operando>, PV := <Operando>)

Declaración en el bloque de datos:

Programación del PLC
Manual de programación y manejo, 11/2019

1805

Instrucciones
4.1 Instrucciones

Código del programa:
SCL
"MyGlobalDB".Counter.SecondCount(CU := <Operando>, PV := <Operando>)

Contador CEI como elemento en la interfaz del bloque
Declaración en la interfaz del bloque:

Código del programa:
SCL
#Counter.FirstCount.CTU(CU := <Operando>, PV := <Operando>)

Declaración en la interfaz del bloque:

1806

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Código del programa:
SCL
#Counter.SecondCount(CU := <Operando>, PV := <Operando>)

Contador CEI en un DB de ARRAY
Declaración en el DB de ARRAY:

Código del programa:
SCL
"MyARRAYDB"."THIS"[0].FirstCount.CTU(CU := <Operando>, PV := <Operando>)

Declaración en el DB de ARRAY:

Programación del PLC
Manual de programación y manejo, 11/2019

1807

Instrucciones
4.1 Instrucciones

Código del programa:
SCL
"MyARRAYDB"."THIS"[0].SecondCount(CU := <Operando>, PV := <Operando>)

CTU: Contador ascendente
Descripción
La instrucción "Contador ascendente" incrementa el valor del parámetro CV. Cuando el estado
lógico del parámetro CU cambia de "0" a "1" (flanco de señal ascendente), se ejecuta la
instrucción y el valor de contaje actual del parámetro CV se incrementa en uno. El valor de
contaje se incrementa cada vez que se detecta un flanco de señal ascendente, hasta alcanzar
el valor límite superior del tipo de datos indicado en el parámetro CV. Cuando se alcanza el
valor límite superior, el estado lógico del parámetro CU deja de tener efecto en la instrucción.
El estado del contador se puede consultar en el parámetro Q. El estado lógico del parámetro
Q es determinado por el parámetro PV. Si el valor de contaje actual es mayor o igual al valor
del parámetro PV, el parámetro Q adopta el estado lógico "1". En los restantes casos, el estado
lógico del parámetro Q es "0". En el parámetro PV también se puede indicar una constante.
El valor del parámetro CV se pone a cero cuando el estado lógico del parámetro R cambia a
"1". Mientras el parámetro R tenga el estado lógico "1", el estado lógico del parámetro CU no
tendrá efecto alguno en la instrucción.
Nota
Utilice el contador en una sola posición del programa para evitar fallos de contaje.
A cada llamada de la instrucción "Contador ascendente" debe asignársele un contador CEI, en
el que se guarden los datos de la instrucción. Un contador CEI es una estructura con uno de
los tipos de datos siguientes:

1808

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Para las CPU de la serie S7-1200
Bloque de datos del tipo de datos de sistema
IEC_<Contador> (Shared DB)

Variable local

● IEC_SCOUNTER / IEC_USCOUNTER

● CTU_SINT / CTU_USINT

● IEC_COUNTER / IEC_UCOUNTER

● CTU_INT / CTU_UINT

● IEC_DCOUNTER / IEC_UDCOUNTER

● CTU_DINT / CTU_UDINT

Para las CPU de la serie S7-1500
Bloque de datos del tipo de datos de sistema
IEC_<Contador> (Shared DB)

Variable local

● IEC_SCOUNTER / IEC_USCOUNTER

● CTU_SINT / CTU_USINT

● IEC_COUNTER / IEC_UCOUNTER

● CTU_INT / CTU_UINT

● IEC_DCOUNTER / IEC_UDCOUNTER

● CTU_DINT / CTU_UDINT

● IEC_LCOUNTER / IEC_ULCOUNTER

● CTU_LINT / CTU_ULINT

Un contador CEI se puede declarar del modo siguiente:
● Declaración de un bloque de datos de instancia del tipo de datos de sistema
IEC_<nombre_del_contador> (p. ej. "MyIEC_COUNTER_DB")
● Declaración como variable local del tipo de datos CTU_<tipo de datos> en la sección
"Static" de un bloque de programa (p. ej., #MyIEC_COUNTER_Instance)
Si el contador CEI se crea en un bloque de datos propio (instancia individual), el bloque de
datos de instancia se crea de forma estándar con "acceso optimizado al bloque" y las distintas
variables se declaran remanentes.
Si el contador CEI se crea como variable local (multiinstancia) en un bloque de función con
"acceso optimizado al bloque", esta se declara remanente en la interfaz del bloque.

Contador CEI como bloque de datos del tipo de datos de sistema IEC_<Nombre_del_contador> (Shared
DB)
Un contador CEI se puede declarar como bloque de datos del modo siguiente:
<IEC_contador_DB>.CTU();

Contador CEI como variable local de la interfaz del bloque (multiinstancia)
El contador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Counter();
Encontrará información sintáctica sobre la llamada de contadores CEI en estructuras
(multiinstancia) aquí: Llamada de contadores CEI (Página 1803)

Programación del PLC
Manual de programación y manejo, 11/2019

1809

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

CU

Input

R

Input

PV

Tipo de datos

Área de memoria

Descripción

BOOL

I, Q, M, D, L

Entrada de contaje

BOOL

I, Q, M, D, L, P

Entrada de reset

Input

Enteros

I, Q, M, D, L, P

Valor con el que se activa la
salida Q

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"IEC_COUNTER_DB".CTU(CU := "Tag_Start",
R := "Tag_Reset",
PV := "Tag_PresetValue",
Q => "Tag_Status",
CV => "Tag_CounterValue");

Cuando el estado lógico del operando "Tag_Start" cambia de "0" a "1", se ejecuta la instrucción
"Contador ascendente" y el valor de contaje actual del operando "Tag_CounterValue" se
incrementa en uno. Con cada flanco de señal ascendente posterior, el valor de contaje irá
incrementando hasta alcanzar el valor límite superior del tipo de datos indicado (INT = 32767).
La salida "Tag_Status" devuelve el estado lógico "1" mientras el valor de contaje actual sea
mayor o igual que el valor del operando "Tag_PresetValue". En todos los demás casos, la
salida "Tag_Status" devuelve el estado lógico "0". El valor de contaje actual se guarda en el
operando "Tag_CounterValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Ajustar la remanencia en un bloque de datos de instancia (Página 7855)
Principios básicos de SCL (Página 8115)

1810

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CTD: Contador descendente
Descripción
La instrucción "Contador descendente" decrementa el valor del parámetro CV. Cuando el
estado lógico del parámetro CD cambia de "0" a "1" (flanco de señal ascendente), se ejecuta
la instrucción y el valor de contaje actual del parámetro CV se decrementa en uno. Cada vez
que se detecta un flanco de señal ascendente, el valor de contaje se decrementa hasta
alcanzar el valor límite inferior del tipo de datos indicado. Cuando se alcanza el valor límite
inferior, el estado lógico del parámetro CD deja de tener efecto en la instrucción.
El estado del contador se puede consultar en el parámetro Q. Si el valor de contaje actual es
menor o igual a cero, el parámetro Q adopta el estado lógico "1". En los restantes casos, el
estado lógico del parámetro Q es "0". En el parámetro PV también se puede indicar una
constante.
El valor del parámetro CV se pone al valor del parámetro PV cuando el estado lógico del
parámetro LD cambia a "1". Mientras el parámetro LD tenga el estado lógico "1", el estado
lógico del parámetro CD no tendrá efecto alguno en la instrucción.
Nota
Utilice el contador en una sola posición del programa para evitar fallos de contaje.
A cada llamada de la instrucción "Contador descendente" debe asignársele un contador CEI,
en el que se guarden los datos de la instrucción. Un contador CEI es una estructura con uno
de los tipos de datos siguientes:

Para las CPU de la serie S7-1200
Bloque de datos del tipo de datos de sistema
IEC_<Contador> (Shared DB)

Variable local

● IEC_SCOUNTER / IEC_USCOUNTER

● CTD_SINT / CTD_USINT

● IEC_COUNTER / IEC_UCOUNTER

● CTD_INT / CTD_UINT

● IEC_DCOUNTER / IEC_UDCOUNTER

● CTD_DINT / CTD_UDINT

Para las CPU de la serie S7-1500
Bloque de datos del tipo de datos de sistema
IEC_<Contador> (Shared DB)

Variable local

● IEC_SCOUNTER / IEC_USCOUNTER

● CTD_SINT / CTD_USINT

● IEC_COUNTER / IEC_UCOUNTER

● CTD_INT / CTD_UINT

● IEC_DCOUNTER / IEC_UDCOUNTER

● CTD_DINT / CTD_UDINT

● IEC_LCOUNTER / IEC_ULCOUNTER

● CTD_LINT / CTD_ULINT

Programación del PLC
Manual de programación y manejo, 11/2019

1811

Instrucciones
4.1 Instrucciones
Un contador CEI se puede declarar del modo siguiente:
● Declaración de un bloque de datos de instancia del tipo de datos de sistema
IEC_<nombre_del_contador> (p. ej. "MyIEC_COUNTER_DB")
● Declaración como variable local del tipo de datos CTD_<tipo de datos> en la sección
"Static" de un bloque de programa (p. ej., #MyIEC_COUNTER_Instance)
Si el contador CEI se crea en un bloque de datos propio (instancia individual), el bloque de
datos de instancia se crea de forma estándar con "acceso optimizado al bloque" y las distintas
variables se declaran remanentes.
Si el contador CEI se crea como variable local (multiinstancia) en un bloque de función con
"acceso optimizado al bloque", esta se declara remanente en la interfaz del bloque.

Contador CEI como bloque de datos del tipo de datos de sistema IEC_<Nombre_del_contador> (Shared
DB)
Un contador CEI se puede declarar como bloque de datos del modo siguiente:
<IEC_Nombre_del_contador_DB>.CTD();

Contador CEI como variable local de la interfaz del bloque (multiinstancia)
El contador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Counter();
Encontrará información sintáctica sobre la llamada de contadores CEI en estructuras
(multiinstancia) aquí: Llamada de contadores CEI (Página 1803)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:

1812

Parámetro

Declaración

CD

Input

LD
PV

Tipo de datos

Área de memoria

Descripción

BOOL

I, Q, M, D, L

Entrada de contaje

Input

BOOL

I, Q, M, D, L, P

Entrada de carga

Input

Enteros

I, Q, M, D, L, P

Valor al que se pone la salida
CV cuando LD = 1.

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"IEC_SCOUNTER_DB".CTD(CD := "Tag_Start",
LD := "Tag_Load",
PV := "Tag_PresetValue",
Q => "Tag_Status",
CV => "Tag_CounterValue");

Cuando el estado lógico del operando "Tag_Start" cambia de "0" a "1", la instrucción se ejecuta
y el valor del operando "Tag_CounterValue" se decrementa en uno. Con cada flanco de señal
ascendente posterior, el valor de contaje irá decrementando hasta alcanzar el valor límite
inferior del tipo de datos indicado (-128).
El operando "Tag_Status" devuelve el estado lógico "1" mientras el valor del contador actual
sea menor o igual a cero. En todos los demás casos, la salida "Tag_Status" devuelve el estado
lógico "0". El valor de contaje actual se guarda en el operando "Tag_CounterValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Ajustar la remanencia en un bloque de datos de instancia (Página 7855)
Principios básicos de SCL (Página 8115)

CTUD: Contador ascendente - descendente
Descripción
La instrucción "Contador ascendente - descendente" incrementa y decrementa el valor de
contaje del parámetro CV. Cuando el estado lógico del parámetro CU cambia de "0" a "1"
(flanco de señal ascendente), el valor de contaje actual del parámetro CV se incrementa en
uno. Cuando el estado lógico del parámetro CD cambia de "0" a "1" (flanco de señal
ascendente), el valor de contaje del parámetro CV se decrementa en uno. Si en un ciclo del
programa se detecta un flanco de señal ascendente en las entradas CU y CD, el valor de
contaje actual no cambia en el parámetro CV.
El valor de contaje se puede seguir incrementando hasta alcanzar el valor límite superior del
tipo de datos indicado en el parámetro CV. Una vez alcanzado el valor límite superior, el valor
de contaje no se incrementa más aunque se detecte un flanco de señal ascendente. Cuando
se alcanza el valor límite inferior del tipo de datos indicado, ya no se decrementa el valor de
contaje.
Cuando el estado lógico del parámetro LD cambia a "1", el valor de contaje del parámetro CV
se pone al valor del parámetro PV. Mientras el parámetro LD tenga el estado lógico "1", el
estado lógico de los parámetros CU y CD no tendrá efecto alguno en la instrucción.
El valor de contaje se pone a cero cuando el estado lógico del parámetro R cambia a "1".
Mientras el estado lógico del parámetro R sea "1", un cambio del estado lógico de los
parámetros CU, CD y LD no tendrá efecto alguno en la instrucción "Contador ascendente descendente".

Programación del PLC
Manual de programación y manejo, 11/2019

1813

Instrucciones
4.1 Instrucciones
El estado del contador ascendente se puede consultar en el parámetro QU. Si el valor de
contaje actual es mayor o igual al valor del parámetro PV, el parámetro QU adopta el estado
lógico "1". En los restantes casos, el estado lógico del parámetro QU es "0". En el parámetro
PV también se puede indicar una constante.
El estado del contador descendente se puede consultar en el parámetro QD. Si el valor de
contaje actual es menor o igual a cero, el parámetro QD adopta el estado lógico "1". En los
restantes casos, el estado lógico del parámetro QD es "0".
Nota
Utilice el contador en una sola posición del programa para evitar fallos de contaje.
A cada llamada de la instrucción "Contador ascendente - descendente" debe asignársele un
contador CEI en el que se guarden los datos de la instrucción. Un contador CEI es una
estructura con uno de los tipos de datos siguientes:

Para las CPU de la serie S7-1200
Bloque de datos del tipo de datos de sistema
IEC_<Contador> (Shared DB)

Variable local

● IEC_SCOUNTER / IEC_USCOUNTER

● CTUD_SINT / CTUD_USINT

● IEC_COUNTER / IEC_UCOUNTER

● CTUD_INT / CTUD_UINT

● IEC_DCOUNTER / IEC_UDCOUNTER

● CTUD_DINT / CTUD_UDINT

Para las CPU de la serie S7-1500
Bloque de datos del tipo de datos de sistema
IEC_<Contador> (Shared DB)

Variable local

● IEC_SCOUNTER / IEC_USCOUNTER

● CTUD_SINT / CTUD_USINT

● IEC_COUNTER / IEC_UCOUNTER

● CTUD_INT / CTUD_UINT

● IEC_DCOUNTER / IEC_UDCOUNTER

● CTUD_DINT / CTUD_UDINT

● IEC_LCOUNTER / IEC_ULCOUNTER

● CTUD_LINT / CTUD_ULINT

Un contador CEI se puede declarar del modo siguiente:
● Declaración de un bloque de datos de instancia del tipo de datos de sistema
IEC_<nombre_del_contador> (p. ej. "MyIEC_COUNTER_DB")
● Declaración como variable local del tipo de datos CTUD_<tipo de datos> en la sección
"Static" de un bloque de programa (p. ej., #MyCTUD_COUNTER_Instance)
Si el contador CEI se crea en un bloque de datos propio (instancia individual), el bloque de
datos de instancia se crea de forma estándar con "acceso optimizado al bloque" y las distintas
variables se declaran remanentes.
Si el contador CEI se crea como variable local (multiinstancia) en un bloque de función con
"acceso optimizado al bloque", esta se declara remanente en la interfaz del bloque.

1814

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Contador CEI como bloque de datos del tipo de datos de sistema IEC_<Nombre_del_contador> (Shared
DB)
Un contador CEI se puede declarar como bloque de datos del modo siguiente:
<IEC_Nombre_del_contador_DB>.CTUD();

Contador CEI como variable local de la interfaz del bloque (multiinstancia)
El contador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Counter();
Encontrará información sintáctica sobre la llamada de contadores CEI en estructuras
(multiinstancia) aquí: Llamada de contadores CEI (Página 1803)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

CU

Input

CD

Tipo de datos

Área de memoria

Descripción

BOOL

I, Q, M, D, L

Entrada de contaje ascen‐
dente

Input

BOOL

I, Q, M, D, L

Entrada de contaje descen‐
dente

R

Input

BOOL

I, Q, M, D, L, P

Entrada de reset

LD

Input

BOOL

I, Q, M, D, L, P

Entrada de carga

PV

Input

Enteros

I, Q, M, D, L, P

Valor con el que se activa la
salida QU. / Valor al que se
pone la salida CV cuando LD
= 1.

QU

Output

BOOL

I, Q, M, D, L

Estado del contador ascen‐
dente

QD

Output

BOOL

I, Q, M, D, L

Estado del contador descen‐
dente

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"IEC_COUNTER_DB".CTUD(CU := "Tag_Start1",
CD := "Tag_Start2",
LD := "Tag_Load",
R := "Tag_Reset",
PV := "Tag_PresetValue",
QU => "Tag_CU_Status",
QD => "Tag_CD_Status",
CV => "Tag_CounterValue");

Programación del PLC
Manual de programación y manejo, 11/2019

1815

Instrucciones
4.1 Instrucciones
Cuando se detecta un flanco de señal ascendente en el estado lógico del operando
"Tag_Start1", el valor actual del contador se incrementa en uno y se deposita en el operando
"Tag_CounterValue". Cuando se detecta un flanco de señal ascendente en el estado lógico del
operando "Tag_Start2", el valor del contador se decrementa en uno y se deposita también en
el operando "Tag_CounterValue". Cuando se detecta un flanco de señal ascendente en el
parámetro CU, el valor del contador se va incrementando hasta alcanzar el valor límite superior
del tipo de datos indicado (INT). Cuando se detecta un flanco de señal ascendente en el
parámetro CD, el valor del contador se va decrementando hasta alcanzar el valor límite inferior
del tipo de datos indicado (INT).
El operando "Tag_CU_Status" devuelve el estado lógico "1" mientras el valor de contaje actual
sea mayor o igual al valor del operando "Tag_PresetValue". En todos los demás casos, la
salida "Tag_CU_Status" devuelve el estado lógico "0".
El operando "Tag_CD_Status" devuelve el estado lógico "1" mientras el valor del contador
actual sea menor o igual a cero. En todos los demás casos, la salida "Tag_CD_Status"
devuelve el estado lógico "0".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Ajustar la remanencia en un bloque de datos de instancia (Página 7855)
Principios básicos de SCL (Página 8115)

Legacy
S_CU: Parametrizar e incrementar contador
Descripción
La instrucción "Parametrizar e incrementar contador" permite incrementar el valor de un
contador. Si el estado lógico del parámetro CU cambia de "0" a "1" (flanco de señal
ascendente), el valor de contaje actual se incrementa en uno. El valor de contaje actual se
deposita en el parámetro CV. El valor de contaje sigue incrementando hasta alcanzar el límite
de "999". Una vez alcanzado el valor límite, el valor de contaje no se incrementa más aunque
se detecte un flanco de señal ascendente.
Cuando el estado lógico del parámetro S cambia de "0" a "1", el valor de contaje adopta el valor
del parámetro PV. Si el contador se activa y el resultado lógico (RLO) de la entrada CU es "1",
el contador cuenta una única vez en el ciclo siguiente aunque no se detecte ningún cambio de
flanco.
El valor de contaje se pone a cero cuando el estado lógico del parámetro R cambia a "1".
Mientras el estado lógico del parámetro R sea "1", un cambio en el estado lógico de los
parámetros CU y S no tiene ningún efecto sobre el valor de contaje.

1816

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El estado lógico del parámetro Q es "1" si el valor de contaje es mayor que cero. Si el valor de
contaje es igual a cero, el parámetro Q devuelve el estado lógico "0".
Nota
Utilice el contador en una sola posición del programa para evitar fallos de contaje.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

C_NO

Input

COUNTER, INT

C

Contador
El número de contadores de‐
pende de la CPU.

CU

Input

BOOL

I, Q, M, D, L

Entrada de contaje ascen‐
dente

S

Input

BOOL

I, Q, M, D, L

Entrada para preajustar el
contador

PV

Input

WORD

I, Q, M, D, L

Valor de contaje predetermi‐
nado (C#0 a C#999) en for‐
mato BCD

R

Input

BOOL

I, Q, M, D, L

Entrada de reset

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

WORD

I, Q, M, D, L

Valor de contaje actual

WORD

I, Q, M, D, L

Valor de contaje actual en
formato BCD

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := S_CU(C_NO := "Counter_1",
CU := "Tag_Start",
S := "Tag_1",
PV := "Tag_PresetValue",
R := "Tag_Reset",
Q => "Tag_Status",
CV => "Tag_Value");

Cuando el estado lógico del parámetro "Tag_Start" cambia de "0" a "1" (flanco de señal
ascendente) y el valor de contaje actual es menor que "999", este valor se incrementará en
uno. Si el estado lógico de la entrada "Tag_1" cambia de "0" a "1", el valor de contaje en formato
BCD se pone al valor del operando "Tag_PresetValue". El valor de contaje se pone a "0" si el
operando "Tag_Reset" tiene el estado lógico "1".

Programación del PLC
Manual de programación y manejo, 11/2019

1817

Instrucciones
4.1 Instrucciones
El valor de contaje actual se almacena en formato hexadecimal en el operando "Tag_Value".
La salida "Tag_Status" devuelve el estado lógico "1" mientras el valor de contaje actual sea
diferente a "0". El valor actual de contaje se guarda en el operando "Tag_Value" y se devuelve
como valor de función.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

S_CD: Parametrizar y decrementar contador
Descripción
La instrucción "Parametrizar y decrementar contador" permite decrementar el valor de un
contador. Si el estado lógico del parámetro CD cambia de "0" a "1" (flanco de señal
ascendente), el valor de contaje se decrementa en uno. El valor de contaje actual se deposita
en el parámetro CV. El valor de contaje sigue decrementando hasta alcanzar el límite inferior
"0". Una vez alcanzado el valor límite, el valor de contaje no se decrementa más al detectarse
un flanco de señal ascendente.
Cuando el estado lógico del parámetro S cambia de "0" a "1", el valor de contaje adopta el valor
del parámetro PV. Si el contador se activa y el resultado lógico (RLO) del parámetro CD es "1",
el contador cuenta una única vez en el ciclo siguiente aunque no se detecte ningún cambio de
flanco.
El valor de contaje se pone a cero cuando el estado lógico del parámetro R cambia a "1".
Mientras el estado lógico del parámetro R sea "1", un cambio en el estado lógico de los
parámetros CD y S no tiene ningún efecto sobre el valor de contaje.
El estado lógico del parámetro Q es "1" si el valor de contaje es mayor que cero. Si el valor de
contaje es igual a cero, el parámetro Q devuelve el estado lógico "0".
Nota
Utilice el contador en una sola posición del programa para evitar fallos de contaje.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

C_NO

Input

COUNTER, INT

C

Contador
El número de contadores de‐
pende de la CPU.

1818

CD

Input

BOOL

I, Q, M, D, L

Entrada de contaje descen‐
dente

S

Input

BOOL

I, Q, M, D, L

Entrada para preajustar el
contador

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

PV

Input

WORD

I, Q, M, D, L

Valor de contaje predetermi‐
nado (C#0 a C#999) en for‐
mato BCD

R

Input

BOOL

I, Q, M, D, L

Entrada de reset

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

WORD

I, Q, M, D, L

Valor de contaje actual

WORD

I, Q, M, D, L

Valor de contaje actual en
formato BCD

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := S_CD(C_NO := "Counter_1",
CD := "Tag_Start",
S := "Tag_1",
PV := "Tag_PresetValue",
R := "Tag_Reset",
Q => "Tag_Status",
CV => "Tag_Value");

Cuando el estado lógico del operando "Tag_Start" cambia de "0" a "1" (flanco de señal
ascendente) y el valor de contaje actual es superior a "0", el valor de contaje se decrementa en
uno. Cuando el estado lógico del operando "Tag_1" cambia de "0" a "1", el valor de contaje
adopta el valor del operando "Tag_PresetValue" en formato BCD. El valor de contaje se pone
a "0" si el operando "Tag_Reset" tiene el estado lógico "1".
El valor de contaje actual se almacena en el operando "Tag_Value".
El operando "Tag_Status" devuelve el estado lógico "1" mientras el valor de contaje actual sea
distinto de "0". El valor actual de contaje se guarda en el operando "Tag_Value" y se devuelve
como valor de función.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1819

Instrucciones
4.1 Instrucciones

S_CUD: Parametrizar e incrementar/decrementar contador
Descripción
La instrucción "Parametrizar e incrementar/decrementar contador" permite incrementar y
decrementar el valor de un contador. Si el estado lógico del parámetro CU cambia de "0" a "1"
(flanco de señal ascendente), el valor de contaje actual se incrementa en uno. Si el estado
lógico del parámetro CD cambia de "0" a "1" (flanco de señal ascendente), el valor de contaje
se decrementa en uno. El valor de contaje actual se deposita en el parámetro CV. Si en un ciclo
del programa se detecta un flanco de señal ascendente en los parámetros CU y CD el valor de
contaje permanece invariable.
El valor de contaje sigue incrementando hasta alcanzar el límite superior "999". Una vez
alcanzado el valor límite superior, el valor de contaje no se incrementa más aunque se detecte
un flanco de señal ascendente. Cuando se alcanza el valor límite inferior "0", no se decrementa
más el valor de contaje.
Cuando el estado lógico del parámetro S cambia de "0" a "1", el valor de contaje adopta el valor
del parámetro PV. Si el contador se activa y el resultado lógico (RLO) de los parámetros CU y
CD es "1", el contador cuenta una única vez en el ciclo siguiente aunque no se detecte ningún
cambio de flanco.
El valor de contaje se pone a cero cuando el estado lógico del parámetro R cambia a "1".
Mientras el parámetro R tenga el estado lógico "1", el estado lógico de los parámetros CU, CD
y S no tiene ningún efecto sobre el valor de contaje.
El estado lógico del parámetro Q es "1" si el valor de contaje es mayor que cero. Si el valor de
contaje es igual a cero, el parámetro Q devuelve el estado lógico "0".
Nota
Utilice el contador en una sola posición del programa para evitar fallos de contaje.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

C_NO

Input

COUNTER, INT

C

Contador
El número de contadores de‐
pende de la CPU.

1820

CU

Input

BOOL

I, Q, M, D, L

Entrada de contaje ascen‐
dente

CD

Input

BOOL

I, Q, M, D, L

Entrada de contaje descen‐
dente

S

Input

BOOL

I, Q, M, D, L

Entrada para preajustar el
contador

PV

Input

WORD

I, Q, M, D, L

Valor de contaje predetermi‐
nado (C#0 a C#999) en for‐
mato BCD

R

Input

BOOL

I, Q, M, D, L

Entrada de reset

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

WORD

I, Q, M, D, L

Valor de contaje actual (he‐
xadecimal)

WORD

I, Q, M, D, L

Valor de contaje actual en
formato BCD

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := S_CD(C_NO := "Counter_1",
CU := "Tag_CU",
CD := "Tag_CD",
S := "Tag_1",
PV := "Tag_PresetValue",
R := "Tag_Reset",
Q => "Tag_Status",
CV => "Tag_Value");

Cuando se detecta un flanco de señal ascendente en el estado lógico del operando "Tag_CU"
y el valor de contaje actual es menor que "999", el valor de contaje se incrementa en uno.
Cuando se detecta un flanco de señal ascendente en el estado lógico del operando "Tag_CD"
y el valor de contaje actual es mayor que "0", el valor de contaje se decrementa en uno.
Cuando el estado lógico del operando "Tag_1" cambia de "0" a "1", el valor de contaje adopta
el valor del operando "Tag_PresetValue" en formato BCD. El valor de contaje se pone a "0" si
el operando "Tag_Reset" tiene el estado lógico "1".
El valor de contaje actual se almacena en el operando "Tag_Value".
El operando "Tag_Status" devuelve el estado lógico "1" mientras el valor de contaje actual sea
distinto de "0". El valor actual de contaje se guarda en el operando "Tag_Value" y se devuelve
como valor de función.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1821

Instrucciones
4.1 Instrucciones

Comparación
TypeOf: Consultar tipo de datos de una variable VARIANT
Descripción
Con la instrucción "Consultar tipo de datos de una variable VARIANT" se consulta qué tipo de
datos tiene una variable a la que apunta un VARIANT. El tipo de datos de la variable declarada
en la interfaz del bloque se puede comparar con el tipo de datos de otra variable o directamente
con un tipo de datos para determinar si es "Igual" o "Diferente".
El operando de comparación puede ser un tipo de datos elemental o un tipo de datos PLC.
La instrucción "Consultar tipo de datos de una variable VARIANT" solo se puede utilizar dentro
de una instrucción IF o CASE.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números binarios,
enteros, números
en coma flotante,
temporizadores,
fecha y hora, cade‐
nas de caracteres,
VARIANT

L (puede declarar‐ Operando que debe consul‐
se en las seccio‐
tarse
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra la comparación con otra variable:
SCL
IF TypeOf(#TagVARIANT) = TypeOf("TagBYTE") THEN
...;
END_IF;

El siguiente ejemplo muestra la comparación con un tipo de datos:
SCL
IF TypeOf(#TagVARIANT) = BYTE THEN
...;
END_IF;

Si el operando al que apunta el VARIANT #TagVARIANT es del tipo de datos BYTE, entonces
se cumple la condición de comparación.

1822

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Ejemplo de programación de una cola de espera (FIFO) (Página 348)
Principios básicos de VARIANT (Página 335)
Principios básicos de SCL (Página 8115)

TypeOfElements: Consultar tipo de datos de un elemento de ARRAY de una variable VARIANT
Descripción
Con la instrucción "Consultar tipo de datos de un elemento de ARRAY de una variable
VARIANT" se consulta qué tipo de datos tiene una variable a la que apunta un VARIANT. El
tipo de datos de la variable declarada en la interfaz del bloque se compara con el tipo de datos
de una variable para determinar si es "Igual" o "Diferente".
El operando debe ser del tipo de datos VARIANT. El operando de comparación puede ser un
tipo de datos elemental o un tipo de datos PLC.
Si el tipo de datos de la variable VARIANT es un ARRAY, se compara el tipo de datos de los
elementos del ARRAY.
La instrucción "Consultar tipo de datos de un elemento de ARRAY de una variable VARIANT"
solo se puede utilizar dentro de una instrucción IF o CASE.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

VARIANT

L (puede declarar‐ Operando que debe consul‐
se en las seccio‐
tarse
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
IF TypeOfElements("Tag_Variant") = TypeOF("GlobalDB".Product[1]) THEN
"Tag_Variant" := "GlobalDB".Product[1] * 3;
END_IF;

Programación del PLC
Manual de programación y manejo, 11/2019

1823

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

"GlobalDB".Product[1]

1.5

Tag_Variant

4.5

Si la variable a la que señala VARIANT y el operando "GlobalDB".Product[1] son del tipo de
datos REAL, el operando "GlobalDB".Product[1] se multiplica por 3 y el resultado se escribe en
el operando "Tag_Variant".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Ejemplo de programación de una cola de espera (FIFO) (Página 348)
Principios básicos de VARIANT (Página 335)
Principios básicos de SCL (Página 8115)

IS_ARRAY: Consultar si es un ARRAY
Descripción
La instrucción "Consultar si es un ARRAY" permite saber si VARIANT apunta a una variable
del tipo de datos ARRAY.
La instrucción "Consultar si es un ARRAY" solo se puede utilizar dentro de una instrucción IF.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar si es un ARRAY":
Parámetro

Declaración

Tipo de datos

Área de memoria

<Operando>

Input

VARIANT

L (puede declarar‐ Operando que se consulta si
se en las seccio‐
es un ARRAY
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

UDINT

I, Q, M, D, L

Valor de función

1824

Descripción

Resultado de la instrucción

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Nota
Consulta de un bloque de datos ARRAY
Si utiliza la instrucción IS_ARRAY en relación con un ArrayDB y genera el parámetro de
entrada VARIANT con DB_ANY_TO_VARIANT , en un punto cualquiera del programa deberá
utilizarse el ArrayDB en forma de símbolo como parámetro actual de un parámetro formal del
tipo de datos de datos VARIANT. Para que funcione correctamente es suficiente que se haya
descargado el lugar de uso. No es necesario que se ejecute.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
IF IS_ARRAY(#Tag_VARIANTToArray) THEN
"Tag_Result" := CountOfElements(#Tag_VARIANTToArray);
END_IF;

Si la variable a la que señala VARIANT es ARRAY, se devuelve el número de elementos
ARRAY.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Ejemplo de programación de una cola de espera (FIFO) (Página 348)
Principios básicos de VARIANT (Página 335)
Principios básicos de SCL (Página 8115)

TypeOfDB: Consultar el tipo de datos de un DB
Descripción
La instrucción "Consultar el tipo de datos de un DB" sirve para consultar el tipo de datos que
tiene el bloque de datos direccionado por la variable del tipo de datos DB_ANY. El tipo de datos
del DB direccionado con la variable <Operando> se puede comparar con el tipo de datos de
otra variable o bien directamente con un tipo de datos para determinar si es "Igual" o
"Diferente".
La variable debe ser del tipo de datos DB_ANY. El operando de comparación puede ser, p. ej.,
un tipo de datos PLC, un tipo de datos de sistema, un eje o un FB.
La instrucción "Consultar el tipo de datos de un DB" solo se puede utilizar dentro de una
instrucción IF o CASE.

Programación del PLC
Manual de programación y manejo, 11/2019

1825

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

DB_ANY

L (puede declarar‐ Operando que de‐
se en las seccio‐
be consultarse
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
IF TypeOfDB(#InputDBAny) = TO_SpeedAxis THEN
"TagOut" := 1;
END_IF;

La salida "TagOut" se activa si el tipo de datos del DB direccionado por el operando
#InputDBAny es igual al tipo de datos TO_SpeedAxis.
La salida "TagOut" no se activa cuando se cumplen las condiciones siguientes:
● El número del bloque de datos es "0".
● El bloque de datos no existe.
● El bloque de datos es un DB de ARRAY.
● El bloque de datos contiene una variable del tipo de datos UDT (tipo de datos PLC).

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Uso del tipo de datos DB_ANY (Página 216)
Principios básicos de SCL (Página 8115)

Funciones matemáticas
ABS: Calcular valor absoluto
Descripción
La instrucción "Calcular valor absoluto" permite calcular el valor absoluto de un valor de
entrada y guardar el resultado en el operando indicado.

1826

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros
<Expresión>

Valor de función

Declaración
Input

Tipo de datos

Área de memo‐ Descripción
ria

S7-1200

S7-1500

SINT, INT,
DINT, números
en coma flotan‐
te

SINT, INT,
DINT, LINT,
números en
coma flotan‐
te

I, Q, M, D, L, P

Valor de entra‐
da

SINT, INT,
DINT, números
en coma flotan‐
te

SINT, INT,
DINT, LINT,
números en
coma flotan‐
te

I, Q, M, D, L, P

Valor absoluto
del valor de en‐
trada

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result1" := ABS("Tag_Value");
"Tag_Result2" := ABS("Tag_Value1"*"Tag_Value2");

El valor absoluto del valor de entrada se devuelve en el formato del valor de entrada como valor
de función.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

-2

Tag_Result1

2

Tag_Value1

4

Tag_Value2

-1

Tag_Result2

4

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1827

Instrucciones
4.1 Instrucciones

MIN: Determinar mínimo
Descripción
Con la instrucción "Determinar mínimo" se comparan los valores de las entradas disponibles
y se devuelve el menor como resultado.
En la instrucción se pueden indicar como mínimo dos y como máximo 32 entradas.
El resultado no es válido si se cumple una de las siguientes condiciones:
● La conversión implícita de los tipos de datos falla durante la ejecución de la instrucción.
● Un número en coma flotante tiene un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Determinar mínimo":
Parámetro

1828

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐ Descripción
ria

IN1

Input

Enteros, núme‐
ros en coma flo‐
tante, TIME,
TOD, DATE,
DTL

Enteros, nú‐ I, Q, M, D, L, P
meros en co‐
ma flotante,
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DT, DTL

Primer valor de
entrada

IN2

Input

Enteros, núme‐
ros en coma flo‐
tante, TIME,
TOD, DATE,
DTL

Enteros, nú‐ I, Q, M, D, L, P
meros en co‐
ma flotante,
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DT, DTL

Segundo valor
de entrada

INn

Input

Enteros, núme‐
ros en coma flo‐
tante, TIME,
TOD, DATE,
DTL

Enteros, nú‐ I, Q, M, D, L, P
meros en co‐
ma flotante,
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DT, DTL

Entradas inser‐
tadas adicional‐
mente cuyos
valores se com‐
paran

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro
Valor de función

Declaración

Tipo de datos

Área de memo‐ Descripción
ria

S7-1200

S7-1500

Enteros, núme‐
ros en coma flo‐
tante, TIME,
TOD, DATE,
DTL

Enteros, nú‐ I, Q, M, D, L, P
meros en co‐
ma flotante,
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DT, DTL

Resultado de la
instrucción

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar cuando la verificación CEI está
desactivada.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := MIN(IN1 := "Tag_Value1",
IN2 := "Tag_Value2",
IN3 := "Tag_Value3");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN1

Tag_Value1

12222

IN2

Tag_Value2

14444

IN3

Tag_Value3

13333

Valor de función

Tag_Result

12222

La instrucción compara los valores de las entradas disponibles y copia el valor menor
(Tag_Value1) en el operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

MAX: Determinar máximo
Descripción
Con la instrucción "Determinar máximo" se comparan los valores de las entradas disponibles
y se devuelve el mayor como resultado.
En la instrucción se pueden indicar como mínimo dos y como máximo 32 entradas.

Programación del PLC
Manual de programación y manejo, 11/2019

1829

Instrucciones
4.1 Instrucciones
El resultado no es válido si se cumple una de las siguientes condiciones:
● La conversión implícita de los tipos de datos falla durante la ejecución de la instrucción.
● Un número en coma flotante tiene un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Determinar máximo":
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐ Descripción
ria

IN1

Input

Enteros, núme‐
ros en coma flo‐
tante, TIME,
TOD, DATE,
DTL

Enteros, nú‐ I, Q, M, D, L, P
meros en co‐
ma flotante,
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DT, DTL

Primer valor de
entrada

IN2

Input

Enteros, núme‐
ros en coma flo‐
tante, TIME,
TOD, DATE,
DTL

Enteros, nú‐ I, Q, M, D, L, P
meros en co‐
ma flotante,
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DT, DTL

Segundo valor
de entrada

INn

Input

Enteros, núme‐
ros en coma flo‐
tante, TIME,
TOD, DATE,
DTL

Enteros, nú‐ I, Q, M, D, L, P
meros en co‐
ma flotante,
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DT, DTL

Entradas inser‐
tadas adicional‐
mente cuyos
valores se com‐
paran

Enteros, núme‐
ros en coma flo‐
tante, TIME,
TOD, DATE,
DTL

Enteros, nú‐ I, Q, M, D, L, P
meros en co‐
ma flotante,
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DT, DTL

Resultado de la
instrucción

Valor de función

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar cuando la verificación CEI está
desactivada.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1830

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := MAX(IN1 := "Tag_Value1",
IN2 := "Tag_Value2",
IN3 := "Tag_Value3");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN1

Tag_Value1

12 222

IN2

Tag_Value2

14 444

IN3

Tag_Value3

13 333

Valor de función

Tag_Result

14 444

La instrucción compara los valores de los operandos indicados y copia el valor mayor
("Tag_Value2") en el operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

LIMIT: Ajustar valor límite
Descripción
La instrucción "Ajustar valor límite" limita el valor del parámetro IN a los valores de los
parámetros MN y MX. Para ello, el valor del parámetro MN no puede ser mayor que el valor del
parámetro MX.
Si el valor del parámetro IN cumple la condición MN <= IN <= MX, se devuelve como resultado
de la instrucción. Si no se cumple la condición y el valor de entrada IN rebasa por defecto el
límite inferior MN, se devuelve como resultado el valor del parámetro MN. Si se rebasa por
exceso el límite superior MX se devuelve como resultado el valor del parámetro MX.
Si el valor de la entrada MN es mayor que el de la entrada MX, el resultado será el valor
indicado en el parámetro IN y la salida de habilitación ENO será "0".
Para poder ejecutar la instrucción, es imprescindible que los operandos de todos los
parámetros sean del mismo tipo de datos.

Programación del PLC
Manual de programación y manejo, 11/2019

1831

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐ Descripción
ria

MN

Input

Enteros, núme‐
ros en coma flo‐
tante, TIME,
TOD, DATE,
DTL

Enteros, nú‐ I, Q, M, D, L, P
meros en co‐
ma flotante,
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DT, DTL

Límite inferior

IN

Input

Enteros, núme‐
ros en coma flo‐
tante, TIME,
TOD, DATE,
DTL

Enteros, nú‐ I, Q, M, D, L, P
meros en co‐
ma flotante,
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DT, DTL

Valor de entra‐
da

MX

Input

Enteros, núme‐
ros en coma flo‐
tante, TIME,
TOD, DATE,
DTL

Enteros, nú‐ I, Q, M, D, L, P
meros en co‐
ma flotante,
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DT, DTL

Límite superior

Enteros, núme‐
ros en coma flo‐
tante, TIME,
TOD, DATE,
DTL

Enteros, nú‐ I, Q, M, D, L, P
meros en co‐
ma flotante,
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DT, DTL

Resultado de la
instrucción

Valor de función

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar cuando la verificación CEI está
desactivada.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := LIMIT(MN := "Tag_Minimum",
IN := "Tag_Value",
MX := "Tag_Maximum");

1832

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

MN

Tag_Minimum

12 000

IN

Tag_Value

8 000

MX

Tag_Maximum

16 000

Valor de función

Tag_Result

12 000

El valor del operando "Tag_Value" se compara con los valores de los operandos
"Tag_Minimum" y "Tag_Maximum". Puesto que el valor del operando "Tag_Value" es menor
que el valor límite inferior, el valor del operando "Tag_Minimum" se copia en el operando
"Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

SQR: Calcular cuadrado
Descripción
La instrucción "Calcular cuadrado" permite elevar al cuadrado el valor de entrada y guardar el
resultado en el operando indicado.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

<Expresión>

Input

Números en coma
flotante

I, Q, M, D, L, P

Valor de entrada

Números en coma
flotante

I, Q, M, D, L, P

Cuadrado del valor de entra‐
da

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result1" := SQR("Tag_Value");
"Tag_Result2" := SQR((SQR("Tag_Value1"))*"Tag_Value2");

El cuadrado del valor de entrada se devuelve en el operando "Tag_Resultxy" como valor de
función.

Programación del PLC
Manual de programación y manejo, 11/2019

1833

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

2.5

Tag_Result1

6.25

Tag_Value1

6.0

Tag_Value2

2.0

Tag_Result2

5184.0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

SQRT: Calcular raíz cuadrada
Descripción
La instrucción "Calcular raíz cuadrada" permite extraer la raíz cuadrada del valor de entrada y
guardar el resultado en el operando indicado. La instrucción da un resultado positivo si el valor
de entrada es mayor que cero. En los valores de entrada menores que cero, la instrucción
devuelve un número en coma flotante no válido. Si el valor de entrada es "0", el resultado
también es "0".

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

<Expresión>

Input

Números en coma
flotante

I, Q, M, D, L, P

Valor de entrada

Números en coma
flotante

I, Q, M, D, L, P

Raíz cuadrada del valor de
entrada

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result1" := SQRT("Tag_Value");
"Tag_Result2" := SQRT((SQR("Tag_Value1"))+"Tag_Value2");

La raíz cuadrada del valor de entrada se devuelve en el operando "Tag_Resultxy" como valor
de función.

1834

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

4.0

Tag_Result1

2.0

Tag_Value1

3.0

Tag_Value2

16.0

Tag_Result2

5.0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

LN: Calcular logaritmo natural
Descripción
La instrucción "Calcular logaritmo natural" permite calcular el logaritmo natural en base e (e =
2,718282) a partir del valor de entrada. La instrucción da un resultado positivo si el valor de
entrada es mayor que cero. En los valores de entrada menores que cero, la instrucción
devuelve un número en coma flotante no válido.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

<Expresión>

Input

Números en coma
flotante

I, Q, M, D, L, P

Valor de entrada

Números en coma
flotante

I, Q, M, D, L, P

Logaritmo natural del valor
de entrada

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result1" := LN("Tag_Value");
"Tag_Result2" := LN("Tag_Value1"+"Tag_Value2");

El resultado de la instrucción se devuelve en el operando "Tag_Resultxy" como valor de
función.

Programación del PLC
Manual de programación y manejo, 11/2019

1835

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

2.5

Tag_Result1

0.916

Tag_Value1

1.5

Tag_Value2

3.2

Tag_Result2

1.548

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

EXP: Calcular valor exponencial
Descripción
La instrucción "Calcular valor exponencial" permite calcular la potencia en base e (e =
2,718282) a partir del valor de entrada y guardar el resultado en el operando indicado.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

<Expresión>

Input

Números en coma
flotante

I, Q, M, D, L, P

Valor de entrada

Números en coma
flotante

I, Q, M, D, L, P

Valor exponencial del valor
de entrada

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result1" := EXP("Tag_Value");
"Tag_Result2" := EXP("Tag_Value1"/"Tag_Value2");

El resultado de la instrucción se devuelve en el operando "Tag_Resultxy" como valor de
función.

1836

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

20.5

Tag_Result1

799 902 200

Tag_Value1

15.5

Tag_Value2

30.2

Tag_Result2

1.671

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

SIN: Calcular valor de seno
Descripción
La instrucción "Calcular valor de seno" permite calcular el seno del valor de entrada. El valor
de entrada se ha de indicar en radianes.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

<Expresión>

Input

Números en coma
flotante

I, Q, M, D, L, P

Valor de entrada (tamaño de
un ángulo en radianes)

Números en coma
flotante

I, Q, M, D, L, P

Resultado de la instrucción

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := SIN("Tag_Value");

El resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.

Programación del PLC
Manual de programación y manejo, 11/2019

1837

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

+1.570796 (π/2)

Tag_Result

1.0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

COS: Calcular valor de coseno
Descripción
La instrucción "Calcular valor de coseno" permite calcular el coseno del valor de entrada. El
valor de entrada se ha de indicar en radianes.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

<Expresión>

Input

Números en coma
flotante

I, Q, M, D, L, P

Valor de entrada (tamaño de
un ángulo en radianes)

Números en coma
flotante

I, Q, M, D, L, P

Resultado de la instrucción

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := COS("Tag_Value");

El resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:

1838

Operando

Valor

Tag_Value

+1.570796 (π/2)

Tag_Result

0

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

TAN: Calcular valor de tangente
Descripción
La instrucción "Calcular valor de tangente" permite calcular la tangente del valor de entrada. El
valor de entrada se ha de indicar en radianes.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

<Expresión>

Input

Números en coma
flotante

I, Q, M, D, L, P

Valor de entrada (tamaño de
un ángulo en radianes)

Números en coma
flotante

I, Q, M, D, L, P

Resultado de la instrucción

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := TAN("Tag_Value");

El resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

+3.141593 (π)

Tag_Result

0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1839

Instrucciones
4.1 Instrucciones

ASIN: Calcular valor de arcoseno
Descripción
La instrucción "Calcular valor de arcoseno" permite calcular a partir del valor de seno el tamaño
del ángulo que equivale a este valor. Como valores de entrada solo se pueden indicar números
en coma flotante válidos, comprendidos en un rango de valores entre -1 y +1. El tamaño del
ángulo calculado se devuelve en radianes y puede estar comprendido entre -π/2 y +π/2.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

<Expresión>

Input

Números en coma
flotante

I, Q, M, D, L, P

Valor de seno

Números en coma
flotante

I, Q, M, D, L, P

Tamaño del ángulo en radia‐
nes

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := ASIN("Tag_Value");

El resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

1.0

Tag_Result

+1.570796 (π/2)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

1840

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

ACOS: Calcular valor de arcocoseno
Descripción
La instrucción "Calcular valor de arcocoseno" permite calcular a partir del valor de coseno el
tamaño del ángulo que equivale a este valor. Como valores de entrada solo se pueden indicar
números en coma flotante válidos, comprendidos en un rango de valores entre -1 y +1. El
tamaño del ángulo calculado se devuelve en radianes y puede estar comprendido entre 0 y +π.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

<Expresión>

Input

Números en coma
flotante

I, Q, M, D, L, P

Valor de coseno

Números en coma
flotante

I, Q, M, D, L, P

Tamaño del ángulo en radia‐
nes

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := ACOS("Tag_Value");

El resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

0

Tag_Result

+1.570796 (π/2)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1841

Instrucciones
4.1 Instrucciones

ATAN: Calcular valor de arcotangente
Descripción
La instrucción "Calcular valor de arcotangente" permite calcular a partir del valor de tangente
el tamaño del ángulo que equivale a este valor. Solo se pueden indicar valores de entrada que
sean números en coma flotante válidos (o -NaN/+NaN). El tamaño del ángulo calculado se
devuelve en radianes y puede estar comprendido entre -π/2 y +π/2.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

<Expresión>

Input

Números en coma
flotante

I, Q, M, D, L, P

Valor de tangente

Números en coma
flotante

I, Q, M, D, L, P

Tamaño del ángulo en radia‐
nes

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := ATAN("Tag_Value");

El resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

1.0

Tag_Result

+0,785398 (π/4)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Números en coma flotante no válidos (Página 263)
Principios básicos de SCL (Página 8115)

1842

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

FRAC: Determinar decimales
Descripción
La instrucción "Determinar decimales" devuelve como resultado los decimales de un valor. Así,
por ejemplo, el valor de entrada 123.4567 proporciona como resultado el valor 0.4567.
Para modificar el tipo de datos de la instrucción, utilice la sintaxis siguiente:
FRAC_<tipo de datos>();

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memo‐ Descripción
ria

<Expresión>

Input

Números en coma
flotante

I, Q, M, D, L, P

Valor de entrada

Números en coma
flotante

-

Tipo de datos del valor de
función:

_<tipo de datos>

Ajuste predetermi‐
nado: REAL

1. El tipo de datos de la
instrucción se puede
indicar explícitamente
con "_".
2. Si el tipo de datos no se
indica explícitamente, se
determinará a partir de
las variables utilizadas o
de las constantes con
tipos.
3. Si el tipo de datos no se
indica explícitamente ni
se indican variables
definidas ni constantes
con tipo, se utilizará el
tipo de datos
predeterminado.

Valor de función

Números en coma
flotante

I, Q, M, D, L, P

Decimales del valor de entra‐
da

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result1" := FRAC("Tag_Value");
"Tag_Result2" := FRAC_LREAL("Tag_Value");

Programación del PLC
Manual de programación y manejo, 11/2019

1843

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

2.555

-14 421

Tag_Result1

0.555

-0.4421

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Números en coma flotante no válidos (Página 263)
Principios básicos de SCL (Página 8115)

Transferencia
Deserialize: Deserializar
Descripción
La instrucción "Deserializar" reconvierte la forma de representación secuencial de un tipo de
datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> y rellena todo su contenido.
El área de memoria en la que se encuentra la forma de representación secuencial de un tipo
de datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> debe ser del tipo de datos ARRAY
of BYTE o ARRAY of CHAR y tener declarado el acceso estándar en la versión 1.0. A partir de
la versión 2.0 se permiten también áreas de memoria optimizadas. La capacidad del área de
memoria estándar es de 64 KB. Antes de la conversión asegúrese de que hay suficiente
memoria disponible. Si el área de memoria se ha rellenado utilizando la instrucción "Serializar"
y se han insertado bytes de relleno, estos no se tendrán en cuenta en la conversión.
Se recomienda definir a "0" el límite inferior del ARRAY, ya que entonces el índice dentro del
ARRAY se corresponde con el valor del parámetro POS, p. ej. ARRAY[0] = POS 0. La
descripción y el ejemplo que sigue más abajo se basan en estos fundamentos.
Esta instrucción reconvierte paso a paso a su estado original varias formas de representación
secuenciales de datos convertidos.
Para reconvertir una sola forma de representación secuencial de un tipo de datos PLC (UDT),
STRUCT o ARRAY of <tipo de datos> también se puede utilizar directamente la instrucción
"TRCV: Recibir datos a través de la conexión".

Tamaño del área de memoria
Debido a las reglas de alineación, no se insertan bytes de relleno en las estructuras sencillas
del área de memoria optimizada. Por consiguiente, una estructura del área de memoria
optimizada es más pequeña que en el área de memoria estándar. Los ARRAY de estructuras
y las estructuras anidadas tienen bytes de relleno. Por lo general no es posible saber de
antemano en qué área de memoria requiere más espacio una estructura compuesta.
Válido para las CPU de la serie S7-1500:

1844

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En un bloque con la propiedad "Acceso optimizado al bloque", el BOOL tiene una longitud de
1 byte. Esto hace que una estructura, que básicamente está formada por el tipo de datos
BOOL, sea mayor en el área de memoria optimizada que en el área de memoria estándar. Las
estructuras compuestas con un porcentaje reducido de tipos de datos BOOL son menores en
el área de memoria optimizada que en el área de memoria estándar.
Nota
Serialización de varias estructuras en una CPU-S7-1200
Si desea serializar varias estructuras en un búfer de una CPU-S7-1200 y establecer
comunicación con ellas (p. ej., con un sistema de control o una CPU-S7-1500), deberá
comprobar si el valor de retorno (índice del parámetro POS) es par. Si este no es el caso,
deberá incrementar el valor de retorno en 1 antes de serializar la segunda estructura, ya que
la primera estructura no se rellena con un byte de relleno.
Ejemplo:
Estructura compuesta por 1 DWORD y 1 BYTE
La dirección inicial para la siguiente estructura serializada en el búfer es 5. Añada +1 para que
la dirección inicial sea un número par.

Área de memoria optimizada
Para deserializar estructuras de mayor tamaño, el área de memoria para la representación
secuencial puede declararse también con acceso optimizado a partir de la versión de firmware
>= 4.2 de las CPU de la serie S7-1200 y a partir de la versión de firmware >= 2.0 de las CPU
de la serie S7-1500. El contenido de la representación secuencial no cambia, igual que en un
área de memoria estándar. El acceso a los bytes del ARRAY solo es posible simbólicamente.

Programación del PLC
Manual de programación y manejo, 11/2019

1845

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRC_ARRA
Y

Input

ARRAY[*] of
BYTE 1)

I, Q, D, interfaz de
bloque de un FB
(son posibles las
secciones Input,
Output, Static y
Temp).

ARRAY of BYTE o ARRAY of
CHAR, en el que se guarda el
flujo de datos que debe dese‐
rializarse.

o bien
ARRAY of CHAR

S7-1500:

Para obtener el máximo ren‐
ningún dato de pe‐ dimiento, no transfiera valo‐
riferia
res a este parámetro con un
puntero VARIANT.

DEST_VA‐
RIABLE

InOut

Todos los tipos de
datos

I, Q, D, interfaz de
bloque de un FB

Variable, en la que se escri‐
birán los datos deserializa‐
ningún dato de pe‐ dos.
riferia
S7-1500:
Para obtener el máximo ren‐
dimiento, no transfiera valo‐
res a este parámetro con un
puntero VARIANT.

POS

InOut

Valor de función

DINT

I, Q, M, D, L

El operando del parámetro
POS almacena el índice del
primer byte tras el número de
bytes que ocupan los datos
de cliente convertidos. El pa‐
rámetro POS se calcula ba‐
sado en cero.

INT

I, Q, M, D, L

Información de error

Posible con CPU de la serie S7-1200 a partir de la versión de firmware >= 4.2 y con CPU de la serie
S7-1500 a partir de la versión de firmware >= 2.0
1)

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:

1846

Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B0

Las áreas de memoria de los parámetros SRC_ARRAY y DEST_VARIABLE se solapan.

8136

La variable del parámetro SRC_ARRAY no está en un bloque con acceso estándar.

8150

El tipo de datos VARIANT del parámetro SRC_ARRAY contiene un puntero IGUAL A
CERO.

8151

El parámetro SRC_ARRAY no tiene una referencia válida.

8153

En el parámetro SRC_ARRAY no hay suficiente espacio de memoria disponible.

8154

Tipo de datos no válido en el parámetro SRC_ARRAY

8250

En el parámetro DEST_ARRAY se ha transferido un puntero CERO.

8251

El parámetro DEST_VARIABLE no tiene una referencia válida.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*
(W#16#...)

Explicación

8382

El valor del parámetro POS se encuentra fuera de los valores límite del array.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 4.2 (S7-1200) y 2.0 (S7-1500):
El código de error siguiente tiene un significado distinto:
Código de
error*
(W#16#...)

Explicación

8136

El acceso al área de memoria en el parámetro SRC_ARRAY no es válido.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 2.8 (S7-1500):
El rendimiento de la instrucción "Deserializar" (versión 2.1) mejora si no se transfieren valores
a los parámetros SRC_ARRAY y DEST_VARIABLE con un puntero VARIANT, sino con un tipo
de datos concreto.
Tenga en cuenta que el comportamiento erróneo de la instrucción cambia en este caso. En
determinados escenarios de error, la CPU no devuelve códigos de error, sino que pasa a
STOP con un error de acceso. Para evitar que esto ocurra, utilice el tratamiento de errores local
con las instrucciones "GET_ERROR" y "GET_ERR_ID".

Ejemplo
La tabla siguiente muestra la declaración de los operandos:
Operando

Tipo de datos

Declaración

DeliverPos

INT

En la sección "Input" de la inter‐
faz del bloque de un FB o una FC

BufferPos

DINT

Error

INT

En la sección "Temp" de la inter‐
faz del bloque de un FB o una FC

Label

STRING[4]

La siguiente tabla muestra la declaración de los tipos de datos PLC:
Nombre de los tipos de datos
PLC

Nombre

Tipo de datos

Article

Number

DINT

Declaration

STRING

Colli

INT

Title

INT

First name

STRING[10]

Surname

STRING[10]

Client

Programación del PLC
Manual de programación y manejo, 11/2019

1847

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra la declaración de los bloques de datos:
Nombre de los bloques de datos Nombre

Tipo de datos

Target

Client

"Client" (tipo de datos PLC)

Article

Array[0..10] of "Article" (tipo de
datos PLC)

Bill

Array[0..10] of INT

Field

Array[0..294] of BYTE

Buffer

El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
#Tag_RetVal := Deserialize(SRC_ARRAY := "Buffer".Field,
DEST_VARIABLE := "Target".Client,
POS := #BufferPos);
#Tag_RetVal := Deserialize(SRC_ARRAY := "Buffer".Field,
DEST_VARIABLE := #Label,
POS := #BufferPos);
IF #Label = 'arti' THEN
#Tag_RetVal := Deserialize(SRC_ARRAY := "Buffer".Field,
DEST_VARIABLE := "Target".Article[#DeliverPos],
POS := #BufferPos);
ELSIF #Label = 'Bill' THEN
#Tag_RetVal := Deserialize(SRC_ARRAY := "Buffer".Field,
DEST_VARIABLE := "Target".Bill[#DeliverPos],
POS := #BufferPos);
;
ELSE
;
END_IF;

La instrucción "Deserializar" deserializa la forma de representación secuencial de los datos de
cliente de la variable "Buffer" y los escribe en la variable "Target". El operando #BufferPos
almacena el índice del primer byte tras el número de bytes que ocupan los datos de cliente
convertidos.
La instrucción "Deserializar" deserializa la forma de representación secuencial del separador
(depositado después de los datos de cliente en la forma de representación secuencial) de la
variable "Buffer" y escribe los caracteres en el operando #Label. Los caracteres se comparan
en relación con "arti" y "Bill" mediante instrucciones de comparación. Si la comparación en
relación con "arti" = TRUE, se trata de datos de artículo que se deserializan y se escriben en
la variable "Target". Si la comparación en relación con "Bill" = TRUE, se trata de datos de
cálculo que se deserializan y se escriben en la variable "Target".

1848

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de los tipos de datos PLC (UDT) (Página 283)
Estructura de una variable ARRAY (Página 298)
Estructura de una variable STRUCT (Página 290)
Estructura de una variable STRING (Página 277)
Bytes de relleno cuando se usan tipos de datos estructurados (Página 143)
Principios básicos de SCL (Página 8115)

Serialize: Serializar
Descripción
Mediante la instrucción "Serializar" se convierten varios tipos de datos PLC (UDT), STRUCT
o ARRAY of <tipo de datos> a una forma de representación secuencial sin que se pierdan
partes de su estructura.
La instrucción permite guardar temporalmente varios datos estructurados del programa en un
búfer, ubicado preferentemente en un bloque de datos global, y enviarlos a otra CPU. El área
de memoria en la que se depositen los datos convertidos debe ser del tipo de datos ARRAY of
BYTE o ARRAY of CHAR y tener declarado el acceso estándar en la versión 1.0. A partir de
la versión 2.0 se permiten también datos optimizados. Los datos de relleno del área de datos
del origen no están definidos en el ARRAY de destino. Pueden ser tanto bytes o bits de relleno
de un área de datos (p. ej., ARRAY, STRUCT o tipo de datos PLC (UDT)) como los caracteres
de una cadena que no se utilicen en ese momento.
La capacidad del área de memoria estándar es de 64 KB. Las estructuras mayores que 64 KB
según las reglas para áreas de memoria estándar no pueden serializarse si el operando del
parámetro DEST_ARRAY está en un área de memoria estándar.
Se recomienda definir a "0" el límite inferior del ARRAY, ya que entonces el índice dentro del
ARRAY se corresponde con el valor del parámetro POS, p. ej. ARRAY[0] = POS 0. La
descripción y el ejemplo que sigue más abajo se basan en estos fundamentos.
El operando del parámetro POS contiene la información sobre el número de bytes que ocupan
los datos convertidos.
Para enviar un solo tipo de datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> se puede
llamar directamente la instrucción "TSEND: Enviar datos a través de la conexión".
Nota
Comparación de estructuras
Para comparar estructuras no es necesario serializarlas antes. En su lugar, utilice una
expresión de comparación.
Encontrará más información aquí: Expresiones de comparación (Página 8120)

Programación del PLC
Manual de programación y manejo, 11/2019

1849

Instrucciones
4.1 Instrucciones

Tamaño del área de memoria
Debido a las reglas de alineación, no se insertan bytes de relleno en las estructuras sencillas
del área de memoria optimizada. Por consiguiente, una estructura del área de memoria
optimizada es más pequeña que en el área de memoria estándar. Los ARRAY de estructuras
y las estructuras anidadas tienen bytes de relleno. Por lo general no es posible saber de
antemano en qué área de memoria requiere más espacio una estructura compuesta.
Válido para las CPU de la serie S7-1500:
En un bloque con la propiedad "Acceso optimizado al bloque", la longitud del BOOL depende
del tipo de datos que sigue. Por ejemplo, si lo que sigue es un BYTE, el BOOL tiene una
longitud de 1 byte. Si lo que sigue es WORD, el BOOL tiene una longitud de 2 bytes. Esto hace
que una estructura, que básicamente está formada por el tipo de datos BOOL, sea mayor en
el área de memoria optimizada que en el área de memoria estándar. Las estructuras
compuestas con un porcentaje reducido de tipos de datos BOOL son menores en el área de
memoria optimizada que en el área de memoria estándar.
Por eso se recomienda que el área de datos de origen para la serialización empiece con tipos
de datos grandes y termine con elementos booleanos. De este modo se reduce
considerablemente el relleno con bits de relleno.
Nota
Serialización de varias estructuras en una CPU-S7-1200
Si desea serializar varias estructuras en un búfer de una CPU-S7-1200 y establecer
comunicación con ellas (p. ej., con un sistema de control o una CPU-S7-1500), deberá
comprobar si el valor de retorno (índice del parámetro POS) es par. Si este no es el caso,
deberá incrementar el valor de retorno en 1 antes de serializar la segunda estructura, ya que
la primera estructura no se rellena con un byte de relleno.
Ejemplo:
Estructura compuesta por 1 DWORD y 1 BYTE
La dirección inicial para la siguiente estructura serializada en el búfer es 5. Añada +1 para que
la dirección inicial sea un número par.

Área de memoria optimizada
Para serializar estructuras de mayor tamaño, el área de memoria puede declararse también
con acceso optimizado a partir de la versión de firmware >= 4.2 de las CPU de la serie S7-1200
y a partir de la versión de firmware >= 2.0 de las CPU de la serie S7-1500. La representación
secuencial no cambia, igual que en un área de memoria estándar.

1850

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRC_VARIA‐ Input
BLE

Todos los tipos de
datos

I, Q, D, interfaz de
bloque de un FB,

Variable que se serializará.

DEST_ARRA InOut
Y

ARRAY of BYTE o
ARRAY of CHAR

I, Q, D, interfaz de
bloque de un FB
(son posibles las
secciones Input,
Output, Static y
Temp).

Array en el que se guarda el
flujo de datos generado.

DINT

I, Q, M, D, L

El operando del parámetro
POS almacena el índice del
primer byte tras el número to‐
tal de bytes que han ocupado
los datos de cliente converti‐
dos. El parámetro POS se
calcula basado en cero.

INT

I, Q, M, D, L

Información de error

S7-1500:
ningún dato de pe‐ Para obtener el máximo ren‐
riferia
dimiento, no transfiera valo‐
res a este parámetro con un
puntero VARIANT.

S7-1500:

Para obtener el máximo ren‐
dimiento, no transfiera valo‐
res a este parámetro con un
ningún dato de pe‐ puntero VARIANT.
riferia

POS

InOut

Valor de función

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B0

Las áreas de memoria de los parámetros SRC_VARIABLE y DEST_ARRAY se solapan.

8150

El tipo de datos VARIANT del parámetro SRC_VARIABLE contiene un puntero IGUAL A
CERO.

8151

El parámetro SRC_VARIABLE no tiene una referencia válida.

8236

La variable del parámetro SRC_ARRAY no está en un bloque con acceso estándar.

8250

En el parámetro DEST_ARRAY se ha transferido un puntero CERO.

8251

El parámetro DEST_ARRAY no tiene una referencia válida.

8253

La variable del parámetro DEST_ARRAY no ofrece suficiente espacio de memoria para
el contenido de la variable del parámetro SRC_VARIABLE. El valor de entrada de la
variable del parámetro POS reduce el espacio de memoria disponible. El valor de entrada
del parámetro POS determina en qué posición de la variable se comienza en el parámetro
DEST_ARRAY.

8254

Tipo de datos no válido en el parámetro DEST_ARRAY

Programación del PLC
Manual de programación y manejo, 11/2019

1851

Instrucciones
4.1 Instrucciones
Código de
error*
(W#16#...)

Explicación

8382

El valor del parámetro POS se encuentra fuera de los valores límite del array.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 4.2 (S7-1200) y 2.0 (S7-1500):
El código de error siguiente tiene un significado distinto:
Código de
error*
(W#16#...)

Explicación

8236

El acceso al área de memoria en el parámetro DEST_ARRAY no es válido.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 2.8 (S7-1500):
El rendimiento de la instrucción "Serializar" (versión 2.1) mejora si no se transfieren valores a
los parámetros SRC_VARIABLE y DEST_ARRAY con un puntero VARIANT, sino con un tipo
de datos concreto.
Tenga en cuenta que el comportamiento erróneo de la instrucción cambia en este caso. En
determinados escenarios de error, la CPU no devuelve códigos de error, sino que pasa a
STOP con un error de acceso. Para evitar que esto ocurra, utilice el tratamiento de errores local
con las instrucciones "GET_ERROR" y "GET_ERR_ID".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
#Tag_RetVal := Serialize(SRC_VARIABLE := "Source".Client,
DEST_ARRAY := "Buffer".Field,
POS := #BufferPos);
#Label := STRING_TO_WSTRING('arti');
#Tag_RetVal := Serialize(SRC_VARIABLE := #Label,
DEST_ARRAY := "Buffer".Field,
POS := #BufferPos);
#Tag_RetVal := Serialize(SRC_VARIABLE := "Source".Article[#DeliverPos],
DEST_ARRAY := "Buffer".Field,
POS := #BufferPos);

1852

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucción "Deserializar" serializa los datos de cliente de la variable "Source" y los escribe,
en representación secuencial, en la variable "Buffer". El índice del siguiente byte no escrito del
operando "Buffer".Field se almacena en el operando #BufferPos.
Para facilitar la posterior deserialización de la forma de representación secuencial, ahora se
inserta una especie de separador. La instrucción "Desplazar cadena de caracteres" copia los
caracteres "arti" en el operando #Label. La instrucción "Serializar" escribe estos caracteres,
tras los datos de cliente, en la variable "Buffer". Se incrementa correspondientemente el valor
del operando "#BufferPos".
La instrucción "Serializar" serializa los datos de un determinado artículo, que se calcula en
tiempo de ejecución, de la variable "Source", y los escribe en forma de representación
secuencial después de los caracteres "arti" en la variable "Buffer".
La tabla siguiente muestra la declaración de los operandos:
Operando

Tipo de datos

Declaración

DeliverPos

INT

En la sección "Input" de la inter‐
faz del bloque

BufferPos

DINT

En la sección "Temp" de la inter‐
faz del bloque

Error

INT

En la sección "Temp" de la inter‐
faz del bloque

Label

STRING[4]

En la sección "Temp" de la inter‐
faz del bloque

La siguiente tabla muestra la declaración de los tipos de datos PLC:
Nombre de los tipos de datos
PLC

Nombre

Tipo de datos

Article

Number

DINT

Declaration

STRING

Colli

INT

Title

INT

First name

STRING[10]

Surname

STRING[10]

Client

La tabla siguiente muestra la declaración de los bloques de datos:
Nombre de los bloques de datos Nombre

Tipo de datos

Source

Client

"Client" (tipo de datos PLC)

Article

Array[0..10] of "Article" (tipo de
datos PLC)

Field

Array[0..294] of BYTE

Buffer

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de los tipos de datos PLC (UDT) (Página 283)

Programación del PLC
Manual de programación y manejo, 11/2019

1853

Instrucciones
4.1 Instrucciones
Estructura de una variable ARRAY (Página 298)
Estructura de una variable STRUCT (Página 290)
Estructura de una variable STRING (Página 277)
Bytes de relleno cuando se usan tipos de datos estructurados (Página 143)
Principios básicos de SCL (Página 8115)

MOVE_BLK: Copiar área
Descripción
La instrucción "Copiar área" copia los contenidos de un área de memoria (área de origen) en
un área de memoria diferente (área de destino). El número de elementos que se copian en el
área de destino se determina con el parámetro COUNT. El ancho del primer elemento del área
de origen define el ancho de los elementos que deben copiarse.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
El valor de la salida OUT no es válido si se cumple la siguiente condición:
● Se copian más datos de los que están disponibles en el parámetro IN o en el parámetro
OUT.
Nota
Uso de ARRAYs
La instrucción copia el contenido a partir del elemento definido n elementos (n = depende del
valor del parámetro COUNT) desde el área de origen al área de destino, comenzando por el
índice especificado.

1854

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐ Descripción
ria

IN 1)

Input

Números bina‐
rios, enteros,
números en co‐
ma flotante,
tiempos, DA‐
TE, CHAR,
WCHAR, TOD

Números bi‐ D, L
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD, LTOD

Primer elemen‐
to del área de
origen que se
copia

COUNT

Input

USINT, UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

Número de ele‐
mentos que se
copian del área
de origen al
área de destino

OUT 1)

Output

Números bina‐
rios, enteros,
números en co‐
ma flotante,
tiempos, DA‐
TE, CHAR,
WCHAR, TOD

Números bi‐ D, L
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD, LTOD

1)

I, Q, M, D, L, P

Primer elemen‐
to del área de
destino en la
que se copian
los contenidos
del área de ori‐
gen

Los tipos de datos indicados solamente pueden utilizarse como elementos de una estructura ARRAY.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
MOVE_BLK(IN := #a_array[2],
COUNT := "Tag_Count",
OUT => #b_array[1]);

Programación del PLC
Manual de programación y manejo, 11/2019

1855

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

a_array[2]

El operando "a_array" es del tipo
de datos ARRAY[0..5] of INT.
Consta de 6 elementos del tipo
de datos INT.

COUNT

Tag_Count

3

OUT

b_array[1]

El operando "b_array" es del tipo
de datos ARRAY[0..6] of INT.
Consta de 7 elementos del tipo
de datos INT.

La instrucción selecciona a partir del tercer elemento tres elementos INT de la variable
#a_array y copia su contenido en la variable de salida #b_array, comenzando por el segundo
elemento.
Nota
Encontrará más información sobre la instrucción MOVE_BLK en el Siemens Industry Online
Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

MOVE_BLK_VARIANT: Copiar área
Descripción
La instrucción "Copiar área" copia los contenidos de un área de memoria (área de origen) en
un área de memoria diferente (área de destino). Se pueden copiar elementos de un ARRAY o
un ARRAY completo en otro ARRAY del mismo tipo de datos. El tamaño (número de
elementos) de los ARRAY de origen y de destino puede diferir. Se pueden copiar varios
elementos dentro de un mismo ARRAY o bien copiar elementos individuales.
El número de elementos que deben copiarse no puede rebasar el área de origen o destino
seleccionado.
Cuando se utiliza la instrucción no es necesario conocer el ARRAY en el momento de crear el
bloque, puesto que el origen y el destino se transfieren vía VARIANT.
El recuento en los parámetros SRC_INDEX y DEST_INDEX comienza siempre por el límite
inferior "0", independientemente de la declaración posterior del ARRAY.

1856

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucción no se ejecuta si se copian más datos de los que están disponibles.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

SRC

Input

VARIANT (que
apunta a un
ARRAY o a un ele‐
mento individual
del ARRAY),
ARRAY of <tipo de
datos>

L (puede declarar‐ El área de origen de la que se
se en las seccio‐
copia
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

COUNT

Input

UDINT

I, Q, M, D, L

2)

Descripción

Número de elementos que
se copian
Asigne al parámetro COUNT
el valor "1" si en el parámetro
SRC o en el parámetro DEST
no hay indicado ningún
ARRAY.

SRC_INDEX

Input

DINT

I, Q, M, D, L

Define el primer elemento
que se copia:
● El parámetro
SRC_INDEX se calcula
basado en cero. Si en el
parámetro SRC hay
indicado un ARRAY, el
entero del parámetro
SRC_INDEX indica el
primer elemento del área
de origen de la que debe
copiarse. Esto es así
independientemente de
los límites declarados del
ARRAY.
● Si en el parámetro SRC
no hay indicado ningún
ARRAY o solo un
elemento individual de un
ARRAY, asigne el valor
"0" al parámetro
SRC_INDEX.

Programación del PLC
Manual de programación y manejo, 11/2019

1857

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

DEST_IN‐
DEX

Input

DINT

I, Q, M, D, L

Define el inicio del área de
memoria de destino:
● El parámetro
DEST_INDEX se calcula
basado en cero. Si en el
parámetro DEST hay
indicado un ARRAY, el
entero del parámetro
DEST_INDEX indica el
primer elemento del área
de destino en la que debe
copiarse. Esto es así
independientemente de
los límites declarados del
ARRAY.
● Si en el parámetro DEST
no hay indicado ningún
ARRAY, asigne el valor
"0" al parámetro
DEST_INDEX.

DEST

Output 1)

Valor de función (RET_VAL)

VARIANT

L (puede declarar‐ Área de destino a la que se
se en las seccio‐
copia el contenido del área
nes "Input",
de origen.
"InOut" y "Temp"
de la interfaz del
bloque.)

INT

I, Q, M, D, L

Información de error

1) El parámetro DEST está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.
2) En el parámetro SRC, los tipos de datos BOOL y ARRAY of BOOL no están permitidos.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)

1858

0000

Ningún error

80B4

Los tipos de datos no coinciden. En lugar de un ARRAY of Struct utilice un ARRAY of tipo
de datos PLC (UDT).

8151

No es posible acceder al parámetro SRC.

8152

El operando del parámetro SRC no está tipificado.

8153

Error de creación de código en el parámetro SRC

8154

El operando del parámetro SRC es del tipo de datos BOOL.

8281

Valor no válido en el parámetro COUNT

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*

Explicación

(W#16#...)
8382

El valor del parámetro SRC_INDEX es menor que CERO.

8383

El valor del parámetro SRC_INDEX se encuentra fuera del límite superior del ARRAY.

8482

El valor del parámetro DEST_INDEX se encuentra fuera de los límites del ARRAY.

8483

El ARRAY al que señala el parámetro DEST es demasiado pequeño para los datos que
deben copiarse.

8534

El parámetro DEST está protegido contra escritura

8551

No es posible acceder al parámetro DEST.

8552

El operando del parámetro DEST no está tipificado.

8553

Error de creación de código en el parámetro DEST

8554

El operando del parámetro DEST es del tipo de datos BOOL.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := MOVE_BLK_VARIANT(SRC := #SrcField,
COUNT := "Tag_Count",
SRC_INDEX := "Tag_Src_Index",
DEST_INDEX := "Tag_Dest_Index",
DEST => #DestField);

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Declaración en la inter‐
faz del bloque

Operando

Valor

SRC

Input

#SrcField

El operando local
#SrcField utiliza un tipo
de datos PLC todavía
desconocido en el mo‐
mento de programar el
bloque. (ARRAY[0..10]
of "MOVE_UDT"

COUNT

Input

Tag_Count

2

SRC_INDEX

Input

Tag_Src_Index

3

Programación del PLC
Manual de programación y manejo, 11/2019

1859

Instrucciones
4.1 Instrucciones
Parámetro

Declaración en la inter‐
faz del bloque

Operando

Valor

DEST_INDEX

Input

Tag_Dest_Index

3

DEST

InOut

#DestField

El operando local
#DestField utiliza un ti‐
po de datos PLC toda‐
vía desconocido en el
momento de programar
el bloque.
(ARRAY[10..20] of "MO‐
VE_UDT"

En el área de destino se copian dos elementos del área de origen, empezando por el cuarto
elemento del ARRAY[0..10] of MOVE_UDT. Las copias se insertan en el ARRAY[10..20] of
MOVE_UDT a partir del cuarto elemento.
Nota
Encontrará más información sobre la instrucción MOVE_BLK_VARIANT en el Siemens
Industry Online Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
VariantGet: Leer valor de una variable VARIANT (Página 1914)
Principios básicos de SCL (Página 8115)

UMOVE_BLK: Copiar área sin interrupciones
Descripción
La instrucción "Copiar área sin interrupciones" copia sin interrupciones los contenidos de un
área de memoria (área de origen) en un área de memoria diferente (área de destino). El
número de elementos que se copian en el área de destino se determina con el parámetro
COUNT. El ancho del primer elemento del área de origen define el ancho de los elementos que
deben copiarse.

1860

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
Nota
La operación de copia no debe ser interrumpida por otras actividades del sistema operativo.
Por este motivo, los tiempos de reacción a alarmas de la CPU podrían aumentar al ejecutar la
instrucción "Copiar área sin interrupciones".
El valor de la salida OUT no es válido si se cumple la siguiente condición:
● Se copian más datos de los que están disponibles en el parámetro IN o en el parámetro
OUT.
La instrucción "Copiar área sin interrupciones" permite copiar 16 KB como máximo. A este
respecto deben tenerse en cuenta las limitaciones específicas de la CPU.
Nota
Uso de ARRAYs
La instrucción copia el contenido a partir del elemento definido n elementos (n = depende del
valor del parámetro COUNT) desde el área de origen al área de destino, comenzando por el
índice especificado.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

S7-1200

S7-1500

IN 1)

Input

Números bina‐
rios, enteros,
números en co‐
ma flotante,
tiempos, DA‐
TE, CHAR,
WCHAR, TOD

Números bi‐ D, L
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD, LTOD

Primer elemen‐
to del área de
origen que se
copia

COUNT

Input

USINT, UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

Número de ele‐
mentos que se
copian del área
de origen al
área de destino

Programación del PLC
Manual de programación y manejo, 11/2019

Tipo de datos

Área de memo‐ Descripción
ria

I, Q, M, D, L, P

1861

Instrucciones
4.1 Instrucciones
Parámetro
OUT 1)

1)

Declaración
Output

Tipo de datos

Área de memo‐ Descripción
ria

S7-1200

S7-1500

Números bina‐
rios, enteros,
números en co‐
ma flotante,
tiempos, DA‐
TE, CHAR,
WCHAR, TOD

Números bi‐ D, L
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD, LTOD

Primer elemen‐
to del área de
destino en la
que se copian
los contenidos
del área de ori‐
gen

Los tipos de datos indicados solamente pueden utilizarse como elementos de una estructura ARRAY.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
UMOVE_BLK(IN := #a_array[2],
COUNT := "Tag_Count",
OUT => #b_array[1]);

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

a_array[2]

El operando "a_array" es del tipo
de datos ARRAY[0..5] of INT.
Consta de 6 elementos del tipo
de datos INT.

COUNT

Tag_Count

3

OUT

b_array[1]

El operando "b_array" es del tipo
de datos ARRAY[0..6] of INT.
Consta de 7 elementos del tipo
de datos INT.

La instrucción selecciona a partir del tercer elemento tres elementos INT de la variable
#a_array y copia su contenido en la variable de salida #b_array, comenzando por el segundo
elemento. La operación de copia no debe ser interrumpida por otras actividades del sistema
operativo.
Nota
Encontrará más información sobre la instrucción UMOVE_BLK en el Siemens Industry Online
Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

1862

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

FILL_BLK: Rellenar área
Descripción
La instrucción "Rellenar área" permite rellenar un área de memoria (área de destino) con el
valor de la entrada IN. El área de destino se rellena a partir de la dirección indicada en la salida
OUT. El número de repeticiones de copia se determina mediante el parámetro COUNT. Al
ejecutar la instrucción, el valor de la entrada IN se copia en el área de destino el número de
veces especificado por el valor del parámetro COUNT.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
Como máximo se modifican tantos elementos como tiene el ARRAY o la estructura. Si se
copian más datos que los elementos disponibles en la salida OUT, el resultado no será el
deseado.
Nota
Uso de ARRAYs
La instrucción lee en el área de origen el contenido del elemento seleccionado y lo copia n
veces (n = depende del valor del parámetro COUNT) en el área de destino, comenzado a partir
del índice especificado.

Rellenar estructuras
Además de los elementos de un ARRAY, también es posible rellenar varios elementos de una
estructura (STRUCT, tipo de datos PLC) con el mismo valor. La estructura cuyos elementos
deben rellenarse puede contener únicamente elementos individuales del mismo tipo de datos
elemental. No obstante, la estructura propiamente dicha puede estar incrustada en otra
estructura.

Programación del PLC
Manual de programación y manejo, 11/2019

1863

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de me‐
moria

Descripción

IN

Input

Números bina‐
rios, enteros, nú‐
meros en coma
flotante, tempori‐
zadores, TOD,
DATE, CHAR,
WCHAR

Números bina‐
rios, enteros, nú‐
meros en coma
flotante, tiempos,
DATE, CHAR,
WCHAR, TOD,
LTOD

I, Q, M, D, L,
P

Elemento con el
que se rellena el
área de destino

COUNT

Input

USINT, UINT,
UDINT

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L,
P

Número de repe‐
ticiones de copia

OUT

Output

Números bina‐
rios, enteros, nú‐
meros en coma
flotante, tempori‐
zadores, TOD,
DATE, CHAR,
WCHAR

Números bina‐
rios, enteros, nú‐
meros en coma
flotante, tiempos,
DATE, CHAR,
WCHAR, TOD,
LTOD

D, L

Dirección del
área de destino
a partir de la
cual se rellena

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
El siguiente ejemplo muestra el funcionamiento de la instrucción cuando debe rellenarse un
ARRAY:
SCL
FILL_BLK(IN := #FillValue,
COUNT := "Tag_Count",
OUT => #TargetArea[1]);

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

FillValue

El operando es del tipo de datos
INT.

COUNT

Tag_Count

3

OUT

TargetArea

El operando TargetArea es del
tipo de datos ARRAY[1..5] of
INT. Consta de 5 elementos del
tipo de datos INT.

La instrucción copia tres veces el valor del operando #FillValue en la variable de salida
#TargetArea, empezando por el primer elemento.

1864

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplos con una estructura
Los siguientes ejemplos muestran el funcionamiento de la instrucción cuando debe rellenarse
una estructura.
Cree un bloque de datos global con los elementos siguientes:
Data_block_1

Tipo de datos

MyStruct1

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

MyStruct2

STRUCT

SubArray

ARRAY[1..2] of STRUCT

SubArray[1]

STRUCT

NestedStruct

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

SubArray[2]

STRUCT

Nes‐
tedStruct

STRUCT
Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

Cree el código de programa siguiente para direccionar la variable MyStruct1:
SCL
FILL_BLK(IN := 10,
COUNT := 2,
OUT => "Data_block_1".MyStruct1.Member_2);

Cree el código de programa siguiente para direccionar la variable MyStruct2:
SCL
FILL_BLK(IN := 10,
COUNT := 2,
OUT => "Data_block_1".MyStruct2.SubArray[1].NestedStruct.Member_2);

En ambos ejemplos, el valor 10 del parámetro IN se copia dos veces en el operando del
parámetro OUT, empezando por el elemento Member_2. Esto significa que el valor 10 se copia
tanto en el elemento Member_2 como en el Member_3. Los otros dos elementos, Member_1
y Member_4, no cambian.

Programación del PLC
Manual de programación y manejo, 11/2019

1865

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

UFILL_BLK: Rellenar área sin interrupciones
Descripción
La instrucción "Rellenar área sin interrupciones" rellena sin interrupciones un área de memoria
(área de destino) con el valor de la entrada IN. El área de destino se rellena a partir de la
dirección indicada en la salida OUT. El número de repeticiones de copia se determina
mediante el parámetro COUNT. Al ejecutar la instrucción, el valor de la entrada IN se copia en
el área de destino el número de veces especificado por el valor del parámetro COUNT.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
Nota
La operación de copia no debe ser interrumpida por otras actividades del sistema operativo.
Por este motivo, los tiempos de reacción a alarmas de la CPU podrían aumentar al ejecutar la
instrucción "Rellenar área sin interrupciones".
Como máximo se modifican tantos elementos como tiene el ARRAY o la estructura. Si se
copian más datos que los elementos disponibles en la salida OUT, el resultado no será el
deseado.
Nota
Uso de ARRAYs
La instrucción lee en el área de origen el contenido del elemento seleccionado y lo copia n
veces (n = depende del valor del parámetro COUNT) en el área de destino, comenzado a partir
del índice especificado.
La instrucción "Rellenar área sin interrupciones" permite copiar 16 KB como máximo. A este
respecto deben tenerse en cuenta las limitaciones específicas de la CPU.

Rellenar estructuras
Además de los elementos de un ARRAY, también es posible rellenar varios elementos de una
estructura (STRUCT, tipo de datos PLC) con el mismo valor. La estructura cuyos elementos
deben rellenarse puede contener únicamente elementos individuales del mismo tipo de datos
elemental. No obstante, la estructura propiamente dicha puede estar incrustada en otra
estructura.

1866

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de me‐
moria

Descripción

IN

Input

Números bina‐
rios, enteros,
números en
coma flotante,
tiempos, DA‐
TE, CHAR,
WCHAR, TOD

Números bina‐
rios, enteros,
números en co‐
ma flotante,
tiempos, DATE,
CHAR,
WCHAR, TOD,
LTOD

I, Q, M, D, L, P Elemento con el
que se rellena el
área de destino

COUNT

Input

USINT, UINT,
UDINT

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P Número de repeti‐
ciones de copia

OUT

Output

Números bina‐
rios, enteros,
números en
coma flotante,
temporizado‐
res, TOD, DA‐
TE, CHAR,
WCHAR

Números bina‐
rios, enteros,
números en co‐
ma flotante,
tiempos, DATE,
CHAR,
WCHAR, TOD,
LTOD

D, L

Dirección del área
de destino a partir
de la cual se relle‐
na

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
El siguiente ejemplo muestra el funcionamiento de la instrucción cuando debe rellenarse un
ARRAY:
SCL
UFILL_BLK(IN := #FillValue,
COUNT := "Tag_Count",
OUT => #TargetArea[1]);

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

FillValue

El operando es del tipo de datos
INT.

COUNT

Tag_Count

3

OUT

TargetArea

El operando TargetArea es del
tipo de datos ARRAY[1..5] of
INT. Consta de 5 elementos del
tipo de datos INT.

La instrucción copia tres veces el valor del operando #FillValue en la variable de salida
#TargetArea, empezando por el primer elemento. La operación de copia no debe ser
interrumpida por otras actividades del sistema operativo.

Programación del PLC
Manual de programación y manejo, 11/2019

1867

Instrucciones
4.1 Instrucciones

Ejemplos con una estructura
Los siguientes ejemplos muestran el funcionamiento de la instrucción cuando debe rellenarse
una estructura.
Cree un bloque de datos global con los elementos siguientes:
Data_block_1

Tipo de datos

MyStruct1

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

MyStruct2

STRUCT

SubArray

ARRAY[1..2] of STRUCT

SubArray[1]

STRUCT

NestedStruct

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

SubArray[2]

STRUCT

Nes‐
tedStruct

STRUCT
Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

Cree el código de programa siguiente para direccionar la variable MyStruct1:
SCL
UFILL_BLK(IN := 10,
COUNT := 2,
OUT => "Data_block_1".MyStruct1.Member_2);

Cree el código de programa siguiente para direccionar la variable MyStruct2:
SCL
UFILL_BLK(IN := 10,
COUNT := 2,
OUT => "Data_block_1".MyStruct2.SubArray[1].NestedStruct.Member_2);

En ambos ejemplos, el valor 10 del parámetro IN se copia dos veces en el operando del
parámetro OUT, empezando por el elemento Member_2. Esto significa que el valor 10 se copia
tanto en el elemento Member_2 como en el Member_3. Los otros dos elementos, Member_1
y Member_4, no cambian.

1868

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

SCATTER: Dispersión de una secuencia de bits en bits individuales
Descripción
La instrucción "Dispersión de una secuencia de bits en bits individuales" descompone una
variable del tipo de datos BYTE, WORD, DWORD o LWORD en bits individuales y los guarda
en un ARRAY of BOOL, un STRUCT anónimo o un tipo de datos PLC con elementos
booleanos exclusivamente.
Nota
ARRAY of BOOL multidimensional
En la instrucción "Dispersión de una secuencia de bits en bits individuales" no está permitido
utilizar un ARRAY of BOOL multidimensional.
Nota
Longitud del ARRAY, del STRUCT o del tipo de datos PLC
El ARRAY, el STRUCT anónimo o el tipo de datos PLC deben tener tantos elementos como se
especifique en la secuencia de bits.
Es decir, en el tipo de datos BYTE, p. ej., el ARRAY, el STRUCT o el tipo de datos PLC deben
tener exactamente 8 elementos (WORD = 16, DWORD = 32 y LWORD = 64).
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1200 a partir de la versión de firmware
>4.2 y en las CPU de la serie S7-1500 a partir de la versión de firmware 2.1.
De este modo es posible, p. ej., descomponer una palabra de estado y leer y modificar por
índice el estado de los bits individuales. Mediante GATHER pueden juntarse nuevamente los
bits en una secuencia de bits.
La salida de habilitación ENO devuelve el estado lógico "0" si se cumple una de las siguientes
condiciones:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El ARRAY, STRUCT o tipo de datos PLC no proporciona suficientes elementos BOOL.

Programación del PLC
Manual de programación y manejo, 11/2019

1869

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declara‐
ción

IN

Input

OUT

Output

Tipo de datos
S7-1200

S7-1500

BYTE, WORD,
DWORD

BYTE,
WORD,
DWORD,
LWORD

Área de me‐ Descripción
moria
I, Q, M, D, L Secuencia de bits que se des‐
compone.
Los valores no pueden encon‐
trarse en el área de periferia o
en el DB de un objeto tecnoló‐
gico.

ARRAY[*] of
BOOL,
STRUCT o ti‐
po de datos
PLC

ARRAY[*] of I, Q, M, D, L ARRAY, STRUCT o tipo de da‐
tos PLC en el/los que se guar‐
BOOL,
dan los bits individuales
STRUCT o
tipo de datos
PLC

*: 8, 16, 32 o
64 elementos

*: 8, 16, 32 o
64 elemen‐
tos

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceWord

Input

WORD

DestinationArray

Output

ARRAY[0..15] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
SCATTER(IN := #SourceWord,
OUT => #DestinationArray);

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceWord

WORD (16 bits)

OUT

DestinationArray

El operando "DestinationArray"
es del tipo de datos
ARRAY[0..15] of BOOL. Consta
de 16 elementos y, por tanto, tie‐
ne el mismo tamaño que la
WORD que se debe descompo‐
ner.

El operando #SourceWord del tipo de datos WORD se descompone en sus bits individuales
(16) y se asigna a los distintos elementos del operando #DestinationArray.

1870

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo con un tipo de datos PLC (UDT)
Cree el siguiente tipo de datos PLC "myBits":

Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceWord

Input

WORD

DestinationUDT

Output

"myBits"

El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
SCATTER(IN := #SourceWord,
OUT => #DestinationUDT);

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceWord

WORD (16 bits)

OUT

DestinationUDT

El operando "DestinationUDT"
es del tipo de datos PLC (UDT).
Consta de 16 elementos y, por
tanto, tiene el mismo tamaño
que la WORD que se debe des‐
componer.

El operando #SourceWord del tipo de datos WORD se descompone en sus bits individuales
(16) y se asigna a los distintos elementos del operando #DestinationUDT.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1871

Instrucciones
4.1 Instrucciones

SCATTER_BLK: Dispersión de elementos de un ARRAY of secuencia de bits en bits individuales
Descripción
La instrucción "Dispersión de elementos de un ARRAY of secuencia de bits en bits
individuales" descompone uno o varios elementos de un ARRAY of BYTE, WORD, DWORD
o LWORD en bits individuales y los guarda en un ARRAY of BOOL, un STRUCT anónimo o un
tipo de datos PLC con elementos booleanos exclusivamente. En el parámetro COUNT_IN se
introduce el número de elementos del ARRAY de origen que deben dispersarse. El ARRAY de
origen en el parámetro IN puede tener más elementos que los indicados en el parámetro
COUNT_IN. El ARRAY of BOOL, el STRUCT anónimo o el tipo de datos PLC deben tener
suficientes elementos para poder guardar los bits de la secuencia de bits descompuesta. El
área de memoria de destino también puede ser mayor.
Nota
ARRAY of BOOL multidimensional
Si el ARRAY es un ARRAY of BOOL multidimensional, se cuentan también los bits de relleno
de las dimensiones contenidas, aunque no se hayan declarado explícitamente.
Ejemplo 1: un ARRAY[1..10,0..4,1..2] of BOOL recibe el mismo tratamiento que un
ARRAY[1..10,0..4,1..8] of BOOL o que un ARRAY[0..399] of BOOL.
Ejemplo 2: En el parámetro IN hay un ARRAY[0..5] of WORD (sourceArrayWord[2])
interconectado. El parámetro COUNT_IN tiene el valor "3". En el parámetro OUT hay un
ARRAY[0..1,0..5,0..7] of BOOL (destinationArrayBool[0,0,0]) interconectado. Tanto el array
del parámetro IN como el del parámetro OUT tienen 96 bits de tamaño. El ARRAY of WORD
se descompone en 48 bits individuales.
Nota
Si el límite inferior del ARRAY de destino no es "0", cabe considerar lo siguiente:
Por motivos de rendimiento, el índice debe comenzar siempre en un límite de BYTE, WORD,
DWORD o LWORD. Esto significa que debe calcularse el índice partiendo del límite inferior del
ARRAY. Como base para el cálculo se utiliza la siguiente fórmula:
Índice válido = límite inferior del ARRAY + n(número de secuencias de bits) * número de bits
de la secuencia de bits deseada
Para un ARRAY[-2..45] of BOOL y la secuencia de bits WORD, el cálculo es el siguiente:
● Índice válido (-2) = -2 + 0 * 16
● Índice válido (14) = -2 + 1 * 16
● Índice válido (30) = -2 + 2 * 16
Ver un ejemplo más adelante.
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1200 a partir de la versión de firmware
>4.2 y en las CPU de la serie S7-1500 a partir de la versión de firmware 2.1.

1872

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
De este modo es posible, p. ej., descomponer palabras de estado y leer y modificar por índice
el estado de los bits individuales. Mediante GATHER pueden juntarse nuevamente los bits en
una secuencia de bits.
La salida de habilitación ENO devuelve el estado lógico "0" si se cumple una de las siguientes
condiciones:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El ARRAY de origen tiene menos elementos que los que se especifican en el parámetro
COUNT_IN.
● El índice del ARRAY de destino no empieza en un límite de BYTE, WORD, DWORD o
LWORD. En este caso no se escribe ningún resultado en el ARRAY of BOOL.
● El ARRAY[*] of BOOL, el STRUCT o el tipo de datos PLC no proporcionan el número
necesario de elementos.
– CPU S7-1500: se descomponen tantas secuencias de bits como sea posible y se
escriben en el ARRAY of BOOL, STRUCT anónimo o tipo de datos PLC. El resto de
secuencias de bits no se tiene en cuenta.
– CPU S7-1200: no se efectúa ninguna copia.
Nota
CPU S7-1200: Salida de habilitación ENO = 0
Si la salida de habilitación ENO devuelve el estado lógico "0", no se escribirán datos en el
parámetro de salida OUT.

Programación del PLC
Manual de programación y manejo, 11/2019

1873

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro
IN

COUNT_IN

Declara‐
ción
Input

Input

Tipo de datos

Área de
memoria

Descripción

S7-1200

S7-1500

Elemento de un
ARRAY[*] of
<secuencia de
bits>

Elemento de
un
ARRAY[*] of
<secuencia
de bits>

I, Q, M, D, L ARRAY of <secuencia de
bits> que se descompone.

USINT, UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

I, Q, M, D, L Contador del número de ele‐
mentos del ARRAY de ori‐
gen que deben descompo‐
nerse.

Los valores no pueden en‐
contrarse en el área de peri‐
feria o en el DB de un objeto
tecnológico.

El valor no puede encontrar‐
se en el área de periferia o
en el DB de un objeto tecno‐
lógico.
OUT

Output

Elemento de un
ARRAY[*] of
BOOL,
STRUCT o tipo
de datos PLC

Elemento de I, Q, M, D, L ARRAY, STRUCT o tipo de
datos PLC en el/los que se
un
guardan los bits individuales
ARRAY[*] of
BOOL,
STRUCT o
tipo de datos
PLC

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo de un ARRAY de destino con el límite inferior de "0"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArrayWord

Input

ARRAY[0..5] of WORD

CounterInput
DestinationArrayBool

UDINT
Output

ARRAY[0..95] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
SCATTER_BLK(IN := #SourceArrayWord[2],
COUNT_IN := #CounterInput,
OUT => #DestinationArrayBool[0]);

1874

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayWord[2]

ARRAY[0..5] of WORD (Pueden
dispersarse 96 bits.)

COUNT_IN

CounterInput = 3

UDINT3 (deben descomponerse
3 WORD o 48 bits. Esto significa
que en el ARRAY de destino de‐
be haber al menos 48 bits).

OUT

DestinationArrayBool[0]

El operando "DestinationArray‐
Bool" es del tipo de datos
ARRAY[0..95] of BOOL. Hay por
tanto 96 elementos BOOL dispo‐
nibles.

La 3.ª, 4.ª y 5.ª WORD del operando #SourceArrayWord se descomponen en sus bits
individuales (48) y se asignan a los distintos elementos del operando #DestinationArrayBool a
partir del 1.er elemento.

Ejemplo de ARRAY de destino con el límite inferior de "-2"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArrayWord

Input

ARRAY[0..5] of WORD

CounterInput

UDINT

DestinationArrayBool

Output

ARRAY[-2..93] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
SCATTER_BLK(IN := #SourceArrayWord[2],
COUNT_IN := #CounterInput,
OUT => #DestinationArrayBool[14]);

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayWord[2]

ARRAY[0..5] of WORD (Pueden
dispersarse 96 bits.)

COUNT_IN

CounterInput = 3

UDINT3 (deben descomponerse
3 WORD o 48 bits. Esto significa
que en el ARRAY de destino de‐
be haber al menos 48 bits).

OUT

DestinationArrayBool[14]

El operando "DestinationArray‐
Bool" es del tipo de datos
ARRAY[-2..93] of BOOL. Hay
por tanto 96 elementos BOOL
disponibles.

Programación del PLC
Manual de programación y manejo, 11/2019

1875

Instrucciones
4.1 Instrucciones
La 3.ª, 4.ª y 5.ª WORD del operando #SourceArrayWord se descompone en sus bits
individuales (48) y a partir del 16.º elemento se asignan a los distintos elementos del operando
#DestinationArrayBool.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

GATHER: Recopilación de bits individuales en una secuencia de bits
Descripción
La instrucción "Recopilación de bits individuales en una secuencia de bits" recompone los bits
de un ARRAY of BOOL, un STRUCT anónimo o un tipo de datos PLC en una secuencia de bits
con elementos booleanos exclusivamente. La secuencia de bits se guarda en una variable del
tipo de datos BYTE, WORD, DWORD o LWORD.
Nota
ARRAY of BOOL multidimensional
En la instrucción "Recopilación de bits individuales en una secuencia de bits" no está permitido
utilizar un ARRAY of BOOL multidimensional.
Nota
Longitud del ARRAY, del STRUCT o del tipo de datos PLC
El ARRAY, el STRUCT o el tipo de datos PLC deben tener tantos elementos como se
especifique en la secuencia de bits.
Es decir, en el tipo de datos BYTE, p. ej., el ARRAY, el STRUCT anónimo o el tipo de datos PLC
deben tener exactamente 8 elementos (WORD = 16, DWORD = 32 y LWORD = 64).
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1200 a partir de la versión de firmware
>4.2 y en las CPU de la serie S7-1500 a partir de la versión de firmware 2.1.
La salida de habilitación ENO devuelve el estado lógico "0" si se cumple una de las siguientes
condiciones:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El ARRAY, STRUCT o tipo de datos PLC (UDT) tiene más o menos elementos BOOL que
lo que especifica la secuencia de bits. En este caso no se transfieren los elementos BOOL.
● Hay menos bits que el número de bits necesario.

1876

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro
IN

Declara‐
ción
Input

Tipo de datos
S7-1500

ARRAY[*] of
BOOL,
STRUCT o tipo
de datos PLC

ARRAY[*] of I, Q, M, D, L
BOOL,
STRUCT o
tipo de datos
PLC

*: 8, 16, 32 o 64
elementos

OUT

Output

Área de me‐
moria

S7-1200

BYTE, WORD,
DWORD

*: 8, 16, 32 o
64 elemen‐
tos
BYTE,
WORD,
DWORD,
LWORD

I, Q, M, D, L

Descripción
ARRAY, STRUCT o tipo
de datos PLC cuyos bits
se recomponen en una
secuencia de bits.
Los valores no pueden
encontrarse en el área de
periferia o en el DB de un
objeto tecnológico.
Secuencia de bits recopi‐
lada que está guardada
en una variable

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArray

Input

ARRAY[0..15] of BOOL

DestinationWord

Output

WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
GATHER(IN := #SourceArray,
OUT => #DestinationWord);

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operando
concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArray

El operando "SourceArray" es
del tipo de datos ARRAY[0..15]
of BOOL. Consta de 16 elemen‐
tos y, por tanto, tiene el mismo
tamaño que la WORD en la que
se deben recomponer los bits.

OUT

DestinationWord

WORD (16 bits)

Los bits del operando #SourceArray se recopilan en una WORD.

Programación del PLC
Manual de programación y manejo, 11/2019

1877

Instrucciones
4.1 Instrucciones

Ejemplo con un tipo de datos PLC (UDT)
Cree el siguiente tipo de datos PLC "myBits":

Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceUDT

Input

"myBits"

DestinationWord

Output

WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
GATHER(IN := #SourceUDT,
OUT => #DestinationWord);

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operando
concretos:
Parámetro

Operando

Tipo de datos

IN

SourceUDT

El operando "SourceUDT" es del
tipo de datos PLC (UDT). Consta
de 16 elementos y, por tanto, tie‐
ne el mismo tamaño que la
WORD en la que se deben re‐
componer los bits.

OUT

DestinationWord

WORD (16 bits)

Los bits del operando #SourceUDT se recomponen en una WORD.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

1878

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

GATHER_BLK: Recopilación de bits individuales en varios elementos de un ARRAY of secuencia de bits
Descripción
La instrucción "Recopilación de bits individuales en varios elementos de un ARRAY of
secuencia de bits" recompone los bits de un ARRAY of BOOL, un STRUCT anónimo o un tipo
de datos PLC con elementos booleanos exclusivamente en uno o varios elementos de un
ARRAY of <secuencia de bits>. En el parámetro COUNT_OUT se introduce el número de
elementos del ARRAY de destino que deben escribirse. Al hacerlo se especifica
implícitamente cuántos elementos del ARRAY of BOOL, del STRUCT anónimo o del tipo de
datos PLC se necesitan. El ARRAY de destino en el parámetro OUT puede tener más
elementos que los indicados en el parámetro COUNT_OUT. El ARRAY of <secuencia de bits>
debe tener suficientes elementos para poder guardar los bits que deben recopilarse. El
ARRAY de destino también puede ser mayor.
Nota
ARRAY of BOOL multidimensional
Si el ARRAY es un ARRAY of BOOL multidimensional, se cuentan también los bits de relleno
de las dimensiones contenidas, aunque no se hayan declarado explícitamente.
Ejemplo 1: un ARRAY[1..10,0..4,1..2] of BOOL recibe el mismo tratamiento que un
ARRAY[1..10,0..4,1..8] of BOOL o que un ARRAY[0..399] of BOOL.
Ejemplo 2: En el parámetro OUT hay un ARRAY[0..5] of WORD (sourceArrayWord[2])
interconectado. El parámetro COUNT_IN tiene el valor "3". En el parámetro IN hay un
ARRAY[0..1,0..5,0..7] of BOOL (destinationArrayBool[0,0,0]) interconectado. Tanto el array
del parámetro IN como el del parámetro OUT tienen 96 bits de tamaño. A partir del ARRAY of
BOOL se recomponen 48 bits individuales.
Nota
Si el límite inferior del ARRAY de origen no es "0", cabe considerar lo siguiente:
Por motivos de rendimiento, el índice debe comenzar siempre en un límite de BYTE, WORD,
DWORD o LWORD. Esto significa que debe calcularse el índice partiendo del límite inferior del
ARRAY. Como base para el cálculo se utiliza la siguiente fórmula:
Índice válido = límite inferior del ARRAY + n(número de secuencias de bits) * número de bits
de la secuencia de bits deseada
Para un ARRAY[-2..45] of BOOL y la secuencia de bits WORD, el cálculo es el siguiente:
● Índice válido (-2) = -2 + 0 * 16
● Índice válido (14) = -2 + 1 * 16
● Índice válido (30) = -2 + 2 * 16
Ver un ejemplo más adelante.
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1200 a partir de la versión de firmware
>4.2 y en las CPU de la serie S7-1500 a partir de la versión de firmware 2.1.

Programación del PLC
Manual de programación y manejo, 11/2019

1879

Instrucciones
4.1 Instrucciones
La salida de habilitación ENO devuelve el estado lógico "0" si se cumple una de las siguientes
condiciones:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El índice del ARRAY de origen no empieza en un límite de BYTE, WORD, DWORD o
LWORD. En este caso no se escribe ningún resultado en el ARRAY of <secuencia de bits>.
● El ARRAY[*] of <secuencia de bits> no proporciona el número necesario de elementos.
– CPU S7-1500: se juntan tantas secuencias de bits como sea posible y se escriben en el
ARRAY of <secuencia de bits>. El resto de los bits no se tiene en cuenta.
– CPU S7-1200: no se efectúa ninguna copia.
Nota
CPU S7-1200: Salida de habilitación ENO = 0
Si la salida de habilitación ENO devuelve el estado lógico "0", no se escribirán datos en el
parámetro de salida OUT.

1880

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro
IN

Declaración

Tipo de datos

Input

Área de memo‐ Descripción
ria

S7-1200

S7-1500

Elemento de un
ARRAY[*] of
BOOL,
STRUCT o tipo
de datos PLC

Elemento de I, Q, M, D, L
un
ARRAY[*] of
BOOL,
STRUCT o
tipo de datos
PLC

ARRAY of
BOOL,
STRUCT o tipo
de datos PLC
cuyos bits se re‐
componen
(ARRAY de ori‐
gen).
Los valores no
pueden encon‐
trarse en el
área de perife‐
ria o en el DB
de un objeto
tecnológico.

COUNT_OUT

Input

USINT, UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

I, Q, M, D, L

Contador del
número de ele‐
mentos del
ARRAY de des‐
tino que deben
escribirse.
El valor no pue‐
de encontrarse
en el área de
periferia o en el
DB de un obje‐
to tecnológico.

OUT

Output

Elemento de un
ARRAY[*] of
<secuencia de
bits>

Elemento de
un
ARRAY[*] of
<secuencia
de bits>

I, Q, M, D, L

ARRAY de <se‐
cuencia de
bits> en el que
se guardan los
bits (ARRAY de
destino)

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo de ARRAY de origen con el límite inferior de "0"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArrayBool

Input

ARRAY[0..95] of BOOL

CounterOutput
DestinationArrayWord

Programación del PLC
Manual de programación y manejo, 11/2019

UDINT
Output

ARRAY[0..5] of WORD

1881

Instrucciones
4.1 Instrucciones
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
GATHER_BLK(IN := #SourceArrayBool[0],
COUNT_OUT := #CounterOutput,
OUT => #DestinationArrayWord[2]);

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayBool[0]

El operando "SourceArrayBool"
es del tipo de datos
ARRAY[0..95] of BOOL. Hay por
tanto 96 elementos BOOL dispo‐
nibles que pueden volver a reco‐
pilarse en palabras.

COUNT_OUT

CounterOutput = 3

UDINT3 (deben escribirse 3 pa‐
labras. Esto significa que en el
ARRAY de origen debe haber 48
bits).

OUT

DestinationArrayWord[2]

El operando "DestinationArray‐
Word" es del tipo de datos
ARRAY[0..5] of WORD. Hay 6
elementos WORD disponibles.

Si el operando #Enable devuelve el estado lógico "1" en la entrada de habilitación EN, se
ejecuta la instrucción. A partir del 1.er elemento del operando #SourceArrayBool se
recomponen 48 bits en el operando #DestinationArrayWord. En el ARRAY de destino se
empieza a partir del 3.er elemento. Esto significa que los primeros 16 bits se escriben en la 3.ª
palabra, los segundos 16 bits en la 4.ª palabra y los terceros 16 bits en la 5.ª palabra del
ARRAY de destino. Si ocurre un error durante la ejecución de la instrucción, el operando
#EnableOut devuelve el estado lógico "0" en la salida de habilitación ENO.

Ejemplo de ARRAY de origen con el límite inferior de "-2"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArrayBool

Input

ARRAY[-2..93] of BOOL

CounterOutput

UDINT

DestinationArrayWord

Output

ARRAY[0..5] of WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
GATHER_BLK(IN := #SourceArrayBool[14],
COUNT_OUT := #CounterOutput,
OUT => #DestinationArrayWord[2]);

1882

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayBool[14]

El operando "SourceArrayBool"
es del tipo de datos
ARRAY[-2..93] of BOOL. Dado
que se empieza a partir del 16.º
elemento, hay solo 80 elemen‐
tos BOOL disponibles que pue‐
dan volver a recopilarse en pala‐
bras.

COUNT_OUT

CounterOutput = 3

UDINT3 (deben escribirse 3 pa‐
labras. Esto significa que en el
ARRAY de origen debe haber 48
bits).

OUT

DestinationArrayWord[2]

El operando "DestinationArray‐
Word" es del tipo de datos
ARRAY[0..5] of WORD. Hay 6
elementos WORD disponibles.

Si el operando #Enable devuelve el estado lógico "1" en la entrada de habilitación EN, se
ejecuta la instrucción. A partir del 16.º elemento del operando #SourceArrayBool se recopilan
48 bits en el operando #DestinationArrayWord. En el ARRAY de destino se empieza a partir del
3.er elemento. Esto significa que los primeros 16 bits del ARRAY de origen no se tienen en
cuenta. Los segundos 16 bits se escriben en la 3.ª palabra, los terceros 16 bits en la 4.ª palabra
y los cuartos 16 bits en la 5.ª palabra del ARRAY de destino. Los 64 bits restantes del ARRAY
de origen tampoco se tienen en cuenta. Si ocurre un error durante la ejecución de la
instrucción, el operando #EnableOut devuelve el estado lógico "0" en la salida de habilitación
ENO.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

AssignmentAttempt: Intento de asignación de VARIANT a una referencia
Descripción
La instrucción "AssignmentAttempt" intenta asignar una variable VARIANT a una variable de
referencia. El tipo de datos de una variable de referencia se define en el momento de la
declaración, mientras que el tipo de datos de una variable VARIANT se determina en tiempo
de ejecución. En las variables de referencia no está permitida la conversión implícita del tipo
de datos. Para asignar un tipo de datos al otro se utiliza el intento de asignación.
En el intento de asignación, se comprueba en tiempo de ejecución si la variable VARIANT es
del tipo de datos correcto. Si es así, se ejecuta la asignación. Una vez ejecutada
correctamente, en la variable de destino hay una referencia válida; en caso contrario, hay
CERO.

Programación del PLC
Manual de programación y manejo, 11/2019

1883

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRC

Input

VARIANT

● Interfaz de
bloque de una
FC:
Input, Output,
InOut, Temp

Puntero hacia la
variable origen cu‐
ya dirección se ha
leído

● Interfaz de
bloque de un
FB:
Input, Output,
Temp
DST

Output

Referencia a:
● Secuencias de
bits, excepto
BOOL,
● Enteros,
● Números en
coma flotante,
● Cadenas de
caracteres,

● Interfaz de
bloque de una
FC:
Input, Output,
Temp

Referencia a la
que se transfiere
la dirección de la
variable de origen

● Interfaz de
bloque de un
FB:
Temp

● Tipos de datos
PLC (UDT),
● Tipos de datos
de sistema
(SDT),
● ARRAYs de
los tipos de
datos citados

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Reglas
Para el intento de asignación se aplican las siguientes reglas: Las variables VARIANT que no
satisfacen estas reglas devuelven el valor "NULL" en tiempo de ejecución.
● VARIANT debe señalar a una dirección de un área de memoria optimizada.
● VARIANT no puede señalar a una dirección de un área de memoria temporal.
● Si desea asignar un VARIANT a una referencia a un ARRAY, se aplican las siguientes
reglas:
– La variable VARIANT debe señalar a un ARRAY cuyos límites coincidan exactamente
con los de la referencia declarada. Una variable VARIANT que señala a un ARRAY [0..9]
no concuerda con una variable REF_TO ARRAY[1..10].
– Además, los bloques que forman el valor de la variable VARIANT deben compilarse una
vez en una CPU de la serie S7-1500, con firmware de la versión V2.5.

1884

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
En la interfaz del bloque se han declarado la VARIANT "myVariant" y la variable de referencia
"myReference".

En el código de programa se intenta asignar "myVariant" a la variable de referencia
"myReference". Si en tiempo de ejecución "myVariant" tiene el tipo de datos "Int", en
"myReference" hay una referencia válida a la variable de destino de VARIANT; en caso
contrario, hay CERO. Si la siguiente consulta de si es "NOT_NULL" es verdadera, significa que
la asignación se ha efectuado correctamente y se puede escribir el valor "10" en la variable de
destino.

Consulte también
Principios básicos de las referencias (Página 310)
Intento de asignación de VARIANT a una referencia (Página 325)
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)

SWAP: Cambiar disposición
Descripción
La instrucción "Cambiar disposición" permite cambiar la disposición de los bytes de un valor de
entrada y guardar el resultado en el operando indicado.

Programación del PLC
Manual de programación y manejo, 11/2019

1885

Instrucciones
4.1 Instrucciones
La figura siguiente muestra cómo se intercambian los bytes de un operando del tipo de datos
DWORD utilizando la instrucción "Cambiar disposición":


9DORUGHHQWUDGD

 

 

 

 

 

 


 



 

 

 

 

 

 




 

 

 


 


 



 

 

 






5HVXOWDGR

 



 

 


 



 




 

 

 

 


 


 

 

 





Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros
<Expresión>

Declaración
Input

Valor de función

Tipo de datos

Área de memo‐ Descripción
ria

S7-1200

S7-1500

WORD,
DWORD

WORD,
DWORD,
LWORD

I, Q, M, D, L, P

Valor de entra‐
da

WORD,
DWORD

WORD,
DWORD,
LWORD

I, Q, M, D, L, P

Resultado de la
instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := SWAP("Tag_Value");

El resultado de la instrucción se devuelve como valor de función.

1886

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

0000 1111 0101 0101

Tag_Result

0101 0101 0000 1111

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

DB ARRAY
ReadFromArrayDB: Leer en un bloque de datos ARRAY
Descripción
La instrucción "Leer en un bloque de datos ARRAY" lee el elemento de un bloque de datos del
tipo ARRAY-DB al que hace referencia el índice y escribe el valor en el área de destino.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

DB

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
lee

INDEX

Input

DINT

I, Q, M, D, L, P

Elemento del DB que se lee.
Puede ser una constante,
una variable global o un valor
indexado.

VALUE

Output 1)

VARIANT

L (puede declarar‐ Valor que se lee y se devuel‐
se en las seccio‐
ve
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

INT

I, Q, M, D, L

Valor de función (RET_VAL)

Resultado de la instrucción

1) El parámetro VALUE está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1887

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

80B5

La operación de copia se ha cancelado.

8132

El bloque de datos no existe, es demasiado corto, está protegido contra escritura o está
en la memoria de carga.

8135

El bloque de datos de ARRAY contiene valores no válidos.

8154

El bloque de datos es de un tipo incorrecto.

8282

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8450

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8452

Error de creación de código

8453

Hay dos posibles causas de error:
● El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque
de datos ARRAY.
● Ninguna de las dos variables se encuentra en un área de memoria con acceso
optimizado. Encontrará más información sobre los tipos de acceso al área de memoria
aquí: Fundamentos del acceso a bloques (Página 54)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"TagResult" := ReadFromArrayDB(DB := "ArrayDB",
INDEX := 2,
VALUE => "TargetField");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:

1888

Parámetro

Operando

Valor

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
Array [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

TargetField

El operando "TargetField" es
una variable global del tipo de
datos INT.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El segundo elemento se lee en el "ArrayDB" y se escribe en el operando "TargetField".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Principios básicos de SCL (Página 8115)

WriteToArrayDB: Escribir en un bloque de datos ARRAY
Descripción
La instrucción "Escribir en un bloque de datos ARRAY" escribe el elemento al que hace
referencia el índice en un bloque de datos del tipo ARRAY-DB.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

DB

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
escribe

INDEX

Input

DINT

I, Q, M, D, L, P

Elemento del DB en el que se
escribe. Puede ser una cons‐
tante, una variable global o
un valor indexado.

VALUE

Input

VARIANT

L (puede declarar‐ Valor que se escribe
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

INT

I, Q, M, D, L

Valor de función (RET_VAL)

Resultado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1889

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

80B5

La operación de copia se ha cancelado.

8132

El bloque de datos no existe, es demasiado corto o está en la memoria de carga.

8134

El bloque de datos está protegido contra escritura.

8135

El bloque de datos no es un bloque de datos de ARRAY.

8154

El bloque de datos es de un tipo incorrecto.

8282

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8350

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8352

Error de creación de código

8353

Hay dos posibles causas de error:
● El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque
de datos ARRAY.
● Ninguna de las dos variables se encuentra en un área de memoria con acceso
optimizado. Encontrará más información sobre los tipos de acceso al área de memoria
aquí: Fundamentos del acceso a bloques (Página 54)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"TagResult" := WriteToArrayDB(DB := "ArrayDB",
INDEX := 2,
VALUE := "SourceField");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:

1890

Parámetro

Operando

Valor

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
Array [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

SourceField

El operando "SourceField" es
una variable global del tipo de
datos INT.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El valor del operando "SourceField" se escribe en el segundo elemento del DB de ARRAY.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Principios básicos de SCL (Página 8115)

ReadFromArrayDBL: Leer en un bloque de datos ARRAY de la memoria de carga
Descripción
La instrucción "Leer en un bloque de datos ARRAY de la memoria de carga" lee el elemento
de un bloque de datos del tipo ARRAY-DB de la memoria de carga al que hace referencia el
índice y lo escribe en el área de destino.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".
Si el bloque de datos ARRAY se ha marcado con el atributo de bloque "Depositar sólo en la
memoria de carga", se guarda únicamente en la memoria de carga.
Si en el parámetro REQ se detecta un flanco de señal ascendente, se ejecuta la instrucción.
El parámetro BUSY devuelve el estado lógico "1". Si en el parámetro BUSY se detecta un
flanco de señal descendente, finaliza la instrucción. Durante un ciclo del programa, el
parámetro DONE tiene el estado lógico "1" y durante este ciclo se emite el valor leído en el
parámetro VALUE. En los demás ciclos del programa, el valor del parámetro VALUE no se
modifica.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L

REQ = "1": Comenzar la lec‐
tura del DB de array

DB 1)

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
lee

INDEX

Input

DINT

I, Q, M, D, L, P

Elemento del DB que se lee.
Puede ser una constante,
una variable global o un valor
indexado.

Programación del PLC
Manual de programación y manejo, 11/2019

1891

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

VALUE 1)

InOut

VARIANT

D (elemento de un
bloque de datos
global)

Puntero al bloque de datos
de la memoria de trabajo que
se lee y cuyo valor se escribe.

L (puede declarar‐ No está permitido utilizar
constantes locales o varia‐
se en las seccio‐
bles de la sección TEMP.
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)
BUSY

Output

BOOL

I, Q, M, D, L

BUSY = "1": La lectura del
DB de array todavía no ha fi‐
nalizado

DONE

Output

BOOL

I, Q, M, D, L

DONE = "1": La instrucción
se ha ejecutado correcta‐
mente

ERROR

Output

INT

I, Q, M, D, L

Información de error:
El parámetro ERROR devuel‐
ve un código de error cuando
ocurre un error durante la eje‐
cución de la instrucción.

1)

Los bloques de datos deben crearse con la propiedad de bloque "Optimizado".

Parámetro ERROR
La tabla siguiente muestra el significado de los valores del parámetro ERROR:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8230

El número del bloque de datos es incorrecto.

8231

El bloque de datos no existe.

8232

El bloque de datos es demasiado corto o no está en la memoria de carga.

8235

El bloque de datos no es un DB de ARRAY.

8254

El bloque de datos es de un tipo incorrecto.

8382

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8750

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8751

Error de creación de código

8752

Error de creación de código

8753

El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque de
datos ARRAY.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

1892

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará la descripción de los códigos de error activados por las instrucciones "READ_DBL"
y "WRIT_DBL" en las descripciones de las instrucciones correspondientes.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"ReadFromArrayDBL_DB"(REQ := "TagReg",
DB := "ArrayDB",
INDEX := 2,
VALUE := "TargetField",
BUSY => "TagBusy",
DONE => "TagDone",
ERROR => "TagError");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

REQ

TagReq

BOOL

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
ARRAY [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

TargetField

El operando "TargetField" es
una variable global del tipo de
datos INT.

BUSY

TagBusy

BOOL

DONE

TagDone

BOOL

Si en el operando "TagReq" se detecta un flanco de señal ascendente, se ejecuta la
instrucción. El segundo elemento se lee en el "ArrayDB" y se devuelve en el parámetro
"VALUE". En cuanto se detecta un flanco de señal descendente en el operando "TagBusy",
finaliza la instrucción y el valor del parámetro VALUE ya no se modifica. Después de ejecutar
la instrucción, el operando "TagDone" tiene el estado lógico TRUE.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
READ_DBL: Leer de un bloque de datos de la memoria de carga (Página 2919)
WRIT_DBL: Escribir en un bloque de datos de la memoria de carga (Página 2923)
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1893

Instrucciones
4.1 Instrucciones

WriteToArrayDBL: Escribir en un bloque de datos ARRAY de la memoria de carga
Descripción
La instrucción "Escribir en un bloque de datos ARRAY de la memoria de carga" escribe el
elemento al que hace referencia el índice en un bloque de datos del tipo ARRAY-DB de la
memoria de carga.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".
Si el bloque de datos ARRAY se ha marcado con el atributo de bloque "Depositar sólo en la
memoria de carga", se guarda únicamente en la memoria de carga.
Si en el parámetro REQ se detecta un flanco de señal ascendente, se ejecuta la instrucción.
El parámetro BUSY devuelve el estado lógico "1". Si en el parámetro BUSY se detecta un
flanco de señal descendente, finaliza la instrucción y el valor del parámetro VALUE se escribe
en el bloque de datos. Durante un ciclo del programa, el parámetro DONE tiene el estado
lógico "1".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L

REQ = "1": Comenzar a es‐
cribir en el DB de array

DB 1)

Input

DB_ANY

I, Q, M, D, L

Bloque de datos ARRAY en
el que se escribe

INDEX

Input

DINT

I, Q, M, D, L, P

Elemento del DB en el que se
escribe. Puede ser una cons‐
tante, una variable global o
un valor indexado.

VALUE 1)

Input

VARIANT

D (elemento de un
bloque de datos
global)

Puntero al bloque de datos
de la memoria de trabajo que
se lee y cuyo valor se escribe.

L (puede declarar‐ No está permitido utilizar
constantes locales o varia‐
se en las seccio‐
bles de la sección TEMP.
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

1894

BUSY

Output

BOOL

I, Q, M, D, L

BUSY = "1": Todavía no se
ha terminado de escribir en el
DB de array

DONE

Output

BOOL

I, Q, M, D, L

DONE = "1": La instrucción
se ha ejecutado correcta‐
mente

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ERROR

Output

INT

I, Q, M, D, L

Información de error:
El parámetro ERROR devuel‐
ve un código de error cuando
ocurre un error durante la eje‐
cución de la instrucción.

1)

Los bloques de datos deben crearse con la propiedad de bloque "Optimizado".

Parámetro ERROR
La tabla siguiente muestra el significado de los valores del parámetro ERROR:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8230

El número del bloque de datos es incorrecto.

8231

El bloque de datos no existe.

8232

El bloque de datos es demasiado corto o no está en la memoria de carga.

8234

El bloque de datos está protegido contra escritura.

8235

El bloque de datos no es un DB de ARRAY.

8254

El bloque de datos es de un tipo incorrecto.

8382

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8450

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8751

Error de creación de código

8752

Error de creación de código

8753

El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque de
datos ARRAY.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Encontrará la descripción de los códigos de error activados por las instrucciones "READ_DBL"
y "WRIT_DBL" en las descripciones de las instrucciones correspondientes.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"WriteToArrayDBL_DB"(REQ := "TagReg",
DB := "ArrayDB",
INDEX := 2,
VALUE := "SourceField",
BUSY => "TagBusy",
DONE => "TagDone",

Programación del PLC
Manual de programación y manejo, 11/2019

1895

Instrucciones
4.1 Instrucciones
SCL
ERROR => "TagError");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

REQ

TagReq

BOOL

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
ARRAY [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

SourceField

El operando "SourceField" es
una variable global del tipo de
datos INT.

BUSY

TagBusy

BOOL

DONE

TagDone

BOOL

Si en el operando "TagReq" se detecta un flanco de señal ascendente, se ejecuta la
instrucción. En cuanto se detecta un flanco descendente en el operando "TagBusy", la
instrucción finaliza y el valor del parámetro VALUE se escribe en el segundo elemento del
"ArrayDB". Después de ejecutar la instrucción, el operando "TagDone" tiene el estado lógico
TRUE.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
READ_DBL: Leer de un bloque de datos de la memoria de carga (Página 2919)
WRIT_DBL: Escribir en un bloque de datos de la memoria de carga (Página 2923)
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)
Principios básicos de SCL (Página 8115)

Acceso de lectura/escritura
PEEK: Leer dirección de memoria
Descripción
La instrucción "Leer dirección de memoria" permite leer una dirección de memoria de un área
de memoria estándar sin indicar un tipo de datos.
Para modificar el tipo de datos de la instrucción, utilice la sintaxis siguiente:
PEEK_<tipo de datos>();

1896

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Uso del área de memoria 16#84: DB
Si como área de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
código del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso:
SCL
#Peeker := PEEK(AREA := 16#84,
DBNUMBER := 1,
BYTEOFFSET := 2,
ENO => ENO);
IF NOT ENO THEN;
#Peeker := 16#ffff;
END_IF;

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declara‐
ción

Tipo de datos Área de memo‐
ria

Descripción

AREA

Input

BYTE

Pueden seleccionarse las siguientes
áreas:

I, Q, M, D

● 16#81: Input
● 16#82: Output
● 16#83: Marcas
● 16#84: DB
● 16#1: Entrada de periferia (solo
S7-1500)
DBNUM‐
BER

Input

DINT,
DB_ANY

D

BYTEOFF‐
SET

Input

DINT

I, Q, M, D

_<tipo de datos>

Número del bloque de datos si AREA =
DB, de lo contrario "0"
Dirección en la que se lee
Solo se utilizan los 16 bits menos signi‐
ficativos.

Secuencias
de bits
Valor prede‐
terminado:
BYTE

-

Tipo de datos del valor de función:
1. El tipo de datos de la instrucción se
puede indicar explícitamente con "_".
2. Si el tipo de datos no se indica
explícitamente, se determinará a
partir de las variables utilizadas o de
las constantes con tipos.
3. Si el tipo de datos no se indica
explícitamente ni se indican
variables definidas ni constantes con
tipo, se utilizará el tipo de datos
predeterminado.

Valor de función

Programación del PLC
Manual de programación y manejo, 11/2019

Secuencias
de bits

I, Q, M, D

Resultado de la instrucción

1897

Instrucciones
4.1 Instrucciones

Nota
Si se lee la dirección de memoria en las áreas Input, Output o Marcas, se debe suministrar el
valor "0" al parámetro DBNUMBER, ya que de lo contrario la instrucción será errónea.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result1" := PEEK(AREA := "Tag_Area",
DBNUMBER := "Tag_DBNumber",
BYTEOFFSET := "Tag_Byte");

SCL
"Tag_Result2" := PEEK_WORD(AREA := "Tag_Area",
DBNUMBER := "Tag_DBNumber",
BYTEOFFSET := "Tag_Byte");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

AREA

Tag_Area

16#84

DBNUMBER

Tag_DBNumber

5

BYTEOFFSET

Tag_Byte

20

Valor de función

Tag_Result1

Valor del byte "20"

Valor de función

Tag_Result2

Valor de la palabra "20"

La instrucción lee el valor de la dirección "20" del operando "Tag_Byte" del bloque de datos "5"
y devuelve el resultado como valor de la función en el operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

PEEK_BOOL: Leer bit de memoria
Descripción
La instrucción "Leer bit de memoria" permite leer un bit de memoria de un área de memoria
estándar sin indicar un tipo de datos.

1898

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Uso del área de memoria 16#84: DB
Si como área de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
código del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso:
SCL
#Peeker_BOOL := PEEK_BOOL(AREA := 16#84,
DBNUMBER := 1,
BYTEOFFSET := 2,
BITOFFSET := 1,
ENO => ENO);
IF NOT ENO THEN;
#Peeker_BOOL := 0;
END_IF;

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declara‐
ción

Tipo de datos

Área de memo‐
ria

Descripción

AREA

Input

BYTE

I, Q, M, D

Pueden seleccionarse las siguientes
áreas:
● 16#81: Input
● 16#82: Output
● 16#83: Marcas
● 16#84: DB
● 16#1: Entrada de periferia (solo
S7-1500)

DBNUM‐
BER

Input

DINT,
DB_ANY

D

Número del bloque de datos si AREA
= DB, de lo contrario "0"

BYTEOFF‐
SET

Input

DINT

I, Q, M, D

Dirección en la que se lee
Solo se utilizan los 16 bits menos sig‐
nificativos.

BITOFFSET Input

INT

I, Q, M, D

Bit en el que se lee

Valor de función

BOOL

I, Q, M, D

Resultado de la instrucción

Nota
Si se lee el bit de memoria en las áreas Input, Output o Marcas, se debe suministrar el valor "0"
al parámetro DBNUMBER, ya que de lo contrario la instrucción será errónea.

Programación del PLC
Manual de programación y manejo, 11/2019

1899

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := PEEK_BOOL(AREA := "Tag_Area",
DBNUMBER := "Tag_DBNumber",
BYTEOFFSET := "Tag_Byte",
BITOFFSET := "Tag_Bit");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

AREA

Tag_Area

16#84

DBNUMBER

Tag_DBNumber

5

BYTEOFFSET

Tag_Byte

20

BITOFFSET

Tag_Bit

3

Valor de función

Tag_Result

3

La instrucción lee el valor del bit de memoria "3" del operando "Tag_Bit" del bloque de datos
"5" del byte "20" y devuelve el resultado como valor de función en el operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

POKE: Escribir dirección de memoria
Descripción
La instrucción "Escribir dirección de memoria" permite escribir una dirección de memoria en un
área de memoria estándar sin indicar un tipo de datos.

Uso del área de memoria 16#84: DB
Si como área de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
código del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso:
SCL
POKE(AREA := 16#84,
DBNUMBER := 1,
BYTEOFFSET := 2,
VALUE := BYTE#7,
ENO => ENO);

1900

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros Declaración

Tipo de datos Área de memo‐
ria

Descripción

AREA

BYTE

Pueden seleccionarse las siguientes
áreas:

Input

I, Q, M, D

● 16#81: Input
● 16#82: Output
● 16#83: Marcas
● 16#84: DB
● 16#2: Salida de periferia (solo
S7-1500)
DBNUM‐
BER

Input

DINT,
DB_ANY

D

BYTEOFF‐
SET

Input

DINT

I, Q, M, D

VALUE

Input

Número del bloque de datos si AREA =
DB, de lo contrario "0"
Dirección que se escribe
Solo se utilizan los 16 bits menos signi‐
ficativos.

Secuencias
de bits

I, Q, M, D

Valor que se escribe

Nota
Si se escribe la dirección de memoria en las áreas Input, Output o Marcas, se debe suministrar
el valor "0" al parámetro DBNUMBER, ya que de lo contrario la instrucción será errónea.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
POKE(AREA := "Tag_Area",
DBNUMBER := "Tag_DBNumber",
BYTEOFFSET := "Tag_Byte",
VALUE := "Tag_Value");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operando
concretos:
Parámetro

Operando

Valor

AREA

Tag_Area

16#84

DBNUMBER

Tag_DBNumber

5

BYTEOFFSET

Tag_Byte

20

VALUE

Tag_Value

16#11

La instrucción sobrescribe la dirección de memoria "20" en el bloque de datos "5" con el valor
"16#11".

Programación del PLC
Manual de programación y manejo, 11/2019

1901

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

POKE_BOOL: Escribir bit de memoria
Descripción
La instrucción "Escribir bit de memoria" permite escribir un bit de memoria en un área de
memoria estándar sin indicar un tipo de datos.

Uso del área de memoria 16#84: DB
Si como área de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
código del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso:
SCL
POKE(AREA := 16#84,
DBNUMBER := 1,
BYTEOFFSET := 2,
BITOFFSET := 4,
VALUE := TRUE,
ENO => ENO);

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declara‐
ción

Tipo de da‐
tos

Área de memo‐ Descripción
ria

AREA

Input

BYTE

I, Q, M, D

Pueden seleccionarse las siguientes
áreas:
● 16#81: Input
● 16#82: Output
● 16#83: Marcas
● 16#84: DB
● 16#2: Salida de periferia (solo
S7-1500)

1902

DBNUM‐
BER

Input

DINT,
DB_ANY

D

BYTEOFF‐
SET

Input

DINT

I, Q, M, D

Número del bloque de datos si AREA =
DB, de lo contrario "0"
Dirección que se escribe
Solo se utilizan los 16 bits menos signifi‐
cativos.

BITOFFSET Input

INT

I, Q, M, D

Bit que se escribe

VALUE

BOOL

I, Q, M, D

Valor que se escribe

Input

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Nota
Si se escribe el bit de memoria en las áreas Input, Output o Marcas, se debe suministrar el valor
"0" al parámetro DBNUMBER, ya que de lo contrario la instrucción será errónea.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
POKE_BOOL(AREA := "Tag_Area",
DBNUMBER := "Tag_DBNumber",
BYTEOFFSET := "Tag_Byte",
BITOFFSET := "Tag_Bit",
VALUE := "Tag_Value");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

AREA

Tag_Area

16#84

DBNUMBER

Tag_DBNumber

5

BYTEOFFSET

Tag_Byte

20

BITOFFSET

Tag_Bit

3

VALUE

Tag_Value

M0.0

La instrucción sobrescribe el bit de memoria "3" en el bloque de datos "5" en el byte "20" con
el valor "M0.0".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

POKE_BLK: Escribir área de memoria
Descripción
La instrucción "Escribir área de memoria" permite escribir un área de memoria en un área de
memoria estándar diferente sin indicar un tipo de datos.

Programación del PLC
Manual de programación y manejo, 11/2019

1903

Instrucciones
4.1 Instrucciones

Uso del área de memoria 16#84: DB
Si como área de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
código del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso:
SCL
POKE_BLK(AREA_SRC := 16#84,
DBNUMBER_SRC := 1,
BYTEOFFSET_SRC := 2,
AREA_DEST := 16#84,
DBNUMBER_DEST := 11,
BYTEOFFSET_DEST := 22,
COUNT := 3,
ENO => ENO);

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declara‐
ción

Tipo de da‐
tos

Área de memo‐ Descripción
ria

AREA_SRC

Input

BYTE

I, Q, M, D

Las siguientes áreas pueden se‐
leccionarse en el área de memoria
de origen:
● 16#81: Input
● 16#82: Output
● 16#83: Marcas
● 16#84: DB

DBNUMBER_SRC

Input

DINT,
DB_ANY 1)

D

Número del bloque de datos en el
área de memoria de origen, si
AREA = DB, de lo contrario "0"

BYTEOFF‐
SET_SRC

Input

DINT

I, Q, M, D

Dirección en el área de memoria
de origen, en la que se escribe
Solo se utilizan los 16 bits menos
significativos.

AREA_DEST

Input

BYTE

I, Q, M, D

Las siguientes áreas pueden se‐
leccionarse en el área de memoria
de destino:
● 16#81: Input
● 16#82: Output
● 16#83: Marcas
● 16#84: DB

DBNUM‐
BER_DEST

1904

Input

DINT,
DB_ANY 1)

D

Número del bloque de datos en el
área de memoria de destino, si
AREA = DB, de lo contrario "0"

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetros

Declara‐
ción

Tipo de da‐
tos

Área de memo‐ Descripción
ria

BYTEOFF‐
SET_DEST

Input

DINT

I, Q, M, D

Dirección en el área de memoria
de destino, en la que se escribe
Solo se utilizan los 16 bits menos
significativos.

COUNT

Input

DINT

I, Q, M, D

Número de bytes que se copian

Los tipos de datos de los parámetros DBNUMBER_SRC y DBNUMBER_DEST deben ser idénticos.
Es decir, las dos variables deben ser bien del tipo de datos DINT bien del tipo de datos DB_ANY.

1)

Nota
Si se escribe la dirección de memoria en las áreas Input, Output o Marcas, se debe suministrar
el valor "0" al parámetro DBNUMBER, ya que de lo contrario la instrucción será errónea.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
POKE_BLK(AREA_SRC := "Tag_Source_Area",
DBNUMBER_SRC := "Tag_Source_DBNumber",
BYTEOFFSET_SRC := "Tag_Source_Byte"),
AREA_DEST := "Tag_Destination_Area",
DBNUMBER_DEST := "Tag_Destination_DBNumber",
BYTEOFFSET_DEST := "Tag_Destination_Byte",
COUNT := "Tag_Count");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

AREA_SRC

Tag_Source_Area

16#84

DBNUMBER_SRC

Tag_Source_DBNumber

5

BYTEOFFSET_SRC

Tag_Source_Byte

20

AREA_DEST

Tag_Destination_Area

16#83

DBNUMBER_DEST

Tag_Destination_DBNumber

0

BYTEOFFSET_DEST

Tag_Destination_Byte

30

COUNT

Tag_Count

100

La instrucción escribe 100 bytes del bloque de datos "5" comenzando por la dirección "20" en
el área de memoria Marcas comenzado por la dirección "30".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1905

Instrucciones
4.1 Instrucciones

READ_LITTLE: Leer datos en formato Little-Endian
Descripción
La instrucción "Leer datos en formato Little-Endian" permite leer datos de un área de memoria
y escribirlos en una única variable en el orden de bytes Little-Endian. En el formato LittleEndian, primero se guarda el byte con los bits menos significativos, es decir, en la dirección de
memoria más baja.
Los parámetros SRC_ARRAY y DEST_VARIABLE son del tipo de datos VARIANT. No
obstante, hay algunas restricciones en cuanto al tipo de datos con el que pueden
interconectarse los parámetros. El VARIANT del parámetro DEST_VARIABLE debe apuntar a
un tipo de datos simple. El VARIANT del parámetro SRC_ARRAY apunta a un área de
memoria que se lee, y debe ser un ARRAY of BYTE.
En los parámetros SRC_ARRAY y DEST_VARIABLE también es posible utilizar un parámetro
actual con un índice de ARRAY variable.
El operando del parámetro POS determina la posición del área de memoria en la que se inicia
la lectura.
Nota
Leer variable del tipo de datos VARIANT o BOOL
Para leer una variable a la que apunta un VARIANT se pueden utilizar las instrucciones
"Serializar" o "Deserializar".
Para leer una variable del tipo de datos BOOL se puede utilizar un "acceso slice".

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200 a
S7-1500
partir de V4.0

1906

Área de me‐ Descripción
moria

SRC_ARRA
Y

Input

ARRAY of
BYTE

ARRAY of
BYTE

I, Q, M, D, L

Área de memoria de la
que se lee

DEST_VA‐
RIABLE

Output

Secuencias
de bits, ente‐
ros, números
en coma flo‐
tante, TOD,
DATE,
CHAR,
WCHAR

Secuencias
de bits, ente‐
ros, números
en coma flo‐
tante, LDT,
TOD, LTOD,
DATE,
CHAR,
WCHAR

I, Q, M, D, L

Valor leído

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos
S7-1200 a
S7-1500
partir de V4.0

POS

InOut

Valor de función (RET_VAL)

Área de me‐ Descripción
moria

DINT

DINT

I, Q, M, D, L

Determina la posición
en la que se inicia la lec‐
tura. El parámetro POS
se calcula basado en ce‐
ro.

INT

INT

I, Q, M, D, L

Información de error

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B4

El tipo de datos del parámetro SRC_ARRAY no es un ARRAY of BYTE.

8382

El valor del parámetro POS se encuentra fuera de los valores límite del ARRAY.

8383

El valor del parámetro POS se encuentra dentro de los valores límite del ARRAY, pero el
tamaño del área de memoria excede el límite superior del ARRAY.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
#TagResult := READ_LITTLE(SRC_ARRAY := #SourceField,
DEST_VARIABLE => #DINTVariable,
POS := #TagPos);

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

SRC_ARRAY

#SourceField

ARRAY[0..3] of BYTE
:= 16#1A, 16#2B, 16#3C, 16#4D

DEST_VARIABLE

#DINTVariable

1295788826
16#4D3C2B1A

POS

#TagPos

0 => 4

La instrucción lee el entero 1_295_788_826 del área de memoria "#SourceField" y lo escribe
en formato Little-Endian en el operando #DINTVariable. El tipo de datos del parámetro
DEST_VARIABLE indica cuántos bytes se leen. En el operando #TagPos se guarda el número
4.

Programación del PLC
Manual de programación y manejo, 11/2019

1907

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Deserialize: Deserializar (Página 1844)
Serialize: Serializar (Página 1849)
Direccionar áreas de una variable con accesos Slice (Página 116)
Principios básicos de SCL (Página 8115)

WRITE_LITTLE: Escribir datos en formato Little-Endian
Descripción
La instrucción "Escribir datos en formato Little-Endian" permite escribir los datos de una única
variable de la orden de bytes Little-Endian en un área de memoria. En el formato Little-Endian,
primero se guarda el byte con los bits menos significativos, es decir, en la dirección de memoria
más baja.
Los parámetros SRC_VARIABLE y DEST_ARRAY son del tipo de datos VARIANT. No
obstante, hay algunas restricciones en cuanto al tipo de datos con el que pueden
interconectarse los parámetros. El VARIANT del parámetro SRC_VARIABLE debe apuntar a
un tipo de datos simple. El VARIANT del parámetro DEST_ARRAY apunta a un área de
memoria en la que se escriben los datos, y debe ser un ARRAY of BYTE.
En los parámetros SRC_ARRAY y DEST_VARIABLE también es posible utilizar un parámetro
actual con un índice de ARRAY variable.
El operando del parámetro POS determina la posición del área de memoria en la que se inicia
la escritura.
Nota
Escribir variable del tipo de datos VARIANT o BOOL
Para escribir una variable a la que apunta un VARIANT se pueden utilizar las instrucciones
"Serializar" o "Deserializar".
Para escribir una variable del tipo de datos BOOL se puede utilizar un "acceso slice".

1908

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de me‐ Descripción
moria

S7-1200 a
partir de
V4.0

S7-1500

SRC_VARIA‐ Input
BLE

Secuencias
de bits, ente‐
ros, núme‐
ros en coma
flotante,
TOD, DATE,
CHAR,
WCHAR

Secuencias de
bits, enteros,
números en
coma flotante,
LDT, TOD,
LTOD, DATE,
CHAR,
WCHAR

I, Q, M, D, L Variable cuyos datos se
escriben

DEST_ARRA InOut
Y

ARRAY of
BYTE

ARRAY of
BYTE

I, Q, M, D, L Área de memoria en la
que se escriben los da‐
tos

POS

DINT

DINT

I, Q, M, D, L Determina la posición
en la que se inicia la es‐
critura. El parámetro
POS se calcula basado
en cero.

INT

INT

I, Q, M, D, L Información de error

InOut

Valor de función (RET_VAL)

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B4

El tipo de datos del parámetro SRC_ARRAY no es un ARRAY of BYTE.

8382

El valor del parámetro POS se encuentra fuera de los valores límite del ARRAY.

8383

El valor del parámetro POS se encuentra dentro de los valores límite del ARRAY, pero el
tamaño del área de memoria excede el límite superior del ARRAY.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
#TagResult := WRITE_LITTLE(SRC_VARIABLE := #DINTVariable,
DEST_ARRAY := #TargetField,
POS := #TagPos);

Programación del PLC
Manual de programación y manejo, 11/2019

1909

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

SRC_VARIABLE

#DINTVariable

1295788826

DEST_ARRAY

#TargetField

ARRAY[0..10] of BYTE

POS

#TagPos

0 => 4

16#4D3C2B1A
= 16#1A, 16#2B, 16#3C, 16#4D

La instrucción escribe el entero 1_295_788_826 del operando #DINTVariable en formato Little
Endian en el área de memoria #TargetField. El tipo de datos del parámetro SRC_VARIABLE
indica cuántos bytes se escriben. En el operando #TagPos se guarda el número 4.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Deserialize: Deserializar (Página 1844)
Serialize: Serializar (Página 1849)
Direccionar áreas de una variable con accesos Slice (Página 116)
Principios básicos de SCL (Página 8115)

READ_BIG: Leer datos en formato Big-Endian
Descripción
La instrucción "Leer datos en formato Big-Endian" permite leer datos de un área de memoria
y escribirlos en una única variable en el orden de bytes Big-Endian. En el formato Big-Endian,
primero se guarda el byte con los bits más significativos, es decir, en la dirección de memoria
más baja.
Los parámetros SRC_ARRAY y DEST_VARIABLE son del tipo de datos VARIANT. No
obstante, hay algunas restricciones en cuanto al tipo de datos con el que pueden
interconectarse los parámetros. El VARIANT del parámetro DEST_VARIABLE debe apuntar a
un tipo de datos simple. El VARIANT del parámetro SRC_ARRAY apunta a un área de
memoria que se lee, y debe ser un ARRAY of BYTE.
En los parámetros SRC_ARRAY y DEST_VARIABLE también es posible utilizar un parámetro
actual con un índice de ARRAY variable.

1910

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El operando del parámetro POS determina la posición del área de memoria en la que se inicia
la lectura.
Nota
Leer variable del tipo de datos VARIANT o BOOL
Para leer una variable a la que apunta un VARIANT se pueden utilizar las instrucciones
"Serializar" o "Deserializar".
Para leer una variable del tipo de datos BOOL se puede utilizar un "acceso slice".

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

S7-1200 a
partir de V4.0

Tipo de datos
S7-1500

Área de
memoria

Descripción

SRC_ARRA
Y

Input

ARRAY of
BYTE

ARRAY of
BYTE

I, Q, M, D, L Área de memoria de la
que se lee

DEST_VA‐
RIABLE

Output

Secuencias
de bits, ente‐
ros, números
en coma flo‐
tante, TOD,
DATE,
CHAR,
WCHAR

Secuencias
de bits, ente‐
ros, números
en coma flo‐
tante, LDT,
TOD, LTOD,
DATE,
CHAR,
WCHAR

I, Q, M, D, L Valor leído

POS

InOut

DINT

DINT

I, Q, M, D, L Determina la posición en
la que se inicia la lectura.
El parámetro POS se cal‐
cula basado en cero.

INT

INT

I, Q, M, D, L Información de error

Valor de función (RET_VAL)

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B4

El tipo de datos del parámetro SRC_ARRAY no es un ARRAY of BYTE.

8382

El valor del parámetro POS se encuentra fuera de los valores límite del ARRAY.

8383

El valor del parámetro POS se encuentra dentro de los valores límite del ARRAY, pero el
tamaño del área de memoria excede el límite superior del ARRAY.

Programación del PLC
Manual de programación y manejo, 11/2019

1911

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
#TagResult := READ_BIG(SRC_ARRAY := #SourceField,
DEST_VARIABLE => #DINTVariable,
POS := #TagPos);

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

SRC_ARRAY

#SourceField

ARRAY[0..10] of BYTE
:= 16#1A, 16#2B, 16#3C, 16#4D

DEST_VARIABLE

#DINTVariable

439041101
16#1A2B3C4D

POS

#TagPos

0 => 4

La instrucción lee el entero 439_041_101 del área de memoria "#SourceField" y lo escribe en
formato Big-Endian en el operando #DINTVariable. El tipo de datos del parámetro
DEST_VARIABLE indica cuántos bytes se leen. En el operando #TagPos se guarda el número
4.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Deserialize: Deserializar (Página 1844)
Serialize: Serializar (Página 1849)
Direccionar áreas de una variable con accesos Slice (Página 116)
Principios básicos de SCL (Página 8115)

WRITE_BIG: Escribir datos en formato Big-Endian
Descripción
La instrucción "Escribir datos en formato Big-Endian" permite escribir los datos de una única
variable de la orden de bytes Big-Endian en un área de memoria. En el formato Big-Endian,
primero se guarda el byte con los bits más significativos, es decir, en la dirección de memoria
más baja.
Los parámetros SRC_VARIABLE y DEST_ARRAY son del tipo de datos VARIANT. No
obstante, hay algunas restricciones en cuanto al tipo de datos con el que pueden
interconectarse los parámetros. El VARIANT del parámetro SRC_VARIABLE debe apuntar a
un tipo de datos simple. El VARIANT del parámetro DEST_ARRAY apunta a un área de
memoria en la que se escriben los datos, y debe ser un ARRAY of BYTE.
En los parámetros SRC_ARRAY y DEST_VARIABLE también es posible utilizar un parámetro
actual con un índice de ARRAY variable.

1912

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El operando del parámetro POS determina la posición del área de memoria en la que se inicia
la escritura.
Nota
Escribir variable del tipo de datos VARIANT o BOOL
Para escribir una variable a la que apunta un VARIANT se pueden utilizar las instrucciones
"Serializar" o "Deserializar".
Para escribir una variable del tipo de datos BOOL se puede utilizar un "acceso slice".

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200 a
S7-1500
partir de V4.0

Área de me‐ Descripción
moria

SRC_VARIA‐ Input
BLE

Secuencias
de bits, ente‐
ros, números
en coma flo‐
tante, TOD,
DATE,
CHAR,
WCHAR

Secuencias
de bits, ente‐
ros, números
en coma flo‐
tante, LDT,
TOD, LTOD,
DATE,
CHAR,
WCHAR

I, Q, M, D, L Variable cuyos datos se
escriben

DEST_ARRA InOut
Y

ARRAY of
BYTE

ARRAY of
BYTE

I, Q, M, D, L Área de memoria en la
que se escriben los datos

POS

DINT

DINT

I, Q, M, D, L Determina la posición en
la que se inicia la escri‐
tura. El parámetro POS
se calcula basado en ce‐
ro.

INT

INT

I, Q, M, D, L Información de error

InOut

Valor de función (RET_VAL)

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B4

El tipo de datos del parámetro SRC_ARRAY no es un ARRAY of BYTE.

8382

El valor del parámetro POS se encuentra fuera de los valores límite del ARRAY.

8383

El valor del parámetro POS se encuentra dentro de los valores límite del ARRAY, pero el
tamaño del área de memoria excede el límite superior del ARRAY.

Programación del PLC
Manual de programación y manejo, 11/2019

1913

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
#TagResult := WRITE_BIG(SRC_VARIABLE := #DINTVariable,
DEST_ARRAY := #TargetField,
POS := #TagPos);

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

SRC_VARIABLE

#DINTVariable

439041101
16#1A2B3C4D

DEST_ARRAY

#TargetField

ARRAY[0..10] of BYTE
= 16#1A, 16#2B, 16#3C, 16#4D

POS

#TagPos

0 => 4

La instrucción escribe el entero 439_041_101 del operando #DINTVariable en formato Little
Endian en el área de memoria #TargetField. El tipo de datos del parámetro SRC_VARIABLE
indica cuántos bytes se escriben. En el operando #TagPos se guarda el número 4.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Deserialize: Deserializar (Página 1844)
Serialize: Serializar (Página 1849)
Direccionar áreas de una variable con accesos Slice (Página 116)
Principios básicos de SCL (Página 8115)

VARIANT
VariantGet: Leer valor de una variable VARIANT
Descripción
Con la instrucción "Leer valor de una variable VARIANT" se lee el valor de la variable a la que
apunta VARIANT en el parámetro SRC y se escribe este valor en la variable del parámetro
DST.
El parámetro SRC es del tipo de datos VARIANT. En el parámetro DST se puede indicar
cualquier tipo de datos excepto VARIANT.

1914

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El tipo de datos de la variable indicada en el parámetro DST debe coincidir con el tipo de datos
al que apunta VARIANT.
Nota
Para copiar estructuras y ARRAY también se puede utilizar la instrucción
"MOVE_BLK_VARIANT: Copiar área". Encontrará más información al respecto en "Consulte
también".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

SRC

Input

VARIANT

DST

Output

I, Q, M, D, L
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, tiempos, fe‐
cha y hora, se‐
cuencias de carac‐
teres, elementos
de ARRAY, tipos
de datos PLC

Descripción

S7-1500

L (puede declararse en las
secciones "Input", "InOut" y
"Temp" de la interfaz del blo‐
que.)
I, Q, M, D, L,
P

Variable que se
lee

Resultado de la
instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
VariantGet(SRC := #TagIn_Source,
DST => "TagOut_Dest");

El valor de la variable a la que señala VARIANT en el operando "#TagIn_Source" se lee y se
escribe en el operando "TagOut_Dest".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
MOVE_BLK_VARIANT: Copiar área (Página 1856)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1915

Instrucciones
4.1 Instrucciones

VariantPut: Escribir valor en una variable VARIANT
Descripción
La instrucción "Escribir valor en una variable VARIANT" escribe el valor de la variable indicada
en el parámetro SRC en la memoria del parámetro DST al que apunta VARIANT.
El parámetro DST es del tipo de datos VARIANT. En el parámetro SRC se puede indicar
cualquier tipo de datos excepto VARIANT.
El tipo de datos de la variable del parámetro SRC debe coincidir con el tipo de datos al que
apunta VARIANT.
Nota
Para copiar estructuras y ARRAY también se puede utilizar la instrucción
"MOVE_BLK_VARIANT: Copiar área". Encontrará más información al respecto en "Consulte
también".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

Descripción

S7-1500

SRC

Input

Secuencias de
I, Q, M, D, L
bits, enteros, nú‐
meros en coma flo‐
tante, tiempos, fe‐
cha y hora, se‐
cuencias de carac‐
teres, elementos
de ARRAY, tipos
de datos PLC

DST

Input

VARIANT

I, Q, M, D, L,
P

Variable que se
lee

L (puede declararse en las
secciones "Input", "InOut" y
"Temp" de la interfaz del blo‐
que.)

Resultado de la
instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
VariantPut(SRC := "TagIn_Source",
DST := #TagIn_Dest);

El valor del operando "TagIn_Source" se escribe en la variable a la que apunta VARIANT en
el operando #TagIn_Dest.

1916

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
MOVE_BLK_VARIANT: Copiar área (Página 1856)
Principios básicos de SCL (Página 8115)

CountOfElements: Consultar número de elementos de ARRAY
Descripción
La instrucción "Consultar número de elementos de ARRAY" permite saber el número de
elementos de ARRAY que tiene una variable a la que apunta VARIANT.
Si el ARRAY es unidimensional, el resultado se devuelve como número de elementos ARRAY.
(La diferencia entre el límite superior e inferior + 1). Si el ARRAY es multidimensional, el
resultado se devuelve como cantidad de todas las dimensiones.
Si desea consultar los elementos de un DB de ARRAY deberá utilizar las instrucciones
"ReadFromArrayDB" o "WriteFromArrayDB", puesto que estas permiten una evaluación de
errores más precisa para el número de elementos.
Nota
Instancias
El puntero VARIANT no puede señalar a ninguna instancia y, por lo tanto, tampoco a ninguna
multiinstancia o ARRAY of multiinstancias.
Nota
ARRAY en un bloque de datos
Si desea consultar el número de elementos de un ARRAY que se encuentra en un bloque de
datos, en este no debe estar activado el atributo de bloque "Bloque de datos protegido contra
escritura en el dispositivo". De lo contrario, el parámetro RET_VAL devuelve el resultado "0",
independientemente de cuántos elementos contenga el ARRAY.
El resultado también es "0" si la variable VARIANT no es ARRAY.
Si VARIANT apunta a un ARRAY of BOOL, se cuentan también los elementos de relleno. (P.
ej. con un ARRAY[0..1] of BOOL se devuelve 8.)

Programación del PLC
Manual de programación y manejo, 11/2019

1917

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

<Operando>

Input

VARIANT

L (puede declarar‐ Variable que se consulta
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

UDINT

I, Q, M, D, L

Valor de función

Descripción

Resultado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
IF IS_ARRAY(#Tag_VARIANTToArray) THEN
"Tag_Result" := CountOfElements(#Tag_VARIANTToArray);
END_IF;

Si la variable a la que señala VARIANT es ARRAY, se devuelve el número de elementos
ARRAY.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

ARRAY[*]
LOWER_BOUND: Leer límite inferior del ARRAY
Descripción
En la interfaz de un bloque de función o de una función se pueden declarar variables del tipo
de datos ARRAY[*]. Para estas variables locales pueden leerse los límites del ARRAY. En el
parámetro DIM debe indicarse la dimensión deseada.

1918

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para leer el límite inferior variable del ARRAY está disponible la instrucción "Leer límite inferior
del ARRAY".
Nota
Disponibilidad de la instrucción
La instrucción está disponible en las CPU de la serie S7-1200 a partir de la versión de firmware
>= 4.2 y en las CPU de la serie S7-1500 a partir de la versión de firmware >= 2.0.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ARR

Input

ARRAY[*]

FB => sección
InOut

ARRAY cuyo límite inferior
variable debe leerse.

FC => sección In‐
put y InOut
DIM

Input

Valor de función

UDINT

I, Q, M, D, L, P o
constante

Dimensión del ARRAY cuyo
límite inferior variable debe
leerse.

DINT

I, Q, M, D, L, P

Resultado

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Result" := LOWER_BOUND(ARR := #ARRAY_A,
DIM := 2);

La instrucción lee el límite inferior variable del ARRAY #ARRAY_A de la segunda dimensión.
Si no se producen errores al ejecutar la instrucción, el resultado se escribe en el operando
"Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del ARRAY (Página 293)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1919

Instrucciones
4.1 Instrucciones

UPPER_BOUND: Leer límite superior de ARRAY
Descripción
En la interfaz de un bloque de función o de una función se pueden declarar variables del tipo
de datos ARRAY[*]. Para estas variables locales pueden leerse los límites del ARRAY. En el
parámetro DIM debe indicarse la dimensión deseada.
Para leer el límite superior variable del ARRAY está disponible la instrucción "Leer límite
superior de ARRAY".
Nota
Disponibilidad de la instrucción
La instrucción está disponible en las CPU de la serie S7-1200 a partir de la versión de firmware
>= 4.2 y en las CPU de la serie S7-1500 a partir de la versión de firmware >= 2.0.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ARR

Input

ARRAY[*]

FB => sección
InOut

ARRAY cuyo límite superior
variable debe leerse.

FC => sección In‐
put y InOut
DIM

Input

Valor de función

UDINT

I, Q, M, D, L, P o
constante

Dimensión del ARRAY cuyo
límite superior variable debe
leerse.

DINT

I, Q, M, D, L, P

Resultado

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Result" := UPPER_BOUND(ARR := #ARRAY_A,
DIM := 2);

La instrucción lee el límite superior variable del ARRAY #ARRAY_A de la segunda dimensión.
Si no se producen errores al ejecutar la instrucción, el resultado se escribe en el operando
"Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del ARRAY (Página 293)
Principios básicos de SCL (Página 8115)

1920

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Legacy
BLKMOV: Copiar área
Descripción
La instrucción "Copiar área" permite copiar los contenidos de un área de memoria (área de
origen) en un área de memoria diferente (área de destino). La operación de copia se realiza por
orden ascendente de direcciones. Las áreas de origen y destino se definen mediante
VARIANT.
Nota
Las variables de la instrucción sólo se pueden usar en áreas de memoria en las que no esté
activado el atributo "Acceso optimizado al bloque". Esto es válido para bloques de datos (DB),
bloques de organización (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucción se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable también se puede usar en áreas de memoria "con acceso
optimizado al bloque".
La figura siguiente muestra el principio de la operación de copia:

'%'%:

$

%

'%'%:

&

'

'%'%:

(

)

'%'%:

*

+

0:

$

%

0:

&

'

0:

(

)

0:

*

+

&RSLD
/DRSHUDFLµQGHFRSLDVH
UHDOL]DSRURUGHQ
DVFHQGHQWHGH
GLUHFFLRQHV

UHDGHPHPRULD

Coherencia de los datos de origen y destino
Tenga en cuenta que durante la ejecución de la instrucción "Copiar área" no se modifican los
datos de origen pues, de lo contrario, no se podría garantizar la coherencia de los datos de
destino.

Programación del PLC
Manual de programación y manejo, 11/2019

1921

Instrucciones
4.1 Instrucciones

Posibilidad de interrupción
No hay limitaciones en cuanto a la profundidad de anidamiento.

Áreas de memoria
La instrucción "Copiar área" permite copiar las siguientes áreas de memoria:
● Áreas de un bloque de datos
● Marcas
● Memoria imagen de proceso de las entradas
● Memoria imagen de proceso de las salidas

Reglas generales para copiar
Las áreas de origen y destino no deben solaparse. Si las áreas de origen y destino son de
diferente longitud, se copia solo hasta la longitud del área más pequeña.
Si el área de origen es más pequeña que el área de destino, el área de origen se copiará por
completo en el área de destino. Los restantes bytes del área de destino permanecen
inalterados.
Si el área de destino es más pequeña que el área de origen, se escribirá en toda el área de
destino. Los restantes bytes del área de origen se ignoran.
Al copiar un área del tipo de datos BOOL, la variable debe direccionarse de forma absoluta y
la longitud indicada del área debe ser un múltiplo de 8, pues de lo contrario no se ejecutará la
instrucción.

Reglas para copiar cadenas de caracteres
La instrucción "Copiar área" permite copiar asimismo áreas de origen y destino del tipo de
datos STRING. Si solo el área de origen es del tipo de datos STRING, se copiarán los
caracteres que realmente contiene la cadena de caracteres. La información sobre la longitud
real y máxima también se escribe en el área de destino. Si tanto el área de origen como el área
de destino son del tipo de datos STRING, la longitud actual de la cadena de caracteres en el
área de destino se pone al número de caracteres realmente copiados.
Si se desea copiar información sobre la longitud máxima y real de una cadena de caracteres,
las áreas de los parámetros SRCBLK y DSTBLK deben indicarse en bytes.

1922

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRCBLK

Input

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria que se copia (área de ori‐
gen).

DSTBLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria en la que se copia (área
de destino).

INT

I, Q, M, D, L, P

Información de error

Valor de función (RET_VAL)

1) El parámetro DSTBLK está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

8092

El área de origen o destino está solo en la memoria de carga.

8152

En el parámetro SRCBLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

8352

En el parámetro DSTBLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
Información
de error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_RetVal" := BLKMOV(SRCBLK := P#M100.0 BYTE 10,
DSTBLK => P#DB1.DBX0.0 BYTE 10);

La instrucción copia 10 bytes a partir de MB100 y los escribe en el DB1. Si ocurre un error
durante la operación de copia, el respectivo código de error se indica en la variable
"Tag_RetVal".

Programación del PLC
Manual de programación y manejo, 11/2019

1923

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1982)
Principios básicos de SCL (Página 8115)

UBLKMOV: Copiar área sin interrupciones
Descripción
La instrucción "Copiar área sin interrupciones" permite copiar los contenidos de un área de
memoria (área de origen) en un área de memoria diferente (área de destino). La operación de
copia se realiza por orden ascendente de direcciones. Las áreas de origen y destino se definen
mediante VARIANT.
La operación de copia no debe ser interrumpida por otras actividades del sistema operativo.
Ello puede aumentar el tiempo de reacción a alarmas de la CPU durante la ejecución de la
instrucción "Copiar área sin interrupciones".
Nota
Las variables de la instrucción sólo se pueden usar en áreas de memoria en las que no esté
activado el atributo "Acceso optimizado al bloque". Esto es válido para bloques de datos (DB),
bloques de organización (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucción se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable también se puede usar en áreas de memoria "con acceso
optimizado al bloque".

Áreas de memoria
La instrucción "Copiar área sin interrupciones" permite copiar las siguientes áreas de memoria:
● Áreas de un bloque de datos
● Marcas
● Memoria imagen de proceso de las entradas
● Memoria imagen de proceso de las salidas

Reglas generales para copiar
Al ejecutar la instrucción "Copiar área sin interrupciones" no pueden solaparse las áreas de
origen y destino. Si el área de origen es más pequeña que el área de destino, el área de origen
se copiará por completo en el área de destino. Los restantes bytes del área de destino
permanecen inalterados.
Si el área de destino es más pequeña que el área de origen, se escribirá en toda el área de
destino. Los restantes bytes del área de origen se ignoran.

1924

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si un área de origen o destino definida como parámetro formal es menor que un área de origen
o destino indicada en los parámetros SRCBLK o DSTBLK, no se transferirán datos.
Al copiar un área del tipo de datos BOOL, la variable debe direccionarse de forma absoluta y
la longitud indicada del área debe ser un múltiplo de 8, pues de lo contrario no se ejecutará la
instrucción.
La instrucción "Copiar área sin interrupciones" permite copiar 16 KB como máximo. A este
respecto deben tenerse en cuenta las limitaciones específicas de la CPU.

Reglas para copiar cadenas de caracteres
La instrucción "Copiar área sin interrupciones" permite copiar asimismo áreas de origen y
destino del tipo de datos STRING. Si solo el área de origen es del tipo de datos STRING, se
copiarán los caracteres que realmente contiene la cadena de caracteres. La información sobre
la longitud real y máxima no se escribe en el área de destino. Si tanto el área de origen como
el área de destino son del tipo de datos STRING, la longitud actual de la cadena de caracteres
en el área de destino se pone al número de caracteres realmente copiados. Si se copian áreas
del tipo de datos STRING, debe indicarse "1" como longitud del área.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRCBLK

Input

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria que se copia (área de ori‐
gen).

DSTBLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria en la que se copia (área
de destino).

INT

I, Q, M, D, L, P

Información de error

Valor de función (RET_VAL)

1) El parámetro DSTBLK está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error
(W#16#....)

Explicación

0000

Ningún error

8091

El área de origen o destino está solo en la memoria de carga.

8152

En el parámetro SRCBLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

8352

En el parámetro DSTBLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

Programación del PLC
Manual de programación y manejo, 11/2019

1925

Instrucciones
4.1 Instrucciones
Código de
error
(W#16#....)

Explicación

Información
de error ge‐
neral

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_RetVal" := UBLKMOV(SRCBLK := P#M100.0 BYTE 10,
DSTBLK => P#DB1.DBX0.0 BYTE 10);

La instrucción copia 10 bytes a partir de MB100 y los escribe en el DB1. Si ocurre un error
durante la operación de copia, el respectivo código de error se indica en la variable
"Tag_RetVal".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1982)
Principios básicos de SCL (Página 8115)

FILL: Rellenar área
Descripción
La instrucción "Rellenar área" rellena un área de memoria (área de destino) con el contenido
de un área de memoria diferente (área de origen). La instrucción "Rellenar área" copia el
contenido del área de origen en el área de destino las veces necesarias hasta que el área de
destino quede escrita por completo. La operación de copia se realiza por orden ascendente de
direcciones.

1926

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Las áreas de origen y destino se definen mediante VARIANT.
Nota
Las áreas de origen y destino también se pueden definir mediante el tipo de datos ANY.
Si se utiliza el tipo de datos ANY, hay que tener en cuenta lo siguiente en relación con el tipo
de datos STRING:
● En una asignación de STRING (área de origen) mediante ANY a STRING (área de destino),
el contenido del STRING se copia una y otra vez en el área de destino hasta llenarla.
Área de origen: 'STEP7-SCL-TIA-Portal'
Área de destino: 'STEP7-SCL-TIA-PortalSTEP7-SCL-TIA-PortalSTEP7-SCL'
● En una asignación de WSTRING (área de origen) mediante ANY a WSTRING (área de
destino), el WSTRING completo, incluida la tipificación, solo se copia una vez en el área de
destino.
Área de origen: WSTRING#'STEP7-SCL-TIA-Portal'
Área de destino: WSTRING#'STEP7-SCL-TIA-Portal'
Nota
Las variables de la instrucción sólo se pueden usar en áreas de memoria en las que no esté
activado el atributo "Acceso optimizado al bloque". Esto es válido para bloques de datos (DB),
bloques de organización (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucción se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable también se puede usar en áreas de memoria "con acceso
optimizado al bloque".
Para los bloques con el atributo "Acceso optimizado al bloque" puede utilizarse la instrucción
"FILL_BLK: Rellenar área".
La figura siguiente muestra el principio de la operación de copia:
),//

%9$/

$

%

0:

$

%

0:

&

'

0:

&

'

0:

(

)

0:

(

)

0:

*

+

0:

*

+

0:

$

%

0:

&

'

0:

(

)

0:

*

+

0:

$

%

0:

&

'

0:

%/.

Programación del PLC
Manual de programación y manejo, 11/2019

1927

Instrucciones
4.1 Instrucciones
Ejemplo: el contenido del área MW100 a MW118 debe inicializarse con el contenido de las
palabras de marcas MW14 a MW20.

Coherencia de los datos de origen y destino
Tenga en cuenta que al ejecutar la instrucción "Rellenar área" no se modifican los datos de
origen, pues de lo contrario no se podría garantizar la coherencia de los datos de destino.

Áreas de memoria
La instrucción "Rellenar área" permite copiar las siguientes áreas de memoria:
● Áreas de un bloque de datos
● Marcas
● Memoria imagen de proceso de las entradas
● Memoria imagen de proceso de las salidas

Reglas generales para copiar
Las áreas de origen y destino no deben solaparse. Aunque el área de destino que se debe
inicializar no sea múltiplo entero de la longitud del parámetro de entrada BVAL, el área de
destino se rellenará igualmente hasta el último byte.
Si el área de destino que se debe rellenar es menor que el área de origen, sólo se copiarán los
datos que quepan en el área de destino.
Si el área de origen o destino realmente existente es menor que el tamaño del área de memoria
parametrizada para el área de origen o destino (parámetros BVAL, BLK), los datos no se
transfieren.
Si el puntero ANY (origen o destino) es del tipo de datos BOOL, debe direccionarse de forma
absoluta y la longitud indicada del área debe ser un múltiplo de 8, pues de lo contrario no se
ejecutará la instrucción.
Si el área de destino es del tipo de datos STRING, la instrucción escribe la cadena de
caracteres completa, incluida la información de administración.

Reglas para copiar estructuras
Al transferir una estructura a modo de parámetro de entrada, tenga en cuenta que la longitud
de una estructura se rige siempre por un número par de bytes. Si se declara una estructura con
un número impar de bytes, la estructura necesitará un byte adicional de espacio en memoria.

1928

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

BVAL

Input

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria (área de origen) con cuyo
contenido se rellena el área
de destino en el parámetro
BLK.

BLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria que se rellena con el con‐
tenido del área de origen.

INT

I, Q, M, D, L, P

Información de error

Valor de función (RET_VAL)

1) El parámetro BLK está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro BVAL
Al indicar una estructura a modo de parámetro de entrada, tenga en cuenta que la longitud de
una estructura se adapta siempre a un número entero de bytes. Si se declara una estructura
con un número impar de bytes, la estructura necesitará un byte adicional de espacio en
memoria.

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de Explicación
error
(W#16#....)
0000

Ningún error

8092

El área de origen o destino está solo en la memoria de carga.

8152

En el parámetro BVAL no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

8352

En el parámetro BLK no están permitidos los tipos de datos WSTRING, WCHAR, BOOL,
ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

Informa‐
Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
ción de
error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Programación del PLC
Manual de programación y manejo, 11/2019

1929

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_RetVal" := FILL(BVAL := P#M14.0 WORD 4,
BLK => P#M100.0 WORD 10);

La instrucción copia el área de origen de MW14 a MW20 y rellena el área de destino de MW100
a MW118 con el contenido de las 4 palabras contenidas en el área de memoria del parámetro
BVAL.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1982)
Principios básicos de SCL (Página 8115)

Conversión
CONVERT: Convertir valor
Descripción
La instrucción "Convertir valor" permite programar conversiones explícitas. Al insertar la
instrucción se abre el cuadro de diálogo "CONVERT". En él se indica el tipo de datos de origen
y el tipo de datos de destino de la conversión. El valor de origen se lee y se convierte al tipo de
datos de destino indicado.

1930

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Opciones de conversión de secuencias de bits
En el cuadro de la instrucción no se pueden seleccionar las secuencias de bits BYTE y WORD.
Sin embargo es posible indicar un operando del tipo de datos DWORD o LWORD en un
parámetro de la instrucción si coinciden la longitud del operando de entrada y la del operando
de salida. En tal caso, el operando del tipo de datos de una secuencia de bits se interpreta
conforme al tipo de datos del parámetro de entrada o salida y se convierte implícitamente. El
tipo de datos DWORD se interpreta, p. ej., como DINT/UDINT, y LWORD como LINT/ULINT.
Estas opciones de conversión también están disponibles estando activada la verificación CEI.
Nota
Para las CPU de las series S7-1500 se aplica: Los tipos de datos DWORD y LWORD sólo se
pueden convertir a o desde el tipo de datos REAL o LREAL.
El patrón de bits del valor de origen se transfiere sin cambios y justificado a la derecha al tipo
de datos de destino. Si no se producen errores durante la conversión, el estado de señal de la
salida de habilitación ENO = 1; si se produce un error durante la ejecución, el estado de señal
de la salida de habilitación ENO = 0.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

<Tipo de ori‐
gen>

Input

Números binarios, I, Q, M, D, L, P o
enteros, números constante
en coma flotante,
temporizadores,
fecha y hora, cade‐
nas de caracteres,
BCD16, BCD32

Valor que se convierte.

Números binarios, I, Q, M, D, L, P o
enteros, números constante
en coma flotante,
temporizadores,
fecha y hora, cade‐
nas de caracteres,
BCD16, BCD32

Resultado de la conversión

<Tipo de des‐ Output
tino>

Área de memoria

Descripción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_INT" := REAL_TO_INT("Tag_REAL");

Programación del PLC
Manual de programación y manejo, 11/2019

1931

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Tipo de datos

Valor

Tag_REAL

REAL

20.56

Tag_INT

INT

21

En la conversión, el valor del operando "Tag_REAL" se redondea al siguiente entero y se
deposita en el operando "Tag_INT".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

ROUND: Redondear número
Descripción
La instrucción "Redondear número" permite redondear el valor de la entrada IN al siguiente
número entero. La instrucción interpreta el valor de la entrada IN como número en coma
flotante y lo convierte a un número entero o a un número en coma flotante. Si el valor de
entrada se encuentra entre un número par y uno impar, se selecciona el número par.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

<Expresión>

Input

Números en
coma flotante

I, Q, M, D, L, P

Valor de entrada
que se debe redon‐
dear.

Valor de función

Enteros, núme‐ I, Q, M, D, L, P
ros en coma
flotante

Resultado del re‐
dondeo

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := ROUND("Tag_Value");

El resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.

1932

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

1.50000000

-1.50000000

Tag_Result

2

-2

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

CEIL: Redondear un número en coma flotante al siguiente entero superior
Descripción
La instrucción "Redondear un número en coma flotante al siguiente entero superior" permite
redondear el valor al siguiente número entero superior. La instrucción interpreta el valor de
entrada como número en coma flotante y lo convierte al número entero superior más próximo.
El valor de la función puede ser mayor o igual al valor de entrada.
Para modificar el tipo de datos de la instrucción, utilice la sintaxis siguiente:
CEIL_<Tipo de datos>();

Programación del PLC
Manual de programación y manejo, 11/2019

1933

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declara‐
ción

Tipo de datos

Área de memoria Descripción

<Expresión>

Input

Números en
coma flotante

I, Q, M, D, L, P

_<tipo de datos>

Valor de entrada

Enteros, núme‐ ros en coma
flotante, valor
predetermina‐
do: DINT

Tipo de datos del valor de función:
1. El tipo de datos de la
instrucción se puede indicar
explícitamente con "_".
2. Si el tipo de datos no se indica
explícitamente, se
determinará a partir de las
variables utilizadas o de las
constantes con tipos.
3. Si el tipo de datos no se indica
explícitamente ni se indican
variables definidas ni
constantes con tipo, se
utilizará el tipo de datos
predeterminado.

Valor de función

Enteros, núme‐ I, Q, M, D, L
ros en coma
flotante

Valor de entrada redondeado

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result1" := CEIL("Tag_Value");
"Tag_Result2" := CEIL_REAL("Tag_Value");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

0.5

-0.5

Tag_Result1

1

0

Tag_Result2

1.0

0.0

El resultado de la instrucción se devuelve en el operando "Tag_Resultxy" como valor de
función.

1934

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

FLOOR: Redondear un número en coma flotante al siguiente entero inferior
Descripción
La instrucción "Redondear un número en coma flotante al siguiente entero inferior" permite
redondear el valor al siguiente número entero inferior. La instrucción interpreta el valor de
entrada como número en coma flotante y lo convierte al número entero inferior más próximo.
El valor de función puede ser menor o igual al valor de entrada.
Para modificar el tipo de datos de la instrucción, utilice la sintaxis siguiente:
FLOOR_<Tipo de datos>();

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria Descripción

<Expresión>

Input

Números en
coma flotante

I, Q, M, D, L, P

_<tipo de datos>

Enteros, núme‐ ros en coma
flotante, valor
predetermina‐
do: DINT

Valor de entrada
Tipo de datos del valor de fun‐
ción:
1. El tipo de datos de la
instrucción se puede indicar
explícitamente con "_".
2. Si el tipo de datos no se
indica explícitamente, se
determinará a partir de las
variables utilizadas o de las
constantes con tipos.
3. Si el tipo de datos no se
indica explícitamente ni se
indican variables definidas
ni constantes con tipo, se
utilizará el tipo de datos
predeterminado.

Valor de función

Enteros, núme‐ I, Q, M, D, L
ros en coma
flotante

Valor de entrada redondeado

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1935

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result1" := FLOOR("Tag_Value");
"Tag_Result2" := FLOOR_REAL("Tag_Value");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

0.5

-0.5

Tag_Result1

0

-1

Tag_Result2

0.0

-1.0

El resultado de la instrucción se devuelve en el operando "Tag_Resultxy" como valor de
función.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

TRUNC: Truncar a entero
Descripción
La instrucción "Truncar a entero" permite generar un valor entero no redondeado a partir del
valor de entrada. La instrucción selecciona solo la parte entera del valor de entrada y la
devuelve sin decimales como valor de función.
Para modificar el tipo de datos de la instrucción, utilice la sintaxis siguiente:
TRUNC_<Tipo de datos>();

1936

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declara‐
ción

Tipo de datos

Área de memoria

Descripción

<Expresión>

Input

Números en
coma flotante

I, Q, M, D, L

Valor de entrada

_<tipo de datos>

Enteros, núme‐ ros en coma
flotante
Valor predeter‐
minado: DINT

Tipo de datos del valor de
función:
1. El tipo de datos de la
instrucción se puede
indicar explícitamente
con "_".
2. Si el tipo de datos no se
indica explícitamente,
se determinará a partir
de las variables
utilizadas o de las
constantes con tipos.
3. Si el tipo de datos no se
indica explícitamente ni
se indican variables
definidas ni constantes
con tipo, se utilizará el
tipo de datos
predeterminado.

Valor de función

Enteros, núme‐ I, Q, M, D, L
ros en coma
flotante

Parte entera del valor de en‐
trada

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result1" := TRUNC("Tag_Value1");
"Tag_Result2" := TRUNC("Tag_Value2"+"Tag_Value3");
"Tag_Result3" := TRUNC_SINT("Tag_Value4");

El resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value1

-1.5

Tag_Result1

-1

Tag_Value2

2.1

Programación del PLC
Manual de programación y manejo, 11/2019

1937

Instrucciones
4.1 Instrucciones
Operando

Valor

Tag_Value3

3.2

Tag_Result2

5

Tag_Result3

2

Tag_Value4

2.4

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

SCALE_X: Escalar
Descripción
La instrucción "Escalar" permite escalar un número en coma flotante mapeándolo en un
determinado rango de valores. El rango de valores se especifica con los parámetros MIN y
MAX. El resultado de la escala es un entero.
Para modificar el tipo de datos de la instrucción, utilice la sintaxis siguiente:
SCALE_X_<Tipo de datos>();
La figura siguiente muestra un ejemplo de cómo pueden escalarse los valores:

0$;
5HVXOWDGR!
0,1




([SUHVLµQ!

La instrucción "Escalar" utiliza la siguiente ecuación:

1938

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
OUT = [VALUE ∗ (MAX – MIN)] + MIN
Nota
Encontrará más información sobre la conversión de valores analógicos en el manual de
producto correspondiente.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memo‐ Descripción
ria

MIN

Input

Enteros, núme‐
ros en coma flo‐
tante

I, Q, M, D, L

Límite inferior del rango de
valores

VALUE

Input

Números en co‐
ma flotante

I, Q, M, D, L

Valor que se escala. Si se in‐
dica una constante, esta de‐
be declararse.

MAX

Input

Enteros, núme‐
ros en coma flo‐
tante

I, Q, M, D, L

Límite superior del rango de
valores

Enteros, núme‐
ros en coma flo‐
tante
valor predeter‐
minado: INT

-

Tipo de datos del valor de fun‐
ción:

_<tipo de datos>

1. El tipo de datos de la
instrucción se puede
indicar explícitamente con
"_".
2. Si el tipo de datos no se
indica explícitamente, se
determinará a partir de las
variables utilizadas o de
las constantes con tipos.
3. Si el tipo de datos no se
indica explícitamente ni
se indican variables
definidas ni constantes
con tipo, se utilizará el tipo
de datos predeterminado.

Valor de función

Enteros, núme‐
ros en coma flo‐
tante

-

Resultado de la escala

Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Encontrará más información sobre la declaración de constantes en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1939

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result1" := SCALE_X(MIN := "Tag_Value1",
VALUE := "Tag_Real",
MAX := "Tag_Value2");
"Tag_Result2" := SCALE_X_REAL(MIN := "Tag_Value1",
VALUE := "Tag_Real",
MAX := "Tag_Value2");

El resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Real

0.5

Tag_Value1

10

Tag_Value2

30

Tag_Result1

20

Tag_Result2

20.0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Declarar constantes globales (Página 7910)
Principios básicos de SCL (Página 8115)

NORM_X: Normalizar
Descripción
La instrucción "Normalizar" normaliza el valor de la variable de la entrada VALUE
representándolo en una escala lineal. Los parámetros MIN y MAX sirven para definir los límites
de un rango de valores que se refleja en la escala. En función de la posición del valor que se
debe normalizar en este rango de valores, se calcula el resultado y se deposita como número
en coma flotante en la salida OUT. Si el valor que se debe normalizar es igual al valor de la
entrada MIN, la instrucción devuelve el valor "0.0" como resultado. Si el valor que se debe
normalizar es igual al valor de la entrada MAX, la instrucción devuelve el valor "1.0" como
resultado.
Para modificar el tipo de datos de la instrucción, utilice la sintaxis siguiente:
NORM_X_<Tipo de datos>();
La figura siguiente muestra un ejemplo de cómo pueden normalizarse los valores:

1940

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones


5HVXOWDGR!

0,1

0$;

([SUHVLµQ!

La instrucción "Normalizar" utiliza la siguiente ecuación:
OUT = (VALUE – MIN) / (MAX – MIN)
Nota
Encontrará más información sobre la conversión de valores analógicos en el manual de
producto correspondiente.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memo‐
ria

Descripción

MIN 1)

Input

Enteros, núme‐
ros en coma flo‐
tante

I, Q, M, D, L

Límite inferior del rango de
valores

VALUE 1)

Input

Enteros, núme‐
ros en coma flo‐
tante

I, Q, M, D, L

Valor que se normaliza.

MAX 1)

Input

Enteros, núme‐
ros en coma flo‐
tante

I, Q, M, D, L

Límite superior del rango de
valores

Programación del PLC
Manual de programación y manejo, 11/2019

1941

Instrucciones
4.1 Instrucciones
Parámetros
_<tipo de datos>

Declaración

Tipo de datos

Área de memo‐
ria

Descripción

Números en co‐
ma flotante
Valor predeter‐
minado: REAL

-

Tipo de datos del valor de
función:
1. El tipo de datos de la
instrucción se puede
indicar explícitamente
con "_".
2. Si el tipo de datos no se
indica explícitamente, se
determinará a partir de
las variables utilizadas o
de las constantes con
tipos.
3. Si el tipo de datos no se
indica explícitamente ni
se indican variables
definidas ni constantes
con tipo, se utilizará el
tipo de datos
predeterminado.

Valor de función
1)

Números en co‐
ma flotante

I, Q, M, D, L

Resultado de la normaliza‐
ción

Si se utilizan constantes en estos tres parámetros, basta con declarar una de ellas.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Encontrará más información sobre la declaración de constantes en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result1" := NORM_X(MIN := "Tag_Value1",
VALUE := "Tag_InputValue",
MAX := "Tag_Value2");
"Tag_Result2" := NORM_X_LREAL(MIN := "Tag_Value1",
VALUE := "Tag_InputValue",
MAX := "Tag_Value2");

El resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:

1942

Operando

Valor

Tag_InputValue

20

Tag_Value1

10

Tag_Value2

30

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Operando

Valor

Tag_Result1

0.5

Tag_Result2

0.5

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Declarar constantes globales (Página 7910)
Principios básicos de SCL (Página 8115)

REF: Crear referencia a una variable
Descripción
Con la palabra clave "REF()" se especifica la variable a la que debe señalar una referencia
previamente declarada. Como parámetro se indica la variable que debe referenciarse.

Nota
Declaración de referencias
Antes de utilizar la palabra clave "REF()" es necesario declarar una referencia en la interfaz del
bloque.
Consulte también:
Declarar referencias (Página 314)

Programación del PLC
Manual de programación y manejo, 11/2019

1943

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Expresión>

Input

Secuencias de
bits, excepto
BOOL,

Variable DB (opti‐
mizada),

Variable a la que
debe señalar la re‐
ferencia

Enteros,
Números en coma
flotante,

Interfaz de un blo‐
que FB (optimiza‐
do)

Cadenas de carac‐
teres,
Tipos de datos
PLC (UDT),
Tipos de datos de
sistema (SDT),
ARRAYs de los ti‐
pos de datos cita‐
dos
Valor de función

El tipo de datos del
valor de función
concuerda con el
de la variable de
referencia declara‐
da.

Interfaz de bloque
de una FC: Input,
Output, Temp

Dirección de la va‐
riable referenciada

Interfaz de bloque
de un FB: Temp

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Reglas
Para el referenciado se aplican las reglas siguientes:
● El tipo de datos de la variable, que se indica entre paréntesis, debe coincidir exactamente
con el tipo de datos de la referencia declarada. Una referencia del tipo "REF_TO Int" sólo
puede señalar por tanto a una variable del tipo "Int". No se produce una conversión de tipos
de datos.
● La variable que se especifique como parámetro para "REF()" debe estar en un área de
memoria optimizada.
● Una referencia no debe señalar a los datos siguientes:
– datos temporales (TEMP)
– variables globales procedentes de la tabla de variables PLC
– parámetros de bloque
– constantes
– variables protegidas contra escritura

1944

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para referencias a arrays (matrices) se aplica:
● Los límites de arrays (matrices) y dimensiones de la referencia y de la variable referenciada
deben ser idénticos.
● Array[*] no se soporta.
● Las referencias a los DB ARRAY que se basan en un tipo de datos PLC deben crearse del
siguiente modo:
REF("my_ArrayDB_UDT".THIS)
REF("my_ArrayDB_UDT"."THIS"[i])

Ejemplo
En la interfaz del bloque se han declarado las variables temporales "#myRefInt",
"#myRefType" y "#myRefArray".

En el código del programa se han asignado variables concretas a estas referencias:
SCL
#myRefInt := REF(#a);
#myRefType := REF("myDB".myUDT);
#myRefType := REF("myArrayDB_UDT"."THIS"[1]);
#myRefARRAY := REF("myDB".myArray);

Consulte también
Principios básicos de las referencias (Página 310)
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1945

Instrucciones
4.1 Instrucciones

VARIANT
VARIANT_TO_DB_ANY: Convertir VARIANT en DB_ANY
Descripción
La instrucción "Convertir VARIANT en DB_ANY" consulta el número de bloque de datos que
direcciona el operando indicado en el parámetro IN. Se puede tratar de un bloque de datos de
instancia o de un bloque de datos ARRAY. El operando del parámetro IN es del tipo de datos
VARIANT, por lo que al escribir el programa no se necesita saber qué tipo de datos tiene el
bloque de datos, cuyo número debe consultarse. El número del bloque de datos se lee en
tiempo de ejecución y se escribe en el operando indicado en el parámetro RET_VAL.

Requisitos
Si se cumplen los requisitos, se ejecuta la instrucción. Si no se cumplen los requisitos, se
devuelve "0" como número del bloque de datos.

1946

La variable de salida...

referencia...

Posibilidades de conversión

VARIANT

... un bloque de datos que puede
ser un bloque de datos de ins‐
tancia de un tipo de datos PLC o
de un tipo de datos del sistema
(SDT).

Es posible convertir la variable
de salida a un número del bloque
de datos.

VARIANT

... un bloque de datos que es un
DB de ARRAY.

Es posible convertir la variable
de salida a un número del bloque
de datos.

VARIANT

... una variable con un tipo de
datos simple.

No es posible convertir la varia‐
ble de salida a un número del
bloque de datos, puesto que un
bloque de datos nunca consta
solamente de un tipo de datos
simple.

VARIANT

... una estructura de un bloque
de datos.

No es posible convertir la varia‐
ble de salida a un número del
bloque de datos, puesto que so‐
lo se trata de una parte del blo‐
que de datos.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

VARIANT

L (puede declarar‐
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

Variable que se lee. (Valor de
función de la instrucción
"DB_ANY_TO_VARIANT")
En el parámetro IN puede
emplearse una variable local
o global.

ERR

Output

INT

I, Q, M, D, L

Información de error

DB_ANY

I, Q, M, D, L

Resultado: número de DB

Valor de función (RET_VAL)

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro ERR
La tabla siguiente muestra el significado de los valores del parámetro ERR:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

252C

El tipo de datos VARIANT del parámetro IN devuelve el valor "0" y la CPU pasa al estado
operativo STOP.

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8130

El parámetro IN es del tipo de datos ANY.

8131

El bloque de datos no existe, es demasiado corto o está en la memoria de carga.

8132

El bloque de datos es demasiado corto y no es un bloque de datos ARRAY.

8150

El tipo de datos VARIANT del parámetro IN devuelve el valor "0". Para recibir este men‐
saje de error, la propiedad de bloque "Tratamiento local de errores en el bloque" debe
estar activada. En caso contrario, la CPU pasa al estado operativo STOP y devuelve el
código de error 16#252C.

8153

El tipo de datos VARIANT del parámetro IN no apunta al principio de un bloque de datos
ARRAY o bien la longitud del VARIANT no concuerda con la del bloque de datos.

8154

El bloque de datos es de un tipo incorrecto.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"OutputDBNumber" := VARIANT_TO_DB_ANY(IN := #tempVARIANT,
ERR := "Tag_Error");

Programación del PLC
Manual de programación y manejo, 11/2019

1947

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Declaración en la inter‐
faz del bloque

Operando

Valor

IN

Input

tempVARIANT

-

<Valor de función>

Output

OutputDBNumber

11

Se lee el número de un bloque de datos indicado en el operando tempVARIANT. Puesto que
el operando es del tipo de datos VARIANT, en el momento de la elaboración del programa aún
no es necesario saber de qué tipo de datos es la variable. El número se escribe en la variable
"OutputDBNumber" que tiene el tipo de datos DB_ANY.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

DB_ANY_TO_VARIANT: Convertir DB_ANY en VARIANT
Descripción
La instrucción "Convertir DB_ANY en VARIANT" permite generar, a partir de un bloque de
datos, una variable VARIANT que cumple los requisitos abajo indicados. El operando del
parámetro IN es del tipo de datos DB_ANY, por lo que al escribir el programa no es necesario
conocer el bloque de datos. El número del bloque de datos se lee en tiempo de ejecución.

Requisitos
Si se cumplen los requisitos, se ejecuta la instrucción. Si no se cumplen los requisitos o el
bloque de datos no existe, se devuelve el valor NULL en el parámetro RET_VAL. Los demás
accesos con la variable RET_VAL dan error.

1948

La variable de entrada del tipo
de datos...

referencia...

Posibilidades de conversión

DB_ANY

... un bloque de datos que puede
ser un bloque de datos de ins‐
tancia de un tipo de datos PLC o
de un tipo de datos del sistema
(SDT).

La conversión es posible

DB_ANY

... un bloque de datos que es un
DB de ARRAY.

La conversión es posible

DB_ANY

... un bloque de datos que puede
ser un bloque de datos de ins‐
tancia de un bloque de función o
un bloque de datos global.

La conversión no es posible

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

DB_ANY

I, Q, M, D, L

Bloque de datos cuyo núme‐
ro se lee. En el parámetro IN
puede emplearse una varia‐
ble local o global.

ERR

Output

INT

I, Q, M, D, L

Información de error

VARIANT

L (puede declarar‐ Número del bloque de datos
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

Valor de función
(RET_VAL) 1)

1) El parámetro RET_VAL está declarado como Output, ya que los datos desembocan en la variable.
Sin embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro ERR
La tabla siguiente muestra el significado de los valores del parámetro ERR:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

8130

El número del bloque de datos es "0".

8131

El bloque de datos no existe, es demasiado corto o está en la memoria de carga.

8132

El bloque de datos es demasiado corto y no es un bloque de datos ARRAY.

8134

El bloque de datos está protegido contra escritura.

8154

El bloque de datos es de un tipo incorrecto.

8155

El bloque de datos es de un tipo de datos desconocido. 1)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".
1)

La causa del código de error #8155 es la siguiente:

Se ha declarado un tipo de datos PLC (UDT1) y a continuación se crea un bloque de datos
(DB2) del tipo de datos "UDT1". En la tabla de variables hay una variable (3) del tipo de datos
DB_ANY. En un bloque de programa (4) se llamó entonces la instrucción
"DB_ANY_TO_VARIANT" y se le asignó la variable (3) en el parámetro IN. Al ejecutar la
instrucción "DB_ANY_TO_VARIANT", se emite el código de error 16#8155.
Para resolver el código de error, haga lo siguiente:
1. Cree una función (FC5) y declare una variable del tipo de datos VARIANT en la interfaz
InOut.
2. Cree otra función (FC6) y en ella llame FC5.

Programación del PLC
Manual de programación y manejo, 11/2019

1949

Instrucciones
4.1 Instrucciones
3. En FC6, en la interfaz Temp, cree una variable (7) del tipo de datos "UDT1".
4. Asigne a la interfaz InOut de FC5 la variable (7).
5. Compile y cargue los dos bloques (FC5 y FC6) en la CPU. No hace falta que llame estos
bloques (FC5 y FC6) en el programa de usuario.
Resultado:
El código de error 16#8155 no se emite, puesto que el programa de usuario ya conoce el tipo
de datos.
Este proceso no es necesario si después de llamar la instrucción "DB_ANY_TO_VARIANT",
llama una de las dos instrucciones "VariantGet" o "VariantPut".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
#tempVARIANT := DB_ANY_TO_VARIANT(IN := "InputDB",
ERR := "Tag_Error");

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Declaración en la Operando
interfaz del bloque

Valor

IN

Input

InputDB

11

<Valor de función>

Temp

tempVARIANT

-

El número de un bloque de datos cualquiera indicado en el operando "InputDB" se utiliza para
generar una variable del tipo de datos VARIANT que direccione el bloque de datos. Puesto que
el operando del parámetro IN es del tipo de datos DB_ANY, al escribir el programa aún no es
necesario saber qué bloque de datos se utilizará en tiempo de ejecución, ni tampoco el nombre
y el número del bloque de datos. Puesto que el operando del parámetro RET_VAL es del tipo
de datos VARIANT, al escribir el programa aún no es necesario saber qué tipo de datos tiene
el bloque de datos.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

1950

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Legacy
SCALE: Escalar
Descripción
La instrucción "Escalar" convierte el entero del parámetro IN en un número en coma flotante
que se escala en unidades físicas entre un límite inferior y uno superior. Los límites inferior y
superior del rango de valores en el que se escala el valor de entrada se definen mediante los
parámetros LO_LIM y HI_LIM. El resultado de la instrucción se devuelve en el parámetro OUT.
La instrucción "Escalar" utiliza la siguiente ecuación:
OUT = [((FLOAT (IN) – K1)/(K2–K1)) ∗ (HI_LIM–LO_LIM)] + LO_LIM
El estado lógico del parámetro BIPOLAR determina los valores de las constantes "K1" y "K2".
El parámetro BIPOLAR puede tener los siguientes estados lógicos:
● Estado lógico "1": se presupone que el valor del parámetro IN es bipolar y está comprendido
en un rango de valores entre -27648 y 27648. En este caso, la constante "K1" tiene el valor
-27648,0, y la constante "K2", el valor +27648,0.
● Estado lógico "0": se presupone que el valor del parámetro IN es unipolar y está
comprendido en un rango de valores entre 0 y 27648. En este caso, la constante "K1" tiene
el valor 0,0, y la constante "K2", el valor +27648,0.
Si el valor del parámetro IN es mayor que el de la constante "K2", el resultado de la instrucción
se pone al valor del límite superior (HI_LIM) y se emite un error.
Si el valor del parámetro IN es menor que el de la constante "K1", el resultado de la instrucción
se pone al valor del límite inferior (LO_LIM) y se emite un error.
Si el límite inferior indicado es mayor que el límite superior (LO_LIM > HI_LIM), el resultado se
escala de forma inversamente proporcional al valor de entrada.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

INT

I, Q, M, D, L, P

Valor de entrada que se es‐
cala.

HI_LIM

Input

REAL

I, Q, M, D, L, P

Valor límite superior

LO_LIM

Input

REAL

I, Q, M, D, L, P

Valor límite inferior

BIPOLAR

Input

BOOL

I, Q, M, D, L

Indica si el valor del paráme‐
tro IN se interpreta como bi‐
polar o unipolar. El paráme‐
tro puede adoptar los valores
siguientes:
1: Bipolar
0: Unipolar

OUT

Output

Valor de función (RET_VAL)

Programación del PLC
Manual de programación y manejo, 11/2019

REAL

I, Q, M, D, L, P

Resultado de la instrucción

WORD

I, Q, M, D, L, P

Información de error

1951

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de Explicación
error
(W#16#....)
0000

Ningún error

0008

El valor del parámetro IN es mayor que 27 648 o menor que 0 (unipolar) o -27 648 (bipolar).

Informa‐
Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
ción de
error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_ErrorCode" := SCALE(IN := "Tag_InputValue",
HI_LIM := "Tag_HighLimit",
LO_LIM := "Tag_LowLimit",
BIPOLAR := "Tag_Bipolar",
OUT => "Tag_Result");

La información de error se devuelve en el operando "Tag_ErrorCode" como valor de función.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

Tag_InputValue

22

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

OUT

Tag_Result

50.03978588

RET_VAL

Tag_ErrorCode

W#16#0000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1982)

1952

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de SCL (Página 8115)

UNSCALE: Desescalar
Descripción
La instrucción "Desescalar" permite desescalar el número en coma flotante del parámetro IN
en unidades físicas comprendidas entre un límite inferior y uno superior y convertirlo en un
número entero. Los límites inferior y superior del rango de valores en el que se desescala el
valor de entrada se definen mediante los parámetros LO_LIM y HI_LIM. El resultado de la
instrucción se devuelve en el parámetro OUT.
La instrucción "Desescalar" utiliza la siguiente ecuación:
OUT = [((IN–LO_LIM)/(HI_LIM–LO_LIM)) ∗ (K2–K1)] + K1
El estado lógico del parámetro BIPOLAR determina los valores de las constantes "K1" y "K2".
El parámetro BIPOLAR puede tener los siguientes estados lógicos:
● Estado lógico "1": se presupone que el valor del parámetro IN es bipolar y está comprendido
en un rango de valores entre -27648 y 27648. En este caso, la constante "K1" tiene el valor
-27648,0, y la constante "K2", el valor +27648,0.
● Estado lógico "0": se presupone que el valor del parámetro IN es unipolar y está
comprendido en un rango de valores entre 0 y 27648. En este caso, la constante "K1" tiene
el valor 0,0, y la constante "K2", el valor +27648,0.
Si el valor del parámetro IN no se encuentra dentro de los límites definidos por HI_LIM y
LO_LIM, se emite un error. El resultado se ajusta al límite más próximo.
Si el límite inferior indicado es mayor que el límite superior (LO_LIM > HI_LIM), el resultado se
escala de forma inversamente proporcional al valor de entrada.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

REAL

I, Q, M, D, L, P

Valor de entrada que se de‐
sescala en un valor entero.

HI_LIM

Input

REAL

I, Q, M, D, L, P

Valor límite superior

LO_LIM

Input

REAL

I, Q, M, D, L, P

Valor límite inferior

BIPOLAR

Input

BOOL

I, Q, M, D, L

Indica si el valor del paráme‐
tro IN se interpreta como bi‐
polar o unipolar. El paráme‐
tro puede adoptar los valores
siguientes:
1: Bipolar
0: Unipolar

OUT

Output

Valor de función (RET_VAL)

Programación del PLC
Manual de programación y manejo, 11/2019

INT

I, Q, M, D, L, P

Resultado de la instrucción

WORD

I, Q, M, D, L, P

Información de error

1953

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de Explicación
error
(W#16#....)
0000

Ningún error

0008

El valor del parámetro IN es mayor que el del límite superior (HI_LIM) o menor que el del
límite inferior (LO_LIM).

Informa‐
Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
ción de
error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización aquí: Cambiar
formatos de visualización en el estado del programa (Página 8529)

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

"Tag_ErrorCode" := UNSCALE(IN := "Tag_InputValue",
HI_LIM := "Tag_HighLimit",
LO_LIM := "Tag_LowLimit",
BIPOLAR := "Tag_Bipolar",
OUT => "Tag_Result");

La información de error se devuelve en el operando "Tag_ErrorCode" como valor de función.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

Tag_InputValue

50.03978588

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

OUT

Tag_Result

22

RET_VAL

Tag_ErrorCode

W#16#0000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
GET_ERR_ID: Consultar ID de error localmente (Página 1982)

1954

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de SCL (Página 8115)

Control del programa
IF: Ejecución condicional
Descripción
La instrucción "Ejecución condicional" permite ramificar el flujo del programa en función de una
condición. La condición es una expresión con un valor booleano (TRUE o FALSE). Como
condición se pueden indicar expresiones lógicas o expresiones de comparación.
Al ejecutar la instrucción, se evalúan las expresiones indicadas. Si el valor de una expresión
es TRUE, la condición se considera cumplida; en el caso de FALSE se considera que la
condición no se cumple.

Parámetros
Dependiendo del tipo de ramificación se pueden programar las siguientes formas de la
instrucción:
● Ramificación con IF:
IF <condición> THEN <instrucciones>
END_IF;
Si se cumple la condición, se ejecutan las instrucciones que están programadas después de
THEN. Si la condición no se cumple, el procesamiento del programa continúa con la siguiente
instrucción después de END_IF.
● Ramificación con IF y ELSE:
IF <condición> THEN <instrucciones1>
ELSE <Instrucciones0>
END_IF;
Si se cumple la condición, se ejecutan las instrucciones que están programadas después de
THEN. Si no se cumple la condición, se ejecutan las instrucciones que están programadas
después de ELSE. Después, el procesamiento del programa continúa con la siguiente
instrucción después de END_IF.
● Ramificación con IF, ELSIF y ELSE:
IF <condición1> THEN <instrucciones1>
IF <condición2> THEN <instrucciones2>
ELSE <Instrucciones0>
END_IF;
Si se cumple la primera condición (<condición1>), se ejecutan las instrucciones
(<instrucciones1>) después de THEN. Después de ejecutar las instrucciones, el
procesamiento del programa continúa después de END_IF.
Si no se cumple la primera condición, se comprueba la segunda (<condición2>). Si se cumple
la segunda condición (<condición2>), se ejecutan las instrucciones (<instrucciones2>)

Programación del PLC
Manual de programación y manejo, 11/2019

1955

Instrucciones
4.1 Instrucciones
después de THEN. Después de ejecutar las instrucciones, el procesamiento del programa
continúa después de END_IF.
Si no se cumple ninguna condición, se ejecutan las instrucciones (<instrucciones0> después
de ELSE y, a continuación, continúa el procesamiento del programa después de END_IF.
En una instrucción IF se pueden anidar tantas combinaciones de ELSIF y THEN como se
desee. La programación de una rama ELSE es opcional.
La sintaxis de la instrucción IF se compone de las siguientes partes:
Parámetro

Tipo de datos Área de memoria

Descripción

<Condición>

BOOL

Expresión que se evalúa.

<Instruccio‐
nes>

-

I, Q, M, D, L

Instrucciones que se ejecutan si se cumple la con‐
dición. Una excepción son las instrucciones que
están programadas después de ELSE. Estas se
ejecutan si no se cumple ninguna condición dentro
del bucle.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
IF "Tag_1" = 1
THEN "Tag_Value" :=
ELSIF "Tag_2" = 1
THEN "Tag_Value" :=
ELSIF "Tag_3" = 1
THEN "Tag_Value" :=
ELSE "Tag_Value" :=
END_IF;

10;
20;
30;
0;

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_1

1

0

0

0

Tag_2

0

1

0

0

Tag_3

0

0

1

0

Tag_Value

10

20

30

0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

1956

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CASE: Estructura selectiva múltiple
Descripción
La instrucción "Estructura selectiva múltiple" permite procesar una de varias secuencias de
instrucciones en función del valor de una expresión.
El valor de la expresión puede ser un número entero o una secuencia de bits. Al ejecutar la
instrucción CASE se compara el valor de la expresión (variable) con los valores de varias
constantes. Si el valor de la expresión (variable) coincide con el de una constante, se cumple
la condición y se ejecutan las instrucciones que están programadas directamente después de
esta constante. Al hacerlo, las constantes pueden adoptar distintos valores.
La instrucción se puede declarar del siguiente modo:
CASE <Variable> OF
<Constante1>: <Instrucciones1>;
<Constante2>: <Instrucciones2>;
<ConstanteX>: <InstruccionesX>; // X >= 3
ELSE <Instrucciones0>;
END_CASE;

Programación del PLC
Manual de programación y manejo, 11/2019

1957

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Tipo de datos Área de memoria

Descripción

<Variable>

Secuencias
de bits, ente‐
ros

I, Q, M, D, L

Valor que se compara con los valores de constan‐
tes programados.

<Constante>

Secuencias
de bits

-

En el caso de una secuencia de bits, las constan‐
tes pueden adoptar los siguientes valores:

Pueden pro‐
gramarse
constantes
locales y glo‐
bales.

● Número binario (p. ej., 2#10)
● Número octal (p. ej., 8#77)
● Número hexadecimal (p. ej., 16#AD)
● Constante sin tipo (p. ej., 1000)
En caso de una variable Byte tipificada, deben
programarse constantes Byte (p. ej., BYTE#2).
En caso de una variable Word tipificada, pueden
programarse constantes Byte o Word (p. ej.,
BYTE#2, WORD#2).
En caso de una variable DWord tipificada, pueden
programarse constantes Byte, Word o DWord
(p. ej., BYTE#2, WORD#2, DWORD#2).
En caso de una variable LWord tipificada, pueden
programarse constantes Byte, Word, DWord o
LWord (p. ej., BYTE#2, WORD#2, DWORD#2,
LWORD#2).
Enteros

En el caso de un número entero, las constantes
pueden adoptar los siguientes valores:
● un número entero (p. ej., 5)
● un rango de enteros (p. ej., 15 a 20)
● una enumeración de números enteros y
rangos (p. ej., 10, 11, 15..20)

<Instrucción> -

-

Cualquier instrucción que se ejecuta si el valor de
la expresión coincide con el valor de una constan‐
te. Una excepción son las instrucciones que están
programadas después de ELSE. Estas se ejecu‐
tan cuando los valores no coinciden.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Si el valor de la expresión coincide con el valor de la primera constante (<Constante1>), se
ejecutan las instrucciones (<instrucciones1>) que están programadas directamente después
de la primera constante. Luego, el procesamiento del programa continúa después de
END_CASE.
Si el valor de la expresión no coindice con el valor de la primera constante (<Constante1), este
se compara con el valor de la constante que está programada a continuación. De esta manera
la instrucción CASE se ejecuta hasta que coincidan los valores. Si el valor de la expresión no
se corresponde con ninguno de los valores programados de las constantes, se ejecutan las
instrucciones (<instrucciones0>) que están programadas después de ELSE. ELSE es una
parte opcional de la sintaxis y se puede omitir.

1958

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucción CASE también se puede anidar sustituyendo un bloque de instrucciones por
CASE. END_CASE cierra la instrucción CASE.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
CASE "Tag_Value" OF
0 :
"Tag_1" :=
1,3,5 :
"Tag_2" :=
6..10 :
"Tag_3" :=
16,17,20..25 :
"Tag_4" :=
ELSE
"Tag_5" :=
END_CASE;

1;
1;
1;
1;
1;

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valores

Tag_Value

0

1, 3 , 5

6, 7, 8, 9, 10

16,17, 20, 21,
22, 23, 24, 25

2

Tag_1

1

-

-

-

-

Tag_2

-

1

-

-

-

Tag_3

-

-

1

-

-

Tag_4

-

-

-

1

-

Tag_5

-

-

-

-

1

1: El operando se pone al estado lógico "1".
-: El estado lógico del operando permanece sin cambios.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

FOR: Ejecutar en bucle contador
Descripción
La instrucción "Ejecutar en bucle contador" permite procesar un bucle mientras la variable de
contaje se encuentre dentro del rango de valores indicado.
Los bucles también se pueden anidar. Dentro de un bucle se pueden programar otros bucles
con otras variables de contaje.

Programación del PLC
Manual de programación y manejo, 11/2019

1959

Instrucciones
4.1 Instrucciones
La ejecución actual de un bucle se puede finalizar con la instrucción "Verificar condición de
bucle" (CONTINUE). La instrucción "Abandonar el bucle inmediatamente" (EXIT) permite
finalizar el procesamiento de todo el bucle. Encontrará más información al respecto en
"Consulte también".
Nota
Información sobre el número de ejecuciones y sobre la variable de control
El número de ejecuciones no puede modificarse durante la ejecución del programa.
Por motivos de rendimiento, la variable de control debe declararse en la sección "Temp" de la
interfaz del bloque. Tampoco es posible modificar la variable de control desde el propio bucle.
El ejemplo siguiente tendría pues un error de sintaxis, por lo que no se podría compilar:
FOR #i := 1 TO 10 DO
#i := #i + 1;
END_FOR;

Valores límite para instrucciones FOR
Para programar instrucciones FOR "seguras" que no se ejecuten de manera infinita, tenga en
cuenta las siguientes reglas y los siguientes valores límite:
FOR <variable de contaje> := <valor inicial> TO <valor final> BY <incremento> DO
<instrucciones>;
END_FOR;
Si...

... entonces

Observación

Valor inicial < valor final

Valor final < (PMAX - paso)

La variable de contaje cuenta en
sentido positivo

Valor inicial > valor final AND in‐ Valor final > (NMAX - paso)
cremento < O

La variable de contaje cuenta en
sentido negativo

Nota
Uso de tipo de datos y sentido de ejecución
No está permitido combinar enteros con y sin signo en una instrucción FOR.
En caso de utilizar enteros sin signo tampoco es posible programar un bucle en sentido
negativo.
Valores límite
Para los tipos de datos posibles son válidos diferentes valores límite:
Tipo de datos

PMAX

Variable de contaje del tipo SINT 127
Variable de contaje del tipo INT

32767

Variable de contaje del tipo DINT 2147483647

1960

NMAX
-128
-32768
-2147483648

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tipo de datos

PMAX

NMAX

Variable de contaje del tipo LINT 9223372036854775807

-9223372036854775808

Variable de recuento del tipo
USINT

255

-

Variable de recuento del tipo
UINT

65535

-

Variable de recuento del tipo
UDINT

4294967295

-

Variable de recuento del tipo
ULINT

18446744073709551615

-

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Tipo de datos
S7-1200

S7-1500

Área de me‐
moria

Descripción

<Variable
SINT, INT,
de contaje> DINT,
USINT,
UINT, UDINT

SINT, INT,
DINT, LINT,
USINT, UINT,
UDINT, ULINT

I, Q, M, D, L

Operando, cuyo valor se evalúa du‐
rante el procesamiento del bucle. El
tipo de datos de la variable de contaje
determina el tipo de datos de los pa‐
rámetros restantes.

<Valor ini‐
cial>

SINT, INT,
DINT,
USINT,
UINT, UDINT

SINT, INT,
DINT, LINT,
USINT, UINT,
UDINT, ULINT

I, Q, M, D, L

Expresión, cuyo valor se asigna a la
variable de contaje al comienzo del
procesamiento del bucle.

<Valor fi‐
nal>

SINT, INT,
DINT,
USINT,
UINT, UDINT

SINT, INT,
DINT, LINT,
USINT, UINT,
UDINT, ULINT

I, Q, M, D, L

Expresión, cuyo valor determina la úl‐
tima ejecución del bucle. Antes de ca‐
da ejecución del bucle se comprueba
qué valor tiene la variable de contaje:
● Valor final no alcanzado:
Se ejecutarán las instrucciones
según DO
● Valor final alcanzado:
El bucle FOR se ejecuta por última
vez
● Valor final sobrepasado:
El bucle FOR finaliza
No se puede modificar el valor final
durante la ejecución de la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

1961

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de datos
S7-1200

<Incremen‐ SINT, INT,
to>
DINT,
USINT,
UINT, UDINT

S7-1500
SINT, INT,
DINT, LINT,
USINT, UINT,
UDINT, ULINT

Área de me‐
moria

Descripción

I, Q, M, D, L

Expresión, en cuyo valor aumenta (in‐
cremento positivo) o disminuye (incre‐
mento negativo) la variable de contaje
después de cada ejecución del bucle.
La indicación del incremento es opcio‐
nal. Si no se ha indicado ningún incre‐
mento, el valor de la variable de con‐
taje aumenta en 1 después de cada
ejecución del bucle.
No se puede modificar el incremento
durante la ejecución de la instrucción.

<Instruccio‐ nes>

-

Instrucciones que se ejecutan durante
cada ejecución del bucle mientras el
valor de la variable de control se en‐
cuentre en el rango de valores. El ran‐
go de valores se especifica mediante
los valores inicial y final.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
FOR i := 2 TO 8 BY 2
DO "a_array[i] := "Tag_Value"*"b_array[i]";
END_FOR;

El operando "Tag_Value" se multiplica por los elementos (2, 4, 6, 8) de las variables ARRAY
"b_array". El resultado se lee en los elementos (2, 4, 6, 8) de las variables ARRAY "a_array".

Consulte también
CONTINUE: Verificar condición de bucle (Página 1965)
EXIT: Abandonar el bucle inmediatamente (Página 1966)
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

WHILE: Ejecutar cuando se cumpla la condición
Descripción
La instrucción "Ejecutar cuando se cumpla la condición" permite procesar un bucle mientras se
cumpla una condición de ejecución. La condición es una expresión con un valor booleano
(TRUE o FALSE). Como condición se pueden indicar expresiones lógicas o expresiones de
comparación.

1962

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Al ejecutar la instrucción, se evalúan las expresiones indicadas. Si el valor de una expresión
es TRUE, la condición se considera cumplida; en el caso de FALSE se considera que la
condición no se cumple.
Los bucles también se pueden anidar. Dentro de un bucle se pueden programar otros bucles
con otras variables de contaje.
La ejecución actual de un bucle se puede finalizar con la instrucción "Verificar condición de
bucle" (CONTINUE). La instrucción "Abandonar el bucle inmediatamente" (EXIT) permite
finalizar el procesamiento de todo el bucle. Encontrará más información al respecto en
"Consulte también".
La instrucción se puede declarar del siguiente modo:
WHILE <condición> DO <instrucciones>;
END_WHILE;

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Tipo de datos Área de memoria

Descripción

<Condición>

BOOL

Expresión que se evalúa antes de cada ejecución
del bucle.

<Instruccio‐
nes>

-

I, Q, M, D, L

Instrucciones que se ejecutan si se cumple la con‐
dición. Si no se cumple la condición, el procesa‐
miento del programa continúa después de
END_WHILE.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
WHILE
"Tag_Value1" <> "Tag_Value2"
DO "Tag_Result"
:= "Tag_Input";
END_WHILE:

Mientras difieran los valores de los operandos "Tag_Value1" y "Tag_Value2", al operando
"Tag_Result" se le asignará el valor del operando "Tag_Input".

Consulte también
EXIT: Abandonar el bucle inmediatamente (Página 1966)
CONTINUE: Verificar condición de bucle (Página 1965)
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1963

Instrucciones
4.1 Instrucciones

REPEAT: Ejecutar cuando no se cumpla la condición
Descripción
La instrucción "Ejecutar cuando no se cumpla la condición" permite procesar un bucle mientras
no se cumpla una condición de interrupción. La condición es una expresión con un valor
booleano (TRUE o FALSE). Como condición se pueden indicar expresiones lógicas o
expresiones de comparación.
Al ejecutar la instrucción, se evalúan las expresiones indicadas. Si el valor de una expresión
es TRUE, la condición se considera cumplida; en el caso de FALSE se considera que la
condición no se cumple.
Las instrucciones se ejecutan una vez aunque se cumpla la condición de interrupción.
Los bucles también se pueden anidar. Dentro de un bucle se pueden programar otros bucles
con otras variables de contaje.
La ejecución actual de un bucle se puede finalizar con la instrucción "Verificar condición de
bucle" (CONTINUE). La instrucción "Abandonar el bucle inmediatamente" (EXIT) permite
finalizar el procesamiento de todo el bucle. Encontrará más información al respecto en
"Consulte también".
La instrucción se puede declarar del siguiente modo:
REPEAT <instrucciones>;
UNTIL <condición> END_REPEAT;

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Tipo de datos Área de memoria

Descripción

<Instruccio‐
nes>

-

Instrucciones que se ejecutan mientras la condi‐
ción programada tenga el valor FALSE. Las ins‐
trucciones se ejecutan una vez aunque se cumpla
la condición de interrupción.

<Condición>

BOOL

I, Q, M, D, L

Expresión que se evalúa después de cada ejecu‐
ción del bucle. Si la expresión tiene el valor FAL‐
SE, el bucle se procesa de nuevo. Si la expresión
tiene el valor TRUE, el procesamiento del progra‐
ma continúa después de END_REPEAT.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
REPEAT "Tag_Result"
:= "Tag_Value";
UNTIL "Tag_Error"
END_REPEAT;

1964

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Mientras el valor del operando "Tag_Error" tenga el estado lógico "0", se le asignará al
operando "Tag_Result" el valor del operando "Tag_Value".

Consulte también
CONTINUE: Verificar condición de bucle (Página 1965)
EXIT: Abandonar el bucle inmediatamente (Página 1966)
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

CONTINUE: Verificar condición de bucle
Descripción
La instrucción "Verificar condición de bucle" permite finalizar la ejecución actual de un bucle
FOR, WHILE o REPEAT.
Después de ejecutar la instrucción, se evalúan de nuevo las condiciones para continuar el
bucle. La instrucción tiene efecto sobre el bucle que incluye directamente la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
FOR i
:= 1 TO 15 BY 2 DO
IF (i < 5) THEN
CONTINUE;
END_IF;
"DB10".Test[i] := 1;
END_FOR;

Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Si se cumple la condición i < 5, no se ejecuta la siguiente asignación de valor
("DB10".Test[i] :=1). La variable de contaje (i) se incrementa en "2" y se comprueba si su valor
actual se encuentra en el rango de valores programados. Si la variable de contaje se encuentra
en el rango de valores, se evalúa de nuevo una condición IF.
Si no se cumple la condición i < 5, se ejecuta la siguiente asignación de valor ("DB10".Test[i] :=
1) y se inicia una nueva ejecución del bucle. La variable de control también se aumenta con el
incremento "2" y se comprueba.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1965

Instrucciones
4.1 Instrucciones

EXIT: Abandonar el bucle inmediatamente
Descripción
La instrucción "Abandonar el bucle inmediatamente" permite interrumpir en cualquier punto la
ejecución de un bucle FOR, WHILE o REPEAT independientemente de las condiciones. El
procesamiento del programa continúa después finalizar el bucle (END_FOR, END_WHILE,
END_REPEAT).
La instrucción tiene efecto sobre el bucle que incluye directamente la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
FOR i := 15 TO 1 BY -2 DO
IF (i < 5)
THEN EXIT;
END_IF;
"DB10".Test[i] := 1;
END_FOR;

Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Si se cumple la condición i < 5, se interrumpe el procesamiento del bucle. El procesamiento
continúa después de END_FOR.
Si no se cumple la condición i < 5, se ejecuta la siguiente asignación de valor
("DB10".Test[i] :=1) y se inicia una nueva ejecución del bucle. La variable de contaje (i) se
decrementa en "-2" y se comprueba si su valor actual se encuentra en el rango de valores
programados. Si la variable de control (i) se encuentra en el rango de valores, la condición IF
se evalúa de nuevo.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

GOTO: Saltar
Descripción
La instrucción "Saltar" permite continuar el procesamiento del programa en un punto marcado
con una etiqueta.
La etiqueta y la instrucción "Saltar" deben estar en el mismo bloque. La denominación de la
etiqueta debe ser unívoca en un bloque. A toda etiqueta pueden acceder distintas
instrucciones de salto.
No se permite saltar a un bucle desde "fuera", pero sí es posible saltar desde un bucle hacia
"fuera".

1966

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para la etiqueta deben observarse las siguientes reglas gramaticales:
● Letras (a - z, A - Z)
● Una combinación de letras y números. Es importante observar el orden, es decir, primero
las letras y después los números (a - z, A - Z, 0 - 9).
● No pueden utilizarse caracteres especiales o una combinación de letras y números en
orden inverso, es decir, primero los números y después las letras (0 - 9, a - z, A - Z).
La instrucción se puede declarar del siguiente modo:
GOTO <Etiqueta>;
...
<Etiqueta>: <Instrucciones>

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Tipo de datos

Descripción

<Etiqueta>

-

Etiqueta a la que se salta

<Instrucciones>

-

Instrucciones que se ejecutan después del salto.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
CASE "Tag_Value" OF
1 : GOTO MyLABEL1;
2 : GOTO MyLABEL2;
3 : GOTO MyLABEL3;
ELSE GOTO MyLABEL4;
END_CASE;
MyLABEL1: "Tag_1" := 1;
MyLABEL2: "Tag_2" := 1;
MyLABEL3: "Tag_3" := 1;
MyLABEL4: "Tag_4" := 1;

Dependiendo del valor del operando "Tag_Value", el procesamiento del programa se continúa
en el punto marcado por la etiqueta correspondiente. Por ejemplo, si el operando "Tag_Value"
tiene el valor "2", el procesamiento del programa continúa a partir de la etiqueta "MyLABEL2".
En este caso, la línea del programa marcada con la etiqueta "MyLABEL1" se omite.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

1967

Instrucciones
4.1 Instrucciones

RETURN: Abandonar el bloque
Descripción
La instrucción "Abandonar el bloque" permite finalizar el procesamiento del programa en el
bloque que se está ejecutando y continuar en el bloque invocante.
En el fin del bloque se puede omitir la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
IF "Tag_Error" <>0 THEN RETURN;
END_IF;

Si el estado lógico del operando "Tag_Error" no es igual a cero, el procesamiento del programa
se finaliza en el bloque que se está procesando.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

(*...*): Insertar sección de comentario
Descripción
La instrucción "Insertar sección de comentario" permite insertar una sección de comentario. El
texto encerrado entre paréntesis (*...*) se trata como un comentario.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
(*Esta es una sección de comentario.*)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

1968

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

(/*...*/): Insertar comentario multilingüe
Descripción
Con la instrucción "Insertar comentario multilingüe" se inserta un comentario que puede
traducirse a otros idiomas del proyecto. Un comentario multilingüe se inicia con "(/*" y se cierra
con "*/)", lo que lo convierte en una unidad. Esto significa que, en cualquier caso, solo se puede
marcar o seleccionar el comentario entero y no partes por separado. Los comentarios
multilingües no pueden anidarse unos dentro de otros, pero pueden utilizarse dentro de
comentarios de líneas y secciones de comentarios. A diferencia de ello, no es posible emplear
comentarios de líneas o secciones de comentarios sencillas dentro de comentarios
multilingües, ya que todo lo incluido entre "(/*" y "*/)" se interpreta como texto normal.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
(/*Este es un comentario que puede traducirse a otros idiomas del
proyecto.*/)

Consulte también
Inserción de comentarios (Página 8179)

REGION: Estructurar el código del programa
Descripción
La instrucción "Estructurar el código del programa" permite estructurar el código del programa
en un bloque SCL dividiéndolo en diferentes áreas.
Encontrará más información sobre cómo trabajar con áreas aquí: Trabajar con áreas
(Página 8153)
La instrucción se puede declarar del siguiente modo:
REGION <Nombre>
<Instrucciones>
END_REGION

Programación del PLC
Manual de programación y manejo, 11/2019

1969

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Tipo de datos

Área de memoria

Descripción

REGION

-

-

Palabra clave con la
que empieza el área

<Nombre>

-

-

Texto que designa RE‐
GION

<Instrucciones>

-

-

Código de programa
que comprende RE‐
GION

END_REGION

-

-

Palabra clave con la
que finaliza el área

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
REGION Feeder System
// Estructura el código fuente para el sistema de alimentación
IF "Variable_1" = 0 THEN
"Variable_2" := 10;
END_IF;
END_REGION

El área Feeder System abarca el código del programa completo.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Control del tiempo de ejecución
ENDIS_PW: Limitar y habilitar legitimación de la contraseña
Descripción
La instrucción "Limitar y habilitar legitimación de la contraseña" permite definir si las
contraseñas configuradas para la CPU están legitimadas o no. Con ello, se pueden impedir
conexiones legitimadas, aun conociendo la contraseña correcta.
Si se llama la instrucción y el parámetro REQ tiene el estado lógico "0", en los parámetros de
salida se muestra el estado ajustado en ese momento. Si se han realizado cambios en los
parámetros de entrada, estos no se transfieren a los parámetros de salida.

1970

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si se ejecuta la instrucción y el parámetro REQ tiene el estado lógico "1", se aplica el estado
lógico de los parámetros de entrada (F_PWD, FULL_PWD, R_PWD, HMI_PWD):
● Con el estado lógico "0", no está permitida la legitimación por contraseña.
● Con el estado lógico "1" se puede utilizar la contraseña.
Es posible permitir o prohibir individualmente el bloqueo o la habilitación de las contraseñas.
Por ejemplo, pueden prohibirse todas las contraseñas excepto la contraseña de seguridad
positiva. Esto permite limitar las posibilidades de acceso a un reducido grupo de usuarios. Los
parámetros de salida (F_PWD_ON, FULL_PWD_ON, R_PWD_ON, HMI_PWD_ON) siempre
muestran el estado actual del uso de contraseñas, independientemente del parámetro REQ.
Las contraseñas no configuradas deben tener el estado lógico TRUE en la entrada y devolver
el estado lógico TRUE en la salida. La contraseña de seguridad solo puede parametrizarse
para una CPU F y por eso en una CPU estándar debe interconectarse siempre con el estado
lógico TRUE. Si la instrucción devuelve un error, la llamada permanece sin efecto, es decir, el
bloqueo anterior sigue en vigor.
Las contraseñas bloqueadas pueden volver a habilitarse en las condiciones siguientes:
● Se ha restablecido la configuración de fábrica de la CPU.
● El panel frontal de la CPU S7-1500 soporta un cuadro de diálogo que permite navegar al
menú adecuado y volver a habilitar las contraseñas.
● Cuando se llama la instrucción "Limitar y habilitar legitimación de la contraseña", el
parámetro de entrada de la contraseña deseada tiene el estado lógico "1".
● Ponga el selector de modo a STOP. La restricción de la legitimación de contraseña se
activa de nuevo en cuanto se mueve el selector nuevamente a RUN.
● La inserción de una tarjeta de memoria vacía (tarjeta de transferencia o tarjeta de
programa) en una CPU S7-1200.
● La transición de POWER OFF-POWER ON desactiva la protección en la CPU S7-1200. La
instrucción "Limitar y habilitar legitimación de la contraseña" debe volverse a llamar en el
programa (por ejemplo en el OB de arranque).
Nota
Si la contraseña HMI no está habilitada, la instrucción "Limitar y habilitar legitimación de la
contraseña" bloquea el acceso de los sistemas HMI.
Nota
Las conexiones ya existentes y legitimadas conservan sus derechos de acceso y no pueden
limitarse con la instrucción "Limitar y habilitar legitimación de la contraseña".

Impedir el bloqueo no intencionado en una CPU S7-1500
Los ajustes pueden realizarse en el panel frontal de la CPU, que guarda el último ajuste en
cada caso.
Para impedir un bloqueo no intencionado, en una CPU S7-1500 es posible desactivar la
protección moviendo el selector de modo a STOP. La protección se activa automáticamente
después de mover el selector de modo a RUN sin que tenga que volver a llamarse la
Programación del PLC
Manual de programación y manejo, 11/2019

1971

Instrucciones
4.1 Instrucciones
instrucción "Limitar y habilitar legitimación de la contraseña" o deban realizarse otras acciones
en el panel frontal.

Impedir el bloqueo no intencionado en una CPU S7-1200
Como la CPU S7-1200 no dispone de selector de modo, la protección se desactiva con
POWER OFF-POWER ON. De este modo es posible y recomendable impedir el bloqueo no
intencionado con ayuda de determinadas secuencias en el programa.
Para ello, programe un control de tiempo, ya sea mediante un OB de alarma cíclica o un
temporizador en el Main OB (OB 1). De este modo, tras una transición de POWER OFFPOWER ON y la consiguiente desactivación de la protección, se puede volver a llamar
rápidamente la instrucción "Limitar y habilitar legitimación de la contraseña" en el OB
correspondiente (por ejemplo OB 1 u OB 35). Para que la ventana temporal en la que la
instrucción no está activa y en la que por tanto no existen limitaciones en la legitimación de la
contraseña sea lo más pequeña posible, llame la instrucción en el OB de arranque (OB 100).
Este procedimiento ofrece la mayor protección posible contra accesos no autorizados.
Si se ha producido un bloqueo no intencionado, puede omitirse la llamada en el OB de
arranque (por ejemplo mediante consulta de un parámetro de entrada) y se dispondrá del
tiempo configurado (por ejemplo de 10 segundos a 1 minuto) para establecer una conexión con
la CPU antes de que el bloqueo vuelva a activarse.
Si no se ha previsto ningún temporizador en el código del programa y se produce un bloqueo,
inserte en la CPU una tarjeta de transferencia o una tarjeta de programa vacía. La tarjeta de
transferencia o la tarjeta de programa vacía borra la memoria de carga interna de la CPU.
Después deberá cargarse nuevamente el programa de usuario de STEP 7 en la CPU.

Procedimiento en caso de pérdida de contraseña en una CPU S7-1200
Si ha perdido la contraseña de una CPU S7-1200 protegida por contraseña, borre el programa
protegido por contraseña con una tarjeta de transferencia o una tarjeta de programa vacía. La
tarjeta de transferencia o la tarjeta de programa vacía borra la memoria de carga interna de la
CPU. A continuación, puede transferir un nuevo programa de usuario de STEP 7 Basic a la
CPU.
ADVERTENCIA
Inserción de una tarjeta de transferencia vacía
Cuando se inserta una tarjeta de transferencia en una CPU en funcionamiento, la CPU pasa
a STOP. En caso de estados operativos no seguros, los controladores pueden fallar y, con
ello, provocar un funcionamiento descontrolado de los dispositivos que se controlan. El
resultado es un funcionamiento impredecible del sistema de automatización, que puede
provocar lesiones mortales o graves, así como daños materiales.
El contenido de la tarjeta de transferencia se encuentra en la memoria de carga interna
después de su extracción. Compruebe aquí que la tarjeta no contenga ningún programa.

1972

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
ADVERTENCIA
Inserción de una tarjeta de programa vacía
Cuando se inserta una tarjeta de programa en una CPU en funcionamiento, la CPU pasa a
STOP. En caso de estados operativos no seguros, los controladores pueden fallar y, con ello,
provocar un funcionamiento descontrolado de los dispositivos que se controlan. El resultado
es un funcionamiento impredecible del sistema de automatización, que puede provocar
lesiones mortales o graves, así como daños materiales.
Asegúrese de que la tarjeta de programa esté vacía. La memoria de carga interna se copiará
en la tarjeta de programa vacía. Después de retirar la tarjeta de programa previamente vacía,
la memoria de carga interna quedará vacía.
Debe retirarse la tarjeta de transferencia o la tarjeta de programa antes de poner la CPU en
RUN.

Efectos del uso de contraseñas en los modos de operación
La siguiente tabla muestra qué efectos tiene el uso de contraseñas en los modos de operación
y en las respectivas acciones del usuario mediante la instrucción "Limitar y habilitar
legitimación de la contraseña".
Acción

Protección por contraseña mediante la instruc‐
ción

Estado básico después de

No activado

● Selector de modo en STOP

(sin limitaciones)

● Restablecimiento manual de la memoria (PG,
interruptor, cambio de MC (Motion Control))
● Restablecimiento de la configuración de fábrica
Estado básico tras conexión (POWER ON)

● CPU S7-1200:
El bloqueo está desactivado y la
instrucción tiene que volverse a ejecutar
en el programa (por ejemplo en el OB de
arranque).
● CPU S7-1500:
Activada (si antes de la desconexión
(POWER OFF) había un bloqueo activo)
La posibilidad de no permitir contraseñas
es remanente.

Activado
Transición del estado operativo RUN/ARRANQUE/
PARADA -> STOP (mediante finalización de la ins‐
Las contraseñas siguen sin poder utilizarse.
trucción, un error o comunicación) o STOP -> ARRAN‐
QUE/RUN/PARADA

Programación del PLC
Manual de programación y manejo, 11/2019

1973

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o
constante

Si el parámetro REQ tiene el
estado lógico "0", se consulta
el estado lógico ajustado ac‐
tualmente para las contrase‐
ñas.

F_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura/escritura
incluido failsafe
● F_PWD = "0": No permitir
contraseña
● F_PWD = "1": Permitir
contraseña

FULL_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura/escritura
● FULL_PWD = "0": No
permitir contraseña
● FULL_PWD = "1":
Permitir contraseña

R_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura
● R_PWD = "0": No permitir
contraseña
● R_PWD = "1": Permitir
contraseña

HMI_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso a la HMI
● HMI_PWD = "0": No
permitir contraseña
● HMI_PWD = "1": Permitir
contraseña

F_PWD_ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura/
escritura incluido failsafe
● F_PWD_ON = "0":
Contraseña no permitida
● F_PWD_ON = "1":
Contraseña permitida

FULL_PWD_
ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura/
escritura
● FULL_PWD_ON = "0":
Contraseña no permitida
● FULL_PWD_ON = "1":
Contraseña permitida

R_PWD_ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura
● R_PWD_ON = "0":
Contraseña no permitida
● R_PWD_ON = "1":
Contraseña permitida

1974

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

HMI_PWD_O Output
N

Tipo de datos

Área de memoria

Descripción

BOOL

I, Q, M, D, L

Estado del acceso a la HMI
● HMI_PWD_ON = "0":
Contraseña no permitida
● HMI_PWD_ON = "1":
Contraseña permitida

Valor de función (RET_VAL)

WORD

I, Q, M, D, L

Información de error

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

8090

No se soporta la instrucción "Limitar y habilitar legitimación de la contraseña".

80D0

La contraseña de seguridad no está configurada. En las CPU estándar, el estado lógico
tiene que ser TRUE.

80D1

El acceso de lectura/escritura no está configurado

80D2

El acceso de lectura no está configurado

80D3

El acceso HMI no está configurado

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := ENDIS_PW(REQ := 0,
F_PWD := 0,
FULL_PWD := 0,
R_PWD := 1,
HMI_PWD := 0,
F_PWD_ON => "Status_F_PWD",
FULL_PWD_ON => "Status_FULL_PWD",
R_PWD_ON => "Status_R_PWD",
HMI_PWD_ON => "Status_HMI_PWD");

Programación del PLC
Manual de programación y manejo, 11/2019

1975

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Tipo de datos

Valor

REQ

BOOL

0

F_PWD

BOOL

0

FULL_PWD

BOOL

0

R_PWD

BOOL

1

HMI_PWD

BOOL

0

Status_F_PWD

BOOL

0

Status_FULL_PWD

BOOL

0

Status_R_PWD

BOOL

1

Status_HMI_PWD

BOOL

0

La instrucción se ejecuta ya que el operando REQ tiene el estado lógico "1". El operando
R_PWD tiene el estado lógico "1", lo que significa que al introducir la contraseña asignada se
otorga acceso de lectura. El operando de estado R_PWD_ON también tiene el estado lógico
"1", lo que indica que el operando R_PWD está activado.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de SCL (Página 8115)

Sistemas de PC
SHUT_DOWN: Apagar sistema de destino
Descripción
Con la instrucción "SHUT_DOWN: Apagar sistema de destino" se apaga el sistema de
automatización basado en PC y se rearranca el controlador por software S7 CPU 150xS o
Windows en el sistema de automatización basado en PC.
Encontrará la instrucción en la Task Card "Instrucciones", sección Instrucciones básicas >
Control del programa > Control del tiempo de ejecución.
Un reinicio puede ser útil en las situaciones siguientes, p. ej.:
● Un SAI industrial (sistema de alimentación ininterrumpida) notifica un fallo de tensión
mediante una entrada digital.
● Windows no responde o presenta una "pantalla azul".
● En el programa de usuario se llaman demasiados OB de error.

1976

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Apagar sistema de destino":
Parámetro

Declaración

Tipo de
datos

Área de memoria

Descripción

MODE

Input

UINT

I, Q, M, D, L o constan‐ MODE = 1: apagar CPU 150xS y Windows
te
La CPU pasa a STOP y guarda los datos remanentes. Se‐
guidamente se apagan la CPU y Windows. El sistema debe
rearrancarse manualmente.
MODE = 2: rearrancar CPU 150xS
La CPU pasa a STOP y guarda los datos remanentes. A
continuación la CPU se apaga y se reinicia.
MODE = 3: Reiniciar Windows. La CPU permanece en RUN.
Windows se reinicia (desde TIA Portal V14, el MODE 3 solo
está autorizado en caso de compatibilidad descendente. Se
recomienda usar MODE 4 o MODE 5).
MODE = 4: Windows se apaga correctamente y se reinicia.
La CPU permanece en RUN.
MODE = 5: Reiniciar Windows. (comparable al MODE 3;
excepción: MODE 5 solo debe usarse si se ha caído Win‐
dows).

COM‐
MENT

Input

STRING

I, Q, M, D, L

Con Mode = 1, 3 y 4 es posible indicar el motivo del reinicio.
El motivo se mostrará en el registro de eventos de Windows.

Ret_Val

Return

WORD

Q, M, D, L

Ret_Val = 0: ningún error
Ret_Val = 8090: el valor transferido a MODE no se soporta.
Ret_Val = 8091: Windows no responde a la llamada de la
instrucción Shut_Down (solo válido para Mode 3 y 4).
Ret_Val = 8092: Si aparece este error diríjase al SIMATIC
Customer Support (solo válido para Mode 3 y 4).

RE_TRIGR: Reiniciar tiempo de vigilancia del ciclo
Descripción
La instrucción "Reiniciar tiempo de vigilancia del ciclo" reinicia el tiempo de vigilancia del ciclo
de la CPU. El tiempo de vigilancia del ciclo se reinicia entonces con la duración ajustada en la
configuración de la CPU.
La instrucción se ejecuta correctamente durante un intervalo de tiempo (10 veces el ciclo
máximo del programa), independientemente del número de llamadas. Transcurrido ese
tiempo, el ciclo del programa ya no puede prolongarse.

Programación del PLC
Manual de programación y manejo, 11/2019

1977

Instrucciones
4.1 Instrucciones

Llamada de la instrucción
Se aplican las siguientes condiciones de llamada:
● En las CPU de la serie S7-1200:
En las versiones de firmware < 2.2 solo es posible llamar la instrucción en un bloque de
organización cíclico de la prioridad 1. Equivale a la prioridad más baja de todos los bloques
de organización. Si la instrucción se llama desde un bloque de organización de prioridad
superior, no se ejecuta y el resultado (bit BR, salida de habilitación ENO) es siempre "0".
En las versiones de firmware >= 2.2 puede llamarse la instrucción en todos los bloques de
organización, independientemente de la prioridad.
● En las CPU de la serie S7-1500:
La instrucción puede llamarse en todos los bloques de organización, independientemente
de la prioridad.

Parámetro
La instrucción "Reiniciar tiempo de vigilancia del ciclo" no tiene parámetros y no devuelve
información de error.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

STP: Finalizar programa
Descripción
La instrucción "Finalizar programa" conmuta la CPU al estado operativo STOP, con lo que se
finaliza la ejecución del programa. Los efectos al conmutar de RUN a STOP dependen de la
configuración de la CPU.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

GET_ERROR: Consultar error localmente
Descripción
La instrucción "Consultar error localmente" consulta si se han producido errores en un bloque
de programa. Suele tratarse de un error de programación o de acceso. Si el sistema notifica
errores durante la ejecución del bloque de programa, en el operando <Operando> se guarda
información detallada acerca del primer error de ejecución del bloque de probrama ocurrido
desde la última vez que se ejecutó la instrucción.

1978

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La información relativa al error solo se puede guardar en operandos del tipo de datos de
sistema "ErrorStruct". El tipo de datos de sistema "ErrorStruct" especifica la estructura exacta
con la que debe guardarse la información acerca del error que ha ocurrido. Con ayuda de otras
instrucciones se puede evaluar esta estructura y programar la reacción correspondiente. Si se
producen varios errores en el bloque de programa, la instrucción devolverá información sobre
el siguiente error ocurrido solo tras haberse solucionado el primer error.
Nota
<Operando>
El <operando> solo se modifica si hay una información de error. Para volver a poner el
operando a "0" tras tratar un error existen las siguientes posibilidades:
● Declare el operando en la sección "Temp" de la interfaz de bloque.
● Ponga el operando de nuevo a "0" antes de llamar la instrucción.
Nota
Activación del tratamiento local de errores
En cuanto se inserta la instrucción en el código de un bloque de programa, se activa el
tratamiento local de errores y se ignoran las reacciones preajustadas del sistema cuando se
producen errores.

Posibilidades del tratamiento de errores
Este apartado ofrece una visión general de las posibilidades del tratamiento de
errores: Sinopsis de los mecanismos para el tratamiento de errores (Página 149)
Encontrará un ejemplo detallado del tratamiento local de errores que ofrece varias opciones de
tratamiento aquí: Ejemplo de tratamiento de errores de ejecución del programa (Página 180)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Tipo de datos Área de memoria

Descripción

<Operando>

ErrorStruct

Información sobre los errores ocurridos

D, L

Tipo de datos "ErrorStruct"
El tipo de datos "ErrorStruct" se puede insertar en un bloque de datos global o en la interfaz del
bloque. También se puede insertar el tipo de datos varias veces siempre que se asigne cada
vez un nombre distinto para la estructura de datos. La estructura de datos y el nombre de los
distintos elementos de la estructura no se pueden modificar. Si guarda la información del error
en un bloque de datos global, se podrá leer desde otro bloque de programa.

Programación del PLC
Manual de programación y manejo, 11/2019

1979

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra la estructura del tipo de datos "ErrorStruct":
Componente de estructura

Tipo de datos

Descripción

ERROR_ID

WORD

ID de error

FLAGS

BYTE

Muestra si el error se ha producido durante
la llamada de un bloque de programa.
16#01: error durante la llamada de un blo‐
que de programa
16#00: no hay errores durante la llamada
de un bloque de programa

REACTION

BYTE

Reacción predeterminada:
0: ignorar (error de escritura)
1: continuar con el valor sustitutivo "0"
(error de lectura)
2: omitir instrucción (error de sistema)

CODE_ADDRESS
BLOCK_TYPE

CREF

Información sobre la dirección y el tipo del
bloque de programa

BYTE

Tipo de bloque de programa en el que se
ha producido el error:
1: bloque de organización (OB)
2: función (FC)
3: bloque de función (FB)

CB_NUMBER

UINT

Número del bloque lógico

OFFSET

UDINT

Referencia a la memoria interna

MODE

BYTE

Información sobre la dirección de un ope‐
rando

OPERAND_NUMBER

UINT

Número de operando del comando de la
máquina

POINTER_NUMBER_LOCA‐
TION

UINT

(A) Puntero interno

SLOT_NUMBER_SCOPE

UINT

(B) Área de almacenamiento en la memo‐
ria interna

DATA_ADDRESS

NREF

Información sobre la dirección de un ope‐
rando

BYTE

(C) Área de memoria:

AREA

L: 16#40...16#7F, 16#86, 16#87, 16#8E,
16#8F, 16#C0...16#FF
I: 16#81
Q: 16#82
M: 16#83
DB: 16#40, 16#84, 16#85, 16#8A, 16#8B
PI: 16#01
PQ: 16#02
Objetos tecnológicos: 16#04

1980

DB_NUMBER

UINT

(D) Número del bloque de datos

OFFSET

UDINT

(E) Dirección relativa del operando

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Componente de estructura "ERROR_ID"
La tabla siguiente muestra los valores que pueden devolverse en el componente de estructura
"ERROR_ID":
ID*
(hexadecimal)

ID*
(decimal)

Descripción

0

0

Ningún error

2503

9475

Puntero no válido

2520

9504

STRING no válido

2522

9506

Error de lectura: operando fuera del rango válido

2523

9507

Error de escritura: operando fuera del rango válido

2524

9508

Error de lectura: operando no válido

2525

9509

Error de escritura: operando no válido

2528

9512

Error de lectura: alineación de datos

2529

9513

Error de escritura: alineación de datos

252C

9516

Puntero no válido

2530

9520

Error de escritura: Bloque de datos

2533

9523

Referencia usada no válida

2538

9528

Error de acceso: el DB no existe

2539

9529

Error de acceso: se ha utilizado un DB incorrecto

253A

9530

El bloque de datos global no existe

253C

9532

Indicación errónea o la función no existe

253D

9533

La función de sistema no existe

253E

9534

Indicación errónea o el bloque de función no existe

253F

9535

El bloque de sistema no existe

2550

9552

Error de acceso: el DB no existe

2551

9553

Error de acceso: se ha utilizado un DB incorrecto

2575

9589

Error en la profundidad de anidamiento del programa

2576

9590

Error en la distribución de datos locales

2577

9591

La propiedad de bloque "Alimentación de parámetros a través de
registros" no está activada.

25A0

9632

Error interno en TP

25A1

9633

Variable protegida contra escritura

25A2

9634

Valor numérico no válido de la variable

2942

10562

Error de lectura: entrada

2943

10563

Error de escritura: salida

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Programación del PLC
Manual de programación y manejo, 11/2019

1981

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
LABEL: #TagOut := #Field[#index] * REAL#40.5;
GET_ERROR(#Error);
IF #Error.REACTION = 1 THEN
GOTO LABEL;
;
END_IF;

Se ha producido un error al acceder a la variable #Field[#index]. A pesar del error de lectura y
acceso, el operando #TagOut devuelve el estado lógico "1" y la multiplicación se realiza con el
valor "0.0". Si se produce este error se recomienda programar la instrucción "Consultar error
localmente" tras la multiplicación para capturar el error. La información de error suministrada
por la instrucción "Consultar error localmente" se evalúa con una comparación. Si el
componente de estructura #Error.REACTION tiene el valor "1", se trata de un error de lectura/
acceso y la ejecución del programa comienza de nuevo en la etiqueta de salto LABEL.

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Uso de las instrucciones GET_ERROR y GET_ERR_ID (Página 178)
Principios básicos de SCL (Página 8115)

GET_ERR_ID: Consultar ID de error localmente
Descripción
La instrucción "Consultar ID de error localmente" consulta si se han producido errores en un
bloque. Suele tratarse de un error de acceso. Si al ejecutar el bloque el sistema notifica errores
de ejecución desde que se ejecutó la instrucción por última vez, la instrucción emite la ID del
primer error ocurrido.

1982

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La ID de error solo se puede guardar en operandos del tipo de datos WORD. Si se producen
varios errores en el bloque, la instrucción soluciona el primer error ocurrido, y solo entonces la
instrucción emite la ID de error del siguiente error ocurrido.
Nota
El <operando> solo se modifica si hay una información de error. Para volver a poner el
operando a "0" tras tratar un error existen las siguientes posibilidades:
● Declare el operando en la sección "Temp" de la interfaz de bloque.
● Ponga el operando de nuevo a "0" antes de llamar la instrucción.
La salida de la instrucción "Consultar ID de error localmente" se activa únicamente si existe
una información de error. Si no se cumple esta condición, el procesamiento ulterior del
programa no se ve afectado por la instrucción "Consultar ID de error localmente".
Encontrará un ejemplo sobre cómo utilizar la instrucción en combinación con otras
posibilidades de tratamiento de errores, en "Consulte también".
Nota
La instrucción "Consultar ID de error localmente" activa el tratamiento local de errores dentro
del bloque. Si en la lógica de un bloque se ha insertado la instrucción "Consultar ID de error
localmente", se ignoran las reacciones predeterminadas del sistema al ocurrir errores.

Posibilidades del tratamiento de errores
Este apartado ofrece una visión general de las posibilidades del tratamiento de
errores: Sinopsis de los mecanismos para el tratamiento de errores (Página 149)
Encontrará un ejemplo detallado del tratamiento local de errores que ofrece varias opciones de
tratamiento aquí: Ejemplo de tratamiento de errores de ejecución del programa (Página 180)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Tipo de datos Área de memoria

Descripción

Valor de fun‐
ción

WORD

ID de error

D, L

ID de error
La tabla siguiente muestra los valores que pueden devolverse:
ID*
(hexadecimal)

ID*
(decimal)

Descripción

0

0

Ningún error

2503

9475

Puntero no válido

2520

9504

STRING no válido

Programación del PLC
Manual de programación y manejo, 11/2019

1983

Instrucciones
4.1 Instrucciones
ID*
(hexadecimal)

ID*
(decimal)

Descripción

2522

9506

Error de lectura: operando fuera del rango válido

2523

9507

Error de escritura: operando fuera del rango válido

2524

9508

Error de lectura: operando no válido

2525

9509

Error de escritura: operando no válido

2528

9512

Error de lectura: alineación de datos

2529

9513

Error de escritura: alineación de datos

252C

9516

Puntero no válido

2530

9520

Error de escritura: Bloque de datos

2533

9523

Referencia usada no válida

2538

9528

Error de acceso: el DB no existe

2539

9529

Error de acceso: se ha utilizado un DB incorrecto

253A

9530

El bloque de datos global no existe

253C

9532

Indicación errónea o la función no existe

253D

9533

La función de sistema no existe

253E

9534

Indicación errónea o el bloque de función no existe

253F

9535

El bloque de sistema no existe

2550

9552

Error de acceso: el DB no existe

2551

9553

Error de acceso: se ha utilizado un DB incorrecto

2575

9589

Error en la profundidad de anidamiento del programa

2576

9590

Error en la distribución de datos locales

2577

9591

La propiedad de bloque "Alimentación de parámetros a través de
registros" no está activada.

25A0

9632

Error interno en TP

25A1

9633

Variable protegida contra escritura

25A2

9634

Valor numérico no válido de la variable

2942

10562

Error de lectura: entrada

2943

10563

Error de escritura: salida

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
#TagOut := #Field[#index] * REAL#40.5;
#TagID := GET_ERR_ID();
IF #TagID = 16#2522 THEN
MOVE_BLK(IN := #TagArrayIn[0],
COUNT := 1,

1984

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
OUT => #TagArrayOut[1]);
END_IF;

Se ha producido un error al acceder a la variable #Field[#index]. A pesar del error de lectura y
acceso, el operando #TagOut devuelve el estado lógico "1" y la multiplicación se realiza con el
valor "0.0". Si se produce este error se recomienda programar la instrucción "Consultar ID de
error localmente" tras la multiplicación para capturar el error. La ID de error suministrada por
la instrucción "Consultar ID de error localmente" se evalúa con una comparación. Si el
operando #TagID devuelve la ID 16#2522, se trata de un error de lectura/acceso y el valor
"100.0" del operando #TagArrayIn[0] se copia en el operando #TagArrayOut[1].

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Uso de las instrucciones GET_ERROR y GET_ERR_ID (Página 178)
Principios básicos de SCL (Página 8115)

INIT_RD: Inicializar todos los datos remanentes
Descripción
La instrucción "Inicializar todos los datos remanentes" permite inicializar todos los datos
remanentes de todos los bloques de datos, marcas y temporizadores y contadores SIMATIC
al mismo tiempo. La instrucción solo puede ejecutarse dentro de un OB de arranque, puesto
que su ejecución excedería el tiempo de ciclo de programa.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

BOOL

I, Q, M, D, L

Si la entrada REQ devuelve
el estado lógico "1", se inicia‐
lizan todos los datos rema‐
nentes.

INT

I, Q, M, D, L

Información de error:

Valor de función (RET_VAL)

El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1985

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B5

No puede ejecutarse la instrucción porque no ha sido programada dentro de un OB de arranque.

Información
Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
de error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := INIT_RD("Tag_REQ");

Si el operando "Tag_REQ" devuelve el estado lógico "1", se ejecuta la instrucción. Se
inicializan todos los datos remanentes de todos los bloques de datos, marcas y
temporizadores y contadores SIMATIC.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1982)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de SCL (Página 8115)

WAIT: Programar retardo
Descripción
La instrucción "Programar retardo" permite detener la ejecución del programa durante un
periodo predeterminado. El periodo se indica en microsegundos en el parámetro WT de la
instrucción.
Es posible programar tiempos de retardo de -32768 a 32767 microsegundos (μs). El tiempo de
retardo mínimo depende de la CPU utilizada y equivale al tiempo de ejecución de la instrucción.

1986

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La ejecución de la instrucción puede verse interrumpida por eventos de prioridad superior y no
arrojará información de error.
Nota
Tiempo de retardo negativo
Si indica un tiempo de retardo negativo en el parámetro WT, la salida de habilitación ENO, o
el RLO y el bit BR arrojan el estado lógico FALSE. Un tiempo de retardo negativo no afecta a
la CPU. En KOP y FUP no se ejecutan las siguientes instrucciones vinculadas a la salida de
habilitación ENO.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

WT

Input

INT

I, Q, M, D, L, P o
constante

Tiempo de retardo en micro‐
segundos (μs)

Ejemplo de cómo influir en el tiempo de retardo previsto
En el ejemplo siguiente se ve la influencia del tiempo de retardo de la instrucción "WAIT" en
diferentes escenarios.
La figura siguiente ilustra los escenarios esquemáticamente:

Programación del PLC
Manual de programación y manejo, 11/2019

1987

Instrucciones
4.1 Instrucciones
6HQG&ORFN

&DVR 
2%

PV

:$,7  PV
7'HOD\ PV

7&RGH PV

7'HOD\ PV

7&RGH PV

7'HOD\ PV

7&RGH PV

75H PV

&DVR
2%GHDODUPD

75H PV

&DVR
2%GHDODUPD

7&RGH PV

&DVR
2%GHDODUPD
72Y PV
6HQG&ORFN 7LHPSRGHFLFORGHHPLVLµQGHOD&38
7'HOD\ 7LHPSRGHUHWDUGRGHO2%GHDODUPD
7&RGH 7LHPSRGHHMHFXFLµQGHOSURJUDPD
75H 7LHPSRUHVWDQWH
72Y 7LHPSRHQHOTXHVHSURORQJDHOWLHPSRGHFLFORGHHPLVLµQ
(O2%FRQODLQVWUXFFLµQ:$,7WDPEL«QIRUPDSDUWHGHORVFDVRV\\GHEH
WHQHUVHHQFXHQWD

Tiempo restante = intervalo entre el final del tiempo de retardo previsto (mediante "WAIT") y la
finalización del OB de alarma
Tiempo de prolongación = intervalo entre la finalización del OB de alarma y el final del tiempo
de retardo previsto (mediante "WAIT")
Caso 1:
La instrucción "WAIT" se llama en un OB1. La instrucción "WAIT" puede verse interrumpida por
OB o procesos de mayor prioridad (p. ej. System Threads). Sin embargo, el tiempo de retardo
de la instrucción "WAIT" no se ha modificado ni se ha aplazado.
Casos 2 y 3:
El procesamiento del programa en el OB1 prosigue tras un retardo de 20 ms. Este retardo se
calcula con la llamada de la instrucción "WAIT" en el OB1 (consulte OB1 con WAIT). En esos
20 ms, un OB de alarma puede ejecutar su propio código de programa. El tiempo de ciclo de
emisión de la CPU no cambia.

1988

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Caso 4:
El procesamiento del programa en el OB1 prosigue tras finalizar el proceso de mayor prioridad.
Los 20 ms de retardo en el OB1 han transcurrido, pero el proceso de mayor prioridad todavía
no ha finalizado. El tiempo de ciclo de emisión de la CPU aumenta.
Nota
Secuencia de ejecución de procesos del sistema o de comunicación (System Threads)
Los threads del sistema suelen utilizar la prioridad "15". También hay threads del sistema con
una prioridad mayor que "26", pero estos procesos suponen una carga menor para la CPU. Los
threads del sistema no se muestran en la figura.
Medición del tiempo de ejecución del OB1 utilizando la instrucción "RT_INFO":
Caso 2: 20 ms - 8 ms - System Threads = <12 ms. Tiempo de ciclo de emisión: ~20 ms.
Caso 3: 20 ms - 11 ms - System Threads - <9 ms. Tiempo de ciclo de emisión: ~20 ms.
Caso 4: 20 ms - 15 ms - System Threads - <7 ms. Tiempo de ciclo de emisión: ~22 ms.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

RUNTIME: Medir tiempo de ejecución
Descripción
La instrucción "Medir tiempo de ejecución" permite medir el tiempo de ejecución de todo el
programa, bloques individuales o secuencias de comandos.
Si desea medir el tiempo de ejecución de todo el programa, efectúe la llamada de la instrucción
"Medir tiempo de ejecución" en el OB1. El punto inicial para medir el tiempo de ejecución se
determina con la primera llamada y la salida RET_VAL devuelve el tiempo de ejecución del
programa tras la segunda llamada. El tiempo de ejecución medido incluye toda clase de
procesos de la CPU que se hayan producido durante la ejecución del programa, como, p. ej.,
interrupciones a causa de eventos o comunicaciones de mayor prioridad. La instrucción "Medir
tiempo de ejecución" lee un contador interno de la CPU y escribe su valor en el parámetro de
entrada/salida. La instrucción calcula el tiempo de ejecución actual del programa según la
frecuencia interna del contador, y la escribe en la salida RET_VAL.
Si desea medir el tiempo de ejecución de bloques o secuencias de comandos individuales,
necesita tres segmentos diferentes. Efectúe la llamada de la instrucción "Medir tiempo de
ejecución" en un segmento individual dentro del programa. Al efectuar esta primera llamada de
la instrucción se establece el punto inicial para medir el tiempo de ejecución. A continuación,
llame el bloque de programa o la secuencia de comando que desee en el siguiente segmento.
Efectúe la llamada de la instrucción "Medir tiempo de ejecución" por segunda vez en otro
segmento diferente y asigne al parámetro de entrada/salida la misma memoria que en la
primera llamada de la instrucción. En el tercer segmento, la instrucción "Medir tiempo de
ejecución" lee un contador interno de la CPU, calcula el tiempo de ejecución actual del bloque

Programación del PLC
Manual de programación y manejo, 11/2019

1989

Instrucciones
4.1 Instrucciones
de programa o secuencia de comando según la frecuencia interna del contador y lo escribe en
la salida RET_VAL.
La instrucción "Medir tiempo de ejecución" utiliza un contador interno de alta frecuencia para
calcular el tiempo. Cuando el contador se desborda, la instrucción devuelve valores <= 0.0. En
las CPU S7-1200 con versión de firmware < V4.2, esto puede suceder hasta una vez por
minuto. Estos valores de runtime deben ignorarse.
Nota
Puesto que el orden de las instrucciones de una secuencia de comandos se modifica mediante
la compilación optimizada del programa, no es posible determinar el tiempo de ejecución de
una secuencia de comandos con exactitud.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

InOut

LREAL

I, Q, M, D, L

El contenido está previsto
únicamente para fines inter‐
nos.

LREAL

I, Q, M, D, L

Devuelve el tiempo de ejecu‐
ción medido en segundos

Valor de función

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción mediante el cálculo del tiempo
de ejecución de un bloque de programa:
SCL
"Tag_Result" := RUNTIME("Tag_Memory");
"Best_before_date_DB" ();
"Tag_Result" := RUNTIME("Tag_Memory");

Con la primera llamada de la instrucción se determina el punto inicial para la medición del
tiempo de ejecución, y se guarda como referencia en una memora intermedia del operando
"TagMemory" para la segunda llamada de la instrucción.
A continuación se llama el bloque de programa FB1 "Best_before_date".
Una vez se ha procesado el bloque de programa FB1, la instrucción se ejecuta por segunda
vez. La segunda llamada de la instrucción calcula el tiempo de ejecución del bloque de
programa y escribe el resultado en la salida "Tag_Result".
Encontrará un ejemplo detallado de cómo medir el tiempo de ciclo total de un programa en el
Siemens Industry Online Support, en la ID de artículo: 87668055 (https://
support.industry.siemens.com/cs/ww/es/view/87668055)

1990

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Operaciones lógicas con palabras
DECO: Descodificar
Descripción
La instrucción "Descodificar" activa un bit predeterminado por el valor de entrada en el valor de
salida.
La instrucción "Descodificar" lee el valor del parámetro IN y activa el bit en el valor de salida
cuya posición equivale al valor leído. Los demás bits del valor de salida se rellenan con ceros.
Si el valor del parámetro IN es mayor que 31, se ejecuta una instrucción modulo 32.
Para modificar el tipo de datos de la instrucción, utilice la sintaxis siguiente:
DECO_<Tipo de datos>();

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declara‐
ción

Tipo de datos

Área de memoria

Descripción

IN

Input

UINT

I, Q, M, D, L, P

Posición del bit que se activa en
el valor de salida.

Secuencias de
bits
Valor predeter‐
minado:
DWORD

-

Tipo de datos del valor de fun‐
ción:

_<tipo de datos>

1. El tipo de datos de la
instrucción se puede indicar
explícitamente con "_".
2. Si el tipo de datos no se
indica explícitamente, se
determinará a partir de las
variables utilizadas o de las
constantes con tipos.
3. Si el tipo de datos no se
indica explícitamente ni se
indican variables definidas
ni constantes con tipo, se
utilizará el tipo de datos
predeterminado.

Valor de función

Secuencias de
bits

I, Q, M, D, L, P

Valor de salida actual

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1991

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := DECO(IN := "Tag_Value");
"Tag_Result2" := DECO_BYTE(IN := "Tag_Value2");

La figura siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
ಯ7DJB9DOXHಯ




ಯ7DJB5HVXOWಯ

 



 

La instrucción lee el número "3" del valor del operando "Tag_Value" y activa el tercer bit del
valor del operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

ENCO: Codificar
Descripción
La instrucción "Codificar" permite leer el número del bit menos significativo que está activado
en el valor de entrada y devolverlo como resultado.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

Secuencias de
bits

I, Q, M, D, L, P

Valor de entrada

INT

I, Q, M, D, L, P

Número del bit que
se lee en el valor de
entrada.

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := ENCO(IN := "Tag_Value");

1992

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La figura siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:

ಯ7DJB9DOXHಯ
ಯ7DJB5HVXOWಯ

 



 


La instrucción lee el bit menos significativo que está activado en el operando "Tag_Value" y
escribe la posición de bit "3" en el operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

SEL: Seleccionar
Descripción
La instrucción "Seleccionar" selecciona, en función de un interruptor (parámetro G), uno de los
parámetros IN0 o IN1 y devuelve su contenido como resultado. Si el parámetro G tiene el
estado lógico "0", se copia el valor del parámetro IN0. Si el parámetro G tiene el estado lógico
"1", se copia el valor del parámetro IN1 y se devuelve como valor de función.
Para poder ejecutar la instrucción, es imprescindible que las variables de todos los parámetros
del tipo de datos sean de la misma clase.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetros Declaración

Tipo de datos
S7-1200

S7-1500

Área de me‐
moria
I, Q, M, D, L

G

Input

BOOL

BOOL

IN0

Input

Números bina‐
rios, enteros, nú‐
meros en coma
flotante, tempori‐
zadores, secuen‐
cias de caracte‐
res, TOD, DATE,
DT

Números bina‐ I, Q, M, D, L,
P
rios, enteros,
números en co‐
ma flotante,
temporizado‐
res, secuencias
de caracteres,
DATE, TOD,
LTOD, DT, LDT

Programación del PLC
Manual de programación y manejo, 11/2019

Descripción
Interruptor
Primer valor de
entrada

1993

Instrucciones
4.1 Instrucciones
Parámetros Declaración
IN1

Input

Valor de función

Tipo de datos

Área de me‐
moria

Descripción

S7-1200

S7-1500

Números bina‐
rios, enteros, nú‐
meros en coma
flotante, tempori‐
zadores, secuen‐
cias de caracte‐
res, TOD, DATE,
DT

Números bina‐ I, Q, M, D, L,
P
rios, enteros,
números en co‐
ma flotante,
temporizado‐
res, secuencias
de caracteres,
DATE, TOD,
LTOD, DT, LDT

Segundo valor de
entrada

Números bina‐
rios, enteros, nú‐
meros en coma
flotante, tempori‐
zadores, secuen‐
cias de caracte‐
res, TOD, DATE,
DT

Números bina‐ I, Q, M, D, L,
rios, enteros,
P
números en co‐
ma flotante,
temporizado‐
res, secuencias
de caracteres,
DATE, TOD,
LTOD, DT, LDT

Resultado de la
instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := SEL(G := "Tag_Value",
IN0 := "Tag_0",
IN1 := "Tag_1");

El resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

0

1

Tag_0

W#16#0000

W#16#4C

Tag_1

W#16#FFFF

D#16#5E

Tag_Result

W#16#0000

D#16#5E

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

1994

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

MUX: Multiplexar
Descripción
La instrucción "Multiplexar" copia el valor de un parámetro de entrada seleccionado y lo
devuelve. Con el parámetro K se especifica el número del parámetro de entrada cuyo número
se copiará. La numeración comienza por IN0 y continúa en orden ascendente con cada nueva
entrada. Se puede declarar un máximo de 32 entradas.
En las entradas se permiten tipos de datos numéricos y tipos de datos de tiempo. Todas las
variables parametrizadas deben ser del mismo tipo de datos.
El valor de función no es válido si se cumple una de las siguientes condiciones:
● Se producen errores al ejecutar la instrucción.
● Si la entrada del parámetro K está fuera del rango de entradas disponibles y la entrada
INELSE no se usa, el valor de función no es válido.
Nota
El parámetro K tiene un entero negativo
Si en los parámetros de entrada se indica una variable con un tipo de datos válido y el
parámetro K tiene un entero negativo, el valor de la variable se modificará.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

K

Input

Tipo de datos
S7-1200

S7-1500

Enteros

Enteros

Área de me‐ Descripción
moria
I, Q, M, D, L,
P

Indica el parámetro
cuyo contenido se
transfiere.
● Si K = 0 =>
parámetro IN0
● Si K = 1 =>
parámetro IN1,
etc.

IN0

Input

Programación del PLC
Manual de programación y manejo, 11/2019

Números bi‐
narios, ente‐
ros, números
en coma flo‐
tante, tempo‐
rizadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

Números bina‐ I, Q, M, D, L,
rios, enteros,
P
números en co‐
ma flotante, se‐
cuencias de ca‐
racteres, TOD,
LTOD, DATE,
temporizado‐
res, DT, LDT

Primer valor de entra‐
da

1995

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de me‐ Descripción
moria

IN1

Input

Números bi‐
narios, ente‐
ros, números
en coma flo‐
tante, tempo‐
rizadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

Números bina‐ I, Q, M, D, L,
rios, enteros,
P
números en co‐
ma flotante, se‐
cuencias de ca‐
racteres, TOD,
LTOD, DATE,
temporizado‐
res, DT, LDT

Segundo valor de en‐
trada

INn

Input

Números bi‐
narios, ente‐
ros, números
en coma flo‐
tante, tempo‐
rizadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

Números bina‐ I, Q, M, D, L,
rios, enteros,
P
números en co‐
ma flotante, se‐
cuencias de ca‐
racteres, TOD,
LTOD, DATE,
temporizado‐
res, DT, LDT

Valores de entrada op‐
cionales

INELSE

Input

Números bi‐
narios, ente‐
ros, números
en coma flo‐
tante, tempo‐
rizadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

Números bina‐ I, Q, M, D, L,
rios, enteros,
P
números en co‐
ma flotante, se‐
cuencias de ca‐
racteres, TOD,
LTOD, DATE,
temporizado‐
res, DT, LDT

Indica el valor que se
copia si K <> n.

Números bi‐
narios, ente‐
ros, números
en coma flo‐
tante, tempo‐
rizadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

Números bina‐ I, Q, M, D, L,
rios, enteros,
P
números en co‐
ma flotante, se‐
cuencias de ca‐
racteres, TOD,
LTOD, DATE,
temporizado‐
res, DT, LDT

Resultado de la ins‐
trucción

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1996

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := MUX(K := "Tag_Number",
IN0 := "Tag_1",
IN1 := "Tag_2",
INELSE := "Tag_3");

El resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Number

1

4

Tag_1

DW#16#00000000

DW#16#00000000

Tag_2

DW#16#003E4A7D

DW#16#003E4A7D

Tag_3

DW#16#FFFF0000

DW#16#FFFF0000

Tag_Result

DW#16#003E4A7D

DW#16#FFFF0000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

DEMUX: Desmultiplexar
Descripción
La instrucción "Desmultiplexar" permite transferir el valor del parámetro de entrada IN a un
parámetro de salida seleccionado. La selección del parámetro de salida se efectúa en función
del valor del parámetro K. El parámetro K indica el número del parámetro de salida al que se
transfiere el valor del parámetro de entrada IN. Los demás parámetros de salida no cambian.
La numeración comienza por OUT0 y continúa en orden ascendente con cada nueva salida.
Se puede declarar un máximo de 32 parámetros de salida.
Si el valor del parámetro K es mayor que el número de parámetros de salida, se copia el
contenido del parámetro de entrada IN en el parámetro de salida OUTELSE y se asigna a la
salida de habilitación ENO el estado lógico "0".
El valor de función no es válido si se cumple una de las siguientes condiciones:
● El valor del parámetro K es mayor que el número de salidas disponibles.
● Se producen errores al ejecutar la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

1997

Instrucciones
4.1 Instrucciones

Nota
El parámetro K < 0 o K > las salidas disponibles
Si indica un valor en el parámetro K que esté fuera de las salidas disponibles (K < 0 o K >
salidas disponibles), en el parámetro de salida OUTELSE se emitirá el valor del parámetro de
entrada IN.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

K

Input

Tipo de datos
S7-1200

S7-1500

Enteros

Enteros

Área de me‐
moria

Descripción

I, Q, M, D, L, P Indica la salida en la
que se copia el valor
de entrada (IN).
● Si K = 0 =>
parámetro OUT0
● Si K = 1 =>
parámetro
OUT1, etc.

1998

IN

Input

Números bi‐
narios, ente‐
ros, números
en coma flo‐
tante, tempori‐
zadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

Números bina‐ I, Q, M, D, L, P Valor de entrada
rios, enteros,
números en
coma flotante,
secuencias de
caracteres,
temporizado‐
res, TOD,
LTOD, DATE,
DT, LDT

OUT0

Output

Números bi‐
narios, ente‐
ros, números
en coma flo‐
tante, tempori‐
zadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

Números bina‐ I, Q, M, D, L, P Primera salida
rios, enteros,
números en
coma flotante,
secuencias de
caracteres,
temporizado‐
res, TOD,
LTOD, DATE,
DT, LDT

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de me‐
moria

Descripción

OUT1

Output

Números bi‐
narios, ente‐
ros, números
en coma flo‐
tante, tempori‐
zadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

Números bina‐ I, Q, M, D, L, P Segunda salida
rios, enteros,
números en
coma flotante,
secuencias de
caracteres,
temporizado‐
res, TOD,
LTOD, DATE,
DT, LDT

OUTn

Output

Números bi‐
narios, ente‐
ros, números
en coma flo‐
tante, tempori‐
zadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

Números bina‐ I, Q, M, D, L, P Salidas opcionales
rios, enteros,
números en
coma flotante,
secuencias de
caracteres,
temporizado‐
res, TOD,
LTOD, DATE,
DT, LDT

OUTELSE

Output

Números bi‐
narios, ente‐
ros, números
en coma flo‐
tante, tempori‐
zadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

Números bina‐ I, Q, M, D, L, P Salida a la que se co‐
pia el valor de la en‐
rios, enteros,
trada IN con K > n.
números en
coma flotante,
secuencias de
caracteres,
temporizado‐
res, TOD,
LTOD, DATE,
DT, LDT

Encontrará más información sobre los tipos de datos disponibles en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
DEMUX(K := "Tag_Number",
IN := "Tag_Value",
OUT0 := "Tag_1",
OUT1 := "Tag_2",
OUTELSE := "Tag_3");

Las tablas siguientes muestran el funcionamiento de la instrucción con valores de operandos
concretos:

Programación del PLC
Manual de programación y manejo, 11/2019

1999

Instrucciones
4.1 Instrucciones
Valores de entrada de la instrucción "Desmultiplexar" antes de ejecutar el segmento
Parámetro

Operando

Valores

K

Tag_Number

2

4

IN

Tag_Value

DW#16#FFFFFFFF

DW#16#003E4A7D

Valores de salida de la instrucción "Desmultiplexar" tras ejecutar el segmento
Parámetro

Operando

OUT0

Tag_1

sin cambios

Valores
sin cambios

OUT1

Tag_2

DW#16#FFFFFFFF

sin cambios

OUTELSE

Tag_3

sin cambios

DW#16#003E4A7D

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Desplazamiento y rotación
SHR: Desplazar a la derecha
Descripción
Con la instrucción "Desplazar a la derecha" se desplaza el contenido del parámetro IN de bit
en bit hacia la derecha y se devuelve como valor de función. El parámetro N determina el
número de bits que debe desplazarse el valor indicado.
Si el valor del parámetro N es "0", se devuelve como resultado el valor del parámetro IN.
Si el valor del parámetro N es mayor que el número de bits disponibles, el valor del parámetro
IN se desplaza hacia la derecha las posiciones de bit disponibles.
En los valores sin signo, se rellenan con ceros los bits que quedan libres en el área izquierda
del operando al realizar el desplazamiento. Si el valor indicado lleva signo, las posiciones libres
se ocupan con el estado lógico del bit de signo.
La figura siguiente muestra cómo el contenido de un operando del tipo de datos Integer se
desplaza cuatro posiciones de bit hacia la derecha:

2000

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones


,1



 










1

5HVXOWDGR!




































SRVLFLRQHV



























(VWRVFXDWURELWV
VHSLHUGHQ

/DVSRVLFLRQHVGHELWTXHTXHGDQOLEUHV
VHUHOOHQDQFRQFHURV

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐
ria

Descripción

IN

Input

Secuencias Secuencias I, Q, M, D, L
de bits, ente‐ de bits, ente‐
ros
ros

Valor que se
desplaza

N

Input

USINT,
UINT,
UDINT

I, Q, M, D, L

Número de bits
que se desplaza
el valor (IN)

Secuencias Secuencias I, Q, M, D, L
de bits, ente‐ de bits, ente‐
ros
ros

Resultado de la
instrucción

Valor de función

USINT,
UINT,
UDINT,
ULINT

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := SHR(IN := "Tag_Value",
N := "Tag_Number");

Programación del PLC
Manual de programación y manejo, 11/2019

2001

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

Tag_Value

0011 1111 1010 1111

N

Tag_Number

3

Valor de función

Tag_Result

0000 0111 1111 0101

El valor del operando "Tag_Value" se desplaza tres posiciones de bit hacia la derecha. El
resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

SHL: Desplazar a la izquierda
Descripción
Con la instrucción "Desplazar a la izquierda" se desplaza el contenido del parámetro IN de bit
en bit hacia la izquierda y se devuelve como valor de función. El parámetro N determina el
número de bits que debe desplazarse el valor indicado.
Si el valor del parámetro N es "0", se devuelve como resultado el valor del parámetro IN.
Si el valor del parámetro N es mayor que el número de bits disponibles, el valor del parámetro
IN se desplaza hacia la izquierda las posiciones de bit disponibles.
Las posiciones que quedan libres al desplazar se rellenan con ceros.
La figura siguiente muestra cómo el contenido de un operando del tipo de datos WORD se
desplaza seis posiciones de bit hacia la izquierda:

2002

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones


,1



 




1




























SRVLFLRQHV

5HVXOWDGR!      

































/DVSRVLFLRQHVGHELW
TXHKDQTXHGDGROLEUHV
VHUHOOHQDQFRQFHURV

(VWRVVHLVELWV
VHSLHUGHQ

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐
ria

Descripción

IN

Input

Secuencias Secuencias I, Q, M, D, L
de bits, ente‐ de bits, ente‐
ros
ros

Valor que se
desplaza

N

Input

USINT,
UINT,
UDINT

I, Q, M, D, L

Número de bits
que se desplaza
el valor (IN)

Secuencias Secuencias I, Q, M, D, L
de bits, ente‐ de bits, ente‐
ros
ros

Resultado de la
instrucción

Valor de función

USINT,
UINT,
UDINT,
ULINT

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := SHL(IN := "Tag_Value",
N := "Tag_Number");

Programación del PLC
Manual de programación y manejo, 11/2019

2003

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

Tag_Value

0011 1111 1010 1111

N

Tag_Number

4

Valor de función

Tag_Result

1111 1010 1111 0000

El valor del operando "Tag_Value" se desplaza cuatro posiciones de bit hacia la izquierda. El
resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

ROR: Rotar a la derecha
Descripción
La instrucción "Rotar a la derecha" permite rotar el contenido del parámetro IN de bit en bit
hacia la derecha y asignar el resultado al operando indicado. El parámetro N determina el
número de bits que debe rotarse el valor indicado. Los bits que quedan libres al realizar la
rotación se rellenan con los bits desplazados hacia fuera.
Si el valor del parámetro N es "0", se devuelve como resultado el valor de la entrada IN.
Si el valor del parámetro N es mayor que el número de bits disponibles, el valor del operando
en la entrada IN rota de todos modos el número indicado de posiciones de bit.
La figura siguiente muestra cómo el contenido de un operando del tipo de datos DWORD rota
tres posiciones hacia la derecha:

2004

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones


,1

 



       

1

SRVLFLRQHV

        

5HVXOWDGR!

(OHVWDGROµJLFRGHORVWUHV
ELWVGHVSOD]DGRVVHLQWURGXFHHQODV
SRVLFLRQHVTXHKDQTXHGDGROLEUHV

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐
ria

Descripción

IN

Input

Secuencias Secuencias I, Q, M, D, L
de bits, ente‐ de bits, ente‐
ros
ros

Valor que se rota

N

Input

USINT,
UINT,
UDINT

I, Q, M, D, L

Número de bits
que rota el valor
(IN)

Secuencias Secuencias I, Q, M, D, L
de bits, ente‐ de bits, ente‐
ros
ros

Resultado de la
instrucción

Valor de función

USINT,
UINT,
UDINT,
ULINT

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := ROR(IN := "Tag_Value",
N := "Tag_Number");

Programación del PLC
Manual de programación y manejo, 11/2019

2005

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

Tag_Value

0000 1111 1001 0101

N

Tag_Number

5

Valor de función

Tag_Result

1010 1000 0111 1100

El contenido del operando "Tag_Value" se rota cinco posiciones de bit hacia la derecha. El
resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

ROL: Rotar a la izquierda
Descripción
Con la instrucción "Rotar a la izquierda", el contenido del parámetro IN rota de bit en bit hacia
la izquierda y se devuelve como valor de función. El parámetro N determina el número de bits
que debe rotarse el valor indicado. Los bits que quedan libres al realizar la rotación se rellenan
con los bits desplazados hacia fuera.
Si el valor del parámetro N es "0", se devuelve como resultado el valor de la entrada IN.
Si el valor del parámetro N es mayor que el número de bits disponibles, el valor del operando
en la entrada IN rota de todos modos el número indicado de posiciones de bit.
La figura siguiente muestra cómo el contenido de un operando del tipo de datos DWORD rota
tres posiciones hacia la izquierda:

2006

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones


,1

 

       

1

5HVXOWDGR!



SRVLFLRQHV

        
(OHVWDGROµJLFRGHORVWUHV
ELWVGHVSOD]DGRVVHLQVHUWD
HQODVSRVLFLRQHVTXHKDQTXHGDGR
OLEUHV

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐
ria

Descripción

IN

Input

Secuencias Secuencias I, Q, M, D, L
de bits, ente‐ de bits, ente‐
ros
ros

Valor que se rota

N

Input

USINT,
UINT,
UDINT

I, Q, M, D, L

Número de bits
que rota el valor
(IN)

Secuencias Secuencias I, Q, M, D, L
de bits, ente‐ de bits, ente‐
ros
ros

Resultado de la
instrucción

Valor de función

USINT,
UINT,
UDINT,
ULINT

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := ROL(IN := "Tag_Value",
N := "Tag_Number");

Programación del PLC
Manual de programación y manejo, 11/2019

2007

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

Tag_Value

1010 1000 1111 0110

N

Tag_Number

5

Valor de función

Tag_Result

0001 1110 1101 0101

El contenido del operando "Tag_Value" se rota cinco posiciones de bit hacia la izquierda. El
resultado de la instrucción se devuelve en el operando "Tag_Result" como valor de función.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Legacy
DRUM: Materializar circuito secuencial sucesivo
Descripción
La instrucción "Materializar circuito secuencial sucesivo" ocupa los bits de salida programados
(OUT1 a OUT16) y la palabra de salida (OUT_WORD) con los valores programados del
parámetro OUT_VAL del paso respectivo. El paso en cuestión debe cumplir las condiciones de
la máscara de habilitación programada en el parámetro S_MASK mientras la instrucción
permanece en dicho paso. La instrucción pasa al paso siguiente cuando el evento de éste es
verdadero y una vez transcurrido el tiempo programado para el paso actual, o bien cuando el
valor del parámetro JOG cambia de "0" a "1". La instrucción se desactiva cuando el estado
lógico del parámetro RESET cambia a "1". Con ello, el paso actual se iguala al paso
predeterminado (DSP).
El tiempo de permanencia en un paso se calcula multiplicando la base de tiempo
predeterminada (DTBP) por el valor de contaje predeterminado (S_PRESET) para cada paso.
Al comienzo de un nuevo paso, este valor calculado se carga en el parámetro DCC, que
contiene el tiempo restante para el paso actual. Por ejemplo, si el valor del parámetro DTBP es
"2" y el valor predeterminado para el primer paso es "100" (100 ms), el parámetro DCC
devolverá el valor "200" (200 ms).
Un paso puede programarse con un valor de tiempo, con un evento o con ambos. Los pasos
programados con un bit de evento y el valor de tiempo "0" pasan al siguiente paso en cuanto
el estado lógico del bit de evento es "1". Los pasos programados solo con un valor de tiempo
empiezan a contar el tiempo inmediatamente. Los pasos programados con un bit de evento y
un valor de tiempo mayor que "0" empiezan a contar el tiempo en cuanto el estado lógico del
bit de evento es "1". Los bits de evento se inicializan con el estado lógico "1".
Si el circuito secuencial sucesivo se encuentra en el último paso programado (LST_STEP) y ha
transcurrido el tiempo para dicho paso, el estado lógico del parámetro Q se pone a "1". De lo
contrario, se pone a "0". Si está activado el parámetro Q, la instrucción permanece en el paso
hasta la desactivación.

2008

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En la máscara configurable (S_MASK) es posible seleccionar los distintos bits de la palabra de
salida (OUT_WORD) y activar o desactivar los bits de salida (OUT1 a OUT16) mediante los
valores de salida (OUT_VAL). Si un bit de la máscara configurable tiene el estado lógico "1",
el valor OUT_VAL activa o desactiva el bit correspondiente. Si el estado lógico de un bit de la
máscara configurable es "0", no cambia el bit respectivo. Todos los bits de la máscara
configurable de todos los 16 pasos se inicializan con el estado lógico "1".
El bit de salida del parámetro OUT1 equivale al bit menos significativo de la palabra de salida
(OUT_WORD). El bit de salida del parámetro OUT16 equivale al bit más significativo de la
palabra de salida (OUT_WORD).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RESET

Input

BOOL

I, Q, M, D, L

El estado lógico "1" indica
una condición de desactiva‐
ción.

JOG

Input

BOOL

I, Q, M, D, L

Si el estado lógico cambia de
"0" a "1", la instrucción pasa
al siguiente paso.

DRUM_EN

Input

BOOL

I, Q, M, D, L

El estado lógico "1" permite
que el circuito secuencial su‐
cesivo siga contando según
el evento y los criterios de
tiempo.

LST_STEP

Input

BYTE

I, Q, M, D, L

Número máximo de etapas
(p. ej.: LST_STEP = 16#08;
son posibles 8 etapas como
máximo.)

EVENT(i),

Input

BOOL

I, Q, M, D, L

OUT(j),

Bit de evento (i);
El estado lógico inicial es "1".

1 ≤ i ≤ 16
Output

BOOL

I, Q, M, D, L

Bit de salida (j)

Q

Output

BOOL

I, Q, M, D, L

El estado lógico "1" indica
que ha transcurrido el tiempo
del último paso.

OUT_WORD

Output

WORD

I, Q, M, D, L, P

Dirección de palabra en la
que el circuito secuencial su‐
cesivo escribe los valores de
salida.

ERR_CODE

Output

WORD

I, Q, M, D, L, P

Información de error

JOG_HIS

Static

BOOL

I, Q, M, D, L

Bit de evolución del paráme‐
tro JOG

EOD

Static

BOOL

I, Q, M, D, L

El estado lógico "1" indica
que ha transcurrido el tiempo
del último paso.

DSP

Static

BYTE

I, Q, M, D, L, P

Paso predeterminado del cir‐
cuito secuencial sucesivo

1 ≤ j ≤ 16

Programación del PLC
Manual de programación y manejo, 11/2019

2009

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

DSC

Static

BYTE

I, Q, M, D, L, P

Paso actual del circuito se‐
cuencial sucesivo

DCC

Static

DWORD

I, Q, M, D, L, P

Valor de contaje actual del
circuito secuencial sucesivo

DTBP

Static

WORD

I, Q, M, D, L, P

Base de tiempo predetermi‐
nada del circuito secuencial
sucesivo

PrevTime

Static

TIME

I, Q, M, D, L

Hora de sistema anterior

S_PRESET

Static

ARRAY[1..16] of
WORD

I, Q, M, D, L

Valor de contaje predetermi‐
nado para cada paso [1 a 16];
1 ciclo de reloj = 1 ms.

OUT_VAL

Static

ARRAY[1..16,
0..15] of BOOL

I, Q, M, D, L

Valores de salida para cada
etapa [1 a 16, 0 a 15].

S_MASK

Static

ARRAY[1..16,
0..15] of BOOL

I, Q, M, D, L

Máscara configurable para
cada etapa [1 a 16, 0 a 15].
Los estados lógicos iniciales
son "1".

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
ERR_CO‐
DE*

Explicación

W#16#000
0

Ningún error

W#16#000
B

El valor del parámetro LST_STEP es menor que 1 o mayor que 16.

W#16#000
C

El valor del parámetro DSC es menor que 1 o mayor que el valor del parámetro
LST_STEP.

W#16#000
D

El valor del parámetro DSP es menor que 1 o mayor que el valor de LST_STEP.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
En el ejemplo siguiente, la instrucción pasa del paso 1 al paso 2. Los bits de salida (OUT1 a
OUT16) y la palabra de salida (OUT_WORD) se activan según la máscara configurada para el
paso 2 y los valores del parámetro OUT_VAL.
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

2010

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

SCL
"DRUM_DB"(RESET := "Tag_Reset"
JOG := "Tag_Input_Jog"
DRUM_EN := "Tag_Input_DrumEN"
LST_STEP := "Tag_Number_LastStep"
EVENT1 := "MyTag_Event_1"
EVENT2 := "MyTag_Event_2"
EVENT3 := "MyTag_Event_3"
EVENT4 := "MyTag_Event_4"
EVENT5 := "MyTag_Event_5"
EVENT6 := "MyTag_Event_6"
EVENT7 := "MyTag_Event_7"
EVENT8 := "MyTag_Event_8"
EVENT9 := "MyTag_Event_9"
EVENT10 := "MyTag_Event_10"
EVENT11 := "MyTag_Event_11"
EVENT12 := "MyTag_Event_12"
EVENT13 := "MyTag_Event_13"
EVENT14 := "MyTag_Event_14"
EVENT15 := "MyTag_Event_15"
EVENT16 := "MyTag_Event_16"
OUT1 => "MyTag_Output_1"
OUT2 => "MyTag_Output_2"
OUT3 => "MyTag_Output_3"
OUT4 => "MyTag_Output_4"
OUT5 => "MyTag_Output_5"
OUT6 => "MyTag_Output_6"
OUT7 => "MyTag_Output_7"
OUT8 => "MyTag_Output_8"
OUT9 => "MyTag_Output_9"
OUT10 => "MyTag_Output_10"
OUT11 => "MyTag_Output_11"
OUT12 => "MyTag_Output_12"
OUT13 => "MyTag_Output_13"
OUT14 => "MyTag_Output_14"
OUT15 => "MyTag_Output_15"
OUT16 => "MyTag_Output_16"
Q => "Tag_Output_Q"
OUT_WORD => "Tag_OutputWord"
ERR_CODE => "Tag_ErrorCode");

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

Programación del PLC
Manual de programación y manejo, 11/2019

2011

Instrucciones
4.1 Instrucciones

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para asignar valores a los parámetros de
entrada:
Parámetro

Operando

Dirección

Valor

RESET

Tag_Reset

M0.0

FALSE

JOG

Tag_Input_JOG

M0.1

FALSE

DRUM_EN

Tag_Input_DrumEN

M0.2

TRUE

LST_STEP

Tag_Number_LastStep

MB1

B#16#08

EVENT2

MyTag_Event_2

M20.0

FALSE

EVENT4

MyTag_Event_4

M20.1

FALSE

EVENT6

MyTag_Event_6

M20.2

FALSE

EVENT8

MyTag_Event_8

M20.3

FALSE

EVENT10

MyTag_Event_10

M20.4

FALSE

EVENT12

MyTag_Event_12

M20.5

FALSE

EVENT14

MyTag_Event_14

M20.6

FALSE

EVENT16

MyTag_Event_16

M20.7

FALSE

En el bloque de datos de instancia "DRUM_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

2012

Dirección

Valor

JOG_HIS

DBX12.0

FALSE

EOD

DBX12.1

FALSE

DSP

DBB13

W#16#0001

DSC

DBB14

W#16#0001

DCC

DBD16

DW#16#0000000A

DTBP

DBW20

W#16#0001

S_PRESET[1]

DBW26

W#16#0064

S_PRESET[2]

DBW28

W#16#00C8

OUT_VAL[1,0]

DBX58.0

TRUE

OUT_VAL[1,1]

DBX58.1

TRUE

OUT_VAL[1,2]

DBX58.2

TRUE

OUT_VAL[1,3]

DBX58.3

TRUE

OUT_VAL[1,4]

DBX58.4

TRUE

OUT_VAL[1,5]

DBX58.5

TRUE

OUT_VAL[1,6]

DBX58.6

TRUE

OUT_VAL[1,7]

DBX58.7

TRUE

OUT_VAL[1,8]

DBX59.0

TRUE

OUT_VAL[1,9]

DBX59.1

TRUE

OUT_VAL[1,10]

DBX59.2

TRUE

OUT_VAL[1,11]

DBX59.3

TRUE

OUT_VAL[1,12]

DBX59.4

TRUE

OUT_VAL[1,13]

DBX59.5

TRUE

OUT_VAL[1,14]

DBX59.6

TRUE

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Dirección

Valor

OUT_VAL[1,15]

DBX59.7

TRUE

OUT_VAL[2,0]

DBX60.0

FALSE

OUT_VAL[2,1]

DBX60.1

FALSE

OUT_VAL[2,2]

DBX60.2

FALSE

OUT_VAL[2,3]

DBX60.3

FALSE

OUT_VAL[2,4]

DBX60.4

FALSE

OUT_VAL[2,5]

DBX60.5

FALSE

OUT_VAL[2,6]

DBX60.6

FALSE

OUT_VAL[2,7]

DBX60.7

FALSE

OUT_VAL[2,8]

DBX61.0

FALSE

OUT_VAL[2,9]

DBX61.1

FALSE

OUT_VAL[2,10]

DBX61.2

FALSE

OUT_VAL[2,11]

DBX61.3

FALSE

OUT_VAL[2,12]

DBX61.4

FALSE

OUT_VAL[2,13]

DBX61.5

FALSE

OUT_VAL[2,14]

DBX61.6

FALSE

OUT_VAL[2,15]

DBX61.7

FALSE

S_MASK[2,0]

DBX92.0

FALSE

S_MASK[2,1]

DBX92.1

TRUE

S_MASK[2,2]

DBX92.2

TRUE

S_MASK[2,3]

DBX92.3

TRUE

S_MASK[2,4]

DBX92.4

TRUE

S_MASK[2,5]

DBX92.5

FALSE

S_MASK[2,6]

DBX92.6

TRUE

S_MASK[2,7]

DBX92.7

TRUE

S_MASK[2,8]

DBX93.0

FALSE

S_MASK[2,9]

DBX93.1

FALSE

S_MASK[2,10]

DBX93.2

TRUE

S_MASK[2,11]

DBX93.3

TRUE

S_MASK[2,12]

DBX93.4

TRUE

S_MASK[2,13]

DBX93.5

TRUE

S_MASK[2,14]

DBX93.6

FALSE

S_MASK[2,15]

DBX93.7

TRUE

Los parámetros de salida tienen los valores siguientes antes de ejecutarse la instrucción:
Parámetro

Operando

Dirección

Valor

Q

Tag_Output_Q

M6.0

FALSE

OUTWORD

Tag_OutputWord

MW8

W#16#FFFF

OUT1

MyTag_Output_1

M4.0

TRUE

OUT2

MyTag_Output_2

M4.1

TRUE

OUT3

MyTag_Output_3

M4.2

TRUE

OUT4

MyTag_Output_4

M4.3

TRUE

Programación del PLC
Manual de programación y manejo, 11/2019

2013

Instrucciones
4.1 Instrucciones
Parámetro

Operando

Dirección

Valor

OUT5

MyTag_Output_5

M4.4

TRUE

OUT6

MyTag_Output_6

M4.5

TRUE

OUT7

MyTag_Output_7

M4.6

TRUE

OUT8

MyTag_Output_8

M4.7

TRUE

OUT9

MyTag_Output_9

M5.0

TRUE

OUT10

MyTag_Output_10

M5.1

TRUE

OUT11

MyTag_Output_11

M5.2

TRUE

OUT12

MyTag_Output_12

M5.3

TRUE

OUT13

MyTag_Output_13

M5.4

TRUE

OUT14

MyTag_Output_14

M5.5

TRUE

OUT15

MyTag_Output_15

M5.6

TRUE

OUT16

MyTag_Output_16

M5.7

TRUE

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:

2014

Parámetro

Operando

Dirección

Valor

OUT1

MyTag_Output_1

M4.0

TRUE

OUT2

MyTag_Output_2

M4.1

FALSE

OUT3

MyTag_Output_3

M4.2

FALSE

OUT4

MyTag_Output_4

M4.3

FALSE

OUT5

MyTag_Output_5

M4.4

FALSE

OUT6

MyTag_Output_6

M4.5

TRUE

OUT7

MyTag_Output_7

M4.6

FALSE

OUT8

MyTag_Output_8

M4.7

FALSE

OUT9

MyTag_Output_9

M5.0

TRUE

OUT10

MyTag_Output_10

M5.1

TRUE

OUT11

MyTag_Output_11

M5.2

FALSE

OUT12

MyTag_Output_12

M5.3

FALSE

OUT13

MyTag_Output_13

M5.4

FALSE

OUT14

MyTag_Output_14

M5.5

FALSE

OUT15

MyTag_Output_15

M5.6

TRUE

OUT16

MyTag_Output_16

M5.7

FALSE

Q

Tag_Output_Q

M6.0

FALSE

OUTWORD

Tag_OutputWord

MW8

W#16#4321

ERR_CODE

Tag_ErrorCode

MW10

W#16#0000

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los siguientes valores se modifican en el bloque de datos de instancia "DRUM_DB" de la
instrucción después de su ejecución:
Parámetro

Dirección

Valor

JOG_HIS

DBX12.0

FALSE

EOD

DBX12.1

FALSE

DSC

DBB14

W#16#0002

DCC

DBD16

DW#16#000000C8

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de SCL (Página 8115)

DCAT: Alarma de tiempo para control discreto
Descripción
La instrucción "Alarma de tiempo para control discreto" acumula el tiempo desde el instante en
el que el parámetro CMD da la orden de abrir o cerrar. El tiempo se acumula hasta excederse
el tiempo predeterminado (PT) o hasta recibir la notificación de que el dispositivo se ha cerrado
o abierto dentro del tiempo prescrito (O_FB o C_FB). Si se excede el tiempo predeterminado
antes de recibirse la notificación de que se ha abierto o cerrado el dispositivo, se activa la
alarma correspondiente. Si el estado lógico de la entrada de la orden cambia antes del tiempo
predeterminado, se reinicia el tiempo.
La instrucción "Alarma de tiempo para control discreto" tiene las reacciones siguientes en las
condiciones de entrada:
● Si el estado lógico del parámetro CMD cambia de "0" a "1", esto tiene los efectos siguientes
en los estados lógicos de los parámetros Q, CMD_HIS, ET (solo si ET < PT), OA y CA:
– Los parámetros Q y CMD_HIS se ponen a "1"
– Los parámetros ET, OA y CA se ponen a "0"
● Si el estado lógico del parámetro CMD cambia de "1" a "0", los parámetros Q, ET (solo si
ET < PT), OA, CA y CMD_HIS se ponen a "0".
● Si los parámetros CMD y CMD_HIS tienen el estado lógico "1" y el parámetro O_FB se pone
a "0", la diferencia de tiempo (ms) desde la última ejecución de la instrucción se suma al
valor del parámetro ET. Si el valor del parámetro ET excede el del parámetro PT, el estado
lógico del parámetro OA se pone a "1". Si el valor del parámetro ET no excede el del
parámetro PT, el estado lógico del parámetro OA se pone a "0". El valor del parámetro
CMD_HIS se pone al del parámetro CMD.
● Si los estados lógicos de los parámetros CMD, CMD_HIS y O_FB están a "1" y el parámetro
C_FB devuelve el valor "0", el estado lógico del parámetro OA se pone a "0". El valor del
parámetro ET se pone al del parámetro PT. Si el estado lógico del parámetro O_FB cambia
a "0", se activa la alarma en la siguiente ejecución de la instrucción. El valor del parámetro
CMD_HIS se pone al del parámetro CMD.

Programación del PLC
Manual de programación y manejo, 11/2019

2015

Instrucciones
4.1 Instrucciones
● Si los parámetros CMD, CMD_HIS y C_FB devuelven "0", la diferencia de tiempo (ms)
desde la última ejecución de la instrucción se suma al valor del parámetro ET. Si el valor del
parámetro ET excede el del parámetro PT, el estado lógico del parámetro CA se pone a "1".
Si no se excede el valor del parámetro PT, el parámetro CA devuelve el estado lógico "0".
El valor del parámetro CMD_HIS se pone al del parámetro CMD.
● Si los parámetros CMD, CMD_HIS y O_FB devuelven el estado lógico "0" y el parámetro
C_FB está a "1", el parámetro CA se pone a "0". El valor del parámetro ET se pone al del
parámetro PT. Si el estado lógico del parámetro C_FB cambia a "0", se activa la alarma en
la siguiente ejecución de la instrucción. El valor del parámetro CMD_HIS se pone al del
parámetro CMD.
● Si los parámetros O_FB y C_FB devuelven simultáneamente el estado lógico "1", los
estados lógicos de ambas salidas de alarma se ponen a "1".
La instrucción "Alarma de tiempo para control discreto" no devuelve información de error.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de da‐ Área de memoria Descripción
tos

CMD

Input

BOOL

I, Q, M, D, L

El estado lógico "0" da la orden de
"Cerrar".
El estado lógico "1" da la orden de
"Abrir".

O_FB

Input

BOOL

I, Q, M, D, L

Entrada de realimentación al abrir

C_FB

Input

BOOL

I, Q, M, D, L

Entrada de realimentación al ce‐
rrar

Q

Output

BOOL

I, Q, M, D, L

Indica el estado del parámetro
CMD

OA

Output

BOOL

I, Q, M, D, L

Salida de alarma al abrir

CA

Output

BOOL

I, Q, M, D, L

Salida de alarma al cerrar

ET

Static

DINT

D, L

Tiempo actual transcurrido; un ci‐
clo de reloj = 1 ms.

PT

Static

DINT

D, L

Valor de tiempo predeterminado;
un ciclo de reloj = 1 ms.

PREV_TIME

Static

DWORD

D, L

Hora de sistema anterior

CMD_HIS

Static

BOOL

D, L

Bit de evolución de CMD

Los parámetros estáticos no son visibles al efectuar la llamada de la instrucción en el
programa. Estos se almacenan en la instancia de la instrucción.

2016

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
En el ejemplo siguiente, el parámetro CMD cambia de "0" a "1". Una vez ejecutada la
instrucción, el parámetro Q se pone a "1" y las dos salidas de alarma OA y CA se ponen a "0".
El parámetro CMD_HIS del bloque de datos de instancia se pone a "1" y el parámetro ET se
pone a "0".
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

SCL
"DCAT_DB"(CMD := "Tag_Input_CMD",
O_FB := "Tag_Input_O_FB",
C_FB := "Tag_Input_C_FB",
Q => "Tag_Output_Q",
OA => "Tag_Output_OA",
CA => "Tag_Output_CA");

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.
Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada y salida:
Parámetro

Operando

Valor

CMD

Tag_Input_CMD

TRUE

O_FB

Tag_Input_O_FB

FALSE

C_FB

Tag_Input_C_FB

FALSE

Q

Tag_Output_Q

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Los siguientes valores se almacenan en el bloque de datos de instancia "DCAT_DB" de la
instrucción:
Parámetro

Dirección

Valor

ET

DBD4

L#12

PT

DBD8

L#222

CMD_HIS

DBX16.0

FALSE

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

Q

Tag_Output_Q

TRUE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Programación del PLC
Manual de programación y manejo, 11/2019

2017

Instrucciones
4.1 Instrucciones
Los siguientes valores se almacenan en el bloque de datos de instancia "DCAT_DB" de la
instrucción:
Parámetro

Dirección

Valor

ET

DBD4

L#0

CMD_HIS

DBX16.0

TRUE

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

MCAT: Alarma de tiempo para control del motor
Descripción
La instrucción "Alarma de tiempo para control del motor" acumula el tiempo desde el instante
en el que se activa una de las entradas de comando (abrir o cerrar). El tiempo se acumula hasta
que se excede el tiempo predeterminado o hasta que la entrada de realimentación
correspondiente indica que el dispositivo ha ejecutado la operación solicitada dentro del
tiempo prescrito. Si se excede el tiempo predeterminado antes de recibir respuesta, se dispara
la alarma correspondiente.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:

2018

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

O_CMD

Input

BOOL

I, Q, M, D, L

Entrada del comando "Abrir"

C_CMD

Input

BOOL

I, Q, M, D, L

Entrada del comando "Ce‐
rrar"

S_CMD

Input

BOOL

I, Q, M, D, L

Entrada del comando "Parar"

O_FB

Input

BOOL

I, Q, M, D, L

Entrada de respuesta al abrir

C_FB

Input

BOOL

I, Q, M, D, L

Entrada de respuesta al ce‐
rrar

OO

Output

BOOL

I, Q, M, D, L

Salida "Abrir"

CO

Output

BOOL

I, Q, M, D, L

Salida "Cerrar"

OA

Output

BOOL

I, Q, M, D, L

Salida de alarma al abrir

CA

Output

BOOL

I, Q, M, D, L

Salida de alarma al cerrar

Q

Output

BOOL

I, Q, M, D, L

El estado lógico "0" indica
una condición de error.

ET

Static

DINT

D, L

Tiempo actual transcurrido;
un ciclo de reloj = 1 ms

PT

Static

DINT

D, L

Valor de tiempo predetermi‐
nado; un ciclo de reloj = 1 ms

PREV_TIME

Static

DWORD

D, L

Hora de sistema anterior

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

O_HIS

Static

BOOL

D, L

Bit de evolución "Abrir"

C_HIS

Static

BOOL

D, L

Bit de evolución "Cerrar"

Los parámetros estáticos no son visibles al llamar la instrucción en el programa. Estos se
almacenan en la instancia de la instrucción.

Ejecución de la instrucción "Alarma de tiempo para control del motor"
La tabla siguiente muestra las reacciones de la instrucción "Alarma de tiempo para control del
motor" a las distintas condiciones de entrada:
Parámetros de entrada
O_C
MD

Parámetros de salida

ET

O_H
IS

C_H
IS

C_C
MD

S_C
MD

X

1

1

X

X

X

X

X

X

X

X

X

X

X

X

X

X

1

X

X

X

1

1

X

X

0

X

1

0

<PT

1

0

X

0

O_F
B

C_F
B

OO

CO

OA

CA

ET

O_H
IS

C_HI Q
S

Estado

X

X

0

0

1

1

PT

0

0

0

Alarma

1

1

0

0

1

1

PT

0

0

0

Alarma

X

X

0

0

0

0

X

0

0

1

Stop

X

X

0

0

0

0

X

0

0

1

Stop

0

X

X

1

0

0

0

0

1

0

1

Empezar a
abrir

0

0

X

1

0

0

0

INC

1

0

1

Abrir

X

1

0

X

0

0

1

0

0

0

0

0

PT

1

0

1

Abierto

>=
PT

1

0

X

0

0

0

X

0

0

1

0

PT

1

0

0

Abrir alarma

X

X

0

0

1

0

X

X

0

1

0

0

0

0

1

1

Empezar a
cerrar

< PT 0

1

0

X

0

X

0

0

1

0

0

INC

0

1

1

Cerrar

X

0

1

0

X

0

0

1

0

0

0

0

PT

0

1

1

Cerrado

>=
PT

0

1

0

X

0

X

0

0

0

0

1

PT

0

1

0

Cerrar alar‐
ma

X

0

0

0

0

0

X

X

0

0

0

0

X

0

0

1

Parado

Leyenda:
INC

Sumar a ET la diferencia de tiempo (en ms) desde la última ejecución del FB

PT

PT se pone al mismo valor que ET

X

No aplicable

< PT

ET < PT

Programación del PLC
Manual de programación y manejo, 11/2019

2019

Instrucciones
4.1 Instrucciones
Parámetros de entrada
>= PT

Parámetros de salida

ET >= PT

Si los parámetros de entrada O_HIS y C_HIS tienen el estado lógico "1", se ponen inmediatamente al estado lógico "0". En
este caso se aplica la última fila de la tabla mencionada más arriba (X). Puesto que por este motivo no es posible comprobar
si los parámetros de entrada O_HIS y C_HIS tienen el estado lógico "1", en este caso se asigna el siguiente valor a los
parámetros de salida:
OO = FALSE
CO = FALSE
OA = FALSE
CA = FALSE
ET = PT
Q = TRUE

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

SCL
"MCAT_DB"(O_CMD := "Tag_Iput_O_CMD",
C_CMD := "Tag_Input_C_CMD",
S_CMD := "Tag_Input_S_CMD",
O_FB := "Tag_Input_O_FB",
C_FB := "Tag_Input_C_FB",
OO => "Tag_OutputOpen",
CO => "Tag_OutputClosed",
OA => "Tag_Output_OA",
CA => "Tag_Output_CA",
Q => "Tag_Output_Q");

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.
Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada y salida:

2020

Parámetro

Operando

Valor

O_CMD

Tag_Input_O_CMD

TRUE

C_CMD

Tag_Input_C_CMD

FALSE

S_CMD

Tag_Input_S_CMD

FALSE

O_FB

Tag_Input_O_FB

FALSE

C_FB

Tag_Input_C_FB

FALSE

OO

Tag_OutputOpen

FALSE

CO

Tag_OutputClosed

FALSE

OA

Tag_Output_OA

FALSE

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Operando

Valor

CA

Tag_Output_CA

FALSE

Q

Tag_Output_Q

FALSE

En el bloque de datos de instancia "MCAT_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

ET

DBD4

L#2

PT

DBD8

L#22

O_HIS

DBX16.0

TRUE

C_HIS

DBX16.1

FALSE

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

OO

Tag_OutputOpen

TRUE

CO

Tag_OutputClosed

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Q

Tag_Output_Q

TRUE

En el bloque de datos de instancia "MCAT_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

ET

DBD4

L#0

O_HIS

DBX16.0

TRUE

CMD_HIS

DBX16.1

FALSE

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

2021

Instrucciones
4.1 Instrucciones

IMC: Comparar bits de entrada con bits de una máscara
Descripción
La instrucción "Comparar bits de entrada con bits de una máscara" compara el estado lógico
de hasta 16 bits de entrada programados (IN_BIT0 a IN_BIT15) con el bit correspondiente de
una máscara. Es posible programar como máximo 16 pasos con máscaras. El valor del
parámetro IN_BIT0 se compara con el valor de la máscara CMP_VAL[x,0], siendo "x" el
número del paso. El número del paso de la máscara utilizada para la comparación se define en
el parámetro CMP_STEP. De esta misma manera se comparan todos los valores
programados. Los bits de entrada no programados o los bits no programados de la máscara
tienen el estado lógico predeterminado FALSE.
Si se encuentra una correspondencia al realizar la comparación, el estado lógico del parámetro
OUT se pone a "1". De lo contrario, el parámetro OUT se pone a "0".
Si el valor del parámetro CMP_STEP es mayor que 15, no se ejecuta la instrucción. En el
parámetro ERR_CODE se emite un mensaje de error.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:

2022

Parámetro

Declara‐
ción

Tipo de datos

Área de memoria

Descripción

IN_BIT0

Input

BOOL

I, Q, M, D, L

El bit de entrada 0 se compara con el
bit 0 de la máscara.

IN_BIT1

Input

BOOL

I, Q, M, D, L

El bit de entrada 1 se compara con el
bit 1 de la máscara.

IN_BIT2

Input

BOOL

I, Q, M, D, L

El bit de entrada 2 se compara con el
bit 2 de la máscara.

IN_BIT3

Input

BOOL

I, Q, M, D, L

El bit de entrada 3 se compara con el
bit 3 de la máscara.

IN_BIT4

Input

BOOL

I, Q, M, D, L

El bit de entrada 4 se compara con el
bit 4 de la máscara.

IN_BIT5

Input

BOOL

I, Q, M, D, L

El bit de entrada 5 se compara con el
bit 5 de la máscara.

IN_BIT6

Input

BOOL

I, Q, M, D, L

El bit de entrada 6 se compara con el
bit 6 de la máscara.

IN_BIT7

Input

BOOL

I, Q, M, D, L

El bit de entrada 7 se compara con el
bit 7 de la máscara.

IN_BIT8

Input

BOOL

I, Q, M, D, L

El bit de entrada 8 se compara con el
bit 8 de la máscara.

IN_BIT9

Input

BOOL

I, Q, M, D, L

El bit de entrada 9 se compara con el
bit 9 de la máscara.

IN_BIT10

Input

BOOL

I, Q, M, D, L

El bit de entrada 10 se compara con
el bit 10 de la máscara.

IN_BIT11

Input

BOOL

I, Q, M, D, L

El bit de entrada 11 se compara con
el bit 11 de la máscara.

IN_BIT12

Input

BOOL

I, Q, M, D, L

El bit de entrada 12 se compara con
el bit 12 de la máscara.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción

Tipo de datos

Área de memoria

Descripción

IN_BIT13

Input

BOOL

I, Q, M, D, L

El bit de entrada 13 se compara con
el bit 13 de la máscara.

IN_BIT14

Input

BOOL

I, Q, M, D, L

El bit de entrada 14 se compara con
el bit 14 de la máscara.

IN_BIT15

Input

BOOL

I, Q, M, D, L

El bit de entrada 15 se compara con
el bit 15 de la máscara.

CMP_STEP Input

BYTE

I, Q, M, D, L, P

Número de paso de la máscara con
la que se compara.

OUT

BOOL

I, Q, M, D, L

El estado lógico "1" indica que se ha
encontrado una correspondencia.

Output

El estado lógico "0" indica que no se
ha encontrado ninguna correspon‐
dencia.
ERR_CO‐
DE

Output

WORD

I, Q, M, D, L, P

Información de error

CMP_VAL

Static

ARRAY OF
WORD

I, Q, M, D, L

Máscaras de comparación [0 a 15, 0
a 15]: El primer número del índice es
el número del paso y, el segundo, el
número de bit de la máscara.

Los parámetros estáticos no son visibles al efectuar la llamada de la instrucción en el
programa. Estos se almacenan en la instancia de la instrucción.

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

000A

El valor del parámetro CMP_STEP es mayor que 15.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

2023

Instrucciones
4.1 Instrucciones

SMC: Barrido de matriz
Descripción
La instrucción "Barrido de matriz" compara el estado lógico de hasta 16 bits de entrada
programados (IN_BIT0 a IN_BIT15) con los bits correspondientes de las máscaras de
comparación de cada paso. La ejecución empieza por el paso 1 y continúa hasta el último paso
programado (LAST) o hasta que se encuentre una correspondencia. El bit de entrada del
parámetro IN_BIT0 se compara con el valor de la máscara CMP_VAL[x,0], siendo "x" el
número de paso. De esta misma manera se comparan todos los valores programados. Si se
encuentra una correspondencia, el estado lógico del parámetro OUT se pone a "1" y el número
de paso se escribe con la máscara correspondiente en el parámetro OUT_STEP. Los bits de
entrada no programados o los bits no programados de la máscara tienen el estado lógico
predeterminado FALSE. Si varios pasos tienen una máscara equivalente, se indica solo la
primera correspondencia encontrada en el parámetro OUT_STEP. Si no se encuentra ninguna
correspondencia, el estado lógico del parámetro OUT se pone a "0". En este caso, el valor del
parámetro OUT_STEP excede en "1" el valor del parámetro LAST.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:

2024

Parámetros

Declara‐
ción

Tipo de datos

Área de memoria

Descripción

IN_BIT0

Input

BOOL

I, Q, M, D, L

El bit de entrada 0 se compara con el
bit 0 de la máscara.

IN_BIT1

Input

BOOL

I, Q, M, D, L

El bit de entrada 1 se compara con el
bit 1 de la máscara.

IN_BIT2

Input

BOOL

I, Q, M, D, L

El bit de entrada 2 se compara con el
bit 2 de la máscara.

IN_BIT3

Input

BOOL

I, Q, M, D, L

El bit de entrada 3 se compara con el
bit 3 de la máscara.

IN_BIT4

Input

BOOL

I, Q, M, D, L

El bit de entrada 4 se compara con el
bit 4 de la máscara.

IN_BIT5

Input

BOOL

I, Q, M, D, L

El bit de entrada 5 se compara con el
bit 5 de la máscara.

IN_BIT6

Input

BOOL

I, Q, M, D, L

El bit de entrada 6 se compara con el
bit 6 de la máscara.

IN_BIT7

Input

BOOL

I, Q, M, D, L

El bit de entrada 7 se compara con el
bit 7 de la máscara.

IN_BIT8

Input

BOOL

I, Q, M, D, L

El bit de entrada 8 se compara con el
bit 8 de la máscara.

IN_BIT9

Input

BOOL

I, Q, M, D, L

El bit de entrada 9 se compara con el
bit 9 de la máscara.

IN_BIT10

Input

BOOL

I, Q, M, D, L

El bit de entrada 10 se compara con
el bit 10 de la máscara.

IN_BIT11

Input

BOOL

I, Q, M, D, L

El bit de entrada 11 se compara con
el bit 11 de la máscara.

IN_BIT12

Input

BOOL

I, Q, M, D, L

El bit de entrada 12 se compara con
el bit 12 de la máscara.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetros

Declara‐
ción

Tipo de datos

Área de memoria

Descripción

IN_BIT13

Input

BOOL

I, Q, M, D, L

El bit de entrada 13 se compara con
el bit 13 de la máscara.

IN_BIT14

Input

BOOL

I, Q, M, D, L

El bit de entrada 14 se compara con
el bit 14 de la máscara.

IN_BIT15

Input

BOOL

I, Q, M, D, L

El bit de entrada 15 se compara con
el bit 15 de la máscara.

OUT

Output

BOOL

I, Q, M, D, L

El estado lógico "1" indica que se ha
encontrado una correspondencia.
El estado lógico "0" indica que no se
ha encontrado ninguna correspon‐
dencia.

OUT_STEP

Output

BYTE

I, Q, M, D, L, P

Contiene el número de paso con la
máscara correspondiente o el núme‐
ro de paso que excede en "1" el valor
del parámetro LAST, si no se ha en‐
contrado ninguna correspondencia.

ERR_CO‐
DE

Output

WORD

I, Q, M, D, L, P

Información de error

LAST

Static

BYTE

I, Q, M, D, L, P

Indica el número del último paso en
que se tiene que buscar una máscara
correspondiente.

CMP_VAL

Static

ARRAY OF
WORD

I, Q, M, D, L

Máscaras de comparación [0 a 15, 0
a 15]: El primer número del índice es
el número del paso y, el segundo, el
número de bit de la máscara.

Los parámetros estáticos no son visibles al efectuar la llamada de la instrucción en el
programa. Estos se almacenan en la instancia de la instrucción.

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

000E

El valor del parámetro LAST es mayor que 15.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de SCL (Página 8115)

Programación del PLC
Manual de programación y manejo, 11/2019

2025

Instrucciones
4.1 Instrucciones

LEAD_LAG: Algoritmo Lead y Lag
Descripción
La instrucción "Algoritmo Lead y Lag" procesa señales con una variable analógica. El valor de
la ganancia en el parámetro GAIN debe ser mayor que cero. El resultado de la instrucción
"Algoritmo Lead y Lag" se calcula con la siguiente ecuación:
287

/*B7,0(
/'B7,0(6$03/(B7
/'B7,0(
,1*$,1
35(9B287*$,1
/*B7,0(6$03/(B7
/*B7,0(6$03/(B7
/*B7,0(6$03/(B7

35(9B,1

La instrucción "Algoritmo Lead y Lag" solo devuelve resultados relevantes cuando se ejecuta
en ciclos de programa fijos. Deben indicarse las mismas unidades en los parámetros
LD_TIME, LG_TIME y SAMPLE_T. Si LG_TIME > 4 + SAMPLE_T, la instrucción se aproxima
a la siguiente función:
OUT = GAIN * ((1 + LD_TIME * s) / (1 + LG_TIME * s)) * IN
Si el valor del parámetro GAIN es menor o igual a cero, no se realiza el cálculo y el parámetro
ERR_CODE devuelve una información de error.
La instrucción "Algoritmo Lead y Lag" puede utilizarse junto con bucles para la compensación
en el control anticipativo. La instrucción comprende dos operaciones. La operación "Lead"
desplaza la fase de la salida OUT, anticipándose la salida a la entrada. En cambio, la operación
"Lag" desplaza la salida, de manera que la salida sigue a la entrada. Puesto que la operación
"Lag" equivale a una integración, puede utilizarse como supresor de perturbaciones o filtro de
paso bajo. La operación "Lead" equivale a una acción diferencial, por lo que puede utilizarse
como un filtro de paso alto. La combinación de ambas operaciones (Lead y Lag) hace que la
fase de salida siga a la entrada a bajas frecuencias y se le anticipe a altas frecuencias. Por este
motivo, la instrucción "Algoritmo Lead y Lag" puede utilizarse como si fuera un filtro de paso de
banda.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

REAL

I, Q, M, D, L, P

Valor de entrada
del tiempo de
muestreo actual
(tiempo de ciclo)
que se procesa.
En el parámetro IN
también se pueden
indicar constantes.

SAMPLE_T

Input

INT

I, Q, M, D, L, P

Tiempo de mues‐
treo
En el parámetro
SAMPLE_T tam‐
bién se pueden in‐
dicar constantes.

OUT

2026

Output

REAL

I, Q, M, D, L

Resultado de la ins‐
trucción

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ERR_CODE

Output

WORD

I, Q, M, D, L

Información de
error

LD_TIME

Static

REAL

I, Q, M, D, L, P

Tiempo de anticipa‐
ción en la misma
unidad que el tiem‐
po de muestreo.

LG_TIME

Static

REAL

I, Q, M, D, L, P

Tiempo de segui‐
miento en la misma
unidad que el tiem‐
po de muestreo.

GAIN

Static

REAL

I, Q, M, D, L, P

Ganancia en % / %
(relación del cam‐
bio en la salida con
respecto al cambio
en la entrada como
estado constante).

PREV_IN

Static

REAL

I, Q, M, D, L, P

Entrada anterior

PREV_OUT

Static

REAL

I, Q, M, D, L, P

Salida anterior

Los parámetros estáticos no son visibles al efectuar la llamada de la instrucción en el
programa. Estos se almacenan en la instancia de la instrucción.

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

0009

El valor del parámetro GAIN es menor o igual a cero.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

SCL
"LEAD_LAG_DB"(IN := "Tag_Input",
SAMPLE_T := "Tag_Input_SAMPLE_T",
OUT => "Tag_Output_Result",
ERR_CODE => "Tag_ErrorCode");

Programación del PLC
Manual de programación y manejo, 11/2019

2027

Instrucciones
4.1 Instrucciones
Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.
Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada:
Parámetro

Operando

Valor

IN

Tag_Input

2.0

SAMPLE_T

Tag_Input_SAMPLE_T

10

Los siguientes valores se almacenan en el bloque de datos de instancia "LEAD_LAG_DB" de
la instrucción:
Parámetro

Dirección

Valor

LD_TIME

DBD12

2.0

LG_TIME

DBD16

2.0

GAIN

DBD20

1.0

PREV_IN

DBD24

6.0

PREV_OUT

DBD28

6.0

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

OUT

Tag_Output_Result

2.0

Los siguientes valores se guardan en el bloque de datos de instancia "LEAD_LAD_DB" de la
instrucción:
Parámetro

Operando

Valor

PREV_IN

DBD24

2.0

PREV_OUT

DBD28

2.0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de SCL (Página 8115)

SEG: Generar patrón de bits para el display de 7 segmentos
Descripción
La instrucción "Generar patrón de bits para el display de 7 segmentos" convierte cada una de
las cuatro cifras hexadecimales de la palabra de origen indicada (IN) en un patrón de bits
equivalente para un display de 7 segmentos. El resultado de la instrucción se deposita en la
palabra doble del parámetro OUT.

2028

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Entre las cifras hexadecimales y la ocupación de los 7 segmentos (a, b, c, d, e, f, g) existe la
siguiente relación:
Cifra de en‐
trada

Ocupación de los
segmentos

Display

(binaria)

‑gfedcba

0000

00111111

0

0001

00000110

1

0010

01011011

2

0011

01001111

3

0100

01100110

4

0101

01101101

5

0110

01111101

6

0111

00000111

7

1000

01111111

8

1001

01100111

9

1010

01110111

A

1011

01111100

B

1100

00111001

C

1101

01011110

D

1110

01111001

E

1111

01110001

F

Display de siete segmentos

(hexadecimal)
D
I

E
J

H

F
G

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

WORD

I, Q, M, D, L, P

Palabra de origen
con cuatro cifras
hexadecimales

OUT

Output

DWORD

I, Q, M, D, L, P

Patrón de bits para
el display de 7 seg‐
mentos

Valor de función

VOID

Valor de función va‐
cío

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
SEG(IN := "Tag_Input",
OUT => "Tag_Output");

Programación del PLC
Manual de programación y manejo, 11/2019

2029

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor
Hexadecimal

Binario

IN

Tag_Input

W#16#1234

0001 0010 0011 0100

OUT

Tag_Output

DW16#065B4F66

00000110 01011011 01001111
01100110
Visualización: 1234

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de SCL (Página 8115)

BCDCPL: Generar complemento a diez
Descripción
La instrucción "Generar complemento a diez" crea el complemento a diez de un número BCD
de siete dígitos que se indica en el operando. La instrucción realiza el cálculo con la siguiente
fórmula matemática:
10000000 (como BCD)
– Valor BCD de 7 dígitos
---------------------------------------Complemento a diez (como BCD)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Secuencias de
bits

I, Q, M, D, L, P

Número BCD de 7
dígitos

DWORD

I, Q, M, D, L, P

Resultado de la ins‐
trucción

Valor de función

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

2030

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := BCDCPL("Tag_Input");

La tabla siguiente muestra el funcionamiento de la instrucción con valores concretos:
Operando

Valor*

Tag_Input

DW#16#01234567

Tag_Result

DW#16#08765433

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de SCL (Página 8115)

BITSUM: Contar número de bits activados
Descripción
La instrucción "Contar número de bits activados" cuenta el número de bits de un operando que
están puestos al estado lógico "1".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

DWORD

I, Q, M, D, L, P

Operando cuyos
bits activados se
cuentan

INT

I, Q, M, D, L, P

Resultado de la ins‐
trucción

Valor de función

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
SCL
"Tag_Result" := BITSUM("Tag_Input");

Programación del PLC
Manual de programación y manejo, 11/2019

2031

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores concretos:
Operando

Valor*

Tag_Input

DW#16#12345678

Tag_Result

W#16#000D (13 bits)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de SCL (Página 8115)

4.1.3.5

GRAPH

Cadena GRAPH
Etapa y transición
Descripción
El componente de estructura "Etapa y transición" permite insertar simultáneamente una etapa
y una transición en la cadena secuencial.
Consulte también:
Etapa (Página 2033)
Transición (Página 2033)

Consulte también
Etapa (Página 2033)
Transición (Página 2033)
Fin de cadena (Página 2034)
Salto a etapa (Página 2034)
Rama alternativa (Página 2035)
Rama simultánea (Página 2035)
Cerrar rama (Página 2036)
Etapas y transiciones (Página 8198)

2032

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Etapa
Descripción
Las etapas sirven para dividir las tareas de automatización complejas en tareas más pequeñas
y claras que, seguidamente, se llevan a cabo por medio de acciones. Las diferentes etapas se
organizan en cadenas secuenciales, de modo que al ejecutar el programa cada etapa se
procesa en el orden especificado. Cada etapa debe tener un nombre y un número unívocos.
Para que el procesamiento se lleve a cabo realmente, la etapa debe activarse con una de las
condiciones siguientes:
● La etapa se ha definido como inicial.
● Se cumple la transición de la etapa anterior.
● La etapa es llamada por una acción controlada por evento.
Una vez se han procesado todas las acciones se vuelve a desactivar la etapa.
Las etapas en las que no hay ninguna acción programada se denominan etapas vacías. Una
etapa vacía tiene el mismo comportamiento que una etapa activa y la transición siguiente
siempre se cumple.

Consulte también
Principios básicos de las etapas (Página 8198)
Etapa y transición (Página 2032)
Transición (Página 2033)
Fin de cadena (Página 2034)
Salto a etapa (Página 2034)
Rama alternativa (Página 2035)
Rama simultánea (Página 2035)
Cerrar rama (Página 2036)

Transición
Descripción
Las transiciones se encuentran entre una etapa y otra y contienen las condiciones para pasar
de una etapa a la siguiente. Cuando se cumplen las condiciones de continuación de una
transición, se activa la etapa siguiente y se procesan sus acciones. Las condiciones de una
transición se programan en KOP o FUP.

Consulte también
Principios básicos de las transiciones (Página 8200)
Etapa y transición (Página 2032)

Programación del PLC
Manual de programación y manejo, 11/2019

2033

Instrucciones
4.1 Instrucciones
Etapa (Página 2033)
Fin de cadena (Página 2034)
Salto a etapa (Página 2034)
Rama alternativa (Página 2035)
Rama simultánea (Página 2035)
Cerrar rama (Página 2036)

Fin de cadena
Descripción
El componente de estructura "Fin de cadena" permite finalizar una cadena secuencial o una
rama. En una rama simultánea, sin embargo, el fin de cadena debe estar precedido de una
transición.
Nota
Si todas las ramas de una cadena secuencial se cierran con un fin de cadena, es posible volver
a iniciar la cadena secuencial con el parámetro "INIT_SQ" o con el botón "Inicializar" de la Task
Card "Test" en la paleta "Control secuencial".

Consulte también
Elementos de una cadena secuencial (Página 8194)
Etapa y transición (Página 2032)
Etapa (Página 2033)
Transición (Página 2033)
Salto a etapa (Página 2034)
Rama alternativa (Página 2035)
Rama simultánea (Página 2035)
Cerrar rama (Página 2036)

Salto a etapa
Descripción
Con un salto se prosigue la ejecución del programa en una etapa cualquiera dentro del bloque
de función GRAPH. Los saltos pueden insertarse al final de la rama principal o de una rama
alternativa, de modo que sea posible procesar la cadena secuencial cíclicamente. El salto y su
destino se representan en la cadena secuencial en forma de flecha, de modo que en el destino
del salto se indica la transición de origen.

2034

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Elementos de una cadena secuencial (Página 8194)
Etapa y transición (Página 2032)
Etapa (Página 2033)
Transición (Página 2033)
Fin de cadena (Página 2034)
Rama alternativa (Página 2035)
Rama simultánea (Página 2035)
Cerrar rama (Página 2036)

Rama alternativa
Descripción
Las ramas alternativas permiten programar ramas O. Esto significa que, después de una
etapa, se insertan ramas que empiezan con una transición. En función de la transición que se
cumpla primero se ejecutará la rama correspondiente. Si se cumplen varias transiciones al
mismo tiempo, tendrá prioridad la transición que esté más a la izquierda y se ejecutará la rama
correspondiente. Las ramas alternativas finalizan con otra transición.
Es posible programar un máximo de 125 ramas alternativas en una cadena secuencial.

Consulte también
Elementos de una cadena secuencial (Página 8194)
Etapa y transición (Página 2032)
Etapa (Página 2033)
Transición (Página 2033)
Fin de cadena (Página 2034)
Salto a etapa (Página 2034)
Rama simultánea (Página 2035)
Cerrar rama (Página 2036)

Rama simultánea
Descripción
Las ramas simultáneas permiten programar ramas Y. Esto significa que con una transición se
activan varias etapas cuyas acciones se ejecutarán a continuación. Por ese motivo, las ramas
simultáneas empiezan y terminan siempre con una etapa.

Programación del PLC
Manual de programación y manejo, 11/2019

2035

Instrucciones
4.1 Instrucciones
Las transiciones posteriores de las ramas simultáneas se encuentran en la rama principal, de
modo que las diferentes ramas simultáneas pueden cerrarse en diferentes puntos de la rama
principal. Tenga en cuenta que las ramas que se agrupan en una transición no conmutarán a
la etapa siguiente, hasta que no se hayan ejecutado por completo dichas ramas.
Es posible programar un máximo de 249 ramas simultáneas en una cadena secuencial.

Consulte también
Elementos de una cadena secuencial (Página 8194)
Etapa y transición (Página 2032)
Etapa (Página 2033)
Transición (Página 2033)
Fin de cadena (Página 2034)
Salto a etapa (Página 2034)
Rama alternativa (Página 2035)
Cerrar rama (Página 2036)

Cerrar rama
Descripción
El elemento "Cerrar rama" permite cerrar ramas simultáneas o alternativas y llevarlas a su
rama matriz. Esto debe hacerse cuando la rama no se cierra con un salto o un fin de cadena.
En una rama simultánea solo es posible insertar "Cerrar rama" después de una etapa.

Consulte también
Elementos de una cadena secuencial (Página 8194)
Etapa y transición (Página 2032)
Etapa (Página 2033)
Transición (Página 2033)
Fin de cadena (Página 2034)
Salto a etapa (Página 2034)
Rama alternativa (Página 2035)
Rama simultánea (Página 2035)

2036

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Acciones GRAPH
Temporizadores
TP: Impulso
Descripción
La instrucción "Impulso" activa la salida Q por un tiempo programado. La instrucción se inicia
cuando el resultado lógico (RLO) del parámetro IN cambia de "0" a "1" (flanco de señal
ascendente). Cuando se inicia la instrucción, se empieza a contar el tiempo programado PT.
El parámetro Q se activa por el tiempo PT, independientemente de cómo evolucione la señal
de entrada. Durante el tiempo PT, la detección de un nuevo flanco de señal ascendente en la
entrada IN no influye en el estado lógico de la salida Q.
El valor actual de tiempo se puede consultar en el parámetro ET. Este valor de tiempo empieza
a partir de T#0s y termina al alcanzarse el valor del tiempo PT. Si cuando se alcanza el tiempo
PT el estado lógico del parámetro IN es "0", se resetea el parámetro ET. Si en el programa no
se llama la instrucción porque, p. ej., esta se omite, la salida ET devuelve un valor constante
en cuanto transcurre este tiempo.
La instrucción "Impulso" se puede colocar dentro o al final del segmento. Dicha instrucción
requiere una operación lógica precedente.
A cada llamada de la instrucción "Impulso" debe asignársele un temporizador CEI, en el que
se guarden los datos de instancia. El temporizador CEI es una estructura del tipo de datos
IEC_TIMER, IEC_LTIMER, TP_TIME o TP_LTIME que se puede declarar como se indica a
continuación:
● Declaración de un bloque de datos del tipo de datos de sistema IEC_TIMER o IEC_LTIMER
(p. ej., "MyIEC_TIMER")
● Declaración como variable local del tipo TP_TIME, TP_LTIME, IEC_TIMER o IEC_LTIMER
en la sección "Static" de un bloque (p. ej., #MyIEC_TIMER)

Programación del PLC
Manual de programación y manejo, 11/2019

2037

Instrucciones
4.1 Instrucciones

Actualización de los valores actuales en los datos de instancia
Los datos de instancia de "Impulso" se actualizan siguiendo las reglas indicadas a
continuación:
● Entrada IN
La instrucción "Impulso" compara el RLO actual con el RLO de la consulta anterior, que está
almacenado en el parámetro IN de los datos de instancia. Si la instrucción detecta un
cambio del RLO de "0" a "1", significa que hay un flanco de señal ascendente y se empieza
a medir el tiempo. Una vez procesada la instrucción "Impulso", el valor del parámetro IN se
actualiza en los datos de instancia y se utiliza como marca de flancos para la siguiente
consulta.
Tenga en cuenta que la evaluación de flancos falla cuando el valor actual del parámetro IN
es escrito o inicializado por otras funciones.
● Entrada PT
El valor de la entrada PT se escribe en el parámetro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
● Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
– Al llamar la instrucción, si las salidas ET o Q están interconectadas.
O bien:
– Al acceder a Q o ET.
Si las salidas no están interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucción se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan parámetros internos de la
instrucción "Impulso". Tenga en cuenta que la medición de tiempo falla cuando los valores
actuales de la instrucción son escritos o inicializados por otras funciones.

2038

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está midiendo el
tiempo, se interfiere en la función del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse daños materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de arranque

PT

Input

TIME, LTIME

I, Q, M, D, L, P o
constante

Duración del impulso.
El valor del parámetro PT de‐
be ser positivo.

Q

Output

BOOL

I, Q, M, D, L, P

Salida de impulso

ET

Output

TIME, LTIME

I, Q, M, D, L, P

Valor de tiempo actual

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

2039

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el cronograma de impulsos de la instrucción "Impulso" tras el
arranque:
,1

4

37

37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL TP TIME, "IEC_TP_DB"
(IN := "Tag_Start"
PT := "Tag_PresetTIME"
Q => "Tag_Status"
ET => "Tag_ElapsedTIME"
)

Cuando el estado lógico del operando "Tag_Start" cambia de "0" a "1", el tiempo programado
en el parámetro PT empieza a contar y el operando "Tag_Status" se pone a "1". El valor de
tiempo actual se guarda en el operando "Tag_ElapsedTIME".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

2040

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

TON: Retardo al conectar
Descripción
La instrucción "Retardo al conectar" retarda la activación de la salida Q por el tiempo
programado PT. La instrucción se inicia cuando el resultado lógico (RLO) del parámetro IN
cambia de "0" a "1" (flanco de señal ascendente). Cuando se inicia la instrucción, se empieza
a contar el tiempo programado PT. Una vez transcurrido el tiempo PT, el parámetro Q devuelve
el estado lógico "1". El parámetro Q permanecerá activado mientras la entrada de arranque IN
esté puesta a "1". Cuando el estado lógico de la entrada de arranque cambia de "1" a "0", se
desactiva el parámetro Q. La función de temporización se reinicia al detectarse un nuevo
flanco de señal ascendente en la entrada de arranque.
El valor de tiempo actual se puede consultar en la salida ET. Este valor de tiempo empieza a
partir de T#0s y termina al alcanzarse el valor del tiempo PT. El parámetro ET se inicializa en
cuanto el estado lógico de la entrada IN cambia a "0". Si en el programa no se llama la
instrucción porque, p. ej., esta se omite, la salida ET devuelve un valor constante en cuanto ha
transcurrido el tiempo PT.
La instrucción "Retardo al conectar" se puede colocar dentro o al final del segmento. Dicha
instrucción requiere una operación lógica precedente.
A cada llamada de la instrucción "Retardo al conectar" debe asignársele un temporizador CEI,
en el que se guarden los datos de instancia. El temporizador CEI es una estructura del tipo de
datos IEC_TIMER, IEC_LTIMER, TON_TIME o TON_LTIME que se puede declarar como se
indica a continuación:
● Declaración de un bloque de datos del tipo de datos de sistema IEC_TIMER o IEC_LTIMER
(p. ej., "MyIEC_TIMER")
● Declaración como variable local del tipo TON_TIME, TON_LTIME, IEC_TIMER o
IEC_LTIMER en la sección "Static" de un bloque (p. ej., #MyIEC_TIMER)

Programación del PLC
Manual de programación y manejo, 11/2019

2041

Instrucciones
4.1 Instrucciones

Actualización de los valores actuales en los datos de instancia
Los datos de instancia de "Retardo al conectar" se actualizan siguiendo las reglas indicadas a
continuación:
● Entrada IN
La instrucción "Retardo al conectar" compara el RLO actual con el RLO de la consulta
anterior, que está almacenado en el parámetro IN de los datos de instancia. Si la instrucción
detecta un cambio del RLO de "0" a "1", significa que hay un flanco de señal ascendente y
se empieza a medir el tiempo. Una vez procesada la instrucción "Retardo al conectar", el
valor del parámetro IN se actualiza en los datos de instancia y se utiliza como marca de
flancos para la siguiente consulta.
Tenga en cuenta que la evaluación de flancos falla cuando el valor actual del parámetro IN
es escrito o inicializado por otras funciones.
● Entrada PT
El valor de la entrada PT se escribe en el parámetro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
● Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
– Al llamar la instrucción, si las salidas ET o Q están interconectadas.
O bien:
– Al acceder a Q o ET.
Si las salidas no están interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucción se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan parámetros internos de la
instrucción "Retardo al conectar". Tenga en cuenta que la medición de tiempo falla cuando
los valores actuales de la instrucción son escritos o inicializados por otras funciones.

2042

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está midiendo el
tiempo, se interfiere en la función del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse daños materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de arranque

PT

Input

TIME, LTIME

I, Q, M, D, L, P o
constante

Tiempo del retardo al conec‐
tar
El valor del parámetro PT de‐
be ser positivo.

Q

Output

BOOL

I, Q, M, D, L, P

Estado lógico que se retarda
por el tiempo PT.

ET

Output

TIME, LTIME

I, Q, M, D, L, P

Valor de tiempo actual

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

2043

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el comportamiento de la instrucción "Retardo al conectar" tras el
arranque:
,1

4

37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL TON TIME, "IEC_TON_DB"
(IN := "Tag_Start"
PT := "Tag_PresetTIME"
Q => "Tag_Status"
ET => "Tag_ElapsedTIME"
)

Cuando el estado lógico del operando "Tag_Start" cambia de "0" a "1", el tiempo programado
en el parámetro PT empieza a contar. Una vez transcurrido el tiempo, el operando
"Tag_Status" se pone al estado lógico "1". El operando "Tag_Status" permanece a "1" mientras
el operando "Tag_Start" tenga el estado lógico "1". El valor de tiempo actual se guarda en el
operando "Tag_ElapsedTime". Cuando el estado lógico del operando "Tag_Start" cambia de
"1" a "0", se resetea el operando "Tag_Status".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

2044

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

TOF: Retardo al desconectar
Descripción
La instrucción "Retardo al desconectar" retarda la desactivación de la salida Q por el tiempo
programado PT. El parámetro Q se activa cuando el resultado lógico (RLO) del parámetro IN
cambia de "1" a "0" (flanco de señal descendente). Cuando el estado lógico del parámetro IN
cambia nuevamente a "1", el tiempo programado PT deja de contar. El parámetro Q
permanecerá activado mientras transcurra el tiempo PT. Una vez transcurrido el tiempo PT se
inicializa el parámetro Q. Si el estado lógico del parámetro IN cambia a "1" antes de que
transcurra el tiempo PT, se inicializa el temporizador. El estado lógico del parámetro Q
permanece a "1".
La instrucción "Retardo al desconectar" se puede colocar dentro o al final del segmento. Dicha
instrucción requiere una operación lógica precedente.
El valor de tiempo actual se puede consultar en el parámetro ET. Este valor de tiempo empieza
a partir de T#0s y termina al alcanzarse el valor del tiempo PT. Una vez transcurrido el tiempo
PT, el parámetro ET permanece al valor actual hasta que el parámetro IN vuelva a cambiar a
"1". Si el estado lógico de la entrada IN cambia a "1" antes de transcurrir el tiempo PT, la salida
ET adopta el valor T#0s. Si en el programa no se llama la instrucción porque, p. ej., esta se
omite, la salida ET devuelve un valor constante en cuanto transcurre este tiempo.
A cada llamada de la instrucción "Retardo al desconectar" debe asignársele un temporizador
CEI, en el que se guarden los datos de instancia. El temporizador CEI es una estructura del tipo
de datos IEC_TIMER, IEC_LTIMER, TOF_TIME o TOF_LTIME que se puede declarar como se
indica a continuación:
● Declaración de un bloque de datos del tipo de datos de sistema IEC_TIMER o IEC_LTIMER
(p. ej., "MyIEC_TIMER")
● Declaración como variable local del tipo TOF_TIME, TOF_LTIME, IEC_TIMER o
IEC_LTIMER en la sección "Static" de un bloque (p. ej., #MyIEC_TIMER)

Programación del PLC
Manual de programación y manejo, 11/2019

2045

Instrucciones
4.1 Instrucciones

Actualización de los valores actuales en los datos de instancia
Los datos de instancia de "Retardo al desconectar" se actualizan siguiendo las reglas
indicadas a continuación:
● Entrada IN
La instrucción "Retardo al desconectar" compara el RLO actual con el RLO de la consulta
anterior, que está almacenado en el parámetro IN de los datos de instancia. Si la instrucción
detecta un cambio del RLO de "1" a "0", significa que hay un flanco de señal descendente
y se empieza a contar el tiempo. Una vez procesada la instrucción "Retardo al
desconectar", el valor del parámetro IN se actualiza en los datos de instancia y se utiliza
como marca de flancos para la siguiente consulta.
Tenga en cuenta que la evaluación de flancos falla cuando el valor actual del parámetro IN
es escrito o inicializado por otras funciones.
● Entrada PT
El valor de la entrada PT se escribe en el parámetro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
● Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
– Al llamar la instrucción, si las salidas ET o Q están interconectadas.
O bien:
– Al acceder a Q o ET.
Si las salidas no están interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucción se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan parámetros internos de la
instrucción "Retardo al desconectar". Tenga en cuenta que la medición de tiempo falla
cuando los valores actuales de la instrucción son escritos o inicializados por otras
funciones.

2046

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está midiendo el
tiempo, se interfiere en la función del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse daños materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de arranque

PT

Input

TIME, LTIME

I, Q, M, D, L, P o
constante

Tiempo del retardo al desco‐
nectar
El valor del parámetro PT de‐
be ser positivo.

Q

Output

BOOL

I, Q, M, D, L, P

Estado lógico que se retarda
por el tiempo PT.

ET

Output

TIME, LTIME

I, Q, M, D, L, P

Valor de tiempo actual

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

2047

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el comportamiento de la instrucción "Retardo al desconectar" tras
el arranque:
,1

4
37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL TOF TIME, "IEC_TOF_DB"
(IN := "Tag_Start"
PT := "Tag_PresetTIME"
Q => "Tag_Status"
ET => "Tag_ElapsedTIME"
)

Si se produce un cambio del estado lógico del operando "Tag_Start" de "0" a "1", el operando
se pone a "Tag_Status". Cuando el estado lógico del operando "Tag_Start" cambia de "1" a "0",
el tiempo programado en el parámetro PT empieza a contar. Mientras transcurra el tiempo,
permanecerá activado el operando "Tag_Status". Una vez transcurrido el tiempo, el operando
"Tag_Status" se desactiva. El valor de tiempo actual se guarda en el operando
"Tag_ElapsedTIME".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

2048

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

TONR: Acumulador de tiempo
Descripción
La instrucción "Acumulador de tiempo" acumula valores de tiempo dentro de un periodo
definido por el parámetro PT. Cuando el estado lógico de la entrada IN cambia de "0" a "1"
(flanco de señal ascendente), se inicia la medición de tiempo y se empieza a contar el tiempo
PT. Mientras transcurre el tiempo PT se van acumulando los valores de tiempo que se leen
cuando el estado lógico de la entrada IN es "1". El tiempo acumulado se deposita en la salida
ET y se puede consultar allí. Una vez se ha alcanzado el tiempo PT, la salida Q devuelve el
estado lógico "1". El parámetro Q permanece a "1" aunque el estado lógico del parámetro IN
cambie de "1" a "0" (flanco de señal descendente).
La instrucción "Acumulador de tiempo" se puede colocar dentro o al final del segmento. Dicha
instrucción requiere una operación lógica precedente.
La entrada R desactiva las salidas ET y Q independientemente del estado lógico de la entrada
de arranque.
A cada llamada de la instrucción "Acumulador de tiempo" debe asignársele un temporizador
CEI, en el que se guarden los datos de instancia. El temporizador CEI es una estructura del tipo
de datos IEC_TIMER, IEC_LTIMER, TONR_TIME o TONR_LTIME que se puede declarar
como se indica a continuación:
● Declaración de un bloque de datos del tipo de datos de sistema IEC_TIMER o IEC_LTIMER
(p. ej., "MyIEC_TIMER")
● Declaración como variable local del tipo TONR_TIME, TONR_LTIME, IEC_TIMER o
IEC_LTIMER en la sección "Static" de un bloque (p. ej., #MyIEC_TIMER)

Actualización de los valores actuales en los datos de instancia
Los datos de instancia de "Acumulador de tiempo" se actualizan siguiendo las reglas indicadas
a continuación:
● Entrada IN
La instrucción "Acumulador de tiempo" compara el RLO actual con el RLO de la consulta
anterior, que está almacenado en el parámetro IN de los datos de instancia. Si la instrucción
detecta un cambio del RLO de "0" a "1", significa que hay un flanco de señal ascendente y
se reanuda la medición de tiempo. Si la instrucción detecta un cambio de "1" a "0" en el
RLO, significa que hay un flanco de señal descendente y la medición de tiempo se
interrumpe. Una vez procesada la instrucción "Acumulador de tiempo", el valor del
parámetro IN se actualiza en los datos de instancia y se utiliza como marca de flancos para
la siguiente consulta.
Tenga en cuenta que la evaluación de flancos falla cuando el valor actual del parámetro IN
es escrito o inicializado por otras funciones.
● Entrada PT
El valor de la entrada PT se escribe en el parámetro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.

Programación del PLC
Manual de programación y manejo, 11/2019

2049

Instrucciones
4.1 Instrucciones
● Entrada R
La señal "1" en la entrada R inicializa la medición de tiempo y la bloquea. Los flancos en la
entrada IN se ignoran. La señal "0" en la entrada R habilita de nuevo la medición de tiempo.
● Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
– Al llamar la instrucción, si las salidas ET o Q están interconectadas.
O bien:
– Al acceder a Q o ET.
Si las salidas no están interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucción se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan parámetros internos de la
instrucción "Acumulador de tiempo". Tenga en cuenta que la medición de tiempo falla
cuando los valores actuales de la instrucción son escritos o inicializados por otras
funciones.
PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está midiendo el
tiempo, se interfiere en la función del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse daños materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

2050

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de arranque

R

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de reset

PT

Input

TIME, LTIME

I, Q, M, D, L, P o
constante

Tiempo máximo de lectura
del tiempo
El valor del parámetro PT de‐
be ser positivo.

Q

Output

BOOL

I, Q, M, D, L, P

Salida que se activa una vez
transcurrido el tiempo PT.

ET

Output

TIME, LTIME

I, Q, M, D, L, P

Tiempo acumulado

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.

Cronograma de impulsos
La figura siguiente muestra el cronograma de impulsos de la instrucción "Acumulador de
tiempo":
,1

5

4

37

(7

Programación del PLC
Manual de programación y manejo, 11/2019

2051

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL TONR TIME, "IEC_TONR_DB"
(IN := "Tag_Start"
R := "Tag_Reset"
PT := "Tag_PresetTIME"
Q => "Tag_Status"
ET => "Tag_ElapsedTIME"
)

Cuando el estado lógico del operando "Tag_Start" cambia de "0" a "1", el tiempo programado
en el parámetro PT empieza a contar. Mientras transcurre el tiempo, se van acumulando los
valores de tiempo que se leen cuando el estado lógico del operando "Tag_Start" es "1". El
tiempo acumulado se almacena en el operando "Tag_ElapsedTIME". Una vez alcanzado el
valor de tiempo indicado en el parámetro PT, el operando "Tag_Status" adopta el estado lógico
"1". El valor de tiempo actual se guarda en el operando "Tag_ElapsedTIME".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

Contadores
CTU: Contador ascendente
Descripción
La instrucción "Contador ascendente" incrementa el valor del parámetro CV. Cuando el estado
lógico del parámetro CU cambia de "0" a "1" (flanco de señal ascendente), se ejecuta la
instrucción y el valor de contaje actual del parámetro CV se incrementa en uno. El valor de
contaje se incrementa cada vez que se detecta un flanco de señal ascendente, hasta alcanzar
el valor límite superior del tipo de datos indicado en la salida CV. Cuando se alcanza el valor
límite superior, el estado lógico del parámetro CU deja de tener efecto en la instrucción.
El estado del contador se puede consultar en el parámetro Q. El estado lógico del parámetro
Q es determinado por el parámetro PV. Si el valor de contaje actual es mayor o igual al valor
del parámetro PV, el parámetro Q adopta el estado lógico "1". En los restantes casos, el estado
lógico del parámetro Q es "0".

2052

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El valor del parámetro CV se pone a cero cuando el estado lógico del parámetro R cambia a
"1". Mientras el parámetro R tenga el estado lógico "1", el estado lógico del parámetro CU no
tendrá efecto alguno en la instrucción.
Nota
Utilice el contador en una sola posición del programa para evitar fallos de contaje.
A cada llamada de la instrucción "Contador ascendente" debe asignársele un contador CEI, en
el que se guarden los datos de la instrucción. Un contador CEI es una estructura con uno de
los tipos de datos siguientes:

Bloque de datos del tipo de datos de sistema IEC_<Contador> (Shared DB)
● IEC_SCOUNTER / IEC_USCOUNTER
● IEC_COUNTER / IEC_UCOUNTER
● IEC_DCOUNTER / IEC_UDCOUNTER
● IEC_LCOUNTER / IEC_ULCOUNTER

Variable local
● CTU_SINT / CTU_USINT
● CTU_INT / CTU_UINT
● CTU_DINT / CTU_UDINT
● CTU_LINT / CTU_ULINT
● IEC_SCOUNTER / IEC_USCOUNTER
● IEC_COUNTER / IEC_UCOUNTER
● IEC_DCOUNTER / IEC_UDCOUNTER
● IEC_LCOUNTER / IEC_ULCOUNTER
Un contador CEI se puede declarar del modo siguiente:
● Declaración de un bloque de datos del tipo de datos de sistema IEC_<Contador> (p. ej.
"MyIEC_COUNTER")
● Declaración como variable local del tipo CTU_<tipo de datos> o IEC_<contador> en la
sección "Static" de un bloque (p. ej., #MyCTU_COUNTER)
Si el contador CEI se crea en un bloque de datos propio (instancia individual), el bloque de
datos de instancia se crea de forma estándar con "acceso optimizado al bloque" y las distintas
variables se declaran remanentes. Encontrará más información sobre la configuración de la
remanencia en un bloque de datos de instancia en "Consulte también".
Si el contador CEI se crea como variable local (multiinstancia) en un bloque de función con
"acceso optimizado al bloque", esta se declara remanente en la interfaz del bloque.
Para poder ejecutar la instrucción "Contador ascendente" se requiere una operación lógica
precedente. Se puede colocar dentro o al final del segmento.

Programación del PLC
Manual de programación y manejo, 11/2019

2053

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

CU

Input

BOOL

I, Q, M, D, L o
constante

Entrada de contaje

R

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de reset

PV

Input

Enteros

I, Q, M, D, L, P o
constante

Valor con el que se activa la
salida Q.

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL CTU INT, "IEC_CTU_DB"
(CU := "Tag_Start"
R := "Tag_ResetCOUNTER"
PV := "Tag_PresetValue"
Q => "Tag_Status"
CV => "Tag_CounterValue"
)

Cuando el estado lógico del operando "Tag_Start" cambia de "0" a "1", se ejecuta la instrucción
"Contador ascendente" y el valor de contaje actual del operando "Tag_CounterValue" se
incrementa en uno. Con cada flanco de señal ascendente posterior, el valor de contaje irá
incrementando hasta alcanzar el valor límite superior del tipo de datos (INT = 32767).
El valor del parámetro PV se utiliza como límite para determinar la salida "Tag_Status". La
salida "Tag_Status" devuelve el estado lógico "1" mientras el valor de contaje actual sea mayor
o igual que el valor del operando "Tag_PresetValue". En todos los demás casos, la salida
"Tag_Status" devuelve el estado lógico "0".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ajustar la remanencia en un bloque de datos de instancia (Página 7855)
Remanencia de las variables locales (Página 7789)
Principios básicos de GRAPH (Página 8191)

2054

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CTD: Contador descendente
Descripción
La instrucción "Contador descendente" decrementa el valor del parámetro CV. Cuando el
estado lógico del parámetro CD cambia de "0" a "1" (flanco de señal ascendente), se ejecuta
la instrucción y el valor de contaje actual del parámetro CV se decrementa en uno. Cada vez
que se detecta un flanco de señal ascendente, el valor de contaje se decrementa hasta
alcanzar el valor límite inferior del tipo de datos indicado. Cuando se alcanza el valor límite
inferior, el estado lógico del parámetro CD deja de tener efecto en la instrucción.
El estado del contador se puede consultar en el parámetro Q. Si el valor de contaje actual es
menor o igual a cero, el parámetro Q adopta el estado lógico "1". En los restantes casos, el
estado lógico del parámetro Q es "0".
El valor del parámetro CV se pone al valor del parámetro PV cuando el estado lógico del
parámetro LD cambia a "1". Mientras el parámetro LD tenga el estado lógico "1", el estado
lógico del parámetro CD no tendrá efecto alguno en la instrucción.
Nota
Utilice el contador en una sola posición del programa para evitar fallos de contaje.
A cada llamada de la instrucción "Contador descendente" debe asignársele un contador CEI,
en el que se guarden los datos de la instrucción. Un contador CEI es una estructura con uno
de los tipos de datos siguientes:

Bloque de datos del tipo de datos de sistema IEC_<Contador> (Shared DB)
● IEC_SCOUNTER / IEC_USCOUNTER
● IEC_COUNTER / IEC_UCOUNTER
● IEC_DCOUNTER / IEC_UDCOUNTER
● IEC_LCOUNTER / IEC_ULCOUNTER

Variable local
● CTD_SINT / CTD_USINT
● CTD_INT / CTD_UINT
● CTD_DINT / CTD_UDINT
● CTD_LINT / CTD_ULINT
● IEC_SCOUNTER / IEC_USCOUNTER
● IEC_COUNTER / IEC_UCOUNTER
● IEC_DCOUNTER / IEC_UDCOUNTER
● IEC_LCOUNTER / IEC_ULCOUNTER

Programación del PLC
Manual de programación y manejo, 11/2019

2055

Instrucciones
4.1 Instrucciones
Un contador CEI se puede declarar del modo siguiente:
● Declaración de un bloque de datos del tipo de datos de sistema IEC_<Contador> (p. ej.
"MyIEC_COUNTER")
● Declaración como variable local del tipo CTD_<Tipo de datos> o IEC_<Contador> en la
sección "Static" de un bloque (p. ej. #MyCTD_COUNTER)
Si el contador CEI se crea en un bloque de datos propio (instancia individual), el bloque de
datos de instancia se crea de forma estándar con "acceso optimizado al bloque" y las distintas
variables se declaran remanentes. Encontrará más información sobre la configuración de la
remanencia en un bloque de datos de instancia en "Consulte también".
Si el contador CEI se crea como variable local (multiinstancia) en un bloque de función con
"acceso optimizado al bloque", esta se declara remanente en la interfaz del bloque.
Para poder ejecutar la instrucción "Contador descendente" se requiere una operación lógica
precedente. Se puede colocar dentro o al final del segmento.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

CD

Input

BOOL

I, Q, M, D, L o
constante

Entrada de contaje

LD

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de carga

PV

Input

Enteros

I, Q, M, D, L, P o
constante

Valor al que se pone la salida
CV cuando LD = 1.

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL CTD INT, "IEC_CTD_DB"
(CD := "Tag_Start"
LD := "Tag_LoadPV"
PV := "Tag_PresetValue"
Q => "Tag_Status"
CV => "Tag_CounterValue"
)

Cuando el estado lógico del operando "Tag_Start" cambia de "0" a "1", se ejecuta la instrucción
"Contador descendente" y el valor de la salida "Tag_CounterValue" se decrementa en uno.
Con cada flanco de señal ascendente posterior, el valor de contaje irá decrementando hasta
alcanzar el valor límite inferior del tipo de datos indicado (INT = -32768).

2056

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La salida "Tag_Status" devuelve el estado lógico "1" mientras el valor de contaje actual sea
menor o igual a cero. En todos los demás casos, la salida "Tag_Status" devuelve el estado
lógico "0".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ajustar la remanencia en un bloque de datos de instancia (Página 7855)
Remanencia de las variables locales (Página 7789)
Principios básicos de GRAPH (Página 8191)

CTUD: Contador ascendente - descendente
Descripción
La instrucción "Contador ascendente - descendente" incrementa y decrementa el valor del
parámetro CV. Cuando el estado lógico del parámetro CU cambia de "0" a "1" (flanco de señal
ascendente), el valor de contaje actual del parámetro CV se incrementa en uno. Cuando el
estado lógico del parámetro CD cambia de "0" a "1" (flanco de señal ascendente), el valor de
contaje actual del parámetro CV se decrementa en uno. Si en un ciclo del programa se detecta
un flanco de señal ascendente en las entradas CU y CD, el valor de contaje actual no cambia
en el parámetro CV.
El valor de contaje se puede seguir incrementando hasta alcanzar el valor límite superior del
tipo de datos indicado en el parámetro CV. Una vez alcanzado el valor límite superior, el valor
de contaje no se incrementa más aunque se detecte un flanco de señal ascendente. Cuando
se alcanza el valor límite inferior del tipo de datos indicado, ya no se decrementa el valor de
contaje.
Cuando el estado lógico del parámetro LD cambia a "1", el valor de contaje del parámetro CV
se pone al valor del parámetro PV. Mientras el parámetro LD tenga el estado lógico "1", el
estado lógico de las entradas CU y CD no tendrá efecto alguno en la instrucción.
El valor de contaje se pone a cero cuando el estado lógico del parámetro R cambia a "1".
Mientras el estado lógico del parámetro R sea "1", un cambio del estado lógico de los
parámetros CU, CD y LD no tendrá efecto alguno en la instrucción "Contador ascendente descendente".
El estado del contador ascendente se puede consultar en el parámetro QU. Si el valor de
contaje actual es mayor o igual al valor del parámetro PV, el parámetro QU adopta el estado
lógico "1". En los restantes casos, el estado lógico del parámetro QU es "0".
El estado del contador descendente se puede consultar en el parámetro QD. Si el valor de
contaje actual es menor o igual a cero, el parámetro QD adopta el estado lógico "1". En los
restantes casos, el estado lógico del parámetro QD es "0".
Nota
Utilice el contador en una sola posición del programa para evitar fallos de contaje.

Programación del PLC
Manual de programación y manejo, 11/2019

2057

Instrucciones
4.1 Instrucciones
A cada llamada de la instrucción "Contador ascendente - descendente" debe asignársele un
contador CEI en el que se guarden los datos de la instrucción. Un contador CEI es una
estructura con uno de los tipos de datos siguientes:

Bloque de datos del tipo de datos de sistema IEC_<Contador> (Shared DB)
● IEC_SCOUNTER / IEC_USCOUNTER
● IEC_COUNTER / IEC_UCOUNTER
● IEC_DCOUNTER / IEC_UDCOUNTER
● IEC_LCOUNTER / IEC_ULCOUNTER

Variable local
● CTUD_SINT / CTUD_USINT
● CTUD_INT / CTUD_UINT
● CTUD_DINT / CTUD_UDINT
● CTUD_LINT / CTUD_ULINT
● IEC_SCOUNTER / IEC_USCOUNTER
● IEC_COUNTER / IEC_UCOUNTER
● IEC_DCOUNTER / IEC_UDCOUNTER
● IEC_LCOUNTER / IEC_ULCOUNTER
Un contador CEI se puede declarar del modo siguiente:
● Declaración de un bloque de datos del tipo de datos de sistema IEC_<Contador> (p. ej.
"MyIEC_COUNTER")
● Declaración como variable local del tipo CTUD_<tipo de datos> o IEC_<contador> en la
sección "Static" de un bloque (p. ej., #MyCTUD_COUNTER)
Si el contador CEI se crea en un bloque de datos propio (instancia individual), el bloque de
datos de instancia se crea de forma estándar con "acceso optimizado al bloque" y las distintas
variables se declaran remanentes. Encontrará más información sobre la configuración de la
remanencia en un bloque de datos de instancia en "Consulte también".
Si el contador CEI se crea como variable local (multiinstancia) en un bloque de función con
"acceso optimizado al bloque", esta se declara remanente en la interfaz del bloque.
Para poder ejecutar la instrucción "Contador ascendente - descendente" se requiere una
operación lógica precedente. Se puede colocar dentro o al final del segmento.

2058

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

CU

Input

BOOL

I, Q, M, D, L o
constante

Entrada de contaje ascen‐
dente

CD

Input

BOOL

I, Q, M, D, L o
constante

Entrada de contaje descen‐
dente

R

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de reset

LD

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de carga

PV

Input

Enteros

I, Q, M, D, L, P o
constante

Valor con el que se activa la
salida QU. / Valor al que se
ajusta la salida CV si LD = 1.

QU

Output

BOOL

I, Q, M, D, L

Estado del contador ascen‐
dente

QD

Output

BOOL

I, Q, M, D, L

Estado del contador descen‐
dente

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL CTUD INT, "IEC_CTUD_DB"
(CU := "Tag_StartCTU"
CD := "Tag_StartCTD"
R := "Tag_ResetCOUNTER"
LD := "Tag_LoadPV"
PV := "Tag_PresetValue"
QU => "Tag_CounterStatusUP"
QD => "Tag_CounterStatusDOWN"
CV => "Tag_CounterValue"
)

Si el estado lógico de la entrada "Tag_StartCTU" o "Tag_StartCTD" cambia de "0" a "1" (flanco
de señal ascendente), se ejecuta la instrucción "Contador ascendente - descendente". Cuando
se detecta un flanco de señal ascendente en la entrada "Tag_StartCTU", el valor de contaje
actual se incrementa en uno y se deposita en la salida "Tag_CounterValue". Si se detecta un
flanco de señal ascendente en la entrada "Tag_StartCTD", el valor de contaje se decrementa
en uno y se deposita en la salida "Tag_CounterValue". Si se detecta un flanco de señal
ascendente en la entrada CU, el valor de contaje se sigue incrementando hasta alcanzar el
valor límite superior (32767). Cuando se detecta un flanco de señal ascendente en la entrada
CD, el valor de contaje se decrementa hasta alcanzar el valor límite inferior INT = -32768.

Programación del PLC
Manual de programación y manejo, 11/2019

2059

Instrucciones
4.1 Instrucciones
La salida "Tag_CounterStatusUP" devuelve el estado lógico "1" mientras el valor de contaje
actual sea mayor o igual que el valor de la entrada "Tag_PresetValue". En todos los demás
casos, la salida "Tag_CounterStatusUP" devuelve el estado lógico "0".
La salida "Tag_CounterStatusDOWN" devuelve el estado lógico "1" mientras el valor de
contaje actual sea menor o igual a cero. En todos los demás casos, la salida
"Tag_CounterStatusDOWN" devuelve el estado lógico "0".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ajustar la remanencia en un bloque de datos de instancia (Página 7855)
Remanencia de las variables locales (Página 7789)
Principios básicos de GRAPH (Página 8191)

Funciones matemáticas
NEG: Generar complemento a dos
Descripción
Con la instrucción "Generar complemento a dos" se cambia el signo del valor del operando.
Por ejemplo, si tiene un valor positivo, se deposita el equivalente negativo de este valor.
El valor de la salida OUT no es válido si el resultado de la instrucción está fuera del rango
permitido para el tipo de datos indicado en la salida OUT (solo válido para números enteros).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

SINT, INT, DINT,
LINT, números en
coma flotante

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

SINT, INT, DINT,
LINT, números en
coma flotante

I, Q, M, D, L, P

Complemento a dos del valor
de entrada

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

2060

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := NEG_REAL("Tag_InValue")

La instrucción cambia el signo del valor en el operando "Tag_InValue" e indica el resultado en
el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

ABS: Calcular valor absoluto
Descripción
Con la instrucción "Calcular valor absoluto" se calcula el valor absoluto del valor del operando.
El valor del resultado no es válido si un número en coma flotante presenta un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

SINT, INT, DINT,
LINT, números en
coma flotante

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

SINT, INT, DINT,
LINT, números en
coma flotante

I, Q, M, D, L, P

Valor absoluto del valor de
entrada

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := ABS("Tag_InValue")

Programación del PLC
Manual de programación y manejo, 11/2019

2061

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

-6.234

Tag_OutValue

6.234

La instrucción calcula el valor absoluto del valor del operando "Tag_InValue" e indica el
resultado en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

MIN: Determinar mínimo
Descripción
La instrucción "Determinar mínimo" compara los valores de las entradas disponibles IN1 e IN2
y escribe el valor más pequeño en la salida OUT.
El valor de la salida OUT no es válido si se cumple una de las siguientes condiciones:
● La conversión implícita de los tipos de datos falla durante la ejecución de la instrucción.
● Un número en coma flotante tiene un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:

2062

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P o
constante

Primer valor de entrada

IN2

Input

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P o
constante

Segundo valor de entrada

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OUT

Output

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P

Resultado

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar si la verificación CEI está desac‐
tivada.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL MIN INT
(IN1 := "TagIn_Value1"
IN2 := "TagIn_Value2"
OUT => "Tag_Minimum"
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN1

TagIn_Value1

12222

IN2

TagIn_Value2

14444

OUT

Tag_Minimum

12222

La instrucción compara los valores de los operandos indicados y copia el valor menor
("TagIn_Value1") en la salida "Tag_Minimum".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

MAX: Determinar máximo
Descripción
La instrucción "Determinar máximo" compara los valores de las entradas IN1 e IN2 y escribe
el valor mayor en la salida OUT.

Programación del PLC
Manual de programación y manejo, 11/2019

2063

Instrucciones
4.1 Instrucciones
El valor de la salida OUT no es válido si se cumple una de las siguientes condiciones:
● La conversión implícita de los tipos de datos falla durante la ejecución de la instrucción.
● Un número en coma flotante tiene un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P o
constante

Primer valor de entrada

IN2

Input

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P o
constante

Segundo valor de entrada

OUT

Output

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P

Resultado

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar si la verificación CEI está desac‐
tivada.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL MAX INT
(IN1 := "TagIn_Value1"
IN2 := "TagIn_Value2"
OUT => "Tag_Maximum"
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

2064

Operando

Valor

IN1

TagIn_Value1

12222

IN2

TagIn_Value2

14444

OUT

Tag_Maximum

14444

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucción compara los valores de los operandos indicados y copia el valor mayor
("TagIn_Value2") en la salida "Tag_Maximum".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

LIMIT: Ajustar valor límite
Descripción
La instrucción "Ajustar valor límite" limita el valor de la entrada IN a los valores de las entradas
MN y MX. Si el valor de la entrada IN cumple la condición MN <= IN <= MX, se copia en la salida
OUT. Si no se cumple la condición y el valor de entrada IN es menor que el límite inferior MN,
la salida OUT adopta el valor de la entrada MN. Si el límite superior MX se rebasa por exceso,
la salida OUT adopta el valor de la entrada MX.
Si el valor de la entrada MN es mayor que el de la entrada MX, el resultado será el valor
indicado en el parámetro IN. Para poder ejecutar la instrucción, es imprescindible que las
variables de todas las entradas sean del mismo tipo de datos.
El valor de la salida OUT no es válido si se cumple una de las siguientes condiciones:
● Las variables indicadas no son del mismo tipo de datos.
● Un operando tiene un valor no válido.
● El valor del parámetro MN es mayor que el valor del parámetro MX.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MN

Input

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P o
constante

Límite inferior

IN

Input

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P o
constante

Valor de entrada

MX

Input

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P o
constante

Límite superior

Programación del PLC
Manual de programación y manejo, 11/2019

2065

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OUT

Output

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P

Resultado

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar cuando la verificación CEI está
desactivada.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL LIMIT INT
(MN := "Tag_LowLimit"
IN := "Tag_InputValue"
MX := "Tag_HighLimit"
OUT => "Tag_Result"
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

MN

Tag_LowLimit

12000

IN

Tag_InputValue

8000

MX

Tag_HighLimit

16000

OUT

Tag_Result

12000

El valor del operando "Tag_InputValue" se compara con los valores de los operandos
"Tag_LowLimit" y "Tag_HighLimit". Puesto que el valor del operando "Tag_InputValue" es
menor que el valor límite inferior, el valor del operando "Tag_LowLimit" se copia en la salida
"Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

2066

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

SQR: Calcular cuadrado
Descripción
La instrucción "Calcular cuadrado" permite elevar al cuadrado el valor del número en coma
flotante del operando y escribir el resultado en la salida.
Si el operando contiene un número en coma flotante no válido, el valor del resultado tampoco
será válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

Números en coma
flotante

I, Q, M, D, L, P

Cuadrado del valor de entra‐
da

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := SQR("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

5.0

Tag_OutValue

25.0

La instrucción eleva al cuadrado el valor del operando "Tag_InValue" e indica el resultado en
el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

Programación del PLC
Manual de programación y manejo, 11/2019

2067

Instrucciones
4.1 Instrucciones

SQRT: Calcular raíz cuadrada
Descripción
La instrucción "Calcular raíz cuadrada" permite extraer la raíz cuadrada del valor de entrada y
guardar el resultado en el operando indicado. La instrucción da un resultado positivo si el valor
de entrada es mayor que cero. En los valores de entrada menores que cero, la instrucción
devuelve un número en coma flotante no válido. Si el valor del operando es "0", el resultado
también es "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

Números en coma
flotante

I, Q, M, D, L

Raíz cuadrada del valor de
entrada

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := SQRT("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

25.0

Tag_OutValue

5.0

La instrucción extrae la raíz cuadrada del valor del operando "Tag_InValue" e indica el
resultado en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Números en coma flotante no válidos (Página 263)
Principios básicos de GRAPH (Página 8191)

2068

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

LN: Calcular logaritmo natural
Descripción
La instrucción "Calcular logaritmo natural" permite calcular el logaritmo natural en base e (e =
2,718282) a partir del valor de entrada. La instrucción da un resultado positivo si el valor de
entrada es mayor que cero. En los valores de entrada menores que cero, la instrucción
devuelve un número en coma flotante no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

Números en coma
flotante

I, Q, M, D, L, P

Logaritmo natural del valor
de entrada

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := LN("Tag_InValue")

La instrucción calcula el logaritmo natural del valor del operando "Tag_InValue" e indica el
resultado en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Números en coma flotante no válidos (Página 263)
Principios básicos de GRAPH (Página 8191)

EXP: Calcular valor exponencial
Descripción
La instrucción "Calcular valor exponencial" permite calcular la potencia en base e (e =
2,718282) del valor del operando.

Programación del PLC
Manual de programación y manejo, 11/2019

2069

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

Números en coma
flotante

I, Q, M, D, L, P

Valor exponencial del valor
de entrada

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := EXP("Tag_InValue")

La instrucción calcula la potencia en base e del valor del operando "Tag_InValue" e indica el
resultado (eIN) en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Números en coma flotante no válidos (Página 263)
Principios básicos de GRAPH (Página 8191)

SIN: Calcular valor de seno
Descripción
La instrucción "Calcular valor de seno" permite calcular el seno de un ángulo. El tamaño del
ángulo se indica en radianes en el operando.
El valor del resultado no es válido si el valor del operando no es un número en coma flotante
válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:

2070

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Tamaño del ángulo en radia‐
nes

<Resultado>

Output

Números en coma
flotante

I, Q, M, D, L, P

Seno del ángulo indicado

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := SIN("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

+1.570796 (π/2)

Tag_OutValue

1.0

La instrucción calcula el seno del ángulo indicado en el operando "Tag_InValue" e indica el
resultado en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

COS: Calcular valor de coseno
Descripción
La instrucción "Calcular valor de coseno" permite calcular el coseno de un ángulo. El tamaño
del ángulo se indica en radianes en el operando.
El valor del resultado no es válido si el valor del operando no es un número en coma flotante
válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Tamaño del ángulo en radia‐
nes

<Resultado>

Output

Números en coma
flotante

I, Q, M, D, L, P

Coseno del ángulo indicado

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

2071

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := COS("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

+1.570796 (π/2)

Tag_OutValue

0

La instrucción calcula el coseno del ángulo indicado en el operando "Tag_InValue" e indica el
resultado en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

TAN: Calcular valor de tangente
Descripción
La instrucción "Calcular valor de tangente" permite calcular la tangente de un ángulo. El
tamaño del ángulo se indica en radianes en el operando.
El valor del resultado no es válido si el valor del operando no es un número en coma flotante
válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Tamaño del ángulo en radia‐
nes

<Resultado>

Output

Números en coma
flotante

I, Q, M, D, L, P

Tangente del ángulo indicado

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

2072

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := TAN("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

+3.141593 (π)

Tag_OutValue

0

La instrucción calcula la tangente del ángulo indicado en el operando "Tag_InValue" e indica
el resultado en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

ASIN: Calcular valor de arcoseno
Descripción
La instrucción "Calcular valor de arcoseno" permite calcular a partir del valor de seno indicado
en el operando el tamaño del ángulo que corresponde a este valor. En el operando solo se
pueden indicar números en coma flotante válidos, comprendidos en un rango de valores entre
-1 y +1. El tamaño del ángulo calculado puede estar comprendido entre -π/2 y +π/2.
El valor del resultado no es válido si se cumple una de las siguientes condiciones:
● El valor del operando no es un número en coma flotante válido.
● El valor del operando está fuera del rango de valores permitido (-1 hasta +1).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Valor de seno

<Resultado>

Output

Números en coma
flotante

I, Q, M, D, L, P

Tamaño del ángulo en radia‐
nes

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

2073

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := ASIN("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1.0

Tag_OutValue

+1.570796 (π/2)

La instrucción calcula el tamaño del ángulo que corresponde al valor de seno del operando
"Tag_InValue". El resultado de la instrucción se deposita en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

ACOS: Calcular valor de arcocoseno
Descripción
La instrucción "Calcular valor de arcocoseno" permite calcular a partir del valor de coseno
indicado en el operando el tamaño del ángulo que corresponde a este valor. En el operando
solo se pueden indicar números en coma flotante válidos, comprendidos en un rango de
valores entre -1 y +1. El tamaño del ángulo calculado puede estar comprendido entre 0 y +π.
El valor del resultado no es válido si se cumple una de las siguientes condiciones:
● El valor del operando no es un número en coma flotante válido.
● El valor del operando está fuera del rango de valores permitido (-1 hasta +1).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Valor de coseno

<Resultado>

Output

Números en coma
flotante

I, Q, M, D, L, P

Tamaño del ángu‐
lo en radianes

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

2074

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := ACOS("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

0

Tag_OutValue

+1.570796 (π/2)

La instrucción calcula el tamaño del ángulo que corresponde al valor de coseno del operando
"Tag_InValue". El resultado de la instrucción se deposita en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

ATAN: Calcular valor de arcotangente
Descripción
La instrucción "Calcular valor de arcotangente" permite calcular a partir del valor de tangente
indicado en el operando el tamaño del ángulo que corresponde a este valor. En el operando
solo se pueden indicar números en coma flotante válidos (o -NaN/+NaN). El tamaño del ángulo
calculado puede estar comprendido entre -π/2 y +π/2.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Valor de tangente

<Resultado>

Output

Números en coma
flotante

I, Q, M, D, L, P

Tamaño del ángulo en radia‐
nes

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

2075

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := ATAN("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1.0

Tag_OutValue

+0,785398 (π/4)

La instrucción calcula el tamaño del ángulo que equivale al valor de tangente del operando
"Tag_InValue". El resultado de la instrucción se deposita en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Números en coma flotante no válidos (Página 263)
Principios básicos de GRAPH (Página 8191)

FRAC: Determinar decimales
Descripción
La instrucción "Determinar decimales" permite determinar los decimales del valor del
operando. Por ejemplo, si el valor del operando es 123,4567, el resultado devuelve el valor
0,4567.
El valor del resultado no es válido si el valor del operando no es un número en coma flotante
válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada cuyos deci‐
males se determinan

RET_VAL

Output

Números en coma
flotante

I, Q, M, D, L, P

Decimales del valor de entra‐
da

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

2076

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL FRAC REAL
(IN := "Tag_InValue"
RET_VAL => "Tag_OutValue"
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

2.555

Tag_OutValue

0.555

La instrucción copia los decimales del valor del operando "Tag_InValue" en el operando
"Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

Transferencia
Deserialize: Deserializar
Descripción
La instrucción "Deserializar" reconvierte la forma de representación secuencial de un tipo de
datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> y rellena todo su contenido.
El área de memoria en la que se encuentra la forma de representación secuencial de un tipo
de datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> debe ser del tipo de datos ARRAY
of BYTE o ARRAY of CHAR y tener declarado el acceso estándar en la versión 1.0. A partir de
la versión 2.0 se permiten también áreas de memoria optimizadas. La capacidad del área de
memoria estándar es de 64 KB. Antes de la conversión asegúrese de que hay suficiente
memoria disponible. Si el área de memoria se ha rellenado utilizando la instrucción "Serializar"
y se han insertado bytes de relleno, estos no se tendrán en cuenta en la conversión.
Se recomienda definir a "0" el límite inferior del ARRAY, ya que entonces el índice dentro del
ARRAY se corresponde con el valor del parámetro POS, p. ej. ARRAY[0] = POS 0. La
descripción y el ejemplo que sigue más abajo se basan en estos fundamentos.
Esta instrucción reconvierte paso a paso a su estado original varias formas de representación
secuenciales de datos convertidos.

Programación del PLC
Manual de programación y manejo, 11/2019

2077

Instrucciones
4.1 Instrucciones
Para reconvertir una sola forma de representación secuencial de un tipo de datos PLC (UDT),
STRUCT o ARRAY of <tipo de datos> también se puede utilizar directamente la instrucción
"TRCV: Recibir datos a través de la conexión".

Tamaño del área de memoria
Debido a las reglas de alineación, no se insertan bytes de relleno en las estructuras sencillas
del área de memoria optimizada. Por consiguiente, una estructura del área de memoria
optimizada es más pequeña que en el área de memoria estándar. Los ARRAY de estructuras
y las estructuras anidadas tienen bytes de relleno. Por lo general no es posible saber de
antemano en qué área de memoria requiere más espacio una estructura compuesta.
Válido para las CPU de la serie S7-1500:
En un bloque con la propiedad "Acceso optimizado al bloque", el BOOL tiene una longitud de
1 byte. Esto hace que una estructura, que básicamente está formada por el tipo de datos
BOOL, sea mayor en el área de memoria optimizada que en el área de memoria estándar. Las
estructuras compuestas con un porcentaje reducido de tipos de datos BOOL son menores en
el área de memoria optimizada que en el área de memoria estándar.

Área de memoria optimizada
Para deserializar estructuras de mayor tamaño, el área de memoria para la representación
secuencial puede declararse también con acceso optimizado a partir de la versión de firmware
>= 4.2 de las CPU de la serie S7-1200 y a partir de la versión de firmware >= 2.0 de las CPU
de la serie S7-1500. El contenido de la representación secuencial no cambia, igual que en un
área de memoria estándar. El acceso a los bytes del ARRAY solo es posible simbólicamente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRC_ARRA
Y

Input

ARRAY[*] of
BYTE 1)

I, Q, D, interfaz de
bloque de un FB
(son posibles las
secciones Input,
Output, Static y
Temp).

ARRAY of BYTE o ARRAY of
CHAR, en el que se guarda el
flujo de datos que debe dese‐
rializarse.

o bien
ARRAY of CHAR

S7-1500:

Para obtener el máximo ren‐
ningún dato de pe‐ dimiento, no transfiera valo‐
riferia
res a este parámetro con un
puntero VARIANT.

DEST_VA‐
RIABLE

InOut

Todos los tipos de
datos

I, Q, D, interfaz de
bloque de un FB,

Variable, en la que se escri‐
birán los datos deserializa‐
ningún dato de pe‐ dos.
riferia
S7-1500:
Para obtener el máximo ren‐
dimiento, no transfiera valo‐
res a este parámetro con un
puntero VARIANT.

2078

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

POS

InOut

DINT

I, Q, M, D, L

El operando del parámetro
POS almacena el índice del
primer byte tras el número de
bytes que ocupan los datos
de cliente convertidos. El pa‐
rámetro POS se calcula ba‐
sado en cero.

RET_VAL

Output

INT

I, Q, M, D, L

Información de error

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B0

Las áreas de memoria de los parámetros SRC_ARRAY y DEST_VARIABLE se solapan.

8136

La variable del parámetro SRC_ARRAY no está en un bloque con acceso estándar.

8150

El tipo de datos VARIANT del parámetro SRC_ARRAY contiene un puntero IGUAL A
CERO.

8151

El parámetro SRC_ARRAY no tiene una referencia válida.

8153

En el parámetro SRC_ARRAY no hay suficiente espacio de memoria disponible.

8154

Tipo de datos no válido en el parámetro SRC_ARRAY

8250

En el parámetro DEST_ARRAY se ha transferido un puntero CERO.

8251

El parámetro DEST_VARIABLE no tiene una referencia válida.

8382

El valor del parámetro POS se encuentra fuera de los valores límite del array.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 4.2 (S7-1200) y 2.0 (S7-1500):
El código de error siguiente tiene un significado distinto:
Código de
error*
(W#16#...)

Explicación

8136

El acceso al área de memoria en el parámetro SRC_ARRAY no es válido.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 2.8 (S7-1500):
El rendimiento de la instrucción "Deserializar" (versión 2.1) mejora si no se transfieren valores
a los parámetros SRC_ARRAY y DEST_VARIABLE con un puntero VARIANT, sino con un tipo
de datos concreto.
Tenga en cuenta que el comportamiento erróneo de la instrucción cambia en este caso. En
determinados escenarios de error, la CPU no devuelve códigos de error, sino que pasa a

Programación del PLC
Manual de programación y manejo, 11/2019

2079

Instrucciones
4.1 Instrucciones
STOP con un error de acceso. Para evitar que esto ocurra, utilice el tratamiento de errores local
con las instrucciones "GET_ERROR" y "GET_ERR_ID".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL Deserialize VARIANT
(SRC_ARRAY := "Buffer".Field
DEST_VARIABLE => "Target".Client
POS := #BufferPos
RET_VAL => #Error
)

La instrucción deserializa la forma de representación secuencial de los datos de cliente de la
variable "Buffer" y los escribe en la variable "Target". El operando #BufferPos almacena el
índice del primer byte tras el número de bytes que ocupan los datos de cliente convertidos.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de VARIANT (Página 335)
Principios básicos de los tipos de datos PLC (UDT) (Página 283)
Estructura de una variable ARRAY (Página 298)
Estructura de una variable STRUCT (Página 290)
Estructura de una variable STRING (Página 277)
Bytes de relleno cuando se usan tipos de datos estructurados (Página 143)
Principios básicos de GRAPH (Página 8191)

Serialize: Serializar
Descripción
Mediante la instrucción "Serializar" se convierten varios tipos de datos PLC (UDT), STRUCT
o ARRAY of <tipo de datos> a una forma de representación secuencial sin que se pierdan
partes de su estructura.
La instrucción permite guardar temporalmente varios datos estructurados del programa en un
búfer, ubicado preferentemente en un bloque de datos global, y enviarlos a otra CPU. El área
de memoria en la que se depositen los datos convertidos debe ser del tipo de datos ARRAY of
BYTE o ARRAY of CHAR y tener declarado el acceso estándar en la versión 1.0. A partir de
la versión 2.0 se permiten también datos optimizados. Los datos de relleno del área de datos

2080

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
del origen no están definidos en el ARRAY de destino. Pueden ser tanto bytes o bits de relleno
de un área de datos (p. ej., ARRAY, STRUCT o tipo de datos PLC (UDT)) como los caracteres
de una cadena que no se utilicen en ese momento.
La capacidad del área de memoria estándar es de 64 KB. Las estructuras mayores que 64 KB
según las reglas para áreas de memoria estándar no pueden serializarse si el operando del
parámetro DEST_ARRAY está en un área de memoria estándar.
Se recomienda definir a "0" el límite inferior del ARRAY, ya que entonces el índice dentro del
ARRAY se corresponde con el valor del parámetro POS, p. ej. ARRAY[0] = POS 0. La
descripción y el ejemplo que sigue más abajo se basan en estos fundamentos.
El operando del parámetro POS contiene la información sobre el número de bytes que ocupan
los datos convertidos.
Para enviar un solo tipo de datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> se puede
llamar directamente la instrucción "TSEND: Enviar datos a través de la conexión".

Tamaño del área de memoria
Debido a las reglas de alineación, no se insertan bytes de relleno en las estructuras sencillas
del área de memoria optimizada. Por consiguiente, una estructura del área de memoria
optimizada es más pequeña que en el área de memoria estándar. Los ARRAY de estructuras
y las estructuras anidadas tienen bytes de relleno. Por lo general no es posible saber de
antemano en qué área de memoria requiere más espacio una estructura compuesta.
Válido para las CPU de la serie S7-1500:
En un bloque con la propiedad "Acceso optimizado al bloque", la longitud del BOOL depende
del tipo de datos que sigue. Por ejemplo, si lo que sigue es un BYTE, el BOOL tiene una
longitud de 1 byte. Si lo que sigue es WORD, el BOOL tiene una longitud de 2 bytes. Esto hace
que una estructura, que básicamente está formada por el tipo de datos BOOL, sea mayor en
el área de memoria optimizada que en el área de memoria estándar. Las estructuras
compuestas con un porcentaje reducido de tipos de datos BOOL son menores en el área de
memoria optimizada que en el área de memoria estándar.
Por eso se recomienda que el área de datos de origen para la serialización empiece con tipos
de datos grandes y termine con elementos booleanos. De este modo se reduce
considerablemente el relleno con bits de relleno.

Área de memoria optimizada
Para serializar estructuras de mayor tamaño, el área de memoria puede declararse también
con acceso optimizado a partir de la versión de firmware >= 4.2 de las CPU de la serie S7-1200
y a partir de la versión de firmware >= 2.0 de las CPU de la serie S7-1500. La representación
secuencial no cambia, igual que en un área de memoria estándar.

Programación del PLC
Manual de programación y manejo, 11/2019

2081

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRC_VARIA‐ Input
BLE

Todos los tipos de
datos

I, Q, D, interfaz de
bloque de un FB,

Variable que se serializará.

DEST_ARRA InOut
Y

ARRAY of BYTE o
ARRAY of CHAR

I, Q, D, interfaz de
bloque de un FB
(son posibles las
secciones Input,
Output, Static y
Temp),

Array en el que se guarda el
flujo de datos generado.

S7-1500:
ningún dato de pe‐ Para obtener el máximo ren‐
riferia
dimiento, no transfiera valo‐
res a este parámetro con un
puntero VARIANT.

S7-1500:

Para obtener el máximo ren‐
dimiento, no transfiera valo‐
res a este parámetro con un
ningún dato de pe‐ puntero VARIANT.
riferia

POS

InOut

DINT

I, Q, M, D, L

El operando del parámetro
POS almacena el índice del
primer byte tras el número to‐
tal de bytes que han ocupado
los datos de cliente converti‐
dos. El parámetro POS se
calcula basado en cero.

RET_VAL

Output

INT

I, Q, M, D, L

Información de error

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:

2082

Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B0

Las áreas de memoria de los parámetros SRC_VARIABLE y DEST_ARRAY se solapan.

8150

El tipo de datos VARIANT del parámetro SRC_VARIABLE contiene un puntero IGUAL A
CERO.

8151

El parámetro SRC_VARIABLE no tiene una referencia válida.

8236

La variable del parámetro SRC_ARRAY no está en un bloque con acceso estándar.

8250

En el parámetro DEST_ARRAY se ha transferido un puntero CERO.

8251

El parámetro DEST_ARRAY no tiene una referencia válida.

8253

La variable del parámetro DEST_ARRAY no ofrece suficiente espacio de memoria para
el contenido de la variable del parámetro SRC_VARIABLE. El valor de entrada de la
variable del parámetro POS reduce el espacio de memoria disponible. El valor de entrada
del parámetro POS determina en qué posición de la variable se comienza en el parámetro
DEST_ARRAY.

8254

Tipo de datos no válido en el parámetro DEST_ARRAY

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*
(W#16#...)

Explicación

8382

El valor del parámetro POS se encuentra fuera de los valores límite del array.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 4.2 (S7-1200) y 2.0 (S7-1500):
El código de error siguiente tiene un significado distinto:
Código de
error*
(W#16#...)

Explicación

8236

El acceso al área de memoria en el parámetro DEST_ARRAY no es válido.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 2.8 (S7-1500):
El rendimiento de la instrucción "Serializar" (versión 2.1) mejora si no se transfieren valores a
los parámetros SRC_VARIABLE y DEST_ARRAY con un puntero VARIANT, sino con un tipo
de datos concreto.
Tenga en cuenta que el comportamiento erróneo de la instrucción cambia en este caso. En
determinados escenarios de error, la CPU no devuelve códigos de error, sino que pasa a
STOP con un error de acceso. Para evitar que esto ocurra, utilice el tratamiento de errores local
con las instrucciones "GET_ERROR" y "GET_ERR_ID".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL Serialize VARIANT
(SRC_VARIABLE := "Source".Client
DEST_ARRAY => "Buffer".Field
POS := #BufferPos
RET_VAL => #Error
)

La instrucción serializa los datos de cliente de la variable "Source" y los escribe, en
representación secuencial, en la variable "Buffer". El índice del siguiente byte no escrito del
operando "Buffer".Field se almacena en el operando #BufferPos.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Programación del PLC
Manual de programación y manejo, 11/2019

2083

Instrucciones
4.1 Instrucciones
Principios básicos de VARIANT (Página 335)
Principios básicos de los tipos de datos PLC (UDT) (Página 283)
Estructura de una variable ARRAY (Página 298)
Estructura de una variable STRUCT (Página 290)
Estructura de una variable STRING (Página 277)
Bytes de relleno cuando se usan tipos de datos estructurados (Página 143)
Principios básicos de GRAPH (Página 8191)

MOVE_BLK: Copiar área
Descripción
La instrucción "Copiar área" copia los contenidos de un área de memoria (área de origen) en
un área de memoria diferente (área de destino). El número de elementos que se copian en el
área de destino se determina con el parámetro COUNT. El ancho del elemento del parámetro
IN define el ancho de los elementos que deben copiarse.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
El valor de la salida OUT no es válido si se copian más datos de los que se pone a disposición
en la entrada IN o en la salida OUT.
Nota
Uso de ARRAYs
La instrucción copia el contenido a partir del elemento definido n elementos (n = depende del
valor del parámetro COUNT) desde el área de origen al área de destino, comenzando por el
índice especificado.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:

2084

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN 1)

Input

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

D, L

Primer elemento del área de
origen que se copia

COUNT

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P o
constante

Número de elementos que
se copian del área de origen
al área de destino

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OUT 1)

Output

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

D, L

Primer elemento del área de
destino en la que se copian
los contenidos del área de
origen

1)

Los tipos de datos indicados solamente pueden utilizarse como elementos de una estructura ARRAY.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL MOVE_BLK INT_UINT
(IN := #a_array[2]
COUNT := "Tag_Count"
OUT => #b_array[1]
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

a_array[2]

El operando "a_array" es del tipo
de datos ARRAY[0..5] of INT.
Consta de 6 elementos del tipo
de datos INT.

COUNT

Tag_Count

3

OUT

b_array[1]

El operando "b_array" es del tipo
de datos ARRAY[0..6] of INT.
Consta de 7 elementos del tipo
de datos INT.

La instrucción selecciona a partir del tercer elemento tres elementos INT de la variable
#a_array y copia su contenido en la variable de salida #b_array, comenzando por el segundo
elemento.
Nota
Encontrará más información sobre la instrucción MOVE_BLK en el Siemens Industry Online
Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Programación del PLC
Manual de programación y manejo, 11/2019

2085

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

MOVE_BLK_VARIANT: Copiar área
Descripción
La instrucción "Copiar área" copia los contenidos de un área de memoria (área de origen) en
un área de memoria diferente (área de destino). Se pueden copiar elementos de un ARRAY o
un ARRAY completo en otro ARRAY del mismo tipo de datos. El tamaño (número de
elementos) de los ARRAY de origen y de destino puede diferir. Se pueden copiar varios
elementos dentro de un mismo ARRAY o bien copiar elementos individuales.
El número de elementos que deben copiarse no puede rebasar el área de origen o destino
seleccionado.
Cuando se utiliza la instrucción no es necesario conocer el ARRAY en el momento de crear el
bloque, puesto que el origen y el destino se transfieren vía VARIANT.
El recuento en los parámetros SRC_INDEX y DEST_INDEX comienza siempre por el límite
inferior "0", independientemente de la declaración posterior del ARRAY.
La instrucción no se ejecuta si se copian más datos de los que están disponibles.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

SRC

Input

VARIANT (que
apunta a un
ARRAY o a un ele‐
mento individual
del ARRAY),
ARRAY of <tipo de
datos>

L (puede declarar‐ El área de origen de la que se
se en las seccio‐
copia
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

COUNT

Input

UDINT

I, Q, M, D, L o
constante

2)

Descripción

Número de elementos que
se copian
Asigne al parámetro COUNT
el valor "1" si en el parámetro
SRC o en el parámetro DEST
no hay indicado ningún
ARRAY.

2086

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRC_INDEX

Input

DINT

I, Q, M, D, L o
constante

Define el primer elemento
que se copia:
● El parámetro
SRC_INDEX se calcula
basado en cero. Si en el
parámetro SRC hay
indicado un ARRAY, el
entero del parámetro
SRC_INDEX indica el
primer elemento del área
de origen de la que debe
copiarse. Esto es así
independientemente de
los límites declarados del
ARRAY.
● Si en el parámetro SRC
no hay indicado ningún
Array o solo un elemento
individual de un ARRAY,
asigne el valor "0" al
parámetro SRC_INDEX.

DEST_IN‐
DEX

Input

DINT

I, Q, M, D, L o
constante

Define el inicio del área de
memoria de destino:
● El parámetro
DEST_INDEX se calcula
basado en cero. Si en el
parámetro DEST hay
indicado un ARRAY, el
entero del parámetro
DEST_INDEX indica el
primer elemento del área
de destino en la que debe
copiarse. Esto es así
independientemente de
los límites declarados del
ARRAY.
● Si en el parámetro DEST
no hay indicado ningún
ARRAY, asigne el valor
"0" al parámetro
DEST_INDEX.

DEST

Output 1)

Programación del PLC
Manual de programación y manejo, 11/2019

VARIANT

L (puede declarar‐ Área de destino a la que se
se en las seccio‐
copia el contenido del área
nes "Input",
de origen.
"InOut" y "Temp"
de la interfaz del
bloque.)

2087

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RET_VAL

Output

INT

I, Q, M, D, L

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

1) El parámetro DEST está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.
2) En el parámetro SRC, los tipos de datos BOOL y ARRAY of BOOL no están permitidos.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

Los tipos de datos no coinciden. En lugar de un ARRAY of Struct utilice un ARRAY of tipo
de datos PLC (UDT).

8151

No es posible acceder al parámetro SRC.

8152

El operando del parámetro SRC no está tipificado.

8153

Error de creación de código en el parámetro SRC

8154

El operando del parámetro SRC es del tipo de datos BOOL.

8281

Valor no válido en el parámetro COUNT

8382

El valor del parámetro SRC_INDEX es menor que CERO.

8383

El valor del parámetro SRC_INDEX se encuentra fuera del límite superior del ARRAY.

8482

El valor del parámetro DEST_INDEX se encuentra fuera de los límites del ARRAY.

8483

El ARRAY al que señala el parámetro DEST es demasiado pequeño para los datos que
deben copiarse.

8534

El parámetro DEST está protegido contra escritura

8551

No es posible acceder al parámetro DEST.

8552

El operando del parámetro DEST no está tipificado.

8553

Error de creación de código en el parámetro DEST

8554

El operando del parámetro DEST es del tipo de datos BOOL.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL MOVE_BLK_VARIANT

2088

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
GRAPH
(SRC := #SrcField
COUNT := "Tag_Count"
SRC_INDEX := "Tag_Src_Index"
DEST_INDEX := "Tag_Dest_Index"
DEST => #DestField
RET_VAL := "Tag_Result"
)

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Declaración en la inter‐
faz del bloque

Operando

Valor

SRC

Input

#SrcField

El operando local
#SrcField utiliza un tipo
de datos PLC todavía
desconocido en el mo‐
mento de programar el
bloque. (ARRAY[0..10]
of "MOVE_UDT"

COUNT

Input

Tag_Count

2

SRC_INDEX

Input

Tag_Src_Index

3

DEST_INDEX

Input

Tag_Dest_Index

3

DEST

InOut

#DestField

El operando local
#DestField utiliza un ti‐
po de datos PLC toda‐
vía desconocido en el
momento de programar
el bloque.
(ARRAY[10..20] of "MO‐
VE_UDT"

En el área de destino se copian dos elementos del área de origen, empezando por el cuarto
elemento del ARRAY[0..10] of MOVE_UDT. Las copias se insertan en el ARRAY[10..20] of
MOVE_UDT a partir del cuarto elemento.
Nota
Encontrará más información sobre la instrucción MOVE_BLK_VARIANT en el Siemens
Industry Online Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)

Programación del PLC
Manual de programación y manejo, 11/2019

2089

Instrucciones
4.1 Instrucciones
Cambiar formatos de visualización en el estado del programa (Página 8529)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Ejemplo de movimiento de datos (Página 344)
Principios básicos de VARIANT (Página 335)
Principios básicos de GRAPH (Página 8191)

UMOVE_BLK: Copiar área sin interrupciones
Descripción
La instrucción "Copiar área sin interrupciones" copia sin interrupciones los contenidos de un
área de memoria (área de origen) en un área de memoria diferente (área de destino). El
número de elementos que se copian en el área de destino se determina con el parámetro
COUNT. El ancho del elemento del parámetro IN define el ancho de los elementos que deben
copiarse.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
Nota
Copiar sin interrupciones
La operación de copia no debe ser interrumpida por otras actividades del sistema operativo.
Por este motivo, los tiempos de reacción a alarmas de la CPU podrían aumentar al ejecutar la
instrucción "Copiar área sin interrupciones".
El valor de la salida OUT no es válido si se copian más datos de los que se pone a disposición
en la entrada IN o en la salida OUT.
La instrucción "Copiar área sin interrupciones" permite copiar 16 KB como máximo. A este
respecto deben tenerse en cuenta las limitaciones específicas de la CPU.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

D, L

Primer elemento del área de
origen que se copia

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P o
constante

Número de elementos que
se copian del área de origen
al área de destino

1)

COUNT

2090

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OUT 1)

Output

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

D, L

Primer elemento del área de
destino en la que se copian
los contenidos del área de
origen

1)

Los tipos de datos indicados solamente pueden utilizarse como elementos de una estructura ARRAY.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL UMOVE_BLK INT_UINT
(IN := #a_array[2]
COUNT := "Tag_Count"
OUT => #b_array[1]
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

a_array[2]

El operando "a_array" es del tipo
de datos ARRAY[0..5] of INT.
Consta de 6 elementos del tipo
de datos INT.

COUNT

Tag_Count

3

OUT

b_array[1]

El operando "b_array" es del tipo
de datos ARRAY[0..6] of INT.
Consta de 7 elementos del tipo
de datos INT.

La instrucción selecciona a partir del tercer elemento tres elementos INT de la variable
#a_array y copia su contenido en la variable de salida #b_array, comenzando por el segundo

Programación del PLC
Manual de programación y manejo, 11/2019

2091

Instrucciones
4.1 Instrucciones
elemento. La operación de copia no debe ser interrumpida por otras actividades del sistema
operativo.
Nota
Encontrará más información sobre la instrucción UMOVE_BLK en el Siemens Industry Online
Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

FILL_BLK: Rellenar área
Descripción
La instrucción "Rellenar área" permite rellenar un área de memoria (área de destino) con el
valor de la entrada IN. El área de destino se rellena a partir de la dirección indicada en la salida
OUT. El número de repeticiones de copia se determina mediante el parámetro COUNT. Al
ejecutar la instrucción, el valor de la entrada IN se copia en el área de destino el número de
veces especificado por el valor del parámetro COUNT.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
Como máximo se modifican tantos elementos como tiene el ARRAY o la estructura. Si se
copian más datos que los elementos disponibles en la salida OUT, el resultado no será el
deseado.
Nota
Uso de ARRAYs
La instrucción lee en el área de origen el contenido del elemento seleccionado y lo copia n
veces (n = depende del valor del parámetro COUNT) en el área de destino, comenzado a partir
del índice especificado.

2092

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Rellenar estructuras
Además de los elementos de un ARRAY, también es posible rellenar varios elementos de una
estructura (STRUCT, tipo de datos PLC) con el mismo valor. La estructura cuyos elementos
deben rellenarse puede contener únicamente elementos individuales del mismo tipo de datos
elemental. No obstante, la estructura propiamente dicha puede estar incrustada en otra
estructura.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

I, Q, M, D, L, P o
constante

Elemento con el que se relle‐
na el área de destino

COUNT

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P o
constante

Número de repeticiones de
copia

OUT

Output

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

D, L

Dirección del área de destino
a partir de la cual se rellena

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
El siguiente ejemplo muestra el funcionamiento de la instrucción cuando debe rellenarse un
ARRAY:
GRAPH
CALL FILL_BLK INT_UINT
(IN := #FillValue
COUNT := "Tag_Count"
OUT => #TargetArea[1]
)

Programación del PLC
Manual de programación y manejo, 11/2019

2093

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

FillValue

El operando es del tipo de datos
INT.

COUNT

Tag_Count

3

OUT

TargetArea

El operando TargetArea es del
tipo de datos ARRAY[1..5] of
INT. Consta de 5 elementos del
tipo de datos INT.

La instrucción copia tres veces el valor del operando #FillValue en la variable de salida
#TargetArea, empezando por el primer elemento.

Ejemplos con una estructura
Los siguientes ejemplos muestran el funcionamiento de la instrucción cuando debe rellenarse
una estructura.
Cree un bloque de datos global con los elementos siguientes:
Data_block_1

Tipo de datos

MyStruct1

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

MyStruct2

STRUCT

SubArray

ARRAY[1..2] of STRUCT

SubArray[1]

STRUCT

NestedStruct

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

SubArray[2]

STRUCT

Nes‐
tedStruct

STRUCT
Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

Cree el código de programa siguiente para direccionar la variable MyStruct1:
GRAPH
CALL FILL_BLK INT_UINT
(IN := 10

2094

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
GRAPH
COUNT := 2
OUT => "Data_block_1".MyStruct1.Member_2
)

Cree el código de programa siguiente para direccionar la variable MyStruct2:
GRAPH
CALL FILL_BLK INT_UINT
(IN := 10
COUNT := 2
OUT => "Data_block_1".MyStruct2.SubArray[1].NestedStruct.Member_2
)

En ambos ejemplos, el valor 10 del parámetro IN se copia dos veces en el operando del
parámetro OUT, empezando por el elemento Member_2. Esto significa que el valor 10 se copia
tanto en el elemento Member_2 como en el Member_3. Los otros dos elementos, Member_1
y Member_4, no cambian.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

UFILL_BLK: Rellenar área sin interrupciones
Descripción
La instrucción "Rellenar área sin interrupciones" rellena sin interrupciones un área de memoria
(área de destino) con el valor de la entrada IN. El área de destino se rellena a partir de la
dirección indicada en la salida OUT. El número de repeticiones de copia se determina
mediante el parámetro COUNT. Al ejecutar la instrucción, el valor de la entrada IN se copia en
el área de destino el número de veces especificado por el valor del parámetro COUNT.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
Nota
La operación de copia no debe ser interrumpida por otras actividades del sistema operativo.
Por este motivo, los tiempos de reacción a alarmas de la CPU podrían aumentar al ejecutar la
instrucción "Rellenar área sin interrupciones".

Programación del PLC
Manual de programación y manejo, 11/2019

2095

Instrucciones
4.1 Instrucciones
Como máximo se modifican tantos elementos como tiene el ARRAY o la estructura. Si se
copian más datos que los elementos disponibles en la salida OUT, el resultado no será el
deseado.
Nota
Uso de ARRAYs
La instrucción lee en el área de origen el contenido del elemento seleccionado y lo copia n
veces (n = depende del valor del parámetro COUNT) en el área de destino, comenzado a partir
del índice especificado.
La instrucción "Rellenar área sin interrupciones" permite copiar 16 KB como máximo. A este
respecto deben tenerse en cuenta las limitaciones específicas de la CPU.

Rellenar estructuras
Además de los elementos de un ARRAY, también es posible rellenar varios elementos de una
estructura (STRUCT, tipo de datos PLC) con el mismo valor. La estructura cuyos elementos
deben rellenarse puede contener únicamente elementos individuales del mismo tipo de datos
elemental. No obstante, la estructura propiamente dicha puede estar incrustada en otra
estructura.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

I, Q, M, D, L, P o
constante

Elemento con el que se relle‐
na el área de destino

COUNT

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P o
constante

Número de repeticiones de
copia

OUT

Output

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

D, L

Dirección del área de destino
a partir de la cual se rellena

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

2096

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo con un ARRAY
El siguiente ejemplo muestra el funcionamiento de la instrucción cuando debe rellenarse un
ARRAY:
GRAPH
CALL UFILL_BLK INT_UINT
(IN := #FillValue
COUNT := "Tag_Count"
OUT => #TargetArea[1]
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

FillValue

El operando es del tipo de datos
INT.

COUNT

Tag_Count

3

OUT

TargetArea

El operando TargetArea es del
tipo de datos ARRAY[1..5] of
INT. Consta de 5 elementos del
tipo de datos INT.

La instrucción copia tres veces el valor del operando #FillValue en la variable de salida
#TargetArea, empezando por el primer elemento. La operación de copia no debe ser
interrumpida por otras actividades del sistema operativo.

Ejemplos con una estructura
Los siguientes ejemplos muestran el funcionamiento de la instrucción cuando debe rellenarse
una estructura.
Cree un bloque de datos global con los elementos siguientes:
Data_block_1

Tipo de datos

MyStruct1

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

MyStruct2

Programación del PLC
Manual de programación y manejo, 11/2019

STRUCT

2097

Instrucciones
4.1 Instrucciones
Data_block_1

Tipo de datos

SubArray

ARRAY[1..2] of STRUCT

SubArray[1]

STRUCT

NestedStruct

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

SubArray[2]

STRUCT

Nes‐
tedStruct

STRUCT
Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

Cree el código de programa siguiente para direccionar la variable MyStruct1:
GRAPH
CALL UFILL_BLK INT_UINT
(IN := 10
COUNT := 2
OUT => "Data_block_1".MyStruct1.Member_2
)

Cree el código de programa siguiente para direccionar la variable MyStruct2:
GRAPH
CALL UFILL_BLK INT_UINT
(IN := 10
COUNT := 2
OUT => "Data_block_1".MyStruct2.SubArray[1].NestedStruct.Member_2
)

En ambos ejemplos, el valor 10 del parámetro IN se copia dos veces en el operando del
parámetro OUT, empezando por el elemento Member_2. Esto significa que el valor 10 se copia
tanto en el elemento Member_2 como en el Member_3. Los otros dos elementos, Member_1
y Member_4, no cambian.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

2098

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

SCATTER: Dispersión de una secuencia de bits en bits individuales
Descripción
La instrucción "Dispersión de una secuencia de bits en bits individuales" descompone una
variable del tipo de datos BYTE, WORD, DWORD o LWORD en bits individuales y los guarda
en un ARRAY of BOOL, un STRUCT anónimo o un tipo de datos PLC con elementos
booleanos exclusivamente.
Nota
ARRAY of BOOL multidimensional
En la instrucción "Dispersión de una secuencia de bits en bits individuales" no está permitido
utilizar un ARRAY of BOOL multidimensional.
Nota
Longitud del ARRAY, del STRUCT o del tipo de datos PLC
El ARRAY, el STRUCT anónimo o el tipo de datos PLC deben tener tantos elementos como se
especifique en la secuencia de bits.
Es decir, en el tipo de datos BYTE, p. ej., el ARRAY, el STRUCT o el tipo de datos PLC deben
tener exactamente 8 elementos (WORD = 16, DWORD = 32 y LWORD = 64).
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1500 a partir de la versión de firmware
2.1.
De este modo es posible, p. ej., descomponer una palabra de estado y leer y modificar por
índice el estado de los bits individuales. Mediante GATHER pueden juntarse nuevamente los
bits en una secuencia de bits.
La salida de habilitación ENO devuelve el estado lógico "0" si el ARRAY no proporciona
suficientes elementos BOOL.

Programación del PLC
Manual de programación y manejo, 11/2019

2099

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

IN

Input

Tipo de datos

Área de memoria

BYTE, WORD,
I, Q, M, D, L
DWORD, LWORD

Descripción
Secuencia de bits
que se descompo‐
ne.
Los valores no
pueden encontrar‐
se en el área de
periferia o en el
DB de un objeto
tecnológico.

OUT

Output

ARRAY[*] of
BOOL, STRUCT o
tipo de datos PLC

I, Q, M, D, L

*: 8, 16, 32 o 64
elementos

ARRAY, STRUCT
o tipo de datos
PLC en el/los que
se guardan los bits
individuales

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceWord

Input

WORD

DestinationArray

Output

ARRAY[0..15] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL SCATTER
(IN := #SourceWord
OUT => #DestinationArray
)

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceWord

WORD (16 bits)

OUT

DestinationArray

El operando "DestinationArray"
es del tipo de datos
ARRAY[0..15] of BOOL. Consta
de 16 elementos y, por tanto, tie‐
ne el mismo tamaño que la
WORD que se debe descompo‐
ner.

El operando #SourceWord del tipo de datos WORD se descompone en sus bits individuales
(16) y se asigna a los distintos elementos del operando #DestinationArray.

2100

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo con un tipo de datos PLC (UDT)
Cree el siguiente tipo de datos PLC "myBits":

Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceWord

Input

WORD

DestinationUDT

Output

"myBits"

El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL SCATTER
(IN := #SourceWord
OUT => #DestinationUDT
)

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceWord

WORD (16 bits)

OUT

DestinationUDT

El operando "DestinationUDT"
es del tipo de datos PLC (UDT).
Consta de 16 elementos y, por
tanto, tiene el mismo tamaño
que la WORD que se debe des‐
componer.

El operando #SourceWord del tipo de datos WORD se descompone en sus bits individuales
(16) y se asigna a los distintos elementos del operando #DestinationUDT.

Programación del PLC
Manual de programación y manejo, 11/2019

2101

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

SCATTER_BLK: Dispersión de elementos de un ARRAY of secuencia de bits en bits individuales
Descripción
La instrucción "Dispersión de elementos de un ARRAY of secuencia de bits en bits
individuales" descompone uno o varios elementos de un ARRAY of BYTE, WORD, DWORD
o LWORD en bits individuales y los guarda en un ARRAY of BOOL, un STRUCT anónimo o un
tipo de datos PLC con elementos booleanos exclusivamente. En el parámetro COUNT_IN se
introduce el número de elementos del ARRAY de origen que deben dispersarse. El ARRAY de
origen en el parámetro IN puede tener más elementos que los indicados en el parámetro
COUNT_IN. El ARRAY of BOOL, el STRUCT anónimo o el tipo de datos PLC deben tener
suficientes elementos para poder guardar los bits de la secuencia de bits descompuesta. El
área de memoria de destino también puede ser mayor.
Nota
ARRAY of BOOL multidimensional
Si el ARRAY es un ARRAY of BOOL multidimensional, se cuentan también los bits de relleno
de las dimensiones contenidas, aunque no se hayan declarado explícitamente.
Ejemplo 1: un ARRAY[1..10,0..4,1..2] of BOOL recibe el mismo tratamiento que un
ARRAY[1..10,0..4,1..8] of BOOL o que un ARRAY[0..399] of BOOL.
Ejemplo 2: En el parámetro IN hay un ARRAY[0..5] of WORD (sourceArrayWord[2])
interconectado. El parámetro COUNT_IN tiene el valor "3". En el parámetro OUT hay un
ARRAY[0..1,0..5,0..7] of BOOL (destinationArrayBool[0,0,0]) interconectado. Tanto el array
del parámetro IN como el del parámetro OUT tienen 96 bits de tamaño. El ARRAY of WORD
se descompone en 48 bits individuales.
Nota
Si el límite inferior del ARRAY de destino no es "0", cabe considerar lo siguiente:
Por motivos de rendimiento, el índice debe comenzar siempre en un límite de BYTE, WORD,
DWORD o LWORD. Esto significa que debe calcularse el índice partiendo del límite inferior del
ARRAY. Como base para el cálculo se utiliza la siguiente fórmula:
Índice válido = límite inferior del ARRAY + n(número de secuencias de bits) * número de bits
de la secuencia de bits deseada
Para un ARRAY[-2..45] of BOOL y la secuencia de bits WORD, el cálculo es el siguiente:
● Índice válido (-2) = -2 + 0 * 16
● Índice válido (14) = -2 + 1 * 16
● Índice válido (30) = -2 + 2 * 16
Ver un ejemplo más adelante.

2102

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1500 a partir de la versión de firmware
2.1.
De este modo es posible, p. ej., descomponer palabras de estado y leer y modificar por índice
el estado de los bits individuales. Mediante GATHER pueden juntarse nuevamente los bits en
una secuencia de bits.
La salida de habilitación ENO devuelve el estado lógico "0" si se cumple una de las siguientes
condiciones:
● El ARRAY de origen tiene menos elementos que los que se especifican en el parámetro
COUNT_IN.
● El índice del ARRAY de destino no empieza en un límite de BYTE, WORD, DWORD o
LWORD. En este caso no se escribe ningún resultado en el ARRAY of BOOL.
● El ARRAY[*] of BOOL, el STRUCT o el tipo de datos PLC no proporcionan el número
necesario de elementos. en este caso se descomponen tantas secuencias de bits como
sea posible y se escriben en el ARRAY of BOOL, STRUCT anónimo o tipo de datos PLC.
El resto de secuencias de bits no se tiene en cuenta.
Nota
CPU S7-1200: Salida de habilitación ENO = 0
Si la salida de habilitación ENO devuelve el estado lógico "0", no se escribirán datos en el
parámetro de salida OUT.

Programación del PLC
Manual de programación y manejo, 11/2019

2103

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

IN

Input

Tipo de datos
Elemento de un
ARRAY[*] of <se‐
cuencia de bits>

Área de memoria

Descripción

I, Q, M, D, L

ARRAY of <se‐
cuencia de bits>
que se descompo‐
ne.
Los valores no
pueden encontrar‐
se en el área de
periferia o en el
DB de un objeto
tecnológico.

COUNT_IN

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L

Contador del nú‐
mero de elemen‐
tos del ARRAY de
origen que deben
descomponerse.
El valor no puede
encontrarse en el
área de periferia o
en el DB de un ob‐
jeto tecnológico.

OUT

Output

Elemento de un
ARRAY[*] of
BOOL, STRUCT o
tipo de datos PLC

I, Q, M, D, L

ARRAY, STRUCT
o tipo de datos
PLC en el/los que
se guardan los bits
individuales

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar la secuencia de
bits deseada.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo de un ARRAY de destino con el límite inferior de "0"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArrayWord

Input

ARRAY[0..5] of WORD

CounterInput
DestinationArrayBool

UDINT
Output

ARRAY[0..95] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL SCATTER_BLK
(IN := #SourceArrayWord[2]
COUNT_IN := #CounterInput
OUT => #DestinationArrayBool[0]
)

2104

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayWord[2]

ARRAY[0..5] of WORD (Pueden
dispersarse 96 bits.)

COUNT_IN

CounterInput = 3

UDINT3 (deben descomponerse
3 WORD o 48 bits. Esto significa
que en el ARRAY de destino de‐
be haber al menos 48 bits).

OUT

DestinationArrayBool[0]

El operando "DestinationArray‐
Bool" es del tipo de datos
ARRAY[0..95] of BOOL. Hay por
tanto 96 elementos BOOL dispo‐
nibles.

La 3.ª, 4.ª y 5.ª WORD del operando #SourceArrayWord se descomponen en sus bits
individuales (48) y se asignan a los distintos elementos del operando #DestinationArrayBool a
partir del 1.er elemento.

Ejemplo de ARRAY de destino con el límite inferior de "-2"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArrayWord

Input

ARRAY[0..5] of WORD

CounterInput
DestinationArrayBool

UDINT
Output

ARRAY[-2..93] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL SCATTER_BLK
(IN := #SourceArrayWord[2]
COUNT_IN := #CounterInput
OUT => #DestinationArrayBool[14]
)

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayWord[2]

ARRAY[0..5] of WORD (Pueden
dispersarse 96 bits.)

COUNT_IN

CounterInput = 3

UDINT3 (deben descomponerse
3 WORD o 48 bits. Esto significa
que en el ARRAY de destino de‐
be haber al menos 48 bits).

OUT

DestinationArrayBool[14]

El operando "DestinationArray‐
Bool" es del tipo de datos
ARRAY[-2..93] of BOOL. Hay
por tanto 96 elementos BOOL
disponibles.

Programación del PLC
Manual de programación y manejo, 11/2019

2105

Instrucciones
4.1 Instrucciones
La 3.ª, 4.ª y 5.ª WORD del operando #SourceArrayWord se descomponen en sus bits
individuales (48) y a partir del 16.º elemento se asignan a los distintos elementos del operando
#DestinationArrayBool. Los 32 bits restantes no se escriben.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

GATHER: Recopilación de bits individuales en una secuencia de bits
Descripción
La instrucción "Recopilación de bits individuales en una secuencia de bits" recompone los bits
de un ARRAY of BOOL, un STRUCT anónimo o un tipo de datos PLC en una secuencia de bits
con elementos booleanos exclusivamente. La secuencia de bits se guarda en una variable del
tipo de datos BYTE, WORD, DWORD o LWORD.
Nota
ARRAY of BOOL multidimensional
En la instrucción "Recopilación de bits individuales en una secuencia de bits" no está permitido
utilizar un ARRAY of BOOL multidimensional.
Nota
Longitud del ARRAY, del STRUCT o del tipo de datos PLC
El ARRAY, el STRUCT o el tipo de datos PLC deben tener tantos elementos como se
especifique en la secuencia de bits.
Es decir, en el tipo de datos BYTE, p. ej., el ARRAY, el STRUCT anónimo o el tipo de datos PLC
deben tener exactamente 8 elementos (WORD = 16, DWORD = 32 y LWORD = 64).
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1500 a partir de la versión de firmware
2.1.
La salida de habilitación ENO devuelve el estado lógico "0" si el ARRAY, el STRUCT anónimo
o el tipo de datos PLC tienen más o menos elementos BOOL que los especificados en la
secuencia de bits. En este caso no se transfieren los elementos BOOL. ENO también es "0"
cuando hay menos bits de los necesarios.

2106

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

IN

Input

Tipo de datos
ARRAY[*] of
BOOL, STRUCT o
tipo de datos PLC

Área de memoria

Descripción

I, Q, M, D, L

ARRAY, STRUCT
o tipo de datos
PLC cuyos bits se
recomponen en
una secuencia de
bits.

*: 8, 16, 32 o 64
elementos

Los valores no
pueden encontrar‐
se en el área de
periferia o en el
DB de un objeto
tecnológico.
OUT

Output

BYTE, WORD,
I, Q, M, D, L
DWORD, LWORD

Secuencia de bits
recopilada que es‐
tá guardada en
una variable

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar la secuencia de
bits deseada.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArray

Input

ARRAY[0..15] of BOOL

DestinationWord

Output

WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL GATHER
(IN := #SourceArray
OUT => #DestinationWord
)

Programación del PLC
Manual de programación y manejo, 11/2019

2107

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operando
concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArray

El operando "SourceArray" es
del tipo de datos ARRAY[0..15]
of BOOL. Consta de 16 elemen‐
tos y, por tanto, tiene el mismo
tamaño que la WORD en la que
se deben recomponer los bits.

OUT

DestinationWord

WORD (16 bits)

Los bits del operando #SourceArray se recopilan en una WORD.

Ejemplo con un tipo de datos PLC (UDT)
Cree el siguiente tipo de datos PLC "myBits":

Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceUDT

Input

"myBits"

DestinationWord

Output

WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL GATHER
(IN := #SourceUDT
OUT => #DestinationWord
)

2108

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operando
concretos:
Parámetro

Operando

Tipo de datos

IN

SourceUDT

El operando "SourceUDT" es del
tipo de datos PLC (UDT). Consta
de 16 elementos y, por tanto, tie‐
ne el mismo tamaño que la
WORD en la que se deben re‐
componer los bits.

OUT

DestinationWord

WORD (16 bits)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

GATHER_BLK: Recopilación de bits individuales en varios elementos de un ARRAY of secuencia de bits
Descripción
La instrucción "Recopilación de bits individuales en varios elementos de un ARRAY of
secuencia de bits" recompone los bits de un ARRAY of BOOL, un STRUCT anónimo o un tipo
de datos PLC con elementos booleanos exclusivamente en uno o varios elementos de un
ARRAY of <secuencia de bits>. En el parámetro COUNT_OUT se introduce el número de
elementos del ARRAY de destino que deben escribirse. Al hacerlo se especifica
implícitamente cuántos elementos del ARRAY of BOOL, del STRUCT anónimo o del tipo de
datos PLC se necesitan. El ARRAY de destino en el parámetro OUT puede tener más
elementos que los indicados en el parámetro COUNT_OUT. El ARRAY of <secuencia de bits>
debe tener suficientes elementos para poder guardar los bits que deben recopilarse. El
ARRAY de destino también puede ser mayor.
Nota
ARRAY of BOOL multidimensional
Si el ARRAY es un ARRAY of BOOL multidimensional, se cuentan también los bits de relleno
de las dimensiones contenidas, aunque no se hayan declarado explícitamente.
Ejemplo 1: un ARRAY[1..10,0..4,1..2] of BOOL recibe el mismo tratamiento que un
ARRAY[1..10,0..4,1..8] of BOOL o que un ARRAY[0..399] of BOOL.
Ejemplo 2: En el parámetro OUT hay un ARRAY[0..5] of WORD (sourceArrayWord[2])
interconectado. El parámetro COUNT_IN tiene el valor "3". En el parámetro IN hay un
ARRAY[0..1,0..5,0..7] of BOOL (destinationArrayBool[0,0,0]) interconectado. Tanto el array
del parámetro IN como el del parámetro OUT tienen 96 bits de tamaño. A partir del ARRAY of
BOOL se recomponen 48 bits individuales.

Programación del PLC
Manual de programación y manejo, 11/2019

2109

Instrucciones
4.1 Instrucciones
Nota
Si el límite inferior del ARRAY de origen no es "0", cabe considerar lo siguiente:
Por motivos de rendimiento, el índice debe comenzar siempre en un límite de BYTE, WORD,
DWORD o LWORD. Esto significa que debe calcularse el índice partiendo del límite inferior del
ARRAY. Como base para el cálculo se utiliza la siguiente fórmula:
Índice válido = límite inferior del ARRAY + n(número de secuencias de bits) * número de bits
de la secuencia de bits deseada
Para un ARRAY[-2..45] of BOOL y la secuencia de bits WORD, el cálculo es el siguiente:
● Índice válido (-2) = -2 + 0 * 16
● Índice válido (14) = -2 + 1 * 16
● Índice válido (30) = -2 + 2 * 16
Ver un ejemplo más adelante.
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1500 a partir de la versión de firmware
2.1.
La salida de habilitación ENO devuelve el estado lógico "0" si se cumple una de las siguientes
condiciones:
● El índice del ARRAY de origen no empieza en un límite de BYTE, WORD, DWORD o
LWORD. En este caso no se escribe ningún resultado en el ARRAY of <secuencia de bits>.
● El ARRAY[*] of <secuencia de bits> no proporciona el número necesario de elementos. en
este caso se juntan tantas secuencias de bits como sea posible y se escriben en el ARRAY
of <secuencia de bits>. El resto de los bits no se tiene en cuenta.
Nota
CPU S7-1200: Salida de habilitación ENO = 0
Si la salida de habilitación ENO devuelve el estado lógico "0", no se escribirán datos en el
parámetro de salida OUT.

2110

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

IN

Input

Tipo de datos
Elemento de un
ARRAY[*] of
BOOL, STRUCT o
tipo de datos PLC

Área de memoria

Descripción

I, Q, M, D, L

ARRAY of BOOL,
STRUCT o tipo de
datos PLC cuyos
bits se recompo‐
nen (ARRAY de
origen).
Los valores no
pueden encontrar‐
se en el área de
periferia o en el
DB de un objeto
tecnológico.

COUNT_OUT

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L

Contador del nú‐
mero de elemen‐
tos del ARRAY de
destino que deben
escribirse.
El valor no puede
encontrarse en el
área de periferia o
en el DB de un ob‐
jeto tecnológico.

OUT

Output

Elemento de un
ARRAY[*] of <se‐
cuencia de bits>

I, Q, M, D, L

ARRAY de <se‐
cuencia de bits>
en el que se guar‐
dan los bits
(ARRAY de desti‐
no)

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo de ARRAY de origen con el límite inferior de "0"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArrayBool

Input

ARRAY[0..95] of BOOL

CounterOutput
DestinationArrayWord

UDINT
Output

ARRAY[0..5] of WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL GATHER_BLK
(IN := #SourceArrayBool[0]
COUNT_OUT := #CounterOutput
OUT => #DestinationArrayWord[2]

Programación del PLC
Manual de programación y manejo, 11/2019

2111

Instrucciones
4.1 Instrucciones
GRAPH
)

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayBool[0]

El operando "SourceArrayBool"
es del tipo de datos
ARRAY[0..95] of BOOL. Hay por
tanto 96 elementos BOOL dispo‐
nibles que pueden volver a reco‐
pilarse en palabras.

COUNT_OUT

CounterOutput = 3

UDINT3 (deben escribirse 3 pa‐
labras. Esto significa que en el
ARRAY de origen debe haber 48
bits).

OUT

DestinationArrayWord[2]

El operando "DestinationArray‐
Word" es del tipo de datos
ARRAY[0..5] of WORD. Hay 6
elementos WORD disponibles.

A partir del 1.er elemento del operando #SourceArrayBool se recomponen 48 bits en el
operando #DestinationArrayWord. En el ARRAY de destino se empieza a partir del 3.er
elemento. Esto significa que los primeros 16 bits se escriben en la 3.ª palabra, los segundos
16 bits en la 4.ª palabra y los terceros 16 bits en la 5.ª palabra del ARRAY de destino.

Ejemplo de ARRAY de origen con el límite inferior de "-2"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArrayBool

Input

ARRAY[-2..93] of BOOL

CounterOutput
DestinationArrayWord

UDINT
Output

ARRAY[0..5] of WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL GATHER_BLK
(IN := #SourceArrayBool[14]
COUNT_OUT := #CounterOutput
OUT => #DestinationArrayWord[2]
)

2112

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayBool[14]

El operando "SourceArrayBool"
es del tipo de datos
ARRAY[-2..93] of BOOL. Dado
que se empieza a partir del 16.º
elemento, hay solo 80 elemen‐
tos BOOL disponibles que pue‐
dan volver a recopilarse en pala‐
bras.

COUNT_OUT

CounterOutput = 3

UDINT3 (deben escribirse 3 pa‐
labras. Esto significa que en el
ARRAY de origen debe haber 48
bits).

OUT

DestinationArrayWord[2]

El operando "DestinationArray‐
Word" es del tipo de datos
ARRAY[0..5] of WORD. Hay 6
elementos WORD disponibles.

A partir del 16.º elemento del operando #SourceArrayBool se recopilan 48 bits en el operando
#DestinationArrayWord. En el ARRAY de destino se empieza a partir del 3.er elemento. Esto
significa que los primeros 16 bits del ARRAY de origen no se tienen en cuenta. Los segundos
16 bits se escriben en la 3.ª palabra, los terceros 16 bits en la 4.ª palabra y los cuartos 16 bits
en la 5.ª palabra del ARRAY de destino. Los 64 bits restantes del ARRAY de origen tampoco
se tienen en cuenta.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

SWAP: Cambiar disposición
Descripción
Con la instrucción "Cambiar disposición" se modifica la disposición de los bytes del operando.
Dependiendo del tipo de datos utilizado, se puede cambiar el orden de los bytes en todo el
acumulador 1 o solamente en la palabra derecha del acumulador 1.
La siguiente figura muestra cómo se cambian las posiciones de los bytes del operando del tipo
de datos DWORD:

Programación del PLC
Manual de programación y manejo, 11/2019

2113

Instrucciones
4.1 Instrucciones


,1

 

 
 

 

 



 

 



 

 

 

 

 



 

 



 

 


 


 



 
 

 






287

 



 

 




 

 




 

 

 

 


 


 

 

 





Disposición de los bytes en la palabra derecha del acumulador 1
Para el tipo de datos WORD se cambia la disposición de los bytes en la palabra derecha del
acumulador 1.
La tabla siguiente muestra el contenido del acumulador 1 antes y después de ejecutar la
instrucción:
Estado

Bytes del acumulador 1

Antes de la ejecución

Valor A

Valor B

Valor C

Valor D

Después de la ejecución

Valor A

Valor B

Valor D

Valor C

El resultado de la instrucción se guarda en la palabra derecha del acumulador 1. Los bytes de
la palabra izquierda del acumulador 1 no se ven influidos por la instrucción y no cambian.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

WORD, DWORD,
LWORD

I, Q, M, D, L o
constante

Operando cuyas
posiciones de
bytes se cambian

<Resultado>

Output

WORD, DWORD,
LWORD

I, Q, M, D, L

Resultado

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

2114

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := "SWAPTag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

0000

1111

0000

1111

Tag_OutValue

0000

1111

1111

0000

Cambiar la disposición de los bytes en todo el acumulador 1:
Para el tipo de datos DWORD se modifica la disposición de los bytes en todo el acumulador 1.
La tabla siguiente muestra el contenido del acumulador 1 antes y después de ejecutar la
instrucción:
Estado

Bytes del acumulador 1

Antes de la ejecución

Valor A

Valor B

Valor C

Valor D

Después de la ejecución

Valor D

Valor C

Valor B

Valor A

El resultado de la instrucción se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1111

0000

0000

1111

0000

0000

1111

1111

Tag_OutValue

1111

1111

0000

0000

0000

1111

1111

0000

La disposición de los bytes en el operando "Tag_InValue" se guarda cambiada en el operando
"Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

Programación del PLC
Manual de programación y manejo, 11/2019

2115

Instrucciones
4.1 Instrucciones

DB ARRAY
ReadFromArrayDB: Leer en un bloque de datos ARRAY
Descripción
La instrucción "Leer en un bloque de datos ARRAY" lee datos de un bloque de datos del tipo
ARRAY-DB y los escribe en un área de destino.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
[tipo de datos]. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier otro
tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

DB

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
lee

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB que se lee.
Puede ser una constante,
una variable global o un valor
indexado.

VALUE

Output 1)

VARIANT

L (puede declarar‐ Valor que se lee y se devuel‐
se en las seccio‐
ve
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

INT

I, Q, M, D, L, P

Resultado de la instrucción

1) El parámetro VALUE está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)

2116

0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

80B5

La operación de copia se ha cancelado.

8132

El bloque de datos no existe, es demasiado corto, está protegido contra escritura o está
en la memoria de carga.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*

Explicación

(W#16#...)
8135

El bloque de datos de ARRAY contiene valores no válidos.

8154

El bloque de datos es de un tipo incorrecto.

8282

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8450

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8452

Error de creación de código

8453

Hay dos posibles causas de error:
● El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque
de datos ARRAY.
● Ninguna de las dos variables se encuentra en un área de memoria con acceso
optimizado. Encontrará más información sobre los tipos de acceso al área de memoria
aquí: Fundamentos del acceso a bloques (Página 54)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL ReadFromArrayDB
(DB := "ArrayDB"
INDEX := 2
VALUE => "TargetField"
RET_VAL => "TagResult"
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
Array [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

TargetField

El operando "TargetField" es
una variable global del tipo de
datos INT.

El elemento se lee en el "ArrayDB" y se escribe en el operando "TargetField".

Programación del PLC
Manual de programación y manejo, 11/2019

2117

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Principios básicos de GRAPH (Página 8191)

WriteToArrayDB: Escribir en un bloque de datos ARRAY
Descripción
La instrucción "Escribir en un bloque de datos ARRAY" escribe datos en un bloque de datos del
tipo ARRAY-DB.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
[tipo de datos]. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier otro
tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

DB

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
escribe

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB en el que se
escribe. Puede ser una cons‐
tante, una variable global o
un valor indexado.

VALUE

Input

VARIANT

L (puede declarar‐ Valor que se escribe
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

INT

I, Q, M, D, L, P

Resultado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

2118

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

80B5

La operación de copia se ha cancelado.

8132

El bloque de datos no existe, es demasiado corto o está en la memoria de carga.

8134

El bloque de datos está protegido contra escritura.

8135

El bloque de datos no es un bloque de datos de ARRAY.

8154

El bloque de datos es de un tipo incorrecto.

8282

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8350

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8352

Error de creación de código

8353

Hay dos posibles causas de error:
● El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque
de datos ARRAY.
● Ninguna de las dos variables se encuentra en un área de memoria con acceso
optimizado. Encontrará más información sobre los tipos de acceso al área de memoria
aquí: Fundamentos del acceso a bloques (Página 54)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL WriteToArrayDB
(DB := "ArrayDB"
INDEX := 2
VALUE := "SourceField"
RET_VAL => "TagResult"
)

Programación del PLC
Manual de programación y manejo, 11/2019

2119

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
Array [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

SourceField

El operando "SourceField" es
una variable global del tipo de
datos INT.

El valor del operando "SourceField" se escribe en el segundo elemento del DB de ARRAY.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Principios básicos de GRAPH (Página 8191)

ReadFromArrayDBL: Leer en un bloque de datos ARRAY de la memoria de carga
Descripción
Con la instrucción "Leer en un bloque de datos ARRAY de la memoria de carga" se leen los
datos de un bloque de datos del tipo de bloque ARRAY-DB en la memoria de carga y se
escriben en un área de destino.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
[tipo de datos]. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier otro
tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".
Si el bloque de datos ARRAY se ha marcado con el atributo de bloque "Depositar sólo en la
memoria de carga", se guarda únicamente en la memoria de carga.
Si en el parámetro REQ se detecta un flanco de señal ascendente, se ejecuta la instrucción.
El parámetro BUSY devuelve el estado lógico "1". Si en el parámetro BUSY se detecta un
flanco de señal descendente, finaliza la instrucción. Durante un ciclo del programa, el
parámetro DONE tiene el estado lógico "1" y durante este ciclo se emite el valor leído en el
parámetro VALUE. En los demás ciclos del programa, el valor del parámetro VALUE no se
modifica.

2120

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o
constante

REQ = "1": Comenzar la lec‐
tura del DB de ARRAY

DB 1)

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
lee

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB que se lee.
Puede ser una constante,
una variable global o un valor
indexado.

VALUE 1)

InOut

VARIANT

D (elemento de un
bloque de datos
global)

Puntero al bloque de datos
de la memoria de trabajo que
se lee y cuyo valor se escribe.

L (puede declarar‐ No está permitido utilizar
constantes locales o varia‐
se en las seccio‐
bles de la sección TEMP.
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)
BUSY

Output

BOOL

I, Q, M, D, L

BUSY = "1": La lectura del
DB de ARRAY todavía no ha
finalizado

DONE

Output

BOOL

I, Q, M, D, L

DONE = "1": La instrucción
se ha ejecutado correcta‐
mente

ERROR

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro ERROR devuel‐
ve un código de error cuando
ocurre un error durante la eje‐
cución de la instrucción.

1)

Los bloques de datos deben crearse con la propiedad de bloque "Optimizado".

Parámetro ERROR
La tabla siguiente muestra el significado de los valores del parámetro ERROR:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8230

El número del bloque de datos es incorrecto.

8231

El bloque de datos no existe.

8232

El bloque de datos es demasiado corto o no está en la memoria de carga.

8235

El bloque de datos no es un DB de ARRAY.

8254

El bloque de datos es de un tipo incorrecto.

Programación del PLC
Manual de programación y manejo, 11/2019

2121

Instrucciones
4.1 Instrucciones
Código de
error*

Explicación

(W#16#...)
8382

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8750

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8751

Error de creación de código

8752

Error de creación de código

8753

El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque de
datos ARRAY.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Encontrará la descripción de los códigos de error activados por las instrucciones "READ_DBL"
y "WRIT_DBL" en las descripciones de las instrucciones correspondientes.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL ReadFromArrayDBL DB_ANY, "ReadFromArrayDBL_DB"
(REQ := "TagReg"
DB := "ArrayDB"
INDEX := 2
VALUE := "TargetField"
BUSY => "TagBusy"
DONE => "TagDone"
ERROR => "TagError"
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

REQ

TagReq

BOOL

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
ARRAY [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

TargetField

El operando "TargetField" es
una variable global del tipo de
datos INT.

BUSY

TagBusy

BOOL

DONE

TagDone

BOOL

Si en el operando "TagReq" se detecta un flanco de señal ascendente, se ejecuta la
instrucción. El segundo elemento se lee en el "ArrayDB" y se devuelve en el parámetro
"VALUE". En cuanto se detecta un flanco de señal descendente en el operando "TagBusy",

2122

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
finaliza la instrucción y el valor del parámetro VALUE ya no se modifica. Después de ejecutar
la instrucción, el operando "TagDone" tiene el estado lógico TRUE.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)
Principios básicos de GRAPH (Página 8191)

WriteToArrayDBL: Escribir en un bloque de datos ARRAY de la memoria de carga
Descripción
La instrucción "Escribir en un bloque de datos ARRAY de la memoria de carga" escribe datos
en un bloque de datos del tipo ARRAY-DB de la memoria de carga.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
[tipo de datos]. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier otro
tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".
Si el bloque de datos ARRAY se ha marcado con el atributo de bloque "Depositar sólo en la
memoria de carga", se guarda únicamente en la memoria de carga.
Si en el parámetro REQ se detecta un flanco de señal ascendente, se ejecuta la instrucción.
El parámetro BUSY devuelve el estado lógico "1". Si en el parámetro BUSY se detecta un
flanco de señal descendente, finaliza la instrucción y el valor del parámetro VALUE se escribe
en el bloque de datos. Durante un ciclo del programa, el parámetro DONE tiene el estado
lógico "1".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o
constante

REQ = "1": Comenzar a es‐
cribir en el DB de array

DB 1)

Input

DB_ANY

I, Q, M, D, L

Bloque de datos ARRAY en
el que se escribe

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB en el que se
escribe. Puede ser una cons‐
tante, una variable global o
un valor indexado.

Programación del PLC
Manual de programación y manejo, 11/2019

2123

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

VALUE 1)

Input

VARIANT

D (elemento de un
bloque de datos
global)

Puntero al bloque de datos
de la memoria de trabajo que
se lee y cuyo valor se escribe.

L (puede declarar‐ No está permitido utilizar
constantes locales o varia‐
se en las seccio‐
bles de la sección TEMP.
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)
BUSY

Output

BOOL

I, Q, M, D, L

BUSY = "1": Todavía no se
ha terminado de escribir en el
DB de array

DONE

Output

BOOL

I, Q, M, D, L

DONE = "1": La instrucción
se ha ejecutado correcta‐
mente

ERROR

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro ERROR devuel‐
ve un código de error cuando
ocurre un error durante la eje‐
cución de la instrucción.

1)

Los bloques de datos deben crearse con la propiedad de bloque "Optimizado".

Parámetro ERROR
La tabla siguiente muestra el significado de los valores del parámetro ERROR:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8230

El número del bloque de datos es incorrecto.

8231

El bloque de datos no existe.

8232

El bloque de datos es demasiado corto o no está en la memoria de carga.

8234

El bloque de datos está protegido contra escritura.

8235

El bloque de datos no es un DB de ARRAY.

8254

El bloque de datos es de un tipo incorrecto.

8382

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8450

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8751

Error de creación de código

8752

Error de creación de código

8753

El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque de
datos ARRAY.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

2124

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará la descripción de los códigos de error activados por las instrucciones "READ_DBL"
y "WRIT_DBL" en las descripciones de las instrucciones correspondientes.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL WriteToArrayDBL DB_ANY, "WriteToArrayDBL_DB"
(REQ := "TagReg"
DB := "ArrayDB"
INDEX := 2
VALUE := "SourceField"
BUSY => "TagBusy"
DONE => "TagDone"
ERROR => "TagError"
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

REQ

TagReq

BOOL

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
ARRAY [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

SourceField

El operando "SourceField" es
una variable global del tipo de
datos INT.

BUSY

TagBusy

BOOL

DONE

TagDone

BOOL

Si en el operando "TagReq" se detecta un flanco de señal ascendente, se ejecuta la
instrucción. En cuanto se detecta un flanco descendente en el operando "TagBusy", la
instrucción finaliza y el valor del parámetro VALUE se escribe en el segundo elemento del
"ArrayDB". Después de ejecutar la instrucción, el operando "TagDone" tiene el estado lógico
TRUE.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Ejemplo de uso de bloques de datos ARRAY (Página 43)

Programación del PLC
Manual de programación y manejo, 11/2019

2125

Instrucciones
4.1 Instrucciones
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)
Principios básicos de GRAPH (Página 8191)

Legacy
BLKMOV: Copiar área
Descripción
La instrucción "Copiar área" copia los contenidos de un área de memoria (área de origen) en
un área de memoria diferente (área de destino). La operación de copia se realiza por orden
ascendente de direcciones. Las áreas de origen y destino se definen mediante VARIANT.
Nota
Las variables de la instrucción solo se pueden usar en las áreas de memoria en las que no esté
activado el atributo "Acceso optimizado al bloque". Esto es válido para bloques de datos (DB),
bloques de organización (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucción se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable también se puede usar en áreas de memoria "con acceso
optimizado al bloque".
La figura siguiente muestra el principio de la operación de copia:

'%'%:

$

%

'%'%:

&

'

'%'%:

(

)

'%'%:

*

+

&RSLDU
/DFRSLDVHHIHFW¼DHQ
VHQWLGRDVFHQGHQWHGH
ODVGLUHFFLRQHV

0:

$

%

0:

&

'

0:

(

)

0:

*

+

UHDGHPHPRULD

2126

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Coherencia de los datos de origen y destino
Tenga en cuenta que al ejecutar la instrucción "Copiar área" no se modifican los datos de
origen. De lo contrario no está garantizada la coherencia de los datos de destino.

Posibilidad de interrupción
No hay limitaciones en cuanto a la profundidad de anidamiento.

Áreas de memoria
La instrucción "Copiar área" permite copiar las siguientes áreas de memoria:
● Áreas de un bloque de datos
● Marcas
● Memoria imagen de proceso de las entradas
● Memoria imagen de proceso de las salidas

Reglas generales para copiar
Las áreas de origen y destino no deben solaparse. Si las áreas de origen y destino son de
diferente longitud, se copia solo hasta la longitud del área más pequeña.
Si el área de origen es más pequeña que el área de destino, el área de origen se copiará por
completo en el área de destino. Los restantes bytes del área de destino permanecen
inalterados.
Si el área de destino es más pequeña que el área de origen, se escribirá en toda el área de
destino. Los restantes bytes del área de origen se ignoran.
Al copiar un área del tipo de datos BOOL, la variable debe direccionarse de forma absoluta y
la longitud indicada del área debe ser un múltiplo de 8, pues de lo contrario no se ejecutará la
instrucción.

Reglas para copiar cadenas de caracteres
La instrucción "Copiar área" permite copiar asimismo áreas de origen y destino del tipo de
datos STRING. Si solo el área de origen es del tipo de datos STRING, se copiarán los
caracteres realmente contenidos en la cadena de caracteres. La información sobre la longitud
real y máxima también se escribe en el área de destino. Si tanto el área de origen como el área
de destino son del tipo de datos STRING, la longitud actual de la cadena de caracteres en el
área de destino se pone al número de caracteres realmente copiados.
Si se desea copiar información sobre la longitud máxima y real de una cadena de caracteres,
las áreas de los parámetros SRCBLK y DSTBLK deben indicarse en bytes.

Programación del PLC
Manual de programación y manejo, 11/2019

2127

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRCBLK

Input

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria que se copia (área de ori‐
gen).

RET_VAL

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando se produce un error
durante la ejecución de la ins‐
trucción.

DSTBLK

Output

VARIANT 1)

I, Q, M, D, L, P

Indicación del área de memo‐
ria en la que se copia (área
de destino).

1) El parámetro DSTBLK está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse en la interfaz del bloque como InOut.

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

8092

El área de origen o destino está solo en la memoria de carga.

8152

En el parámetro SRCBLK no se soportan los tipos de datos WSTRING, WCHAR, BOOL
y ARRAY of STRING.

8352

En el parámetro DSTBLK no se soportan los tipos de datos WSTRING, WCHAR, BOOL
y ARRAY of STRING.

Información
de error ge‐
neral

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL BLKMOV VARIANT
(SRCBLK := P#M100.0 BYTE 10
RET_VAL => "Tag_ErrorCode"
DSTBLK => P#DB1.DBX0.0 BYTE 10
)

2128

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucción copia 10 bytes a partir de MB100 y los escribe en el DB1. Si ocurre un error
durante la operación de copia, el respectivo código de error se indica en la variable
"Tag_ErrorCode".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
GET_ERR_ID: Consultar ID de error localmente (Página 2159)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de GRAPH (Página 8191)

UBLKMOV: Copiar área sin interrupciones
Descripción
La instrucción "Copiar área sin interrupciones" copia los contenidos de un área de memoria
(área de origen) en un área de memoria diferente (área de destino). La operación de copia se
realiza por orden ascendente de direcciones. Las áreas de origen y destino se definen
mediante VARIANT.
La operación de copia no debe ser interrumpida por otras actividades del sistema operativo.
Ello puede aumentar el tiempo de reacción a alarmas de la CPU durante la ejecución de la
instrucción "Copiar área sin interrupciones".
Nota
Las variables de la instrucción solo se pueden usar en las áreas de memoria en las que no esté
activado el atributo "Acceso optimizado al bloque". Esto es válido para bloques de datos (DB),
bloques de organización (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucción se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable también se puede usar en áreas de memoria "con acceso
optimizado al bloque".

Áreas de memoria
La instrucción "Copiar área sin interrupciones" permite copiar las siguientes áreas de memoria:
● Áreas de un bloque de datos
● Marcas
● Memoria imagen de proceso de las entradas
● Memoria imagen de proceso de las salidas

Programación del PLC
Manual de programación y manejo, 11/2019

2129

Instrucciones
4.1 Instrucciones

Reglas generales para copiar
Al ejecutar la instrucción "Copiar área sin interrupciones" no pueden solaparse las áreas de
origen y destino. Si el área de origen es más pequeña que el área de destino, el área de origen
se copiará por completo en el área de destino. Los restantes bytes del área de destino
permanecen inalterados.
Si el área de destino es más pequeña que el área de origen, se escribirá en toda el área de
destino. Los restantes bytes del área de origen se ignoran.
Si un área de origen o destino definida como parámetro formal es menor que un área de origen
o destino indicada en los parámetros SRCBLK o DSTBLK, no se transferirán datos.
Al copiar un área del tipo de datos BOOL, la variable debe direccionarse de forma absoluta y
la longitud indicada del área debe ser un múltiplo de 8, pues de lo contrario no se ejecutará la
instrucción.
La instrucción "Copiar área sin interrupciones" permite copiar 16 KB como máximo. A este
respecto deben tenerse en cuenta las limitaciones específicas de la CPU.

Reglas para copiar cadenas de caracteres
La instrucción "Copiar área sin interrupciones" permite copiar asimismo áreas de origen y
destino del tipo de datos STRING. Si solo el área de origen es del tipo de datos STRING, se
copiarán los caracteres realmente contenidos en la cadena de caracteres. La información
sobre la longitud real y máxima no se escribe en el área de destino. Si tanto el área de origen
como el área de destino son del tipo de datos STRING, la longitud actual de la cadena de
caracteres en el área de destino se pone al número de caracteres realmente copiados. Si se
copian áreas del tipo de datos STRING, debe indicarse "1" como longitud del área.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRCBLK

Input

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria que se copia (área de ori‐
gen).

RET_VAL

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando se produce un error
durante la ejecución de la ins‐
trucción.

DSTBLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria en la que se copia (área
de destino).

1) El parámetro DSTBLK está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse en la interfaz del bloque como InOut.

2130

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

8091

El área de origen o destino está solo en la memoria de carga.

8152

En el parámetro SRCBLK no se soportan los tipos de datos WSTRING, WCHAR, BOOL
y ARRAY of STRING.

8352

En el parámetro DSTBLK no se soportan los tipos de datos WSTRING, WCHAR, BOOL
y ARRAY of STRING.

Información
de error ge‐
neral

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL UBLKMOV VARIANT
(SRCBLK := P#M100.0 BYTE 10
RET_VAL => "Tag_ErrorCode"
DSTBLK => P#DB1.DBX0.0 BYTE 10
)

La instrucción copia 10 bytes a partir de MB100 y los escribe en el DB1. Si ocurre un error
durante la operación de copia, el respectivo código de error se indica en la variable
"Tag_ErrorCode".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
GET_ERR_ID: Consultar ID de error localmente (Página 2159)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de GRAPH (Página 8191)

Programación del PLC
Manual de programación y manejo, 11/2019

2131

Instrucciones
4.1 Instrucciones

FILL: Rellenar área
Descripción
La instrucción "Rellenar área" rellena un área de memoria (área de destino) con el contenido
de un área de memoria diferente (área de origen). La instrucción "Rellenar área" copia el
contenido del área de origen en el área de destino hasta que el área de destino quede escrita
por completo. La operación de copia se realiza por orden ascendente de direcciones.
Las áreas de origen y destino se definen mediante VARIANT.
Nota
Las variables de la instrucción solo se pueden usar en las áreas de memoria en las que no esté
activado el atributo "Acceso optimizado al bloque". Esto es válido para bloques de datos (DB),
bloques de organización (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucción se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable también se puede usar en áreas de memoria "con acceso
optimizado al bloque".
Para los bloques con el atributo "Acceso optimizado al bloque" puede utilizarse la instrucción
"FILL_BLK: Rellenar área".
La figura siguiente muestra el principio de la operación de copia:
),//

%9$/

$

%

0:

$

%

0:

&

'

0:

&

'

0:

(

)

0:

(

)

0:

*

+

0:

*

+

0:

$

%

0:

&

'

0:

(

)

0:

*

+

0:

$

%

0:

&

'

0:

%/.

Ejemplo: el contenido del área MW100 a MW118 debe inicializarse con el contenido de las
palabras de marcas MW14 a MW20.

2132

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Coherencia de los datos de origen y destino
Tenga en cuenta que al ejecutar la instrucción "Rellenar área" no se modifican los datos de
origen, pues de lo contrario no se podría garantizar la coherencia de los datos de destino.

Áreas de memoria
La instrucción "Rellenar área" permite copiar las siguientes áreas de memoria:
● Áreas de un bloque de datos
● Marcas
● Memoria imagen de proceso de las entradas
● Memoria imagen de proceso de las salidas

Reglas generales para copiar
Las áreas de origen y destino no deben solaparse. Aunque el área de destino que se debe
inicializar no sea múltiplo entero de la longitud del parámetro de entrada BVAL, el área de
destino se rellenará igualmente hasta el último byte.
Si el área de destino que se debe preasignar es menor que el área de origen, solo se copian
los datos que caben en el área de destino.
Si el área de destino o de origen disponible realmente es menor que el tamaño del área de
memoria parametrizada para el área de origen o destino (parámetros BVAL, BLK), los datos no
se transfieren.
Si el puntero ANY (origen o destino) es del tipo de datos BOOL, debe direccionarse de forma
absoluta y la longitud indicada del área debe ser un múltiplo de 8, pues de lo contrario no se
ejecutará la instrucción.
Si el área de destino es del tipo de datos STRING, la instrucción escribe la cadena de
caracteres completa, incluida la información de administración.

Reglas para copiar estructuras
Al indicar una estructura a modo de parámetro de entrada, tenga en cuenta que la longitud de
una estructura se rige siempre por un número entero de bytes. Si se declara una estructura con
un número impar de bytes, esta estructura necesita un byte adicional de espacio en memoria.

Programación del PLC
Manual de programación y manejo, 11/2019

2133

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

BVAL

Input

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria (área de origen) con cuyo
contenido se rellena el área
de destino en el parámetro
BLK.

RET_VAL

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando se produce un error
durante la ejecución de la ins‐
trucción.

BLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria que se rellena con el con‐
tenido del área de origen.

1) El parámetro BLK está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse en la interfaz del bloque como InOut.

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

8092

El área de origen o destino está solo en la memoria de carga.

8152

En el parámetro BVAL no se soportan los tipos de datos WSTRING, WCHAR, BOOL
y ARRAY of STRING.

8352

En el parámetro BLK no se soportan los tipos de datos WSTRING, WCHAR, BOOL y
ARRAY of STRING.

Información de
error general

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL FILL VARIANT
(BVAL := P#M14.0 WORD 4
RET_VAL => "Tag_ErrorCode"
BLK => P#M100.0 WORD 10

2134

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
GRAPH
)

La instrucción copia el área de origen de MW14 a MW20 y rellena el área de destino de MW100
a MW118 con el contenido de las 4 palabras contenidas en el área de memoria del parámetro
BVAL.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
GET_ERR_ID: Consultar ID de error localmente (Página 2159)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de GRAPH (Página 8191)

Conversión
CONVERT: Convertir valor
Descripción
La instrucción "Convertir valor" lee el contenido del operando y lo convierte según los tipos de
datos parametrizados.
Encontrará información relacionada con las conversiones posibles en el apartado "Conversión
explícita" de "Consulte también".
El valor del resultado no es válido si se producen errores durante la ejecución, p. ej. un
desbordamiento.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números binarios,
enteros, números
en coma flotante,
CHAR, WCHAR,
BCD16, BCD32

I, Q, M, D, L, P o
constante

Valor que se convierte.

<Resultado>

Output

Números binarios,
enteros, números
en coma flotante,
CHAR, WCHAR,
BCD16, BCD32

I, Q, M, D, L, P

Resultado de la conversión

En las listas desplegables "???" puede seleccionar los tipos de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

2135

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := INT_TO_DINT("Tag_InValue")

El contenido del operando "Tag_InValue" se lee y se convierte en un entero (32 bits). El
resultado se deposita en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)
Conversiones explícitas (Página 422)

ROUND: Redondear número
Descripción
La instrucción "Redondear número" permite redondear el valor del operando al siguiente
número entero. La instrucción interpreta el valor como número en coma flotante y lo convierte
al número entero más próximo. Si en el valor de entrada se encuentra entre un número par y
uno impar, se selecciona el número par.
El valor del resultado no es válido si se producen errores durante la ejecución, p. ej. un
desbordamiento.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada que se re‐
dondea.

<Resultado>

Output

Enteros, números
en coma flotante

I, Q, M, D, L, P

Resultado del redondeo

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := ROUND("Tag_InValue")

2136

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1.50000000

-1.50000000

Tag_OutValue

2

-2

El número en coma flotante del operando "Tag_InValue" se redondea al número entero par
más próximo y se indica en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

CEIL: Redondear un número en coma flotante al siguiente entero superior
Descripción
La instrucción "Redondear un número en coma flotante al siguiente entero superior" permite
redondear el valor del operando al siguiente número entero superior. La instrucción interpreta
el valor como número en coma flotante y lo convierte al siguiente número entero superior. El
resultado puede ser mayor o igual que el valor de entrada.
El valor del resultado no es válido si se producen errores durante la ejecución, p. ej. un
desbordamiento.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada como núme‐
ro en coma flotante

<Resultado>

Output

Enteros, números
en coma flotante

I, Q, M, D, L, P

Resultado con el siguiente
entero superior

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := CEIL("Tag_InValue")

Programación del PLC
Manual de programación y manejo, 11/2019

2137

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

0.50000000

-0.50000000

Tag_OutValue

1

0

El número en coma flotante del operando "Tag_InValue" se redondea al siguiente número
entero superior y se indica en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

FLOOR: Redondear un número en coma flotante al siguiente entero inferior
Descripción
La instrucción "Redondear un número en coma flotante al siguiente entero inferior" permite
redondear el valor del operando al siguiente número entero inferior. La instrucción interpreta
el valor como número en coma flotante y lo convierte al siguiente número entero inferior. El
resultado puede ser menor o igual que el valor de entrada.
El valor del resultado no es válido si se producen errores durante la ejecución, p. ej. un
desbordamiento.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada como núme‐
ro en coma flotante

<Resultado>

Output

Enteros, números
en coma flotante

I, Q, M, D, L, P

Resultado con el siguiente
entero inferior

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := FLOOR("Tag_InValue")

2138

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

0.50000000

-0.50000000

Tag_OutValue

0

-1

El número en coma flotante del operando "Tag_InValue" se redondea al siguiente número
entero inferior y se indica en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

TRUNC: Truncar a entero
Descripción
La instrucción "Truncar a entero" permite generar un número entero a partir del valor del
operando. El valor se interpreta como número en coma flotante. La instrucción selecciona solo
la parte entera del número en coma flotante y la indica sin decimales como resultado.
El valor del resultado no es válido si se producen errores durante la ejecución, p. ej. un
desbordamiento.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L o
constante

Valor de entrada como núme‐
ro en coma flotante

<Resultado>

Output

Enteros, números
en coma flotante

I, Q, M, D, L

Resultado con la parte ente‐
ra del número en coma flo‐
tante

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := TRUNC("Tag_InValue")

Programación del PLC
Manual de programación y manejo, 11/2019

2139

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1.50000000

-1.50000000

Tag_OutValue

1

-1

La parte entera del número en coma flotante del operando "Tag_InValue" se convierte en un
número entero y se indica en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

SCALE_X: Escalar
Descripción
La instrucción "Escalar" escala el valor del parámetro VALUE mapeándolo en un determinado
rango de valores. Al ejecutar la instrucción, el número en coma flotante del parámetro VALUE
se escala al rango de valores definido por los parámetros MIN y MAX. El resultado de la escala
es un número entero que se deposita en la salida OUT.
La figura siguiente muestra un ejemplo de cómo pueden escalarse los valores:

0$;
287
0,1



9$/8(

La instrucción "Escalar" utiliza la siguiente ecuación:
OUT = [VALUE ∗ (MAX – MIN)] + MIN

2140

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El valor del resultado no es válido si se cumple una de las siguientes condiciones:
● El valor del parámetro MIN es mayor o igual que el valor del parámetro MAX.
● El valor de un número en coma flotante indicado está fuera del rango de los números
normalizados según IEEE-754.
● Ocurre un rebase por exceso.
● El valor del parámetro VALUE es NaN (Not a number = resultado de una operación
aritmética no válida).
Nota
Encontrará más información sobre la conversión de valores analógicos en el manual de
producto correspondiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MIN

Input

Enteros, números
en coma flotante

I, Q, M, D, L o
constante

Límite inferior del rango de
valores

VALUE

Input

Números en coma
flotante

I, Q, M, D, L o
constante

Valor que se escala.
Si se indica una constante,
esta debe declararse.

MAX

Input

Enteros, números
en coma flotante

I, Q, M, D, L o
constante

Límite superior del rango de
valores

RET_VAL

Output

Enteros, números
en coma flotante

I, Q, M, D, L

Resultado de la escala

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL SCALE_X INT_REAL
(MIN := "Tag_Minimum"
VALUE := "Tag_Value"
MAX := "Tag_Maximum"
RET_VAL => "Tag_OutputValue"
)

Programación del PLC
Manual de programación y manejo, 11/2019

2141

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

MIN

Tag_Minimum

10

VALUE

Tag_Value

0.5

MAX

Tag_Maximum

30

RET_VAL

Tag_ReturnValue

20

El valor del parámetro "Tag_Value" se escala al rango de valores definido por los valores de los
parámetros "Tag_Minimum" y "Tag_Maximum". El resultado se deposita en el parámetro
"Tag_ReturnValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de GRAPH (Página 8191)

NORM_X: Normalizar
Descripción
La instrucción "Normalizar" permite normalizar el valor del parámetro VALUE mapeándolo en
una escala lineal. Los parámetros MIN y MAX sirven para definir los límites de un rango de
valores que se refleja en la escala. En función de la posición del valor que se debe normalizar
en este rango de valores, el resultado se calcula y se deposita como número en coma flotante
en el parámetro OUT. Si el valor que se debe normalizar es igual al valor del parámetro MIN,
el parámetro OUT devuelve el valor "0.0". Si el valor que se debe normalizar es igual al valor
del parámetro MAX, el parámetro OUT devuelve el valor "1.0".
La figura siguiente muestra un ejemplo de cómo pueden normalizarse los valores:

2142

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones


287

0,1

0$;
9$/8(

La instrucción "Normalizar" utiliza la siguiente ecuación:
OUT = (VALUE – MIN) / (MAX – MIN)
El valor del resultado no es válido si se cumple una de las siguientes condiciones:
● El valor del parámetro MIN es mayor o igual que el valor del parámetro MAX.
● El valor de un número en coma flotante indicado está fuera del rango de los números
normalizados según IEEE-754.
● Ocurre un rebase por exceso.
● El valor del parámetro VALUE es NaN (Not a number = resultado de una operación
aritmética no válida).
Nota
Encontrará más información sobre la conversión de valores analógicos en el manual de
producto correspondiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MIN

Input

Enteros, números
en coma flotante

I, Q, M, D, L o
constante

Límite inferior del rango de
valores

VALUE 1)

Input

Enteros, números
en coma flotante

I, Q, M, D, L o
constante

Valor que se normaliza

MAX 1)

Input

Enteros, números
en coma flotante

I, Q, M, D, L o
constante

Límite superior del rango de
valores

1)

Programación del PLC
Manual de programación y manejo, 11/2019

2143

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RET_VAL

Output

Números en coma
flotante

I, Q, M, D, L

Resultado de la normaliza‐
ción

1)

Si se utilizan constantes en estos tres parámetros, basta con declarar una de ellas.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Encontrará más información sobre la declaración de constantes en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL NORM_X INT_REAL
(MIN := "Tag_Minimum"
VALUE := "Tag_Value"
MAX := "Tag_Maximum"
RET_VAL => "Tag_OutputValue"
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

MIN

Tag_Minimum

10

VALUE

Tag_Value

20

MAX

Tag_Maximum

30

RET_VAL

Tag_ReturnValue

0.5

El valor del parámetro "Tag_Value" se asigna al rango de valores definido por los valores de
los parámetros "Tag_Minimum" y "Tag_Maximum". El valor de la variable del parámetro
"Tag_Value" se normaliza conforme al rango de valores definido. El resultado se deposita
como número en coma flotante en el parámetro "Tag_ReturnValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de GRAPH (Página 8191)

2144

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Legacy
SCALE: Escalar
Descripción
La instrucción "Escalar" convierte el entero del parámetro IN en un número en coma flotante
que se escala en unidades físicas entre un límite inferior y uno superior. Los límites inferior y
superior del rango de valores en el que se escala el valor de entrada se definen mediante los
parámetros LO_LIM y HI_LIM. El resultado de la instrucción se devuelve en el parámetro OUT.
La instrucción "Escalar" utiliza la siguiente ecuación:
OUT = [((FLOAT (IN) – K1)/(K2–K1)) ∗ (HI_LIM–LO_LIM)] + LO_LIM
El estado lógico del parámetro BIPOLAR determina los valores de las constantes "K1" y "K2".
El parámetro BIPOLAR puede tener los siguientes estados lógicos:
● Estado lógico "1": Se presupone que el valor del parámetro IN es bipolar y está
comprendido en un rango de valores entre -27 648 y 27 648. En este caso, la constante "K1"
tiene el valor "-27 648,0", y la constante "K2", el valor "+27 648,0".
● Estado lógico "0": Se presupone que el valor del parámetro IN es unipolar y está
comprendido en un rango de valores entre 0 y 27 648. En este caso, la constante "K1" tiene
el valor "0,0", y la constante "K2", el valor "+27 648,0".
Si el valor del parámetro IN es mayor que el de la constante "K2", el resultado de la instrucción
se pone al valor del límite superior (HI_LIM) y se emite un error.
Si el valor del parámetro IN es menor que el de la constante "K1", el resultado de la instrucción
se pone al valor del límite inferior (LO_LIM) y se emite un error.
Si el límite inferior indicado es mayor que el límite superior (LO_LIM > HI_LIM), el resultado se
escala de forma inversamente proporcional al valor de entrada.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

INT

I, Q, M, D, L, P o
constante

Valor de entrada
que se escala.

HI_LIM

Input

REAL

I, Q, M, D, L, P o
constante

Valor límite supe‐
rior

LO_LIM

Input

REAL

I, Q, M, D, L, P o
constante

Valor límite inferior

Programación del PLC
Manual de programación y manejo, 11/2019

2145

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

BIPOLAR

Input

BOOL

I, Q, M, D, L o
constante

Indica si el valor
del parámetro IN
se interpreta como
bipolar o unipolar.
El parámetro pue‐
de adoptar los va‐
lores siguientes:
1: Bipolar
0: Unipolar

RET_VAL

Output

WORD

I, Q, M, D, L, P

Información de
error

OUT

Output

REAL

I, Q, M, D, L, P

Resultado de la
instrucción

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

0008

El valor del parámetro IN es mayor que el de la constante "K2" o menor que el de la
constante "K1".

Información
de error ge‐
neral

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL SCALE
(IN := "Tag_InputValue"
HI_LIM := "Tag_HighLimit"
LO_LIM := "Tag_LowLimit"
BIPOLAR := "Tag_Bipolar"
RET_VAL => "Tag_ErrorCode"
OUT => "Tag_OutputValue"
)

2146

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra los valores de los distintos operandos antes de ejecutar la
instrucción:
Parámetro

Operando

Valor

IN

Tag_InputValue

22

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

RET_VAL

Tag_ErrorCode

W#16#0000

OUT

Tag_OutputValue

0.0

La tabla siguiente muestra los valores de los distintos operandos después de ejecutar la
instrucción:
Parámetro

Operando

Valor

IN

Tag_InputValue

22

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

RET_VAL

Tag_ErrorCode

W#16#0000

OUT

Tag_OutputValue

50.03978588

En el operando "Tag_InputValue" se indica el valor que debe convertirse y escalarse. El valor
límite superior y el inferior se definen mediante los operandos "Tag_HighLimit" y
"Tag_LowLimit". Con ayuda del operando "Tag_Bipolar" = TRUE se indica que el valor del
parámetro IN debe interpretarse como bipolar. En el operando "Tag_OutputValue" se indica el
resultado de la instrucción.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
GET_ERR_ID: Consultar ID de error localmente (Página 2159)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de GRAPH (Página 8191)

UNSCALE: Desescalar
Descripción
La instrucción "Desescalar" permite desescalar el número en coma flotante del parámetro IN
en unidades físicas comprendidas entre un límite inferior y uno superior y convertirlo en un
número entero. Los límites inferior y superior del rango de valores en el que se desescala el
valor de entrada se definen mediante los parámetros LO_LIM y HI_LIM. El resultado de la
instrucción se devuelve en el parámetro OUT.
La instrucción "Desescalar" utiliza la siguiente ecuación:

Programación del PLC
Manual de programación y manejo, 11/2019

2147

Instrucciones
4.1 Instrucciones
OUT = [((IN–LO_LIM)/(HI_LIM–LO_LIM)) ∗ (K2–K1) ] + K1
El estado lógico del parámetro BIPOLAR determina los valores de las constantes "K1" y "K2".
El parámetro BIPOLAR puede tener los siguientes estados lógicos:
● Estado lógico "1": Se presupone que el valor del parámetro IN es bipolar y está
comprendido en un rango de valores entre -27 648 y 27 648. En este caso, la constante "K1"
tiene el valor "-27 648,0", y la constante "K2", el valor "+27 648,0".
● Estado lógico "0": Se presupone que el valor del parámetro IN es unipolar y está
comprendido en un rango de valores entre 0 y 27 648. En este caso, la constante "K1" tiene
el valor "0,0", y la constante "K2", el valor "+27 648,0".
Si el valor del parámetro IN no se encuentra dentro de los límites definidos por HI_LIM y
LO_LIM, se emite un error. El resultado se ajusta al límite más próximo.
Si el límite inferior indicado es mayor que el límite superior (LO_LIM > HI_LIM), el resultado se
escala de forma inversamente proporcional al valor de entrada.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

REAL

I, Q, M, D, L, P o
constante

Valor de entrada
que se desescala
en un valor entero.

HI_LIM

Input

REAL

I, Q, M, D, L, P o
constante

Valor límite supe‐
rior

LO_LIM

Input

REAL

I, Q, M, D, L, P o
constante

Valor límite inferior

BIPOLAR

Input

BOOL

I, Q, M, D, L o
constante

Indica si el valor
del parámetro IN
se interpreta como
bipolar o unipolar.
El parámetro pue‐
de adoptar los va‐
lores siguientes:
1: Bipolar
0: Unipolar

2148

RET_VAL

Output

WORD

I, Q, M, D, L, P

Información de
error

OUT

Output

INT

I, Q, M, D, L, P

Resultado de la
instrucción

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error
(W#16#....)

Explicación

0000

Ningún error

0008

El valor del parámetro IN es mayor que el del límite superior (HI_LIM) o menor que el del
límite inferior (LO_LIM).

Información
de error ge‐
neral

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización aquí: Cambiar
formatos de visualización en el estado del programa (Página 8529)

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL UNSCALE
(IN := "Tag_InputValue"
HI_LIM := "Tag_HighLimit"
LO_LIM := "Tag_LowLimit"
BIPOLAR := "Tag_Bipolar"
RET_VAL => "Tag_ErrorCode"
OUT => "Tag_OutputValue"
)

La tabla siguiente muestra los valores de los distintos operandos antes de ejecutar la
instrucción:
Parámetro

Operando

Valor

IN

Tag_InputValue

50.03978588

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

RET_VAL

Tag_ErrorCode

W#16#0000

OUT

Tag_OutputValue

0.0

La tabla siguiente muestra los valores de los distintos operandos después de ejecutar la
instrucción:
Parámetro

Operando

Valor

IN

Tag_InputValue

50.03978588

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

Programación del PLC
Manual de programación y manejo, 11/2019

2149

Instrucciones
4.1 Instrucciones
Parámetro

Operando

Valor

BIPOLAR

Tag_Bipolar

1

RET_VAL

Tag_ErrorCode

W#16#0000

OUT

Tag_OutputValue

22

En el operando "Tag_InputValue" se indica el valor que debe convertirse y desescalarse. El
valor límite superior y el inferior se definen mediante los operandos "Tag_HighLimit" y
"Tag_LowLimit". Con ayuda del operando "Tag_Bipolar" = TRUE se indica que el valor del
parámetro IN debe interpretarse como bipolar. En el operando "Tag_OutputValue" se indica el
resultado de la instrucción.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
GET_ERR_ID: Consultar ID de error localmente (Página 2159)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de GRAPH (Página 8191)

Control del programa
Control del tiempo de ejecución
ENDIS_PW: Limitar y habilitar legitimación de la contraseña
Descripción
La instrucción "Limitar y habilitar legitimación de la contraseña" permite definir si las
contraseñas configuradas para la CPU están legitimadas o no. Con ello, se pueden impedir
conexiones legitimadas, aun conociendo la contraseña correcta.
Si llama la instrucción y el parámetro REQ tiene el estado lógico "0", en los parámetros de
salida se muestra el estado ajustado en ese momento. Si se han realizado cambios en los
parámetros de entrada, estos no se transfieren a los parámetros de salida.
Si se ejecuta la instrucción y el parámetro REQ tiene el estado lógico "1", se aplica el estado
lógico de los parámetros de entrada (F_PWD, FULL_PWD, R_PWD, HMI_PWD):
● Si se tiene el estado lógico "0", no está permitida la legitimación por contraseña.
● Si se tiene el estado lógico "1", se puede utilizar la contraseña.
Es posible permitir o prohibir individualmente el bloqueo o la habilitación de las contraseñas.
Por ejemplo, pueden prohibirse todas las contraseñas excepto la contraseña de seguridad.
Esto permite limitar las posibilidades de acceso a un reducido grupo de usuarios. Los
parámetros de salida (F_PWD_ON, FULL_PWD_ON, R_PWD_ON, HMI_PWD_ON) siempre
muestran el estado actual del uso de contraseñas, independientemente del parámetro REQ.
Las contraseñas no configuradas deben tener en la entrada el estado lógico TRUE y devolver
el estado lógico TRUE en la salida. La contraseña de seguridad positiva (fail-safe) solo se

2150

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
puede parametrizar para una CPU F y por eso en una CPU estándar debe interconectarse
siempre con el estado lógico TRUE. Si la instrucción devuelve un error, la llamada permanece
sin efecto, es decir, el bloqueo anterior sigue en vigor.
Las contraseñas bloqueadas pueden volver a habilitarse en las condiciones siguientes:
● Se ha restablecido la configuración de fábrica de la CPU.
● El panel frontal de la CPU S7-1500 soporta un cuadro de diálogo que permite navegar al
menú adecuado y volver a habilitar las contraseñas.
● Cuando se llama la instrucción "Limitar y habilitar legitimación de la contraseña", el
parámetro de entrada de la contraseña deseada tiene el estado lógico "1".
● Ponga el selector de modo a STOP. La restricción de la legitimación de contraseña se
activa de nuevo en cuanto se mueve el selector nuevamente a RUN.
● La inserción de una tarjeta de memoria vacía (tarjeta de transferencia o tarjeta de
programa) en una CPU S7-1200.
● La transición de POWER OFF-POWER ON desactiva la protección en la CPU S7-1200. La
instrucción "Limitar y habilitar legitimación de la contraseña" debe volverse a llamar en el
programa (por ejemplo en el OB de arranque).
Nota
Si la contraseña HMI no está habilitada, la instrucción "Limitar y habilitar legitimación de la
contraseña" bloquea el acceso de los sistemas HMI.
Nota
Las conexiones ya existentes y legitimadas conservan sus derechos de acceso y no pueden
limitarse con la instrucción "Limitar y habilitar legitimación de la contraseña".

Impedir el bloqueo no intencionado en una CPU S7-1500
Los ajustes pueden realizarse en el panel frontal de la CPU, que guarda el último ajuste en
cada caso.
Para impedir un bloqueo no intencionado, en una CPU S7-1500 es posible desactivar la
protección moviendo el selector de modo a STOP. La protección se activa automáticamente
después de mover el selector de modo a RUN sin que tenga que volver a llamarse la
instrucción "Limitar y habilitar legitimación de la contraseña" o deban realizarse otras acciones
en el panel frontal.

Impedir el bloqueo no intencionado en una CPU S7-1200
Como la CPU S7-1200 no dispone de selector de modo, la protección se desactiva con
POWER OFF-POWER ON. De este modo es posible y recomendable impedir el bloqueo no
intencionado con ayuda de determinadas secuencias en el programa.
Para ello, programe un control de tiempo, ya sea mediante un OB de alarma cíclica o un
temporizador en el Main OB (OB 1). De este modo, tras una transición de POWER OFFPOWER ON y la consiguiente desactivación de la protección, se puede volver a llamar
rápidamente la instrucción "Limitar y habilitar legitimación de la contraseña" en el OB
Programación del PLC
Manual de programación y manejo, 11/2019

2151

Instrucciones
4.1 Instrucciones
correspondiente (por ejemplo OB 1 u OB 35). Para que la ventana temporal en la que la
instrucción no está activa y en la que por tanto no existen limitaciones en la legitimación de la
contraseña sea lo más pequeña posible, llame la instrucción en el OB de arranque (OB 100).
Este procedimiento ofrece la mayor protección posible contra accesos no autorizados.
Si se ha producido un bloqueo no intencionado puede omitirse la llamada en el OB de arranque
(por ejemplo mediante la consulta de un parámetro de entrada) y se dispondrá del tiempo
configurado (por ejemplo de 10 segundos a 1 minuto) para establecer una conexión con la
CPU antes de que el bloqueo vuelva a activarse.
Si no se ha previsto ningún temporizador en el código del programa y se produce un bloqueo,
inserte en la CPU una tarjeta de transferencia o una tarjeta de programa vacía. La tarjeta de
transferencia o la tarjeta de programa vacía borra la memoria de carga interna de la CPU.
Después deberá cargarse nuevamente el programa de usuario de STEP 7 en la CPU.

Procedimiento en caso de pérdida de contraseña en una CPU S7-1200
Si ha perdido la contraseña de una CPU S7-1200 protegida por contraseña, borre el programa
protegido por contraseña con una tarjeta de transferencia o una tarjeta de programa vacía. La
tarjeta de transferencia o la tarjeta de programa vacía borra la memoria de carga interna de la
CPU. A continuación, puede transferir un nuevo programa de usuario de STEP 7 Basic a la
CPU.
ADVERTENCIA
Inserción de una tarjeta de transferencia vacía
Cuando se inserta una tarjeta de transferencia en una CPU en funcionamiento, la CPU pasa
a STOP. En caso de estados operativos no seguros, los controladores pueden fallar y, con
ello, provocar un funcionamiento descontrolado de los dispositivos que se controlan. El
resultado es un funcionamiento impredecible del sistema de automatización, que puede
provocar lesiones mortales o graves, así como daños materiales.
El contenido de la tarjeta de transferencia se encuentra en la memoria de carga interna
después de su extracción. Compruebe aquí que la tarjeta no contenga ningún programa.
ADVERTENCIA
Inserción de una tarjeta de programa vacía
Cuando se inserta una tarjeta de programa en una CPU en funcionamiento, la CPU pasa a
STOP. En caso de estados operativos no seguros, los controladores pueden fallar y, con ello,
provocar un funcionamiento descontrolado de los dispositivos que se controlan. El resultado
es un funcionamiento impredecible del sistema de automatización, que puede provocar
lesiones mortales o graves, así como daños materiales.
Asegúrese de que la tarjeta de programa esté vacía. La memoria de carga interna se copiará
en la tarjeta de programa vacía. Después de retirar la tarjeta de programa previamente vacía,
la memoria de carga interna quedará vacía.
Debe retirarse la tarjeta de transferencia o la tarjeta de programa antes de poner la CPU en
RUN.

2152

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Efectos del uso de contraseñas en los modos de operación
La siguiente tabla muestra qué efectos tiene el uso de contraseñas en los modos de operación
y en las respectivas acciones del usuario mediante la instrucción "Limitar y habilitar
legitimación de la contraseña".
Acción

Protección por contraseña mediante la instruc‐
ción

Estado básico después de

No activado

● Selector de modo en STOP

(sin limitaciones)

● Restablecimiento manual de la memoria (PG,
interruptor, cambio de MC (Motion Control))
● Restablecimiento de la configuración de fábrica
Estado básico tras conexión (POWER ON)

● CPU S7-1200:
El bloqueo está desactivado y la
instrucción tiene que volverse a ejecutar
en el programa (por ejemplo en el OB de
arranque).
● CPU S7-1500:
Activada (si antes de la desconexión
(POWER OFF) había un bloqueo activo)
La posibilidad de no permitir contraseñas
es remanente.

Activado
Transición del estado operativo RUN/ARRANQUE/
PARADA -> STOP (mediante finalización de la ins‐
Las contraseñas siguen sin poder utilizarse.
trucción, un error o comunicación) o STOP -> ARRAN‐
QUE/RUN/PARADA

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o
constante

Si el parámetro REQ tiene el
estado lógico "0", se consulta
el estado lógico ajustado ac‐
tualmente para las contrase‐
ñas.

F_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura/escritura
incluido failsafe
● F_PWD = "0": No permitir
contraseña
● F_PWD = "1": Permitir
contraseña

FULL_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura/escritura
● FULL_PWD = "0": No
permitir contraseña
● FULL_PWD = "1":
Permitir contraseña

Programación del PLC
Manual de programación y manejo, 11/2019

2153

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

R_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura
● R_PWD = "0": No permitir
contraseña
● R_PWD = "1": Permitir
contraseña

HMI_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso a la HMI
● HMI_PWD = "0": No
permitir contraseña
● HMI_PWD = "1": Permitir
contraseña

F_PWD_ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura/
escritura incluido failsafe
● F_PWD_ON = "0":
Contraseña no permitida
● F_PWD_ON = "1":
Contraseña permitida

FULL_PWD_
ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura/
escritura
● FULL_PWD_ON = "0":
Contraseña no permitida
● FULL_PWD_ON = "1":
Contraseña permitida

R_PWD_ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura
● R_PWD_ON = "0":
Contraseña no permitida
● R_PWD_ON = "1":
Contraseña permitida

HMI_PWD_O Output
N

BOOL

I, Q, M, D, L

Estado del acceso a la HMI
● HMI_PWD_ON = "0":
Contraseña no permitida
● HMI_PWD_ON = "1":
Contraseña permitida

RET_VAL

Output

WORD

I, Q, M, D, L

Información de error

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)

2154

0000

Ningún error

8090

No se soporta la instrucción "Limitar y habilitar legitimación de la contraseña".

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*

Explicación

(W#16#...)
80D0

La contraseña de seguridad (fail-safe) no está configurada. En las CPU estándar, el
estado lógico tiene que ser TRUE.

80D1

El acceso de lectura/escritura no está configurado

80D2

El acceso de lectura no está configurado

80D3

El acceso HMI no está configurado

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de GRAPH (Página 8191)

RE_TRIGR: Reiniciar tiempo de vigilancia del ciclo
Descripción
La instrucción "Reiniciar tiempo de vigilancia del ciclo" reinicia el tiempo de vigilancia del ciclo
de la CPU. El tiempo de vigilancia del ciclo se reinicia entonces con la duración ajustada en la
configuración de la CPU.
La instrucción se ejecuta correctamente durante un intervalo de tiempo (10 veces el ciclo
máximo del programa), independientemente del número de llamadas. Transcurrido ese
tiempo, el ciclo del programa ya no puede prolongarse.

Llamada de la instrucción
La instrucción puede llamarse en todos los bloques de organización, independientemente de
la prioridad.

Parámetros
La instrucción "Reiniciar tiempo de vigilancia del ciclo" no tiene parámetros y no devuelve
información de error.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de GRAPH (Página 8191)

Programación del PLC
Manual de programación y manejo, 11/2019

2155

Instrucciones
4.1 Instrucciones

STP: Finalizar programa
Descripción
La instrucción "Finalizar programa" conmuta la CPU al estado operativo STOP, con lo que se
finaliza la ejecución del programa. Los efectos al conmutar de RUN a STOP dependen de la
configuración de la CPU.

Parámetros
La instrucción "Finalizar programa" no tiene parámetros y no devuelve información de error.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de GRAPH (Página 8191)

GET_ERROR: Consultar error localmente
Descripción
La instrucción "Consultar error localmente" consulta si se han producido errores en un bloque
de programa. Suele tratarse de un error de programación o de acceso. Si el sistema notifica
errores durante la ejecución del bloque de programa, en el operando de la salida OUT se
guarda información detallada acerca del primer error de ejecución ocurrido desde la última vez
que se ejecutó la instrucción.
En la salida OUT solo pueden especificarse operandos del tipo de datos de sistema
"ErrorStruct". El tipo de datos de sistema "ErrorStruct" especifica la estructura exacta con la
que debe guardarse la información acerca del error que ha ocurrido. Con ayuda de otras
instrucciones se puede evaluar esta estructura y programar la reacción correspondiente. Si se
producen varios errores en el bloque de programa, la instrucción emitirá información sobre el
siguiente error ocurrido solo tras haberse solucionado el primer error.
Nota
Salida OUT
La salida OUT solo se modifica si hay una información de error. Para volver a poner la salida
a "0" tras tratar un error existen las siguientes posibilidades:
● Declare la variable en la sección "Temp" de la interfaz de bloque.
● Ponga la variable de nuevo a "0" antes de llamar la instrucción.
Nota
Activación del tratamiento local de errores
En cuanto se inserta la instrucción en el código de un bloque de programa, se activa el
tratamiento local de errores y se ignoran las reacciones preajustadas del sistema cuando se
producen errores.

2156

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Posibilidades del tratamiento de errores
Este apartado proporciona una visión general de las posibilidades del tratamiento de
errores: Sinopsis de los mecanismos para el tratamiento de errores (Página 149)
Encontrará un ejemplo exhaustivo del tratamiento local de errores con varias posibilidades
aquí: Ejemplo de tratamiento de errores de ejecución del programa (Página 180)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OUT

Output

ErrorStruct

D, L

Información de
error

Tipo de datos "ErrorStruct"
El tipo de datos "ErrorStruct" se puede insertar en un bloque de datos global o en la interfaz del
bloque. También se puede insertar el tipo de datos varias veces siempre que se asigne cada
vez un nombre distinto para la estructura de datos. La estructura de datos y el nombre de los
distintos elementos de la estructura no se pueden modificar. Si guarda la información del error
en un bloque de datos global, se podrá leer desde otro bloque de programa.
La tabla siguiente muestra la estructura del tipo de datos "ErrorStruct":
Componente de estructura

Tipo de datos

Descripción

ERROR_ID

WORD

ID de error

FLAGS

BYTE

Muestra si el error se ha producido durante
la llamada de un bloque de programa.
16#01: error durante la llamada de un blo‐
que de programa
16#00: no hay errores durante la llamada
de un bloque de programa

REACTION

BYTE

Reacción predeterminada:
0: ignorar (error de escritura)
1: continuar con el valor sustitutivo "0"
(error de lectura)
2: omitir instrucción (error de sistema)

CODE_ADDRESS
BLOCK_TYPE

CREF

Información sobre la dirección y el tipo del
bloque de programa

BYTE

Tipo de bloque de programa en el que se
ha producido el error:
1: bloque de organización (OB)
2: función (FC)
3: bloque de función (FB)

CB_NUMBER

UINT

Número del bloque lógico

OFFSET

UDINT

Referencia a la memoria interna

BYTE

Información sobre la dirección de un ope‐
rando

MODE

Programación del PLC
Manual de programación y manejo, 11/2019

2157

Instrucciones
4.1 Instrucciones
Componente de estructura

Tipo de datos

Descripción

OPERAND_NUMBER

UINT

Número de operando del comando de la
máquina

POINTER_NUMBER_LOCA‐
TION

UINT

(A) Puntero interno

SLOT_NUMBER_SCOPE

UINT

(B) Área de almacenamiento en la memo‐
ria interna

DATA_ADDRESS

NREF

Información sobre la dirección de un ope‐
rando

BYTE

(C) Área de memoria:

AREA

L: 16#40...16#7F, 16#86, 16#87, 16#8E,
16#8F, 16#C0...16#FF
I: 16#81
Q: 16#82
M: 16#83
DB: 16#40, 16#84, 16#85, 16#8A, 16#8B
PI: 16#01
PQ: 16#02
Objetos tecnológicos: 16#04
DB_NUMBER

UINT

(D) Número del bloque de datos

OFFSET

UDINT

(E) Dirección relativa del operando

Componente de estructura "ERROR_ID"
La tabla siguiente muestra los valores que pueden devolverse en el componente de estructura
"ERROR_ID":

2158

ID*
(hexadecimal)

ID*
(decimal)

Descripción

0

0

Ningún error

2503

9475

Puntero no válido

2520

9504

STRING no válido

2522

9506

Error de lectura: operando fuera del rango válido

2523

9507

Error de escritura: operando fuera del rango válido

2524

9508

Error de lectura: operando no válido

2525

9509

Error de escritura: operando no válido

2528

9512

Error de lectura: alineación de datos

2529

9513

Error de escritura: alineación de datos

252C

9516

Puntero no válido

2530

9520

Error de escritura: bloque de datos

2533

9523

Referencia usada no válida

2534

9524

Error de número de bloque FC

2535

9525

Error de número de bloque FB

2538

9528

Error de acceso: el DB no existe

2539

9529

Error de acceso: se ha utilizado un DB incorrecto

253A

9530

El bloque de datos global no existe

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
ID*
(hexadecimal)

ID*
(decimal)

Descripción

253C

9532

Indicación errónea o la función no existe

253D

9533

La función de sistema no existe

253E

9534

Indicación errónea o el bloque de función no existe

253F

9535

El bloque de sistema no existe

2550

9552

Error de acceso: el DB no existe

2551

9553

Error de acceso: se ha utilizado un DB incorrecto

2575

9589

Error en la profundidad de anidamiento del programa

2576

9590

Error en la distribución de datos locales

2577

9591

La propiedad de bloque "Alimentación de parámetros a través de
registros" no está activada.

25A0

9632

Error interno en TP

25A1

9633

Variable protegida contra escritura

25A2

9634

Valor numérico no válido de la variable

2942

10562

Error de lectura: entrada

2943

10563

Error de escritura: salida

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Uso de las instrucciones GET_ERROR y GET_ERR_ID (Página 178)
Principios básicos de GRAPH (Página 8191)

GET_ERR_ID: Consultar ID de error localmente
Descripción
La instrucción "Consultar ID de error localmente" consulta si se han producido errores en un
bloque. Suele tratarse de un error de acceso. Si al ejecutar el bloque el sistema notifica errores
de ejecución desde que se ejecutó la instrucción por última vez, la ID de error del primer error
ocurrido se guarda en la variable de la salida RET_VAL.
En la salida RET_VAL solo pueden especificarse operandos del tipo de datos "WORD". Si se
producen varios errores en el bloque, la instrucción soluciona el primer error ocurrido, y solo
entonces la instrucción emite la ID de error del siguiente error ocurrido.
Nota
La salida RET_VAL solo se modifica si hay una información de error. Para volver a poner la
salida a "0" tras tratar un error existen las siguientes posibilidades:
● Declare la variable en la sección "Temp" de la interfaz de bloque.
● Ponga la variable de nuevo a "0" antes de llamar la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

2159

Instrucciones
4.1 Instrucciones
La salida de la instrucción "Consultar ID de error localmente" se activa únicamente si existe
una información de error. Si no se cumple esta condición, el procesamiento ulterior del
programa no se ve afectado por la instrucción "Consultar ID de error localmente".
Encontrará un ejemplo sobre cómo utilizar la instrucción en combinación con otras
posibilidades de tratamiento de errores, en "Consulte también".
Nota
La instrucción "Consultar ID de error localmente" activa el tratamiento local de errores dentro
del bloque. Si en la lógica de un bloque se ha insertado la instrucción "Consultar ID de error
localmente", se ignoran las reacciones predeterminadas del sistema al ocurrir errores.

Posibilidades del tratamiento de errores
Este apartado proporciona una visión general de las posibilidades del tratamiento de
errores: Sinopsis de los mecanismos para el tratamiento de errores (Página 149)
Encontrará un ejemplo exhaustivo del tratamiento local de errores con varias posibilidades
aquí: Ejemplo de tratamiento de errores de ejecución del programa (Página 180)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RET_VAL

Output

WORD

I, Q, M, D, L

ID de error

Parámetro RET_VAL
La tabla siguiente muestra los valores que pueden depositarse en el parámetro RET_VAL:

2160

Código de error* Código de
(hexadecimal)
error*
(decimal)

Descripción

0

0

Ningún error

2503

9475

Puntero no válido

2520

9504

STRING no válido

2522

9506

Error de lectura: operando fuera del rango válido

2523

9507

Error de escritura: operando fuera del rango válido

2524

9508

Error de lectura: operando no válido

2525

9509

Error de escritura: operando no válido

2528

9512

Error de lectura: alineación de datos

2529

9513

Error de escritura: alineación de datos

252C

9516

Puntero no válido

2530

9520

Error de escritura: bloque de datos

2533

9523

Referencia usada no válida

2534

9524

Error de número de bloque FC

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error* Código de
(hexadecimal)
error*
(decimal)

Descripción

2535

9525

Error de número de bloque FB

2538

9528

Error de acceso: el DB no existe

2539

9529

Error de acceso: se ha utilizado un DB incorrecto

253A

9530

El bloque de datos global no existe

253C

9532

Indicación errónea o la función no existe

253D

9533

La función de sistema no existe

253E

9534

Indicación errónea o el bloque de función no existe

253F

9535

El bloque de sistema no existe

2550

9552

Error de acceso: el DB no existe

2551

9553

Error de acceso: se ha utilizado un DB incorrecto

2575

9589

Error en la profundidad de anidamiento del programa

2576

9590

Error en la distribución de datos locales

2577

9591

La propiedad de bloque "Alimentación de parámetros a través de
registros" no está activada.

25A0

9632

Error interno en TP

25A1

9633

Variable protegida contra escritura

25A2

9634

Valor numérico no válido de la variable

2942

10562

Error de lectura: entrada

2943

10563

Error de escritura: salida

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Uso de las instrucciones GET_ERROR y GET_ERR_ID (Página 178)
Principios básicos de GRAPH (Página 8191)

INIT_RD: Inicializar todos los datos remanentes
Descripción
La instrucción "Inicializar todos los datos remanentes" permite inicializar todos los datos
remanentes de todos los bloques de datos, marcas y temporizadores y contadores SIMATIC
al mismo tiempo. La instrucción solo puede ejecutarse dentro de un OB de arranque, puesto
que su ejecución excedería el tiempo de ciclo de programa.

Programación del PLC
Manual de programación y manejo, 11/2019

2161

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o
constante

Si la entrada REQ
devuelve el estado
lógico "1", se ini‐
cializan todos los
datos remanentes.

RET_VAL

Output

INT

I, Q, M, D, L

Información de
error:
El parámetro
RET_VAL devuel‐
ve un código de
error cuando se
produce un error
durante la ejecu‐
ción de la instruc‐
ción.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de error* Explicación
(W#16#...)
0000

Ningún error

80B5

No puede ejecutarse la instrucción porque no ha sido programada dentro de un OB de arranque.

Información de
error general

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL INIT_RD
(REQ := "Tag_REQ"
RET_VAL => "Tag_RET_VAL"
)

Si el operando "Tag_REQ" devuelve el estado lógico "1", se ejecuta la instrucción. Se
inicializan todos los datos remanentes de todos los bloques de datos, marcas y
temporizadores y contadores SIMATIC.

2162

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
GET_ERR_ID: Consultar ID de error localmente (Página 2159)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de GRAPH (Página 8191)

WAIT: Programar retardo
Descripción
La instrucción "Programar retardo" detiene la ejecución del programa durante un periodo
parametrizado. El periodo se indica en microsegundos en el parámetro WT.
Es posible parametrizar tiempos de retardo de -32768 a 32767 microsegundos (μs). El tiempo
de retardo mínimo depende de la CPU utilizada y equivale al tiempo de ejecución de la
instrucción.
La ejecución de la instrucción puede verse interrumpida por eventos de prioridad superior y no
arrojará información de error.
Nota
Tiempo de retardo negativo
Si indica un tiempo de retardo negativo en el parámetro WT, la salida de habilitación ENO, o
el RLO y el bit BR arrojan el estado lógico FALSE. Un tiempo de retardo negativo no afecta a
la CPU. En KOP y FUP no se ejecutan las siguientes instrucciones vinculadas a la salida de
habilitación ENO.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

WT

Input

INT

I, Q, M, D, L, P o
constante

Tiempo de retardo en micro‐
segundos (μs)

Ejemplo de cómo influir en el tiempo de retardo previsto
En el ejemplo siguiente se ve la influencia del tiempo de retardo de la instrucción "WAIT" en
diferentes escenarios.
La figura siguiente ilustra los escenarios esquemáticamente:

Programación del PLC
Manual de programación y manejo, 11/2019

2163

Instrucciones
4.1 Instrucciones
6HQG&ORFN

&DVR 
2%

PV

:$,7  PV
7'HOD\ PV

7&RGH PV

7'HOD\ PV

7&RGH PV

7'HOD\ PV

7&RGH PV

75H PV

&DVR
2%GHDODUPD

75H PV

&DVR
2%GHDODUPD

7&RGH PV

&DVR
2%GHDODUPD
72Y PV
6HQG&ORFN 7LHPSRGHFLFORGHHPLVLµQGHOD&38
7'HOD\ 7LHPSRGHUHWDUGRGHO2%GHDODUPD
7&RGH 7LHPSRGHHMHFXFLµQGHOSURJUDPD
75H 7LHPSRUHVWDQWH
72Y 7LHPSRHQHOTXHVHSURORQJDHOWLHPSRGHFLFORGHHPLVLµQ
(O2%FRQODLQVWUXFFLµQ:$,7WDPEL«QIRUPDSDUWHGHORVFDVRV\\GHEH
WHQHUVHHQFXHQWD

Tiempo restante = intervalo entre el final del tiempo de retardo previsto (mediante "WAIT") y la
finalización del OB de alarma
Tiempo de prolongación = intervalo entre la finalización del OB de alarma y el final del tiempo
de retardo previsto (mediante "WAIT")
Caso 1:
La instrucción "WAIT" se llama en un OB1. La instrucción "WAIT" puede verse interrumpida por
OB o procesos de mayor prioridad (p. ej. System Threads). Sin embargo, el tiempo de retardo
de la instrucción "WAIT" no se ha modificado ni se ha aplazado.
Casos 2 y 3:
El procesamiento del programa en el OB1 prosigue tras un retardo de 20 ms. Este retardo se
calcula con la llamada de la instrucción "WAIT" en el OB1 (consulte OB1 con WAIT). En esos
20 ms, un OB de alarma puede ejecutar su propio código de programa. El tiempo de ciclo de
emisión de la CPU no cambia.

2164

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Caso 4:
El procesamiento del programa en el OB1 prosigue tras finalizar el proceso de mayor prioridad.
Los 20 ms de retardo en el OB1 han transcurrido, pero el proceso de mayor prioridad todavía
no ha finalizado. El tiempo de ciclo de emisión de la CPU aumenta.
Nota
Secuencia de ejecución de procesos del sistema o de comunicación (System Threads)
Los threads del sistema suelen utilizar la prioridad "15". También hay threads del sistema con
una prioridad mayor que "26", pero estos procesos suponen una carga menor para la CPU. Los
threads del sistema no se muestran en la figura.
Medición del tiempo de ejecución del OB1 utilizando la instrucción "RT_INFO":
Caso 2: 20 ms - 8 ms - System Threads = <12 ms. Tiempo de ciclo de emisión: ~20 ms.
Caso 3: 20 ms - 11 ms - System Threads - <9 ms. Tiempo de ciclo de emisión: ~20 ms.
Caso 4: 20 ms - 15 ms - System Threads - <7 ms. Tiempo de ciclo de emisión: ~22 ms.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de GRAPH (Página 8191)

Operaciones lógicas con palabras
NOT (INV): Invertir
Descripción
La instrucción "Invertir" permite invertir el estado lógico de los bits del operando. Al ejecutar la
instrucción, el valor del operando se combina con una operación lógica O-exclusiva utilizando
una plantilla hexadecimal (W#16#FFFF para números de 16 bits o DW#16#FFFF FFFF para
números de 32 bits). Esto invierte el estado lógico de los distintos bits y lo devuelve como
resultado.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Secuencias de
bits, enteros

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

Secuencias de
bits, enteros

I, Q, M, D, L, P

Complemento a 1
del valor del ope‐
rando

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

2165

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"TagOut_Value" := NOT("TagIn_Value")

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

TagIn_Value

W#16#000F

TagOut_Value

W#16#FFF0

La instrucción invierte el estado lógico de los distintos bits del operando "TagIn_Value" y
escribe el resultado en el operando "TagOut_Value".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

DECO: Descodificar
Descripción
La instrucción "Descodificar" activa un bit predeterminado por el valor de entrada en el valor de
salida.
La instrucción "Descodificar" lee el valor del parámetro IN y activa el bit del parámetro OUT
cuya posición de bit equivale al valor leído. Los demás bits del valor de salida se rellenan con
ceros. Si el valor del parámetro IN es mayor que 31, se ejecuta una instrucción modulo 32.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

UINT

I, Q, M, D, L, P o
constante

Posición del bit que se activa
en el valor de salida.

OUT

Output

Secuencias de bits I, Q, M, D, L, P

Valor de salida

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

2166

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL DECO UINT_DWORD
(IN := "Tag_Input"
OUT => "Tag_Output"
)

La figura siguiente muestra el funcionamiento de la instrucción con valores concretos:
7DJB,QSXW




7DJB2XWSXW

 



 

La instrucción lee el número de bit "3" del valor del operando "Tag_Input" de la entrada y activa
el tercer bit del valor del operando "Tag_Output" de la salida.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

ENCO: Codificar
Descripción
La instrucción "Codificar" lee el número del bit menos significativo que está activado en el valor
de entrada y devolverlo en el parámetro OUT.
La instrucción "Codificar" selecciona el bit menos significativo del valor del parámetro IN y
escribe su número de bit en el operando del parámetro OUT. Si el parámetro IN devuelve el
valor DW#16#00000001 o DW#16#00000000, en el parámetro OUT se deposita el valor "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

IN

Input

Secuencias de bits I, Q, M, D, L, P o
constante

Área de memoria

Valor de entrada

OUT

Output

INT

Valor de salida

I, Q, M, D, L, P

Descripción

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

2167

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

CALL ENCO DWORD
(IN := "Tag_Input"
OUT => "Tag_Output"
)

La figura siguiente muestra el funcionamiento de la instrucción con valores concretos:


 



ಯ7DJB,QSXWಯ  
ಯ7DJB2XWSXWಯ 

La instrucción selecciona el bit menos significativo que está activado en la variable "Tag_Input"
y escribe su bit "3" en la variable "Tag_Output".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

SEL: Seleccionar
Descripción
La instrucción "Seleccionar" permite elegir, en función de un interruptor (entrada G), una de las
entradas IN0 o IN1 y copiar su contenido en la salida OUT. Si la entrada G tiene el estado lógico
"0", se copia el valor de la entrada IN0. Si la entrada G tiene el estado lógico "1", se copia el
valor de la entrada IN1 en la salida OUT.
Para poder procesar la instrucción, las variables de todos los parámetros deben ser del mismo
tipo de datos.

2168

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

G

Input

BOOL

I, Q, M, D, L o
constante

Interruptor

IN0

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Primer valor de entrada

IN1

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Segundo valor de entrada

OUT

Output

I, Q, M, D, L, P
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Resultado

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL SEL CHAR
(G := "Tag_Input_G"
IN0 := "Tag_Input0"
IN1 := "Tag_Input1"
OUT => "Tag_Output"
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores concretos:
Parámetro

Operando

Valor

G

Tag_Input_G

1

IN0

Tag_Input0

W#16#0000

IN1

Tag_Input1

W#16#FFFF

OUT

Tag_Output

W#16#FFFF

Programación del PLC
Manual de programación y manejo, 11/2019

2169

Instrucciones
4.1 Instrucciones
Dependiendo del estado lógico de la entrada "Tag_Input_G", se selecciona el valor de la
entrada "Tag_Input0" o "Tag_Input1" y se copia en la salida "Tag_Output".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

MUX: Multiplexar
Descripción
La instrucción "Multiplexar" permite copiar el contenido de una entrada seleccionada en la
salida RET_VAL. El número de entradas seleccionables se puede ampliar hasta un máximo de
32. La numeración comienza por IN0 y continúa en orden ascendente con cada nueva entrada.
El parámetro K determina la entrada cuyo contenido se copia en la salida RET_VAL. Si el valor
del parámetro K es mayor que el número de entradas disponibles, el contenido del parámetro
INELSE se copia en la salida RET_VAL.
La instrucción "Multiplexar" solo se puede ejecutar si las variables de todas las entradas y de
la salida RET_VAL tienen el mismo tipo de datos. El parámetro K es una excepción, ya que
para éste sólo pueden indicarse números enteros.
El valor del parámetro RET_VAL no es válido si se cumple una de las siguientes condiciones:
● La entrada del parámetro K está fuera de las entradas disponibles. Esta reacción no
depende de que la entrada INELSE se utilice o no. El valor de la salida RET_VAL
permanece inalterado y la salida de habilitación ENO se pone a "0".
● Se producen errores al ejecutar la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:

2170

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

K

Input

Enteros

I, Q, M, D, L o
constante

Indica la entrada cuyo conte‐
nido se copia.

IN0

Input

Números binarios, I, Q, M, D, L o
enteros, números constante
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Primer valor de entrada

IN1

Input

Números binarios, I, Q, M, D, L o
enteros, números constante
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Segundo valor de entrada

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

INn

Input

Números binarios, I, Q, M, D, L o
enteros, números constante
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Área de memoria

Descripción
Valores de entrada opciona‐
les

INELSE

Input

Números binarios, I, Q, M, D, L o
enteros, números constante
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Indica el valor que se copia si
K > n.

RET_VAL

Output

Números binarios, I, Q, M, D, L
enteros, números
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Salida en la que se copia el
valor.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL MUX SINT_SINT
(K := "Tag_Number"
IN0 := "Tag_Value_1"
IN1 := "Tag_Value_2"
INELSE := "Tag_Value_3"
RET_VAL => "Tag_Result"
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

K

Tag_Number

1

Valor

IN0

Tag_Value_1

DW#16#00000000

IN1

Tag_Value_2

DW#16#3E4A7D

INELSE

Tag_Value_3

DW#16#FFFF0000

RET_VAL

Tag_Result

DW#16#3E4A7D

De acuerdo con el valor del operando "Tag_Number", se copia el valor de la entrada
"Tag_Value_1" y se indica en el operando de la salida "Tag_Result".

Programación del PLC
Manual de programación y manejo, 11/2019

2171

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de GRAPH (Página 8191)

DEMUX: Desmultiplexar
Descripción
La instrucción "Desmultiplexar" permite copiar el contenido de la entrada IN en una salida
seleccionada. El número de salidas seleccionables se puede ampliar hasta un máximo de 32.
La numeración comienza por OUT0 y continúa en orden ascendente con cada nueva salida.
El parámetro K permite determinar la salida en la que se copia el contenido de la entrada IN.
Las demás salidas no cambian. Si el valor del parámetro K es mayor que el número de salidas
disponibles, el contenido de la entrada IN se copia en el parámetro OUTELSE.
La instrucción "Desmultiplexar" solo se puede ejecutar si las variables de la entrada IN y las de
todas las salidas tienen el mismo tipo de datos. El parámetro K es una excepción, ya que en
el mismo sólo pueden indicarse números enteros.
El valor de la salida OUTELSE no es válido si se cumple una de las siguientes condiciones:
● El valor del parámetro K es mayor que el número de salidas disponibles.
● Se producen errores al ejecutar la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:

2172

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

K

Input

Enteros

I, Q, M, D, L o
constante

Indica la salida en la que se
copia el valor de entrada (IN).

IN

Input

Números binarios, I, Q, M, D, L o
enteros, números constante
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Valor de entrada

OUT0

Output

Números binarios, I, Q, M, D, L
enteros, números
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Primera salida

OUT1

Output

Números binarios, I, Q, M, D, L
enteros, números
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Segunda salida

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

OUTn

Output

Números binarios, I, Q, M, D, L
enteros, números
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Área de memoria

Descripción
Salidas opcionales

OUTELSE

Output

Números binarios, I, Q, M, D, L
enteros, números
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Salida en la que se copia el
valor de entrada (IN) con K >
n.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos disponibles en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL DEMUX SINT_SINT
(K := "Tag_Number"
IN := "Tag_Value"
OUT0 => "Tag_Output_1"
OUT1 => "Tag_Output_2"
OUTELSE => "Tag_Output_3"
)

Las tablas siguientes muestran el funcionamiento de la instrucción con valores de operandos
concretos:
Tabla 4-5

Valores de entrada de la instrucción "Desmultiplexar" antes de ejecutar el segmento:

Parámetro

Operando

K

Tag_Number

1

4

IN

Tag_Value

DW#16#FFFFFFFF

DW#16#3E4A7D

Tabla 4-6

Valores

Valores de salida de la instrucción "Desmultiplexar" tras ejecutar el segmento:

Parámetro

Operando

Valores

OUT0

Tag_Output_1

Sin cambios

Sin cambios

OUT1

Tag_Output_2

DW#16#FFFFFFFF

Sin cambios

OUTELSE

Tag_Output_3

Sin cambios

DW#16#3E4A7D

Según el valor del operando "Tag_Number", se copia el valor de la entrada IN en la salida
correspondiente.

Programación del PLC
Manual de programación y manejo, 11/2019

2173

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

Desplazamiento y rotación
SHR: Desplazar a la derecha
Descripción
Con la instrucción "Desplazar a la derecha", el contenido del operando 1 se mueve bit a bit
hacia la derecha. El operando 2 determina el número de posiciones de bit que debe
desplazarse el valor indicado.
Cuando el valor del operando 2 es "0", se copia en valor del operando 1 en el resultado.
Si el valor del operando 2 es mayor que el número de posiciones de bit disponibles, el valor del
operando 1 se desplaza hacia la derecha las posiciones de bit disponibles.
En los valores sin signo, se rellenan con ceros las posiciones de bits que quedan libres en el
área izquierda del operando 1 al realizar el desplazamiento. Si el valor indicado lleva signo, las
posiciones libres se ocupan con el estado lógico del bit de signo.
La figura siguiente muestra cómo el contenido del operando 1 del tipo de datos INT se
desplaza cuatro posiciones de bit hacia la derecha:


2SHUDQGR















2SHUDQGR %LW
GHVLJQR

5HVXOWDGR






































G¯JLWRV











/DVSRVLFLRQHVGHELWOLEHUDGDV
VHUHOOHQDQFRQHOHVWDGROµJLFR
GHOELWGHVLJQR

2174

















(VWRVFXDWUR
ELWVVHSLHUGHQ

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operan‐
do1>

Input

Secuencias de
bits, enteros

I, Q, M, D, L o
constante

Valor que se desplaza

<Operan‐
do2>

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L o
constante

Número de posiciones de bit
que se desplaza el valor

<Resultado>

Output

Secuencias de
bits, enteros

I, Q, M, D, L

Resultado de la instrucción

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := SHR_INT("Tag_InValue","Tag_Number")

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

0011 1111 1010 1111

Tag_Number

3

Tag_OutValue

0000 0111 1111 0101

El contenido del operando "Tag_InValue" se desplaza tres posiciones de bit hacia la derecha.
El resultado se deposita en la salida "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

SHL: Desplazar a la izquierda
Descripción
Con la instrucción "Desplazar a la izquierda", el contenido del operando 1 se mueve bit a bit
hacia la izquierda. El operando 2 determina el número de posiciones de bit que debe
desplazarse el valor indicado.
Cuando el valor del operando 2 es "0", se copia en valor del operando 1 en el resultado.

Programación del PLC
Manual de programación y manejo, 11/2019

2175

Instrucciones
4.1 Instrucciones
Si el valor del operando 2 es mayor que el número de posiciones de bit disponibles, el valor del
operando 1 se desplaza hacia la izquierda las posiciones de bit disponibles.
Las posiciones de bit que quedan libres en el área derecha del operando 1 al realizar el
desplazamiento se rellenan con ceros.
La figura siguiente muestra cómo el contenido del operando 1 del tipo de datos WORD se
desplaza seis posiciones de bit hacia la izquierda:


2SHUDQG







2SHUDQGR

5HVXOWDGR
































G¯JLWRV

     

































/DVSRVLFLRQHV
GHELWOLEHUDGDVVH
UHOOHQDQFRQFHURV

(VWRVVHLV
ELWVVHSLHUGHQ

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operan‐
do1>

Input

Secuencias de
bits, enteros

I, Q, M, D, L o
constante

Valor que se desplaza

<Operan‐
do2>

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L o
constante

Número de posiciones de bit
que se desplaza el valor

<Resultado>

Output

Secuencias de
bits, enteros

I, Q, M, D, L

Resultado de la instrucción

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := SHL_WORD("Tag_InValue","Tag_Number")

2176

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

0011 1111 1010 1111

Tag_Number

4

Tag_OutValue

1111 1010 1111 0000

El contenido del operando "Tag_InValue" se desplaza cuatro posiciones de bit hacia la
izquierda y se indica como resultado en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

ROR: Rotar a la derecha
Descripción
Con la instrucción "Rotar a la derecha", el contenido del operando 1 se rota bit a bit hacia la
derecha. El operando 2 determina el número de posiciones de bit que debe rotarse el valor
indicado.
Cuando el valor del operando 2 es "0", se copia en valor del operando 1 en el resultado.
Si el valor del operando 2 es mayor que el número de posiciones de bit disponibles, el valor del
operando 1 se rota el número indicado de posiciones de bit.
Los bits que quedan libres al realizar la rotación se rellenan con los bits desplazados hacia
fuera.
La figura siguiente muestra cómo el contenido de un operando del tipo de datos DWORD rota
tres posiciones hacia la derecha:

Programación del PLC
Manual de programación y manejo, 11/2019

2177

Instrucciones
4.1 Instrucciones


2SHUDQGR

 



       

2SHUDQGR

G¯JLWRV

5HVXOWDGR

       



(OHVWDGROµJLFRGHORVWUHV
ELWVGHVSOD]DGRVVHLQWURGXFHHQODV
SRVLFLRQHVTXHKDQTXHGDGROLEUHV

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operan‐
do1>

Input

Secuencias de
bits, enteros

I, Q, M, D, L o
constante

Valor que se rota

<Operan‐
do2>

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L o
constante

Número de posiciones de bit
que rota el valor

<Resultado>

Output

Secuencias de
bits, enteros

I, Q, M, D, L

Resultado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := ROR("Tag_InValue","Tag_Number")

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1010 1010 0000 1111 0000 1111 0101 0101

Tag_Number

5

Tag_OutValue

1010 1101 0101 0000 0111 1000 0111 1010

El contenido del operando "Tag_InValue" se rota cinco posiciones de bit hacia la derecha y se
indica como resultado en el operando "Tag_OutValue".

2178

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

ROL: Rotar a la izquierda
Descripción
Con la instrucción "Rotar a la izquierda", el contenido del operando 1 se rota bit a bit hacia la
izquierda. El operando 2 determina el número de posiciones de bit que debe rotarse el valor
indicado.
Cuando el valor del operando 2 es "0", se copia en valor del operando 1 en el resultado.
Si el valor del operando 2 es mayor que el número de posiciones de bit disponibles, el valor del
operando 1 se rota el número indicado de posiciones de bit.
Los bits que quedan libres al realizar la rotación se rellenan con los bits desplazados hacia
fuera.
La figura siguiente muestra cómo el contenido de un operando del tipo de datos DWORD rota
tres posiciones hacia la izquierda:


2SHUDQGR



       

2SHUDQGR

5HVXOWDGR

 

G¯JLWRV



       
(OHVWDGROµJLFRGHORVWUHV
ELWVGHVSOD]DGRVVHLQWURGXFHHQODV
SRVLFLRQHVTXHKDQTXHGDGROLEUHV

Programación del PLC
Manual de programación y manejo, 11/2019

2179

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operan‐
do1>

Input

Secuencias de
bits, enteros

I, Q, M, D, L o
constante

Valor que se rota

<Operan‐
do2>

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L o
constante

Número de posiciones de bit
que rota el valor

<Resultado>

Output

Secuencias de
bits, enteros

I, Q, M, D, L

Resultado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
"Tag_OutValue" := ROL("Tag_InValue","Tag_Number")

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1111 0000 1010 1010 0000 1111 0000 1111

Tag_Number

5

Tag_OutValue

0001 0101 0100 0001 1110 0001 1111 1110

El contenido del operando "Tag_InValue" se rota cinco posiciones de bit hacia la izquierda y se
indica como resultado en el operando "Tag_OutValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

2180

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Legacy
DRUM: Materializar circuito secuencial sucesivo
Descripción
La instrucción "Materializar circuito secuencial sucesivo" ocupa los bits de salida programados
(OUT1 a OUT16) y la palabra de salida (OUT_WORD) con los valores programados del
parámetro OUT_VAL del paso respectivo. El paso en cuestión debe cumplir las condiciones de
la máscara de habilitación programada en el parámetro S_MASK mientras la instrucción
permanece en dicho paso. La instrucción pasa al paso siguiente cuando el evento de éste es
verdadero y una vez transcurrido el tiempo programado para el paso actual, o bien cuando el
valor del parámetro JOG cambia de "0" a "1". La instrucción se desactiva cuando el estado
lógico del parámetro RESET cambia a "1". Con ello, el paso actual se iguala al paso
predeterminado (DSP).
El tiempo de permanencia en un paso se calcula multiplicando la base de tiempo
predeterminada (DTBP) por el valor de contaje predeterminado (S_PRESET) para cada paso.
Al comienzo de un nuevo paso, este valor calculado se carga en el parámetro DCC, que
contiene el tiempo restante para el paso actual. Por ejemplo, si el valor del parámetro DTBP es
"2" y el valor predeterminado para el primer paso es "100" (100 ms), el parámetro DCC
devolverá el valor "200" (200 ms).
Un paso puede programarse con un valor de tiempo, con un evento o con ambos. Los pasos
programados con un bit de evento y el valor de tiempo "0" pasan al siguiente paso en cuanto
el estado lógico del bit de evento es "1". Los pasos programados solo con un valor de tiempo
empiezan a contar el tiempo inmediatamente. Los pasos programados con un bit de evento y
un valor de tiempo mayor que "0" empiezan a contar el tiempo en cuanto el estado lógico del
bit de evento es "1". Los bits de evento se inicializan con el estado lógico "1".
Si el circuito secuencial sucesivo se encuentra en el último paso programado (LST_STEP) y ha
transcurrido el tiempo para dicho paso, el estado lógico del parámetro Q se pone a "1". De lo
contrario, se pone a "0". Si está activado el parámetro Q, la instrucción permanece en el paso
hasta la desactivación.
En la máscara configurable (S_MASK) es posible seleccionar los distintos bits de la palabra de
salida (OUT_WORD) y activar o desactivar los bits de salida (OUT1 a OUT16) mediante los
valores de salida (OUT_VAL). Si un bit de la máscara configurable tiene el estado lógico "1",
el valor OUT_VAL activa o desactiva el bit correspondiente. Si el estado lógico de un bit de la
máscara configurable es "0", no cambia el bit respectivo. Todos los bits de la máscara
configurable de todos los 16 pasos se inicializan con el estado lógico "1".
El bit de salida del parámetro OUT1 equivale al bit menos significativo de la palabra de salida
(OUT_WORD). El bit de salida del parámetro OUT16 equivale al bit más significativo de la
palabra de salida (OUT_WORD).

Programación del PLC
Manual de programación y manejo, 11/2019

2181

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RESET

Input

BOOL

I, Q, M, D, L o
constante

El estado lógico "1" indica
una condición de desactiva‐
ción.

JOG

Input

BOOL

I, Q, M, D, L o
constante

Si el estado lógico cambia de
"0" a "1", la instrucción pasa
al siguiente paso.

DRUM_EN

Input

BOOL

I, Q, M, D, L o
constante

El estado lógico "1" permite
que el circuito secuencial su‐
cesivo siga contando según
el evento y los criterios de
tiempo.

LST_STEP

Input

BYTE

I, Q, M, D, L o
constante

Número máximo de etapas
(p. ej.: LST_STEP = 16#08;
son posibles 8 etapas como
máximo.)

EVENT(i)

Input

BOOL

I, Q, M, D, L o
constante

Bit de evento (i);

Output

BOOL

I, Q, M, D, L

Bit de salida (j)

Q

Output

BOOL

I, Q, M, D, L

El estado lógico "1" indica
que ha transcurrido el tiempo
del último paso.

OUT_WORD

Output

WORD

I, Q, M, D, L, P

Dirección de palabra en la
que el circuito secuencial su‐
cesivo escribe los valores de
salida.

ERR_CODE

Output

WORD

I, Q, M, D, L, P

Información de error

JOG_HIS

Static

BOOL

I, Q, M, D, L o
constante

Bit de evolución del paráme‐
tro JOG

EOD

Static

BOOL

I, Q, M, D, L o
constante

El estado lógico "1" indica
que ha transcurrido el tiempo
del último paso.

DSP

Static

BYTE

I, Q, M, D, L, P o
constante

Primer paso predeterminado
del circuito secuencial suce‐
sivo (1 a 16)

DSC

Static

BYTE

I, Q, M, D, L, P o
constante

Paso actual del circuito se‐
cuencial sucesivo

DCC

Static

DWORD

I, Q, M, D, L, P o
constante

Tiempo de ejecución restan‐
te para el paso actual

DTBP

Static

WORD

I, Q, M, D, L, P o
constante

Base de tiempo predetermi‐
nada del circuito secuencial
sucesivo

PrevTime

Static

TIME

I, Q, M, D, L o
constante

hora de sistema de la llama‐
da anterior

1 ≤ i ≤ 16
OUT(j),

El estado lógico inicial es "1".

1 ≤ j ≤ 16

2182

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

S_PRESET

Static

ARRAY[1..16] of
WORD

I, Q, M, D, L o
constante

Valor de contaje predetermi‐
nado para cada paso [1 a 16];
1 ciclo de reloj = 1 ms.

OUT_VAL

Static

ARRAY[1..16,
0..15] of BOOL

I, Q, M, D, L o
constante

Valores de salida para cada
etapa [1 a 16, 0 a 15].

S_MASK

Static

ARRAY[1..16,
0..15] of BOOL

I, Q, M, D, L o
constante

Máscara configurable para
cada etapa [1 a 16, 0 a 15].
Los estados lógicos iniciales
son "1".

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
ERR_CO‐
DE*

Explicación

W#16#000
0

Ningún error

W#16#000
B

El valor del parámetro LST_STEP es menor que 1 o mayor que 16.

W#16#000
C

El valor del parámetro DSC es menor que 1 o mayor que el valor del parámetro
LST_STEP.

W#16#000
D

El valor del parámetro DSP es menor que 1 o mayor que el valor de LST_STEP.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
En el ejemplo siguiente, la instrucción pasa del paso 1 al paso 2. Los bits de salida (OUT1 a
OUT16) y la palabra de salida (OUT_WORD) se activan según la máscara configurada para el
paso 2 y los valores del parámetro OUT_VAL.
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

GRAPH
CALL DRUM, "DRUM_DB"
(RESET := "Tag_Reset"
JOG := "Tag_Input_Jog"
DRUM_EN := "Tag_Input_Drum_EN"
LST_STEP := "Tag_Number_LastStep"
EVENTn := "MyTag_Event_n"
OUTn => "MyTag_Output_n"

Programación del PLC
Manual de programación y manejo, 11/2019

2183

Instrucciones
4.1 Instrucciones
GRAPH
Q => "Tag_Output_Q"
OUT_WORD => "Tag_OutputWord"
ERR_CODE => "Tag_ErrorCode"
)

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para asignar valores a los parámetros de
entrada:
Parámetro

Operando

Dirección

Valor

RESET

Tag_Reset

M0.0

FALSE

JOG

Tag_Input_JOG

M0.1

FALSE

DRUM_EN

Tag_Input_Drum_EN

M0.2

TRUE

LST_STEP

Tag_Number_LastStep

MB1

B#16#08

EVENT2

MyTag_Event_2

M20.0

FALSE

EVENT4

MyTag_Event_4

M20.1

FALSE

EVENT6

MyTag_Event_6

M20.2

FALSE

EVENT8

MyTag_Event_8

M20.3

FALSE

EVENT10

MyTag_Event_10

M20.4

FALSE

EVENT12

MyTag_Event_12

M20.5

FALSE

EVENT14

MyTag_Event_14

M20.6

FALSE

EVENT16

MyTag_Event_16

M20.7

FALSE

En el bloque de datos de instancia "DRUM_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

2184

Dirección

Valor

JOG_HIS

DBX12.0

FALSE

EOD

DBX12.1

FALSE

DSP

DBB13

W#16#0001

DSC

DBB14

W#16#0001

DCC

DBD16

DW#16#0000000A

DTBP

DBW20

W#16#0001

S_PRESET[1]

DBW26

W#16#0064

S_PRESET[2]

DBW28

W#16#00C8

OUT_VAL[1,0]

DBX58.0

TRUE

OUT_VAL[1,1]

DBX58.1

TRUE

OUT_VAL[1,2]

DBX58.2

TRUE

OUT_VAL[1,3]

DBX58.3

TRUE

OUT_VAL[1,4]

DBX58.4

TRUE

OUT_VAL[1,5]

DBX58.5

TRUE

OUT_VAL[1,6]

DBX58.6

TRUE

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Dirección

Valor

OUT_VAL[1,7]

DBX58.7

TRUE

OUT_VAL[1,8]

DBX59.0

TRUE

OUT_VAL[1,9]

DBX59.1

TRUE

OUT_VAL[1,10]

DBX59.2

TRUE

OUT_VAL[1,11]

DBX59.3

TRUE

OUT_VAL[1,12]

DBX59.4

TRUE

OUT_VAL[1,13]

DBX59.5

TRUE

OUT_VAL[1,14]

DBX59.6

TRUE

OUT_VAL[1,15]

DBX59.7

TRUE

OUT_VAL[2,0]

DBX60.0

FALSE

OUT_VAL[2,1]

DBX60.1

FALSE

OUT_VAL[2,2]

DBX60.2

FALSE

OUT_VAL[2,3]

DBX60.3

FALSE

OUT_VAL[2,4]

DBX60.4

FALSE

OUT_VAL[2,5]

DBX60.5

FALSE

OUT_VAL[2,6]

DBX60.6

FALSE

OUT_VAL[2,7]

DBX60.7

FALSE

OUT_VAL[2,8]

DBX61.0

FALSE

OUT_VAL[2,9]

DBX61.1

FALSE

OUT_VAL[2,10]

DBX61.2

FALSE

OUT_VAL[2,11]

DBX61.3

FALSE

OUT_VAL[2,12]

DBX61.4

FALSE

OUT_VAL[2,13]

DBX61.5

FALSE

OUT_VAL[2,14]

DBX61.6

FALSE

OUT_VAL[2,15]

DBX61.7

FALSE

S_MASK[2,0]

DBX92.0

FALSE

S_MASK[2,1]

DBX92.1

TRUE

S_MASK[2,2]

DBX92.2

TRUE

S_MASK[2,3]

DBX92.3

TRUE

S_MASK[2,4]

DBX92.4

TRUE

S_MASK[2,5]

DBX92.5

FALSE

S_MASK[2,6]

DBX92.6

TRUE

S_MASK[2,7]

DBX92.7

TRUE

S_MASK[2,8]

DBX93.0

FALSE

S_MASK[2,9]

DBX93.1

FALSE

S_MASK[2,10]

DBX93.2

TRUE

S_MASK[2,11]

DBX93.3

TRUE

S_MASK[2,12]

DBX93.4

TRUE

S_MASK[2,13]

DBX93.5

TRUE

S_MASK[2,14]

DBX93.6

FALSE

S_MASK[2,15]

DBX93.7

TRUE

Programación del PLC
Manual de programación y manejo, 11/2019

2185

Instrucciones
4.1 Instrucciones
Los parámetros de salida tienen los valores siguientes antes de ejecutarse la instrucción:
Parámetro

Operando

Dirección

Valor

Q

Tag_Output_Q

M6.0

FALSE

OUTWORD

Tag_OutputWord

MW8

W#16#FFFF

OUT1

MyTag_Output_1

M4.0

TRUE

OUT2

MyTag_Output_2

M4.1

TRUE

OUT3

MyTag_Output_3

M4.2

TRUE

OUT4

MyTag_Output_4

M4.3

TRUE

OUT5

MyTag_Output_5

M4.4

TRUE

OUT6

MyTag_Output_6

M4.5

TRUE

OUT7

MyTag_Output_7

M4.6

TRUE

OUT8

MyTag_Output_8

M4.7

TRUE

OUT9

MyTag_Output_9

M5.0

TRUE

OUT10

MyTag_Output_10

M5.1

TRUE

OUT11

MyTag_Output_11

M5.2

TRUE

OUT12

MyTag_Output_12

M5.3

TRUE

OUT13

MyTag_Output_13

M5.4

TRUE

OUT14

MyTag_Output_14

M5.5

TRUE

OUT15

MyTag_Output_15

M5.6

TRUE

OUT16

MyTag_Output_16

M5.7

TRUE

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:

2186

Parámetro

Operando

Dirección

Valor

OUT1

MyTag_Output_1

M4.0

TRUE

OUT2

MyTag_Output_2

M4.1

FALSE

OUT3

MyTag_Output_3

M4.2

FALSE

OUT4

MyTag_Output_4

M4.3

FALSE

OUT5

MyTag_Output_5

M4.4

FALSE

OUT6

MyTag_Output_6

M4.5

TRUE

OUT7

MyTag_Output_7

M4.6

FALSE

OUT8

MyTag_Output_8

M4.7

FALSE

OUT9

MyTag_Output_9

M5.0

TRUE

OUT10

MyTag_Output_10

M5.1

TRUE

OUT11

MyTag_Output_11

M5.2

FALSE

OUT12

MyTag_Output_12

M5.3

FALSE

OUT13

MyTag_Output_13

M5.4

FALSE

OUT14

MyTag_Output_14

M5.5

FALSE

OUT15

MyTag_Output_15

M5.6

TRUE

OUT16

MyTag_Output_16

M5.7

FALSE

Q

Tag_Output_Q

M6.0

FALSE

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Operando

Dirección

Valor

OUTWORD

Tag_OutputWord

MW8

W#16#4321

ERR_CODE

Tag_ErrorCode

MW10

W#16#0000

En el bloque de datos de instancia "DRUM_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

JOG_HIS

DBX12.0

FALSE

EOD

DBX12.1

FALSE

DSC

DBB14

W#16#0002

DCC

DBD16

DW#16#000000C8

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

DCAT: Alarma de tiempo para control discreto
Descripción
La instrucción "Alarma de tiempo para control discreto" acumula el tiempo desde el instante en
el que el parámetro CMD da la orden de abrir o cerrar. El tiempo se acumula hasta excederse
el tiempo predeterminado (PT) o hasta recibir la notificación de que el dispositivo se ha cerrado
o abierto dentro del tiempo prescrito (O_FB o C_FB). Si se excede el tiempo predeterminado
antes de recibirse la notificación de que se ha abierto o cerrado el dispositivo, se activa la
alarma correspondiente. Si el estado lógico de la entrada de la orden cambia antes del tiempo
predeterminado, se reinicia el tiempo.
La instrucción "Alarma de tiempo para control discreto" tiene las reacciones siguientes en las
condiciones de entrada:
● Si el estado lógico del parámetro CMD cambia de "0" a "1", esto tiene los efectos siguientes
en los estados lógicos de los parámetros Q, CMD_HIS, ET (solo si ET < PT), OA y CA:
– Los parámetros Q y CMD_HIS se ponen a "1"
– Los parámetros ET, OA y CA se ponen a "0"
● Si el estado lógico del parámetro CMD cambia de "1" a "0", los parámetros Q, ET (solo si
ET < PT), OA, CA y CMD_HIS se ponen a "0".
● Si los parámetros CMD y CMD_HIS tienen el estado lógico "1" y el parámetro O_FB se pone
a "0", la diferencia de tiempo (ms) desde la última ejecución de la instrucción se suma al
valor del parámetro ET. Si el valor del parámetro ET excede el del parámetro PT, el estado
lógico del parámetro OA se pone a "1". Si el valor del parámetro ET no excede el del
parámetro PT, el estado lógico del parámetro OA se pone a "0". El valor del parámetro
CMD_HIS se pone al del parámetro CMD.

Programación del PLC
Manual de programación y manejo, 11/2019

2187

Instrucciones
4.1 Instrucciones
● Si los estados lógicos de los parámetros CMD, CMD_HIS y O_FB están a "1" y el parámetro
C_FB devuelve el valor "0", el estado lógico del parámetro OA se pone a "0". El valor del
parámetro ET se pone al del parámetro PT. Si el estado lógico del parámetro O_FB cambia
a "0", se activa la alarma en la siguiente ejecución de la instrucción. El valor del parámetro
CMD_HIS se pone al del parámetro CMD.
● Si los parámetros CMD, CMD_HIS y C_FB devuelven "0", la diferencia de tiempo (ms)
desde la última ejecución de la instrucción se suma al valor del parámetro ET. Si el valor del
parámetro ET excede el del parámetro PT, el estado lógico del parámetro CA se pone a "1".
Si no se excede el valor del parámetro PT, el parámetro CA devuelve el estado lógico "0".
El valor del parámetro CMD_HIS se pone al del parámetro CMD.
● Si los parámetros CMD, CMD_HIS y O_FB devuelven el estado lógico "0" y el parámetro
C_FB está a "1", el parámetro CA se pone a "0". El valor del parámetro ET se pone al del
parámetro PT. Si el estado lógico del parámetro C_FB cambia a "0", se activa la alarma en
la siguiente ejecución de la instrucción. El valor del parámetro CMD_HIS se pone al del
parámetro CMD.
● Si los parámetros O_FB y C_FB devuelven simultáneamente el estado lógico "1", los
estados lógicos de ambas salidas de alarma se ponen a "1".
La instrucción "Alarma de tiempo para control discreto" no devuelve información de error.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración Tipo de da‐ Área de memoria
tos

Descripción

CMD

Input

El estado lógico "0" da la or‐
den de "Cerrar".

BOOL

I, Q, M, D, L o constante

El estado lógico "1" da la or‐
den de "Abrir".

2188

O_FB

Input

BOOL

I, Q, M, D, L o constante

Entrada de realimentación
al abrir

C_FB

Input

BOOL

I, Q, M, D, L o constante

Entrada de realimentación
al cerrar

Q

Output

BOOL

I, Q, M, D, L

Indica el estado del paráme‐
tro CMD

OA

Output

BOOL

I, Q, M, D, L

Salida de alarma al abrir

CA

Output

BOOL

I, Q, M, D, L

Salida de alarma al cerrar

ET

Static

DINT

D, L o constante

Tiempo actual transcurrido;
un ciclo de reloj = 1 ms.

PT

Static

DINT

D, L o constante

Valor de tiempo predetermi‐
nado; un ciclo de reloj = 1
ms.

PREV_TIME

Static

DWORD

D, L o constante

Hora de sistema anterior

CMD_HIS

Static

BOOL

D, L o constante

Bit de evolución de CMD

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
En el ejemplo siguiente, el parámetro CMD cambia de "0" a "1". Una vez ejecutada la
instrucción, el parámetro Q se pone a "1" y las dos salidas de alarma OA y CA se ponen a "0".
El parámetro CMD_HIS del bloque de datos de instancia se pone a "1" y el parámetro ET se
pone a "0".
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

GRAPH
CALL DCAT, "DCAT_DB"
(CMD := "Tag_Input_CMD"
O_FB := "Tag_Input_O_FB"
C_FB := "Tag_Input_C_FB"
Q => "Tag_Output_Q"
OA => "Tag_Output_OA"
CA => "Tag_Output_CA"
)

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada y salida:
Parámetro

Operando

Valor

CMD

Tag_Input_CMD

TRUE

O_FB

Tag_Input_O_FB

FALSE

C_FB

Tag_Input_C_FB

FALSE

Q

Tag_Output_Q

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

En el bloque de datos de instancia "DCAT_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

ET

DBD4

L#12

PT

DBD8

L#222

CMD_HIS

DBX16.0

FALSE

Programación del PLC
Manual de programación y manejo, 11/2019

2189

Instrucciones
4.1 Instrucciones

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

Q

Tag_Output_Q

TRUE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

En el bloque de datos de instancia "DCAT_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

ET

DBD4

L#0

CMD_HIS

DBX16.0

TRUE

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

MCAT: Alarma de tiempo para control del motor
Descripción
La instrucción "Alarma de tiempo para control del motor" acumula el tiempo desde el instante
en el que se activa una de las entradas de comando (abrir o cerrar). El tiempo se acumula hasta
que se excede el tiempo predeterminado o hasta que la entrada de realimentación
correspondiente indica que el dispositivo ha ejecutado la operación solicitada dentro del
tiempo prescrito. Si se excede el tiempo predeterminado antes de recibir respuesta, se dispara
la alarma correspondiente.

Ejecución de la instrucción "Alarma de tiempo para control del motor"
La tabla siguiente muestra las reacciones de la instrucción "Alarma de tiempo para control del
motor" a las distintas condiciones de entrada:
Parámetros de entrada

Parámetros de salida

ET

O_H
IS

C_H
IS

O_C
MD

C_C
MD

S_C
MD

O_F
B

C_F
B

OO

CO

OA

CA

ET

O_H
IS

C_HI Q
S

Estado

X

1

1

X

X

X

X

X

0

0

1

1

PT

0

0

Alarma

X

X

X

X

X

X

1

1

0

0

1

1

PT

0

0

0

Alarma

X

X

X

X

X

1

X

X

0

0

0

0

X

0

0

1

Stop

X

X

X

1

1

X

X

X

0

0

0

0

X

0

0

1

Stop

2190

0

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetros de entrada

Parámetros de salida

X

0

X

1

0

0

X

X

1

0

0

0

0

1

0

1

Empezar a
abrir

<PT

1

0

X

0

0

0

X

1

0

0

0

INC

1

0

1

Abrir

X

1

0

X

0

0

1

0

0

0

0

0

PT

1

0

1

Abierto

>=
PT

1

0

X

0

0

0

X

0

0

1

0

PT

1

0

0

Abrir alarma

X

X

0

0

1

0

X

X

0

1

0

0

0

0

1

1

Empezar a
cerrar

< PT 0

1

0

X

0

X

0

0

1

0

0

INC

0

1

1

Cerrar

X

0

1

0

X

0

0

1

0

0

0

0

PT

0

1

1

Cerrado

>=
PT

0

1

0

X

0

X

0

0

0

0

1

PT

0

1

0

Cerrar alar‐
ma

X

0

0

0

0

0

X

X

0

0

0

0

X

0

0

1

Parado

Leyenda:
INC

Sumar a ET la diferencia de tiempo (en ms) desde la última ejecución del FB

PT

PT se pone al mismo valor que ET

X

No aplicable

< PT

ET < PT

>= PT

ET >= PT

Si los parámetros de entrada O_HIS y C_HIS tienen el estado lógico "1", se ponen inmediatamente al estado lógico "0". En
este caso se aplica la última fila de la tabla mencionada más arriba (X). Puesto que por este motivo no es posible comprobar
si los parámetros de entrada O_HIS y C_HIS tienen el estado lógico "1", en este caso se asigna el siguiente valor a los
parámetros de salida:
OO = FALSE
CO = FALSE
OA = FALSE
CA = FALSE
ET = PT
Q = TRUE

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

O_CMD

Input

BOOL

I, Q, M, D, L o
constante

Entrada de la orden "Abrir"

C_CMD

Input

BOOL

I, Q, M, D, L o
constante

Entrada de la orden "Cerrar"

S_CMD

Input

BOOL

I, Q, M, D, L o
constante

Entrada de la orden "Parar"

O_FB

Input

BOOL

I, Q, M, D, L o
constante

Entrada de realimentación al
abrir

C_FB

Input

BOOL

I, Q, M, D, L o
constante

Entrada de realimentación al
cerrar

OO

Output

BOOL

I, Q, M, D, L

Salida "Abrir"

Programación del PLC
Manual de programación y manejo, 11/2019

2191

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

CO

Output

BOOL

I, Q, M, D, L

Salida "Cerrar"

OA

Output

BOOL

I, Q, M, D, L

Salida de alarma al abrir

CA

Output

BOOL

I, Q, M, D, L

Salida de alarma al cerrar

Q

Output

BOOL

I, Q, M, D, L

El estado lógico "0" indica
una condición de error

ET

Static

DINT

D, L o constante

Tiempo actual transcurrido;
un ciclo de reloj = 1 ms

PT

Static

DINT

D, L o constante

Valor de tiempo predetermi‐
nado; un ciclo de reloj = 1 ms

PREV_TIME

Static

DWORD

D, L o constante

Hora de sistema anterior

O_HIS

Static

BOOL

D, L o constante

Bit de evolución "Abrir"

C_HIS

Static

BOOL

D, L o constante

Bit de evolución "Cerrar"

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

GRAPH
CALL MCAT, "MCAT_DB"
(O_CMD := "Tag_Input_O_CMD"
C_CMD := "Tag_Input_C_CMD"
S_CMD := "Tag_Input_S_CMD"
O_FB := "Tag_Input_O_FB"
C_FB := "Tag_Input_C_FB"
OO => "Tag_OutputOpen"
CO => "Tag_OutputClosed"
OA => "Tag_Output_OA"
CA => "Tag_Output_CA"
Q => "Tag_Output_Q"
)

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada y salida:

2192

Parámetro

Operando

Valor

O_CMD

Tag_Input_O_CMD

TRUE

C_CMD

Tag_Input_C_CMD

FALSE

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Operando

Valor

S_CMD

Tag_Input_S_CMD

FALSE

O_FB

Tag_Input_O_FB

FALSE

C_FB

Tag_Input_C_FB

FALSE

OO

Tag_OutputOpen

FALSE

CO

Tag_OutputClosed

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Q

Tag_Output_Q

FALSE

En el bloque de datos de instancia "MCAT_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

ET

DBD4

L#2

PT

DBD8

L#22

O_HIS

DBX16.0

TRUE

C_HIS

DBX16.1

FALSE

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

OO

Tag_OutputOpen

TRUE

CO

Tag_OutputClosed

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Q

Tag_Output_Q

TRUE

En el bloque de datos de instancia "MCAT_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

ET

DBD4

L#0

O_HIS

DBX16.0

TRUE

CMD_HIS

DBX16.1

FALSE

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

Programación del PLC
Manual de programación y manejo, 11/2019

2193

Instrucciones
4.1 Instrucciones

IMC: Comparar bits de entrada con bits de una máscara
Descripción
La instrucción "Comparar bits de entrada con bits de una máscara" compara el estado lógico
de hasta 16 bits de entrada programados (IN_BIT0 a IN_BIT15) con el bit correspondiente de
una máscara. Es posible programar como máximo 16 pasos con máscaras. El valor del
parámetro IN_BIT0 se compara con el valor de la máscara CMP_VAL[x,0], siendo "x" el
número del paso. El número del paso de la máscara utilizada para la comparación se define en
el parámetro CMP_STEP. De esta misma manera se comparan todos los valores
programados. Los bits de entrada no programados o los bits no programados de la máscara
tienen el estado lógico predeterminado FALSE.
Si se encuentra una correspondencia al realizar la comparación, el estado lógico del parámetro
OUT se pone a "1". De lo contrario, el parámetro OUT se pone a "0".
Si el valor del parámetro CMP_STEP es mayor que 15, no se ejecuta la instrucción. En el
parámetro ERR_CODE se emite un mensaje de error.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:

2194

Paráme‐
tro

Declara‐
ción

Tipo de datos

Área de memoria

Descripción

IN_BIT0

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 0 se compara
con el bit 0 de la máscara.

IN_BIT1

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 1 se compara
con el bit 1 de la máscara.

IN_BIT2

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 2 se compara
con el bit 2 de la máscara.

IN_BIT3

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 3 se compara
con el bit 3 de la máscara.

IN_BIT4

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 4 se compara
con el bit 4 de la máscara.

IN_BIT5

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 5 se compara
con el bit 5 de la máscara.

IN_BIT6

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 6 se compara
con el bit 6 de la máscara.

IN_BIT7

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 7 se compara
con el bit 7 de la máscara.

IN_BIT8

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 8 se compara
con el bit 8 de la máscara.

IN_BIT9

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 9 se compara
con el bit 9 de la máscara.

IN_BIT10

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 10 se compa‐
ra con el bit 10 de la máscara.

IN_BIT11

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 11 se compa‐
ra con el bit 11 de la máscara.

IN_BIT12

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 12 se compa‐
ra con el bit 12 de la máscara.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Paráme‐
tro

Declara‐
ción

Tipo de datos

Área de memoria

Descripción

IN_BIT13

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 13 se compa‐
ra con el bit 13 de la máscara.

IN_BIT14

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 14 se compa‐
ra con el bit 14 de la máscara.

IN_BIT15

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 15 se compa‐
ra con el bit 15 de la máscara.

CMP_ST
EP

Input

BYTE

I, Q, M, D, L, P o constante

Número de paso de la másca‐
ra con la que se compara.

OUT

Output

BOOL

I, Q, M, D, L

El estado lógico "1" indica que
se ha encontrado una corres‐
pondencia.
El estado lógico "0" indica que
no se ha encontrado ninguna
correspondencia.

ERR_CO
DE

Output

WORD

I, Q, M, D, L, P

Información de error

CMP_VA
L

Static

ARRAY OF
WORD

I, Q, M, D, L o constante

Máscaras de comparación [0
a 15, 0 a 15]: El primer número
del índice es el número de la
etapa y, el segundo, el núme‐
ro de bit de la máscara.

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

000A

El valor del parámetro CMP_STEP es mayor que 15.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
En el ejemplo siguiente se comparan todos los 16 bits de entrada con la máscara para el paso
2. El estado lógico del parámetro OUT se pone a TRUE porque los bits de entrada concuerdan
con la máscara para el paso 2.
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

Programación del PLC
Manual de programación y manejo, 11/2019

2195

Instrucciones
4.1 Instrucciones

GRAPH
CALL IMC, "IMC_DB"
(IN_BIT0 - 15 := "Tag_Input_BITn"
CMP_STEP := "Tag_CMP_STEP"
OUT => "Tag_Output"
ERR_CODE => "Tag_ErrorCode"
)

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada y salida:
Parámetro

Operando

Valor

IN_BIT0

Tag_Input_BIT0

TRUE

IN_BIT1

Tag_Input_BIT1

TRUE

IN_BIT2

Tag_Input_BIT2

FALSE

IN_BIT3

Tag_Input_BIT3

TRUE

IN_BIT4

Tag_Input_BIT4

TRUE

IN_BIT5

Tag_Input_BIT5

FALSE

IN_BIT6

Tag_Input_BIT6

TRUE

IN_BIT7

Tag_Input_BIT7

TRUE

IN_BIT8

Tag_Input_BIT8

FALSE

IN_BIT9

Tag_Input_BIT9

TRUE

IN_BIT10

Tag_Input_BIT10

TRUE

IN_BIT11

Tag_Input_BIT11

FALSE

IN_BIT12

Tag_Input_BIT12

TRUE

IN_BIT13

Tag_Input_BIT13

TRUE

IN_BIT14

Tag_Input_BIT14

FALSE

IN_BIT15

Tag_Input_BIT15

TRUE

CMP_STEP

Tag_CMP_STEP

B#16#02

OUT

Tag_Output

FALSE

ERR_CODE

Tag_ErrorCode

W#16#0000

En el bloque de datos de instancia "IMC_DB" de la instrucción están almacenados los
siguientes valores para la máscara del paso 2:

2196

Parámetro

Dirección

Valor

CMP_VAL [2,0]

DBX12.0

TRUE

CMP_VAL [2,1]

DBX12.1

TRUE

CMP_VAL [2,2]

DBX12.2

FALSE

CMP_VAL [2,3]

DBX12.3

TRUE

CMP_VAL [2,4]

DBX12.4

TRUE

CMP_VAL [2,5]

DBX12.5

FALSE

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Dirección

Valor

CMP_VAL [2,6]

DBX12.6

TRUE

CMP_VAL [2,7]

DBX12.7

TRUE

CMP_VAL [2,8]

DBX13.0

FALSE

CMP_VAL [2,0]

DBX13.1

TRUE

CMP_VAL [2,10]

DBX13.2

TRUE

CMP_VAL [2,11]

DBX13.3

FALSE

CMP_VAL [2,12]

DBX13.4

TRUE

CMP_VAL [2,13]

DBX13.5

TRUE

CMP_VAL [2,14]

DBX13.6

FALSE

CMP_VAL [2,15]

DBX13.7

TRUE

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

OUT

Tag_Output

TRUE

ERR_CODE

Tag_ErrorCode

W#16#0000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

SMC: Barrido de matriz
Descripción
La instrucción "Barrido de matriz" compara el estado lógico de hasta 16 bits de entrada
programados (IN_BIT0 a IN_BIT15) con los bits correspondientes de las máscaras de
comparación de cada paso. La ejecución empieza por el paso 1 y continúa hasta el último paso
programado (LAST) o hasta que se encuentre una correspondencia. El bit de entrada del
parámetro IN_BIT0 se compara con el valor de la máscara CMP_VAL[x,0], siendo "x" el
número de paso. De esta misma manera se comparan todos los valores programados. Si se
encuentra una correspondencia, el estado lógico del parámetro OUT se pone a "1" y el número
de paso se escribe con la máscara correspondiente en el parámetro OUT_STEP. Los bits de
entrada no programados o los bits no programados de la máscara tienen el estado lógico
predeterminado FALSE. Si varios pasos tienen una máscara equivalente, se indica solo la
primera correspondencia encontrada en el parámetro OUT_STEP. Si no se encuentra ninguna
correspondencia, el estado lógico del parámetro OUT se pone a "0". En este caso, el valor del
parámetro OUT_STEP excede en "1" el valor del parámetro LAST.

Programación del PLC
Manual de programación y manejo, 11/2019

2197

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Paráme‐
tro

Declara‐
ción

Tipo de datos

Área de memoria

Descripción

IN_BIT0

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 0 se compara
con el bit 0 de la máscara.

IN_BIT1

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 1 se compara
con el bit 1 de la máscara.

IN_BIT2

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 2 se compara
con el bit 2 de la máscara.

IN_BIT3

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 3 se compara
con el bit 3 de la máscara.

IN_BIT4

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 4 se compara
con el bit 4 de la máscara.

IN_BIT5

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 5 se compara
con el bit 5 de la máscara.

IN_BIT6

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 6 se compara
con el bit 6 de la máscara.

IN_BIT7

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 7 se compara
con el bit 7 de la máscara.

IN_BIT8

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 8 se compara
con el bit 8 de la máscara.

IN_BIT9

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 9 se compara
con el bit 9 de la máscara.

IN_BIT10

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 10 se compa‐
ra con el bit 10 de la máscara.

IN_BIT11

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 11 se compa‐
ra con el bit 11 de la máscara.

IN_BIT12

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 12 se compa‐
ra con el bit 12 de la máscara.

IN_BIT13

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 13 se compa‐
ra con el bit 13 de la máscara.

IN_BIT14

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 14 se compa‐
ra con el bit 14 de la máscara.

IN_BIT15

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 15 se compa‐
ra con el bit 15 de la máscara.

OUT

Output

BOOL

I, Q, M, D, L

El estado lógico "1" indica que
se ha encontrado una corres‐
pondencia.
El estado lógico "0" indica que
no se ha encontrado ninguna
correspondencia.

ERR_CO
DE

2198

Output

WORD

I, Q, M, D, L, P

Información de error

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Paráme‐
tro

Declara‐
ción

Tipo de datos

Área de memoria

Descripción

OUT_ST
EP

Output

BYTE

I, Q, M, D, L, P

Contiene el número de paso
con la máscara correspon‐
diente o el número de paso
que excede en "1" el valor del
parámetro LAST, si no se ha
encontrado ninguna corres‐
pondencia.

LAST

Static

BYTE

I, Q, M, D, L, P o constante

Indica el número del último pa‐
so en que se tiene que buscar
una máscara correspondiente.

CMP_VA
L

Static

ARRAY OF
WORD

I, Q, M, D, L o constante

Máscaras de comparación [0
a 15, 0 a 15]: El primer número
del índice es el número de la
etapa y, el segundo, el núme‐
ro de bit de la máscara.

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

000E

El valor del parámetro LAST es mayor que 15.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
En el ejemplo siguiente, todos los 16 bits de entrada se comparan con la máscara para los
pasos 0 a 5 hasta que se encuentre una correspondencia. Se consultan únicamente las
máscaras para los pasos 0 a 2, ya que la máscara para el paso 2 se corresponde con el bit de
entrada.
Nota
Los parámetros estáticos pueden inicializarse en el bloque.

GRAPH
CALL SMC, "SMC_DB"
(IN_BIT0 - 15 := "Tag_Input_BITn"
OUT => "Tag_Output"
OUT_STEP => "Tag_Output_STEP"
ERR_CODE => "Tag_ErrorCode"

Programación del PLC
Manual de programación y manejo, 11/2019

2199

Instrucciones
4.1 Instrucciones
GRAPH
)

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada y salida:
Parámetro

Operando

Valor

IN_BIT0

Tag_Input_BIT0

TRUE

IN_BIT1

Tag_Input_BIT1

TRUE

IN_BIT2

Tag_Input_BIT2

FALSE

IN_BIT3

Tag_Input_BIT3

TRUE

IN_BIT4

Tag_Input_BIT4

TRUE

IN_BIT5

Tag_Input_BIT5

FALSE

IN_BIT6

Tag_Input_BIT6

TRUE

IN_BIT7

Tag_Input_BIT7

TRUE

IN_BIT8

Tag_Input_BIT8

FALSE

IN_BIT9

Tag_Input_BIT9

TRUE

IN_BIT10

Tag_Input_BIT10

TRUE

IN_BIT11

Tag_Input_BIT11

FALSE

IN_BIT12

Tag_Input_BIT12

TRUE

IN_BIT13

Tag_Input_BIT13

TRUE

IN_BIT14

Tag_Input_BIT14

FALSE

IN_BIT15

Tag_Input_BIT15

TRUE

OUT

Tag_Output

FALSE

OUT_STEP

Tag_Output_STEP

B#16#00

ERR_CODE

Tag_ErrorCode

W#16#0000

En el bloque de datos de instancia "SMC_DB" de la instrucción están almacenados los
siguientes valores para la máscara del paso 2:

2200

Parámetro

Dirección

Valor

CMP_VAL [2,0]

DBX12.0

TRUE

CMP_VAL [2,1]

DBX12.1

TRUE

CMP_VAL [2,2]

DBX12.2

FALSE

CMP_VAL [2,3]

DBX12.3

TRUE

CMP_VAL [2,4]

DBX12.4

TRUE

CMP_VAL [2,5]

DBX12.5

FALSE

CMP_VAL [2,6]

DBX12.6

TRUE

CMP_VAL [2,7]

DBX12.7

TRUE

CMP_VAL [2,8]

DBX13.0

FALSE

CMP_VAL [2,0]

DBX13.1

TRUE

CMP_VAL [2,10]

DBX13.2

TRUE

CMP_VAL [2,11]

DBX13.3

FALSE

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Dirección

Valor

CMP_VAL [2,12]

DBX13.4

TRUE

CMP_VAL [2,13]

DBX13.5

TRUE

CMP_VAL [2,14]

DBX13.6

FALSE

CMP_VAL [2,15]

DBX13.7

TRUE

LAST

DB84

B#16#05

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

OUT

Tag_Output

TRUE

OUT_STEP

Tag_Output_STEP

B#16#02

ERR_CODE

Tag_ErrorCode

W#16#0000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

LEAD_LAG: Algoritmo Lead y Lag
Descripción
La instrucción "Algoritmo Lead y Lag" procesa señales con una variable analógica. El valor de
la ganancia del parámetro GAIN debe ser mayor que cero. El resultado de la instrucción
"Algoritmo Lead y Lag" se calcula con la siguiente ecuación:
287

/*B7,0(
/'B7,0(6$03/(B7
/'B7,0(
,1*$,1
35(9B287*$,1
/*B7,0(6$03/(B7
/*B7,0(6$03/(B7
/*B7,0(6$03/(B7

35(9B,1

La instrucción "Algoritmo Lead y Lag" sólo devuelve resultados relevantes cuando se ejecuta
en ciclos de programa fijos. Deben indicarse las mismas unidades en los parámetros
LD_TIME, LG_TIME y SAMPLE_T. Si LG_TIME > 4 + SAMPLE_T, la instrucción se aproxima
a la siguiente función:
OUT = GAIN * ((1 + LD_TIME * s) / (1 + LG_TIME * s)) * IN
Si el valor del parámetro GAIN es menor o igual a cero, no se realiza el cálculo y el parámetro
ERR_CODE devuelve una información de error.
La instrucción "Algoritmo Lead y Lag" puede utilizarse junto con bucles para la compensación
en el control anticipativo. La instrucción comprende dos operaciones. La operación "Lead"
desplaza la fase de la salida OUT, anticipándose la salida a la entrada. En cambio, la operación
"Lag" desplaza la salida, de manera que la salida sigue a la entrada. Puesto que la operación

Programación del PLC
Manual de programación y manejo, 11/2019

2201

Instrucciones
4.1 Instrucciones
"Lag" equivale a una integración, puede utilizarse para suprimir perturbaciones o como filtro
pasa bajo. La operación "Lead" equivale a una acción diferencial, por lo que puede utilizarse
como un filtro de paso alto. La combinación de ambas operaciones (Lead y Lag) hace que la
fase de salida siga a la entrada a bajas frecuencias y se le anticipe a altas frecuencias. Por este
motivo, la instrucción "Algoritmo Lead y Lag" puede utilizarse como si fuera un filtro de paso de
banda.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:

2202

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

REAL

I, Q, M, D, L, P o
constante

Valor de entrada
del tiempo de
muestreo actual
(tiempo de ciclo)
que se procesa.

SAMPLE_T

Input

INT

I, Q, M, D, L, P o
constante

Tiempo de mues‐
treo

OUT

Output

REAL

I, Q, M, D, L, P

Resultado de la
instrucción

ERR_CODE

Output

WORD

I, Q, M, D, L, P

Información de
error

LD_TIME

Static

REAL

I, Q, M, D, L, P o
constante

Tiempo de antici‐
pación en la mis‐
ma unidad que el
tiempo de mues‐
treo.

LG_TIME

Static

REAL

I, Q, M, D, L, P o
constante

Tiempo de segui‐
miento en la mis‐
ma unidad que el
tiempo de mues‐
treo.

GAIN

Static

REAL

I, Q, M, D, L, P o
constante

Ganancia en % /
% (relación del
cambio en la sali‐
da con respecto al
cambio en la entra‐
da como estado
constante).

PREV_IN

Static

REAL

I, Q, M, D, L, P o
constante

Entrada anterior

PREV_OUT

Static

REAL

I, Q, M, D, L, P o
constante

Salida anterior

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

0009

El valor del parámetro GAIN es menor o igual a cero.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

GRAPH
CALL LEAD_LAG, "LEAD_LAG_DB"
(IN := "Tag_Input"
SAMPLE_T := "Tag_Input_SAMPLE_T"
OUT => "Tag_Output_Result"
ERR_CODE => "Tag_ErrorCode"
)

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada:
Parámetro

Operando

Valor

IN

Tag_Input

2.0

SAMPLE_T

Tag_Input_SAMPLE_T

10

En el bloque de datos de instancia "LEAD_LAG_DB" de la instrucción se guardan los
siguientes valores:
Parámetro

Dirección

Valor

LD_TIME

DBD12

2.0

LG_TIME

DBD16

2.0

GAIN

DBD20

1.0

PREV_IN

DBD24

6.0

PREV_OUT

DBD28

6.0

Programación del PLC
Manual de programación y manejo, 11/2019

2203

Instrucciones
4.1 Instrucciones

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

OUT

Tag_Output_Result

2.0

En el bloque de datos de instancia "LEAD_LAD_DB" de la instrucción se guardan los
siguientes valores:
Parámetro

Operando

Valor

PREV_IN

DBD24

2.0

PREV_OUT

DBD28

2.0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

SEG: Generar patrón de bits para el display de 7 segmentos
Descripción
La instrucción "Generar patrón de bits para el display de 7 segmentos" convierte cada una de
las cuatro cifras hexadecimales de la palabra de origen indicada (IN) en cuatro códigos
equivalentes para un display de 7 segmentos y los escribe en la palabra doble de la salida
(OUT).
La instrucción no detecta condiciones de error.

2204

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Entre los valores de entrada hexadecimales y los patrones de bits de la salida existe la relación
siguiente:
Cifra

-gfedcba

Display

0000

00111111

0

0001

00000110

1

0010

01011011

2

0011

01001111

3

0100

01100110

4

0101

01101101

5

0110

01111101

6

0111

00000111

7

1000

01111111

8

1001

01100111

9

1010

01110111

A

1011

01111100

B

1100

00111001

C

1101

01011110

D

1110

01111001

E

1111

01110001

F

Display de siete segmentos
D
I

E
J

H

F
G

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

WORD

I, Q, M, D, L, P o
constante

Palabra de origen
con cuatro cifras
hexadecimales

OUT

Output

DWORD

I, Q, M, D, L, P

Patrón de bits del
destino con cuatro
bytes

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL SEG
(IN := "Tag_Input"
OUT => "Tag_Output"
)

Programación del PLC
Manual de programación y manejo, 11/2019

2205

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores concretos:
Parámetro

Operando

Valor

Hexadecimal

Binario

IN

Tag_Input

W#16#1234

0001 0010 0011 0100

OUT

Tag_Output

DW#16065B4F66

000 00110 0101 1011 0100
1111 0110 0110
Visualización: 1234

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

BCDCPL: Generar complemento a diez
Descripción
La instrucción "Generar complemento a diez" crea el complemento a diez de un número BCD
de siete dígitos que se indica en el parámetro IN. La instrucción realiza el cálculo con la
siguiente fórmula matemática:
10000000 (como BCD)
– Valor BCD de 7 dígitos
---------------------------------------Complemento a diez (como BCD)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

IN

Input

Secuencias de bits I, Q, M, D, L, P o
constante

Número BCD de 7
dígitos

ERR_CODE

Output

DWORD

Resultado de la
instrucción

I, Q, M, D, L, P

Descripción

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL BCDCPL
(IN := "Tag_Input"

2206

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
GRAPH
ERR_CODE => "Tag_Output"
)

La tabla siguiente muestra el funcionamiento de la instrucción con valores concretos:
Parámetro

Operando

Valor*

IN

Tag_Input

DW#16#01234567

ERR_CODE

Tag_Output

DW#16#08765433

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de GRAPH (Página 8191)

BITSUM: Contar número de bits activados
Descripción
La instrucción "Contar número de bits activados" cuenta el número de bits de un operando que
están puestos al estado lógico "1". El operando cuyos bits se cuentan se especifica en el
parámetro IN. El resultado de la instrucción se devuelve en el parámetro RET_VAL.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

DWORD

I, Q, M, D, L, P o
constante

Operando cuyos bits activa‐
dos se cuentan

RET_VAL

Output

INT

I, Q, M, D, L, P

Número de bits activados

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
GRAPH
CALL BITSUM
(IN := "Tag_Input"
RET_VAL => "Tag_Output"
)

Programación del PLC
Manual de programación y manejo, 11/2019

2207

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores concretos:
Parámetro

Operando

Valor*

IN

Tag_Input

DW#16#12345678

RET_VAL

Tag_Output

W#16#000D (13 bits)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de GRAPH (Página 8191)

Instrucciones KOP en GRAPH
Instrucciones KOP generales en GRAPH
Descripción
Para la programación en GRAPH se dispone de diferentes instrucciones KOP.
La tabla siguiente ofrece una vista general de las instrucciones y su disponibilidad:
Instrucciones KOP

Instruc‐ Transición /
ción per‐ Supervisión /
manente Interlock

General
Insertar segmento

x

Cuadro vacío

x

x

Abrir rama

x

x

Cerrar rama

x

x

-|: Insertar entrada

x

Operaciones lógicas con bits

2208

---| |---: Contacto normalmente abierto (Página 621)

x

x

---| / |---: Contacto normalmente cerrado (Página 623)

x

x

--| NOT |--: Invertir RLO (Página 624)

x

x

---( )---: Asignación (Página 625)

x

---( / )---: Negar asignación (Página 626)

x

---( R )---: Desactivar salida (Página 626)

x

---( S )---: Activar salida (Página 627)

x

SET_BF: Activar mapa de bits (Página 628)

x

RESET_BF: Desactivar mapa de bits (Página 630)

x

SR: Flipflop de activación/desactivación (Página 631)

x

RS: Flipflop de desactivación/activación (Página 632)

x

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instrucciones KOP

Instruc‐ Transición /
ción per‐ Supervisión /
manente Interlock

--|P|--: Consultar flanco de señal ascendente de un operando (Página 634)

x

--|N|--: Consultar flanco de señal descendente de un operando (Página 635) x
--(P)--: Activar operando con flanco de señal ascendente (Página 637)

x

--(N)--: Activar operando con flanco de señal descendente (Página 638)

x

P_TRIG: Consultar flanco de señal ascendente del RLO (Página 639)

x

N_TRIG: Consultar flanco de señal descendente del RLO (Página 641)

x

R_TRIG: Detectar flanco de señal ascendente (Página 642)

x

F_TRIG: Detectar flanco de señal descendente (Página 643)

x

Temporizadores
Temporizadores CEI
TP: Impulso (Página 644)

x

TON: Retardo al conectar (Página 649)

x

TOF: Retardo al desconectar (Página 653)

x

TONR: Acumulador de tiempo (Página 657)

x

---(TP)---: Arrancar temporizador como impulso (Página 662)

x

---(TON)---: Arrancar temporizador como retardo a la conexión (Página 666) x
---(TOF)---: Arrancar temporizador como retardo a la desconexión (Pági‐
na 670)

x

---(TONR)---: Acumulador de tiempo (Página 674)

x

---(RT)---: Inicializar temporizador (Página 678)

x

---(PT)---: Cargar tiempo (Página 680)

x

Temporizadores SIMATIC (S7-1500)
S_PULSE: Parametrizar y arrancar temporizador como impulso (Página 683) x
S_PEXT: Parametrizar y arrancar temporizador como impulso prolongado
(Página 686)

x

S_ODT: Parametrizar y arrancar temporizador como retardo a la conexión
(Página 689)

x

S_ODTS: Parametrizar y arrancar temporizador como retardo a la conexión
con memoria (Página 692)

x

S_OFFDT: Parametrizar y arrancar temporizador como retardo a la desco‐
nexión (Página 694)

x

Contadores
Contadores CEI
CTU: Contador ascendente (Página 707)

x

CTD: Contador descendente (Página 710)

x

CTUD: Contador ascendente - descendente (Página 712)

x

Contadores SIMATIC (S7-1500)
S_CU: Parametrizar e incrementar contador (Página 716)

x

S_CD: Parametrizar y decrementar contador (Página 718)

x

S_CUD: Parametrizar e incrementar/decrementar contador (Página 720)

x

Comparación
CMP ==: Igual (Página 725)

Programación del PLC
Manual de programación y manejo, 11/2019

x

x

2209

Instrucciones
4.1 Instrucciones
Instrucciones KOP

Instruc‐ Transición /
ción per‐ Supervisión /
manente Interlock

CMP <>: Diferente (Página 730)

x

x

CMP >=: Mayor o igual (Página 735)

x

x

CMP <=: Menor o igual (Página 738)

x

x

CMP >: Mayor (Página 741)

x

x

CMP <: Menor (Página 744)

x

x

IN_RANGE: Valor dentro del rango (Página 747)

x

OUT_RANGE: Valor fuera del rango (Página 748)

x

---| OK |---: Comprobar validez (Página 749)

x

---| NOT_OK |---: Comprobar invalidez (Página 750)

x

EQ_Type: Comparar si el tipo de datos es IGUAL al tipo de datos de una
variable (Página 751)

x

NE_Type: Comparar si el tipo de datos es DIFERENTE del tipo de datos de
una variable (Página 754)

x

EQ_ElemType: Comparar si el tipo de datos de un elemento del ARRAY es
IGUAL al tipo de datos de una variable (Página 756)

x

NE_ElemType: Comprar si el tipo de datos de un elemento del ARRAY es
DIFERENTE al tipo de datos de una variable (Página 758)

x

IS_NULL: Consultar si es un puntero IGUAL A CERO (Página 759)

x

NOT_NULL: Consultar si es un puntero DIFERENTE DE CERO (Página 761) x
IS_ARRAY: Consultar si es un ARRAY (Página 762)

x

EQ_TypeOfDB: Comparar si el tipo de datos DB_ANY es IGUAL al tipo de
datos de una variable (Página 763)

x

NE_TypeOfDB: Comparar si el tipo de datos DB_ANY es DIFERENTE del
tipo de datos de una variable (Página 764)

x

CMP>T: Superior al tiempo de activación de la etapa (Página 2213)

x

CMP>U: Superior al tiempo de activación ininterrumpido de la etapa (Pági‐
na 2214)

x

Funciones matemáticas

2210

CALCULATE: Calcular (Página 766)

x

ADD: Sumar (Página 769)

x

SUB: Restar (Página 771)

x

MUL: Multiplicar (Página 772)

x

DIV: Dividir (Página 773)

x

MOD: Obtener resto de división (Página 775)

x

NEG: Generar complemento a dos (Página 776)

x

INC: Incrementar (Página 777)

x

DEC: Decrementar (Página 778)

x

ABS: Calcular valor absoluto (Página 780)

x

MIN: Determinar mínimo (Página 781)

x

MAX: Determinar máximo (Página 783)

x

LIMIT: Ajustar valor límite (Página 784)

x

SQR: Calcular cuadrado (Página 787)

x

SQRT: Calcular raíz cuadrada (Página 788)

x

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instrucciones KOP

Instruc‐ Transición /
ción per‐ Supervisión /
manente Interlock

LN: Calcular logaritmo natural (Página 790)

x

EXP: Calcular valor exponencial (Página 791)

x

SIN: Calcular valor de seno (Página 792)

x

COS: Calcular valor de coseno (Página 793)

x

TAN: Calcular valor de tangente (Página 795)

x

ASIN: Calcular valor de arcoseno (Página 796)

x

ACOS: Calcular valor de arcocoseno (Página 798)

x

ATAN: Calcular valor de arcotangente (Página 799)

x

FRAC: Determinar decimales (Página 800)
EXPT: Elevar a potencia (Página 802)

x

Transferencia
MOVE: Copiar valor (Página 803)

x

Deserialize: Deserializar (Página 809)

x

Serialize: Serializar (Página 814)

x

FieldRead: Leer campo (Página 879)

x

FieldWrite: Escribir campo (Página 881)

x

MOVE_BLK: Copiar área (Página 820)

x

SCATTER: Dispersión de una secuencia de bits en bits individuales (Pági‐
na 836)

x

SCATTER_BLK: Dispersión de elementos de un ARRAY of secuencia de
bits en bits individuales (Página 841)

x

GATHER: Recopilación de bits individuales en una secuencia de bits (Pági‐ x
na 845)
GATHER_BLK: Recopilación de bits individuales en varios elementos de un
ARRAY of secuencia de bits (Página 850)

x

MOVE_BLK_VARIANT: Copiar área (Página 822)

x

UMOVE_BLK: Copiar área sin interrupciones (Página 827)

x

FILL_BLK: Rellenar área (Página 829)

x

UFILL_BLK: Rellenar área sin interrupciones (Página 833)

x

?=: Intento de asignación (Página 854)

x

SWAP: Cambiar disposición (Página 857)

x

ReadFromArrayDB: Leer desde bloque de datos de array (Página 859)

x

WriteToArrayDB: Escribir en bloque de datos de array (Página 861)

x

ReadFromArrayDBL: Leer de bloque de datos de array de la memoria de
carga (Página 864)

x

WriteToArrayDBL: Escribir en bloque de datos de array de la memoria de
carga (Página 867)

x

VariantGet: Leer valor de una variable VARIANT (Página 870)

x

VariantPut: Escribir valor en una variable VARIANT (Página 872)

x

CountOfElements: Consultar número de elementos de ARRAY (Página 874) x
LOWER_BOUND: Leer límite inferior del ARRAY (Página 876)

x

UPPER_BOUND: Leer límite superior del ARRAY (Página 877)

x

Programación del PLC
Manual de programación y manejo, 11/2019

2211

Instrucciones
4.1 Instrucciones
Instrucciones KOP

Instruc‐ Transición /
ción per‐ Supervisión /
manente Interlock

BLKMOV: Copiar área (S7-1500) (Página 883)

x

UBLKMOV: Copiar área sin interrupciones (S7-1500) (Página 887)

x

FILL: Rellenar área (S7-1500) (Página 890)

x

Conversión
CONVERT: Convertir valor (Página 893)

x

ROUND: Redondear número (Página 896)

x

CEIL: Redondear número en coma flotante al siguiente entero superior (Pá‐ x
gina 897)
FLOOR: Redondear número en coma flotante al siguiente entero inferior
(Página 898)

x

TRUNC: Truncar a entero (Página 900)

x

SCALE_X: Escalar (Página 901)

x

NORM_X: Normalizar (Página 904)

x

SCALE: Escalar (S7-1500) (Página 906)

x

UNSCALE: Desescalar (S7-1500) (Página 908)

x

Control del programa
Control en runtime
ENDIS_PW: Limitar y habilitar legitimación de la contraseña (Página 920)

x

RE_TRIGR: Reiniciar tiempo de vigilancia del ciclo (Página 927)

x

STP: Finalizar programa (Página 928)

x

GET_ERROR: Consultar error localmente (Página 928)

x

GET_ERR_ID: Consultar ID de error localmente (Página 933)

x

INIT_RD: Inicializar todos los datos remanentes (Página 936)

x

WAIT: Programar retardo (Página 937)

x

RUNTIME: Medir tiempo de ejecución (Página 940)

x

Operaciones lógicas con palabras
AND: Operación lógica Y (Página 942)

x

OR: Operación lógica O (Página 944)

x

XOR: Operación lógica O-exclusiva (Página 945)

x

INV: Generar complemento a 1 (Página 947)

x

DECO: Descodificar (Página 948)

x

ENCO: Codificar (Página 949)

x

SEL: Seleccionar (Página 951)

x

MUX: Multiplexar (Página 953)

x

DEMUX: Desmultiplexar (Página 956)

x

Desplazamiento y rotación
SHR: Desplazar a la derecha (Página 959)

x

SHL: Desplazar a la izquierda (Página 961)

x

ROR: Rotar a la derecha (Página 963)

x

ROL: Rotar a la izquierda (Página 965)

x

Otras instrucciones
DRUM: Materializar circuito secuencial sucesivo (Página 967)

2212

x

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instrucciones KOP

Instruc‐ Transición /
ción per‐ Supervisión /
manente Interlock

DCAT: Alarma de tiempo para control discreto (Página 974)

x

MCAT: Alarma de tiempo para control del motor (Página 977)

x

IMC: Comparar los bits de entrada con los bits de la máscara (Página 981)

x

SMC: Barrido de matriz (Página 983)

x

LEAD_LAG: Algoritmo Lead y Lag (Página 985)

x

SEG: Generar patrón de bits para el display de 7 segmentos (Página 988)

x

BCDCPL: Generar complemento a diez (Página 990)

x

BITSUM: Contar número de bits activados (Página 992)

x

CMP>T: Superior al tiempo de activación de la etapa
Descripción
Con la instrucción "Superior al tiempo de activación de la etapa" se vigila la duración total de
una etapa en condiciones de supervisión. De esta manera se registra el tiempo de los posibles
eventos o errores.
En la condición programada se compara el tiempo de activación en curso o el último de una
etapa (operando1) con un tiempo definido (operando2) en milisegundos. Si se cumple la
condición de la comparación, la instrucción devuelve el resultado lógico (RLO) "1". Si la
condición de la comparación no se cumple, la instrucción devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucción está "inactiva"
En las condiciones citadas a continuación se aplica lo siguiente:
● Antes de la instrucción "CMP >T: Superior al tiempo de activación de la etapa" (con tipo de
datos STRING, WSTRING) se consulta una condición (p. ej. un contacto normalmente
abierto) en el segmento.
● "Activar observación" está activado.
● Un nuevo resultado de la condición vuelve a poner el segmento a FALSE. De este modo,
la instrucción "CMP >T: Superior al tiempo de activación de la etapa" está inactiva.
Resultado:
Para la instrucción "CMP >T: Superior al tiempo de activación de la etapa" (tipo de datos
STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observación" o se desplaza a otro segmento, se mostrará
de nuevo el estado correcto de la instrucción "CMP >T: Superior al tiempo de activación de la
etapa" (tipo de datos STRING, WSTRING). La instrucción "CMP >T: Superior al tiempo de
activación de la etapa" se muestra atenuada en el segmento cuando está inactiva.

Programación del PLC
Manual de programación y manejo, 11/2019

2213

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Superior al tiempo de activación
de la etapa":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operan‐
do1>

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activación actual
o último de la etapa

<Operan‐
do2>

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‐
ra

Ejemplo
El siguiente ejemplo muestra la instrucción en el segmento:
67(37
!
7,0(
706

Mientras el tiempo de activación de #STEP1.T esté por debajo de 100 ms, el RLO será "0". En
cuanto el tiempo de activación sobrepasa 100 ms, el RLO cambia a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

CMP>U: Superior al tiempo de activación ininterrumpido de la etapa
Descripción
Con la instrucción "Superior al tiempo de activación ininterrumpido de la etapa", se vigila la
duración de una etapa, sin tener en cuenta las posibles averías, en condiciones de supervisión.
No se registra el tiempo de posibles eventos o fallos sino que se supervisa la duración de la
mera etapa.

2214

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En la condición programada se compara todo el tiempo de activación de la etapa (operando1)
con un tiempo definido (operando2) en milisegundos. Si se cumple la condición de la
comparación, la instrucción devuelve el resultado lógico (RLO) "1". Si la condición de la
comparación no se cumple, la instrucción devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucción está "inactiva"
En las condiciones citadas a continuación se aplica lo siguiente:
● Antes de la instrucción "CMP >U: Superior al tiempo de activación ininterrumpido de la
etapa" (con tipo de datos STRING, WSTRING) se consulta una condición (p. ej. un contacto
normalmente abierto) en el segmento.
● "Activar observación" está activado.
● Un nuevo resultado de la condición vuelve a poner el segmento a FALSE. De este modo,
la instrucción "CMP >U: Superior al tiempo de activación ininterrumpido de la etapa" está
inactiva.
Resultado:
Para la instrucción "CMP >U: Superior al tiempo de activación ininterrumpido de la etapa" (tipo
de datos STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observación" o se desplaza a otro segmento, se mostrará
de nuevo el estado correcto de la instrucción "CMP >U: Superior al tiempo de activación
ininterrumpido de la etapa" (tipo de datos STRING, WSTRING). La instrucción "CMP >U:
Superior al tiempo de activación ininterrumpido de la etapa" se muestra atenuada en el
segmento cuando está inactiva.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Superior al tiempo de activación
ininterrumpido de la etapa":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operan‐
do1>

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activación actual
o último de la etapa sin con‐
tar averías

<Operan‐
do2>

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‐
ra

Programación del PLC
Manual de programación y manejo, 11/2019

2215

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucción en el segmento:
67(38
!
7,0(
706

Mientras el tiempo de activación de #STEP1.U, sin tener en cuenta las posibles averías, esté
por debajo de 100 ms, el RLO será igual a "0". En cuanto el tiempo de activación sobrepasa
100 ms, el RLO cambia a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

CMP>T_MAX: Superior al tiempo máximo de activación de etapa
Descripción
Con la instrucción "Superior al tiempo máximo de activación de etapa" se vigila la duración total
máxima de una etapa en condiciones de supervisión. De esta manera se registra el tiempo de
los posibles eventos o errores.
En la condición programada se compara el tiempo de activación en curso o el último de una
etapa (operando1) con la duración máxima (operando2) en milisegundos. Si se cumple la

2216

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
condición de la comparación, la instrucción devuelve el resultado lógico (RLO) "1". Si la
condición de la comparación no se cumple, la instrucción devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucción está "inactiva"
En las condiciones citadas a continuación se aplica lo siguiente:
● Antes de la instrucción "CMP >T_MAX: Superior al tiempo máximo de activación de etapa"
(con tipo de datos STRING, WSTRING) se consulta una condición (p. ej. un contacto
normalmente abierto) en el segmento.
● "Activar observación" está activado.
● Un nuevo resultado de la condición vuelve a poner el segmento a FALSE. De este modo,
la instrucción "CMP >T_MAX: Superior al tiempo máximo de activación de etapa" está
inactiva.
Resultado:
Para la instrucción "CMP >T_MAX: Superior al tiempo máximo de activación de etapa" (tipo de
datos STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observación" o se desplaza a otro segmento, se mostrará
de nuevo el estado correcto de la instrucción "CMP >T_MAX: Superior al tiempo máximo de
activación de etapa" (tipo de datos STRING, WSTRING). La instrucción "CMP >T_MAX:
Superior al tiempo máximo de activación de etapa" se muestra atenuada en el segmento
cuando está inactiva.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Superior al tiempo máximo de
activación de etapa":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operan‐
do1>

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activación actual
o último de la etapa

<Operan‐
do2>

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‐
ra

Programación del PLC
Manual de programación y manejo, 11/2019

2217

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucción en el segmento:
6WHS7
!
7,0(
6WHS7B0$;

Mientras el tiempo de activación de #STEP1.T esté por debajo del tiempo máximo de
activación de etapa de #Step1.T_MAX, el RLO será "0". En cuanto el tiempo de activación
sobrepasa el tiempo máximo de activación de etapa, el RLO cambia a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de la vigilancia del tiempo de etapa (Página 8289)
Programar la vigilancia del tiempo de etapa (Página 8290)
Principios básicos de GRAPH (Página 8191)

CMP>T_WARN: Superior al tiempo de advertencia
Descripción
Con la instrucción "Superior al tiempo de advertencia" se vigila la duración de una etapa en
condiciones de supervisión y, si se excede el tiempo, se emite una alarma. De esta manera se
registra el tiempo de los posibles eventos o errores.
En la condición programada se compara el tiempo de activación en curso o el último de una
etapa (operando1) con un tiempo definido (operando2) en milisegundos. Si se cumple la

2218

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
condición de la comparación, la instrucción devuelve el resultado lógico (RLO) "1" y se emite
una alarma. Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucción está "inactiva"
En las condiciones citadas a continuación se aplica lo siguiente:
● Antes de la instrucción "CMP >T_WARN: Superior al tiempo de advertencia" (con tipo de
datos STRING, WSTRING) se consulta una condición (p. ej. un contacto normalmente
abierto) en el segmento.
● "Activar observación" está activado.
● Un nuevo resultado de la condición vuelve a poner el segmento a FALSE. De este modo,
la instrucción "CMP >T_WARN: Superior al tiempo de advertencia" está inactiva.
Resultado:
Para la instrucción "CMP >T_WARN: Superior al tiempo de advertencia" (tipo de datos
STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observación" o se desplaza a otro segmento, se mostrará
de nuevo el estado correcto de la instrucción "CMP >T_WARN: Superior al tiempo de
advertencia" (tipo de datos STRING, WSTRING). La instrucción "CMP >T_WARN: Superior al
tiempo de advertencia" se muestra atenuada en el segmento cuando está inactiva.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Superior al tiempo de advertencia":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operan‐
do1>

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activación actual
o último de la etapa

<Operan‐
do2>

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‐
ra

Programación del PLC
Manual de programación y manejo, 11/2019

2219

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucción en el segmento:
6WHS7
!
7,0(
6WHS7B:$51

Mientras el tiempo de activación de #Step1.T no haya excedido el tiempo de advertencia de
#Step1.T_WARN, el RLO será "0". En cuanto se sobrepasa el tiempo de advertencia, el RLO
cambia a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de la vigilancia del tiempo de etapa (Página 8289)
Programar la vigilancia del tiempo de etapa (Página 8290)
Principios básicos de GRAPH (Página 8191)

Instrucciones FUP en GRAPH
Instrucciones FUP generales en GRAPH
Descripción
Para la programación en GRAPH se dispone de diferentes instrucciones FUP.
La tabla siguiente ofrece una vista general de las instrucciones y su disponibilidad:
Instrucción FUP

Operación
permanen‐
te

Transición/
Supervi‐
sión/ Inter‐
lock

General
Nuevo segmento

x

Cuadro vacío

x

x

Derivación: Abrir rama

x

x

-|: Insertar entrada (Página 1000)

x

x

-o|: Invertir RLO (Página 1001)

x

x

&: Operación lógica Y (Página 993)

x

x

>=1: Operación lógica O (Página 995)

x

x

X: Operación lógica O-exclusiva (Página 998)

x

=: Asignación (Página 1002)

x

Operaciones lógicas con bits

2220

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instrucción FUP

Operación
permanen‐
te

/=: Negar asignación (Página 1003)

x

R: Desactivar salida (Página 1003)

x

S: Activar salida (Página 1004)

x

SET_BF: Activar mapa de bits (Página 1005)

x

RESET_BF: Desactivar mapa de bits (Página 1007)

x

SR: Flipflop de activación/desactivación (Página 1008)

x

RS: Flipflop de desactivación/activación (Página 1010)

x

P: Consultar flanco de señal ascendente de un operando (Página 1011)

x

Transición/
Supervi‐
sión/ Inter‐
lock

N: Consultar flanco de señal descendente de un operando (Página 1013) x
P=: Activar operando con flanco de señal ascendente (Página 1014)

x

N=: Activar operando con flanco de señal descendente (Página 1016)

x

P_TRIG: Consultar flanco de señal ascendente del RLO (Página 1017)

x

N_TRIG: Consultar flanco de señal descendente del RLO (Página 1018)

x

R_TRIG: Detectar flanco de señal ascendente (Página 1019)

x

F_TRIG: Detectar flanco de señal descendente (Página 1021)

x

Temporizadores
Temporizadores CEI
TP: Impulso (Página 1022)

x

TON: Retardo al conectar (Página 1026)

x

TOF: Retardo al desconectar (Página 1030)

x

TONR: Acumulador de tiempo (Página 1034)

x

TP: Arrancar temporizador como impulso (Página 1039)

x

TON: Arrancar temporizador como retardo a la conexión (Página 1044)

x

TOF: Arrancar temporizador como retardo a la desconexión (Página 1048) x
TONR: Acumulador de tiempo (Página 1052)

x

RT: Inicializar temporizador (Página 1056)

x

PT: Cargar tiempo (Página 1058)

x

Temporizadores SIMATIC
S_PULSE: Parametrizar y arrancar temporizador como impulso (Pági‐
na 1061)

x

S_PEXT: Parametrizar y arrancar temporizador como impulso prolongado
(Página 1064)

x

S_ODT: Parametrizar y arrancar temporizador como retardo a la conexión
(Página 1067)

x

S_ODTS: Parametrizar y arrancar temporizador como retardo a la cone‐
xión con memoria (Página 1070)

x

S_OFFDT: Parametrizar y arrancar temporizador como retardo a la des‐
conexión (Página 1072)

x

Contadores
Contadores CEI
CTU: Contador ascendente (Página 1085)

Programación del PLC
Manual de programación y manejo, 11/2019

x

2221

Instrucciones
4.1 Instrucciones
Instrucción FUP

Operación
permanen‐
te

CTD: Contador descendente (Página 1087)

x

CTUD: Contador ascendente - descendente (Página 1090)

x

Transición/
Supervi‐
sión/ Inter‐
lock

Contadores SIMATIC
S_CU: Parametrizar e incrementar contador (Página 1093)

x

S_CD: Parametrizar y decrementar contador (Página 1095)

x

S_CUD: Parametrizar e incrementar/decrementar contador (Página 1097) x
Comparación
CMP ==: Igual (Página 1103)

x

x

CMP <>: Diferente (Página 1108)

x

x

CMP >=: Mayor o igual (Página 1113)

x

x

CMP <=: Menor o igual (Página 1116)

x

x

CMP >: Mayor (Página 1118)

x

x

CMP <: Menor (Página 1121)

x

x

IN_RANGE: Valor dentro del rango (Página 1124)

x

OUT_RANGE: Valor fuera del rango (Página 1125)

x

---| OK |---: Comprobar validez (Página 1126)

x

---| NOT_OK |---: Comprobar invalidez (Página 1127)

x

EQ_Type: Comparar si el tipo de datos es IGUAL al tipo de datos de una
variable (Página 1128)

x

NE_Type: Comparar si el tipo de datos es DIFERENTE del tipo de datos de x
una variable (Página 1130)
EQ_ElemType: Comparar si el tipo de datos de un elemento del ARRAY es
IGUAL al tipo de datos de una variable (Página 1132)

x

NE_ElemType: Comprar si el tipo de datos de un elemento del ARRAY es
DIFERENTE al tipo de datos de una variable (Página 1134)

x

IS_NULL: Consultar si es un puntero IGUAL A CERO (Página 1135)

x

NOT_NULL: Consultar si es un puntero DIFERENTE DE CERO (Pági‐
na 1137)

x

IS_ARRAY: Consultar si es un ARRAY (Página 1138)

x

EQ_TypeOfDB: Comparar si el tipo de datos DB_ANY es IGUAL al tipo de
datos de una variable (Página 1139)

x

NE_TypeOfDB: Comparar si el tipo de datos DB_ANY es DIFERENTE del
tipo de datos de una variable (Página 1140)

x

CMP>T: Superior al tiempo de activación de la etapa (Página 2225)

x

CMP>U: Superior al tiempo de activación ininterrumpido de la etapa (Pá‐
gina 2227)

x

Funciones matemáticas

2222

CALCULATE: Calcular (Página 1142)

x

ADD: Sumar (Página 1145)

x

SUB: Restar (Página 1146)

x

MUL: Multiplicar (Página 1148)

x

DIV: Dividir (Página 1149)

x

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instrucción FUP

Operación
permanen‐
te

MOD: Obtener resto de división (Página 1151)

x

NEG: Generar complemento a dos (Página 1152)

x

INC: Incrementar (Página 1154)

x

DEC: Decrementar (Página 1155)

x

ABS: Calcular valor absoluto (Página 1156)

x

MIN: Determinar mínimo (Página 1157)

x

MAX: Determinar máximo (Página 1159)

x

LIMIT: Ajustar valor límite (Página 1161)

x

SQR: Calcular cuadrado (Página 1163)

x

SQRT: Calcular raíz cuadrada (Página 1164)

x

LN: Calcular logaritmo natural (Página 1166)

x

EXP: Calcular valor exponencial (Página 1167)

x

SIN: Calcular valor de seno (Página 1168)

x

COS: Calcular valor de coseno (Página 1170)

x

TAN: Calcular valor de tangente (Página 1171)

x

ASIN: Calcular valor de arcoseno (Página 1172)

x

ACOS: Calcular valor de arcocoseno (Página 1174)

x

ATAN: Calcular valor de arcotangente (Página 1175)

x

FRAC: Determinar decimales (Página 1176)

x

EXPT: Elevar a potencia (Página 1178)

x

Transición/
Supervi‐
sión/ Inter‐
lock

Transferencia
MOVE: Copiar valor (Página 1179)

x

Deserialize: Deserializar (Página 1185)

x

Serialize: Serializar (Página 1191)

x

FieldRead: Leer campo (Página 1254)

x

FieldWrite: Escribir campo (Página 1256)

x

MOVE_BLK: Copiar área (Página 1196)

x

SCATTER: Dispersión de una secuencia de bits en bits individuales (Pá‐
gina 1212)

x

SCATTER_BLK: Dispersión de elementos de un ARRAY of secuencia de
bits en bits individuales (Página 1217)

x

GATHER: Recopilación de bits individuales en una secuencia de bits (Pá‐ x
gina 1221)
GATHER_BLK: Recopilación de bits individuales en varios elementos de
un ARRAY of secuencia de bits (Página 1226)

x

MOVE_BLK_VARIANT: Copiar área (Página 1198)

x

UMOVE_BLK: Copiar área sin interrupciones (Página 1202)

x

FILL_BLK: Rellenar área (Página 1205)

x

UFILL_BLK: Rellenar área sin interrupciones (Página 1209)

x

?=: Intento de asignación (Página 1230)

x

SWAP: Cambiar disposición (Página 1233)

x

Programación del PLC
Manual de programación y manejo, 11/2019

2223

Instrucciones
4.1 Instrucciones
Instrucción FUP

Operación
permanen‐
te

ReadFromArrayDB: Leer desde bloque de datos de array (Página 1235)

x

WriteToArrayDB: Escribir en bloque de datos de array (Página 1237)

x

ReadFromArrayDBL: Leer de bloque de datos de array de la memoria de
carga (Página 1240)

x

WriteToArrayDBL: Escribir en bloque de datos de array de la memoria de
carga (Página 1243)

x

VariantGet: Leer valor de una variable VARIANT (Página 1246)

x

VariantPut: Escribir valor en una variable VARIANT (Página 1247)

x

CountOfElements: Consultar número de elementos de ARRAY (Pági‐
na 1249)

x

LOWER_BOUND: Leer límite inferior del ARRAY (Página 1251)

x

UPPER_BOUND: Leer límite superior del ARRAY (Página 1252)

x

BLKMOV: Copiar área (S7-1500) (Página 1258)

x

UBLKMOV: Copiar área sin interrupciones (S7-1500) (Página 1262)

x

FILL: Rellenar área (S7-1500) (Página 1264)

x

Transición/
Supervi‐
sión/ Inter‐
lock

Conversión
CONVERT: Convertir valor (Página 1268)

x

ROUND: Redondear número (Página 1270)

x

CEIL: Redondear número en coma flotante al siguiente entero superior
(Página 1271)

x

FLOOR: Redondear número en coma flotante al siguiente entero inferior
(Página 1273)

x

TRUNC: Truncar a entero (Página 1274)

x

SCALE_X: Escalar (Página 1276)

x

NORM_X: Normalizar (Página 1278)

x

VARIANT_TO_DB_ANY: Convertir VARIANT en DB_ANY

x

DB_ANY_TO_VARIANT: Convertir DB_ANY en VARIANT

x

SCALE: Escalar (S7-1500) (Página 1281)

x

UNSCALE: Desescalar (S7-1500) (Página 1283)

x

Control del programa
Control en runtime
ENDIS_PW: Limitar y habilitar legitimación de la contraseña (Página 1295) x
RE_TRIGR: Reiniciar tiempo de vigilancia del ciclo (Página 1301)

x

STP: Finalizar programa (Página 1302)

x

GET_ERROR: Consultar error localmente (Página 1303)

x

GET_ERR_ID: Consultar ID de error localmente (Página 1307)

x

INIT_RD: Inicializar todos los datos remanentes (Página 1310)

x

WAIT: Programar retardo (Página 1312)

x

RUNTIME: Medir tiempo de ejecución (Página 1314)

x

Operaciones lógicas con palabras
AND: Operación lógica Y (Página 1316)

2224

x

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instrucción FUP

Operación
permanen‐
te

OR: Operación lógica O (Página 1318)

x

XOR: Operación lógica O-exclusiva (Página 1320)

x

INV: Generar complemento a 1 (Página 1321)

x

DECO: Descodificar (Página 1323)

x

ENCO: Codificar (Página 1324)

x

SEL: Seleccionar (Página 1325)

x

MUX: Multiplexar (Página 1327)

x

DEMUX: Desmultiplexar (Página 1330)

x

Transición/
Supervi‐
sión/ Inter‐
lock

Desplazamiento y rotación
SHR: Desplazar a la derecha (Página 1333)

x

SHL: Desplazar a la izquierda (Página 1335)

x

ROR: Rotar a la derecha (Página 1337)

x

ROL: Rotar a la izquierda (Página 1339)

x

Otras instrucciones
DRUM: Materializar circuito secuencial sucesivo (Página 1341)

x

DCAT: Alarma de tiempo para control discreto (Página 1348)

x

MCAT: Alarma de tiempo para control del motor (Página 1351)

x

IMC: Comparar los bits de entrada con los bits de la máscara (Pági‐
na 1354)

x

SMC: Barrido de matriz (Página 1357)

x

LEAD_LAG: Algoritmo Lead y Lag (Página 1359)

x

SEG: Generar patrón de bits para el display de 7 segmentos (Página 1362) x
BCDCPL: Generar complemento a diez (Página 1364)

x

BITSUM: Contar número de bits activados (Página 1365)

x

CMP>T: Superior al tiempo de activación de la etapa
Descripción
Con la instrucción "Superior al tiempo de activación de la etapa" se puede vigilar la duración
total de una etapa en condiciones de supervisión. De esta manera se registra el tiempo de los
posibles eventos o errores.
En la condición programada se compara el tiempo de activación en curso o el último de una
etapa (operando1) con un tiempo definido (operando2) en milisegundos. Si se cumple la

Programación del PLC
Manual de programación y manejo, 11/2019

2225

Instrucciones
4.1 Instrucciones
condición de la comparación, la instrucción devuelve el resultado lógico (RLO) "1". Si la
condición de la comparación no se cumple, la instrucción devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucción está "inactiva"
En las condiciones citadas a continuación se aplica lo siguiente:
● Antes de la instrucción "CMP >T: Superior al tiempo de activación de la etapa" (con tipo de
datos STRING, WSTRING) se consulta una condición (p. ej. un contacto normalmente
abierto) en el segmento.
● "Activar observación" está activado.
● Un nuevo resultado de la condición vuelve a poner el segmento a FALSE. De este modo,
la instrucción "CMP >T: Superior al tiempo de activación de la etapa" está inactiva.
Resultado:
Para la instrucción "CMP >T: Superior al tiempo de activación de la etapa" (tipo de datos
STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observación" o se desplaza a otro segmento, se mostrará
de nuevo el estado correcto de la instrucción "CMP >T: Superior al tiempo de activación de la
etapa" (tipo de datos STRING, WSTRING). La instrucción "CMP >T: Superior al tiempo de
activación de la etapa" se muestra atenuada en el segmento cuando está inactiva.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Superior al tiempo de activación
de la etapa":

2226

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activación actual
o último de la etapa

IN2

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‐
ra

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucción en el segmento:
!
7LPH
67(37
706

,1
,1

Mientras el tiempo de activación de #STEP1.T esté por debajo de 100 ms, el RLO será "0". En
cuanto el tiempo de activación sobrepasa 100 ms, el RLO cambia a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

CMP>U: Superior al tiempo de activación ininterrumpido de la etapa
Descripción
Con la instrucción "Superior al tiempo de activación ininterrumpido de la etapa", se puede
vigilar la duración de una etapa, sin tener en cuenta las posibles averías, en condiciones de
supervisión. No se registra el tiempo de posibles eventos o fallos sino que se supervisa la
duración de la mera etapa.
En la condición programada se compara todo el tiempo de activación de una etapa
(operando1) con un tiempo definido (operando2) en milisegundos. Si se cumple la condición

Programación del PLC
Manual de programación y manejo, 11/2019

2227

Instrucciones
4.1 Instrucciones
de la comparación, la instrucción devuelve el resultado lógico (RLO) "1". Si la condición de la
comparación no se cumple, la instrucción devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucción está "inactiva"
En las condiciones citadas a continuación se aplica lo siguiente:
● Antes de la instrucción "CMP >U: Superior al tiempo de activación ininterrumpido de la
etapa" (con tipo de datos STRING, WSTRING) se consulta una condición (p. ej. un contacto
normalmente abierto) en el segmento.
● "Activar observación" está activado.
● Un nuevo resultado de la condición vuelve a poner el segmento a FALSE. De este modo,
la instrucción "CMP >U: Superior al tiempo de activación ininterrumpido de la etapa" está
inactiva.
Resultado:
Para la instrucción "CMP >U: Superior al tiempo de activación ininterrumpido de la etapa" (tipo
de datos STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observación" o se desplaza a otro segmento, se mostrará
de nuevo el estado correcto de la instrucción "CMP >U: Superior al tiempo de activación
ininterrumpido de la etapa" (tipo de datos STRING, WSTRING). La instrucción "CMP >U:
Superior al tiempo de activación ininterrumpido de la etapa" se muestra atenuada en el
segmento cuando está inactiva.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Superior al tiempo de activación
ininterrumpido de la etapa":

2228

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activación actual
o último de la etapa sin con‐
tar averías

IN2

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‐
ra

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucción en el segmento:
!
7LPH
67(38
706

,1
,1

Mientras el tiempo de activación de #STEP1.U, sin tener en cuenta las posibles averías, esté
por debajo de 100 ms, el RLO será igual a "0". En cuanto el tiempo de activación sobrepasa
100 ms, el RLO cambia a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de GRAPH (Página 8191)

CMP>T_MAX: Superior al tiempo máximo de activación de etapa
Descripción
Con la instrucción "Superior al tiempo máximo de activación de etapa" se vigila la duración total
máxima de una etapa en condiciones de supervisión. De esta manera se registra el tiempo de
los posibles eventos o errores.
En la condición programada se compara el tiempo de activación en curso o el último de una
etapa (operando1) con la duración máxima (operando2) en milisegundos. Si se cumple la

Programación del PLC
Manual de programación y manejo, 11/2019

2229

Instrucciones
4.1 Instrucciones
condición de la comparación, la instrucción devuelve el resultado lógico (RLO) "1". Si la
condición de la comparación no se cumple, la instrucción devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucción está "inactiva"
En las condiciones citadas a continuación se aplica lo siguiente:
● Antes de la instrucción "CMP >T_MAX: Superior al tiempo máximo de activación de etapa"
(con tipo de datos STRING, WSTRING) se consulta una condición (p. ej. un contacto
normalmente abierto) en el segmento.
● "Activar observación" está activado.
● Un nuevo resultado de la condición vuelve a poner el segmento a FALSE. De este modo,
la instrucción "CMP >T_MAX: Superior al tiempo máximo de activación de etapa" está
inactiva.
Resultado:
Para la instrucción "CMP >T_MAX: Superior al tiempo máximo de activación de etapa" (tipo de
datos STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observación" o se desplaza a otro segmento, se mostrará
de nuevo el estado correcto de la instrucción "CMP >T_MAX: Superior al tiempo máximo de
activación de etapa" (tipo de datos STRING, WSTRING). La instrucción "CMP >T_MAX:
Superior al tiempo máximo de activación de etapa" se muestra atenuada en el segmento
cuando está inactiva.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Superior al tiempo máximo de
activación de etapa":

2230

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activación actual
o último de la etapa

IN2

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‐
ra

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucción en el segmento:
!
7LPH
6WHS7
6WHS7B0$;

,1
,1

Mientras el tiempo de activación de #STEP1.T esté por debajo del tiempo máximo de
activación de etapa de #Step1.T_MAX, el RLO será "0". En cuanto el tiempo de activación
sobrepasa el tiempo máximo de activación de etapa, el RLO cambia a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de la vigilancia del tiempo de etapa (Página 8289)
Programar la vigilancia del tiempo de etapa (Página 8290)
Principios básicos de GRAPH (Página 8191)

CMP>T_WARN: Superior al tiempo de advertencia
Descripción
Con la instrucción "Superior al tiempo de advertencia" se vigila la duración de una etapa en
condiciones de supervisión y, si se excede el tiempo, se emite una alarma. De esta manera se
registra el tiempo de los posibles eventos o errores.
En la condición programada se compara el tiempo de activación en curso o el último de una
etapa (operando1) con un tiempo definido (operando2) en milisegundos. Si se cumple la

Programación del PLC
Manual de programación y manejo, 11/2019

2231

Instrucciones
4.1 Instrucciones
condición de la comparación, la instrucción devuelve el resultado lógico (RLO) "1" y se emite
una alarma. Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucción está "inactiva"
En las condiciones citadas a continuación se aplica lo siguiente:
● Antes de la instrucción "CMP >T_WARN: Superior al tiempo de advertencia" (con tipo de
datos STRING, WSTRING) se consulta una condición (p. ej. un contacto normalmente
abierto) en el segmento.
● "Activar observación" está activado.
● Un nuevo resultado de la condición vuelve a poner el segmento a FALSE. De este modo,
la instrucción "CMP >T_WARN: Superior al tiempo de advertencia" está inactiva.
Resultado:
Para la instrucción "CMP >T_WARN: Superior al tiempo de advertencia" (tipo de datos
STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observación" o se desplaza a otro segmento, se mostrará
de nuevo el estado correcto de la instrucción "CMP >T_WARN: Superior al tiempo de
advertencia" (tipo de datos STRING, WSTRING). La instrucción "CMP >T_WARN: Superior al
tiempo de advertencia" se muestra atenuada en el segmento cuando está inactiva.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Superior al tiempo de advertencia":

2232

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activación actual
o último de la etapa

IN2

Input

Enteros, números
en coma flotante,
temporizadores,
secuencias de ca‐
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‐
ra

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucción en el segmento:
!
7LPH
6WHS7
6WHS7B:$51

,1
,1

Mientras el tiempo de activación de #Step1.T no haya excedido el tiempo de advertencia de
#Step1.T_WARN, el RLO será "0". En cuanto se sobrepasa el tiempo de advertencia, el RLO
cambia a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de la vigilancia del tiempo de etapa (Página 8289)
Programar la vigilancia del tiempo de etapa (Página 8290)
Principios básicos de GRAPH (Página 8191)

4.1.4

Instrucciones avanzadas

4.1.4.1

Indicaciones generales sobre las instrucciones avanzadas

Parámetro de entrada LADDR en instrucciones con acceso a la periferia
Selección del parámetro de entrada LADDR
Muchas instrucciones avanzadas que acceden a la periferia disponen del parámetro de
entrada LADDR. Es del tipo de datos HW_IO y contiene el identificador de hardware del objeto
de hardware que debe procesar la instrucción.
El identificador de hardware debe tomarse de las propiedades del objeto de hardware en la
vista de redes o de la ficha "Constantes de sistema" de la tabla de variables estándar.
Si selecciona otro valor para el identificador de hardware, generalmente obtendrá un código de
error diferente a 0, p. ej.
● 8090: la dirección indicada en el parámetro LADDR no es válida (WR_REC, RD_REC).
● 8091: el componente de hardware direccionado con el parámetro LADDR no existe (LED).
● 8093: esta instrucción no es válida para el ID de hardware indicado en LADDR (WR_REC,
RD_REC).
No obstante, existen objetos internos de la CPU, cuyos identificadores de hardware no se
muestran p. ej. en la ficha "Constantes de sistema" de la tabla de variables estándar. Si por

Programación del PLC
Manual de programación y manejo, 11/2019

2233

Instrucciones
4.1 Instrucciones
casualidad selecciona un identificador de hardware de este tipo y lo indica en el parámetro
LADDR, no se puede garantizar que se devuelva un código de error diferente a 0, ni que la
instrucción se ejecute correctamente.
Por eso se recomienda encarecidamente asignar al parámetro LADDR únicamente los valores
que se muestren en las propiedades del objeto de hardware en la vista de redes o en la ficha
"Constantes de sistema" de la tabla de variables estándar.

4.1.4.2

Fecha y hora

T_COMP: Comparar variables de tiempo
Descripción
Con esta instrucción se comparan los contenidos de dos variables de los tipos de datos
"Temporizadores" o "Fecha y hora".
La instrucción soporta la comparación de los tipos de datos siguientes: DATE, TIME, LTIME,
TOD (TIME_OF_DAY), LTOD (LTIME_OF_DAY), DT (DATE_AND_TIME), LDT
(DATE_AND_LTIME), DTL, S5Time.
Para realizar la comparación, los tipos de datos deben coincidir en longitud y formato.
El resultado de la comparación se muestra como valor de retorno en el parámetro OUT. Una
vez que se ha cumplido la condición de comparación utilizada, el parámetro OUT se pone a "1".
Existen las siguientes posibilidades de comparación:
Símbolo

Descripción

EQ

Si los momentos son idénticos en el parámetro IN1 y en el parámetro IN2, el valor de retorno tiene el estado
lógico "1".

NE

Si los momentos no son idénticos en el parámetro IN1 y en el parámetro IN2, el valor de retorno tiene el
estado lógico "1".

GE

Si el momento del parámetro IN1 es mayor (más reciente) o igual al del parámetro IN2 , el valor de retorno
tiene el estado lógico "1".

LE

Si el momento del parámetro IN1 es menor (más antiguo) o igual al del parámetro IN2, el valor de retorno
tiene el estado lógico "1".

GT

Si el momento del parámetro IN1 es mayor (más reciente) que el del parámetro IN2, el valor de retorno tiene
el estado lógico "1".

LT

Si el momento del parámetro IN1 es menor (más antiguo) que el del parámetro IN2 , el valor de retorno tiene
el estado lógico "1".

2234

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "T_COMP":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

DATE, TIME, LTIME,
TOD, LTOD, DT,
LDT, DTL, S5Time

I, Q, M, D, L, P o cons‐
tante

Primer valor que se va a comparar

IN2

Input

DATE, TIME, LTIME,
TOD, LTOD, DT,
LDT, DTL, S5Time

I, Q, M, D, L, P o cons‐
tante

Segundo valor que se va a comparar

OUT

Output

BOOL

I, Q, M, D, L, P

Valor de retorno

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el ejemplo siguiente se comparan dos tiempos del tipo de datos LTIME utilizando la opción
de comparación "Mayor o igual".
Para almacenar los datos se crean tres variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo. Seleccione la opción de
comparación "GE".

Puesto que el tiempo del primer valor de comparación ("timeValue1") es mayor o igual al
segundo valor ("timeValue2"), el valor de retorno ("value1GEvalue2") muestra el estado lógico
"TRUE".

Programación del PLC
Manual de programación y manejo, 11/2019

2235

Instrucciones
4.1 Instrucciones

Encontrará información adicional y el código de programa para el ejemplo mencionado más
arriba aquí: Sample Library for Instructions (Página 615)

T_CONV: Convertir y extraer tiempos
Descripción
Con la instrucción "T_CONV" se convierte el tipo de datos del parámetro de entrada IN en el
tipo de datos de la salida OUT. Con los cuadros de instrucciones de la entrada y la salida se
pueden seleccionar los formatos de datos para la conversión.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "T_CONV". Si en el parámetro de
entrada y de salida se utiliza el mismo tipo de datos, la instrucción copia el correspondiente
valor.
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

S7-1200

S7-1500

IN

Input

Enteros, TIME,
fecha y hora*

WORD, ente‐
ros, tempori‐
zadores, fe‐
cha y hora*

I, Q, M, D, L, P o
constante

Valor que se va a convertir

OUT

Return

Enteros, TIME,
fecha y hora*

WORD, ente‐
ros, tempori‐
zadores, fe‐
cha y hora*

I, Q, M, D, L, P

Resultado de la conversión

* El volumen de tipos de datos soportados depende de la CPU. Consulte en el resumen de los correspondientes tipos de
datos válidos los tipos de datos que soportan los módulos S7-1200 y S7-1500.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el ejemplo siguiente se convierte un tiempo del tipo de datos DATE AND TIME en un tiempo
del tipo de datos LTIME OF DAY.

2236

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para almacenar los datos se crean dos variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo y se seleccionan los
tipos de datos.

El valor que debe convertirse ("inputTime") se emite en el parámetro de salida como nuevo
valor de tiempo ("returnTime"). La información de fecha se pierde.

Encontrará información adicional y el código de programa para el ejemplo mencionado más
arriba aquí: Sample Library for Instructions (Página 615)

Programación del PLC
Manual de programación y manejo, 11/2019

2237

Instrucciones
4.1 Instrucciones

T_ADD: Sumar tiempos
Descripción
Con esta instrucción se suma la indicación horaria del parámetro de entrada IN1 a la indicación
horaria del parámetro de entrada IN2. El resultado se puede consultar en el parámetro de
salida OUT. Es posible sumar los formatos siguientes:
● Suma de un tiempo a otro tiempo.
Ejemplo: Suma de un tipo de datos TIME a otro tipo de datos TIME.
● Suma de un tiempo a un momento.
Ejemplo: suma de un tipo de datos TIME al tipo de datos DTL.
El tipo de datos para los valores del parámetro de entrada IN1 y el parámetro de salida OUT
se determinan seleccionándolos en los cuadros de instrucciones de la entrada y de la salida.
En el parámetro de entrada IN2 especifique únicamente indicaciones horarias en formato
TIME (en módulos S7-1500 también LTIME).
Nota
Rebase por exceso/por defecto
A la hora de realizar el cálculo es posible que se produzca un rebase por exceso del valor
máximo posible o un rebase por defecto del valor mínimo posible del parámetro de salida OUT.
Seleccione la salida de habilitación ENO para comprobarlo.

Parámetros
Las tablas siguientes muestran los parámetros de la instrucción "T_ADD" correspondientes a
las posibles conversiones:
Tabla 4-7

Suma de un tiempo a otro tiempo

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

TIME

TIME, LTIME

I, Q, M, D, L, P o
constante

Primer sumando

IN2

Input

TIME

TIME, LTIME

I, Q, M, D, L, P o
constante

Segundo sumando

OUT

Return

DINT,
DWORD, TI‐
ME, TOD

TIME, LTIME,

I, Q, M, D, L, P

Resultado de la suma

S7-1200

2238

S7-1500

La selección de los tipos de datos
depende de los tipos de datos se‐
leccionados para los parámetros de
entrada IN1 e IN2.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-8
Parámetro

Suma de un tiempo a un momento
Declaración

Tipo de datos
S7-1200

IN1

Input

DTL, TOD

Área de memoria

Descripción

DT, TOD,
LTOD, LDT,
DTL

I, Q, M, D, L, P o
constante

Primer sumando

I, Q, M, D, L, P o
constante

Segundo sumando

S7-1500

IN2

Input

TIME

TIME, LTIME

OUT

Return

DINT,
DWORD, TI‐
ME, TOD,
UDINT, DTL

DT, DTL, LDT, I, Q, M, D, L, P
TOD, LTOD

Con LTIME en el parámetro IN2 so‐
lo puede utilizarse LTOD, LDT o
DTL.

Resultado de la suma
La selección de los tipos de datos
depende de los tipos de datos se‐
leccionados para los parámetros de
entrada IN1 e IN2.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el ejemplo siguiente se suma un tiempo del tipo de datos TIME a una hora del tipo de datos
TOD.
Para almacenar los datos se crean tres variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo. Se seleccionan los tipos
de datos para la hora ("timeValTOD") y el tiempo ("timeValTIME").

La hora ("timeValTOD") y el tiempo ("timeValTIME") se suman y el resultado se muestra como
hora en el parámetro de salida OUT ("valueTimeResult").

Programación del PLC
Manual de programación y manejo, 11/2019

2239

Instrucciones
4.1 Instrucciones

Encontrará información adicional y el código de programa para el ejemplo mencionado más
arriba aquí: Sample Library for Instructions (Página 615)

T_SUB: Restar tiempos
Descripción
Con esta instrucción se resta la indicación horaria del parámetro de entrada IN2 de la
indicación horaria del parámetro de entrada IN1. Consulte la diferencia en el parámetro de
salida OUT. Es posible restar los formatos siguientes:
● Restar un tiempo a otro tiempo
Ejemplo: restar un tiempo del tipo de datos TIME a otro tiempo del tipo de datos TIME. El
resultado puede emitirse en una variable del tipo de datos TIME.
● Restar un tiempo a un momento
Ejemplo: restar un tiempo del tipo de datos TIME a un momento del tipo de datos DTL. El
resultado puede emitirse en una variable del tipo de datos DTL.
Los formatos de los valores del parámetro de entrada IN1y del parámetro de salida OUT se
determinan seleccionando los tipos de datos para el parámetro de entrada y el parámetro de
salida de la instrucción.
Nota
Rebase por exceso/por defecto
A la hora de realizar el cálculo es posible que se produzca un rebase por exceso del valor
máximo posible o un rebase por defecto del valor mínimo posible del parámetro de salida OUT.
Seleccione la salida de habilitación ENO para comprobarlo.

2240

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
Las tablas siguientes muestran los parámetros de la instrucción "T_SUB" correspondientes a
las posibles conversiones:
Tabla 4-9
Parámetro

Restar un tiempo a otro tiempo
Declaración

Tipo de datos

Área de memoria Descripción

S7-1200

S7-1500

IN1

Input

TIME

TIME, LTIME

I, Q, M, D, L, P o
constante

Minuendo

IN2

Input

TIME

TIME, LTIME

I, Q, M, D, L, P o
constante

Sustraendo

OUT

Return

DINT, DWORD,
TIME, TOD,
UDINT

TIME, LTIME

I, Q, M, D, L, P

Resultado de la resta

Tabla 4-10
Parámetro
IN1

Restar un tiempo a un momento
Declaración
Input

Tipo de datos

Área de memoria Descripción

S7-1200

S7-1500

DTL, TOD

TOD, LTOD, DTL,
DT, LDT

I, Q, M, D, L, P o
constante

Minuendo
Con LTIME en el parámetro
IN2 solo se utiliza LTOD, LDT o
DTL.

IN2

Input

TIME

TIME, LTIME

I, Q, M, D, L, P o
constante

Sustraendo

OUT

Return

DTL, DINT,
DWORD, TIME,
TOD, UDINT

TOD, LTOD, DTL,
DT, LDT

I, Q, M, D, L, P

Resultado de la resta

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el ejemplo siguiente se resta un tiempo del tipo de datos TIME de una hora del tipo de datos
TOD.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo. Se seleccionan el tipo
de datos de la hora ("value1TOD") y el tipo de datos del tiempo ("value2Time").

Programación del PLC
Manual de programación y manejo, 11/2019

2241

Instrucciones
4.1 Instrucciones

La hora ("value1TOD") y el tiempo ("value2Time") se restan y el resultado se muestra como
hora en el parámetro de salida OUT ("value1MINvalue2").

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615).

T_DIFF: Diferencia de tiempo
Descripción
Con esta instrucción se resta la indicación horaria del parámetro de entrada IN2 de la
indicación horaria del parámetro de entrada IN1. El resultado se devuelve en el parámetro de
salida OUT.
● Si la indicación horaria en el parámetro de entrada IN2es mayor que la indicación horaria
en el parámetro de entrada IN1, se emite un valor negativo en el parámetro de salida OUT.
● Si el resultado de la resta se encuentra fuera del rango numérico TIME, la salida de
habilitación ENO = "0". Dependiendo del tipo de datos utilizado se obtiene un resultado
truncado o "0" (0:00).
– Si como minuendo y sustraendo se seleccionan parámetros del tipo de datos DTL, el
resultado es del tipo de datos TIME. No puede ser mayor que 24 días; en caso contrario,
la salida de habilitación ENO = "0" y el resultado es "0".
– Dicha restricción no existe si como minuendo y sustraendo se seleccionan parámetros
del tipo de datos LDT.

2242

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "T_DIFF":
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memoria

Descripción

IN1

Input

DTL, DATE,
TOD

DTL, DATE, DT,
TOD, LTOD,
LDT

I, Q, M, D, L, P o
constante

Minuendo

IN2

Input

DTL, DATE,
TOD

DTL, DATE, DT,
TOD, LTOD,
LDT

I, Q, M, D, L, P o
constante

Sustraendo

OUT

Return

TIME, INT

TIME, LTIME,
INT

I, Q, M, D, L, P

Diferencia de los parámetros
de entrada

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".
Nota
Uso de la instrucción "T_DIFF" in SCL
En SCL está predeterminado el tipo de datos TIME para el parámetro OUT (consulte
también: Principios básicos de los tipos de datos de instrucciones SCL (Página 8161)). Si
quiere usar el tipo de datos INT para OUT deberá completar el nombre de la instrucción T_DIFF
con "_INT" (consulte también: Modificar el tipo de datos de una instrucción SCL (Página 8162)).

Ejemplo
En el ejemplo siguiente se calcula la diferencia entre dos horas del tipo de datos TOD. La
diferencia se indica en el tipo de datos TIME.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo y se seleccionan los
tipos de datos. En la primera posibilidad de selección se indica el tipo de datos de los instantes.
En la segunda posibilidad de selección se indica el tipo de datos de la diferencia.

Programación del PLC
Manual de programación y manejo, 11/2019

2243

Instrucciones
4.1 Instrucciones

La primera hora ("todvalue1") y la segunda hora ("todvalue2") se restan y la diferencia se
muestra como tiempo en el parámetro de salida OUT ("timevalueDIFF").

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

T_COMBINE: Combinar tiempos
Descripción
La instrucción combina el valor de una fecha con el de una indicación horaria. El resultado es
una indicación horaria combinada de fecha y hora.
● En el parámetro de entrada IN1 se introduce la indicación de fecha. En el tipo de datos
DATE emplee un valor comprendido entre 1990-01-01 y 2089-12-31 (no se comprueba).
● En el valor de entrada IN2 se introduce la indicación horaria (tipo de datos TOD/LTOD).
● En el valor de salida OUT se emite el tipo de datos combinado para indicación de fecha y
hora.

2244

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "T_COMBINE":
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

Descripción

IN1

Input

DATE

DATE

I, Q, M, D, L, P o cons‐ Variable de entrada de la fecha
tante

IN2

Input

TOD

TOD, LTOD

I, Q, M, D, L, P o cons‐ Variable de entrada de la hora
tante

OUT

Return

DTL

DT, DTL, LDT I, Q, M, D, L, P

Valor de retorno de fecha y hora

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".
Nota
Uso de T_COMBINE en programas SCL
Si se arrastra la instrucción T_COMBINE desde la Task Card "Instrucciones" hasta la ventana
de programación SCL se muestra la instrucción interna CONCAT_DATE_TOD o
CONCAT_DATE_LTOD.

Ejemplo
En el ejemplo siguiente se combinan una hora del tipo de datos TOD y una fecha del tipo de
datos DATE. El valor de retorno se indica en el tipo de datos DT.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo y se seleccionan los
tipos de datos. En la primera posibilidad de selección se indica el tipo de datos de la hora del
día ("valueTOD"). En la segunda posibilidad de selección se indica el tipo de datos del valor de
retorno ("combTIME").

Programación del PLC
Manual de programación y manejo, 11/2019

2245

Instrucciones
4.1 Instrucciones
La fecha ("valueDATE") se amplía con la indicación de la hora ("valueTOD") y el valor de
retorno se muestra en el parámetro de salida OUT ("combTIME").

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

Funciones de reloj
WR_SYS_T: Ajustar la hora
Descripción
La instrucción ajusta la fecha y hora (hora del módulo) del reloj de la CPU. La indicación de
fecha y hora se especifica en el parámetro de entrada IN . El valor debe estar dentro del rango
siguiente:
● Con DT: mín. DT#1990-01-01-0:0:0, máx. DT#2089-12-31-23:59:59.999
● Con LDT: mín. LDT#1970-01-01-0:0:0.000000000, máx.
LDT#2200-12-31-23:59:59.999999999
● Con DTL: mín. DTL#1970-01-01-00:00:00.0, máx. DTL#2200-12-31-23:59:59.999999999
En el parámetro de salida RET_VAL se puede consultar si han ocurrido errores durante la
ejecución de la instrucción.
La información de zona horaria local u horario de verano no se transfiere con la instrucción
"WR_SYS_T".
Nota
Hora de módulo del reloj de la CPU
El reloj de la CPU interpreta la hora del módulo como el tiempo universal coordinado (UTC). En
consecuencia, la hora del módulo se guarda siempre en el reloj de la CPU sin los factores
"zona horaria local" u "horario de verano". El reloj de la CPU calcula su hora local basándose
en la hora del módulo.
La hora de módulo del reloj de la CPU sirve de base para todos los procesos de tiempo que
parten de la CPU. Ejemplos de uso:
● Cálculo de la hora local del reloj de la CPU basándose en la hora del módulo
● Representación de la hora del módulo en "Online y diagnóstico" en hora local
● Propiedades de bloques
● Entradas del búfer de diagnóstico de la CPU

2246

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "WR_SYS_T":
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

Descripción

IN

Input

DTL

DT **, DTL, LDT I, Q, M, D, L, P o
constante *

Fecha y hora

RET_VAL

Return

INT

INT

Estado de la instrucción

I, Q, M, D, L, P

* Los tipos de datos DT y DTL no se utilizan para las áreas de memoria Entrada, Salida y Marca.
** Si se utiliza el tipo de datos DT, los milisegundos no se transfieren a la CPU.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error*

Descripción

(W#16#....)
0000

Ningún error

8080

Error en la fecha

8081

Error en la hora

8082**

Valor no válido para indicar el mes (byte 2 en formato DTL)

8083**

Valor no válido para indicar el día (byte 3 en formato DTL)

8084**

Valor no válido para indicar la hora (byte 5 en formato DTL)

8085**

Valor no válido para indicar el minuto (byte 6 en formato DTL)

8086**

Valor no válido para indicar el segundo (byte 7 en formato DTL)

8087**

Valor no válido para indicar el nanosegundo (bytes 8 a 11 en formato DTL)

80B0

Fallo del reloj en tiempo real

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".
** Solo si la fecha y hora se indican en el parámetro IN en formato DTL

Ejemplo
En el siguiente ejemplo se ajusta la fecha y hora del reloj de la CPU. El tipo de datos utilizado
es DATE AND TIME.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo. Seleccione el tipo de
datos DATE AND TIME.

Programación del PLC
Manual de programación y manejo, 11/2019

2247

Instrucciones
4.1 Instrucciones

Si el contacto NA ("execute") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"WR_SYS_T". La hora del módulo del reloj de la CPU se sobrescribe con la hora que debe
ajustarse ("inputTIME"). En el parámetro de salida RET_VAL ("returnValueT") se indica que la
ejecución se ha realizado sin errores.

Existen varias opciones para saber si el reloj de la CPU ha adoptado correctamente la nueva
hora del módulo ("inputTIME"):
● Desde el display de una CPU S7-1500: Para ello, navegue por el display de la CPU hasta
"Ajustes > Fecha y hora > General".
● Desde el TIA Portal: Utilice la instrucción "RD_SYS_T (Página 2249)" para leer la hora del
módulo del reloj de la CPU.
● Desde el TIA Portal: Navegue hasta la opción "Online y diagnóstico" de la CPU y abra la
ficha "Funciones > Ajustar hora".
En el reloj de la CPU la hora del módulo está ajustada como tiempo universal coordinado
(UTC). Para este ejemplo, en el TIA Portal está ajustada como hora local la hora central
europea. En consecuencia, en el TIA Portal, en el apartado "Online y diagnóstico", se suma
una hora a la hora que se desea ajustar ("inputTIME"). Si se utiliza la hora de verano se
suma una hora adicional. La hora local calculada se muestra en formato de 12 horas.

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

2248

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

RD_SYS_T: Leer la hora
Descripción
La instrucción lee la fecha y hora actuales (hora del módulo) del reloj de la CPU.
Los datos leídos se devuelven en el parámetro de salida OUT de la instrucción. El valor emitido
no contiene indicaciones respecto a la zona horaria local ni al horario de verano.
Nota
Hora de módulo del reloj de la CPU
El reloj de la CPU interpreta la hora del módulo como el tiempo universal coordinado (UTC). En
consecuencia, la hora del módulo se guarda siempre en el reloj de la CPU sin los factores
"zona horaria local" u "horario de verano". El reloj de la CPU calcula su hora local basándose
en la hora del módulo.
La hora de módulo del reloj de la CPU sirve de base para todos los procesos de tiempo que
parten de la CPU. Ejemplos de uso:
● Cálculo de la hora local del reloj de la CPU basándose en la hora del módulo
● Representación de la hora del módulo en "Online y diagnóstico" en hora local
● Propiedades de bloques
● Entradas del búfer de diagnóstico de la CPU
En la salida RET_VAL se puede consultar si se han producido errores durante la ejecución de
la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RD_SYS_T":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

S7-1200

S7-1500

RET_VAL

Return

INT

INT

I, Q, M, D, L, P

Estado de la instrucción

OUT

Output

DTL

DT, DTL, LDT

I, Q, M, D, L, P *

Fecha y hora de la CPU

* Los tipos de datos DT y DTL no pueden utilizarse para las áreas de memoria Entrada, Salida y Marca.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2249

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
Código de error* Descripción
(W#16#....)
0000

Ningún error

8081

No es posible guardar los datos leídos, porque están fuera del rango admisible para el tipo de datos
seleccionado del parámetro OUT.
● Con DT: mín. DT#1990-01-01-0:0:0, máx. DT#2089-12-31-23:59:59.999
● Con LDT: mín. LDT#1970-01-01-0:0:0.000000000, máx. LDT#2262-04-11-23:47:16.854775807
● Con DTL: mín. DTL#1970-01-01-00:00:00.0, máx. DTL#2262-04-11-23:47:16.854775807

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
En el ejemplo siguiente se lee la hora del módulo del reloj de la CPU. El tipo de datos utilizado
es DATE AND TIME.
Para almacenar los datos se crean dos variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo. Seleccione el tipo de
datos DATE AND TIME.

La hora del módulo del reloj de la CPU se lee y se indica en el parámetro de salida OUT
("outputTIME"). En el parámetro de salida RET_VAL ("returnValue") se indica que la ejecución
se ha realizado sin errores.

2250

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

RD_LOC_T: Leer hora local
Descripción
La instrucción lee la hora local actual del reloj de la CPU y emite esta hora en la salida OUT.
Para emitir la hora local se utilizan las indicaciones relativas a la zona horaria y al comienzo de
los horarios de verano e invierno, que se han ajustado al configurar el reloj de la CPU.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RD_LOC_T":
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memoria

Descripción

RET_VAL

Return

INT

INT

I, Q, M, D, L, P

Estado de la instrucción

OUT

Output

DTL

DT, LDT, DTL

I, Q, M, D, L, P *

Hora local

* Los tipos de datos DT y DTL no pueden utilizarse para las áreas de memoria Entrada, Salida y Marca.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Descripción
(W#16#....)
0000

Ningún error

0001

Ningún error. La hora local se devuelve como horario de verano.

8080

No se puede leer la hora local.

8081

No es posible guardar la hora local actual, porque está fuera del rango admisible para el tipo de datos
seleccionado del parámetro OUT.
● Con DT: mín. DT#1990-01-01-0:0:0, máx. DT#2089-12-31-23:59:59.999
● Con LDT: mín. LDT#1970-01-01-0:0:0.000000000, máx. LDT#2262-04-11-23:47:16.854775807
● Con DTL: mín. DTL#1970-01-01-00:00:00.0, máx. DTL#2262-04-11-23:47:16.854775807

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

2251

Instrucciones
4.1 Instrucciones

Ejemplo
En el siguiente ejemplo se lee la hora local del reloj de la CPU. El tipo de datos utilizado es
DATE AND TIME.
Para almacenar los datos se crean dos variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo. Seleccione el tipo de
datos DATE AND TIME.

La hora local del reloj de la CPU se lee y se indica en el parámetro de salida OUT
("outputLocTIME"). En el parámetro de salida RET_VAL ("returnValue") se indica que la
ejecución se ha realizado sin errores y que la hora local se emite como horario de verano con
esta llamada.

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

WR_LOC_T: escribir hora local
Descripción
La instrucción "WR_LOC_T" ajusta la fecha y hora del reloj de la CPU. La indicación de fecha
y hora se especifica como hora local en el parámetro de entrada LOCTIME.

2252

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El valor debe estar dentro del rango siguiente:
● Con DTL: mín. DTL#1970-01-01-00:00:00.0, máx. DTL#2200-12-31 23:59:59.999999999
● Con LDT: mín. LDT#1970-01-01-0:0:0.000000000, máx. LDT#2200-12-31
23:59:59.999999999
La granularidad en la indicación de la hora local y la hora del sistema es específica del producto
y es como mínimo de un milisegundo. Al calcul