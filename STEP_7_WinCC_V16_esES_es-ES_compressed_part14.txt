ar la hora del sistema, los valores de entrada del
parámetro LOCTIME inferiores a los valores soportados por la CPU se redondean.
En el parámetro de salida RET_VAL se puede consultar si han ocurrido errores durante la
ejecución de la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "WR_LOC_T":
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memoria

Descripción

LOCTIME

Input

DTL

DTL, LDT

I, Q, M, D, L, P o
constante *

Hora local

DST

Input

BOOL

BOOL

I, Q, M, D, L, P, T,
C o constante

Daylight Saving Time
Solo se evalúa durante la "hora dupli‐
cada" al cambiar al horario de invier‐
no.
● TRUE = horario de verano
(primera hora)
● FALSE = horario de invierno
(segunda hora)

RET_VAL

Return

INT

INT

I, Q, M, D, L, P

Mensaje de error (véase "Parámetro
RET_VAL")

* El tipo de datos DTL no puede utilizarse para las áreas de memoria Entrada, Salida y Marca.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2253

Instrucciones
4.1 Instrucciones

Parámetro DST (Daylight Saving Time)
El parámetro DST solo se evalúa durante el cambio del horario de verano al de invierno:
● Utilización de DST durante el cambio del horario de verano al de invierno
A las 03:00(1) de la mañana el reloj se retrasa una hora. Esto significa que la hora entre las
02:00:00:000000000 y las 02:59:59:999999999 existirá dos veces.
Por tanto, en todas las indicaciones de tiempo para LOCTIME que estén entre las
02:00:00:000000000 y las 02:59:59:999999999, deberá definir si la indicación de tiempo se
refiere al momento anterior o posterior al cambio de horario. Esto se realiza a través del
parámetro DST:
– Con DST=TRUE, la hora indicada se encuentra en la primera de estas dos horas; por
tanto, todavía en el horario de verano.
– Con DST=FALSE, la hora indicada se encuentra en la segunda de estas dos horas; por
tanto, ya en el horario de invierno.
En todas las indicaciones horarias de LOCTIME que están fuera de la hora duplicada, DST
no tiene significado.
● Cambio del horario de invierno al de verano
Durante el cambio del horario de invierno al de verano, el parámetro DST es irrelevante.
A las 02:00(1) de la mañana el reloj se adelanta una hora. Esto significa que la hora entre las
02:00:00:000000000 y las 02:59:59:999999999 no existirá.
Si en LOCTIME se especifica una indicación horaria comprendida durante esta hora, se
emite el código de error W#16#8089.
En este caso, la descripción está basada en la hora central europea (CET). En la CET, el
cambio de hora se efectúa a las 2:00 de la mañana (inicio del horario de verano) o bien a las
3:00 de la mañana (finalización del horario de verano). Es posible que en otras zonas horarias
el cambio de hora se efectúe a otras horas.
(1)

Parámetro RET_VAL
Código de error* Descripción
(W#16#....)
0000

Ningún error.

8080

Valor no válido en el parámetro LOCTIME.

8081

Valor de tiempo indicado en el parámetro LOCTIME fuera del rango de valores admisible:
● Con DTL: mín. DTL#1970-01-01-00:00:00.0, máx. DTL#2200-12-31 23:59:59.999999999
● Con LDT: mín. LDT#1970-1-1-0:0:0.000000000, máx. LDT#2200-12-31 23:59:59.999999999

8082**

Valor no válido para indicar el mes (byte 2 en formato DTL).

8083**

Valor no válido para indicar el día (byte 3 en formato DTL).

8084**

Valor no válido para indicar la hora (byte 5 en formato DTL).

8085**

Valor no válido para indicar el minuto (byte 6 en formato DTL).

8086**

Valor no válido para indicar el segundo (byte 7 en formato DTL).

8087**

Valor no válido para indicar el nanosegundo (bytes 8 a 11 en formato DTL).

8089

El valor de tiempo no existe (hora pasada al cambiar a horario de verano).

80B0

Fallo del reloj en tiempo real.

2254

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error* Descripción
(W#16#....)
* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".
** Solo con indicación de hora local en el parámetro LOCTIME en formato DTL.

Ejemplo
En el siguiente ejemplo se ajusta la hora local del reloj de la CPU. El tipo de datos utilizado es
DTL.
Para almacenar los datos es preciso crear cuatro variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo. Seleccione el tipo de
datos DTL.

Si el contacto NA ("execute") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"WR_LOC_T". La hora local del reloj de la CPU se sobrescribe con el tiempo que debe
ajustarse ("inputLocTIME"). En el parámetro de salida RET_VAL ("returnValue") se indica que
la operación se ha realizado sin errores. El parámetro de entrada DST ("dstValue") indica que
la hora indicada se basa en el horario de invierno Este parámetro es relevante solo para la
"hora doble" (ver la descripción "Parámetro DST").

Programación del PLC
Manual de programación y manejo, 11/2019

2255

Instrucciones
4.1 Instrucciones

Para saber si el reloj de la CPU ha adoptado correctamente la nueva hora local
("inputLocTIME"), existen varias opciones:
● Desde el display de una CPU S7-1500: Para ello, navegue por el display de la CPU hasta
"Ajustes > Fecha y hora > General".
● Desde el TIA Portal: Utilice la instrucción "RD_LOC_T (Página 2251)" para leer la hora local
del reloj de la CPU.
● Desde el TIA Portal: Navegue hasta la opción "Online y diagnóstico" de la CPU y abra la
ficha "Funciones > Ajustar hora".
La hora local se muestra en formato de 12 horas.

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

SET_TIMEZONE: Ajustar zona horaria
Descripción
La instrucción "SET_TIMEZONE" permite ajustar los parámetros para establecer la zona
horaria local y cambiar al horario de verano/invierno.
Los ajustes realizados con la instrucción "SET_TIMEZONE" se corresponden con los ajustes
asociados a la hora en las propiedades de la CPU. Para ejecutar la instrucción
"SET_TIMEZONE" guarde los parámetros correspondientes en el tipo de datos de sistema
TimeTransformationRule.

2256

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La hora local se calcula a partir de la hora del sistema con los ajustes para establecer la zona
horaria y cambiar al horario de verano/invierno. La hora del sistema de la CPU es la hora UTC.
Para la comunicación dentro del sistema se utiliza exclusivamente la hora del sistema.
Nota
Llamada de la instrucción "SET_TIMEZONE"
La instrucción "SET_TIMEZONE" escribe internamente datos en la memoria de carga de la
CPU. En consecuencia, el cambio de la zona horaria sigue activo tras una desconexión. No es
necesario repetir la llamada de la instrucción.
Llame una sola vez la instrucción cada vez que deba cambiarse la zona horaria. Por ejemplo,
es recomendable llamar a "SET_TIMEZONE" en un OB de arranque.
Nota
Utilización con CPU de la serie S7-1500
Para poder usar la instrucción "SET_TIMEZONE" con una CPU de la serie S7-1500, se
requiere la versión de firmware V1.7.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SET_TIMEZONE":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L, P o
constante

● S7-1200: con flanco ascendente en
REQ, se ejecuta la función.
● S7-1500 y versión de SET_TIMEZONE
<V2.0: si REQ=1, se ejecuta la función.
● S7-1500 y versión de SET_TIMEZONE
>=V2.0: con flanco ascendente en REQ,
se ejecuta la función.
Ejecutar la función implica que se iniciará la
transferencia de la zona horaria y la escritu‐
ra de la memoria de carga.

TimeZone

Input

TimeTransformation‐ D, L
Rule

En el parámetro TimeZone se interconecta
el tipo de datos de sistema TimeTransfor‐
mationRule (ver abajo).

DONE

Output

BOOL

Parámetros de estado:

I, Q, M, D, L, P

● 0: Petición no iniciada aún o en ejecución
● 1: Petición finalizada sin errores
BUSY

Output

BOOL

I, Q, M, D, L, P

Parámetros de estado:
● 0: Petición no iniciada aún o ya finalizada
● 1: Petición no finalizada aún. No es
posible iniciar una nueva petición.

Programación del PLC
Manual de programación y manejo, 11/2019

2257

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ERROR

Output

BOOL

I, Q, M, D, L, P

Parámetros de estado:
● 0: Ningún error
● 1: Se han producido errores

STATUS

Output

WORD

I, Q, M, D, L, P

En el parámetro STATUS se visualiza infor‐
mación de estado y error detallada. El pará‐
metro solo está activado durante una llama‐
da. Por ello, para visualizar el estado debe
copiarse el parámetro STATUS en un área
de datos libre.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro TimeZone
En el tipo de datos de sistema TimeTransformationRule se guardan los parámetros para la
zona horaria local y la alternancia de horario de verano e invierno
Para crear la TimeTransformationRule, se debe introducir el tipo de datos
TimeTransformationRule en un bloque de datos o en la interfaz local de un bloque de función.

2258

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La TimeTransformationRule tiene la siguiente estructura:
Nombre

Tipo de da‐ Descripción
tos

TimeTransformationRule STRUCT

Programación del PLC
Manual de programación y manejo, 11/2019

2259

Instrucciones
4.1 Instrucciones
Nombre
Bias

Tipo de da‐ Descripción
tos
INT

Diferencia de tiempo entre la hora local y la hora del sistema
(UTC) en minutos. El valor debe encontrarse entre -720 y
+780 minutos (de -12 a +13 horas).
El valor (UTC -12 a +13 horas) corresponde a las zonas ho‐
rarias que se han configurado en las propiedades de la CPU.

DaylightBias

INT

Desfase entre horario de invierno y horario de verano en mi‐
nutos. El valor debe estar comprendido entre 0 y 120 minutos.
● El valor "0" desactiva la alternancia de horario de verano e
invierno. Los valores para "DaylightStart..." y
"StandardStart..." se ponen a "0". Se evalúa únicamente el
valor de polarización (diferencia de tiempo entre la hora
local y la hora del sistema).
● Si el valor no es "0", se evalúan todas las variables de la
estructura TimeTransformationRule. Si se introduce un
valor no válido, en el parámetro STATUS se emite el
código de error 808F.

Indicación de la hora de cambio a horario de verano. Las siguientes indicaciones horarias hacen
referencia siempre a la hora local.
DaylightStartMonth

USINT

Mes del cambio a horario de verano:
1 = enero
2 = febrero
3 = marzo
...
12 = diciembre

DaylightStartWeek

USINT

Semana del cambio a horario de verano.
1 = primera aparición del día de la semana en el mes
...
5 = última aparición del día de la semana en el mes

DaylightStartWeek‐
day

USINT

Día de la semana del cambio a horario de verano:
1 = domingo
...
7 = sábado

DaylightStartHour

USINT

Hora del cambio a horario de verano

DaylightStartMinute

USINT

Minuto del cambio a horario de verano

Indicación de la hora de cambio a horario de invierno. Las siguientes indicaciones horarias hacen
referencia siempre a la hora local.
StandardStartMonth

USINT

Mes del cambio a horario de invierno:
1 = enero
2 = febrero
3 = marzo
...
12 = diciembre

StandardStartWeek

USINT

Semana del cambio a horario de invierno:
1 = primera aparición del día de la semana en el mes
...

2260

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Nombre

Tipo de da‐ Descripción
tos
5 = última aparición del día de la semana en el mes

StandardStartWeek‐
day

USINT

Día de la semana del cambio a horario de invierno:
1 = domingo
...
7 = sábado

StandardStartHour

USINT

Hora del cambio a horario de invierno

StandardStartMinute

USINT

Minuto del cambio a horario de invierno

TimeZoneName

STRING[8
0]

No se utiliza: la cadena de caracteres parametrizada se igno‐
ra y no se escribe en los datos internos de la CPU.

Parámetro STATUS
Código de error* Descripción
(W#16#....)
7000

No se está procesando ninguna petición.

7001

Inicio de la ejecución de la petición. Parámetro BUSY = 1, DONE = 0

7002

Llamada intermedia (REQ irrelevante): la instrucción ya está activa; BUSY tiene el valor "1".

808F

La estructura, el contenido o los tipos de datos de TimeTransformationRule en el parámetro TimeZone no
son válidos o coherentes.

80C3

Error temporal de recursos: en este momento la CPU está procesando el máximo posible de llamadas de
bloque simultáneas. "SET_TIMEZONE" no se ejecuta antes de haber finalizado como mínimo una llamada
de bloque.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Nota
Validez del ejemplo
En la forma descrita, el siguiente ejemplo solo es válido para S7-1500 con versión de
instrucción <V2.0.
En el siguiente ejemplo se ajustan los parámetros para la zona horaria local y la alternancia de
horario de verano e invierno. Llame el ejemplo preferentemente en un OB de arranque.
Para almacenar los datos debe crearse en un bloque de datos global lo siguiente: La estructura
"timezone" (con el tipo de datos TimeTransformationRule) y otras cinco variables.
Nota
Si desea llamar el ejemplo en un OB de arranque: Ponga el valor de arranque de la variable
"execute" a "TRUE".

Programación del PLC
Manual de programación y manejo, 11/2019

2261

Instrucciones
4.1 Instrucciones

Para interconectar el parámetro de salida DONE es necesario crear una variable local.

Segmento 1: Los parámetros de la instrucción "SET_TIMEZONE" se interconectan del
siguiente modo.

Además es necesario crear las siguientes interconexiones adicionales:
Segmento 2: en caso de fallo, guarde el estado en la variable "memErrStatus".

2262

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 3: El parámetro de entrada REQ ("execute") se restablece automáticamente del
siguiente modo una vez que ha finalizado la ejecución.

Segmento 4: Para que la instrucción "SET_TIMEZONE" se ejecute completamente al llamarla
en un OB de arranque, utilice las instrucciones JMP (en el segmento 4) y Label (véase
segmento 1).

Nota
Si desea llamar el ejemplo en un OB de arranque, la CPU que va a procesar el ejemplo debe
estar arrancada. Ponga la CPU en modo STOP antes de cargar el ejemplo en la CPU. A
continuación pase la CPU a modo RUN.

Programación del PLC
Manual de programación y manejo, 11/2019

2263

Instrucciones
4.1 Instrucciones
Si el parámetro REQ ("execute") devuelve el estado lógico "TRUE", los datos de la zona
horaria del reloj de la CPU se sobrescriben con los datos que deben ajustarse ("timezone").
Esto significa además:
● El parámetro de salida BUSY ("modeBUSY") pasa al estado lógico "TRUE". Tras el
procesamiento, el parámetro de salida BUSY tiene el valor "FALSE" y el parámetro de
salida DONE ("#statDone") tiene el valor "TRUE". El estado correcto se guarda en la
variable "modeDONE".
● En el parámetro de salida STATUS ("statusTime") se indica cómo discurre el
procesamiento*. (*Se inicia el procesamiento de la petición (valor "7001") y a continuación
se indica que la instrucción ya está activa (valor "7002").)
● En el parámetro de salida ERROR ("modeERROR") se indica que el procesamiento está
discurriendo sin errores (el estado lógico es "FALSE").

Nota: La instrucción "SET_TIMEZONE" se activa por nivel. La instrucción solo se ejecuta si el
parámetro de entrada REQ ("execute") devuelve el estado lógico "TRUE".
Si ha finalizado con éxito el procesamiento de SET_TIMEZONE ("modeDONE" es "TRUE"), el
parámetro de entrada REQ ("execute") se restablece automáticamente al valor "FALSE". Para
ello se consulta si "statusTime" tiene el valor "16#7002". Tras el restablecimiento se emite el
valor de estado "16#7000".

2264

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Para saber si el reloj de la CPU ha adoptado correctamente los nuevos datos que deben
ajustarse ("timezone"), existen varias opciones:
● Desde el display de una CPU S7-1500: Para ello, navegue por el display de la CPU hasta
"Ajustes > Fecha y hora > Horario de verano".
● Desde el TIA Portal: Utilice la instrucción "RD_LOC_T (Página 2251)" para leer la hora local
del reloj de la CPU.
● Desde el TIA Portal: Utilice la instrucción "RD_SYS_T (Página 2249)" para leer la hora del
módulo del reloj de la CPU.
Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

SNC_RTCB: Sincronizar relojes esclavos
Definición: Sincronización de relojes esclavos
La sincronización de relojes esclavos consiste en la transmisión de la fecha y la hora del reloj
maestro de un segmento de bus a todos los relojes esclavos de ese segmento de bus.

Programación del PLC
Manual de programación y manejo, 11/2019

2265

Instrucciones
4.1 Instrucciones

Descripción
La instrucción sincroniza todos los relojes esclavos existentes a nivel local ya sea en la CPU
o en un segmento de bus, independientemente del intervalo de sincronización parametrizado
(la interfaz externa de un CP o CM pertenece a otro segmento de bus). Para una correcta
sincronización es imprescindible que "SNC_RTCB" " se llame en una CPU cuyo reloj de tiempo
real haya sido parametrizado como reloj maestro para al menos un segmento de bus.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SNC_RTCB":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RET_VAL

Output

INT

I, Q, M, D, L

Si se produce un error durante la ejecu‐
ción de la instrucción, el valor de respues‐
ta contendrá un código de error.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Explicación
(W#16#...)
0000

No se ha producido ningún error durante la sincronización.

0001

El reloj presente no ha sido parametrizado como reloj maestro para ningún segmento de bus.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

TIME_TCK: Leer hora del sistema
Descripción
Con la instrucción "TIME_TCK" se lee la hora del sistema de la CPU. La hora del sistema es
un contador de tiempo que contabiliza desde 0 a un máximo de 2147483647 ms. En caso de
desbordamiento de la hora del sistema, se reinicia el recuento desde "0". El incremento de
tiempo y la exactitud de la hora del sistema es de 1 ms. El único factor que influye en la hora
del sistema son los estados operativos de la CPU. La hora del sistema se puede usar, por
ejemplo, para medir la duración de procesos obteniendo la diferencia entre los resultados de
dos llamadas de "TIME_TCK". Esta instrucción no ofrece información de error.

2266

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente resume los cambios que experimenta la hora del sistema en función de los
estados operativos de la CPU.
Estado operativo

La hora del sistema ...

Arranque

... se actualiza de modo permanente.

RUN
STOP

... se detiene y mantiene el valor actual.

Rearranque completo (en caliente)

... se borra y vuelve a empezar desde "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "TIME_TCK":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RET_VAL

Return

TIME

I, Q, M, D, L

El parámetro RET_VAL contiene la
hora del sistema leída, en el rango de
0 a 231 -1 ms.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el siguiente ejemplo se lee la hora del sistema de la CPU. El valor de retorno se indica en
el tipo de datos TIME.
Para almacenar los datos se crea una variable en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

La hora del sistema de la CPU se lee y se indica en el parámetro de salida RET_VAL
("outputCPUtimer").

Programación del PLC
Manual de programación y manejo, 11/2019

2267

Instrucciones
4.1 Instrucciones

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

RTM: Contador de horas de funcionamiento
Descripción
La instrucción permite inicializar, arrancar, parar y leer un contador de horas de
funcionamiento de 32 bits de la CPU.
Tenga en cuenta que el contador de horas de funcionamiento también se puede detener o
reiniciar durante la ejecución del programa de usuario, por lo que los valores guardados
pueden verse alterados.

2268

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RTM":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

NR

Input

RTM

I, Q, M, D, L o cons‐
tante

La numeración empieza por 0.

Número del contador de horas de funcionamiento
Para conocer el número de contadores de horas
de funcionamiento de su CPU, consulte los datos
técnicos.

MODE

Input

BYTE

I, Q, M, D, L o cons‐
tante

ID de la petición:
● 0: Leer (tras ello, el estado se registra en CQ
y el valor actual en CV). Si el contador de
horas de funcionamiento cuenta durante más
de (2 elevado a 31) - 1 horas, se detiene en el
último valor representable y devuelve el
mensaje de error "Desbordamiento".
● 1: Arrancar (con el último valor registrado)
● 2: Parar
● 4: Inicializar al valor especificado en el
parámetro PV
● 5: Inicializar al valor especificado en el
parámetro PV y arrancar
● 6: Inicializar al valor especificado en el
parámetro PV y parar

PV

Input

DINT

I, Q, M, D, L o cons‐
tante

Nuevo valor para el contador de horas de funcio‐
namiento

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución de la
instrucción, el valor de respuesta contendrá un
código de error.

CQ

Output

BOOL

I, Q, M, D, L

Estado del contador de horas de funcionamiento
(1: en marcha)

CV

Output

DINT

I, Q, M, D, L

Valor actual del contador de horas de funciona‐
miento

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error

Explicación

(W#16#...)
0000

Ningún error

8080

Número erróneo del contador de horas de funcionamiento

8081

Se ha transmitido un valor negativo al parámetro PV.

8082

Desbordamiento del contador de horas de funcionamiento

Programación del PLC
Manual de programación y manejo, 11/2019

2269

Instrucciones
4.1 Instrucciones
Código de error

Explicación

(W#16#...)
8091

El parámetro de entrada MODE contiene un valor no permitido.

Información de
error general

Consulte también: Evaluación de errores mediante GET_ERR_ID (Página 1982)

Ejemplo
En el siguiente ejemplo se ajusta el contador de horas de servicio de la CPU y se lee el valor
al cabo de una hora.
Para almacenar los datos se crean seis variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo. Introduzca el número
del contador de horas de servicio de la CPU en el parámetro de entrada NR.

Si el contacto NA ("execute") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"RTM". El contador de horas de servicio de la CPU se ajusta al valor deseado
("in_processValue") y se inicia. Una vez iniciado el contador de horas de servicio, ajuste el
valor del parámetro de entrada MODE ("comandMODE") a "0". (Para ello, haga clic en el
parámetro y seleccione "Forzar operando > Poner a 0".) De este modo, la instrucción "RTM"
se limitará a leer el valor actual ("currentValue") del contador de horas de servicio, sin
modificarlo. Cuando empieza a contar el contador de horas de servicio, el parámetro de salida
CQ ("statusRTM") indica que este se encuentra en marcha (el valor es "TRUE"). En el
parámetro de salida RET_VAL ("returnValue") se indica que la ejecución se ha realizado sin
errores.

2270

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Al cabo de una hora, el parámetro de salida CV ("currentValue") indica el valor "6".

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

4.1.4.3

String + Char

S_MOVE: Desplazar cadena de caracteres
Descripción
Esta instrucción permite escribir el contenido de una cadena de caracteres (W)STRING del
parámetro IN en el área de datos especificada en el parámetro OUT.
Para copiar variables del tipo de datos ARRAY utilice las instrucciones "MOVE_BLK" y
"UMOVE_BLK".

Programación del PLC
Manual de programación y manejo, 11/2019

2271

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "S_MOVE":
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

STRING,
WSTRING

D, L o constante

Cadena de caracteres de origen

OUT

Output

STRING,
WSTRING

D, L

Cadena de caracteres de destino

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el siguiente ejemplo se copia el contenido de una cadena de caracteres desde el parámetro
de entrada IN a otra cadena de caracteres especificada en el parámetro OUT. El tipo de datos
utilizado es STRING.
Para almacenar los datos se crean dos variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

El resultado de la cadena de caracteres copiada ("stringValueIN") se devuelve en el parámetro
de salida OUT ("stringValueOUT").

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

2272

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

S_COMP: Comparar cadenas de caracteres
Descripción
Esta instrucción compara los contenidos de dos variables en el formato (W)STRING y
devuelve el resultado de la comparación como valor de retorno. Las variables que se deben
comparar se interconectan en las entradas IN1 y IN2 . Asigne a los parámetros de entrada
únicamente variables definidas como simbólicas.
Seleccione la condición de comparación mediante el cuadro de instrucción. Si se cumple la
condición de comparación (p. ej. mayor o igual), el estado lógico del parámetro de salida OUT
se pone a "1".
Utilice una de las siguientes condiciones de comparación:
Símbolo

Descripción

EQ

Si la cadena de caracteres del parámetro IN1 es igual a la del parámetro IN2 , el valor de
retorno tiene el estado lógico "1".

NE

Si la cadena de caracteres del parámetro IN1 es distinta a la del parámetro IN2 , el valor de
retorno tiene el estado lógico "1".

GT (1)

Si la cadena de caracteres del parámetro IN1 es mayor que la del parámetro IN2 , el valor
de retorno tiene el estado lógico "1".

LT (1)

Si la cadena de caracteres del parámetro IN1 es menor que la del parámetro IN2 , el valor
de retorno tiene el estado lógico "1".

GE (1)

Si la cadena de caracteres del parámetro IN1 es mayor o igual a la del parámetro IN2 , el
valor de retorno tiene el estado lógico "1".

LE (1)

Si la cadena de caracteres del parámetro IN1 es menor o igual a la del parámetro IN2 , el
valor de retorno tiene el estado lógico "1".

Los caracteres se comparan empezando por la izquierda según su codificación ASCII (p. ej. 'a' es
mayor que 'A'). El primer carácter diferente es el decisivo para el resultado de la comparación. Si la
parte izquierda de la cadena de caracteres más larga es idéntica a la cadena de caracteres más corta,
la más larga se considera la mayor de ellas.
(1)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "S_COMP":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

STRING,
WSTRING*

D, L o constante

Variable de entrada en el for‐
mato STRING / WSTRING

IN2

Input

STRING,
WSTRING*

D, L o constante

Variable de entrada en el for‐
mato STRING / WSTRING

OUT

Output

BOOL

I, Q, M, D, L

Resultado de la comparación

* Defina la longitud máxima de la cadena de caracteres si en la declaración de la interfaz se utiliza el
tipo de datos STRING / WSTRING para una variable temporal (encontrará más información en la
descripción del tipo de datos).

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2273

Instrucciones
4.1 Instrucciones

Ejemplo
En el siguiente ejemplo se comparan dos cadenas de caracteres del tipo de datos STRING
utilizando la opción de comparación "Igual".
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo. Seleccione el tipo de
datos STRING y la opción de comparación EQ.

Puesto que el valor de la primera cadena de caracteres que debe compararse ("stringvalue1")
es igual a la segunda cadena de caracteres ("stringvalue2"), el resultado de la comparación
("svalue1EQsvalue2") indica el estado lógico "TRUE".

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

2274

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

S_CONV: Convertir cadena de caracteres
Descripción
Esta instrucción permite convertir el valor de la entrada IN al formato de datos indicado en la
salida OUT. El formato de salida de la conversión se determina seleccionando un tipo de datos
para el parámetro de salida OUT.
Son posibles las conversiones siguientes:
● Conversión de una cadena de caracteres
● Conversión de un valor numérico o de un carácter en una cadena de caracteres
● Conversión de un carácter en un carácter
Nota
Conversiones explícitas
Encontrará más información sobre las conversiones explícitas aquí:
● CPU S7-1200: Conversiones explícitas (Página 529)
● CPU S7-1500: Conversiones explícitas (Página 422)

Conversión de una cadena de caracteres
● En un valor numérico (entero o número en coma flotante):
La conversión se ejecuta para todos los caracteres de la cadena de caracteres indicada en
el parámetro de entrada IN. Los caracteres permitidos son las cifras de "0" a "9", el punto
decimal, así como los signos más (+) y menos (–). El primer carácter de la cadena puede
ser una cifra válida o un signo. Se ignoran los espacios iniciales y las representaciones
exponenciales.
● En un carácter:
Al convertir una cadena de caracteres en un carácter, el primer carácter de la cadena de
caracteres se transfiere al parámetro OUT.
● En una cadena de caracteres

Conversión de un valor numérico o de un carácter en una cadena de caracteres
● El formato del valor numérico que se debe convertir se determina seleccionando un tipo de
datos para la entrada IN. Especifique en la salida OUT una variable válida del tipo de datos
(W)STRING. La longitud de la cadena de caracteres tras la conversión depende del valor
de la entrada IN.
● El resultado de la conversión se guarda a partir del tercer byte de la cadena de caracteres.
En el primer byte de la cadena de caracteres se registra la longitud máxima, y en el
segundo, la longitud real de la cadena. Los valores numéricos positivos se emiten sin signo.
● Si el valor numérico 0, que está presente como tipo de datos INT o UINT, se convierte en
una cadena de caracteres (p. ej. INT_TO_STRING(0)), la cadena tendrá al final una
longitud de 6 caracteres.

Programación del PLC
Manual de programación y manejo, 11/2019

2275

Instrucciones
4.1 Instrucciones
● En caso de convertir un valor numérico en una cadena de caracteres, los primeros
caracteres de la cadena se rellenan con espacios. El número de espacios varía en función
de la longitud del valor numérico.
Nota
Información específica de SCL
En caso de convertir un valor numérico en una cadena de caracteres, no se rellenan con
espacios los primeros caracteres de la cadena.
Si desea que se rellenen con espacios los primeros caracteres de la cadena, utilice la
instrucción "VAL_STRG".
● Al convertir un carácter (W)CHAR, el carácter se escribe en la primera posición de la
cadena de caracteres.
Nota
Notación exponencial en la conversión de números en coma flotante
No utilice notación exponencial ("e" o "E") en la conversión de números en coma flotante con
la instrucción "S_CONV". Para la conversión de números en coma flotante con notación
exponencial, utilice en su lugar la instrucción "STRG_VAL". Seleccione el formato de entrada
de la notación exponencial con el parámetro FORMAT de la instrucción.

Parámetros
Las tablas siguientes muestran los parámetros de la instrucción "S_CONV" correspondientes
a las posibles conversiones:
Tabla 4-11

Parámetros cuando se convierte una cadena de caracteres en un valor numérico:

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

STRING,
WSTRING

D, L o constante

Valor que se va a convertir

OUT

Output

CHAR, WCHAR,
USINT, UINT,
UDINT, ULINT,
SINT, INT, DINT,
LINT, REAL,
LREAL

I, Q, M, D, L

Resultado de la conversión

Tabla 4-12

Parámetros para la conversión de una cadena de caracteres en una cadena de caracteres:

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

STRING,
WSTRING

D, L o constante

Valor que se va a convertir

OUT

Output

STRING,
WSTRING

D, L

Resultado de la conversión (conversio‐
nes posibles: STRING a WSTRING y a
la inversa)

2276

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-13

Parámetros cuando se convierte un valor numérico o un carácter en una cadena de caracteres:

Parámetro

Declaración

Tipo de datos

Área de memoria

IN

Input

CHAR, WCHAR,
USINT, UINT,
UDINT, ULINT,
SINT, INT, DINT,
LINT, REAL,
LREAL

I, Q, M, D, L o constan‐ Valor que se va a convertir
te

OUT

Output

STRING,
WSTRING

D, L

Tabla 4-14

Descripción

Resultado de la conversión

Parámetros para la conversión de un carácter en un carácter:

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

CHAR, WCHAR

I, Q, M, D, L o constan‐ Valor que se va a convertir
te

OUT

Output

CHAR, WCHAR

I, Q, M, D, L

Resultado de la conversión (conversio‐
nes posibles: CHAR a WCHAR y a la
inversa)

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el ejemplo siguiente se convierte un número del tipo de datos INT en una cadena de
caracteres del tipo de datos STRING.
Para almacenar los datos se crean dos variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo. Seleccione los tipos de
datos. En la primera selección posible, especifique el tipo de datos del valor que desea
convertir ("inputValueNBR"). En la segunda selección, especifique el tipo de datos de la
cadena de caracteres que desea crear ("resultSTRING").

Programación del PLC
Manual de programación y manejo, 11/2019

2277

Instrucciones
4.1 Instrucciones

El valor que debe convertirse ("inputValueNBR") se convierte al formato de salida. En las
posiciones vacías al principio de la cadena de caracteres se escriben espacios en blanco. El
resultado de la conversión se deposita como cadena de caracteres en el parámetro de salida
OUT ("resultSTRING").

Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615)

Consulte también
STRG_VAL: Convertir cadena de caracteres en valor numérico (Página 2278)

STRG_VAL: Convertir cadena de caracteres en valor numérico
Descripción
La instrucción "STRG_VAL" convierte una cadena de caracteres numéricos en un entero o un
número en coma flotante:
● La cadena de caracteres que se va a convertir se especifica en el parámetro de entrada IN.
● El formato del valor de salida se determina seleccionando un tipo de datos para el
parámetro de salida OUT.
Los caracteres permitidos para la conversión son las cifras de "0" a "9", el punto decimal, la
coma decimal, las notaciones "E" y "e", así como los signos más (+) y menos (–). La conversión
finaliza cuando se encuentra un carácter no válido.

2278

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "STRG_VAL":
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memoria

Descripción

IN

Input

STRING,
WSTRING

STRING,
WSTRING

D, L o constante

Cadena de caracteres numé‐
ricos que se va a convertir

FORMAT

Input

WORD

WORD

I, Q, M, D, L, P o
constante

Formato de entrada de los
caracteres

P

Input

UINT

UINT

I, Q, M, D, L, P o
constante

Remite al primer carácter
que debe convertirse (primer
carácter = 1, el valor "0" o un
valor > longitud del string no
es válido)

OUT

Output

USINT, SINT,
UINT, INT,
UDINT, DINT,
REAL, LREAL

USINT, SINT,
UINT, INT,
UDINT, DINT,
ULINT, LINT,
REAL, LREAL

I, Q, M, D, L, P

Resultado de la conversión

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro FORMAT
Con el parámetro FORMAT se especifica cómo deben interpretarse los caracteres de una
cadena de caracteres. Con la instrucción "STRG_VAL" se convierten y representan valores
exponenciales.
La tabla siguiente muestra los valores posibles del parámetro FORMAT y su significado:
Valor

Notación

Representación decimal

Fracción decimal

"."

(W#16#....)
0000
0001
0002

","
Exponencial

0003
0004 hasta FFFF

"."
","

Valores no válidos

Parámetro P
La conversión comienza a partir del carácter cuya posición se ha especificado en el parámetro
P. Si, por ejemplo, se ha especificado el valor "1" en el parámetro P, la conversión comenzará
a partir del primer carácter de la cadena de caracteres indicada.

Programación del PLC
Manual de programación y manejo, 11/2019

2279

Instrucciones
4.1 Instrucciones

Ejemplo
La tabla siguiente muestra ejemplos de conversión de una cadena de caracteres en un valor
numérico:
IN (STRING)

FORMAT
(W#16#....)

OUT (Tipo de datos)

OUT (Valor)

Estado ENO

'123'

0000

INT/DINT

123

1

'-00456'

0000

INT/DINT

-456

1

'123.45'

0000

INT/DINT

123

1

'+2345'

0000

INT/DINT

2345

1

'00123AB'

0000

INT/DINT

123

1

'123'

0000

REAL

123.0

1

'-00456'

0001

REAL

-456.0

1

'+00456'

0001

REAL

456.0

1

'123.45'

0000

REAL

123.45

1

'123.45'

0001

REAL

12345.0

1

'123,45'

0000

REAL

12345.0

1

'123,45'

0001

REAL

123.45

1

'.00123AB'

0001

REAL

123.0

1

'1.23e-4'

0000

REAL

1.23

1

'1.23E-4'

0000

REAL

1.23

1

'1.23E-4'

0002

REAL

1.23E-4

1

'12,345.67'

0000

REAL

12345.67

1

'12,345.67'

0001

REAL

12.345

1

'3.4e39'

0002

REAL

W#16#7F800000

0

'-3.4e39'

0002

REAL

W#16#FF800000

0

'1.1754943e-38'

0002

REAL

0.0

1

'12345'

-/-

SINT

0

0

'A123'

-/-

-/-

0

0

''

-/-

-/-

0

0

'++123'

-/-

-/-

0

0

'+-123'

-/-

-/-

0

0

Ejemplo
En el siguiente ejemplo se convierte una cadena de caracteres numéricos del tipo de datos
STRING en un número en coma flotante del tipo de datos REAL. Debido al tipo de datos REAL,
el resultado tendrá una longitud de 32 bits y podrá tener signo.
Para almacenar los datos es preciso crear cuatro variables en un bloque de datos global.

2280

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Los parámetros de la instrucción se interconectan del siguiente modo. En la selección
izquierda, seleccione el tipo de datos para la cadena de caracteres. En la selección derecha,
seleccione el tipo de datos para el número en coma flotante.

De acuerdo con el valor "1" del parámetro P ("pointerSTRG"), la cadena de caracteres
numérica se convierte a partir del primer carácter. Debido al valor "0001" del parámetro
FORMAT ("resultSformat"), el punto de la cadena de caracteres numérica se interpreta como
separador de miles. (El separador de decimales para el valor "0001" es la coma.) El valor que
debe convertirse ("inputSTRING") se emite en el parámetro de salida OUT ("outputVAL") como
número en coma flotante.

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)
Programación del PLC
Manual de programación y manejo, 11/2019

2281

Instrucciones
4.1 Instrucciones

VAL_STRG: Convertir valor numérico en cadena de caracteres
Descripción
La instrucción "VAL_STRG" convierte un valor numérico en una cadena de caracteres.
● El valor que se va a convertir se especifica en el parámetro de entrada IN. El formato del
valor numérico se determina seleccionando un tipo de datos.
● El resultado de la conversión se consulta en el parámetro de salida OUT.
Los caracteres permitidos para la conversión son las cifras de "0" a "9", el punto decimal, la
coma decimal, las notaciones "E" y "e", así como los signos más (+) y menos (–). La conversión
se interrumpe si se detectan caracteres no válidos.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "VAL_STRG":
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memoria

Descripción

IN

Input

USINT, SINT,
UINT, INT,
UDINT, DINT,
REAL, LREAL

USINT, SINT,
UINT, INT,
UDINT, DINT,
ULINT, LINT,
REAL, LREAL

I, Q, M, D, L, P o
constante

Valor que se va a convertir

SIZE

Input

USINT

USINT

I, Q, M, D, L, P o
constante

Número de posiciones de ca‐
rácter

PREC

Input

USINT

USINT

I, Q, M, D, L, P o
constante

Número de decimales

FORMAT

Input

WORD

WORD

I, Q, M, D, L, P o
constante

Formato de salida de los ca‐
racteres

P

InOut

UINT

UINT

I, Q, M, D, L, P o
constante

Carácter a partir del cual se
escribe el resultado.

OUT

Output

STRING,
WSTRING

STRING,
WSTRING

D, L

Resultado de la conversión

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro P
El parámetro P especifica a partir de qué carácter de la cadena de caracteres se escribe el
resultado. Si, por ejemplo, se ha especificado el valor "2" en el parámetro P, el valor convertido
se guardará a partir del segundo carácter de la cadena de caracteres.

2282

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros SIZE y P
El parámetro SIZEdetermina en cuántos caracteres de la cadena de caracteres se debe
escribir. A este efecto, se cuenta a partir del carácter especificado en el parámetro P. Si el valor
emitido es más corto que la longitud especificada, el resultado se escribe justificado a la
derecha en la cadena de caracteres. Las posiciones de carácter vacías se rellenan con
espacios.

Parámetro FORMAT
Con el parámetro FORMATse especifica cómo debe interpretarse el valor numérico durante la
conversión y escribirse en la cadena de caracteres. En el parámetro FORMATsolo pueden
especificarse variables del tipo de datos USINT.
La tabla siguiente muestra los valores posibles del parámetro FORMATy su significado:
Valor

Notación

Signo

Representación decimal

Fracción decimal

"-"

"."

(W#16#....)
0000
0001
0002

","
Exponencial

"."

0003
0004

","
Fracción decimal

"+" y "-"

0005
0006

","
Exponencial

0007
0008 a FFFF

"."
"."
","

Valores no válidos

Nota
Relevancia de los valores 2, 3, 6 y 7 del parámetro FORMAT
Los valores 2, 3, 6 y 7 del parámetro FORMAT solo son relevantes si el parámetro IN es del tipo
de datos REAL o LREAL.

Parámetro PREC
Con el parámetro PRECse define el número de decimales al convertir números en coma
flotante. Como máximo se admite una precisión de 7 cifras para valores numéricos del tipo de
datos REAL. Si el valor que se va a convertir es un entero, es necesario definir con el parámetro
PRECla posición en la que debe colocarse un punto decimal.

Programación del PLC
Manual de programación y manejo, 11/2019

2283

Instrucciones
4.1 Instrucciones

Ejemplo
La tabla siguiente muestra ejemplos de conversión de valores numéricos en una cadena de
caracteres cuando el parámetro OUT contiene un string vacío antes de la llamada de
VAL_STRG.
IN(Valor)

IN (Tipo de da‐
tos)

P

SIZE

FORMAT (W#16#....)

PREC

OUT (STRING)

Estado ENO

123

UINT

16

10

0000

0

xxxxxxx123 C

1

0

UINT

16

10

0000

2

xxxxxx0.00 C

1

12345678

UDINT

16

10

0000

3

x12345.678 C

1

12345678

UDINT

16

10

0001

3

x12345.678 C

1

123

INT

16

10

0004

0

xxxxxx+123 C

1

-123

INT

16

10

0004

0

xxxxxx-123 C

1

-0.00123

REAL

16

10

0004

4

xxx-0.0012 C

1

-0.00123

REAL

16

10

0006

4

-1.2300E-3 C

1

-Inf 1)

REAL

16

10

-/-

4

xxxxxx-INF C

0

+Inf 2)

REAL

16

10

-/-

4

xxxxxx+INF C

0

NaN 3)

REAL

16

10

-/-

4

xxxxxxxNaN C

0

12345678

UDINT

16

6

-/-

3

xxxxxxxxxx C

0

"x" representa espacios
1)
-Inf: número en coma flotante que representa un valor infinito negativo.
2)
+Inf: número en coma flotante que representa un valor infinito positivo.
3)
NaN: Valor devuelto como resultado de operaciones aritméticas no válidas.

Ejemplo
A continuación encontrará tres ejemplos de conversión de valores numéricos en una cadena
de caracteres cuando el parámetro OUT contiene un string no vacío antes de la llamada de
VAL_STRG.

2284

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En todos los casos, los parámetros IN, SIZE, PREC, FORMAT y P tienen los mismos valores:
IN=123, SIZE=16, PREC=0, FORMAT=4, P=10. Solo es diferente el ajuste predeterminado de
OUT.
● OUT contiene una cadena de caracteres más corta que P.
La CPU rellena OUT con espacios tras el string existente, concretamente hasta la posición
(P-1). A partir de la posición P, OUT se escribe teniendo en cuenta los espacios a la
izquierda.
OUT antes de la llamada de VAL_STRG:

ABCDEFxxxxxxxxxx xxxxxxxxxxxxxxxx

OUT después de la llamada de VAL_STRG:

ABCDEFxxxxxxxxxx xxxxxx123xxxxxxx

"x" representa un espacio

● OUT contiene una cadena de caracteres más larga que P+SIZE.
La CPU rellena OUT con caracteres SIZE a partir de la posición P teniendo en cuenta los
espacios a la izquierda.
OUT antes de la llamada de VAL_STRG:

ABCDEFGHIJKLMNOP QRSTUVWXYZABCDEF

OUT después de la llamada de VAL_STRG:

ABCDEFGHIxxxxxxx xxxxxx123ZABCDEF

"x" representa un espacio

● OUT contiene una cadena de caracteres más larga que P pero más corta que P+SIZE.
La CPU rellena OUT con caracteres SIZE a partir de la posición P teniendo en cuenta los
espacios a la izquierda.
OUT antes de la llamada de VAL_STRG:

ABCDEFGHIJKLMNOP xxxxxxxxxxxxxxxx

OUT después de la llamada de VAL_STRG:

ABCDEFGHIxxxxxxx xxxxxx123xxxxxxx

"x" representa un espacio

Ejemplo
En el siguiente ejemplo se convierte un número en coma flotante del tipo de datos REAL en una
cadena de caracteres del tipo de datos STRING.
Para almacenar los datos se crean seis variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo. Seleccione los tipos de
datos:
● La selección izquierda representa el valor que se desea convertir.
● La selección derecha representa la cadena de caracteres que se generará.

Programación del PLC
Manual de programación y manejo, 11/2019

2285

Instrucciones
4.1 Instrucciones

De acuerdo con el valor "16" del parámetro P ("pointer2STRG"), la cadena de caracteres se
escribirá a partir del carácter n.º 16. A partir de este punto, la cadena tendrá 10 caracteres, de
acuerdo con el valor "10" del parámetro SIZE ("sizeSTRG"). Debido al valor "0004" del
parámetro FORMAT ("resultV2Sformat"), el punto del valor que se convertirá ("inputVAL") se
interpreta como separador de decimales. De acuerdo con el valor "3" del parámetro PREC
("precVAL"), en la cadena de caracteres se escribirán tres decimales. El signo del valor que se
convertirá se incorpora en la cadena como carácter y se coloca delante de las cifras. Delante
del signo se escriben como espacios los caracteres restantes de los 10 que tiene la cadena.
La cadena de caracteres se emite en el parámetro de salida OUT ("outputSTRING").

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

2286

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Strg_TO_Chars: Convertir cadena de caracteres en Array of CHAR
Descripción
Con la instrucción "Strg_TO_Chars" se copia una cadena de caracteres del tipo de datos
STRING en un Array of CHAR o Array of BYTE o una cadena de caracteres del tipo de datos
WSTRING en un Array of WCHAR o Array of WORD. Para el proceso de copia solo son válidos
caracteres ASCII.
● La cadena de caracteres se especifica en el parámetro de entrada STRG.
● Los caracteres se escriben en el parámetro CHARS en un tipo de datos Array of CHAR /
BYTE / WCHAR / WORD .
– El número de caracteres en el campo de destino tiene que ser por lo menos igual al
número de caracteres que se copian de la cadena de caracteres de origen.
– Si el campo de destino contiene menos caracteres que la cadena de origen, los
caracteres se escriben hasta alcanzar la longitud máxima del campo de destino.
– El hecho de que la cadena de caracteres contenga un carácter "$00" o W#16#0000, no
afecta al proceso de copia (véase el gráfico).
– El número de caracteres copiados se visualiza en el parámetro CNT.
● Mediante el parámetro PCHARS se indica a partir de qué posición se escribe en el campo
de destino.
– Ejemplo: Si la escritura debe empezar a partir de la tercera posición, utilice el valor "2"
en el parámetro PCHARS:

675,1*>@

%\WH

%\WH

%\WH

%\WH

%\WH

%\WH

%\WH

%\WH

7

(

6

7



$

%

&

7

(

6

7



$

&KDU>@

&KDU>@

&KDU>@

&KDU>@

&KDU>@

&KDU>@

3&+$56 

$UUD\>@RI&+$5
&KDU>@

&KDU>@

– La opción predeterminada para PCHARS es "0". Si PCHARS = 0, se usa el límite inferior
del índice del array (p. ej. CHAR[0] con un Array [0..5] of CHAR). Esto es válido también
cuando el límite inferior del array es negativo (p. ej. CHAR[-5] con un Array [-5..5] of
CHAR).
Nota
Uso de la instrucción con S7-1200 V2.0
El S7-1200 hasta la versión 2.0 solo soporta Array [0 .. n] of CHAR / BYTE. Los límites de índice
negativos (p. ej. Array [-3..2] of CHAR) no son admisibles. El software no comprueba esta
restricción.

Programación del PLC
Manual de programación y manejo, 11/2019

2287

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Strg_TO_Chars":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

STRG

Input

STRING,
WSTRING

D, L o constante

Origen del proceso de copia

PCHARS

Input

DINT

I, Q, M, D, L, P o cons‐
tante

Posición en la estructura
Array of (W)CHAR / BYTE / WORD a par‐
tir de la cual se escriben los caracteres de
la cadena.

CHARS

InOut

VARIANT

D, L

Destino del proceso de copia
Copie los caracteres en una estructura
del tipo de datos Array of (W)CHAR /
BYTE / WORD.

CNT

Output

UINT

I, Q, M, D, L, P

Número de caracteres copiados.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el ejemplo siguiente se copian caracteres de una cadena del tipo de datos STRING en una
estructura del tipo de datos Array of CHAR.
Para almacenar los datos es preciso crear cuatro variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo y se selecciona el tipo de
datos de la cadena de caracteres.

2288

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Debido al tipo de datos Array of CHAR, se crea una estructura formada por caracteres
individuales. La estructura CHARS ("myarrayCHARS") tendrá diez caracteres (Array ... [0..9]).
De acuerdo con el valor "2" del parámetro PCHARS ("pointerCHARS"), se escribe a partir del
tercer carácter de la estructura ("0" y "1" quedan vacíos, y "2" contiene el primer carácter de la
cadena ("inputSTRG")). Una vez que se han escrito los caracteres de la cadena ("inputSTRG")
en la estructura ("myarrayCHARS"), el último carácter que debe crearse en la estructura queda
vacío. El número de caracteres copiados de la cadena se emite en el parámetro de salida CNT
("countCHARS").

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

Programación del PLC
Manual de programación y manejo, 11/2019

2289

Instrucciones
4.1 Instrucciones

Chars_TO_Strg: Convertir Array of CHAR en cadena de caracteres
Descripción
Con la instrucción "Chars_TO_Strg" se copian caracteres de un Array of CHAR o Array of
BYTE en una cadena de caracteres del tipo de datos STRING o bien de un ARRAY of WCHAR
o Array of WORD en una cadena de caracteres del tipo de datos WSTRING. Para la copia solo
son válidos los caracteres ASCII.
● Los caracteres del Array of (W)CHAR / BYTE / WORD que han de copiarse en una cadena
de caracteres se introducen en el parámetro de entrada CHARS.
● Los caracteres se escriben en el parámetro STRG en un tipo de datos (W)STRING.
– El número de caracteres de la cadena es por lo menos igual al número de caracteres que
se deben copiar del campo de origen.
– Si la cadena tiene menos caracteres que el campo de origen, los caracteres se escriben
hasta alcanzar la longitud máxima de la cadena de caracteres.
– Si el Array of CHAR / BYTE contiene un carácter "$00" o el Array of WCHAR / WORD
un carácter W#16#0000, la copia solo se ejecutará hasta la posición correspondiente
(ver el gráfico).
● Con el parámetro PCHARS se indica a partir de qué posición del campo de origen deben
copiarse los caracteres. PCHARS = 0 es el valor estándar y siempre indica el límite inferior
del índice del array, aunque sea negativo.
– Ejemplo: Si la copia debe empezar en el tercer carácter del campo de origen, utilice el
valor "2" en el parámetro PCHARS:

$UUD\>@RI&+$5

&KDU>@

&KDU>@

&KDU>@

&KDU>@

&KDU>@

&KDU>@

7

(

6

7



$

%\WH

%\WH

%\WH

%\WH

S&KDUV 
675,1*>@

6

7

%\WH

%\WH

– Si en el parámetro PCHARS se indica un índice que no está contenido en el origen de
la copia (p. ej. "7" con Array [0..5] of CHAR), la instrucción no se ejecuta.
Nota
Uso de la instrucción con S7-1200 V2.0
El S7-1200 hasta la versión 2.0 solo soporta Array [0 .. n] of CHAR / BYTE. Los límites de índice
negativos (p. ej. Array [-3..2] of CHAR) no son admisibles. El software no comprueba esta
restricción.

2290

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Chars_TO_Strg":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

CHARS

Input

VARIANT

D, L

Origen del proceso de copia
Array of (W)CHAR / BYTE / WORD del que
se copian los caracteres.

PCHARS

Input

DINT

I, Q, M, D, L, P o cons‐
tante

Posición en el Array of (W)CHAR / BYTE /
WORD a partir de la cual se copian los ca‐
racteres.

CNT

Input

UINT

I, Q, M, D, L, P o cons‐
tante

Número de caracteres que se van a copiar.
Con "0" se copian todos los caracteres.

STRG

Output

STRING,
WSTRING

D, L

Destino del proceso de copia
Cadena de caracteres del tipo de datos
(W)STRING. Respete la longitud máxima de
los tipos de datos:
● STRING: 254 caracteres
● WSTRING: 254 caracteres (estándar)/
16382 caracteres (máximo)
Si utiliza WSTRING, tenga en cuenta que
las longitudes > 254 caracteres deben defi‐
nirse explícitamente entre corchetes (p. ej.
WSTRING[16382]).

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el ejemplo siguiente se copian caracteres de una estructura del tipo de datos Array of CHAR
en una cadena de caracteres del tipo de datos STRING.
Para almacenar los datos es preciso crear cuatro variables en un bloque de datos global.

Programación del PLC
Manual de programación y manejo, 11/2019

2291

Instrucciones
4.1 Instrucciones
Los parámetros de la instrucción se interconectan del siguiente modo y se selecciona el tipo de
datos de la cadena de caracteres.

La estructura CHARS ("inputArrayCHARS") tendrá diez caracteres (Array ... [0..9]). De
acuerdo con el valor "2" del parámetro PCHARS ("pointerCHARS") se copia en la cadena de
caracteres a partir de la tercera posición de la estructura ("outputSTRG"). A partir de la posición
"2", todos los caracteres de la estructura ("inputArrayCHARS") se copiarán en la cadena
("outputSTRG"), ya que el parámetro CNT ("countCHARS") tiene el valor "0".

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

2292

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

MAX_LEN: Determinar la longitud máxima de una cadena de caracteres
Descripción
Una variable del tipo de datos (W)STRING contiene dos longitudes: la longitud máxima y la
longitud actual (es decir, el número de caracteres válidos actualmente).
● La longitud máxima de la cadena de caracteres de cada variable se especifica entre
corchetes en la palabra clave STRING. El número de bytes ocupados por una cadena de
caracteres excede en 2 la longitud máxima.
● La longitud máxima de la cadena de caracteres de cada variable se especifica entre
corchetes en la palabra clave WSTRING. El número de palabras ocupadas por una cadena
de caracteres excede en 2 la longitud máxima.
● La longitud actual representa el número de posiciones de carácter realmente ocupadas. La
longitud actual es menor o igual que la longitud máxima.
Con la instrucción "MAX_LEN" se determina la longitud máxima de la cadena de caracteres
especificada en el parámetro de entrada IN. Esta se devuelve como valor numérico en el
parámetro de salida OUT.
Nota
Comprobación de la cadena de caracteres
La instrucción "MAX_LEN" no comprueba la cadena de caracteres del parámetro "IN".
Si ocurren errores durante la ejecución de la instrucción, en el parámetro OUT se devuelve el
valor "0".
Nota
Leer la longitud actual
Con la instrucción "LEN (Página 2332)" se lee la longitud actual de una cadena de caracteres.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "MAX_LEN":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

● STRING

D, L o constante

Cadena de caracteres

I, Q, M, D, L, P

Número máximo de caracteres

● WSTRING
OUT

Return

● INT
● DINT

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2293

Instrucciones
4.1 Instrucciones

Ejemplo
En el ejemplo siguiente se calcula la longitud máxima de una cadena de caracteres del tipo de
datos STRING.
Para almacenar los datos se crean dos variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

La longitud máxima de la cadena de caracteres indicada ("inputSTRING") se calcula y se emite
en el parámetro de salida OUT ("stringMLengthOUT") como valor numérico.

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

JOIN: Concatenar varias cadenas de caracteres
JOIN: Unir varias cadenas de caracteres
Descripción
La instrucción "JOIN" une varias cadenas de caracteres y crea un array.

2294

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para convertir varias cadenas de caracteres en una sola cadena, la instrucción ofrece las
funciones siguientes:
● Selección de formato
Con el primer bit del parámetro Mode se indica si la yuxtaposición de las cadenas de
caracteres fuente debe convertirse en un array en formato CSV o FSR.
En el ejemplo siguiente hay dos cadenas de caracteres fuente procedentes de las dos
columnas de la tabla. El número máximo de caracteres para la primera cadena fuente es de
4, para la segunda 13, para la tercera 10 y para la cuarta 14 caracteres.
1963

1974

Miller

Jackson

John

Peter

Roadname

VeryLongRoadna

– Con CSV (Comma Separated Values), las cadenas de caracteres fuente se escriben en
el array de destino una tras otra y separadas por un separador. (Encontrará ejemplos
más adelante.)
– Con FSR (Fixed Size Records) se define en el array de destino un número determinado
de caracteres para cada cadena fuente. Si los caracteres de una cadena fuente no
ocupan el espacio reservado en el array de destino, los elementos de campo
correspondientes se rellenan con separadores. Sin embargo, si el número de caracteres
de una cadena fuente es mayor que el espacio reservado, los elementos de campo
correspondientes se rellenan empezando por delante y los caracteres sobrantes de la
cadena fuente se cortan (encontrará un ejemplo más adelante).
● Selección de separadores de las cadenas de caracteres fuente
Con el parámetro RecSeparator se selecciona el separador que se utilizará para cada uno
de los strings. La elección del carácter separador debería depender del contenido de las
cadenas de caracteres de entrada en el parámetro SrcStruct. Si las cadenas de caracteres
de entrada contienen una coma dentro de un string, por ejemplo, no utilice la coma como
separador. El tipo de datos que se utilice para el separador deberá corresponderse con el
del array de destino en el parámetro DstArray. De este modo, los separadores también
podrán escribirse en el array de destino.
● Selección de separadores para el final de todas las cadenas de caracteres fuente
Con el tercer bit del parámetro Mode se selecciona si en el array de destino (parámetro
DstArray) debe escribirse un carácter adicional como separador al final de la cadena
copiada. En el parámetro EndSeparator puede indicar el carácter que se utilizará como
separador. Asegúrese de usar otro carácter del indicado en el parámetro RecSeparator
(separador de cadenas de caracteres individuales). De lo contrario, en caso de una
reconversión realizada con la instrucción "SPLIT", obtendrá resultados indeseados si los
dos separadores no pueden discernirse.
● Selección de las cadenas de caracteres fuente
Las cadenas de caracteres fuente se indican en el parámetro SrcStruct. Como tipo de datos
se puede utilizar Array of STRING o Array of WSTRING o cualquier estructura que
contenga exclusivamente el tipo de datos STRING o WSTRING. Esto también es válido
para tipos de datos de usuario o estructuras anidadas. Mientras contengan exclusivamente
el tipo de datos STRING o WSTRING, pueden utilizarse.

Programación del PLC
Manual de programación y manejo, 11/2019

2295

Instrucciones
4.1 Instrucciones
● Se indica el número de cadenas de caracteres unidas
Si en el parámetro SrcStruct (cadenas de caracteres fzente) se utiliza un Array of STRING
o Array of WSTRING (y no estructuras anidadas), mediante el parámetro Count se puede
indicar el número de cadenas de caracteres fuente que se han unido para formar una
cadena larga. Si en el parámetro SrcStruct se utiliza un tipo de datos distinto a Array of
(W)STRING, se ignora el parámetro Count. De este modo solo se puede unir una parte
grande de un array.
● Selección del área de destino para escribir el array
En el parámetro DstArray se utiliza el tipo de datos Array of (W)CHAR. En este caso no es
posible utilizar los tipos de datos STRING o WSTRING, pues en el caso de STRING la
longitud estaría limitada a 254 caracteres o 256 bytes.
● Índice de la posición en el array (parámetro de destino DestArray)
La conversión comienza en esta posición. La instrucción indica mediante el parámetro
Position en qué posición finalizó la conversión. Esto permite realizar llamadas consecutivas
de la instrucción para rellenar el array.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "JOIN":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

Mode

Input

DWORD

I, Q, M, D, L o
constante

Especifica cómo se realiza la fusión en una cade‐
na de caracteres (véase "Parámetro Mode").

RecSeparator

Input

VARIANT

I, Q, M, D, L

Separadores de las cadenas de caracteres fuente
● Con CSV: carácter que se utiliza como
separador de los distintos strings.
● Con FSR: carácter que se utiliza como
carácter de relleno de los distintos strings.

EndSeparator

Input

VARIANT

I, Q, M, D, L

Separador para el final de la conversión
Separador que se escribe al final de los caracteres
en caso de que para el parámetro Mode se haya
puesto el bit 3 = 1.

SrcStruct

Input

VARIANT

I, Q, M, D, L

Puntero a las cadenas de caracteres fuente.

Count

Input

UDINT

I, Q, M, D, L o
constante

Número de cadenas de caracteres que se han fu‐
sionado.
El parámetro Count puede utilizarse únicamente si
en el parámetro SrcStruct se ha utilizado un Array
of (W)STRING.

DestArray

InOut

VARIANT

I, Q, M, D, L

Área en la que se escriben los caracteres después
de la conversión.
Utilice en el parámetro DestArray el tipo de datos
Array [0 .. x] of CHAR/WCHAR. La longitud (x) del
array se selecciona en el parámetro SrcStruct se‐
gún la longitud de las cadenas de caracteres fuen‐
te.

Position

InOut

UDINT

I, Q, M, D, L

Índice de la posición en la cadena de caracteres
total

Ret_Val

Return

INT

I, Q, M, D, L

Estado de la instrucción (véase la tabla "Paráme‐
tros RET_VAL")

2296

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro Mode
Bit

Valor de bit "0"

Valor de bit "1"

Descripción

0

Formato CSV (Com‐
ma Separated Va‐
lues)

Formato FSR (Fixed
Size Record)

Selección del formato:
● Con CSV, las cadenas de caracteres fuente se separan con un
separador en el array de destino.
● Con FSR se escriben en el array de destino las cadenas de
caracteres fuente con los caracteres de relleno definidos en el
parámetro RecSeparator.

1

-

-

No relevante para la instrucción "JOIN".

2

-

-

Reservado (valor de bit irrelevante)

3

No escribir ningún se‐ Al final de los caracte‐ Se selecciona si en el array (parámetro DestArray) debe escribirse un
parador adicional.
res leídos escribir el
carácter adicional como separador al final de los caracteres.
carácter que se defi‐
nió mediante el pará‐
metro EndSeparator.

4

-

-

No relevante para la instrucción "JOIN".

Parámetro RET_VAL
Código de
error*

Explicación

(W#16#...)
0000

Ningún error.

8190

No está soportada la selección en el parámetro Mode.

8x20

Cadenas de caracteres fuente no válidas.

8x53

VARIANT señala a una estructura de datos demasiado corta.

8x54

Tipo de datos no válido

8082

El valor del parámetro Count es superior al número de cadenas de caracteres fuente especificado en
SrcStruct.

8xB4

Tipos de datos diferentes en los parámetros SrcStruct (fuente) y DestArray (destino) o en los separadores
(parámetros RecSeparator y EndSeparator).

80B5

Desbordamiento del búfer en la instrucción. En el parámetro DestArray, los caracteres se emiten de ma‐
nera incompleta, o el valor del parámetro Position está fuera de DestArray.

Programación del PLC
Manual de programación y manejo, 11/2019

2297

Instrucciones
4.1 Instrucciones
Código de
error*

Explicación

(W#16#...)
Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Observe lo siguiente respecto a los códigos de error:
● Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".
● La "x" en la segunda posición de los códigos de error listados indica el parámetro que ha causado el error.
Ejemplo: código de error 8352 hex = error ocurrido en el tercer parámetro (EndSeparator), consulte la tabla de parámetros.
● Si el error no se atribuye a un parámetro en particular, se devuelve un "0".
Ejemplo: Para el separador (parámetro RecSeparator) se utiliza el tipo de datos CHAR. Para el array del parámetro
DestArray se utiliza el tipo de datos WCHAR. En este caso se devuelve el código de error 80B4.

Dos ejemplos de la instrucción JOIN cuando el ARRAY de destino debe tener el formato CSV
● Primer ejemplo
Se tienen las siguientes cadenas de caracteres fuente:
– 1963
– Miller
– John
– Roadname
Si se selecciona "," como separador, la llamada de JOIN proporciona el array de destino
siguiente:
1963,Miller,John,Roadname
● Segundo ejemplo
Se tienen las siguientes cadenas de caracteres fuente:
– 1974
– Jackson
– Peter
– VeryLongRoadname
Si se selecciona "," como separador, la llamada de JOIN proporciona el array de destino
siguiente:
1974,Jackson,Peter,VeryLongRoadname

2298

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Dos ejemplos de la instrucción JOIN cuando el ARRAY de destino debe tener el formato FSR
● Primer ejemplo
Se tienen las siguientes cadenas de caracteres fuente:
– 1963
– Miller
– John
– Roadname
El número de caracteres reservados en el array de destino es de 4 para la primera cadena
fuente, 13 para la segunda, 10 para la tercera y 14 para la cuarta.
Si se selecciona "," como carácter de relleno, la llamada de JOIN proporciona el array de
destino siguiente:
1963Miller,,,,,,,John,,,,,,Roadname,,,,,,
● Segundo ejemplo
Se tienen las siguientes cadenas de caracteres fuente:
– 1974
– Jackson
– Peter
– VeryLongRoadname
El número de caracteres reservados en el array de destino es de 4 para la primera cadena
fuente, 13 para la segunda, 10 para la tercera y 14 para la cuarta.
Si se selecciona "," como carácter de relleno, la llamada de JOIN proporciona el array de
destino siguiente:
1974Jackson,,,,,,Peter,,,,,VeryLongRoadna

Ejemplo de programa
Encontrará el ejemplo aquí: Ejemplo de programa de JOIN (Página 2299).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Ejemplo de programa de JOIN
En el siguiente ejemplo se concatenan tres cadenas de caracteres de un Array of STRING para
formar una secuencia de caracteres de un Array of CHAR.

Programación del PLC
Manual de programación y manejo, 11/2019

2299

Instrucciones
4.1 Instrucciones

Almacenamiento de datos
Para almacenar los datos deben crearse las variables siguientes en un bloque de datos global.

FC "SLI_FC_encodeMode_JOIN": Interconectar parámetros
Para agrupar el valor del parámetro MODE de la instrucción "JOIN", se crea la FC
"SLI_FC_encodeMode_JOIN". En la FC se crean las siguientes variables locales:

Segmento 1: Para seleccionar el formato se crean las interconexiones siguientes.

Segmento 2: para utilizar el separador al final de la conversión se crean las interconexiones
siguientes.

2300

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

FC "SLI_FC_calculateLength_JOIN": Interconectar parámetros
Para calcular la longitud de caracteres en formato FSR o CSF se crea la FC
"SLI_FC_calculateLength_JOIN". En la FC se crean las siguientes variables locales:

Segmento 1: Para contar los elementos del array y calcular el límite del array se crean las
interconexiones siguientes.
Parte 1:

Parte 2:

Programación del PLC
Manual de programación y manejo, 11/2019

2301

Instrucciones
4.1 Instrucciones

Segmento 2: Partiendo del formato FSR se consulta el valor de posición ("positionInDest")
mediante el parámetro de entrada POSITION.

Segmento 3: Para calcular la longitud de caracteres en formato FSR se crean las
interconexiones siguientes.

Segmento 4: Partiendo del formato CSV se lee el contenido del Array of STRING y se consulta
el valor de posición ("positionInDest") mediante el parámetro de entrada POSITION.

Segmento 5: Partiendo del formato CSV se lee la longitud de caracteres de todas las cadenas
de caracteres.

2302

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 6: Partiendo del formato CSV se incrementa un contador y se llama el Array of
STRING varias veces.

Segmento 7: Partiendo del formato CSV se calcula la longitud de caracteres necesaria de toda
la secuencia de caracteres y del límite de array necesario.

Segmento 8: Partiendo del formato CSV se calcula la posición en la que la instrucción "JOIN"
debe detener su ejecución.

Programación del PLC
Manual de programación y manejo, 11/2019

2303

Instrucciones
4.1 Instrucciones

FB "SLI_FB_JOIN": Interconectar parámetros
La instrucción "JOIN" se llama en un FB. En el FB se crean las siguientes variables locales:

Segmento 1: Las FC "SLI_FC_encodeMode_JOIN" y "SLI_FC_calculateLength_JOIN" se
interconectan del siguiente modo.

Segmento 2: La instrucción "JOIN" se interconecta del siguiente modo.

2304

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Segmento 3: La variable "execute" se desactiva del siguiente modo.

FB "SLI_FB_JOIN": Resultado del segmento 1
En base a los parámetros de entrada FORMAT ("mode.format") y WRITEENDSEPARATOR
("mode.writeEndSeparator"), la FC "SLI_FC_encodeMode_JOIN" recibe el modo que debe
utilizar la instrucción "JOIN" para convertir las cadenas de caracteres. Por consiguiente, la
conversión debe realizarse en formato CSV ("format" es FALSE) y al final de la cadena de
caracteres debe escribirse un carácter ("writeEndSeparator" es TRUE). El modo que debe
utilizarse se emite en el parámetro de salida MODE ("#statMode") de la FC
"SLI_FC_encodeMode_JOIN".
En base a los parámetros de entrada SOURCEARRAY ("sourceArray"),
ONESTRINGOFARRAY ("sourceStruct[0]") y MODE ("#statMode"), la FC
"SLI_FC_calculateLength_JOIN" calcula la longitud de caracteres ("#joinLength") para
convertir las cadenas de caracteres en función del modo. La FC
"SLI_FC_calculateLength_JOIN" calcula que toda la secuencia de caracteres tiene 18
caracteres.
La posición para detener la ejecución de la instrucción "JOIN" se emite en el parámetro de
salida FINALPOSITION ("#finalPosition") de la FC "SLI_FC_calculateLength_JOIN".

Programación del PLC
Manual de programación y manejo, 11/2019

2305

Instrucciones
4.1 Instrucciones

FB "SLI_FB_JOIN": Resultado del segmento 2
Si el contacto NA ("execute") y el comparador devuelven el estado lógico "TRUE"
("positionInDest" tiene un valor menor o igual a "760"), se ejecuta la instrucción "JOIN".
La variable "#finalPosition" muestra un nuevo valor tras la primera ejecución de la instrucción
"JOIN". Dicho valor se basa en el valor de posición actual ("postionInDest") y en la longitud de
toda la secuencia de caracteres ("#joinLength").
En el parámetro de salida RET_VAL ("returnValue") de la instrucción "JOIN" se indica que la
ejecución del ejemplo se ha realizado sin errores. Puesto que la ejecución de la instrucción
"JOIN" queda limitada por la variable "execute" y un comparador ("#finalPosition"), tampoco se
desborda el búfer.
Partiendo del formato CSV, el resultado es el siguiente:

2306

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

FB "SLI_FB_JOIN": Resultado del segmento 3
Si el valor de la variable "positionInDest" es igual al valor de la variable "#finalPosition", la
variable "execute" se desactivará. Con ello, la ejecución de la instrucción "JOIN" finalizará en
cuanto toda la secuencia de caracteres se haya convertido con la longitud determinada y se
haya emitido.

Conversiones alternativas
La conversión del Array of STRING citado también puede realizarse de otro modo.
Conversión según el formato CSV / variante 2:
Requisitos:
● Las variables "format" y "writeEndSeparator" tienen el valor "FALSE".
● Para toda la secuencia de caracteres se determina una longitud de 17 caracteres.
● Sin embargo, la variable para limitar la llamada de la instrucción "JOIN" ("#finalPosition")
tiene el valor "18" y el parámetro POSITION ("postionInDest") tiene el valor "0".
En consecuencia, toda la secuencia de caracteres de emite dos veces consecutivas.
Nota
Con el valor "18" de la variable "#finalPosition", la instrucción "JOIN" intenta llenar un
Array[0..17] of CHAR. Ahora bien, como toda la secuencia de caracteres ya ha llenado la zona
de destino (0..16 del Array of CHAR) y no debe ponerse ningún separador al final, JOIN
empieza a transmitir toda la secuencia de caracteres por segunda vez.

Programación del PLC
Manual de programación y manejo, 11/2019

2307

Instrucciones
4.1 Instrucciones
Conversión según el formato FSR:
Requisitos:
● Las variables "format" y "writeEndSeparator" tienen el valor "TRUE".
● En base al tipo de datos (STRING) se ha determinado previamente la longitud máxima (10
caracteres) de una cadena de caracteres.
Los puntos no utilizados de cada cadena de caracteres se llenan con separadores en toda la
secuencia de caracteres. Seguidamente, se transmite al Array of CHAR toda la secuencia de
caracteres, incluidos los separadores al final.

Código del programa
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

2308

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

SPLIT: Separar matriz de caracteres en varias cadenas de caracteres
SPLIT: Dividir un array de caracteres en varias cadenas de caracteres
Descripción
La instrucción "SPLIT" convierte un array (Array of CHAR / WCHAR) en varias cadenas de
caracteres separadas (Array of STRING / WSTRING o estructura).
Para la conversión del array en varias cadenas de caracteres introduzca la información
siguiente:
● Selección del array que se va a leer
El array que se va a leer se especifica en el parámetro SrcArray. En los parámetros
siguientes, asegúrese de que coincidan los tipos de datos utilizados para los parámetros de
entrada y salida. Si en el parámetro SrcArray se utiliza por ejemplo un array del tipo CHAR,
tanto los separadores (Rec-/EndSeparator) como la estructura del parámetro DestStruct
deberán contener únicamente cadenas del tipo STRING.
● Selección de formato para el array fuente
Con el primer bit del parámetro Mode se indica si el array que se va a leer tiene el formato
CSV o FSR.
– Con CSV (Comma Separated Values), los caracteres relacionados del array de origen
se separan del siguiente carácter relacionado por medio de un separador.
Dos ejemplos de arrays fuente:
1963,Miller,John,CitynameA,Roadname
1974,Jackson,Peter,CitynameB,VeryLongRoadname
– Con FSR (Fixed Size Records) se define un número determinado de caracteres para
cada información lógica del array fuente. Cada información debe caber en el espacio
definido para ella. Si una información no ocupa el espacio definido, se rellena con
separadores.
Dos ejemplos de arrays fuente, siendo la longitud de la información de 4 caracteres para
la primera información (año de nacimiento), de 13 para la segunda (apellido), de 10 para
la tercera (nombre), de 9 para la cuarta (población) y de 16 para la quinta (calle):
1963Miller,,,,,,,John,,,,,,CitynameARoadname,,,,,,,,
1974Jackson,,,,,,Peter,,,,,CitynameBVeryLongRoadname
● Separador utilizado para el array que se va a leer
– Si el array que se va a leer tiene el formato CSV, indique en el parámetro RecSeparator
qué separador se ha utilizado.
– Si el array que se va a leer tiene el formato FSR, indique en el parámetro RecSeparator
qué carácter de relleno se ha utilizado.

Programación del PLC
Manual de programación y manejo, 11/2019

2309

Instrucciones
4.1 Instrucciones
● Separador utilizado para el final de la cadena de caracteres total
En el parámetro EndSeparator se especifica el separador a partir del cual se deja de leer
el array. La instrucción "SPLIT" termina en esta posición y emite las cadenas de caracteres
encontradas. Tenga en cuenta que el separador EndSeparator se evalúa con preferencia
con respecto al separador RecSeparator. Si el separador del parámetro EndSeparator se
utiliza en una cadena de caracteres que se va a leer (entre dos separadores RecSeparator),
dejarán de emitirse los contenidos que se encuentren a partir del separador EndSeparator.
Por eso se recomienda encarecidamente seleccionar para el carácter separador
EndSeparator un carácter diferente al carácter separador RecSeparator en el array leído.
● Indicación de la posición a partir de la cual se lee el array
La conversión comienza en esta posición del array y la instrucción indica mediante el
parámetro Position en qué posición finalizó la conversión. Esto permite realizar llamadas
consecutivas de la instrucción para rellenar distintas cadenas de caracteres en el
parámetro DestStruct.
● Se indica el número de cadenas de caracteres leídas
Si en el parámetro DestStruct se utiliza un Array of STRING, puede indicarse el número de
cadenas de caracteres leídas a través del parámetro Count. Solo se cuentan las cadenas
de caracteres con contenido. Si en el parámetro DestStruct se utiliza un tipo de datos
distinto a Array of STRING, en el parámetro Count se indica "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SPLIT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

Mode

Input

DWord

I, Q, M, D, L o constante Especifica cómo se realiza la segmentación
en varias cadenas de caracteres (véase
"Parámetro Mode").

RecSeparator

Input

Variant

I, Q, M, D, L

Carácter separador o de relleno
● Con CSV: carácter que se ha utilizado
en el array que se va a leer para
identificar cada una de las cadenas de
caracteres.
● Con FSR: carácter que se ha utilizado
como relleno en el array que se va a leer.

EndSeparator

Input

Variant

I, Q, M, D, L

Separador mediante el cual se ha definido el
final de la cadena de caracteres total en el
array que se va a leer.

SrcArray

Input

Variant

I, Q, M, D, L

Puntero al array que se va a leer (Array of
CHAR/WCHAR)

DestStruct

InOut

Variant

I, Q, M, D, L

Estructura que contiene las cadenas de ca‐
racteres convertidas (Array of STRING /
WSTRING).

Position

InOut

UDInt

I, Q, M, D, L

Posición a partir de la cual se lee el array en
el parámetro SrcArray.

2310

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

Ret_Val

Return

Int

I, Q, M, D, L

Resultado de la ejecución de la instrucción /
código de error (consulte la tabla "Paráme‐
tro Ret_Val")

Count

Output

UDInt

I, Q, M, D, L

Número de cadenas de caracteres que se
han encontrado.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro "Mode"
Bit

Valor de bit "0"

Valor de bit "1"

Descripción

0

Formato CSV (Com‐
ma Separated Va‐
lues)

Formato FSR (Fixed
Size Record)

Modo básico: Elección entre CSV o FSR

1

● Con CSV: los
caracteres
adicionales
provocan un
error.

● Con CSV: Los
caracteres
adicionales se
ignoran.

Con el bit 1 se elige cómo proceder con los caracteres adicionales:

● Con FSR: Los
caracteres de
relleno
adicionales
permanecen en
la cadena.

● Con CSV:
–

Si el bit está activado, se ignoran los caracteres adicionales
que no caben en la cadena de caracteres.
Ejemplo: la instrucción escribe en una cadena de caracteres
de longitud 16 (tipo de datos STRING[16]). La fuente no
contiene ningún separador después de los primeros 16
caracteres. Si está activado el bit 1, los caracteres sobrantes
se ignoran y la instrucción continúa leyendo el array.

–

Si el bit no está activado, la instrucción se cancela y emite un
mensaje de error en el parámetro Ret_Val.

● Con FSR: Los
caracteres de
relleno
adicionales se
eliminan.

● Con FSR:
–

Si está activado este bit, al transferir el array fuente a las
cadenas de caracteres de destino, los caracteres de relleno
situados a la derecha de caracteres con información no se
escribirán en la cadena de caracteres de destino (ver
ejemplo).

–

Si este bit está desactivado, al transferir el array fuente a las
cadenas de caracteres de destino, los caracteres de relleno
situados a la derecha de caracteres con información se
escribirán en la cadena de caracteres de destino (ver ejemplo).

2

-

-

Reservado para el uso en versiones futuras.

3

EndSeparator no se
cuenta.

EndSeparator se
cuenta.

Elección de si EndSeparator debe contarse también en el parámetro
Position.

4

Conservar la longitud
de las cadenas de ca‐
racteres no escritas
(STRING).

Cambiar a "0" la longi‐ Elección de si las cadenas no utilizadas (STRING) deben cambiar a
tud de las cadenas de longitud "0" en el parámetro DestStruct.
caracteres no escritas
(STRING).

Programación del PLC
Manual de programación y manejo, 11/2019

2311

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
Código de
error*

Explicación

(W#16#...)
0000

Ningún error.

0001

Los caracteres adicionales se ignoran.

0002

Solo en CSV:
● En el array que se leerá (definido por SrcArray) no se ha encontrado ningún separador EndSeparator .
La conversión se ha interrumpido por otro motivo, p. ej. porque DestStruct está completamente lleno.
● RecSeparator y EndSeparator son idénticos.

8190

No está soportada la selección en el parámetro Mode.

8x20

Cadenas de caracteres fuente no válidas.

8x53

VARIANT señala a una estructura de datos demasiado corta.

8x54

Tipo de datos no válido

8882

Position no se encuentra en el rango permitido

8x84

Se han encontrado caracteres adicionales.

8xB4

Tipos de datos diferentes en los parámetros SrcArray (fuente) y DestStruct (destino) o en los separadores
(parámetros RecSeparator y EndSeparator).

80B5

El array SrcArray que se leerá es demasiado pequeño.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Observe lo siguiente respecto a los códigos de error:
● Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".
● La "x" en la segunda posición de los códigos de error listados indica el parámetro que ha causado el error.
Ejemplo: código de error 8352 hex = error ocurrido en el tercer parámetro (EndSeparator), consulte la tabla de parámetros.
● Si el error no se atribuye a un parámetro en particular, se devuelve un "0".
Ejemplo: Para el separador (parámetro RecSeparator) se utiliza el tipo de datos CHAR. Para el array del parámetro
DestArray se utiliza el tipo de datos WCHAR. En este caso se devuelve el código de error 80B4.

Dos ejemplos de la instrucción SPLIT cuando el ARRAY que se leerá tiene el formato CSV
En el primer paso, el array fuente se desintegra en cadenas de caracteres tal como prescriben
los separadores (parámetro RecSeparator, p. ej. ",").
En el segundo paso, las cadenas de caracteres surgidas de la desintegración se guardan en
cadenas de caracteres de destino. Su longitud se especifica con el parámetro DestStruct.
Si en las cadenas de caracteres surgidas de la desintegración hay más caracteres de los que
caben en las cadenas, el comportamiento de SPLIT depende del parámetro Mode. Si
Mode=2#00 se produce un error: se emite el código de error correspondiente y no se llenan
más cadenas de caracteres de destino. Si Mode=2#10 se ignoran los caracteres sobrantes y

2312

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
la próxima cadena de caracteres de destino se rellena con los caracteres posteriores al
siguiente separador.
● Primer ejemplo
En este ejemplo hay estos dos arrays fuente:
– 1963,Miller,John,Roadname
– 1974,Jackson,Peter,VeryLongRoadname
La longitud de las cadenas de caracteres de destino es de 4 caracteres para la primera
cadena de destino, 13 para la segunda, 10 para la tercera y 14 caracteres para la cuarta.
La primera llamada de SPLIT proporciona las siguientes cadenas de caracteres de destino
siendo Mode=2#10:
– 1963
– Miller
– John
– Roadname
La segunda llamada de SPLIT proporciona las siguientes cadenas de caracteres de destino
siendo Mode=2#10:
– 1974
– Jackson
– Peter
– VeryLongRoadna
● Segundo ejemplo
En este ejemplo, la información lógica de los arrays fuente no está en el orden previsto. Hay
estos dos arrays fuente:
– 1963,Miller,Roadname,John
– 1974,Jackson,VeryLongRoadname,Peter
La longitud de las cadenas de caracteres de destino es, como en el primer ejemplo, de 4
caracteres para la primera cadena de destino, 13 para la segunda, 10 para la tercera y 14
para la cuarta.
La primera llamada de SPLIT proporciona las siguientes cadenas de caracteres de destino
siendo Mode=2#10:
– 1963
– Miller
– Roadname
– John
La segunda llamada de SPLIT proporciona las siguientes cadenas de caracteres de destino
siendo Mode=2#10:
– 1974
– Jackson
– VeryLongRo

Programación del PLC
Manual de programación y manejo, 11/2019

2313

Instrucciones
4.1 Instrucciones
– Peter

Dos ejemplos de la instrucción SPLIT cuando el ARRAY que se leerá tiene el formato FSR
El array fuente se desintegra en cadenas de caracteres tal como se ha especificado en el
parámetro DestStruct para la longitud de las cadenas de caracteres de destino.

2314

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En cuanto a los caracteres de relleno (parámetro RecSeparator, p. ej. ","), el comportamiento
de SPLIT depende del parámetro Mode: si Mode=2#01, los caracteres de relleno se incorporan
a las cadenas de caracteres de destino; si Mode=2#11, no se incorporan.
● Primer ejemplo
En este ejemplo hay estos dos arrays fuente:
– 1963Miller,,,,,,,John,,,,,,Roadname,,,,,,
– 1974Jackson,,,,,,Peter,,,,,VeryLongRoadname
La longitud de las cadenas de caracteres de destino es de 4 caracteres para la primera
cadena de destino, 13 para la segunda, 10 para la tercera y 14 caracteres para la cuarta.
La primera llamada de SPLIT proporciona las siguientes cadenas de caracteres de destino
siendo Mode=2#01:
– 1963
– Miller,,,,,,,
– John,,,,,,
– Roadname,,,,,,
La segunda llamada de SPLIT proporciona las siguientes cadenas de caracteres de destino
siendo Mode=2#01:
– 1974
– Jackson,,,,,,
– Peter,,,,,
– VeryLongRoadna
● Segundo ejemplo
En este ejemplo, la información lógica de los arrays fuente no está en el orden previsto. Hay
estos dos arrays fuente:
– 1963Miller,,,,,,,Roadname,,,,,,John,,,,,,
– 1974Jackson,,,,,,VeryLongRoadnamePeter,,,,,
La longitud de las cadenas de caracteres de destino es, como en el primer ejemplo, de 4
caracteres para la primera cadena de destino, 13 para la segunda, 10 para la tercera y 14
para la cuarta.
La primera llamada de SPLIT proporciona las siguientes cadenas de caracteres de destino
siendo Mode=2#11:
– 1963
– Miller
– Roadname
– ,,,,John
Explicación: la instrucción SPLIT crea en cierto modo plantillas por medio del array fuente
y su longitud está especificada por la longitud de las cadenas de caracteres de destino.
Durante la transferencia a las cadenas de caracteres de destino solo se valoran como
caracteres de relleno las comas que están a la derecha de caracteres con información. Si
Mode=2#11, los caracteres de relleno no se incorporan. En la primera llamada, las comas
a la derecha de "John" son caracteres de relleno. En cambio, las comas a la izquierda de

Programación del PLC
Manual de programación y manejo, 11/2019

2315

Instrucciones
4.1 Instrucciones
"John" no son caracteres de relleno, porque antes de llegar al final de la cadena de destino
correspondiente los caracteres relevantes todavía siguen a "John". Por este motivo, las
comas a la izquierda de "John" aparecen en la cadena de caracteres de destino.
La segunda llamada de SPLIT proporciona las siguientes cadenas de caracteres de destino
siendo Mode=2#11:
– 1974
– Jackson
– VeryLongRo
– adnamePeter

Ejemplo de programa
Encontrará el ejemplo aquí: Ejemplo de programa de SPLIT (Página 2316).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
JOIN: Unir varias cadenas de caracteres (Página 2294)

Ejemplo de programa de SPLIT
En el siguiente ejemplo se convierte la secuencia de caracteres de un Array of CHAR en tres
cadenas de caracteres separadas de un Array of STRING.
Nota
Ejemplo más complejo
Si desea poder llamar el área fuente varias veces, utilice la versión modificada de este ejemplo
("SPLIT multiple calls") de la Sample Library for Instructions (Página 615).
La FC "SLI_FC_calculateLength_SPLIT" de la versión modificada de este ejemplo tiene en
cuenta la posición inicial ("positionInSource") y calcula además un nuevo punto de parada
("#finalPosition") para la ejecución de SPLIT.
Asimismo, la versión modificada del ejemplo permite convertir varias secuencias de caracteres
(partiendo de un solo Array of CHAR) en varias cadenas de caracteres separadas (de un Array
of STRING).

2316

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Almacenamiento de datos
Para almacenar los datos deben crearse las variables siguientes en un bloque de datos global.

Nota
Los datos fuente deben concordar con el formato seleccionado para la conversión.
Fuente para el formato CSV:

Fuente para el formato FSR:

Programación del PLC
Manual de programación y manejo, 11/2019

2317

Instrucciones
4.1 Instrucciones

FC "SLI_FC_encodeMode_SPLIT": Interconectar parámetros
Para agrupar el valor del parámetro MODE de la instrucción "SPLIT", se crea la FC
"SLI_FC_encodeMode_SPLIT". En la FC se crean las siguientes variables locales:

Segmento 1: Para seleccionar el formato se crean las interconexiones siguientes.

2318

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 2: La forma en que debe procederse con caracteres adicionales se especifica del
siguiente modo.

Segmento 3: Si debe contarse el separador al final de la cadena de caracteres se especifica
del siguiente modo.

Segmento 4: Para vaciar las celdas no utilizadas del área de destino se crean las
interconexiones siguientes.

FC "SLI_FC_calculateLength_SPLIT": Interconectar parámetros
Para leer la longitud de caracteres de la cadena de caracteres en el área fuente se crea la FC
"SLI_FC_calculateLength_SPLIT". En la FC se crean las siguientes variables locales:

Programación del PLC
Manual de programación y manejo, 11/2019

2319

Instrucciones
4.1 Instrucciones
Segmento 1: la cadena de caracteres se convierte al tipo de datos STRING del siguiente modo,
y también se eliminan los espacios.
Parte 1:

Parte 2:

Segmento 2: Para calcular la longitud de caracteres se crean las interconexiones siguientes.
Parte 1:

Parte 2:

2320

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

FB "SLI_FB_SPLIT": Interconectar parámetros
La instrucción "SPLIT" se llama en un FB. En el FB se crean las siguientes variables locales:

Segmento 1: Las FC "SLI_FC_encodeMode_SPLIT" y "SLI_FC_calculateLength_SPLIT" se
interconectan del siguiente modo.

Segmento 2: La instrucción "SPLIT" se interconecta del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2321

Instrucciones
4.1 Instrucciones

Segmento 3: La variable "execute" se desactiva del siguiente modo.

FB "SLI_FB_SPLIT": Resultado del segmento 1
En base a sus parámetros de entrada, la FC "SLI_FC_encodeMode_SPLIT" recibe el modo
que debe utilizar la instrucción "SPLIT" para la conversión. Por consiguiente, debe realizarse
una conversión de datos en formato CSV ("format" es FALSE). Los caracteres adicionales
deben ignorarse ("ignoreAdditionalChar" es TRUE), el separador al final de la secuencia de
caracteres también debe contarse ("countEndSeparator" es TRUE) y el espacio no utilizado en
el área de destino debe mantenerse invariable ("unusedStringsToZero" es FALSE). El modo
que debe utilizarse se emite en el parámetro de salida MODE ("#statMode").
En base a los parámetros de entrada SOURCEARRAY ("sourceArray") y MODE
("#statMode"), la FC "SLI_FC_calculateLength_SPLIT" calcula la longitud de caracteres
("#splitLength"). Por consiguiente, toda la secuencia de caracteres debe tener 18 caracteres.

2322

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

FB "SLI_FB_SPLIT": Resultado del segmento 2
Si el contacto NA ("execute") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"SPLIT".
Mediante los parámetros de entrada RECSEPARATOR ("recSeparator") y ENDSEPARATOR
("endSeparator") se transmiten a la instrucción "SPLIT" los separadores para las cadenas de
caracteres fuente y el separador para el fin de la conversión. En el ejemplo se utilizan como
separadores la coma y el punto y coma.
Mediante el parámetro de entrada SRCARRAY ("sourceArrayCSV") se transmite una
secuencia de caracteres de un Array of CHAR en formato CSV. Dicha secuencia de caracteres
se convierte en varias cadenas de caracteres y se emite en un Array of STRING en el
parámetro DSTSTRUCT ("destArray").
La lectura de los caracteres del Array of CHAR empieza en la primera celda, de acuerdo con
el valor "0" del parámetro POSITION ("positionInSource").
Nota
Posición inicial
Si desea utilizar una posición inicial distinta ("positionInSource"), en la FC
"SLI_FC_calculateLength_SPLIT" deberá modificarse el parámetro PCHARS de la instrucción
"CHARS_TO_Strg".
Alternativamente puede utilizar también el ejemplo "SPLIT multiple calls"
Al final de la conversión de la secuencia de caracteres se emite la posición ("positionInSource"
tiene el valor "18"), que señala a la próxima celda del Array of CHAR. En el parámetro de salida
COUNT ("countOutputStrings") se indica el número ("3") de cadenas de caracteres
encontradas.
Programación del PLC
Manual de programación y manejo, 11/2019

2323

Instrucciones
4.1 Instrucciones
En el parámetro de salida RET_VAL ("returnValue") se indica que la ejecución del ejemplo se
ha realizado sin errores. Puesto que la ejecución de la instrucción "SPLIT" está limitada por la
variable "execute", no se desborda el búfer.
El resultado en formato CSV es el siguiente:

FB "SLI_FB_SPLIT": Resultado del segmento 3
Si el valor de la variable "positionInSource" es igual al valor de la variable "#splitLength", la
variable "execute" se desactivará. Con ello, la ejecución de la instrucción "SPLIT" finalizará en
cuanto el Array of CHAR se haya leído hasta el punto determinado y la secuencia de caracteres
se haya convertido.

Conversiones alternativas
Conversión de los datos fuente en formato CSV / variante 2:
El resultado en formato CSV pero sin recuento del separador es el siguiente:

2324

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Conversión de los datos fuente en formato FSR:
Para convertir la secuencia de caracteres del área fuente "sourceArrayFSR" se utiliza el
formato FSR.
Requisitos:
● Los parámetros de entrada SRCARRAY (véase SPLIT) y SOURCEARRAY (véase la FC
"SLI_FC_calculateLength_SPLIT") están interconectados con la variable
"sourceArrayFSR".
● Las variables "format" y "countEndSeparator" tienen el valor "TRUE".
Objetivo: no deben insertarse caracteres adicionales en el área de destino
("ignoreAdditionalChar" tiene el valor "TRUE"). Sin embargo, en el ejemplo no se alcanza el
objetivo.
Partiendo del tipo de datos (STRING[12]) del área de destino ("destArray"), la instrucción
"SPLIT" calcula todas las cadenas de caracteres que deben emitirse como si tuvieran 12
caracteres. Puesto que las cadenas de caracteres que hay en el área fuente
("sourceArrayFSR"), incluidos los caracteres de relleno, solo tienen una longitud de 10
caracteres, se emiten por completo dos de las cadenas de caracteres (rellenadas hasta 12
caracteres). De este modo, solo se eliminan los caracteres de relleno en la tercera cadena de
caracteres, que al final solo tiene caracteres de relleno.
La celda no utilizada del array del área de destino ("destArray") se deja invariable
("unusedStringsToZero" es FALSE). En el parámetro de salida RET_VAL ("returnValue") de la
instrucción "SPLIT" se indica que los caracteres adicionales se ignorarán.

Programación del PLC
Manual de programación y manejo, 11/2019

2325

Instrucciones
4.1 Instrucciones

Código del programa
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

ATH: Convertir cadena de caracteres ASCII en número hexadecimal
Descripción
La instrucción "ATH" convierte la cadena de caracteres ASCII especificada en el parámetro de
entrada IN en un número hexadecimal. El resultado de la conversión se deposita en el
parámetro de salida OUT.
● Con el puntero en el parámetro IN (ASCII) se puede remitir a los siguientes tipos de datos:
STRING, WSTRING, CHAR, BYTE, Array of CHAR, Array of BYTE, WCHAR, Array of
WCHAR, Array of WORD.
● Con el puntero en el parámetro OUT (hexadecimal) se puede remitir a los siguientes tipos
de datos: Array of CHAR, Array of BYTE, Array of WORD, STRING, BYTE, CHAR, WORD,
INT, DWORD, DINT, SINT, USINT, UINT, UDINT. Solo en S7-1500: Array of WCHAR,
WSTRING, WCHAR, ULINT, LINT, LWORD
El número de caracteres ASCII que se deben convertir se define con el parámetro N. Como
máximo se pueden convertir 32.767 caracteres ASCII válidos. Solo pueden interpretarse los
números de "0" a "9", las letras mayúsculas de "A" a "F" y las letras minúsculas de "a" a "f".
Todos los demás caracteres se convierten en ceros.
Dado que un carácter ASCII requiere 8 bits y un número hexadecimal solo 4, la palabra de
salida es la mitad de larga que la palabra de entrada. Después de la conversión, los caracteres
ASCII se ordenan a la salida en el mismo orden en el que se han leído. Si se trata de un número
impar de caracteres ASCII, el número hexadecimal correspondiente al semibyte a la derecha
del último número hexadecimal convertido se rellena con ceros.

2326

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "ATH":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

IN

Input

VARIANT

D, L

Puntero a cadena de caracteres
ASCII

N

Input

INT

I, Q, M, D, L o cons‐ Número de caracteres ASCII que
tante
se deben convertir

RET_VAL

Return

WORD

I, Q, M, D, L

Estado de la instrucción

OUT

Output

VARIANT

I, Q, M, D, L

Número hexadecimal

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de
error

Descripción

(W#16#....)*
0000

Ningún error

0007

Carácter no válido. Solo pueden utilizarse los siguientes caracteres ASCII: Números
de "0" a "9", letras mayúsculas de "A" a "F", letras minúsculas de "a" a "f".

8182

El búfer de entrada es demasiado pequeño para los datos en el parámetro N.

8120

Formato no válido en el parámetro IN.

8151

Tipo de datos no soportado en el parámetro IN.

8482

El búfer de salida es demasiado pequeño para los datos en el parámetro N.

8420

Formato no válido en el parámetro OUT.

8451

Tipo de datos no soportado en el parámetro OUT.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o
hexadecimales. Encontrará más información sobre el cambio de los formatos de visualización en
"Consulte también".

Caracteres ASCII y valores hexadecimales
La tabla siguiente muestra los caracteres ASCII y los correspondientes valores hexadecimales:
Caracteres ASCII

Valor hexadecimal codificado en
ASCII

Número hexadecimal

"0"

30

0

"1"

31

1

"2"

32

2

"3"

33

3

"4"

34

4

"5"

35

5

"6"

36

6

"7"

37

7

Programación del PLC
Manual de programación y manejo, 11/2019

2327

Instrucciones
4.1 Instrucciones
Caracteres ASCII

Valor hexadecimal codificado en
ASCII

Número hexadecimal

"8"

38

8

"9"

39

9

"A"

41

A

"B"

42

B

"C"

43

C

"D"

44

D

"E"

45

E

"F"

46

F

Ejemplo
La tabla siguiente muestra ejemplos de conversión de cadenas de caracteres ASCII en un
número hexadecimal:
Tipo de datos de IN

IN

N

OUT

Estado ENO

STRING, WSTRING

'0a23'

4

● WORD#16#0A23

1

● UINT#10#2595
STRING, WSTRING

‘123aFx1a23’

10

● LWORD#16#123AF01A_23000000

0

● ULINT#10#1 313 626 236 378 939
392
STRING, WSTRING

‘a23’

3

WORD#16#A230

1

STRING, WSTRING

‘0a23’

4

● WORD#[16#0A23, 16#0000]

1

STRING, WSTRING

‘aFbE’

1

● BYTE#[16#0A, 16#23]
1

● CHAR#‘A’
● WCHAR#‘A’

STRING, WSTRING

‘0a23’

4

STRING, WSTRING

‘123aFC1a23’

10

● CHAR#[‘0’, ‘A’, ‘2’, ‘3’]

1

● WCHAR#[‘0’, ‘A’, ‘2’, ‘3’]
● STRING#‘123AFC1A23’

1

● WSTRING#‘123AFC1A23’
ArrayOfCHAR, Arra‐
yOfWCHAR

[‘a’, ‘B’, ‘E’, ‘3’]

4

WORD#16#ABE3

1

ArrayOfBYTE

[16#39, 16#32, 16#35]

3

WORD#16#9250

1

ArrayOfWORD

[16#1234, 16#0032,
16#0031, 16#0000]

3

WORD#16#0210

0

ArrayOfWORD

[16#0031, 16#0032,
16#0033, 16#0034]

4

WORD#16#1234

1

ArrayOfWORD

[16#AB31, 16#32AF,
16#4333, 16#0034]

4

WORD#16#0004

0

ArrayOfWORD

[16#0031, 16#0032,
16#0033, 16#0034]

4

[16#1234, 16#0000, 16#0000, 16#0000] 1

ArrayOfWORD

[16#0034, 16#0035,
16#0036, 16#0037,
16#0041, 16#0042,
16#0043, 16#0044]

8

DWORD#16#4567_ABCD

2328

1

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

HTA: Convertir número hexadecimal en cadena de caracteres ASCII
Descripción
La instrucción "HTA" convierte el número hexadecimal especificado en la entrada IN en una
cadena de caracteres ASCII. El resultado de la conversión se deposita en la dirección
especificada en el parámetro OUT.
● Con el puntero en el parámetro IN (hexadecimal) se puede remitir a los siguientes tipos de
datos: Array of CHAR, Array of BYTE, STRING, BYTE, CHAR, WORD, Array of WORD,
INT, DWORD, Array of DWORD, DINT, SINT, USINT, UINT, UDINT. Solo en el S7-1500:
Array of WCHAR, WSTRING, WCHAR, ULINT, LINT, LWORD, Array of LWORD
● Con el puntero del parámetro OUT (ASCII) se puede remitir a los siguientes tipos de datos:
STRING, WSTRING, Array of CHAR, Array of WCHAR, Array of BYTE, Array of WORD
El número de bytes hexadecimales que se deben convertir se define con el parámetro N. Dado
que un carácter ASCII requiere 8 bits y un número hexadecimal solo 4, el valor de salida es el
doble de largo que el valor de entrada. Cada semibyte del número hexadecimal se convierte
en un carácter manteniendo el orden original.
En la cadena de caracteres ASCII se escriben como máximo 32.767 caracteres. El resultado
de la conversión se representa con los números "0" a "9" y las letras mayúsculas "A" a "F".
Si no se puede mostrar el resultado completo de la conversión en el parámetro OUT, el
resultado solo se escribe parcialmente en el parámetro.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "HTA":
Parámetro

Declaración

Tipo de datos Área de memoria

Descripción

IN

Input

VARIANT

I, Q, M, D, L

Dirección inicial de la cifra hexa‐
decimal

N

Input

UINT

I, Q, M, D, L o cons‐ Número de bytes hexadecimales
tante
que se deben convertir

RET_VAL

Return

WORD

I, Q, M, D, L

Mensaje de error

OUT

Output

VARIANT

D, L

Dirección en la que se guarda el
resultado.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2329

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
Código de error* Descripción
(W#16#....)
0000

Ningún error

8182

El búfer de entrada es demasiado pequeño para los datos en el parámetro N.

8120

Formato no válido en el parámetro IN.

8151

Tipo de datos no soportado en el parámetro IN.

8482

El búfer de salida es demasiado pequeño para los datos en el parámetro N.

8420

Formato no válido en el parámetro OUT.

8451

Tipo de datos no soportado en el parámetro OUT.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Caracteres ASCII y valores hexadecimales
La tabla siguiente muestra los caracteres ASCII y los correspondientes valores hexadecimales:

2330

Número hexadecimal

Valor hexadecimal codificado en
ASCII

Caracteres ASCII

0

30

"0"

1

31

"1"

2

32

"2"

3

33

"3"

4

34

"4"

5

35

"5"

6

36

"6"

7

37

"7"

8

38

"8"

9

39

"9"

A

41

"A"

B

42

"B"

C

43

"C"

D

44

"D"

E

45

"E"

F

46

"F"

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
La tabla siguiente muestra ejemplos de conversión de números hexadecimales en cadenas de
caracteres ASCII:
IN

N

OUT

Tipo de datos de OUT

Estado ENO

● WORD#16#0123

2

'0123'

STRING, WSTRING

1

4

'123AF012'

STRING, WSTRING

1

WORD#16#ABE3

2

CHAR#[‘A’, ‘B’, ‘E’, ‘3’]

ArrayOfCHAR, ArrayOfW‐
CHAR

1

WORD#16#9250

2

[16#39, 16#32, 16#35, 16#30]

ArrayOfBYTE

1

ArrayOfWORD#[16#123A,
2
16#0000, 16#ABCD, 16#0000]

[16#0031, 16#0032, 16#0033,
16#0041]

ArrayOfWORD

1

WORD#16#1234

2

[16#0031, 16#0032, 16#0033,
16#0034]

ArrayOfWORD

1

DWORD#16#4567ABCD

4

[16#0034, 16#0035, 16#0036,
16#0037, 16#0041, 16#0042,
16#0043, 16#0044]

ArrayOfWORD

1

ArrayOfD‐
WORD#[16#A800_0037,
16#0000_0041]

1

‘A8’

STRING, WSTRING

1

● CHAR#[‘0’, ‘A’, ‘2’, ‘3’]

2

‘3041’

STRING, WSTRING

1

5

‘3132334146’

STRING, WSTRING

1

1

‘41’

STRING, WSTRING

1

● UINT#10#291
● DWORD#16#123AF012
● INT#10#305852434

● WCHAR#[‘0’, ‘A’, ‘2’, ‘3’]
● STRING#‘123AFC1A23’
● WSTRING#‘123AFC1A23’
● Char#‘A‘
● Byte#16#41

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Programación del PLC
Manual de programación y manejo, 11/2019

2331

Instrucciones
4.1 Instrucciones

LEN: Determinar la longitud de una cadena de caracteres
Descripción
Una variable del tipo de datos (W)STRING contiene dos longitudes: la longitud máxima y la
longitud actual (es decir, el número de caracteres válidos actualmente).
● La longitud máxima de la cadena de caracteres de cada variable se especifica entre
corchetes en la palabra clave STRING. El número de bytes ocupados por una cadena de
caracteres excede en 2 la longitud máxima.
● La longitud máxima de la cadena de caracteres de cada variable se especifica entre
corchetes en la palabra clave WSTRING. El número de palabras ocupadas por una cadena
de caracteres excede en 2 la longitud máxima.
● La longitud actual representa el número de posiciones de carácter realmente ocupadas. La
longitud actual es menor o igual que la longitud máxima.
La instrucción "LEN" consulta la longitud actual de la cadena de caracteres especificada en el
parámetro de entrada IN. Esta se devuelve como valor numérico en el parámetro de salida
OUT. Una cadena vacía ('') tiene la longitud cero.
Si ocurren errores durante la ejecución de la instrucción, en el parámetro OUT se devuelve el
valor "0".
Nota
Leer la longitud máxima
Con la instrucción "MAX_LEN (Página 2293)" se lee la longitud máxima de una cadena de
caracteres.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "LEN":
Parámetros

Declaración

Tipo de datos Área de memoria

Descripción

IN

Input

STRING,
WSTRING

D, L o constante

Cadena de caracteres

OUT

Return

INT

I, Q, M, D, L

Número de caracteres válidos

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el siguiente ejemplo se calcula la longitud de una cadena de caracteres del tipo de datos
STRING.
Para almacenar los datos se crean dos variables en un bloque de datos global.

2332

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Los parámetros de la instrucción se interconectan del siguiente modo.

El número de caracteres realmente ocupados de la cadena ("inputSTRING") se calcula y se
emite en el parámetro de salida OUT ("stringLengthOUT") como valor numérico.

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

CONCAT: Agrupar cadenas de caracteres
Descripción
La instrucción "CONCAT" une la cadena de caracteres del parámetro de entrada IN1 con la
cadena de caracteres del parámetro de entrada IN2. El resultado se emite en el parámetro de
salida OUT en formato (W)STRING. Si la cadena de caracteres resultante excede la longitud
de la variable especificada en el parámetro de salida OUT, la cadena se trunca a la longitud
disponible.
Si ocurren errores durante la ejecución de la instrucción y es posible escribir en el parámetro
de salida OUT, se emite una cadena vacía.

Programación del PLC
Manual de programación y manejo, 11/2019

2333

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "CONCAT":
Parámetro

Declaración

Tipo de da‐ Área de memoria
tos

Descripción

IN1

Input

STRING,
WSTRING

D, L o constante

Cadena de caracteres

IN2

Input

STRING,
WSTRING

D, L o constante

Cadena de caracteres

OUT

Return

STRING,
WSTRING

D, L

Cadena de caracteres resultante

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el siguiente ejemplo se conectan entre sí dos cadenas de caracteres del tipo de datos
STRING.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

Los caracteres de la segunda cadena de caracteres ("inputstring2") se agregan a la primera
cadena de caracteres ("inputstring1") y el resultado se emite en el parámetro de salida OUT
("string1CONCstring2").

2334

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

LEFT: Leer los caracteres izquierdos de una cadena
Descripción
La instrucción "LEFT" extrae una cadena de caracteres parcial a partir del primer carácter de
la cadena en el parámetro de entrada IN. El número de caracteres que se extraen se especifica
en el parámetro L. Los caracteres extraídos se emiten en el parámetro de salida OUT en
formato (W)STRING.
Si el número de caracteres que debe extraerse excede la longitud actual de la cadena de
caracteres, el parámetro de salida OUT devuelve como resultado la cadena de caracteres de
entrada. Si el parámetro L tiene el valor "0" o si el valor de entrada es una cadena vacía, se
devuelve una cadena vacía. Si el valor del parámetro L es negativo, se devuelve una cadena
vacía.
Si ocurren errores durante la ejecución de la instrucción y es posible escribir en el parámetro
de salida OUT, se emite una cadena vacía.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "LEFT":
Parámetro

Declaración

Tipo de datos Área de memoria

Descripción

IN

Input

STRING,
WSTRING

Cadena de caracteres

L

Input

BYTE, INT,
I, Q, M, D, L o cons‐ Número de caracteres que deben
SINT, USINT tante
extraerse

OUT

Return

STRING,
WSTRING

D, L o constante

D, L

Cadena de caracteres parcial ex‐
traída

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2335

Instrucciones
4.1 Instrucciones

Ejemplo
En el siguiente ejemplo se extrae de una cadena de caracteres, a partir del primer carácter, una
cadena de caracteres parcial del tipo de datos STRING.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

De acuerdo con el valor "4" del parámetro L ("extractNumber"), a partir del primer carácter a la
izquierda de la cadena de caracteres ("inputSTRING") se extrae una cadena de caracteres
parcial de cuatro caracteres de longitud. La cadena de caracteres extraída se emite en el
parámetro de salida OUT ("outputExtractSTRING").

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

RIGHT: Leer los caracteres derechos de una cadena
Descripción
Con la instrucción se extraen los últimos L caracteres de una cadena en el parámetro de
entrada IN. El número de caracteres que se extraen se especifica en el parámetro L. Los
caracteres extraídos se emiten en el parámetro de salida OUT en formato (W)STRING.

2336

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si el número de caracteres que debe extraerse excede la longitud actual de la cadena de
caracteres, el parámetro de salida OUT devuelve como resultado la cadena de caracteres de
entrada. Si el parámetro L tiene el valor "0" o si el valor de entrada es una cadena vacía, se
devuelve una cadena vacía. Si el valor del parámetro L es negativo, se devuelve una cadena
vacía.
Si ocurren errores durante la ejecución de la instrucción y es posible escribir en el parámetro
de salida OUT , se emite una cadena vacía.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RIGHT":
Parámetro

Declaración

Tipo de datos Área de memoria

Descripción

IN

Input

STRING,
WSTRING

Cadena de caracteres

L

Input

BYTE, INT,
I, Q, M, D, L o cons‐ Número de caracteres que deben
SINT, USINT tante
extraerse

OUT

Return

STRING,
WSTRING

D, L o constante

D, L

Cadena de caracteres parcial ex‐
traída

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el siguiente ejemplo se extrae de una cadena de caracteres, a partir del último carácter, una
cadena de caracteres parcial del tipo de datos STRING.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2337

Instrucciones
4.1 Instrucciones
De acuerdo con el valor "4" del parámetro de entrada L ("extractNumber"), a partir del primer
carácter a la derecha de la cadena de caracteres ("inputSTRING") se extrae una cadena de
caracteres parcial de cuatro caracteres de longitud. La cadena de caracteres extraída se emite
en el parámetro de salida OUT ("outputExtractSTRING").

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

MID: Leer los caracteres centrales de una cadena
Descripción
La instrucción extrae una parte de la cadena de caracteres del parámetro de entrada IN. Con
el parámetro P se especifica la posición del primer carácter que se va a extraer. La longitud de
la cadena de caracteres que se va a extraer se determina con el parámetro L. La cadena de
caracteres extraída se emite en el parámetro de salida OUT.
Tenga en cuenta las reglas siguientes al ejecutar la instrucción:
● Si el número de caracteres que se va a extraer excede la longitud actual de la cadena de
caracteres en el parámetro de entrada IN, se emite una cadena de caracteres parcial. La
cadena de caracteres parcial comienza en la posición de carácter P y continúa hasta el final
de la cadena de caracteres.
● Si la posición de carácter especificada en el parámetro P se encuentra fuera de la longitud
actual de la cadena de caracteres del parámetro de entrada IN, se deposita una cadena de
caracteres vacía en el parámetro de salida OUT.
● Si el valor del parámetro P o L es cero o negativo, se deposita una cadena de caracteres
vacía en el parámetro de salida OUT.
Si ocurren errores durante la ejecución de la instrucción y es posible escribir en el parámetro
de salida OUT, se emite una cadena vacía.

2338

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "MID":
Parámetro

Declaración

Tipo de da‐ Área de memoria
tos

Descripción

IN

Input

STRING,
WSTRING

D, L o constante

Cadena de caracteres

L

Input

BYTE, INT,
SINT,
USINT

I, Q, M, D, L o cons‐
tante

Longitud de la cadena de caracte‐
res que debe extraerse

P

Input

BYTE, INT,
SINT,
USINT

I, Q, M, D, L o cons‐
tante

Posición del primer carácter que
debe extraerse (primer carácter =
1)

OUT

Return

STRING,
WSTRING

D, L

Cadena de caracteres parcial ex‐
traída

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el siguiente ejemplo se extrae del centro de una cadena de caracteres una cadena de
caracteres parcial del tipo de datos STRING.
Para almacenar los datos es preciso crear cuatro variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

De acuerdo con el valor "4" del parámetro de entrada L ("extractNumber"), se extrae de la
cadena de caracteres ("inputSTRING") una cadena de caracteres parcial de cuatro caracteres
de longitud. La extracción se inicia a partir del tercer carácter ("startingPoint" tiene el valor "3")
de la cadena de caracteres ("inputSTRING"). La cadena de caracteres extraída se emite en el
parámetro de salida OUT ("outputExtractSTRING").

Programación del PLC
Manual de programación y manejo, 11/2019

2339

Instrucciones
4.1 Instrucciones

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

DELETE: Borrar caracteres de una cadena
Descripción
La instrucción borra una parte de la cadena de caracteres del parámetro de entrada IN. La
posición del primer carácter que se va a borrar se determina con el parámetro P. En el
parámetro L se especifica el número de caracteres que se van a borrar. La cadena de
caracteres parcial restante se emite en el parámetro de salida OUT en formato (W)STRING.
Tenga en cuenta las reglas siguientes al ejecutar la instrucción:
● Si el valor del parámetro P es menor o igual a cero, se devuelve una cadena de caracteres
vacía en el parámetro de salida OUT.
● Si el valor del parámetro P excede la longitud actual de la cadena de caracteres en la
entrada IN, el parámetro de salida OUTdevuelve la cadena de caracteres de entrada.
● Si el valor del parámetro L es cero, el parámetro de salida OUT devuelve la cadena de
caracteres de entrada.
● Si el número de caracteres que debe borrarse en el parámetro L excede la longitud de la
cadena de caracteres en el parámetro de entrada IN, se borran los caracteres a partir de la
posición especificada en el parámetro P. Se emite la cadena de caracteres resultante.
● Si el valor del parámetro L es negativo, se emite una cadena de caracteres vacía.
Si ocurren errores durante la ejecución de la instrucción y es posible escribir en el parámetro
de salida OUT, se emite una cadena vacía.

2340

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DELETE":
Parámetro

Declaración

Tipo de datos Área de memoria

Descripción

IN

Input

STRING,
WSTRING

Cadena de caracteres

L

Input

BYTE, INT,
I, Q, M, D, L o cons‐ Número de caracteres que se van a
SINT, USINT tante
borrar

P

Input

BYTE, INT,
I, Q, M, D, L o cons‐ Posición del primer carácter que
SINT, USINT tante
debe borrarse

OUT

Return

STRING,
WSTRING

D, L o constante

D, L

Cadena de caracteres resultante

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el ejemplo siguiente se eliminan caracteres de una cadena de caracteres del tipo de datos
STRING.
Para almacenar los datos es preciso crear cuatro variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

De acuerdo con el valor "4" del parámetro de entrada L ("deleteNumber"), se eliminan cuatro
caracteres de la cadena de caracteres ("inputSTRING") a partir del tercer carácter
("startingPoint" tiene el valor "3"). La cadena de caracteres restante se emite en el parámetro
de salida OUT ("outputResidualSTRING").

Programación del PLC
Manual de programación y manejo, 11/2019

2341

Instrucciones
4.1 Instrucciones

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

INSERT: Insertar caracteres en una cadena
Descripción
La instrucción inserta la cadena de caracteres del parámetro de entrada IN2 en la cadena de
caracteres del parámetro de entrada IN1. Con el parámetro P se especifica la posición del
carácter a partir del cual deben insertarse los caracteres. El resultado se indica en el parámetro
de salida OUT en formato (W)STRING.
Tenga en cuenta las reglas siguientes al ejecutar la instrucción:
● Si el valor del parámetro P excede la longitud actual de la cadena de caracteres en el
parámetro de entrada IN1, la cadena de caracteres del parámetro de entrada IN2 se agrega
a la del parámetro de entrada IN1.
● Si el valor del parámetro P es cero, la cadena de caracteres del parámetro de entrada IN1
se coloca a continuación de la del parámetro de entrada IN2.
● Si el valor del parámetro P es negativo, en la salida OUT se emite una cadena de caracteres
vacía.
● Si la cadena de caracteres resultante excede la longitud de la variable especificada en el
parámetro de salida OUT, la cadena se trunca a la longitud disponible.

2342

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "INSERT":
Parámetro

Declaración

Tipo de da‐ Área de memoria
tos

Descripción

IN1

Input

STRING,
WSTRING

D, L o constante

Cadena de caracteres

IN2

Input

STRING,
WSTRING

D, L o constante

Cadena de caracteres que se va a
insertar

P

Input

BYTE,
INT, SINT,
USINT

I, Q, M, D, L o cons‐ Posición de inserción
tante

OUT

Return

STRING,
WSTRING

D, L

Cadena de caracteres resultante

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el siguiente ejemplo se inserta una cadena de caracteres en otra cadena de caracteres. El
tipo de datos utilizado es STRING.
Para almacenar los datos es preciso crear cuatro variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

Los caracteres de la segunda cadena de caracteres ("input2_STRING") se insertan en la
primera cadena de caracteres ("input1_STRING"). De acuerdo con el valor "3" del parámetro
P ("startingPoint"), la inserción se inicia después del tercer carácter de la primera cadena de

Programación del PLC
Manual de programación y manejo, 11/2019

2343

Instrucciones
4.1 Instrucciones
caracteres ("input1_STRING"). El resultado se devuelve en el parámetro de salida OUT
("outputStrg1AndStrg2").

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

REPLACE: Reemplazar caracteres de una cadena
Descripción
La instrucción sustituye una parte de la cadena de caracteres de la entrada IN1 por la cadena
de caracteres del parámetro de entrada IN2. La posición del primer carácter que se va a
sustituir se determina con el parámetro P. El número de caracteres que se van a sustituir se
especifica en el parámetro L. El resultado se emite en el parámetro de salida OUT en formato
(W)STRING.
Tenga en cuenta las reglas siguientes al ejecutar la instrucción:
● Si el valor del parámetro P es menor o igual a cero, se devuelve una cadena de caracteres
vacía en el parámetro de salida OUT.
● Si el valor del parámetro L es menor que cero, en el parámetro de salida OUT se devuelve
una cadena de caracteres vacía.
● Si P es igual a uno, se sustituye la cadena de caracteres de la entrada IN1 a partir del primer
carácter (inclusive).
● Si el valor del parámetro P excede la longitud actual de la cadena de caracteres en el
parámetro de entrada IN1, la cadena de caracteres del parámetro de entrada IN2 se agrega
a la del parámetro de entrada IN1.
● Si la cadena de caracteres resultante excede la longitud de la variable especificada en el
parámetro de salida OUT, la cadena se trunca a la longitud disponible.
● Si el valor del parámetro L es igual a cero, no se sustituyen caracteres, sino que se insertan.
Rigen unas condiciones similares a las de la instrucción INSERT. Consulte
también: INSERT: Insertar caracteres en una cadena (Página 2342)

2344

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "REPLACE":
Parámetro

Declaración

Tipo de datos Área de memoria

Descripción

IN1

Input

STRING,
WSTRING

D, L o constante

Cadena cuyos caracteres se sus‐
tituyen.

IN2

Input

STRING,
WSTRING

D, L o constante

Cadena cuyos caracteres se in‐
sertan.

L

Input

BYTE, INT,
I, Q, M, D, L o cons‐ Número de caracteres que se van
SINT, USINT tante
a sustituir

P

Input

BYTE, INT,
I, Q, M, D, L o cons‐ Posición del primer carácter que
SINT, USINT tante
se va a sustituir

OUT

Return

STRING,
WSTRING

D, L

Cadena de caracteres resultante

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el siguiente ejemplo se sustituye una parte de una cadena de caracteres por otra cadena
de caracteres. El tipo de datos utilizado es STRING.
Para almacenar los datos se crean cinco variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2345

Instrucciones
4.1 Instrucciones

A la primera cadena de caracteres ("input1_STRING") se le agrega la segunda cadena de
caracteres ("input2_STRING") a partir del tercer carácter ("startingPoint" tiene el valor "3"). De
acuerdo con el valor "2" del parámetro L ("replaceNumber"), al hacerlo se sustituyen el tercer
y el cuarto carácter de la primera cadena de caracteres ("input1_STRING"). El resultado se
devuelve en el parámetro de salida OUT ("outputNewSTRING").

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

FIND: Buscar caracteres en una cadena
Descripción
La instrucción permite buscar una secuencia de caracteres determinada en la cadena de
caracteres del parámetro de entrada IN1.
● El valor que se va a buscar se especifica en el parámetro de entrada IN2. La búsqueda se
efectúa de izquierda a derecha.
● En el parámetro de salida OUT se emite la posición de la primera ocurrencia. Si la búsqueda
es infructuosa, se deposita el valor "0" en el parámetro de salida OUT.
Si en el parámetro IN2 se indica un carácter no válido o si durante la ejecución se produce un
error, se devuelve el valor "0" en el parámetro OUT.

2346

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "FIND":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

STRING,
WSTRING

D, L o constante

Cadena de caracteres en la que se bus‐
ca

IN2

Input

STRING,
WSTRING

D, L o constante

Secuencia de caracteres que se va a
buscar

OUT

Return

INT

I, Q, M, D, L

Posición de carácter

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el siguiente ejemplo se busca una cadena de caracteres dentro de otra cadena de
caracteres. El tipo de datos utilizado es STRING.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

Se busca en la primera cadena de caracteres ("inputSTRING") el valor "4a" de la segunda
cadena de caracteres ("STRINGsearchedFor"). La posición ("4") en la que empieza la cadena
de caracteres buscada se emite en el parámetro de salida OUT ("returnPosition").

Programación del PLC
Manual de programación y manejo, 11/2019

2347

Instrucciones
4.1 Instrucciones
Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

Información del tiempo de ejecución
GetSymbolName: Leer nombre de una variable en el parámetro de entrada.
Descripción
La instrucción "GetSymbolName" permite leer el nombre de una variable interconectada en el
parámetro VARIABLE mediante el parámetro de entrada de un bloque.
Nota
Variable negada en el parámetro de entrada de un bloque
Si se utiliza "GetSymbolName" en un parámetro de entrada de un bloque en el que hay
interconectada una variable negada, se devolverá siempre un String vacío
Nota
Mayor necesidad de espacio para código
El uso de GetSymbolName crea una mayor necesidad de espacio de memoria para el código.
Esta necesidad es tanto mayor cuanto mayor sea la frecuencia de llamada de la instrucción y
cuanto más largo sean los símbolos actuales.
Si un bloque se utiliza más de una vez en el proyecto o es llamado por diferentes variables,
existe la posibilidad de evaluar el nombre de la variable que realiza la llamada con la

2348

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
instrucción "GetSymbolName". El valor de proceso de la variable es irrelevante en este
contexto.
● El parámetro de entrada de la interfaz del bloque se indica en el parámetro VARIABLE de
la instrucción. No use en este parámetro variables PLC o de bloques de datos, sino única
y exclusivamente un parámetro de la interfaz.
● Con el parámetro SIZE se puede limitar la longitud del nombre de la variable que se ha
leído. Si el nombre está cortado, se indica con el carácter "..." (carácter Unicode 16#2026)
al final del nombre. Tenga en cuenta que este carácter tiene una longitud de 1.
El siguiente ejemplo explica el significado del parámetro SIZE. A través de la interfaz del
bloque se lee el siguiente nombre de variable: "MyPLCTag" (las comillas dobles al principio
y al final forman parte del nombre)
SIZE

GetSymbolName devuelve

Significado

1

'...'

● Carácter inicial del WSTRING: '
● Indica que el nombre ha quedado cortado: ...
● Carácter de fin del WSTRING: '

2

'"...'

● Carácter inicial del WSTRING: '
● El primer carácter del nombre y la indicación de que el
nombre está cortado: "...
● Carácter de fin del WSTRING: '

3

'"M...'

● Carácter inicial del WSTRING: '
● Los dos primeros caracteres del nombre y la indicación
de que el nombre está cortado: "M...
● Carácter de fin del WSTRING: '

6

'"MyPL...'

● Carácter inicial del WSTRING: '
● Los cinco primeros caracteres del nombre y la
indicación de que el nombre está cortado: "MyPL...
● Carácter de fin del WSTRING: '

0

'"MyPLCTag"'

● Carácter inicial del WSTRING: '
● Todos los caracteres del nombre: "MyPLCTag"
● Carácter de fin del WSTRING: '

● En el parámetro OUT se devuelve el nombre leído.

Programación del PLC
Manual de programación y manejo, 11/2019

2349

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GetSymbolName":
Parámetro

Declaración

Tipo de datos

Área de memo‐ Descripción
ria

VARIABLE

Input

PARAMETER Secciones de
parámetros In‐
put, Output,
InOut

Selección de la interfaz local para leer el nombre del
suministro de parámetros de entrada.

SIZE

Input

DINT

Limita el número de caracteres visualizados en el
parámetro OUT:

I, Q, M, D, L

● SIZE > 0: GetSymbolName proporciona los
primeros caracteres SIZE del nombre.
● SIZE = 0: GetSymbolName proporciona el
nombre entero.
● SIZE < 0: GetSymbolName proporciona los
últimos caracteres SIZE del nombre.
OUT

Return

WSTRING

D, L

Salida del nombre de la variable para el suministro
de parámetros de entrada

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el siguiente ejemplo se lee el nombre de una variable que está interconectada mediante el
parámetro de entrada de un bloque.
Para almacenar los datos se crean dos variables en un bloque de datos global.

Se crea una FC "SLI_FC_GetSymbolName". En el bloque se crea la siguiente variable local.

La instrucción "GetSymbolName" se llama en la FC y se interconecta "GetSymbolName" del
siguiente modo.

2350

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Se crea una FC "SLI_FC_FCCall_GetSymbolName". En la FC se llama la FC
"SLI_FC_GetSymbolName" y se interconecta del siguiente modo.

En el bloque "SLI_FC_GetSymbolName" se ejecuta la instrucción "GetSymbolName".
Mediante el parámetro de entrada VARIABLE de la instrucción se explora la interconexión del
parámetro de entrada inputValue del bloque "SLI_FB_GetSymbolName". Al hacerlo se lee la
variable "symbolVALUE" y se devuelve en el parámetro de salida OUT ("MySymNAME") como
cadena de caracteres. La longitud de la cadena de caracteres se limita a 60 caracteres de
acuerdo con el valor del parámetro de entrada SIZE.

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615)

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Programación del PLC
Manual de programación y manejo, 11/2019

2351

Instrucciones
4.1 Instrucciones

GetSymbolPath: Consultar parámetro actual al inicio de una ruta de llamada.
Descripción
Con la instrucción "GetSymbolPath" se lee el nombre de un parámetro que se transfiere al
inicio de una ruta de llamada y que se transmite a lo largo de varias llamadas de bloques.
Nota
Mayor necesidad de espacio para código
El uso de GetSymbolPath crea una mayor necesidad de espacio de memoria para el código.
Esta necesidad es tanto mayor cuanto mayor sea la frecuencia de llamada de la instrucción y
cuanto más largo sean los símbolos actuales.

2352

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● En el parámetro VARIABLE de la instrucción se indica el nombre del parámetro formal del
que debe leerse el nombre del parámetro actual interconectado en la llamada en tiempo de
ejecución.
– Si para suministrar parámetros de entrada se utiliza la variable de un bloque de datos,
se emitirá dicha variable, compuesta por el nombre del DB y la ruta de acceso a la
posible variable estructurada.
– Si para suministrar parámetros de entrada se utiliza una variable PLC, se emitirá el
nombre de la variable PLC.
– Si para suministrar valores a los parámetros de entrada se utiliza una constante, se
emitirá dicha constante.
● Con el parámetro SIZE se puede limitar la longitud del nombre de la variable que se ha
leído. Si el nombre está cortado, se indica con el carácter "..." (carácter Unicode 16#2026)
al final del nombre. Tenga en cuenta que este carácter tiene una longitud de 1.
El siguiente ejemplo explica el significado del parámetro SIZE. A través de la interfaz del
bloque se lee el siguiente nombre de variable: "MyPLCTag" (las comillas dobles al principio
y al final forman parte del nombre)
SIZE

GetSymbolPath devuelve

Significado

1

'...'

● Carácter inicial del WSTRING: '
● Indica que el nombre ha quedado cortado: ...
● Carácter de fin del WSTRING: '

2

'"...'

● Carácter inicial del WSTRING: '
● El primer carácter del nombre y la indicación de que el
nombre está cortado: "...
● Carácter de fin del WSTRING: '

3

'"M...'

● Carácter inicial del WSTRING: '
● Los dos primeros caracteres del nombre y la indicación
de que el nombre está cortado: "M...
● Carácter de fin del WSTRING: '

6

'"MyPL...'

● Carácter inicial del WSTRING: '
● Los cinco primeros caracteres del nombre y la
indicación de que el nombre está cortado: "MyPL...
● Carácter de fin del WSTRING: '

0

'"MyPLCTag"'

● Carácter inicial del WSTRING: '
● Todos los caracteres del nombre: "MyPLCTag"
● Carácter de fin del WSTRING: '

Programación del PLC
Manual de programación y manejo, 11/2019

2353

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GetSymbolPath":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

VARIABLE

Input

PARAMETER

Secciones de pará‐
metros Input, Output,
InOut

Selección del parámetro formal para el que se
desea leer el nombre del parámetro actual al
inicio de la ruta de llamada.

SIZE

Input

DINT

I, Q, M, D, L o cons‐
tante

Limita el número de caracteres visualizados en
el parámetro OUT:
● SIZE > 0: GetSymbolPath proporciona los
primeros caracteres SIZE del nombre.
● SIZE = 0: GetSymbolPath proporciona el
nombre entero.
● SIZE < 0: GetSymbolPath proporciona los
últimos caracteres SIZE del nombre.

OUT

Output

WSTRING

D, L

Salida del nombre de variable para el suminis‐
tro de parámetros de entrada.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
El siguiente ejemplo muestra el uso de GetSymbolPath a través de varios niveles de llamada:
● Desde el bloque de organización OB1 se llama el bloque FB_Level_1. Desde este bloque,
a su vez, se llama el bloque FB_Level_2.
● En el bloque FB_Level_2 se ejecuta GetSymbolPath para leer el nombre del parámetro
cuyo valor se pasa a REQ2 al inicio de la ruta de llamada.
● En el parámetro REQ1 se utiliza la variable MyStarterBit como parámetro actual. El bit está
dentro del bloque de datos MyDatablock, en la estructura MySTRUCT.
Esta información se lee mediante GetSymbolPath y se emite en el parámetro OUT.

2354

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

2%

)%B/HYHOB
(1

ಯ0\'DWD%ORFNಯ0\6758&7
0\6WDUWHU%LW

5(4

ಯ7DJBಯ

,QSXWB

ಯ7DJBಯ

,QSXWB


(12
2XWSXWB

ಯ7DJBಯ

)%B/HYHOB

)%B/HYHOB
(1
5(4

5(4

ಯ7DJBಯ

,QSXWB

ಯ7DJBಯ

,QSXWB


(12
ಯ7DJBಯ

2XWSXWB

)%B/HYHOB

*HW6\PERO3DWK
(1

5(4


(12

YDULDEOH
VL]H

287

:675,1*ಫ
ಯ0\'DWD%ORFNಯ
0\6758&7
0\6WDUWHU%LW

Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615)

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

GetInstanceName: Leer el nombre de la instancia del bloque
Descripción
La instrucción "GetInstanceName" lee el nombre del bloque de datos de instancia en un bloque
de función.
Nota
Mayor necesidad de memoria para código
El uso de GetInstanceName crea una mayor necesidad de espacio de memoria para el código.
Esta necesidad es tanto mayor cuanto mayor sea la frecuencia de llamada de la instrucción,
cuanto más largo sea el nombre del bloque de datos de instancia y cuanto menos se limite
dicha longitud.

Programación del PLC
Manual de programación y manejo, 11/2019

2355

Instrucciones
4.1 Instrucciones
● Con el parámetro SIZE se puede limitar la longitud del nombre de instancia que se ha leído.
Si el nombre está cortado, se indica con el carácter "..." (carácter Unicode 16#2026) al final
del nombre. Tenga en cuenta que este carácter tiene una longitud de 1.
El siguiente ejemplo explica el significado del parámetro SIZE. A través de la interfaz del
bloque se lee el siguiente nombre de instancia: "Level1_DB" (las comillas dobles al principio
y al final forman parte del nombre)
SIZE

GetInstanceName devuel‐
ve

Significado

1

'...'

● Carácter inicial del WSTRING: '
● Indica que el nombre ha quedado cortado: ...
● Carácter de fin del WSTRING: '

2

'"...'

● Carácter inicial del WSTRING: '
● El primer carácter del nombre y la indicación de que el
nombre está cortado: "...
● Carácter de fin del WSTRING: '

3

'"L...'

● Carácter inicial del WSTRING: '
● Los dos primeros caracteres del nombre y la indicación
de que el nombre está cortado: "L...
● Carácter de fin del WSTRING: '

6

'"Leve...'

● Carácter inicial del WSTRING: '
● Los cinco primeros caracteres del nombre y la
indicación de que el nombre está cortado: "Leve...
● Carácter de fin del WSTRING: '

0

'"Level1_DB"'

● Carácter inicial del WSTRING: '
● Todos los caracteres del nombre: "Level1_DB"
● Carácter de fin del WSTRING: '

● En el parámetro OUT se escribe el nombre del bloque de datos de instancia. Si el nombre
del bloque de datos de instancia es más largo que la longitud máxima de WSTRING, el
nombre se corta.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GetInstanceName":
Parámetro

Declaración

Tipo de datos Área de memoria

SIZE

Input

DINT

Descripción

I, Q, M, D, L o cons‐ Limita el número de caracteres visualizados en el pará‐
tante
metro OUT:
● SIZE > 0: GetInstanceName proporciona los
primeros caracteres SIZE del nombre.
● SIZE = 0: GetInstanceName proporciona el nombre
entero.
● SIZE < 0: GetInstanceName proporciona los últimos
caracteres SIZE del nombre.

OUT

2356

Output

WSTRING

D, L

Nombre leído del bloque de datos de instancia

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el ejemplo siguiente se lee el nombre de un bloque de datos de instancia.
Para almacenar los datos se crean dos variables en un bloque de datos global.

Se crea un FB "SLI_FB_GetInstanceName". Los parámetros de la instrucción
"GetInstanceName" se interconectan del siguiente modo.

En el bloque "SLI_FB_GetInstanceName" se ejecuta la instrucción "GetInstanceName". La
instrucción "GetInstanceName" permite obtener el correspondiente bloque de datos de
instancia del bloque "SLI_FB_GetInstanceName" y emitirlo en el parámetro de salida OUT
("outputInstName") como cadena de caracteres. La longitud de la cadena de caracteres es
ilimitada, de acuerdo con el valor "0" del parámetro SIZE ("limitSIZE").

Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615)

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Programación del PLC
Manual de programación y manejo, 11/2019

2357

Instrucciones
4.1 Instrucciones

GetInstancePath: consultar nombre global compuesto de la instancia del bloque
Descripción
La instrucción "GetInstancePath" lee el nombre global compuesto de la instancia de bloque en
de un bloque de función. El nombre global compuesto de la instancia de bloque es la ruta de
la jerarquía de llamada completa en caso de usarse multiinstancias.
Nota
Mayor necesidad de espacio para código
El uso de GetInstancePath crea una mayor necesidad de espacio de memoria para el código.
El espacio necesario adicionalmiente es tanto mayor cuanto más largo sean los nombres y
cuanto mayor sea el número de parámetros.
En el siguiente ejemplo se llama la instrucción "GetInstancePath" en el bloque de función
FB_Level_3.
● El bloque de función FB_Level_3 deposita sus datos en el bloque de función invocante
FB_Level_2.
● A su vez, el bloque de función FB_Level_2 deposita sus datos en el bloque de función
llamante FB_Level_1.
● Por su parte, el bloque de función FB_Level_1 deposita sus datos en su bloque de datos de
instancia IDB_LEVEL_1. Gracias al uso de multiinstancias, el bloque de datos de instancia
de FB_Level_1 contiene todos los datos de los tres bloques de función.
,'%B/(9(/B

)%B/HYHOB

,QSXW
2XWSXW
,Q2XW
6WDWLF
/HYHOBB,QVWDQFH
,QSXW
2XWSXW
,Q2XW
6WDWLF
/HYHOBB,QVWDQFH
,QSXW
2XWSXW
,Q2XW
6WDWLF


6WDWLF
/HYHOBB,QVWDQFH
6WDWLF
/HYHOBB,QVWDQFH

2358

0DLQ

,B'%B/HYHOB
)%B/HYHOB

)%B/HYHOB

6WDWLF
/HYHOBB,QVWDQFH

)%B/HYHOB

)%B/HYHOB

)%B[\]

)%BDEF

)&B[\]

)&BDEF

)%B/HYHOB

6WDWLF

*HW,QVWDQFH3DWK
VL]H
287

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En el ejemplo, la instrucción "GetInstancePath" devuelve los valores siguientes:
SIZE

GetInstancePath devuelve

Significado

1

'...'

● Carácter inicial del WSTRING: '
● Indica que el nombre ha quedado cortado: ...
● Carácter de fin del WSTRING: '

2

'"...'

● Carácter inicial del WSTRING: '
● El primer carácter del nombre y la indicación de que el
nombre está cortado: "...
● Carácter de fin del WSTRING: '

3

'"I...'

● Carácter inicial del WSTRING: '
● Los dos primeros caracteres del nombre y la indicación de
que el nombre está cortado: "I...
● Carácter de fin del WSTRING: '

6

'"IDB_...'

● Carácter inicial del WSTRING: '
● Los cinco primeros caracteres del nombre y la indicación
de que el nombre está cortado: "IDB_...
● Carácter de fin del WSTRING: '

0

'"IDB_LEVEL_1".Level_2_

● Carácter inicial del WSTRING: '
Instance.Level_3_Instance' ● Todos los caracteres del nombre:
"IDB_LEVEL_1".Level_2_Instance.Level_3_Instance
● Carácter de fin del WSTRING: '

Nota
Uso de "GetInstancePath" en bloques de función con instancia individual
Si el bloque de función en el que se llama "GetInstancePath" guarda los datos en un bloque de
datos de instancia propio, se emite como nombre global el nombre de la instancia individual.
En este caso, el resultado en el parámetro OUT corresponde a la instrucción
"GetInstanceName (Página 2355)".

Programación del PLC
Manual de programación y manejo, 11/2019

2359

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GetInstancePath":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SIZE

Input

DINT

I, Q, M, D, L o cons‐
tante

Limita el número de caracteres visualizados en
el parámetro OUT:
● SIZE > 0: GetInstancePath proporciona los
primeros caracteres SIZE del nombre.
● SIZE = 0: GetInstancePath proporciona el
nombre entero.
● SIZE < 0: GetInstancePath proporciona los
últimos caracteres SIZE del nombre.

OUT

Output

WSTRING

D, L

Nombre global leído de la instancia de bloque.
Si el nombre global de la instancia de bloque
es más largo que la longitud máxima de
WSTRING (254 caracteres), el nombre se cor‐
ta.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el siguiente ejemplo se lee el nombre global compuesto de la instancia del bloque.
Para almacenar los datos se crea una variable en un bloque de datos global.

Se crea un FB "SLI_FB_GIP_Level4" y en él se llama la instrucción "GetInstancePath".

Se crea un FB "SLI_FB_GIP_Level3" y en él se llama el FB "SLI_FB_GIP_Level4".

2360

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Se crea un FB "SLI_FB_GIP_Level2" y en él se llama el FB "SLI_FB_GIP_Level3".

Se crea un FB "SLI_FB_GIP_Level1" y en él se llama el FB "SLI_FB_GIP_Level2".

En el FB "SLI_FB_GIP_Level1" se crean las siguientes variables locales.

Se crea un OB de ciclo ("OB123") y en él se llama el FB "SLI_FB_GIP_Level1". El FB se
interconecta del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2361

Instrucciones
4.1 Instrucciones

En el "OB123" se ejecuta la instrucción "GetInstancePath". La instrucción "GetInstancePath"
lee las instancias de todos los bloques de función desde la llamada de la instrucción en el FB
"SLI_FB_GIP_Level4" hasta la llamada en el OB123. Los nombres de las instancias se
devuelven como cadena de caracteres en el parámetro de salida OUT
("outputPath_Level4FB") de la instrucción "GetInstancePath". La longitud de la cadena de
caracteres se limita a 80 caracteres de acuerdo con el valor del parámetro de entrada SIZE de
la instrucción "GetInstancePath".

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

2362

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

GetBlockName: Leer el nombre del bloque
Descripción
Mediante la instrucción "GetBlockName" se lee el nombre del bloque en el que se llama la
instrucción.
● Si la longitud del nombre del bloque debe limitarse a un número específico de caracteres,
indique la longitud máxima en el parámetro SIZE. Si el nombre está cortado, se indica con
el carácter "..." (carácter Unicode 16#2026) al final del nombre. Tenga en cuenta que este
carácter tiene una longitud de 1.
El siguiente ejemplo explica el significado del parámetro SIZE. Se lee el siguiente nombre
de bloque: "Level1_gbn" (las comillas dobles al principio y al final forman parte del nombre)
SIZE

GetBlockName devuelve

Significado

1

'...'

● Carácter inicial del WSTRING: '
● Indica que el nombre ha quedado cortado: ...
● Carácter de fin del WSTRING: '

2

'"...'

● Carácter inicial del WSTRING: '
● El primer carácter del nombre y la indicación de que el
nombre está cortado: "...
● Carácter de fin del WSTRING: '

3

'"L...'

● Carácter inicial del WSTRING: '
● Los dos primeros caracteres del nombre y la indicación
de que el nombre está cortado: "L...
● Carácter de fin del WSTRING: '

6

'"Leve...'

● Carácter inicial del WSTRING: '
● Los cinco primeros caracteres del nombre y la
indicación de que el nombre está cortado: "Leve...
● Carácter de fin del WSTRING: '

0

'"Level1_gbn"'

● Carácter inicial del WSTRING: '
● Todos los caracteres del nombre: "Level1_gbn"
● Carácter de fin del WSTRING: '

● En el parámetro RET_VAL se escribe el nombre del bloque. Si el nombre del bloque es más
largo que la longitud máxima de WSTRING, el nombre se corta.

Programación del PLC
Manual de programación y manejo, 11/2019

2363

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GetBlockName":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

SIZE

Input

DINT

I, Q, M, D, L o
constante

Limita el número de caracteres visualizados en el pará‐
metro RET_VAL:
● SIZE > 0: GetBlockName proporciona los primeros
caracteres SIZE del nombre.
● SIZE = 0: GetBlockName proporciona el nombre
entero.
● SIZE < 0: GetBlockName proporciona los últimos
caracteres SIZE del nombre.

RET_VAL

Output

WSTRING

D, L

Nombre leído del bloque de datos de instancia

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
En el siguiente ejemplo se lee el nombre del bloque.
Para almacenar los datos se crean dos variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

En el bloque "SLI_FC_GetBlockName" se ejecuta la instrucción "GetBlockName". La
instrucción "GetBlockName" permite leer el nombre del bloque "SLI_FC_GetBlockName" y
emitirlo en el parámetro de salida RET_VAL ("outputBlockName") como cadena de caracteres.
La longitud de la cadena de caracteres es ilimitada, de acuerdo con el valor "0" del parámetro
SIZE ("limitSIZE").

2364

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615)

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

4.1.4.4

Memoria imagen de proceso

UPDAT_PI: Actualizar memoria imagen de proceso de las entradas
Descripción
Esta instrucción permite actualizar una memoria imagen parcial de proceso de las entradas
mediante configuración.
Si se ha configurado como método de notificación para la actualización de la memoria imagen
de proceso por el sistema la notificación repetida de todos los errores de acceso a la periferia,
la actualización de la memoria imagen de proceso seleccionada se lleva a cabo de modo
continuo.
De lo contrario, esta actualización solo se efectúa si la memoria imagen parcial de proceso
seleccionada no es actualizada por el sistema, es decir, si esa memoria imagen parcial de
proceso no se ha asignado a ningún OB de alarma.
Nota
Las direcciones lógicas que se han asignado en la configuración a una memoria imagen parcial
de proceso de las entradas no pertenecen ya a la memoria imagen de proceso de las entradas
del OB 1.
Una memoria imagen parcial de proceso que se actualiza con "UPDAT_PI" no debe
actualizarse al mismo tiempo con la instrucción "SYNC_PI (Página 2371)".
Si se ha asignado a un OB de alarma la actualización por el sistema de la memoria imagen de
proceso del OB 1 de las entradas y de la memoria imagen parcial de proceso de las entradas,
la actualización se realiza independientemente de las llamadas de "UPDAT_PI".

Programación del PLC
Manual de programación y manejo, 11/2019

2365

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "UPDAT_PI":
Parámetro

Declaración

Tipo de da‐ Área de memoria
tos

PART

Input

PIP

Descripción

I, Q, M, D, L o cons‐ Número de la memoria imagen par‐
tante
cial de proceso de las entradas que
se debe actualizar. Rango máximo
de valores (el rango depende de la
CPU):
1 <= n <= 31 (significa memoria ima‐
gen parcial de proceso n).

RET_VAL

Return

INT

I, Q, M, D, L, P

Información de error

FLADDR

Output

WORD

I, Q, M, D, L, P

Dirección del primer byte que provo‐
ca errores, en caso de que se haya
producido un error de acceso

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Explicación
(W#16#...)
0000

No ha ocurrido ningún error.

8090

Valor no válido en el parámetro PART

8091

La memoria imagen parcial de proceso especificada todavía no está definida.

8092

La memoria imagen parcial de proceso es actualizada por el sistema y no puede utilizarse para el pará‐
metro PART.

8093

La actualización de la memoria imagen parcial de proceso está teniendo lugar en otro OB.

80A0

Se ha detectado un error de acceso al acceder a la periferia.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Nota
Si se utiliza esta instrucción para memorias imagen parcial de proceso de esclavos DP
normalizados, también son posibles los códigos de error de la instrucción "DPRD_DAT
(Página 2510)". Este es el caso cuando se han definido áreas de coherencia de más de 32
bytes.

Ejemplo
En el ejemplo siguiente se actualiza la memoria imagen parcial de proceso "1" de las entradas
que se ha definido por configuración.

2366

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para almacenar los datos es preciso crear cuatro variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

Cree para su CPU un módulo de entradas (DI) y configure la memoria imagen parcial de
proceso "1" en "Propiedades > Entrada 0 - 15 > Direcciones I/O". No asigne la memoria imagen
parcial de proceso a ningún OB.

En el parámetro de entrada PART ("part") de la instrucción "UPDAT_PI" se encuentra el
número de la memoria imagen parcial de proceso que se debe actualizar. Al llamar la
instrucción "UPDAT_PI" se actualiza la memoria imagen parcial de proceso indicada.

Programación del PLC
Manual de programación y manejo, 11/2019

2367

Instrucciones
4.1 Instrucciones
En el parámetro de salida RET_VAL ("returnValue") se indica que la ejecución se ha realizado
sin errores. La ejecución sin errores pone la bobina ("updateOk") a "TRUE". Puesto que no hay
errores de acceso, la dirección de error ("errAddress") de la instrucción "UPDAT_PI" muestra
el valor "16#0000".

Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615)

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

UPDAT_PO: Actualizar memoria imagen de proceso de las salidas
Descripción
Esta instrucción permite transferir a los módulos de salida los estados lógicos de una memoria
imagen parcial de proceso de las salidas definida mediante configuración.
Si se ha definido un área de coherencia para la memoria imagen parcial de proceso
seleccionada, los datos en cuestión se transfieren de modo coherente al módulo de periferia
correspondiente.
Nota
Las direcciones lógicas que se han asignado mediante configuración a una memoria imagen
parcial de proceso de las salidas no pertenecen ya a la memoria imagen de proceso del OB 1
de las salidas.
Las salidas que se actualizan con "UPDAT_PO" no deben actualizarse al mismo tiempo con la
instrucción "SYNC_PO (Página 2373)".
Si se ha asignado a un OB de alarma la transferencia a los módulos de salida de la memoria
imagen de proceso del OB 1 de las salidas y de la memoria imagen parcial de proceso de las
salidas, el sistema realiza la transferencia independientemente de las llamadas de
"UPDAT_PO".

2368

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "UPDAT_PO":
Parámetro

Declaración Tipo de da‐ Área de memoria
tos

PART

Input

PIP

Descripción

I, Q, M, D, L o cons‐ Número de la memoria imagen parcial
tante
de proceso de las salidas que se debe
transferir.
Rango máximo de valores (el rango
depende de la CPU): 1 <= n <= 31
(significa memoria imagen parcial de
proceso n)

RET_VAL

Return

INT

I, Q, M, D, L, P

Información de error

FLADDR

Output

WORD

I, Q, M, D, L, P

Dirección del primer byte que provoca
errores, en caso de que se haya pro‐
ducido un error de acceso

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Explicación
(W#16#...)
0000

No ha ocurrido ningún error.

8090

Valor no válido en el parámetro PART

8091

La memoria imagen parcial de proceso especificada todavía no está definida.

8092

La memoria imagen parcial de proceso es actualizada por el sistema y no puede utilizarse para el pará‐
metro PART.

8093

La actualización de la memoria imagen parcial de proceso tiene lugar en otro OB.

80A0

Se ha detectado un error de acceso al acceder a la periferia.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Nota
Si se utiliza esta instrucción para memorias imagen parcial de proceso de esclavos DP
normalizados, también son posibles los códigos de error de la instrucción "DPWR_DAT
(Página 2512)". Este es el caso cuando se han definido áreas de coherencia de más de 32
bytes.

Ejemplo
En el ejemplo siguiente se actualiza la memoria imagen parcial de proceso "1" de las salidas
que se ha definido por configuración.

Programación del PLC
Manual de programación y manejo, 11/2019

2369

Instrucciones
4.1 Instrucciones
Para almacenar los datos es preciso crear cuatro variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

Cree para su CPU un módulo de salidas (DQ) y configure la memoria imagen parcial de
proceso "1" en "Propiedades > Salida 0 - 15 > Direcciones I/O". No asigne la memoria imagen
parcial de proceso a ningún OB.

En el parámetro de entrada PART ("part") de la instrucción "UPDAT_PO" se encuentra el
número de la memoria imagen parcial de proceso que se debe actualizar. Al llamar la
instrucción "UPDAT_PO" se actualiza la memoria imagen parcial de proceso indicada.
En el parámetro de salida RET_VAL ("returnValue") se indica que la ejecución se ha realizado
sin errores. La ejecución sin errores pone la bobina ("updateOk") a "TRUE". Puesto que no hay

2370

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
errores de acceso, la dirección de error ("errAddress") de la instrucción "UPDAT_PO" muestra
el valor "16#0000".

Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615)

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

SYNC_PI: Sincronizar memoria imagen de proceso de las entradas
Descripción
La instrucción "SYNC_PI" permite actualizar de modo isócrono una memoria imagen parcial de
proceso de las entradas. Con esta instrucción, un programa de usuario vinculado a un ciclo DP
o a un ciclo de emisión PN actualiza los datos de entrada registrados de modo isócrono y
coherente en una memoria imagen parcial de proceso de las entradas.

Llamada
"SYNC_PI" puede interrumpirse, y solo puede llamarse en los OB 61, 62, 63 y 64.
Nota
Si la memoria imagen parcial de proceso en cuestión se ha asignado al OB correspondiente en
la configuración hardware, la llamada de la instrucción "SYNC_PI" solo está autorizada en los
OB 61 a 64. Una memoria imagen parcial de proceso que se actualiza con "SYNC_PI" no
puede actualizarse al mismo tiempo con la instrucción "UPDAT_PI (Página 2365)".

Programación del PLC
Manual de programación y manejo, 11/2019

2371

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SYNC_PI":
Parámetro

Declaración

Tipo de da‐ Área de memo‐ Rango de valo‐
tos
ria
res

Descripción

PART

Input

PIP

RET_VAL

Return

FLADDR

Output

I, Q, M, D, L o
constante

de 1 a 31

Número de la memoria imagen parcial de
proceso de las entradas que se debe ac‐
tualizar en modo isócrono.

INT

I, Q, M, D, L, P

-

Información de error

WORD

I, Q, M, D, L, P

Dirección del primer byte que provoca erro‐
res, en caso de que se haya producido un
error de acceso.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de
error
(W#16#...)*

Explicación

0000

No ha ocurrido ningún error.

0001

Advertencia de coherencia. La actualización de la memoria imagen parcial de proceso se ha repartido entre
dos ciclos DP o PN. Sin embargo, los datos pertenecientes a un submódulo se han transferido de modo
coherente.

8090

Un valor no admisible en el parámetro PART, o bien la actualización de la memoria imagen parcial de proceso
de las entradas indicada no está permitida en este OB. Probablemente la memoria imagen parcial de proceso
especificada todavía no está definida o bien no se le han asignado módulos de entrada. No se ha actualizado
la memoria imagen parcial de proceso de las entradas.

8092

La memoria imagen parcial de proceso es actualizada por el sistema y no puede utilizarse para el parámetro
PART.

8093

La actualización de la memoria imagen parcial de proceso tiene lugar en otro OB.

80A0

Durante la actualización se ha detectado un error de acceso. Las entradas afectadas se han ajustado a "0".

80A1

El momento de actualización es posterior a la ventana de acceso admisible. No se ha actualizado la memoria
imagen parcial de proceso de las entradas.
El ciclo DP o PN es demasiado corto y no garantiza suficiente tiempo para procesar la instrucción. Por ello
deben incrementarse los tiempos TDP (también conocidos como T_DC), Ti y To.

80A2

Error de acceso con advertencia de coherencia
Durante la actualización de la memoria imagen parcial de proceso de las entradas se ha detectado un error
de acceso con advertencia de coherencia simultánea.
● Los datos de las entradas erróneas no han sido leídos todavía por la periferia. En la memoria imagen
parcial de proceso de las entradas, las entradas afectadas se ponen a "0".
● La actualización de los datos de entrada no afectados por el error de acceso se ha distribuido entre dos
ciclos DP o PN.

80C1

2372

El momento de actualización es anterior a la ventana de acceso admisible. No se ha actualizado la memoria
imagen parcial de proceso de las entradas.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error
(W#16#...)*

Explicación

Información
de error ge‐
neral

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Nota
Si se utiliza la instrucción "SYNC_PI" para memorias imagen parcial de proceso de esclavos
DP normalizados, también son posibles los códigos de error de la instrucción "DPRD_DAT".
Este es el caso cuando se han definido áreas de coherencia de más de 32 bytes.

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
DPRD_DAT: Leer datos coherentes de un esclavo DP normalizado (Página 2510)

SYNC_PO: Sincronizar memoria imagen de proceso de las salidas
Descripción
La instrucción "SYNC_PO" permite actualizar de modo isócrono una memoria imagen parcial
de proceso de las salidas. Con esta instrucción, un programa de usuario vinculado a un ciclo
DP o a un tiempo de ciclo de emisión PN puede transferir a la periferia de modo isócrono y
coherente los datos de salida calculados de una memoria imagen parcial de proceso de las
salidas.

Llamada
"SYNC_PO" puede interrumpirse, y solo puede llamarse en los OB 61, 62, 63 y 64.
Nota
Si la memoria imagen parcial de proceso en cuestión se ha asignado al OB correspondiente en
la configuración hardware, la llamada de la instrucción "SYNC_PO" solo está autorizada en los
OB 61 a 64. Una memoria imagen parcial de proceso que se actualiza con "SYNC_PO" no
puede actualizarse al mismo tiempo con la instrucción "UPDAT_PO (Página 2368)".

Programación del PLC
Manual de programación y manejo, 11/2019

2373

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SYNC_PO":
Parámetro

Declaración

Tipo de da‐
tos

Área de memo‐ Rango de valo‐
ria
res

Descripción

PART

Input

PIP

I, Q, M, D, L o
constante

de 1 a 31

Número de la memoria imagen parcial de
proceso de las salidas que se debe ac‐
tualizar en modo isócrono.

RET_VAL

Return

INT

I, Q, M, D, P

-

Si se produce un error durante la ejecu‐
ción de la instrucción, el valor de respues‐
ta contendrá un código de error.

FLADDR

Output

WORD

I, Q, M, D, L, P

-

Dirección del primer byte que provoca
errores.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de
error

Explicación

(W#16#...)*
0000

No ha ocurrido ningún error.

0001

Advertencia de coherencia. La actualización de la memoria imagen parcial de proceso se ha repartido entre
dos ciclos DP o PN. Sin embargo, los datos pertenecientes a un submódulo se han transferido de modo
coherente.

8090

Un valor no admisible en el parámetro PART, o bien la actualización de la memoria imagen parcial de proceso
de las salidas indicada no está permitida en este OB. Probablemente la memoria imagen parcial de proceso
especificada todavía no está definida o bien no se le han asignado módulos de salida. No se han transferido
las salidas a la periferia. La memoria imagen parcial de proceso de las salidas no se modifica.

8092

La memoria imagen parcial de proceso es actualizada por el sistema y no puede utilizarse para el parámetro
PART.

8093

La actualización de la memoria imagen parcial de proceso tiene lugar en otro OB.

80A0

Durante la actualización de la memoria imagen parcial de proceso de las salidas se ha detectado un error de
acceso. No se han transferido las salidas erróneas a la periferia. En la memoria imagen parcial de proceso
de las salidas, estas no sufren modificación alguna.

80A1

Error de acceso con advertencia de coherencia
Durante la actualización de la memoria imagen parcial de proceso de las salidas se ha detectado un error de
acceso con advertencia de coherencia simultánea.
● No se han transferido los datos de las salidas erróneas a la periferia. En la memoria imagen parcial de
proceso de las salidas, las salidas afectadas no sufren modificación alguna.
● La actualización de los datos de salida no afectados por el error de acceso se ha distribuido entre dos
ciclos DP o PN.

80A2

El momento de actualización es posterior a la ventana de acceso admisible. No se han transferido las salidas
a la periferia. La memoria imagen parcial de proceso de las salidas no se modifica.

80C1

El momento de actualización es anterior a la ventana de acceso admisible. No se han transferido las salidas
a la periferia. La memoria imagen parcial de proceso de las salidas no se modifica.

2374

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error

Explicación

(W#16#...)*
Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)
Información
de error gene‐
ral
* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Nota
Si se utiliza la instrucción "SYNC_PO" para memorias imagen parcial de proceso de esclavos
DP normalizados, también son posibles los códigos de error de la instrucción "DPWR_DAT".
Este es el caso cuando se han definido áreas de coherencia de más de 32 bytes.

Consulte también
DPWR_DAT: Escribir datos coherentes de un esclavo DP normalizado (Página 2512)
Cambiar formatos de visualización en el estado del programa (Página 8529)

4.1.4.5

Periferia descentralizada

Descripción general de los tipos de juegos de datos
Introducción
El juego de datos como característica del hardware corresponde al conjunto de datos que
refleja determinadas características del hardware. Todo hardware puede tener varios juegos
de datos como características. Los juegos de datos se distinguen por su utilidad y su volumen
de información.
A continuación se familiarizará con los tipos de juegos de datos y se le ofrece una guía para
trabajar con juegos de datos mediante la asignación a módulos, sistemas e instrucciones.
La exposiciones siguientes son válidas para los sistemas de automatización S7-1200 y
S7-1500 y para la periferia descentralizada ET 200MP, ET 200SP.

Tipos de juegos de datos
Existen los siguientes tipos de juegos de datos:
Tipos
Juegos de pa‐
rámetros

Ventajas
a) para módulos de entradas
b) para módulos tecnológicos o
módulos que utilizan la función
tecnológica

Los juegos de parámetros contienen las propiedades de la función de
entrada/salida del módulo de periferia correspondiente. Un juego de da‐
tos permite, p. ej., leer una rotura de hilo o modificar el retardo a la en‐
trada. Los juegos de parámetros son de lectura y escritura.

c) para módulos de salida

Programación del PLC
Manual de programación y manejo, 11/2019

2375

Instrucciones
4.1 Instrucciones
Tipos
Juegos de da‐
tos de control

Juegos de da‐
tos I&M

Ventajas
a) para una configuración cen‐
tralizada o descentralizada
b) para reconfigurar un sistema
IO

El juego de datos de control contiene la configuración hardware del sis‐
tema o de la instalación y permite reconfigurar un módulo o un sistema IO
por medio del programa de usuario. El juego de datos de control es de
lectura y escritura.

a) para la configuración centra‐
lizada o descentralizada me‐
diante PROFINET IO

Los juegos de datos I&M contienen los datos de identificación y mante‐
nimiento de un módulo (I&M = Identification & Maintenance). Los datos
se distinguen del siguiente modo:

b) para la configuración centra‐
lizada o descentralizada me‐
diante PROFIBUS DP

● Datos de identificación:
–

En función de los datos del fabricante

–

Solo de lectura

–

Permiten leer, p. ej., el número de serie.

● Datos de mantenimiento:

Juegos de da‐
tos de diagnós‐
tico y juegos
de datos de
configuración

–

En función de la instalación y el uso del dispositivo

–

De lectura y escritura

–

Permiten modificar, p. ej., el lugar de montaje del módulo.

a) para la configuración descen‐ Los juegos de datos de diagnóstico y los juegos de datos de configura‐
tralizada mediante PROFINET ción tienen la misma estructura y solo se diferencian en su contenido y
IO
tamaño.
b) para la configuración descen‐ Se distinguen los siguientes juegos de datos:
tralizada mediante PROFIBUS ● Juegos de datos de diagnóstico:
DP
– Los juegos de datos de diagnóstico contienen los datos de
diagnóstico y vigilancia de un módulo.
–

Los juegos de datos de diagnóstico de canal se generan cuando
un canal presenta un error y/o ha disparado una alarma. Si no hay
error, se devuelve un juego de datos de diagnóstico de longitud 0.

–

La estructura y el tamaño de los juegos de datos de diagnóstico
específicos del fabricante dependen del fabricante en cuestión.

–

Los juegos de datos de diagnóstico son de solo lectura.

● Juegos de datos de configuración:
–

Los juegos de datos de configuración contienen los datos de la
configuración real o de la configuración teórica de un módulo.

–

Los juegos de datos de configuración son de lectura
(configuración real, configuración teórica) y de escritura
(configuración teórica).

Nota
Los juegos de datos de receta utilizados en WinCC no son propiedades del módulo y no tienen
nada que ver con los juegos de datos descritos aquí.

Uso de un juego de datos en el proyecto
Antes de utilizar un juego de datos en el proyecto, lea el manual correspondiente para
averiguar la estructura del juego de datos y los posibles requisitos. El apartado "Información
adicional" correspondiente remite al manual adecuado en cada caso.

2376

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Juegos de parámetros
Nota
Leer canales
Los juegos de datos 0..X y 64..64+X contienen parámetros específicos de canal. Así, p. ej., el
juego de datos 0 contiene la información del canal 0.
El juego de datos 128 contiene la información de todos los canales del módulo correspondiente
de la configuración hardware.
La instrucción RD_DPAR solo puede ejecutarse en una CPU S7-1500 o en una periferia
descentralizada ET 200.

Tipo:

Juegos de parámetros (a)

Afecta al módu‐
lo:

Módulo de entradas

Ubicación:

Configuración centralizada (S7-1500) o ET 200MP

S7-1200 o ET 200SP (*)

Instrucciones:

RDREC, WRREC

RDREC, WRREC

Juego de datos
(DS):

DS 0..X (DS = canal; X = últi‐ DS 128
mo canal del módulo de en‐
tradas en cada caso)

ID de HW:

Utilizar el ID de hardware del módulo de entradas.

Ejemplo:

P. ej. S7-1500 DI16x24VDC
HF --> canales 0..15; (p. ej.
utilizar DS 13).

p. ej., S7-1500
DI16x24VDC HF -->
DS 128.

Ejemplo 1: módulo de entradas de una CPU
S7-1212C --> ID de HW de la CPU, utilizar DS
128 y RDREC / WRREC.

Consulte también "Utilizar el
ejemplo de programa para el
juego de parámetros con
WRREC y RDREC (Pági‐
na 2404)".

Consulte también
"Ejemplo de programa
para RD_DPAR (Pági‐
na 2613)".

Ejemplo 2: ET 200SP DI8x24VDC HF --> ID de
HW del módulo DI, utilizar DS 128 y RDREC /
WRREC o RD_DPAR.

RD_DPAR

DS 128

RD_DPAR
(no para
S7-1200)

*Para ET 200SP Na‐ DS 128
mur: DS 0..X (DS =
canal; X = último ca‐
nal del módulo de en‐
tradas en cada caso)
o DS 128

Consulte también "Ejemplo de programa para
RD_DPAR (Página 2613)".

Tipo:

Juegos de parámetros (b)

Afecta al módu‐
lo:

Módulo tecnológico o módulo que utiliza la función tecnológica

Ubicación:

Configuración centralizada (S7-1500 o S7-1200)
o configuración descentralizada (ET 200MP o ET 200SP)

Instrucciones:

RDREC, WRREC

Juego de datos
(DS):

DS 128

RD_DPAR (no para S7-1200)
Alternativa con módulos
DI del S7-1500:

DS 128

DS 0..X (DS = canal; X =
último canal del módulo
de entradas en cada caso)

Programación del PLC
Manual de programación y manejo, 11/2019

2377

Instrucciones
4.1 Instrucciones
Tipo:

Juegos de parámetros (b)

ID de HW:

Utilizar el ID de hardware del módulo o del módulo de periferia en cuestión.

Ejemplo:

1) Ejemplo: CPU S7-1511 PN; High Speed Counter de S7-1500 DI16x24VDC HF --> p. ej. DS 1; utilizar
ID de HW del módulo DI (HSC). Utilizar WRREC / RDREC.
2) Ejemplo: TM Count 2x24V --> DS 128; utilizar ID de HW del TM. Utilizar WRREC / RDREC o RD_DPAR.
3) Ejemplo: High Speed Counter de una CPU S7-1200 --> DS 128; utilizar ID de HW de la CPU y WRREC /
RDREC.

Tipo:

Juegos de parámetros (c)

Afecta al módu‐
lo:

Módulo de salida

Ubicación:

Configuración centralizada (S7-1500) o ET 200MP

S7-1200 o ET 200SP (*)

Instrucciones:

RDREC, WRREC

RDREC, WRREC

Juego de datos
(DS):

DS 64..64 + X (DS 64 = canal DS 128
0; X = último canal del módu‐
lo de salida en cada caso)

ID de HW:

Utilizar el ID de hardware del módulo de salidas.

Ejemplo:

p. ej. DQ16x24VDC/0.5A ST
--> canales 0..15; (p. ej. para
el canal 13 utilizar el DS 77).

RD_DPAR

p. ej., DQ16x24VDC/
0.5A ST --> DS 128.

DS 128

RD_DPAR
(no para
S7-1200)

*Para ET 200SP Na‐ DS 128
mur: DS 64..64 + X
(DS 64 = canal 0; X =
último canal del mó‐
dulo de salidas en
cada caso) o DS 128

p. ej., ET 200SP DQ8x24VDC/0.5A ST --> DS
128.

Nota
Otros juegos de datos
En determinados casos hay otros juegos de datos. P. ej. para los módulos de entrada:
● En el ET 200SP AI RTD hay el DS 237 para desactivar la comprobación de rotura de hilo.
● En el ET 200SP AI Energy Meter ST hay el DS 142 para leer los datos medidos.
Nota
Módulo de interfaz con PROFIBUS DP
Si se utiliza un módulo de interfaz con PROFIBUS DP no es posible leer los juegos de
parámetros "0" y "1" del módulo de entradas/salidas que está situado detrás. En su lugar se lee
el contenido de los juegos de datos de diagnóstico "0" y "1".
Así, por ejemplo, en los módulos de salida el "juego de parámetros 0" es el "DS 64" y el "juego
de parámetros 1" el "DS 65".
Información adicional
Encontrará más información sobre el juego de parámetros correspondiente en el manual de
producto del módulo de periferia en cuestión (p. ej. S7-1500 DI16x24VDC HF (https://
support.industry.siemens.com/cs/ww/es/view/59193001)).

2378

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Juegos de datos de control
Tipo:

Juegos de datos de control

Afecta al módu‐
lo:

Todos los módulos de la configuración que se van a utilizar

Sistema IO y dispositivos IO desea‐
dos

Ubicación:

Configuración centralizada
(S7-1200, S7-1500)

Configuración descentralizada
(p. ej. ET 200MP, ET 200SP)

PROFINET IO

Instrucciones:

WRREC, RDREC

WRREC,
RDREC

RDREC

ReconfigIOSystem

Juego de datos
(DS):

DS 196

DS 196

DS 197 (juego
de datos de
respuesta)

DS "CTRLREC" (parámetros de Re‐
configIOSystem)

ID de HW:

Utilizar el ID de hardware 33.

Utilizar el ID de hardware del
encabezado [Head] del IM de
la periferia descentralizada.

Ejemplo:

P. ej. DI16x24VDC HF, ET
200MP IM 155-5 PN ST --> de
"<IO-device_V2.0[Head]>" utili‐
Consulte también "Utilizar el
ejemplo de programa para el jue‐ zar el ID.
go de datos de control con
La configuración real contiene
WRREC y RDREC (Pági‐
otra DI16x24VDC HF, que no
na 2413)".
debe tenerse en cuenta en la
configuración.
p. ej. para CPU S7-1511-1 PN
con DI16x24VDC HF.

Utilizar el ID de hardware de la inter‐
faz PROFINET (controlador IO).
En función de las conexiones y dis‐
positivos IO que van a crearse, indi‐
car las correspondientes ID de hard‐
ware mediante CTRLREC.
P. ej. conectar y activar una CPU
S7-1500 (controlador IO) con una
ET 200MP (dispositivo IO) y una ET
200SP (como dispositivo IO opcio‐
nal).
Consulte también "Ejemplo de pro‐
grama para ReconfigIOSystem (Pá‐
gina 2493)".

Información adicional
Encontrará más información sobre el juego de datos de control 196 en el manual de sistema
del sistema de automatización correspondiente (p. ej. "Sistema de automatización S7-1500
(https://support.industry.siemens.com/cs/ww/es/view/109755202)").
Encontrará más información sobre el juego de datos de respuesta 197 en el manual de
producto del módulo de interfaz correspondiente (p. ej. "ET 200MP IM 155-5 PN HF (https://
support.industry.siemens.com/cs/ww/es/view/89261636)").
Encontrará más información sobre el juego de datos de control "CTRLREC" en la instrucción
"ReconfigIOSystem: reconfigurar el sistema IO (Página 2487)".

Juegos de datos I&M
Considere el siguiente uso de los juegos de datos I&M:
● El juego de datos "I&M0" ("16#AFF0") sirve para transmitir información general relacionada
con el módulo o dispositivo.
● El juego de datos "I&M1" ("16#AFF1") sirve para transmitir la función y el lugar de montaje
del módulo o dispositivo.
● El juego de datos "I&M2" ("16#AFF2") sirve para transmitir la fecha de instalación del
módulo o dispositivo.

Programación del PLC
Manual de programación y manejo, 11/2019

2379

Instrucciones
4.1 Instrucciones
● El juego de datos "I&M3" ("16#AFF3") sirve para transmitir información complementaria
individual relacionada con el módulo o dispositivo.
● El juego de datos "I&M4" ("16#AFF4") sirve para transmitir un código de seguridad del
módulo o dispositivo a un controlador IO.
Nota
El juego de datos "I&M0" ("16#AFF0") es soportado por todos los módulos. Todos los demás
juegos de datos I&M son opcionales.

Tipo:

Juegos de datos I&M

Afecta al
módulo:

Dispositivo / módulo

Ubicación:

Configuración centralizada o descentralizada mediante PROFINET IO
o PROFIBUS DP

Instruccio‐
nes:

RDREC, WRREC

Juego de
DS
datos (DS): 16#AFF0

DS
16#AFF1

DS
16#AFF2

DS 16#AFF3

DS 16#AFF4

Como alternativa, en una configura‐
ción descentralizada mediante
PROFIBUS DP: DS 255

ID de HW:

Utilizar el ID de hardware del módulo.

Ejemplo:

1) Ejemplo: Para CPU S7-1511-1 PN --> DS 16#AFF0; utilizar el ID de
hardware de la CPU.

2) Ejemplo: Para ET 200SP con IM
155-6 DP ST --> DS 255; utilizar el
ID de hardware del IM.

Consulte también "Leer el ejemplo de programa para el juego de datos
I&M con RDREC (Página 2385)".

Información adicional
Encontrará más información sobre el juego de datos I&M correspondiente aquí:
● en el manual de sistema del sistema de automatización correspondiente (p. ej. "Sistema de
automatización S7-1500 (https://support.industry.siemens.com/cs/ww/es/view/
109755202)").
● en el manual de programación "SIMATIC NET PROFINET IO-Base user programming
interface (https://support.industry.siemens.com/cs/ww/es/view/26435491/en)".

Juegos de datos de diagnóstico y juegos de datos de configuración
Tipo:

Juegos de datos de diagnóstico y juegos de datos de configuración

Afecta al módu‐
lo:

Dispositivo / módulo o submódulo en el sistema IO

Ubicación:

Configuración descentralizada (PROFINET IO, PROFIBUS DP)

Instrucciones:

RDREC, WRREC

2380

RDREC

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tipo:

Juegos de datos de diagnóstico y juegos de datos de configuración

Juego de datos
(DS):

Configuración (real / teórica):

Diagnóstico de canal:

Utilizar DS para el módulo en cuestión.
Ver al respecto el nivel de direccionamiento y DS para "PROFINET IO
(https://support.industry.siemens.com/cs/ww/es/view/19289930)".

Diagnóstico específico del fabri‐
cante a través del módulo de in‐
terfaz:
para PROFI‐
NET IO:

para PROFI‐
BUS DP:

Consulte Mó‐
DS 0, 1
dulo de interfaz

ID de HW:

Utilizar el ID de hardware del módulo en cuestión (ID de hardwaer con tipo de datos "Hw_SubModule").

Ejemplo:

P. ej. controlador IO S7-1513-1
PN; utilizar ID de HW del módulo
en el nivel de slots para el disposi‐
tivo IO (ET 200MP IM 155-5 PN
HF). Con DS 16#C001, leer la con‐
figuración real.

P. ej. el dispositivo IO (ET 200MP
IM 155-5 PN HF) con módulo DQ
genera rotura de hilo. Utilizar ID
de HW del módulo de cabecera
del dispositivo IO. El controlador
IO es S7-1513-1 PN. Utilizar DS
16#E00A para diagnóstico de ca‐
nal.

p. ej., PROFIBUS DP: ET 200MP
con IM 155-5 DP ST; leer módulo
DI --> utilizar el ID de hardware
(tipo de datos "Hw_SubModule")
del módulo DI y el DS 1 para el
diagnóstico.

Consulte también "Leer el ejem‐
plo de programa para el juego de
datos de diagnóstico con
RDREC (Página 2389)".

Información adicional
Encontrará el nivel de direccionamiento, la estructura y juegos de datos importantes para
Diagnóstico y configuración con PROFINET IO:
● En el manual de programación "De PROFIBUS DP a PROFINET IO (https://
support.industry.siemens.com/cs/ww/es/view/19289930)".
Encontrará información general y más información sobre los juegos de datos de diagnóstico de
canal:
● En la Ayuda en pantalla de STEP 7, en "Diagnóstico de dispositivos PROFINET".
● En el manual de funciones de PROFINET ("PROFINET con STEP 7 V15 (https://
support.industry.siemens.com/cs/ww/es/view/49948856)").
Encontrará más información sobre los juegos de datos de diagnóstico específicos del
fabricante aquí:
● En el manual de producto del módulo de interfaz correspondiente (p. ej. ET 200MP IM 155-5
PN ST (https://support.industry.siemens.com/cs/ww/es/view/59193106)).

Consulte también
Sample Library for Instructions (Página 615)
RDREC: Leer registro (Página 2382)
WRREC: Escribir registro (Página 2401)
Página de preguntas frecuentes (FAQ) de Library of PLC Datatypes (https://
support.industry.siemens.com/cs/ww/es/view/109482396)

Programación del PLC
Manual de programación y manejo, 11/2019

2381

Instrucciones
4.1 Instrucciones

RDREC: Leer juego de datos
RDREC: Leer registro
Descripción
La instrucción "RDREC" permite leer el juego de datos con número INDEX del módulo
direccionado mediante ID. Puede tratarse de un módulo central o descentralizado (PROFIBUS
DP o PROFINET IO).
● El parámetro ID permite seleccionar desde qué módulo (DP/PROFINET IO) se debe leer un
juego de datos. Para el parámetro ID utilice el identificador de hardware (ID de hardware)
del módulo. El identificador de hardware de la CPU se consulta en "Variables PLC >
Constantes de sistema". P. ej. para un módulo DI S7-1500: se indica como <Nombre del
módulo DI> con el tipo de datos "Hw_SubModule".
● El parámetro INDEX permite seleccionar el juego de datos que se debe leer en el módulo.
Qué juegos de datos se pueden leer y con qué número de juego de datos depende del
módulo. Encontrará más información al respecto en la documentación del módulo en
cuestión.
● Los juegos de datos que se pueden leer mediante "RDREC" son de diferente longitud. Con
MLEN se especifica el número máximo de bytes del juego de datos que se quiere leer. Si
en el parámetro MLEN se selecciona "0" como longitud, se escribirá el juego de datos
completo en el parámetro RECORD.
● Seleccione un área de destino RECORD con una longitud de por lo menos MLEN bytes. Si
se lee el juego de datos completo con MLEN=0, para RECORD se deberá utilizar la longitud
máxima. La estructura (estructura, tipos de datos y longitud) que se utiliza en el parámetro
RECORD también depende de qué juego de datos se lea de qué módulo.
● El valor TRUE del parámetro de salida VALID indica que el juego de datos se ha transferido
correctamente al área de destino RECORD. En ese caso, el parámetro de salida LEN
contiene la longitud en bytes de los datos leídos.
● Si se ha producido un error durante la transferencia del juego de datos, se señaliza
mediante el parámetro de salida ERROR. En ese caso, el parámetro de salida STATUS
contiene la información de error.
Nota
La interfaz de la instrucción "RDREC" es idéntica a la del FB "RDREC" definido en la norma
"PROFIBUS and PROFINET Guideline Communication Function Blocks on PROFIBUS DP
and PROFINET IO".

Funcionamiento
"RDREC" es una instrucción asíncrona, de modo que la ejecución se prolonga a lo largo de
varias llamadas. Para iniciar la transferencia del juego de datos, debe llamarse "RDREC" con
REQ = 1.

2382

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Mediante el parámetro de salida BUSY y los dos bytes centrales del parámetro de salida
STATUS, se muestra el estado de la orden. Los dos bytes centrales de STATUS corresponden
al parámetro de salida RET_VAL de las instrucciones asíncronas.
Consulte también: Diferencia entre las instrucciones que funcionan síncronamente y las que
funcionan asíncronamente (Página 618).
Cuando el parámetro de salida BUSY toma el valor FALSE , la transferencia del juego de datos
se puede dar por finalizada.

Llamada de RDREC en el estado de sistema SYNCUP de un sistema S7-1500 R/H
Si se llama la instrucción RDREC en el estado de sistema SYNCUP de un sistema S7-1500 R/
H, siempre se devuelven los códigos de error 0x7001 y 0x7002. También en caso de error, p.
ej. si el origen del juego de datos no existe, no se devuelve ningún otro código de error. En ese
caso, el código de error correcto no se devuelve hasta que finaliza SYNCUP.
El comportamiento dinámico del estado del sistema SYNCUP requiere la llamada cíclica de
RDREC.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RDREC":
Parámetro

Declaración

Tipo de datos*

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L, T**, C**
o constante

REQ = 1: Transferir el juego de datos

ID

Input

HW_IO

I, Q, M, D, L o cons‐
tante

ID de hardware del módulo de hardware (DP/
PROFINET IO)
El número se asigna automáticamente y se
guarda en las propiedades del módulo o de la
interfaz en la configuración hardware.

INDEX

Input

DINT

I, Q, M, D, L o cons‐
tante

Número del juego de datos

MLEN

Input

UINT

I, Q, M, D, L o cons‐
tante

Longitud máxima en bytes de la información
del juego de datos que se debe leer.

VALID

Output

BOOL

I, Q, M, D, L

El nuevo juego de datos se ha recibido y es
válido.

BUSY

Output

BOOL

I, Q, M, D, L

BUSY = 1: la lectura todavía no ha finalizado.

ERROR

Output

BOOL

I, Q, M, D, L

ERROR = 1: se ha producido un error durante
la lectura.

STATUS

Output

DWORD

I, Q, M, D, L

Estado del bloque o información de error.

LEN

Output

UINT

I, Q, M, D, L

Longitud de la información leída en el juego de
datos.

Programación del PLC
Manual de programación y manejo, 11/2019

2383

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos*

Área de memoria

Descripción

RECORD

InOut

VARIANT

I, Q, M, D, L

Área de destino del juego de datos leído.
Si para el área de destino se utiliza el tipo de
datos de sistema NREF en un bloque de datos
con acceso optimizado, en el área de destino
no se escribirán valores.

* En AWL no se realiza conversión implícita, por lo que el volumen de tipos de datos admisibles puede estar restringido. Al
programar en AWL, tenga en cuenta los tipos de datos admisibles en el tooltip (información sobre herramientas) del parámetro
** Solo con S7-1500.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".
Nota
Si utiliza "RDREC" para leer un juego de datos en PROFINET IO, los valores negativos en los
parámetros INDEX, MLEN y LEN se interpretan como números enteros de 16 bits sin signo
previo.

Parámetro STATUS
Para la interpretación del parámetro STATUS, véase Parámetro STATUS (Página 2447).

Caso especial para sistemas PC: determinar el estado de Windows
El siguiente escenario le ayuda a obtener información sobre el estado de Windows de su
sistema PC:
● Llame la instrucción "RDREC" (SFB52) desde un OB cíclico, p. ej. OB1
Para determinar el estado de Windows mediante la instrucción "RDREC" hay definido un
nuevo Data Record index (0x7FFE) para el controlador por software.
La instrucción "RDREC" se llama con los siguientes parámetros de entrada:

2384

Parámetro

Declara‐
ción

Tipo de da‐
tos

Área de memoria

Valor/Descripción

(HIC) ID

Input

HW_IO

I, Q, M, D, L o constante

59 (Host Interface RID)

INDEX

Input

DINT

I, Q, M, D, L o constante

0x7FFE

MLEN

Input

UINT

I, Q, M, D, L o constante

9

RECORD

InOut

VARIANT

I, Q, M, D, L

Dirección para cada
área de 9 bytes

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El nuevo Data Record del estado de Windows se emite en el octavo byte y puede tener el
contenido siguiente:
● 0x01: Windows funciona
● 0x02: Windows no funciona
● 0x03: Bluescreen
Nota
Si se produce un fallo total del sistema, Windows ya no reacciona y muestra una pantalla
azul, que proporciona información sobre la causa y el momento de la caída del sistema. Por
defecto la pantalla azul permanece visible de forma permanente.
Tras el error de sistema este se detiene y pueden presentarse varios escenarios:
● Windows deja de enviar señales a la CPU por software configurada
● Ninguna llamada del OB82
● No se crea ninguna entrada de diagnóstico

Ejemplos
Encontrará un ejemplo aquí: Leer el ejemplo de programa para el juego de datos I&M con
RDREC (Página 2385).
Encontrará otro ejemplo aquí: Leer el ejemplo de programa para el juego de datos de
diagnóstico con RDREC (Página 2389).
Encontrará información adicional y el código del programa para los ejemplos aquí: Sample
Library for Instructions (Página 615).

Consulte también
Fundamentos del acceso a bloques (Página 54)
Descripción general de los tipos de juegos de datos (Página 2375)
Bytes de relleno cuando se usan tipos de datos estructurados (Página 143)

Leer el ejemplo de programa para el juego de datos I&M con RDREC
Introducción
jEn el siguiente ejemplo se lee el juego de datos I&M0 de una CPU S7-1500.
Encontrará información adicional sobre los juegos de datos en Descripción general de los tipos
de juegos de datos (Página 2375).

Requisitos
Para almacenar los datos es preciso crear nueve variables y una estructura en un bloque de
datos global.

Programación del PLC
Manual de programación y manejo, 11/2019

2385

Instrucciones
4.1 Instrucciones
El identificador de hardware de la CPU se lee en "Variables PLC > Constantes de sistema". Allí,
la CPU debería mostrarse como <Local> con el tipo de datos "Hw_SubModule". El identificador
de hardware se almacena mediante el parámetro de entrada ID ("id").

En un FB se crea la siguiente variable local.

2386

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Interconectar parámetros
Segmento 1: Los parámetros de la instrucción "RDREC" se interconectan del siguiente modo.

Segmento 2: Para guardar el estado en caso de error, la variable "status" se interconecta del
siguiente modo.

Resultado
Si el parámetro de entrada REQ ("start") devuelve el estado lógico "TRUE", se inicia la
instrucción "RDREC". Mediante el parámetro de entrada ID ("id"), la instrucción "RDREC"
llama el módulo. Mediante el parámetro de entrada INDEX ("dataRecNbr") se llama el juego de
datos I&M0 de la CPU.
Durante varias llamadas, la instrucción "RDREC" lee el juego de datos I&M0 y lo guarda
mediante el parámetro RECORD ("recordIM0").
El juego de datos I&M0 contiene la información siguiente, entre otras:
● el nombre del fabricante ("VendorID_HL")
● el número de artículo ("OrderID") y de dispositivo ("IM_SerialNbr")

Programación del PLC
Manual de programación y manejo, 11/2019

2387

Instrucciones
4.1 Instrucciones
● información de hardware ("IM_HWrev") y software ("IMSWrev")
● versión IM ("IM_Version") y el ancho de banda de los juegos de datos I&M soportados
("IM_Supported")

La longitud del juego de datos leído se recoge en el parámetro de salida LEN ("len"). De
acuerdo con el valor del parámetro de entrada MLEN ("maxLen" tiene el valor "0"), la
información del juego de datos que debe leerse es ilimitada.
Durante la ejecución, el parámetro de salida BUSY ("busy") está ajustado a "TRUE" y VALID
("checkedValid") a "FALSE". Una lectura correcta ("checkedValid" a "TRUE") no se indica
hasta finalizar la ejecución. En el parámetro de salida STATUS ("status") se indica el estado
del bloque. La ejecución transcurre sin errores.

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

2388

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
RDREC: Leer registro (Página 2382)

Leer el ejemplo de programa para el juego de datos de diagnóstico con RDREC
Introducción
En el siguiente ejemplo se utiliza RDREC para leer el juego de datos de diagnóstico "16#E00A"
de un dispositivo IO. Al dispararse una rotura de hilo, la información de error se indica como
juego de datos de diagnóstico.
Encontrará información adicional sobre los juegos de datos en Descripción general de los tipos
de juegos de datos (Página 2375).
Nota
Número de juegos de datos de diagnóstico
Cada slot de un módulo que dispare un error genera su propio juego de datos para el
dispositivo IO. Por tanto el diagnóstico puede contener varios juegos de datos.
El ejemplo está pensado para leer varios errores de hardware (fallos de canal) de diferentes
módulos y copiarlos en la estructura adecuada de un array de memoria. Dependiendo del
ajuste predeterminado, los arrays de memoria ("recordA", "recordB") pueden alojar como
máximo seis juegos de datos con un máximo de 16 canales cada uno.

'DWRVOH¯GRV

6HOHFFLµQGHODHVWUXFWXUDSDUDFDGD
MXHJRGHGDWRVFRQ[MXHJRVGH
GDWRV
UHFRUG$>[@

6HOHFFLµQGHODHVWUXFWXUD
SDUD\GLDJQµVWLFRVGH
FDQDO
86,BY>\@
86,BY>\@

UHFRUG%<7(

9HUVLRQ

86,BY>\@

UHFRUG%>[@

86,BY>\@
86,BY>\@

9HUVLRQ

86,BY>\@

Requisitos
Hardware instalado
Se necesita el hardware siguiente:
● Un controlador IO (p. ej. S7-1513-1 PN)
● Un dispositivo IO (p. ej. ET 200MP IM 155-5 PN HF)
● Uno o varios módulos de salidas digitales del tipo HF (p. ej. DQ 4x24VDC HF)

Programación del PLC
Manual de programación y manejo, 11/2019

2389

Instrucciones
4.1 Instrucciones

Nota
Disparar rotura de hilo
Asegúrese de que los canales del módulo DQ que van a disparar la rotura de hilo no están
cableados.
Nota
Procedimiento de configuración del hardware
El hardware se configura del siguiente modo:
1. Conecte la CPU y el dispositivo IO a través de PROFINET y asigne la CPU como
controlador IO al dispositivo IO.
2. Para el módulo DQ correspondiente, abra la ruta "Propiedades > Salida 0-x > Salidas >
Canal 0-y".
3. Seleccione el canal que debe configurarse y, en el área "Diagnóstico", active la opción
"Rotura de hilo".
Tipos de datos PLC creados
Para redistribuir y almacenar los juegos de datos se necesitan los tipos de datos PLC
siguientes:
● para el contenido central de la estructura "A"/"0100":

● para el contenido central de la estructura "B"/"0101":

2390

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● para la estructura del tipo 1 en función del valor de "UserStructureIdentifier":
el tipo 1 de la estructura se utiliza para el diagnóstico de canal simple.

● para la estructura del tipo 2 en función del valor de "UserStructureIdentifier":
el tipo 2 de la estructura se utiliza para el diagnóstico de canal avanzado.

● para la estructura del tipo 3 en función del valor de "UserStructureIdentifier":
el tipo 3 de la estructura se utiliza para un diagnóstico de canal específico del fabricante. En
este ejemplo no se define cómo se organiza la estructura. Para este ejemplo se supone que
el tipo 3 tiene una longitud de 28 bytes.

● para el resumen de la estructura "A"/"0100":

● para el resumen de la estructura "B"/"0101":

Programación del PLC
Manual de programación y manejo, 11/2019

2391

Instrucciones
4.1 Instrucciones

Nota
Tamaño de los arrays
Si desea modificar el tamaño de los arrays (para memoria de solo lectura, juego de datos o
canales), proceda del siguiente modo:
● Para canales: Adapte el tamaño de los arrays ("Array[0..y] of USI_v..") en los tipos de datos
PLC ("RECdiag_0100", "RECdiag_0101"). Adapte el valor de "maxChannelPos" en el gDB.
● Para juegos de datos: Adapte el tamaño de los arrays ("recordA", "recordB") en el gDB.
Adapte el valor de "maxRecordPos" en el gDB.
● Para memoria de solo lectura ("recordBYTE"): Adapte el tamaño del array ("recordBYTE")
y el valor de "maxPosition" en el gDB. Tenga en cuenta que el juego de datos de diagnóstico
"16#E00A" puede tener como máximo una longitud total de 4176 bytes.
Tabla de vigilancia creada
Para disparar una rotura de hilo se utiliza la función "Forzar permanentemente" de una tabla
de vigilancia.
Así, p. ej., si para la salida "%QW0" se fuerza el valor "16#FFFF", todos los canales que utilizan
la salida y tengan configurada una rotura de hilo dispararán un error de hardware.

2392

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Almacenamiento de datos
Para almacenar los datos es preciso crear en un bloque de datos global (gDB) las variables y
estructuras siguientes.

El identificador de hardware del encabezado del dispositivo IO se lee y se almacena mediante
la variable "id". El identificador de hardware para el módulo de encabezado se encuentra en
"Variables PLC > Constantes de sistema" y mediante una entrada como <Head~IO_Device>.
El tipo de datos utilizado es "HW_SubModule".

FC "SLI_FC_start_RDiag": Interconectar parámetros
Para iniciar la instrucción "RDREC", en base a un error de hardware, es necesario crear la FC
"SLI_FC_start_RDiag".
En la FC se crea la interconexión siguiente.

Programación del PLC
Manual de programación y manejo, 11/2019

2393

Instrucciones
4.1 Instrucciones
La FC "SLI_FC_start_RDiag" se llama en un OB de alarma de diagnóstico (OB82).

FC "SLI_FC_reset_RDiag": Interconectar parámetros
Para restablecer los valores de proceso después de un error es necesario crear la FC
"SLI_FC_reset_RDiag".
En la FC se crea la siguiente variable local.

En la FC se crean las interconexiones siguientes.
Segmento 1: Para restablecer los valores de proceso se crean las interconexiones siguientes.
Parte 1:

Parte 2:

Parte 3:

Parte 4:

2394

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 2: Para desactivar la variable "reset" se crean las interconexiones siguientes.

FB "SLI_FB_chooseStruct_RDiag": Interconectar parámetros
El FB "SLI_FB_chooseStruct_RDiag" se crea para seleccionar la estructura adecuada para el
juego de datos y para copiar los datos en el lugar adecuado del array.
Encontrará más información en el apartado "Resultado" ("Segmento 6") o en el área de
comentarios de los segmentos (consulte "Código del programa").

FB "SLI_FB_RDREC_Diag": Interconectar parámetros
El FB "SLI_FC_start_RDiag" se crea para llamar y procesar la instrucción "RDREC" y todos los
procesos subsiguientes.
En el FB se crean las siguientes variables locales.

En el FB se crean las interconexiones siguientes.
Segmento 1: Se llama la FC "SLI_FC_reset_RDiag" y se crea la instrucción "Label" con el
nombre "RDREC".

Segmento 2: Los parámetros de la instrucción "RDREC" se interconectan del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2395

Instrucciones
4.1 Instrucciones

Segmento 3: Para guardar el estado en caso de error de RDREC se interconecta el parámetro
del siguiente modo.

Segmento 4: Para finalizar la ejecución de RDREC, se crean las interconexiones siguientes.

Segmento 5: Para retroceder hasta el segmento 1, cree las interconexiones siguientes.

Segmento 6: Se llama el FB "SLI_FB_chooseStruct_RDiag" del siguiente modo:

El FB "SLI_FB_RDREC_Diag" se llama en un OB de ciclo (OB1).

2396

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Resultado - FB "SLI_FB_RDREC_Diag"
Segmento 1:
Si el contacto NA ("reset") devuelve el estado lógico "TRUE", se restablecen los valores de
proceso del FB "SLI_FB_chooseStruct_RDiag" y los valores de proceso del bloque de datos
global.
Segmento 2:
Si el parámetro de entrada REQ ("startRead") devuelve el estado lógico "TRUE", se inicia la
instrucción "RDREC".
Nota
Llamada de "startRead"
Conforme a la llamada del OB82, "startRead" se pone a "TRUE" cada vez que se detecta un
error de hardware. Las llamadas de RDREC que se han realizado correctamente se cuentan
mediante la variable "countCalls". Al cabo de tres disparos de fallos de canal, el valor pasa de
"countCalls" a "3".
Mediante el parámetro de entrada ID ("id"), la instrucción "RDREC" llama el módulo de
cabecera del dispositivo IO. Mediante el parámetro de entrada INDEX ("dataRecNbr") se llama
el juego de datos de diagnóstico "16#E00A" del dispositivo IO.
Durante varias llamadas, la instrucción "RDREC" lee los datos de diagnóstico y guarda los
datos leídos (x juegos de datos) mediante el parámetro RECORD ("recordBYTE"). La longitud
de los datos leídos se retiene mediante el parámetro de salida LEN ("#lengthOut") y se guarda
para su posterior uso mediante la variable "readLength". De acuerdo con el valor del parámetro
de entrada MLEN ("maxLength" tiene el valor "0"), la longitud de los datos que deben leerse es
ilimitada.
Durante la ejecución, el parámetro de salida BUSY ("busy") está ajustado a "TRUE" y VALID
("checkedValid") a "FALSE". Una lectura correcta ("checkedValid" a "TRUE") no se indica
hasta finalizar el procesamiento, y sirve como condición de arranque para el FB
"SLI_FB_chooseStruct_RDiag". Una vez finalizado el procesamiento del FB
"SLI_FB_chooseStruct_RDiag", la variable "checkedValid" se pone a "FALSE".
En el parámetro de salida STATUS ("#statusExe") se indica el estado del bloque. En el ejemplo
la ejecución transcurre sin errores.

Programación del PLC
Manual de programación y manejo, 11/2019

2397

Instrucciones
4.1 Instrucciones

Segmento 3:
Si el contacto NA ("error") devuelve el estado lógico "TRUE", el estado ("#statusExe") se
guarda en caso de error ("memErrStatus"). Además de desactivan las variables
"checkedValid" y "startRead". Ha finalizado el procesamiento de RDREC. No es posible iniciar
el procesamiento del FB "SLI_FB_chooseStruct_RDiag".
Segmento 4:
Si el procesamiento de RDREC se ha realizado completamente ("#statusExe" tiene el valor
"16#0070_0200"), "startRead" se pone a "FALSE". Ha finalizado el procesamiento de RDREC.
Segmento 5:
Si el contacto NA ("startRead") devuelve el estado lógico "TRUE", el procesamiento (mediante
la instrucción "JMP") salta al segmento 1 conforme a la etiqueta "RDREC".
Segmento 6:
Si la variable "checkedValid" devuelve el estado lógico "TRUE" y la variable "reset" el estado
lógico "FALSE", en el FB "SLI_FB_chooseStruct_RDiag" se inicia el proceso de clasificación.
En el FB "SLI_FB_chooseStruct_RDiag" se selecciona el tipo de estructura del juego de datos
correspondiente y el tipo de estructura en función del UserStructureIdentifier. Los datos del
juego de datos se copian en el lugar correspondiente del array adecuado. Además, en
determinadas circunstancias el procesamiento se realiza varias veces en función del tamaño
del correspondiente juego de datos. Para ello se lee la información de uno o de varios canales.
Si al final del procesamiento del contenido del juego de datos la "longitud del juego de datos
+ longitudes precedentes" ("#allRecLEN") es menor que la longitud de todos los datos leídos
("readLength"), el procesamiento del FB comienza desde el principio. Se lee otro juego de
datos, se comparan sus contenidos y sus datos se copian en el lugar correspondiente del array
adecuado.
El proceso de clasificación termina cuando las variables locales ("#readComplete",
"#dbComplete", "#limitReach") y la variable global "checkedValid" se ponen a "FALSE".

2398

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El proceso de clasificación se documenta basándose en las variables siguientes:
● "data_sorting_done": esta variable indica que el procesamiento del FB
"SLI_FB_chooseStruct_RDiag" se ha ejecutado completamente y ha terminado. La variable
"checkedValid" se desactiva, por lo que no puede ejecutarse de nuevo el procesamiento del
FB.
● "outputOverflow": esta estructura contiene tres variables, cada una de las cuales define un
rebase distinto de los límites del array. Así, por ejemplo, podrían haberse leído más juegos
de datos de los que puede guardar el array correspondiente ("recordA" o "recordB").
● "different_structs_used": si se ha utilizado tanto "recordA" como "recordB" para almacenar
juegos de datos de un diagnóstico, la variable "different_structs_used" devuelve el valor
"TRUE".
● "countRecs": esta variable cuenta los juegos de datos copiados.
● "chooseStruct": esta variable muestra la última estructura utilizada. El valor "4" indica que
recientemente se ha almacenado un juego de datos en la estructura "recordB" con la
característica "USI tipo 1".
● "posForRec": esta variable guarda la última posición utilizada en el array de los juegos de
datos ("recordA" o "recordB"). El valor "1" indica que recientemente se ha guardado un
juego de datos en "recordB[1]" (consulte "chooseStruct").
● "posForChannel": esta variable guarda la última ubicación utilizada en el array de los
canales ("USI_DetailsType[x]"). El valor "0" indica que en "recordB[1]/USI_DetailsType[0]"
(consulte "chooseStruct" y "posForRec") se ha guardado un canal.

Programación del PLC
Manual de programación y manejo, 11/2019

2399

Instrucciones
4.1 Instrucciones
A continuación puede verse el juego de datos con la estructura "B"/"0101" en la posición "0"
("recordB[0]"), con dos canales leídos.
El valor "16#8000" de "ChannelLocation" indica un diagnóstico a nivel de submódulo. Según
el valor "16#0006" de "ChannelErrorType" existe una rotura de hilo, en los canales 0 y 1
(consulte "ChannelNumber") del submódulo 1 (consulte "SubSlotNumber"), del módulo en el
slot 2 (consulte "SlotNumber").

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
RDREC: Leer registro (Página 2382)

2400

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

WRREC: Escribir juego de datos
WRREC: Escribir registro
Descripción
La instrucción "WRREC" permite transferir el juego de datos RECORD al componente
direccionado con ID. Puede tratarse de un módulo central o de un componente
descentralizado (PROFIBUS DP o PROFINET IO).
● El parámetro ID permite seleccionar para qué módulo se debe escribir un juego de datos.
Para el parámetro ID utilice el identificador de hardware (ID de hardware) del módulo. El
identificador de hardware de la CPU se consulta en "Variables PLC > Constantes de
sistema". P. ej. para un módulo DI S7-1500: se indica como <Nombre del módulo DI> con
el tipo de datos "Hw_SubModule".
● El parámetro INDEX permite seleccionar qué juego de datos se va a escribir. Qué juegos
de datos se pueden escribir y con qué número de juego de datos depende del módulo. Para
más información al respecto consulte el manual de producto del respectivo módulo.
● Con LEN se indica la longitud en bytes del juego de datos que se debe transferir. Seleccione
un área de origen RECORD con una longitud de por lo menos LEN bytes.
● El valor TRUE del parámetro de salida DONE indica que el juego de datos se ha transferido
correctamente.
● Si se ha producido un error durante la transferencia del juego de datos, se señaliza
mediante el parámetro de salida ERROR. En ese caso, el parámetro de salida STATUS
contiene la información de error.
Nota
La interfaz de la instrucción "WRREC" es idéntica a la del FB "WRREC" definido en la norma
"PROFIBUS and PROFINET Guideline Communication Function Blocks on PROFIBUS DP
and PROFINET IO".

Funcionamiento
"WRREC" es una instrucción que funciona de forma asíncrona. Su ejecución se prolonga a lo
largo de varias llamadas. Para iniciar la transferencia del juego de datos, debe llamarse
"WRREC" con REQ = 1.
Mediante el parámetro de salida BUSY y los dos bytes centrales del parámetro de salida
STATUS, se muestra el estado de la petición. Los dos bytes centrales de STATUS
corresponden al parámetro de salida RET_VAL de las instrucciones asíncronas.
Consulte también: Diferencia entre las instrucciones que funcionan síncronamente y las que
funcionan asíncronamente (Página 618).
Asegúrese de asignar siempre el mismo valor al parámetro actual de RECORD en todas las
llamadas a "WRREC" pertenecientes a una misma petición. Lo mismo se aplica a los
parámetros actuales de LEN.

Programación del PLC
Manual de programación y manejo, 11/2019

2401

Instrucciones
4.1 Instrucciones
Cuando el parámetro de salida BUSY ha adoptado el valor FALSE, la transferencia del juego
de datos se puede dar por finalizada.

Llamada de WRREC en el estado de sistema SYNCUP de un sistema S7-1500 R/H
Si se llama la instrucción WRREC en el estado de sistema SYNCUP de un sistema S7-1500
R/H, siempre se devuelven los códigos de error 0x7001 y 0x7002. También en caso de error,
p. ej. si el destino del juego de datos no existe, no se devuelve ningún otro código de error. En
ese caso, el código de error correcto no se devuelve hasta que finaliza SYNCUP.
El comportamiento dinámico del estado del sistema SYNCUP requiere la llamada cíclica de
WRREC.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "WRREC":
Parámetro

Declaración

Tipo de datos** Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L, T*, C* o
constante

REQ = 1: Transferir el juego de datos

ID

Input

HW_IO

I, Q, M, D, L o cons‐
tante

Número de identificación de los componentes
de hardware (DP/PROFINET IO)
El número se asigna automáticamente y se
guarda en las propiedades del componente o
de la interfaz en la configuración hardware.

INDEX

Input

DINT

I, Q, M, D, L o cons‐
tante

Número del juego de datos

LEN

Input

UINT

I, Q, M, D, L o cons‐
tante

(oculto)
Longitud máxima en bytes del juego de datos
que se debe transferir

DONE

Output

BOOL

I, Q, M, D, L

Se ha transferido el juego de datos

BUSY

Output

BOOL

I, Q, M, D, L

BUSY = 1: La escritura todavía no ha finaliza‐
do.

ERROR

Output

BOOL

I, Q, M, D, L

ERROR = 1: Se ha producido un error durante
la escritura.

STATUS

Output

DWORD

I, Q, M, D, L

Estado del bloque o información de error
Respecto a la interpretación del parámetro
STATUS, consulte más abajo.

RECORD

InOut

VARIANT

I, Q, M, D, L

Juego de datos

* Solo con S7-1500.
** En AWL no se realiza conversión implícita, por lo que el volumen de tipos de datos admisibles puede estar restringido. Al
programar en AWL tenga en cuenta los tipos de datos admisibles en el tooltip del parámetro.

2402

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".
Nota
Si utiliza "WRREC" para escribir un juego de datos en PROFINET IO, los valores negativos de
los parámetros INDEX y LEN se interpretan como números enteros de 16 bits sin signo.

Parámetro STATUS
En los módulos SIEMENS, los valores DW#16#DF80E0xy, DF80E1xy y DF80E200 tienen el
significado especificado en la tabla siguiente. Para los valores indicados en STATUS[3] y
STATUS[4], STATUS se interpreta como ARRAY[1...4] of BYTE.

Significado

Estructura del juego de
datos no válida

Error_Co‐
de_1

Error_Co‐
de_2

= STA‐
TUS[3]

= STA‐
TUS[4]

(B#16# ...)

(B#16# ...)

E0

00

No hay información detallada disponible

01

Conflicto de versión

02

Longitud incorrecta en el encabezado

03

Tipo de bloque incorrecto en el encabezado (en‐
cabezado de bloque I&M)

04 - FF

Reservado

Parámetro de usuario
no válido

E1

Contexto incorrecto

E2

Causa detallada del error

00

No hay información detallada disponible

01 - FF

Parámetro incorrecto 1 ... 255

00

El juego de datos no puede editarse en este con‐
texto de OB.

Respecto a la interpretación de todos los valores restantes de STATUS en módulos SIEMENS
y de todos los valores de STATUS en módulos no SIEMENS, consulte Parámetro STATUS
(Página 2447).

Ejemplos
Encontrará un ejemplo aquí: Utilizar el ejemplo de programa para el juego de parámetros con
WRREC y RDREC (Página 2404).
Encontrará otro ejemplo aquí: Utilizar el ejemplo de programa para el juego de datos de control
con WRREC y RDREC (Página 2413).
Encontrará información adicional y el código del programa para los ejemplos aquí: Sample
Library for Instructions (Página 615).

Programación del PLC
Manual de programación y manejo, 11/2019

2403

Instrucciones
4.1 Instrucciones

Consulte también
Descripción general de los tipos de juegos de datos (Página 2375)
Bytes de relleno cuando se usan tipos de datos estructurados (Página 143)

Utilizar el ejemplo de programa para el juego de parámetros con WRREC y RDREC
Introducción
En el ejemplo siguiente se lee el juego de parámetros de un módulo de entradas digitales
mediante RDREC y se escribe nuevamente mediante WRREC. Durante la operación se
modifica el retardo a la entrada.
Encontrará información adicional sobre los juegos de datos en Descripción general de los tipos
de juegos de datos (Página 2375).

Requisitos
Para almacenar los datos deben crearse las variables siguientes en un bloque de datos global:
● dos variables de uso general y siete variables para WRREC:

● una estructura para el juego de datos en WRREC:

2404

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● ocho variables para RDREC:

● una estructura para el juego de datos en RDREC:

En un FB "SLI_FB_WRREC_Para" se crean las siguientes variables locales.

Interconectar parámetro: FC "SLI_itemisePara_WRREC_Para"
Para reenviar los valores de una secuencia de bits (0..7) debe crearse la FC
"SLI_itemisePara_WRREC_Para".
En ella se crean las siguientes variables locales.

Programación del PLC
Manual de programación y manejo, 11/2019

2405

Instrucciones
4.1 Instrucciones

Segmento 1: Siguiendo el ejemplo del segmento 1 se crean interconexiones para todos los bits
(0..7).

Interconectar parámetro: FB "SLI_FB_WRREC_Para"
En el FB "SLI_FB_WRREC_Para" se crean las interconexiones siguientes.
Segmento 1: Los parámetros de la instrucción "RDREC" se interconectan del siguiente modo.

2406

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 2: A continuación se interconectan todas las variables de la estructura "#readBYTE"
con la estructura "readParaRecord". Parte 1 del segmento:

Parte 2 del segmento: Las variables "ClearanceDiagnosis" y "InputDelay_ProcessEvent" se
interconectan según el ejemplo siguiente.

Segmento 3: A continuación se interconectan las variables para el caso de error de RDREC.

Programación del PLC
Manual de programación y manejo, 11/2019

2407

Instrucciones
4.1 Instrucciones

Segmento 4: A continuación se interconectan las variables para finalizar RDREC.

Segmento 5: A continuación se interconectan todas las variables de la estructura
"writeParaRecord" con la estructura "#writeBYTE". Parte 1 del segmento:

Parte 2 del segmento:

Segmento 6: A continuación se interconectan los parámetros de la instrucción "WRREC".

2408

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 7: A continuación se interconectan las variables para el caso de error de WRREC.

Segmento 8: A continuación se interconectan las variables para finalizar WRREC y volver a
llamar RDREC.

Programación del PLC
Manual de programación y manejo, 11/2019

2409

Instrucciones
4.1 Instrucciones

Resultado del segmento 1:
Cree un módulo de entradas y lea el identificador de hardware en las propiedades del mismo.
El identificador de hardware se almacena mediante el parámetro de entrada ID ("id"). Mediante
el parámetro de entrada INDEX ("dataRecNbr") se llama el juego de datos del número "3" del
módulo. El juego de datos equivale al canal homónimo.

Si el parámetro de entrada REQ ("startRead") devuelve el estado lógico "TRUE", se inicia la
instrucción "RDREC". Mediante el parámetro de entrada ID ("id"), la instrucción "RDREC"
llama el módulo de entradas.
Durante varias llamadas, la instrucción "RDREC" lee el juego de datos y lo guarda mediante
el parámetro RECORD ("#readBYTE"). La longitud del juego de datos leído se recoge en el
parámetro de salida LEN ("#readLength"). De acuerdo con el valor del parámetro de entrada
MLEN ("maxReadLength"), la información que debe leerse del juego de datos está limitada a
4 bytes.
Durante la ejecución, el parámetro de salida BUSY ("readBusy") está ajustado a "TRUE" y
VALID ("#readCheck") a "FALSE".
Una lectura correcta no se indica hasta finalizar la ejecución, tal como se muestra:
● El parámetro de salida VALID ("#readCheck") se pone a "TRUE" y pone la variable
"readCheckedValid" a "TRUE" de forma permanente.
● Además, el valor de la variable local "#readLength" se guarda de forma permanente en la
variable "readLength".
En el parámetro de salida STATUS ("readStatus") se indica el estado del bloque. La ejecución
transcurre sin errores.

2410

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Resultado del segmento 2:
Mediante instrucciones MOVE y la FC "SLI_itemisePara_WRREC_Para" se transfieren los
valores de las variables de la estructura "#readBYTE" a las variables homónimas de la
estructura "readParaRecord". Para mayor claridad, las variables de la estructura
"readParaRecord" se muestran como nombres explícitos. La configuración se describe en el
manual de producto del módulo. Así, p. ej., mediante "InputDelay_ProcessEvent" se muestra
un retardo a la entrada de 3,2 ms. Para el estado del canal ("ClearanceDiagnosis") no se
emiten fallos (los bits 0 a 8 están a "FALSE").

Programación del PLC
Manual de programación y manejo, 11/2019

2411

Instrucciones
4.1 Instrucciones

Resultado del segmento 3:
Si "readError" devuelve el estado lógico "TRUE", el valor de la variable "readStatus" se guarda
en la variable "reMemErrStat".

Resultado del segmento 4:
Una vez ha finalizado la ejecución de la instrucción "RDREC", "readStatus" devuelve el valor
"16#0070_0200". Seguidamente, un desactivador pone la variable "startRead" a "FALSE".

Resultado del segmento 5:
Mediante instrucciones MOVE y la FC "SLI_itemisePara_WRREC_Para" se transfieren los
valores de las variables de la estructura "writeParaRecord" a las variables homónimas de la
estructura "#writeBYTE". Para mayor claridad, las variables de la estructura
"writeParaRecord" se muestran como nombres explícitos.

Resultado del segmento 6:
Si el parámetro de entrada REQ ("startWrite") devuelve el estado lógico "TRUE", se inicia la
instrucción "WRREC".
En el parámetro RECORD ("#writeBYTE") se depositan los datos nuevos del juego de datos.
Durante varias llamadas, la instrucción "WRREC" escribe los datos nuevos en el juego de
datos "3". De acuerdo con el valor del parámetro de entrada LEN ("maxWriteLength"), la
información que debe escribirse del juego de datos está limitada a 4 bytes.
Durante la ejecución, el parámetro de salida BUSY ("writeBusy") está ajustado a "TRUE" y
DONE ("#writeCheck") a "FALSE".
Una escritura correcta no se indica hasta finalizar la ejecución, tal como se muestra:
● El parámetro de salida DONE ("#writeCheck") se pone a "TRUE".
● Si "#writeCheck" devuelve el estado lógico "TRUE", la variable "writeCheckedValid" se
pone a "TRUE" de forma permanente.
En el parámetro de salida STATUS ("writeStatus") se indica el estado del bloque. La ejecución
transcurre sin errores.

Resultado del segmento 7:
Si "writeError" devuelve el estado lógico "TRUE", el valor de la variable "writeStatus" se guarda
en la variable "wrMemErrStat".

2412

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Resultado del segmento 8:
Una vez ha finalizado la ejecución de la instrucción "WRREC", "writeStatus" devuelve el valor
"16#0070_0200". Seguidamente, el desactivador pone la variable "startWrite" a "FALSE". La
variable "startRead" se pone a "TRUE", con lo que la instrucción "RDREC" vuelve a ejecutarse
desde el principio. La estructura "readParaRecord" muestra los valores del juego de datos que
acaban de escribirse. Puesto que en "InputDelay_ProcessEvent" el bit 0 devuelve el estado
lógico "TRUE", ahora el canal 3 tiene un retardo a la entrada de 0,1 ms.

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
WRREC: Escribir registro (Página 2401)
RDREC: Leer registro (Página 2382)

Utilizar el ejemplo de programa para el juego de datos de control con WRREC y RDREC
Introducción
En el ejemplo siguiente se escribe el juego de datos de control 196 mediante WRREC y se lee
mediante RDREC para su comprobación. Para la configuración se selecciona la configuración
centralizada de un S7-1500.
Encontrará información adicional sobre los juegos de datos en Descripción general de los tipos
de juegos de datos (Página 2375).

Programación del PLC
Manual de programación y manejo, 11/2019

2413

Instrucciones
4.1 Instrucciones

Requisitos
Nota
Activación del control de configuración
Para que sea posible escribir el juego de datos de control debe estar activado el control de
configuración (configuración futura) de la CPU. Lo encontrará en "Propiedades de la CPU >
Control de configuración".
Para almacenar los datos deben crearse las variables siguientes en un bloque de datos global:
● Tres variables de uso general y seis para WRREC:

● Una estructura para los datos en WRREC (juego de datos 196):

El juego de datos tiene la siguiente estructura:
– "BlockLength" indica la longitud del juego de datos en Byte.
–

"BlockID" indica el número del juego de datos.

– "Version" indica el tipo de configuración. Para el ejemplo se utiliza una configuración
centralizada. En una configuración centralizada, "Subversion" tiene el valor "0".
– "Slot_0" a "Slot_.." corresponden a los slots utilizados. Los valores de los slots indican
la numeración que se utiliza.

2414

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● seis variables para RDREC:

● una estructura para los datos en RDREC:

La instrucción "WRREC" para escribir el juego de datos de control debe llamarse en un OB de
arranque. En el OB de arranque se crean las variables locales siguientes para redistribuir los
datos:

En un FB se crean las siguientes variables locales. El FB se llama en un OB de ciclo de
programa (OB1).

Programación del PLC
Manual de programación y manejo, 11/2019

2415

Instrucciones
4.1 Instrucciones

Interconectar parámetros en el OB de arranque
Segmento 1: A continuación se interconectan los parámetros de la instrucción "WRREC".

Segmento 2: A continuación se interconectan los parámetros para el caso de error de WRREC.

Segmento 3: A continuación se interconectan los parámetros para finalizar WRREC.

2416

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Segmento 4: A continuación se interconectan los parámetros para consultar la llamada
repetitiva de WRREC.

Interconectar parámetros en el FB
Segmento 1: A continuación se interconectan los parámetros de la instrucción "RDREC".

Segmento 2: A continuación se interconectan los parámetros para el caso de error de RDREC.

Programación del PLC
Manual de programación y manejo, 11/2019

2417

Instrucciones
4.1 Instrucciones

Segmento 3: A continuación se interconectan los parámetros para finalizar RDREC.

Parámetros generales
El identificador de hardware correspondiente a la configuración de la CPU ("33") se almacena
mediante el parámetro de entrada ID ("id"). El juego de datos de control ("196") se almacena
mediante el parámetro de entrada INDEX ("dataRecNbr"). De acuerdo con el valor de la
variable "maxLength" (con el valor "0"), la cantidad de información del juego de datos que debe
tenerse en cuenta es ilimitada.
Nota
Carga en la CPU y procesamiento del programa en el arranque
1. Ponga la CPU en modo "STOP". A continuación cargue el programa en la CPU.
2. Ponga el proyecto en modo "Online".
3. Ponga la CPU en modo "RUN". Se procesa el modo "Arranque".
En el estado "Arranque", la CPU ejecuta las partes del programa que se encuentran en el OB
de arranque.

OB de arranque: Resultado del segmento 1
Puesto que el parámetro de entrada REQ devuelve el estado lógico "TRUE", se inicia la
instrucción "WRREC". El contacto NC ("configDone") tiene el estado lógico "FALSE".
En el parámetro RECORD ("recConfigCtrl_WR") se depositan los datos del juego de datos de
control. Para mayor claridad, las variables de la estructura "recConfigCtrl_WR" se muestran
como nombres explícitos y tienen la misma estructura que la descrita en el manual de sistema.

2418

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Durante varias llamadas, la instrucción "WRREC" escribe los datos en el juego de datos de
control. Durante la ejecución de WRREC, el parámetro de salida BUSY ("busyWR") está
ajustado a "TRUE" y DONE ("#checkWR") a "FALSE".
Una escritura correcta no se indica hasta finalizar la ejecución, tal como se muestra:
● El parámetro de salida DONE ("#checkWR") se pone a "TRUE" y pone la variable
"checkedValid_WR" a "TRUE" de forma permanente.
En el parámetro de salida STATUS ("statusWR") se indica el estado del bloque. La ejecución
transcurre sin errores.

OB de arranque: Resultado del segmento 2
En caso de error en el procesamiento de WRREC:
Si "errorWR" devuelve el estado lógico "TRUE", el valor de la variable "statusWR" se guarda
en la variable "memErrStatusWR".

OB de arranque: Resultado del segmento 3
Una vez ha finalizado la ejecución de la instrucción "WRREC", "statusWR" devuelve el valor
"16#0070_0200". A continuación, la variable "configDone" se pone a "TRUE". Con ello finaliza
la ejecución de WRREC.

OB de arranque: Resultado del segmento 4
Mientras la ejecución de la instrucción "WRREC" no haya finalizado ("configDone" tiene el
valor "FALSE" y "busyWR" tiene el valor "TRUE"), la ejecución retrocede hasta el segmento 1.

Programación del PLC
Manual de programación y manejo, 11/2019

2419

Instrucciones
4.1 Instrucciones

FB: Resultado del segmento 1
Una vez se han ejecutado las secciones del programa que hay en el OB de arranque, la CPU
está en estado "RUN".
Si el parámetro de entrada EN ("configDone") devuelve el estado lógico "TRUE", la instrucción
"RDREC" está habilitada para su ejecución. Si el parámetro de entrada REQ ("startRead")
devuelve el estado lógico "TRUE", se inicia la instrucción "RDREC".
Durante varias llamadas, la instrucción "RDREC" lee el juego de datos de control y lo guarda
mediante el parámetro RECORD ("recConfigCtrl_RD").

La longitud del juego de datos leído se recoge en el parámetro de salida LEN ("#readLength").
Durante la ejecución de RDREC, el parámetro de salida BUSY ("busyRD") está ajustado a
"TRUE" y VALID ("#checkRD") a "FALSE".
Una lectura correcta no se indica hasta finalizar la ejecución, tal como se muestra:
● El parámetro de salida VALID ("#checkRD") se pone a "TRUE". Seguidamente, #checkRD
pone la variable "checkedValid_RD" a "TRUE" de forma permanente.
● Además, el valor de la variable local "#lengthRD" se guarda de forma permanente en la
variable "lengthRD".
En el parámetro de salida STATUS ("statusRD") se indica el estado del bloque. La ejecución
transcurre sin errores.

FB: Resultado del segmento 2
En caso de error en el procesamiento de RDREC:
Si "errorRD" devuelve el estado lógico "TRUE", el valor de la variable "statusRD" se guarda en
la variable local "#memErrStatus".

FB: Resultado del segmento 3
Una vez ha finalizado la ejecución de la instrucción "RDREC" y se han comprobado los datos,
"#checkRD" devuelve el valor "TRUE". A continuación, la variable "startRead" se pone a
"FALSE". Se finaliza la ejecución de la instrucción "RDREC".

2420

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
WRREC: Escribir registro (Página 2401)
RDREC: Leer registro (Página 2382)

GETIO: Leer todas las entradas de un submódulo
Descripción
Con la instrucción "GETIO" se leen de modo coherente todas las entradas de un submódulo
de un esclavo DP normalizado/dispositivo PROFINET IO. Si no se ha producido ningún error
durante la transferencia de datos, los datos leídos se registran en el área de destino del
parámetro INPUTS .
Para el área de destino se aplica lo siguiente:
● Si para el componente seleccionado se ha configurado una longitud de un byte
exactamente, el área de destino deberá tener una longitud mínima de un byte.
● Si para el componente seleccionado se ha configurado una longitud de varios bytes, el área
de destino deberá tener como mínimo la misma longitud que el número de bytes
configurados.
En un esclavo DP normalizado con estructura modular o con varias ID de DP, la llamada con
"GETIO" solo permite acceder cada vez a los datos de un solo componente o ID de DP en la
dirección inicial configurada.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GETIO":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ID

Input

HW_SUBMO‐
DULE

I, Q, M, D, L o constante ID de hardware del submódulo

STATUS

Output

DWORD

I, Q, M, D, L

Información de error

LEN

Output

INT

I, Q, M, D, L

Número de datos leídos, en bytes

INPUTS

InOut

VARIANT

I, Q, M, D, L

Área de destino para los datos leídos. Debe
tener como mínimo la misma longitud que la
configurada para el submódulo selecciona‐
do.
Se recomienda utilizar únicamente el tipo de
datos BYTE o ARRAY of BYTE .

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2421

Instrucciones
4.1 Instrucciones

Parámetro STATUS
Código de
error*
(DW#16#...)

Explicación

40000000

No ha ocurrido ningún error

40809000

No se ha indicado ninguna ID de hardware como dirección en el parámetro ID .

40809200

Tipo de datos no soportado en el parámetro INPUTS (Wchar, Array of Wchar , Wstring o Array of Wstring)

40809300

El submódulo direccionado a través de ID no tiene ninguna entrada.

4080A000

Se ha detectado un error de acceso al acceder a la periferia.

4080B100

La longitud del área de destino especificada en el parámetro INPUTS es más corta que la longitud de datos
de usuario configurada.

Información
Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)
de error gene‐
ral
* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para GETIO y SETIO (Página 2424).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
DPRD_DAT: Leer datos coherentes de un esclavo DP normalizado (Página 2510)
Cambiar formatos de visualización en el estado del programa (Página 8529)

SETIO: Escribir todas las salidas de un submódulo
Descripción
Con la instrucción "SETIO" se transmiten datos desde un área fuente de forma coherente a las
salidas de un submódulo y a la correspondiente memoria imagen de proceso de las salidas.
El área fuente debe tener como mínimo la misma longitud que la configurada para el
submódulo seleccionado.
En un esclavo DP normalizado/dispositivo PROFINET IO con estructura modular o con varias
ID, la llamada de "SETIO" permite acceder a los datos de un solo componente o ID de DP.

2422

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SETIO":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ID

Input

HW_SUBMO‐
DULE

I, Q, M, D, L o cons‐
tante

ID de hardware del submódulo

STATUS

Output

DWORD

I, Q, M, D, L

Información de error

OUTPUTS

InOut

VARIANT

I, Q, M, D, L

Área fuente para los datos que se deben
escribir. Debe tener como mínimo la mis‐
ma longitud que la configurada para el
submódulo seleccionado.
Se recomienda utilizar únicamente el tipo
de datos BYTE o ARRAY of BYTE.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de
error*
(DW#16#...)

Explicación

40000000

No ha ocurrido ningún error

40809000

No se ha indicado ninguna ID de hardware como dirección en el parámetro ID .

40809200

Tipo de datos no soportado en el parámetro OUTPUTS (Wchar, Array of Wchar , Wstring o Array of Wstring)

40809300

El submódulo direccionado a través de ID no tiene ninguna salida.

4080A000

Se ha detectado un error de acceso al acceder a la periferia.

4080B100

La longitud del área fuente indicada en el parámetro OUTPUTS es inferior a la longitud de las salidas.

Información
Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)
de error gene‐
ral
* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para GETIO y SETIO (Página 2424).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
DPWR_DAT: Escribir datos coherentes de un esclavo DP normalizado (Página 2512)
Cambiar formatos de visualización en el estado del programa (Página 8529)

Programación del PLC
Manual de programación y manejo, 11/2019

2423

Instrucciones
4.1 Instrucciones

Ejemplo de programa para GETIO y SETIO
Introducción
En el siguiente ejemplo se leen los canales de un módulo de entradas digitales mediante
GETIO y se escriben nuevos valores en los canales de un módulo de salidas digitales mediante
SETIO. A continuación se leen los cambios mediante GETIO y a través del módulo de entradas
digitales.

2424

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Requisitos
● Hay creado un dispositivo IO / esclavo DP con un módulo de entradas digitales y un módulo
de salidas digitales.
Nota
Modificar con SETIO, leer los cambios con GETIO.
El módulo de entradas digitales debe estar conectado con el módulo de salidas digitales
para que los valores escritos mediante SETIO puedan leerse con GETIO.
● Para almacenar los datos es preciso crear nueve variables y las dos estructuras
"readinputs" y "writeOutputs" en un bloque de datos global.
Mediante la variable "id_Read" se guarda el identificador de hardware del módulo de
entradas digitales. Mediante la variable "id_Write" se guarda el identificador de hardware
del módulo de salidas digitales.
Nota
Buscar identificador de hardware
El identificador de hardware se encuentra en "Variables PLC > Constantes de sistema". P.
ej., para el módulo de entradas digitales busque "Local~<Nombre del módulo DI>", con el
tipo de datos "HW_Submodule". La celda "Valor" correspondiente contiene el identificador
de hardware.

Programación del PLC
Manual de programación y manejo, 11/2019

2425

Instrucciones
4.1 Instrucciones
● Para reenviar los datos deben crearse las siguientes variables locales en un FB
"SLI_FB_GETIO_SETIO".

● Para modificar los estados de los canales, en el bloque de datos global se ponen a "TRUE"
los bits siguientes (canales 1 y 2):

Interconectar parámetro: FC "SLI_itemiseByte_gsIO"
Para reenviar los valores de una secuencia de bits (0..7) debe crearse la FC
"SLI_itemiseByte_gsIO".
En ella se crean las siguientes variables locales.

2426

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 1: Siguiendo el ejemplo del segmento 1 se crean interconexiones para todos los bits
(0..7).

Interconectar parámetro: FB "SLI_FB_GETIO_SETIO"
En el FB "SLI_FB_GETIO_SETIO" se crean las interconexiones siguientes. A continuación, en
el dispositivo IO / esclavo DP se llama el FB "SLI_FB_GETIO_SETIO" en un OB de ciclo de
programa (OB1).
Segmento 1: Los parámetros de la instrucción "GETIO" se interconectan del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2427

Instrucciones
4.1 Instrucciones
Segmento 2: La instrucción "GETIO" se finaliza del siguiente modo.

Segmento 3: Para convertir los valores de canal de GETIO se crean las interconexiones según
el ejemplo siguiente. Se interconectan todas las entradas y salidas (0..7) de la FC
"SLI_itemiseByte_gsIO".

Segmento 4: Para convertir los valores de canal de SETIO se crean las interconexiones según
el ejemplo siguiente. Se interconectan todas las entradas y salidas (0..7) de la FC
"SLI_itemiseByte_gsIO".

Segmento 5: Los parámetros de la instrucción "SETIO" se interconectan del siguiente modo.

2428

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 6: La instrucción "SETIO" se finaliza del siguiente modo.

Resultado del segmento 1 (GETIO)
Si el parámetro de entrada EN ("executeRead") devuelve el estado lógico "TRUE", se inicia la
instrucción "GETIO". Mediante el parámetro de entrada ID ("id_Read"), la instrucción "GETIO"
llama el módulo de entradas. Mediante el parámetro de entrada INPUTS ("#readBYTE") se
leen los canales del módulo de entradas. La longitud de los canales leídos en BYTE se
deposita en el parámetro de salida LEN ("lengthRead"). El valor "2" hace referencia a 16
canales de entrada.
En el parámetro de salida STATUS ("statusRead") se indica el estado del bloque. La ejecución
transcurre sin errores.

Resultado del segmento 2 (GETIO)
Una vez que ha finalizado la ejecución de la instrucción "GETIO", el parámetro de salida ENO
("doneRead") devuelve el estado lógico "TRUE". Seguidamente, el desactivador pone la
variable "executeRead" a "FALSE" y finaliza la ejecución de GETIO.

Programación del PLC
Manual de programación y manejo, 11/2019

2429

Instrucciones
4.1 Instrucciones

Resultado del segmento 3 (GETIO)
Mediante la FC "SLI_itemiseByte_gsIO" se transfieren los valores de las variables de la
estructura "#readBYTE" a las variables de la estructura "readInputs". Los valores de los
canales 0..7 y 8..15 se convierten de BYTE a Array of BOOL.
Para mayor claridad, las variables de la estructura "readInputs" se muestran como nombres
explícitos.

Resultado del segmento 4 (SETIO)
Mediante la FC "SLI_itemiseByte_gsIO" se transfieren los valores de las variables de la
estructura "writeOutputs" a las variables de la estructura "#writeBYTE". Los valores de los
canales 0..7 y 8..15 se convierten de Array of BOOL a BYTE.
Para mayor claridad, las variables de la estructura "writeOutputs" se muestran como nombres
explícitos.

Resultado del segmento 5 (SETIO)
Si el parámetro de entrada EN ("executeWrite") devuelve el estado lógico "TRUE", se inicia la
instrucción "SETIO". Mediante el parámetro de entrada ID ("id_Write"), la instrucción "SETIO"
llama el módulo de salidas. Mediante el parámetro de entrada OUTPUTS ("#writeBYTE") se
escriben nuevos valores en los canales del módulo de salidas.
En el parámetro de salida STATUS ("statusWrite") se indica el estado del bloque. La ejecución
transcurre sin errores.

Resultado del segmento 6 (SETIO)
Una vez que ha finalizado la ejecución de la instrucción "SETIO", el parámetro de salida ENO
("doneWrite") devuelve el estado lógico "TRUE". Seguidamente, el desactivador pone la
variable "executeWrite" a "FALSE" y finaliza la ejecución de SETIO.

2430

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Resultado de una nueva ejecución de GETIO
Si la variable "executeRead" se pone de nuevo a "TRUE", tras ejecutar GETIO la estructura
"readInputs" indica los nuevos valores en los canales del módulo de entradas. Entonces los
canales 1 y 2 ("Channel_0-7[1]..[2]") devuelven el estado lógico "TRUE".

Nota
Modificar el estado lógico de un canal
Si un canal cuyo estado lógico va a cambiarse ya está ocupado con un valor (p. ej. por una
variable PLC), ese estado lógico puede hacer que el cambio mediante SETIO no tenga ningún
efecto. Asegúrese de que el estado lógico de un canal que se va a modificar no está
predeterminado por otros factores.

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
GETIO: Leer todas las entradas de un submódulo (Página 2421)
SETIO: Escribir todas las salidas de un submódulo (Página 2422)

GETIO_PART: Leer entradas de un submódulo
Descripción
La instrucción "GETIO_PART" permite leer de forma coherente una parte conexa de las
entradas de un submódulo.
Con el parámetro de entrada ID se selecciona el submódulo.
Con los parámetros OFFSET y LEN se define la porción que se debe leer de las entradas del
submódulo.

Programación del PLC
Manual de programación y manejo, 11/2019

2431

Instrucciones
4.1 Instrucciones
La longitud del área de destino debe ser superior o igual al número de bytes que se van a leer:
● Si no se ha producido ningún error durante la transferencia de datos, ERROR adquiere el
valor FALSE. Los datos leídos se escriben en el área de destino definida en el parámetro
INPUTS.
● Si se ha producido algún error durante la transferencia de datos, ERROR adquiere el valor
TRUE. El parámetro STATUS contiene la información de error:
● Si el área de destino es mayor que LEN, se escriben los primeros LEN bytes del área de
destino. ERROR adquiere el valor FALSE.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GETIO_PART":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ID

Input

HW_SUBMO‐
DULE

I, Q, M, D, L o constan‐ ID de hardware del submódulo
te

OFFSET

Input

INT

I, Q, M, D, L o constan‐ Número del primer byte del submódulo
te
que se debe leer (valor más pequeño po‐
sible: 0)

LEN

Input

INT

I, Q, M, D, L o constan‐ Número de bytes que deben leerse
te

STATUS

Output

DWORD

I, Q, M, D, L

Información del error, si ERROR = TRUE

ERROR

Output

BOOL

I, Q, M, D, L

Visualización de error: ERROR = TRUE,
en caso de que se produzca un error

INPUTS

InOut

VARIANT

I, Q, M, D, L

Área de destino para los datos leídos:
Si el área de destino es mayor que LEN,
se escriben los primeros bytes LEN del
área de destino.
Se recomienda utilizar únicamente el tipo
de datos BYTE o ARRAY of BYTE .

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de
error*
(DW#16#...)

Explicación

40000000

No ha ocurrido ningún error

40809000

No se ha indicado ninguna ID de hardware como dirección en el parámetro ID .

40809200

Tipo de datos no soportado en el parámetro INPUTS (Wchar, Array of Wchar , Wstring o Array of Wstring)

40809300

El submódulo direccionado a través de ID no tiene ninguna entrada.

4080A000

Se ha detectado un error de acceso al acceder a la periferia.

4080B100

La longitud del área de destino especificada en el parámetro INPUTS es inferior a la longitud de datos
indicada en LEN.

4080B700

El área establecida con OFFSET y LEN no queda completamente cubierta por el submódulo.

2432

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*
(DW#16#...)

Explicación

Información
Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)
de error gene‐
ral
* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para GETIO_PART y SETIO_PART
(Página 2435).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
DPRD_DAT: Leer datos coherentes de un esclavo DP normalizado (Página 2510)
Cambiar formatos de visualización en el estado del programa (Página 8529)

SETIO_PART: Escribir salidas de un submódulo
Descripción
Con la instrucción "SETIO_PART" se escriben datos desde un área fuente de forma coherente
a las salidas de un submódulo y a la memoria imagen de proceso de las salidas
correspondiente.
Con el parámetro de entrada ID se selecciona el submódulo.
Con los parámetros OFFSET y LEN se define la porción de las salidas del submódulo y de la
memoria imagen de proceso de las salidas que debe escribirse.
La longitud del área fuente debe ser superior o igual al número de bytes que se van a escribir:
● Si no se ha producido ningún error durante la transferencia de datos, ERROR adquiere el
valor FALSE.
● Si se ha producido algún error durante la transferencia de datos, ERROR adquiere el valor
TRUE. El parámetro STATUS contiene la información de error:
● Si el área fuente es mayor que LEN, se transfieren los primeros bytes LEN de OUTPUTS.
ERROR adquiere el valor FALSE.

Programación del PLC
Manual de programación y manejo, 11/2019

2433

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SETIO_PART":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ID

Input

HW_SUBMO‐
DULE

I, Q, M, D, L o constante ID de hardware del submódulo

OFFSET

Input

INT

I, Q, M, D, L o constante Número del primer byte que se debe escribir
en el submódulo (valor más pequeño posi‐
ble: 0).

LEN

Input

INT

I, Q, M, D, L o constante Número de bytes que se van a escribir

STATUS

Output

DWORD

I, Q, M, D, L

Información del error, si ERROR = TRUE

ERROR

Output

BOOL

I, Q, M, D, L

Visualización de error: ERROR = TRUE, en
caso de que se produzca un error.

OUTPUTS

InOut

VARIANT

I, Q, M, D, L

Área fuente para los datos que se deben
escribir:
Si el área fuente es mayor que LEN, se
transmiten los primeros bytes LEN de OUT‐
PUTS.
Se recomienda utilizar únicamente el tipo de
datos BYTE o ARRAY of BYTE.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de
error*
(DW#16#...)

Explicación

40000000

No ha ocurrido ningún error

40809000

No se ha indicado ninguna ID de hardware como dirección en el parámetro ID .

40809200

Tipo de datos no soportado en el parámetro OUTPUTS (Wchar, Array of Wchar , Wstring o Array of Wstring)

40809300

El submódulo direccionado a través de ID no tiene ninguna salida.

4080A000

Se ha detectado un error de acceso al acceder a la periferia.

4080B100

La longitud del área fuente especificada en el parámetro OUTPUTS es inferior a la longitud de datos indicada
en LEN.

4080B700

El área establecida con OFFSET y LEN no queda completamente cubierta por el submódulo.

Información
Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)
de error gene‐
ral
* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para GETIO_PART y SETIO_PART
(Página 2435).

2434

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
DPWR_DAT: Escribir datos coherentes de un esclavo DP normalizado (Página 2512)
Cambiar formatos de visualización en el estado del programa (Página 8529)

Ejemplo de programa para GETIO_PART y SETIO_PART
Introducción
En el siguiente ejemplo se leen los canales de un módulo de entradas digitales mediante
GETIO_PART y se escriben nuevos valores en una parte de los canales de un módulo de
salidas digitales mediante SETIO_PART. A continuación se leen los cambios mediante
GETIO_PART y a través del módulo de entradas digitales.

Programación del PLC
Manual de programación y manejo, 11/2019

2435

Instrucciones
4.1 Instrucciones

Requisitos
● Hay creado un dispositivo IO / esclavo DP con un módulo de entradas digitales y un módulo
de salidas digitales.
Nota
Modificar con SETIO_PART, leer los cambios con GETIO_PART.
El módulo de entradas digitales debe estar conectado con el módulo de salidas digitales
para que los valores escritos mediante SETIO_PART puedan leerse con GETIO_PART.
● Para almacenar los datos es preciso crear 14 variables y las estructuras "readinputs" y
"writeOutputs" en un bloque de datos global.
Mediante la variable "id_Read" se guarda el identificador de hardware del módulo de
entradas digitales. Mediante la variable "id_Write" se guarda el identificador de hardware
del módulo de salidas digitales.
Nota
Buscar identificador de hardware
El identificador de hardware se encuentra en "Variables PLC > Constantes de sistema". P.
ej., para el módulo de entradas digitales busque "Local~<Nombre del módulo DI>", con el
tipo de datos "HW_Submodule". La celda "Valor" correspondiente contiene el identificador
de hardware.

2436

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● Para modificar los estados de canal (para BYTE 0 y BYTE 1), ponga a "TRUE" los
siguientes bits del bloque de datos global:

● Para reenviar los datos deben crearse las siguientes variables locales en un FB
"SLI_FB_GETIO_SETIO_PART".

Interconectar parámetro: FC "SLI_itemiseByte_gpspIO"
Para reenviar los valores de una secuencia de bits (0..7) debe crearse la FC
"SLI_itemiseByte_gpspIO".
En ella se crean las siguientes variables locales.

Programación del PLC
Manual de programación y manejo, 11/2019

2437

Instrucciones
4.1 Instrucciones
Segmento 1: Siguiendo el ejemplo del segmento 1 se crean interconexiones para todos los bits
(0..7).

Interconectar parámetro: FB "SLI_FB_GETIO_SETIO_PART"
En el FB "SLI_FB_GETIO_SETIO_PART" se crean las interconexiones siguientes. A
continuación, en el dispositivo IO / esclavo DP se llama el FB "SLI_FB_GETIO_SETIO_PART"
en un OB de ciclo de programa (OB1).
Segmento 1: Los parámetros de la instrucción "GETIO_PART" se interconectan del siguiente
modo.

Segmento 2: La instrucción "GETIO_PART" se finaliza del siguiente modo.

Segmento 3: Para convertir los valores de canal de GETIO_PART se crean las interconexiones
según el ejemplo siguiente. Se interconectan todas las entradas y salidas (0..7) de la FC
"SLI_itemiseByte_gpspIO".

2438

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 4: Para convertir los valores de canal de SETIO_PART se crean las interconexiones
según el ejemplo siguiente. Se interconectan todas las entradas y salidas (0..7) de la FC
"SLI_itemiseByte_gpspIO".

Segmento 5: Los parámetros de la instrucción "SETIO_PART" se interconectan del siguiente
modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2439

Instrucciones
4.1 Instrucciones

Segmento 6: La instrucción "SETIO_PART" se finaliza del siguiente modo.

Resultado del segmento 1 (GETIO_PART)
Si el parámetro de entrada EN ("executeRead") devuelve el estado lógico "TRUE", se inicia la
instrucción "GETIO_PART". Mediante el parámetro de entrada ID ("id_Read"), la instrucción
"GETIO_PART" llama el módulo de entradas. Mediante el parámetro de entrada INPUTS
("#readBYTE") se leen los canales del módulo de entradas.
Mediante el parámetro de entrada OFFSET ("firstByteRead") con el valor "0" la instrucción
"GETIO_PART" empieza a leer los canales del módulo de entradas a partir del "BYTE 0". De
acuerdo con el valor "2" del parámetro de entrada LEN ("maxLengthRead") se leen dos BYTE
(16 canales). En este ejemplo este valor corresponde a los canales 0..15.
En el parámetro de salida STATUS ("statusRead") y ERROR ("errorRead") se indica el estado
del bloque. La ejecución transcurre sin errores.

2440

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Resultado del segmento 2 (GETIO_PART)
Una vez que ha finalizado la ejecución de la instrucción "GETIO_PART", el parámetro de salida
ENO ("doneRead") devuelve el estado lógico "TRUE". Seguidamente, el desactivador pone la
variable "executeRead" a "FALSE" y finaliza la ejecución de GETIO_PART.

Resultado del segmento 3 (GETIO_PART)
Mediante la FC "SLI_itemiseByte_gpspIO" se transfieren los valores de las variables de la
estructura "#readBYTE" a las variables de la estructura "readInputs". Los valores de los
canales 0..7 y 8..15 se convierten de BYTE a Array of BOOL.
Para mayor claridad, las variables de la estructura "readInputs" se muestran como nombres
explícitos.

Programación del PLC
Manual de programación y manejo, 11/2019

2441

Instrucciones
4.1 Instrucciones

Resultado del segmento 4 (SETIO_PART)
Mediante la FC "SLI_itemiseByte_gpspIO" se transfieren los valores de las variables de la
estructura "writeOutputs" a las variables de la estructura "#writeBYTE". Los valores de los
canales 0..7 y 8..15 se convierten de Array of BOOL a BYTE.
Para mayor claridad, las variables de la estructura "writeOutputs" se muestran como nombres
explícitos.

Resultado del segmento 5 (SETIO_PART)
Si el parámetro de entrada EN ("executeWrite") devuelve el estado lógico "TRUE", se inicia la
instrucción "SETIO_PART". Mediante el parámetro de entrada ID ("id_Write"), la instrucción
"SETIO_PART" llama el módulo de salidas. Mediante el parámetro de entrada OUTPUTS
("#writeBYTE") se escriben nuevos valores en los canales del módulo de salidas.
Mediante el parámetro de entrada OFFSET ("firstByteWrite") con el valor "0" la instrucción
"SETIO_PART" comienza a escribir los canales del módulo de salidas a partir del "BYTE 0". De
acuerdo con el valor "1" del parámetro de entrada LEN ("maxLengthWrite") se escribe solo un
BYTE (8 canales). En este ejemplo este valor corresponde a los canales 0..7. Por tanto, al
escribir en los canales del módulo de salidas no se tiene en cuenta el canal 9 (véase
"writeOutputs", "Channel_8-15[1]") puesto al valor "TRUE".
En el parámetro de salida STATUS ("statusWrite") y ERROR ("errorWrite") se indica el estado
del bloque. La ejecución transcurre sin errores.

2442

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Resultado del segmento 6 (SETIO_PART)
Una vez que ha finalizado la ejecución de la instrucción "SETIO_PART", el parámetro de salida
ENO ("doneWrite") devuelve el estado lógico "TRUE". Seguidamente, el desactivador pone la
variable "executeWrite" a "FALSE" y finaliza la ejecución de SETIO_PART.

Resultado de una nueva ejecución de GETIO_PART
Si la variable "executeRead" se pone de nuevo a "TRUE", tras ejecutar GETIO_PART la
estructura "readInputs" indica los nuevos valores en los canales del módulo de entradas. De
acuerdo con los valores de las variables "firstByteWrite" y "maxLengthWrite", una modificación
solo afecta a los canales 0..7. Entonces los canales 1 y 2 ("Channel_0-7[1]..[2]") devuelven el
estado lógico "TRUE". El estado de señal del canal 9 ("Channel_8-15[1]") no cambia.

Nota
Modificar el estado lógico de un canal
Si un canal cuyo estado lógico va a cambiarse ya está ocupado con un valor (p. ej. por una
variable PLC), ese estado lógico puede hacer que el cambio mediante SETIO_PART no tenga
ningún efecto. Asegúrese de que el estado lógico de un canal que se va a modificar no está
predeterminado por otros factores.

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Programación del PLC
Manual de programación y manejo, 11/2019

2443

Instrucciones
4.1 Instrucciones

Consulte también
GETIO_PART: Leer entradas de un submódulo (Página 2431)
SETIO_PART: Escribir salidas de un submódulo (Página 2433)

RALRM: Recibir alarma
Descripción de RALRM
Descripción
La instrucción recibe una alarma, junto con la información correspondiente, desde un módulo
de periferia (configuración centralizada) o desde un módulo de un esclavo DP o un dispositivo
PROFINET IO. Esta información se proporciona a través de sus parámetros de salida.
Los parámetros de salida ofrecen tanto la información de arranque del OB llamado como
información sobre el origen de la alarma.
La composición de la estructura de datos del área de destino AINFO equivale a la estructura
de datos de PROFINET IO para una instalación central.
Llame a "RALRM" solamente desde el OB de alarma que el sistema operativo de la CPU ha
arrancado a consecuencia de la alarma de la periferia que se debe analizar
Nota
Si se llama a "RALRM" en un OB cuyo evento de arranque no es una alarma de la periferia, la
instrucción proporcionará menos información a través de sus salidas.
Recuerde utilizar diferentes DB de instancia al llamar a "RALRM" en diferentes OB. Si se van
a evaluar los datos resultantes de una llamada de "RALRM" fuera del OB de alarma
correspondiente, utilice un DB de instancia independiente por cada evento de arranque de OB.
Nota
La interfaz de la instrucción "RALRM" es idéntica a la del FB "RALRM" definido en la norma
"PROFIBUS and PROFINET Guideline Communication Function Blocks on PROFIBUS DP
and PROFINET IO".

2444

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Llamada de RALRM
"RALRM" se puede llamar en tres modos de operación diferentes (parámetro MODE), que se
muestran en la siguiente tabla.
MODE

RALRM ...

0

... muestra el componente causante de la alarma en el parámetro de salida ID y escribe con TRUE en el
parámetro de salida NEW .

1

... escribe en todos los parámetros de salida, sea cual sea el componente causante de la alarma.

2

... comprueba si el componente especificado en el parámetro de entrada F_ID es el causante de la alarma.
● En caso negativo, NEW adquiere el valor FALSE.
● En caso afirmativo, NEW adquiere el valor TRUE, y se escriben todos los demás parámetros de salida.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RALRM":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MODE

Input

INT

I, Q, M, D, L o cons‐
tante

Modo de operación

F_ID

Input

HW_IO

I, Q, M, D, L o cons‐
tante

ID de hardware del módulo o submódulo
El número se asigna automáticamente y se guar‐
da en las propiedades del componente o de la
interfaz en la configuración hardware.

MLEN

Input

UINT

I, Q, M, D, L o cons‐
tante

Longitud máxima en bytes de la información de
alarma que se va a recibir.
Si MLEN = 0 se leen todos los datos especifica‐
dos en el parámetro AINFO.

NEW

Output

BOOL

I, Q, M, D, L

Se ha recibido una nueva alarma.

STATUS (Pá‐
gina 2447)

Output

DWORD

I, Q, M, D, L

Código de error

ID

Output

HW_IO

I, Q, M, D, L

ID de hardware del módulo o submódulo del que
se ha recibido una alarma.

LEN

Output

UINT

I, Q, M, D, L

Longitud de la información de alarma recibida

TINFO (Pági‐
na 2451)

InOut

VARIANT

D, L

Área de destino para la información de arranque
del OB y la información administrativa

AINFO (Pági‐
na 2469)

InOut

VARIANT

I, Q, M, D, L

Área de destino para información de encabeza‐
do e información adicional de alarma
Para AINFO reserve una longitud de por lo me‐
nos MLEN bytes.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".
Nota
Si el área de destino (Página 2476)TINFO o AINFO seleccionada es demasiado corta, RALRM
no registrará toda la información.

Programación del PLC
Manual de programación y manejo, 11/2019

2445

Instrucciones
4.1 Instrucciones

Caso especial para sistemas PC: Determinar el estado de Windows
El siguiente escenario le ayuda a obtener información sobre el estado de Windows de su
sistema PC:
● Llame a la instrucción "RALRM" (SFB54) en el OB82
La instrucción "RALRM" se llama con los siguientes parámetros de entrada:
Parámetro

Declaración

Tipo de datos

Área de memoria

Valor/Descripción

MODE

Input

INT

I, Q, M, D, L o constante

2

F_ID

Input

HW_IO

I, Q, M, D, L o constante

59 (Host Interface
RID)

MLEN

UINT

UINT

I, Q, M, D, L o constante

0

TINFO

InOut

VARIANT

D, L

Dirección para cada
área de 54 bytes

AINFO

InOut

VARIANT

I, Q, M, D, L

Dirección para cada
área de 54 bytes

En el caso de un controlador por software obtendrá información acerca del estado de Windows
con RALRM.
Los bytes 50 y 51 del parámetro "AINFO" se utilizan para obtener información detallada sobre
el estado de Windows. Si el byte 50 indica el valor W#16#40, podrá leer en el byte 51 la
siguiente información detallada del estado de Windows:
● 0xA1: Bluescreen
● 0xA2: Windows funciona
● 0xA3: Windows no funciona
Nota
Si se produce un fallo total del sistema, Windows ya no reacciona y muestra una pantalla
azul, que proporciona información sobre la causa y el momento de la caída del sistema. Por
defecto la pantalla azul permanece visible de forma permanente.
Tras el error de sistema este se detiene y puede presentarse el siguiente escenario:
● Windows deja de enviar señales a la CPU por software configurada

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para RALRM (Página 2477).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

2446

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro STATUS
Descripción
El parámetro de salida STATUS contiene información de error. Si se interpreta como
ARRAY[1...4] of BYTE, la información de error tiene la estructura siguiente:
Elemento de cam‐
po

Nombre

Significado

STATUS[1]

Function_Num

● B#16#00, si no hay ningún error
● ID de función de DPV1-PDU:
En caso de error se emite B#16#80 (en caso de error al leer un juego de datos
B#16#DE y al escribir un juego de datos B#16#DF).
Si no se utiliza ningún elemento de protocolo DPV1 se emite B#16#C0.

STATUS[2]

Error_Decode

Ubicación de la identificación de error

STATUS[3]

Error_Code_1

Identificación de error

STATUS[4]

Error_Code_2

Extensión específica del fabricante de la identificación de error

Elemento de campo STATUS[2]
STATUS[2] puede adoptar los siguientes valores:
Error_Decode
(B#16#...)

Origen

Significado

De 00 a 7F

CPU

Ningún error ni advertencia

80

DPV1

Error según IEC 61158-6

De 81 a 8F

CPU

B#16#8x indica un error en el x parámetro de llamada de la instrucción.

FE, FF

DP Profile

Error específico del perfil

Elemento de campo STATUS[3]
STATUS[3] puede adoptar los siguientes valores:
Error_Decode
(B#16#...)

Error_Code_1
(B#16#...)

00

00

70

00

reserved, reject

Primera llamada; no hay ninguna transferencia de juego de
datos activa

01

reserved, reject

Primera llamada; transferencia del juego de datos iniciada

02

reserved, reject

Llamada intermedia; transferencia del juego de datos ya
iniciada

Programación del PLC
Manual de programación y manejo, 11/2019

Explicación según
DPV1

Significado
Ningún error ni advertencia

2447

Instrucciones
4.1 Instrucciones
Error_Decode
(B#16#...)

Error_Code_1
(B#16#...)

80

81

Explicación según
DPV1

Significado
El tipo de datos de sistema del parámetro TINFO no cuadra
con el entorno de llamada de la instrucción.
El tipo de datos de sistema utilizado debe cuadrar con el
bloque de organización en el programa de usuario (ejem‐
plo: para un OB de alarma de retardo se requiere el tipo de
datos del sistema TI_Delay).

90

reserved, pass

● Dirección lógica inicial no válida
● Instrucciones RDREC y WRREC en una CPU S7-1500
R/H: no es posible el acceso al juego de datos, pues la
otra CPU está en estado operativo STOP.

92

reserved, pass

Tipo no admisible con puntero VARIANT

93

reserved, pass

El componente DP direccionado mediante ID o F_ID no es‐
tá configurado.

96

"RALRM (Página 2444)" no proporciona la información de
arranque del OB, la información de administración, la infor‐
mación de cabecera ni la información de alarma adicional.
En los OB 4x, 55, 56, 57, 82 y 83 se puede leer de manera
asíncrona el telegrama de diagnóstico actual del esclavo
DP afectado (información de dirección de información de
arranque del OB) con la instrucción "DPNRM_DG (Pági‐
na 2541)".

A0

read error

Respuesta negativa al leer el módulo

A1

write error

Respuesta negativa al escribir en el módulo

A2

module failure

Error de protocolo DP con Layer 2 (p. ej. fallo de esclavo o
fallos de bus)

A3

reserved, pass

Error general de comunicación o dispositivo IO / esclavo DP
no accesible

A4

reserved, pass

Fallo de comunicación en PBUS+

A5

reserved, pass

–

A7

reserved, pass

El esclavo DP o el módulo está ocupado en otra tarea (error
temporal)

A8

version conflict

El esclavo DP o el módulo notifica versiones no concordan‐
tes

A9

feature not suppor‐
ted

Función no soportada por el esclavo DP o el módulo

AA a AF

user specific

El esclavo DP o el módulo notifica un error específico del
fabricante en su aplicación. Consulte la documentación del
fabricante del esclavo DP o el módulo.

B0

invalid index

El módulo desconoce el juego de datos
No se admiten números de juegos de datos ≥ 256

B1

write length error

Error al indicar la longitud:
● Con "RALRM (Página 2444)": error de longitud
en AINFO (Página 2469)
● Con "RDREC (Página 2382)": error de longitud en MLEN
● Con "WRREC (Página 2401)": error de longitud en LEN

2448

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Error_Decode
(B#16#...)

Error_Code_1
(B#16#...)

Explicación según
DPV1

Significado

B2

invalid slot

● El slot configurado no está ocupado.
● Para PROFINET IO y PROFIBUS DP: dispositivo IO /
esclavo DP no accesible

B3

type conflict

El tipo de módulo real no coincide con el tipo de módulo
configurado

B4

invalid area

El esclavo DP o el módulo notifica un acceso a un área no
autorizada.

B5

state conflict

El esclavo DP o el módulo no está listo

B6

access denied

El esclavo DP o el módulo deniega el acceso

B7

invalid range

El esclavo DP o el módulo notifica un área no autorizada en
un parámetro o un valor

B8

invalid parameter

El esclavo DP o el módulo notifica un parámetro no autori‐
zado

B9

invalid type

El esclavo DP o el módulo notifica un tipo no autorizado
Con "RDREC (Página 2382)": búfer demasiado pequeño
(no es posible leer porciones)
Con "WRREC (Página 2401)": búfer demasiado pequeño
(no es posible escribir porciones)

BA

CPU S7-1500 R/H: La CPU primaria falla durante la lectura
o escritura de un juego de datos. La nueva CPU primaria
confirma la petición con 0x80BA. La petición de juego de
datos no se repite en la nueva CPU primaria.

BB a BF

user specific

El esclavo DP o el módulo notifica un error específico del
fabricante en el acceso. Consulte la documentación del fa‐
bricante del esclavo DP o el módulo.

C0

read constrain con‐
flict

Con "WRREC (Página 2401)": Los datos solo se escriben
en el estado STOP de la CPU. Nota: En consecuencia, el
programa de usuario no puede escribir. Los datos solo se
escriben online con la PG/el PC.
Con "RDREC (Página 2382)": El juego de datos está car‐
gado en el módulo, pero todavía no existen datos o los da‐
tos solo pueden leerse en el estado STOP de la CPU. Nota:
Si los datos solo pueden leerse en el estado STOP de la
CPU, el programa de usuario no puede evaluarlos. Por ello,
solo es posible leer los datos online con la programadora o
el PC.

C1

write constrain con‐
flict

Los datos de la petición de escritura efectuada anterior‐
mente en el módulo para el mismo juego de datos no han
sido procesados todavía por el módulo.

C2

resource busy

En este momento el módulo está procesando el máximo
posible de órdenes para una CPU.

C3

resource unavailable En este momento los recursos necesarios están ocupados.

C4

Error temporal interno. No se ha podido ejecutar la petición.
Repita la petición. Si este error se produce a menudo, com‐
pruebe si hay fuentes de perturbación en la instalación.

C5

El esclavo DP o el módulo no está disponible.

C6

Transferencia del juego de datos cancelada debido a una
interrupción de la clase de prioridad.

Programación del PLC
Manual de programación y manejo, 11/2019

2449

Instrucciones
4.1 Instrucciones
Error_Decode
(B#16#...)

81

Error_Code_1
(B#16#...)

Explicación según
DPV1

Significado

C7

Interrupción de la petición debido a rearranque completo
(en caliente) o arranque en frío del maestro DP.

C8 a CF

El esclavo DP o el módulo notifica a sus recursos un error
específico de fabricante. Consulte la documentación del fa‐
bricante del esclavo DP o el módulo.

Dx

user specific

Específico de esclavo DP. Ver descripción del esclavo DP.

Ex

user specific

Específico del fabricante. Consulte la documentación del
módulo.

00 a FF

Error en el primer parámetro de llamada (con "RALRM (Pá‐
gina 2444)": MODE)

00

Modo de operación no admisible

82

00 a FF

Error en el segundo parámetro de llamada

:

:

:

88

00 a FF

Error en el octavo parámetro de llamada (con "RALRM (Pá‐
gina 2444)": TINFO (Página 2451))

01

Identificación de sintaxis incorrecta

23

Rebase de la cantidad o zona de destino demasiado pe‐
queña

24

Identificación de zona incorrecta

32

N.º DB/DI fuera del área de usuario

3A

El N.º DB/DI es CERO en la identificación de zona DB/DI o
el DB/DI especificado no existe

00 a FF

Error en el noveno parámetro de llamada (con "RALRM
(Página 2444)": AINFO (Página 2469))

01

Identificación de sintaxis incorrecta

23

Rebase de la cantidad o zona de destino demasiado pe‐
queña

24

Identificación de zona incorrecta

32

N.º DB/DI fuera del área de usuario

3A

El N.º DB/DI es CERO en la identificación de zona DB/DI o
el DB/DI especificado no existe

8A

00 a FF

Error en el 10.º parámetro de llamada

:

:

:

8F

00 a FF

Error en el 15.º parámetro de llamada

FE, FF

00 a FF

Error específico del perfil

89

2450

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro TINFO
Estructura de datos del área de destino TINFO
La estructura de datos del área de destino TINFO contiene la información de arranque del
bloque de organización en el que se llamó a "RALRM".
El área de destino TINFO puede incluir la información de arranque con acceso estándar o
acceso optimizado. El formato de la información de arranque en el área de destino TINFO debe
corresponderse siempre con el de la información de arranque del respectivo bloque de
organización.
● La información de arranque de un OB con acceso estándar figura siempre en los primeros
20 bytes de la sección "Temp" de la interfaz del bloque. En este caso se utiliza la estructura
de datos "TI_Classic".
● La información de arranque de un OB con acceso optimizado se guarda en la sección
"Input". La información de arranque se guarda en las estructuras de datos específicas del
OB. Utilice la estructura de datos específica que corresponde al OB.
Cambiando el acceso a bloque (estándar/optimizado), también cambia la interfaz del bloque.
La siguiente tabla ofrece una lista de las estructuras de datos que se utilizan en función del
bloque de organización en el parámetro TINFO.
Nombre de la estructura
de datos

CPU
S7-1200 a
partir de
versión

CPU
S7-1500 a
partir de
versión

Estructura de datos utilizada para:

Estructura de datos para bloques de organización con acceso estándar
TI_Classic

-

V1

Bloques de organización sin acceso a bloque optimizado

Estructura de datos para bloques de organización con acceso a bloque optimizado

Programación del PLC
Manual de programación y manejo, 11/2019

2451

Instrucciones
4.1 Instrucciones
Nombre de la estructura
de datos

CPU
S7-1200 a
partir de
versión

CPU
S7-1500 a
partir de
versión

Estructura de datos utilizada para:

TI_ProgramCycle

V2

V1

OB de ciclo (Program cycle)

TI_Startup

V2

V1

OB de arranque (Startup)

TI_Delay

V2

V1

OB de alarma de retardo (Time delay interrupt)

TI_Cyclic

V2

V1

OB de alarma cíclica (Cyclic interrupt)

TI_HWInterrupt

V2

V1

OB de alarma de proceso (Hardware interrupt)

TI_HWInterrupt_Ex‐
tended

-

V2.0

OB de alarma de proceso (Hardware interrupt)

TI_TimeError

V2

V1

OB de error de tiempo (Time error interrupt)

TI_DiagnosticInterrupt

V2

V1

OB de alarma de diagnóstico (Diagnostic error interrupt)

TI_PlugPullModule

V2

V1

OB de cambio de módulo (Pull or plug of modules)

TI_StationFailure

V2

V1

OB de fallo del rack (Rack or station failure)

TI_ProgIOAccessError V2

V1

● OB de error de programación (Programming error)
● OB de error de acceso a la periferia (IO access error)

TI_TimeOfDay

V2

V1

OB de alarma horaria (Time of day)

TI_SynchCycle

-

V1

OB de alarma de sincronismo (Synchronous Cycle)

TI_Submodule

V2

V1

● OB de alarma de estado (Status)
● OB de alarma de actualización (Update)
● OB para la alarma específica del fabricante o perfil (Profile)

TI_CPURedundanc‐
yError_V2

2452

-

V2.6

OB de error de redundancia en CPU

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Estructura de datos para bloques de organización con acceso estándar
La estructura de datos TI_Classic está organizada de la manera siguiente:
Parámetro

Tipo de
datos

Byte

TI_Classic

Programación del PLC
Manual de programación y manejo, 11/2019

Descripción
Estructura de datos para bloques de organización sin acceso a bloque optimizado

2453

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de
datos

Byte

Descripción

Bytes 0 a 19: información de arranque del OB en el que se llamó a "RALRM".*
EV_CLASS

BYTE

0

Clase de evento
Ejemplo OB1:
● Bits 0-3: identificador del evento (1 = evento entrante)
● Bits 4-7: clase de evento (1 = clase de evento 1)

EV_NUM

BYTE

1

Número de evento (en función del tipo de OB)
Ejemplo OB1 (SCAN_1):
● SCAN_1 = 1 en primera llamada
● SCAN_1 = 3 en todas las demás llamadas

PRIORITY

BYTE

2

Clase de prioridad

NUM

BYTE

3

Número de OB

TYP2_3

BYTE

4

Información adicional

TYP1

BYTE

5

En los BYTES "TYP2_3" y "TYP1" se guardan diferentes informaciones en función
del tipo de OB utilizado.
Encontrará información al respecto en la documentación de los respectivos bloques
de organización.
Ejemplo (OB1):
● TYP2_3: OB1_RESERVED_1 (reservado)
● TYP1: OB1_RESERVED_2 (reservado)

ZI1

WORD

6a7

Información adicional
En "ZI1" se guardan diferentes informaciones en función del tipo de OB utilizado.
Encontrará información al respecto en la documentación de los respectivos bloques
de organización.
Ejemplo (OB1):
● ZI1: OB1_PREV_CYCLE (tiempo de ejecución del ciclo anterior en ms)

ZI2_3

DWORD

8 a 11

Información adicional
En "ZI2_3" se guardan diferentes informaciones en función del tipo de OB utilizado.
Encontrará información al respecto en la documentación de los respectivos bloques
de organización.
Ejemplo (OB1):
● ZI2: OB1_MIN_CYCLE (tiempo de ciclo mínimo (ms) desde el último arranque)
● ZI3: OB1_MAX_CYCLE (tiempo de ciclo máximo (ms) desde el último arranque)

OB_DA‐
TE_TIME

DA‐
de 12 a
TE_AND_ 19
TIME (DT)

Fecha y hora en las que se solicitó el OB.

Bytes 20 y 21: información de dirección
address

WORD

20 y 21

Información de dirección como en CPU S7-300/400:
● En caso de configuración centralizada, el número de rack (0-31):
%LW



































1¼PHURGHUDFN

● En caso de configuración descentralizada con PROFIBUS DP:

2454

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de
datos

Byte

Descripción
–

ID del sistema maestro DP (1-31)

–

Número de estación (0-127).
%LW



































1¼PHURGHHVWDFLµQ

,'GHOVLVWHPDPDHVWUR'3

● En caso de configuración descentralizada con PROFINET IO:
–

Las dos últimas posiciones del ID del sistema PROFINET IO (0-15); para
obtener el ID del sistema PROFINET IO completo, sume 100 (decimal)

–

Número de estación (0-2047)
%LW



















,'GHOVLVWHPD,2

















1¼PHURGHHVWDFLµQ

Bytes 22 a 31: Información administrativa
slv_prfl

BYTE

22

Perfil de esclavo como en CPU S7-300/400:
● En configuración centralizada: 0 (juego de datos 0 o juego de datos 1)
● En configuración descentralizada:

intr_type

BYTE

23

–

bits de 0 a 3: Tipo de esclavo
- 0000: DP (estructura juego de datos 0)
- 0001: DPS7 (estructura juego de datos 0 o juego de datos 1)
- 0010: DPS7 V1 (estructura juego de datos 0 o juego de datos 1)
- 0011: DPV1 (estructura según estándar PROFIBUS DP)
- 0100 – 0111: reservado
- 1000: PROFINET IO (estructura según estándar PROFINET IO)
- a partir de 1001: reservado

–

bits de 4 a 7: tipo de perfil (reservado)

Tipo de información de alarma como en CPU S7-300/400:
● En configuración centralizada: 0
● En configuración descentralizada:

flags1

BYTE

24

–

bits de 0 a 3: Tipo de información de alarma
- 0000: la alarma procede de un módulo descentralizado configurado
- 0001: alarma de un esclavo no DPV1/un dispositivo no IO o de un slot no
configurado
- 0010: alarma generada en la CPU
- a partir de 0011: reservado

–

bits de 4 a 7: versión de la estructura
- 0000: Inicial
- a partir de 0001: reservado

Flags de la interfaz de maestro PROFIBUS DP/interfaz de controlador PROFINET
IO como en CPU S7-300/400:
● En configuración centralizada: 0
● En configuración descentralizada:

Programación del PLC
Manual de programación y manejo, 11/2019

2455

Instrucciones
4.1 Instrucciones
Parámetro

flags2

Tipo de
datos

BYTE

Byte

25

Descripción
–

Bit 0 = 0: Alarma procedente de una interfaz integrada (PROFINET IO o
PROFIBUS DP)

–

Bit 0 = 1: Alarma procedente de una interfaz externa (PROFINET IO o
PROFIBUS DP)

–

Bits de 1 a 7: reservado

Flags de la interfaz de maestro PROFIBUS DP/interfaz de controlador PROFINET
IO como en CPU S7-300/400:
● En configuración centralizada: 0
● En caso de configuración descentralizada con PROFIBUS DP:
–

Bit 0: EXT_DIAG_FLAG del telegrama de diagnóstico, o 0 si este bit no está
presente en la alarma. Si el esclavo DP tiene un fallo, el bit es 1.

–

Bits de 1 a 7: reservado

● En caso de configuración descentralizada con PROFINET IO:

id

UINT

26 y 27

–

Bit 0: ARDiagnosisstate o 0, si no hay información en la alarma. Si el
dispositivo IO tiene un fallo, el bit es 1.

–

Bits de 1 a 7: reservado

Información administrativa
● En configuración centralizada: 0
● En caso de configuración descentralizada con PROFIBUS DP: Número de
identificación de PROFIBUS como identificación unívoca del esclavo
PROFIBUS DP
● En caso de configuración descentralizada con PROFINET IO: Número de
identificación del dispositivo PROFINET IO como identificación unívoca del
dispositivo PROFINET IO

manufactu‐
rer

UINT

28 y 29

Identificación de fabricante (solo en caso de configuración descentralizada con
PROFINET IO).

instance

UINT

30 y 31

Número de identificación de la instancia (solo en caso de configuración descentra‐
lizada con PROFINET IO).

* La información de arranque depende del OB utilizado. La información de arranque del respectivo tipo de OB se encuentra
en la interfaz o la documentación del OB.

Estructuras de datos para bloques de organización con acceso a bloque optimizado
Las estructuras de datos para bloques de organización con acceso a bloque optimizado están
organizadas de la manera siguiente:
● Bytes 0 a 3: formato de información de arranque, clase y número del OB llamado (misma
organización para todas las estructuras de datos).
● Bytes 4 a 19: información de arranque optimizada (estructura en función del tipo de OB).
Los datos de los bytes 4 a 19 se corresponden en organización y contenido con la interfaz
del OB correspondiente.
● Bytes 20 a 31: En determinados OB, adicionalmente información administrativa y de
dirección. Los datos de los bytes 20 a 31 se corresponden con los datos de los bytes 20 a
31 de la estructura de datos TI_Classic.
En las siguientes tablas se describe la organización de las estructuras de datos.

2456

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-15

OB de ciclo: estructura de datos TI_ProgramCycle
Tipo de
datos

Parámetro

Byte

TI_ProgramCycle
SI_Format

Descripción
Estructura de datos del OB de ciclo

USINT

0

Formato de la información de arranque:
● 16#FF: Ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB (= 1)

OB_Nr

UINT

2

Número de OB (1 ... 32767)

Initial_Call

BOOL

4

= TRUE en la primera llamada del OB con:
● transición de STOP o PARADA a RUN
● Tras recargar

Remanence

Tabla 4-16

BOOL

5

= TRUE si hay datos remanentes disponibles.

OB de arranque: estructura de datos TI_Startup

Parámetro

Tipo de
datos

Byte

TI_Startup

Descripción
Estructura de datos del OB de arranque

SI_Format

USINT

0

Formato de la información de arranque:
● 16#FF: Ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB (= 100)

OB_Nr

UINT

2

Número de OB (1 ... 32767)

LostRetentive

BOOL

4

= TRUE si se han perdido los contenidos de las áreas de datos remanentes.

LostRTC

BOOL

5

= TRUE si se ha perdido la hora del reloj en tiempo real.

Tabla 4-17

OB de alarma de retardo: estructura de datos TI_Delay

Parámetro

Tipo de
datos

Byte

USINT

0

TI_Delay
SI_Format

Descripción
Estructura de datos del OB de alarma de retardo
Formato de la información de arranque:
● 16#FF: Ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB (= 20)

OB_Nr

UINT

2

Número de OB (1 ... 32767)

Sign

WORD

4

Identificador de usuario: parámetro de entrada SIGN de la llamada de la instrucción
"SRT_DINT (Página 2661)".

Programación del PLC
Manual de programación y manejo, 11/2019

2457

Instrucciones
4.1 Instrucciones
Tabla 4-18

OB de alarma cíclica: estructura de datos TI_Cyclic
Tipo de
datos

Parámetro

Byte

TI_Cyclic

Descripción
Estructura de datos del OB de alarma cíclica

SI_Format

USINT

0

Formato de la información de arranque:
● 16#FF: Ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB (= 30)

OB_Nr

UINT

2

Número de OB (1 ... 32767)

Initial_Call

BOOL

4

= TRUE en la primera llamada del OB
● En la transición de STOP o PARADA a RUN
● Tras recargar

Event_Count

Tabla 4-19

INT

6

Número de eventos de arranque rechazados desde el último arranque de este OB.

OB de alarma de proceso: estructura de datos TI_HWInterrupt

Parámetro

Tipo de
datos

Byte

TI_HWInterrupt
SI_Format

Descripción
Estructura de datos del OB de alarma de proceso

USINT

0

Formato de la información de arranque:
● 16#FF: Ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB (= 40)

OB_Nr

UINT

2

Número de OB (1 ... 32767)

LADDR

HW_IO

4

Identificador de hardware del módulo que dispara la alarma de proceso.

USI

WORD

6

Identificador para ampliaciones futuras (irrelevante para el usuario).

IChannel

USINT

8

Número del canal que dispara la alarma de proceso.

EventType

BYTE

9

Identificador del tipo de evento que dispara la alarma (p. ej., flanco ascendente).
Este identificador se indica en la descripción del módulo correspondiente.

address

WORD

20

Ver parámetro "address" de la estructura de datos TI_Cassic..

slv_prfl

BYTE

22

Ver parámetro "slv_prfl" de la estructura de datos TI_Cassic.

intr_type

BYTE

23

Ver parámetro "intr_type" de la estructura de datos TI_Cassic.

flags1

BYTE

24

Ver parámetro "flags1" de la estructura de datos TI_Cassic.

flags2

BYTE

25

Ver parámetro "flags2" de la estructura de datos TI_Cassic.

id

UNIT

26

Ver parámetro "id" de la estructura de datos TI_Cassic.

manufacturer

UNIT

28

Ver parámetro "manufacturer" de la estructura de datos TI_Cassic.

instance

UNIT

30

Ver parámetro "instance" de la estructura de datos TI_Cassic.

2458

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-20

OB de alarma de proceso: estructura de datos TI_HWInterrupt_Extended

Parámetro

Tipo de
datos

Byte

TI_HWInterrupt_Extended
SI_Format

USINT

Descripción
Estructura de datos del OB de alarma de proceso

0

Formato de la información de arranque:
● 16#FF: Ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB (= 40)

OB_Nr

UINT

2

Número de OB (1 ... 32767)

LADDR

HW_IO

4

Identificador de hardware del módulo que dispara la alarma de proceso.

USI

WORD

6

Identificador para ampliaciones futuras (irrelevante para el usuario).

IChannel

USINT

8

Número del canal que dispara la alarma de proceso.

EventType

BYTE

9

Identificador del tipo de evento que dispara la alarma (p. ej., flanco ascendente).
Este identificador se indica en la descripción del módulo correspondiente.

PointAddr

DWORD

12

● Con módulos digitales: mapa de bits con las entradas del módulo que han
disparado la alarma de proceso
● Con módulos analógicos: mapa de bits que indica qué canal ha rebasado un
determinado límite
● Con CP o IM: estado de alarma del módulo (no relevante para el usuario)

address

WORD

20

Ver parámetro "address" de la estructura de datos TI_Cassic..

slv_prfl

BYTE

22

Ver parámetro "slv_prfl" de la estructura de datos TI_Cassic.

intr_type

BYTE

23

Ver parámetro "intr_type" de la estructura de datos TI_Cassic.

flags1

BYTE

24

Ver parámetro "flags1" de la estructura de datos TI_Cassic.

flags2

BYTE

25

Ver parámetro "flags2" de la estructura de datos TI_Cassic.

id

UNIT

26

Ver parámetro "id" de la estructura de datos TI_Cassic.

manufacturer

UNIT

28

Ver parámetro "manufacturer" de la estructura de datos TI_Cassic.

instance

UNIT

30

Ver parámetro "instance" de la estructura de datos TI_Cassic.

Programación del PLC
Manual de programación y manejo, 11/2019

2459

Instrucciones
4.1 Instrucciones
Tabla 4-21
Parámetro

OB de error de tiempo: estructura de datos TI_TimeError
Tipo de
datos

Byte

TI_TimeError
SI_Format

Descripción
Estructura de datos del OB de error de tiempo

USINT

0

Formato de la información de arranque:
● 16#FF: Ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB (= 80)

OB_Nr

UINT

2

Número de OB (1 ... 32767)

Csg_OBnr

OB_ANY

4

Número del OB que se estaba procesando cuando se produjo el error de tiempo.

Fault_ID

BYTE

7

Código de error. Valores posibles:
● B#16#01: rebase por exceso del tiempo de ciclo
● B#16#02: el OB solicitado todavía está procesándose.
● B#16#05: Alarma horaria expirada debido a salto de hora.
● B#16#06: Alarma horaria expirada al reanudar RUN después de PARADA.
● B#16#07: desbordamiento del búfer de solicitud de OB para la clase de prioridad
actual.
● B#16#08: error de tiempo en alarma de sincronismo.
● B#16#09: pérdida de alarmas por sobrecarga de alarmas
● B#16#0B: error de tiempo en alarma de sincronismo tecnológica

Csg_Prio

2460

UNIT

8

Prioridad del OB que se estaba procesando cuando se produjo el error de tiempo.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-22

OB de alarma de diagnóstico: estructura de datos TI_DiagnosticInterrupt

Parámetro

Tipo de
datos

Byte

TI_DiagnosticInterrupt
SI_Format

USINT

Descripción
Estructura de datos del OB de alarma de diagnóstico

0

Formato de la información de arranque:
● 16#FF: Ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB (= 82)

OB_Nr

UINT

2

Número de OB (1 ... 32767)

LADDR

HW_ANY

4

Identificador de hardware del objeto de hardware que ha disparado la alarma de
diagnóstico.

IO_State

WORD

6

Estado del objeto de hardware:
● Bit 0: Bueno
● Bit 1: Desactivado
● Bit 2: Mantenimiento necesario
● Bit 3: Mantenimiento solicitado
● Bit 4: Error
● Bit 5: No accesible
● Bit 6: Cualificado
● Bit 7: No disponible

Channel

UINT

8

MultiError

BOOL

10

= TRUE si existe más de un error.

address

WORD

20

Ver parámetro "address" de la estructura de datos TI_Cassic..

slv_prfl

BYTE

22

Ver parámetro "slv_prfl" de la estructura de datos TI_Cassic.

intr_type

BYTE

23

Ver parámetro "intr_type" de la estructura de datos TI_Cassic.

flags1

BYTE

24

Ver parámetro "flags1" de la estructura de datos TI_Cassic.

flags2

BYTE

25

Ver parámetro "flags2" de la estructura de datos TI_Cassic.

id

UINT

26

Ver parámetro "id" de la estructura de datos TI_Cassic.

manufacturer

UINT

28

Ver parámetro "manufacturer" de la estructura de datos TI_Cassic.

instance

UINT

30

Ver parámetro "instance" de la estructura de datos TI_Cassic.

Programación del PLC
Manual de programación y manejo, 11/2019

Número de canal

2461

Instrucciones
4.1 Instrucciones
Tabla 4-23

OB de enchufe/desenchufe: estructura de datos TI_PlugPullModule

Parámetro

Tipo de
datos

Byte

TI_PlugPullModule
SI_Format

Descripción
Estructura de datos del OB de cambio de módulo

USINT

0

Formato de la información de arranque:
● 16#FF: Ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB (= 83)

OB_Nr

UINT

2

Número de OB (1 ... 32767)

LADDR

HW_IO

4

Identificador de hardware del módulo o submódulo afectado

Event_Class

BYTE

6

● B#16#38: (sub)módulo enchufado

Fault_ID

BYTE

7

● B#16#39: (sub)módulo desenchufado o no responde
Código de error
El código de error indica qué evento ha provocado el arranque del OB de enchufe/
desenchufe.
● Si Event_Class = B#16#38 - (sub)módulo enchufado:
–

B#16#54: submódulo enchufado y coincide con el submódulo parametrizado

–

B#16#55: submódulo enchufado, pero no coincide con el submódulo
parametrizado

–

B#16#56: submódulo enchufado, pero error en parametrización del módulo

–

B#16#57: submódulo o módulo enchufado, pero con avería o mantenimiento

–

B#16#58: error de acceso a submódulo solucionado

–

B#16#61: módulo enchufado

● Si Event_Class = B#16#39 - (sub)módulo desenchufado o no responde:
–

B#16#51: módulo desenchufado

–

B#16#54: submódulo desenchufado

–

B#16#61: módulo desenchufado o no responde

address

WORD

20

Ver parámetro "address" de la estructura de datos TI_Cassic..

slv_prfl

BYTE

22

Ver parámetro "slv_prfl" de la estructura de datos TI_Cassic.

intr_type

BYTE

23

Ver parámetro "intr_type" de la estructura de datos TI_Cassic.

flags1

BYTE

24

Ver parámetro "flags1" de la estructura de datos TI_Cassic.

flags2

BYTE

25

Ver parámetro "flags2" de la estructura de datos TI_Cassic.

id

UINT

26

Ver parámetro "id" de la estructura de datos TI_Cassic.

manufacturer

UINT

28

Ver parámetro "manufacturer" de la estructura de datos TI_Cassic.

instance

UINT

30

Ver parámetro "instance" de la estructura de datos TI_Cassic.

2462

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-24

OB de fallo de rack: estructura de datos TI_StationFailure

Parámetro

Tipo de
datos

Byte

TI_StationFailure
SI_Format

Descripción
Estructura de datos de OB de fallo de rack

USINT

0

Formato de la información de arranque:
● 16#FF: Ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

OB_Nr

UINT

2

LADDR

HW_Devi‐ 4
ce

Identificador de hardware del objeto de hardware defectuoso.

Event_Class

BYTE

● B#16#32: Activar una estación con la instrucción "D_ACT_DP"

6

Clase de OB (= 86)
Número de OB (1 ... 32767)

● B#16#33: Desactivar una estación con la instrucción "D_ACT_DP"
● B#16#38: evento saliente
● B#16#39: evento entrante
Fault_ID

BYTE

7

Código de error
El código de error indica qué evento ha provocado el arranque del OB de fallo de
rack.
● Event_Class = B#16#39, FAULT_ID = C3: Periferia descentralizada: Fallo de un
sistema maestro DP
● Event_Class = B#16#38, FAULT_ID = C4: Fallo de una estación DP
● Event_Class = B#16#39, FAULT_ID = CA: Fallo de sistema de PROFINET IO
● Event_Class = B#16#39/38, FAULT_ID = CB: Fallo de estación/retorno de
estación PROFINET IO
● Event_Class = B#16#38, FAULT_ID = CC: Retorno de estación PROFINET IO
con fallo o mantenimiento
● Event_Class = B#16#38, FAULT_ID = CD: Retorno de estación PROFINET IO,
pero la configuración teórica difiere de la configuración real
● Event_Class = B#16#38, FAULT_ID = CE: Retorno de estación PROFINET IO,
pero error en la parametrización del módulo
● Event_Class = B#16#32/33, FAULT_ID = CF: Activación/desactivación de un
dispositivo PROFINET IO con la instrucción "D_ACT_DP"
● Event_Class = B#16#39/38, FAULT_ID = F8: Fallo/retorno de una parte de los
submódulos de un I-device PROFINET
● Event_Class = B#16#38, FAULT_ID = F9: Retorno de una parte de los
submódulos de un I-device PROFINET con diferencias en la configuración de
dispositivos

address

WORD

20

Ver parámetro "address" de la estructura de datos TI_Cassic..

slv_prfl

BYTE

22

Ver parámetro "slv_prfl" de la estructura de datos TI_Cassic.

intr_type

BYTE

23

Ver parámetro "intr_type" de la estructura de datos TI_Cassic.

flags1

BYTE

24

Ver parámetro "flags1" de la estructura de datos TI_Cassic.

flags2

BYTE

25

Ver parámetro "flags2" de la estructura de datos TI_Cassic.

id

UINT

26

Ver parámetro "id" de la estructura de datos TI_Cassic.

manufacturer

UINT

28

Ver parámetro "manufacturer" de la estructura de datos TI_Cassic.

instance

UINT

30

Ver parámetro "instance" de la estructura de datos TI_Cassic.

Programación del PLC
Manual de programación y manejo, 11/2019

2463

Instrucciones
4.1 Instrucciones
Tabla 4-25
Parámetro

OB de error de programación/OB de error de acceso a la periferia: estructura de datos TI_ProgIOAccessError
Tipo de
datos

TI_ProgIOAccessError

2464

Byte

Descripción*
Estructura de datos de OB de error de programación y OB de error de acceso a la
periferia

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro
SI_Format

Tipo de
datos

Byte

Descripción*

USINT

0

Formato de la información de arranque:
● 16#FF: Ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB:
● = 120 para OB de error de programación
● = 120 para OB de error de acceso a la periferia

OB_Nr

UINT

2

Número de OB (1 ... 32767)

BlockNr

UINT

4

Número del bloque en el que se ha producido el error de programación.

Reaction

USINT

6

● 0: Ignorar error
● 1: Reemplazar valor incorrecto
● 2: Saltar comando

Fault_ID

BYTE

7

Código de error
● B#16#21: Error de conversión BCD
● B#16#22: Error de longitud de área durante lectura
● B#16#23: Error de longitud de área durante escritura
● B#16#24: Error de área durante lectura
● B#16#25: Error de área durante escritura
● B#16#26: Error en el n.º del temporizador
● B#16#27: Error en el n.º del contador
● B#16#28: Acceso de lectura a un byte, palabra o palabra doble con un puntero
cuya dirección de bit es distinta de "0"
● B#16#29: Acceso de escritura a un byte, palabra o palabra doble con un puntero
cuya dirección de bit es distinta de "0"
● B#16#:30: Acceso de escritura a un DB global protegido contra escritura
● B#16#31: Acceso de escritura a un DB de instancia protegido contra escritura
● B#16#32: Error de número de DB al acceder a un DB global
● B#16#33: Error de número de DB al acceder a un DB de instancia
● B#16#34: Error de número en la llamada FC
● B#16#35: Error de número en la llamada FB
● B#16#42: Error de acceso a la periferia, lectura
● B#16#43: Error de acceso a la periferia, escritura
● B#16#3A: Acceso a un DB no cargado; el número de DB está dentro del rango
admisible
● B#16#3C: Acceso a una FC no cargada; el número de la FC está dentro del
rango admisible
● B#16#3D: Acceso a una instrucción (SFC) no cargada; el número de la SFC
está dentro del rango admisible
● B#16#3E: Acceso a un FB no cargado; el número de FB está dentro del rango
admisible
● B#16#3F: Acceso a una SFB inexistente; el número de SFB está dentro del
rango admisible

BlockType

USINT

8

Programación del PLC
Manual de programación y manejo, 11/2019

Tipo de bloque en el que se ha producido el error:

2465

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de
datos

Byte

Descripción*
● 1: OB
● 2: FC
● 3: FB
● 4: SFC
● 5: SFB
● 6: DB

Area

USINT

9

Área de memoria en la que se ha producido el acceso incorrecto:
● Datos locales: B#16#40 a 4E, 86, 87, 8E, 8F, C0 a CE
● Memoria imagen de proceso de las entradas: B#16#01
● Memoria imagen de proceso de las salidas: B#16#02
● DB de tecnología: B#16#04
● I: B#16#81
● Q: B#16#82
● M: B#16#83
● DB: B#16#84, 85, 8A, 8B

DBNr

DB_ANY

10

N.º DB si Area = DB (DB global o DB de instancia)
Solo relevante con OB de error de programación.

Csg_OBNr

OB_ANY

12

Número de OB:
● 121: OB de error de programación
● 122: OB de error de acceso a la periferia

Csg_Prio

USINT

14

Width

USINT

15

Prioridad de OB
Tipo de acceso en el que se ha producido el error:
● Bit: B#16#00
● Byte: B#16#01
● Word: B#16#02
● DWord: B#16#03
● LWord: B#16#04

* En función del OB cuya información se lee (OB de error de acceso a la periferia u OB de error de programación), solo son
posibles determinados valores de salida.

2466

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-26

OB de alarma horaria: estructura de datos TI_TimeOfDay
Tipo de
datos

Parámetro

Byte

TI_TimeOfDay
SI_Format

Descripción
Estructura de datos del OB de alarma horaria

USINT

0

Formato de la información de arranque:
● 16#FF: Ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB (= 10)

OB_Nr

UINT

2

Número de OB (1 ... 32767)

CaughtUp

BOOL

4

=TRUE, si se ha ejecutado un OB a posteriori por haberse adelantado la hora

SecondTime

BOOL

5

=TRUE, si se ha llamado un OB por segunda vez debido al retraso de la hora. Nota:
SecondTime se activa una única vez con la hora retrasada.

Tabla 4-27

OB de alarma de sincronismo: estructura de datos TI_SynchCycle

Parámetro

Tipo de
datos

Byte

USINT

0

TI_SynchCycle
SI_Format

Descripción
Estructura de datos de OB de alarma de sincronismo
Formato de la información de arranque:
● 16#FF: Ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB (= 61)

OB_Nr

UINT

2

Número de OB (1 ... 32767)

Initial_Call

BOOL

4

= TRUE en la primera llamada del OB con:
● transición de STOP o PARADA a RUN
● Tras recargar

IO _System

USINT

5

Número del sistema de periferia descentralizada que ha disparado la alarma

Event_Count

INT

6

● = n: número de ciclos perdidos
● = -1: Se ha perdido un número desconocido de ciclos (p. ej. porque el ciclo ha
cambiado).

PIP_Input

BOOL

10

= TRUE: la memoria imagen de proceso correspondiente de las entradas es actual

PIP_Output

BOOL

11

= TRUE: la memoria imagen de proceso correspondiente de las salidas se transfirió
a tiempo a las salidas tras el último ciclo

SyncCycleTi‐
me

LTIME

16

Tiempo de ciclo calculado

Programación del PLC
Manual de programación y manejo, 11/2019

2467

Instrucciones
4.1 Instrucciones
Tabla 4-28

OB de alarma de estado/OB de alarma de actualización/OB para la alarma específica del fabricante o perfil:
estructura de datos TI_Submodule
Tipo de
datos

Parámetro

Byte

TI_Submodule
SI_Format

Descripción
Estructura de datos del OB de alarma de estado, OB de alarma de actualización y
OB para la alarma específica del fabricante o perfil

USINT

0

Formato de la información de arranque:
● 16#FF: ninguna
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB
● = 55 para OB de alarma de estado
● = 56 para OB de alarma de actualización
● = 57 para OB para la alarma específica del fabricante o perfil

OB_Nr

UINT

2

Número de OB (1 ... 32767)

LADDR

HW_IO

4

Dirección de hardware del componente causante de la alarma

Slot

UINT

6

Número de slot del componente causante de la alarma

Specifier

WORD

8

Especificador de alarma del telegrama de alarma

address

WORD

20

Ver parámetro "address" de la estructura de datos TI_Cassic..

slv_prfl

BYTE

22

Ver parámetro "slv_prfl" de la estructura de datos TI_Cassic.

intr_type

BYTE

23

Ver parámetro "intr_type" de la estructura de datos TI_Cassic.

flags1

BYTE

24

Ver parámetro "flags1" de la estructura de datos TI_Cassic.

flags2

BYTE

25

Ver parámetro "flags2" de la estructura de datos TI_Cassic.

id

UINT

26

Ver parámetro "id" de la estructura de datos TI_Cassic.

manufacturer

UINT

28

Ver parámetro "manufacturer" de la estructura de datos TI_Cassic.

instance

UINT

30

Ver parámetro "instance" de la estructura de datos TI_Cassic.

Tabla 4-29

OB de error de redundancia en CPU: estructura de datos TI_CPURedundancyError_V2

Parámetro

Tipo de
datos

Byte

TI_CPURedundancyError_V2
SI_Format

USINT

Descripción
Estructura de datos del OB de error de redundancia en CPU

0

Formato de la información de arranque:
● 16#FF: ninguno
● 16#FE: información de arranque optimizada

OB_Class

USINT

1

Clase de OB (= 72)

OB_Nr

UINT

2

Número de OB (1...32767)

LADDR

HW_ANY

4

Identificador de hardware del objeto de hardware defectuoso

Event_Class

BYTE

6

Clase de evento e identificadores (B#16#73: evento entrante)

Fault_ID

BYTE

7

Código de error

2468

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro AINFO
Estructura de datos del área de destino AINFO en las alarmas de PROFIBUS DP
Byte

Significado

0a3

Información de encabezado y descripción exacta: ver abajo

4 a 63

Información adicional de alarma: datos de la alarma en cuestión:
Descentralizado:

ARRAY[0] hasta ARRAY[59]

Estructura de la información de encabezado en las alarmas de PROFIBUS DP
Byte

Tipo de datos

Significado

0

BYTE

Longitud en bytes de la información de alarma recibida

1

BYTE

Centralizado:

4 a 224

Descentraliza‐
do:

4 a 63

Centralizado:

Reservado

Descentraliza‐
do:

Identificador del tipo de alarma
1:
2:
3:
4:
5:
6:
31

Alarma de diagnóstico
Alarma de proceso
Alarma de extracción
Alarma de inserción
Alarma de estado
Alarma de actualización
Fallo de un aparato de ampliación, un sistema maestro DP
o una estación DP

32 a 126:

Alarma específica de fabricante

2

BYTE

Número de slot del componente causante de la alarma

3

BYTE

Centralizado:

Reservado

Descentraliza‐
do:

Specifier
Bits 0 y 1:

0: No hay más información;
1: slot con fallo
2: slot sin fallo

Bit 2:

Add_Ack

Bits 3 a 7:

Número de secuencia

Estructura de datos del área de destino AINFO en las alarmas de PROFINET IO o de la periferia
centralizada
Byte

Significado

0 a 25

Información de encabezado y descripción exacta: ver abajo

26 a 1431

Información adicional de alarma: datos de diagnóstico normalizados de la alarma en cuestión:
ARRAY[0] hasta ARRAY[1405]
Nota: La información adicional de alarma también puede omitirse.

Programación del PLC
Manual de programación y manejo, 11/2019

2469

Instrucciones
4.1 Instrucciones
Estructura de la información de encabezado en las alarmas de PROFINET IO o de la periferia
centralizada
Byte

Tipo de datos

Significado

0y1

WORD

● Bits 0 a 7: Tipo de bloque
● Bits 8 a 15: Reservado

2y3

WORD

Longitud del bloque

4y5

WORD

Versión:
● Bits 0 a 7: low byte
● Bits 8 a 15: high byte

6y7

WORD

Identificador del tipo de alarma:
● 1: Alarma de diagnóstico (entrante o saliente)
● 2: Alarma de proceso
● 3: Alarma de desenchufe
● 4: Alarma de enchufe
● 5: Alarma de estado
● 6: Alarma de actualización
● 7: Alarma de redundancia
● 8: Controlado por el Supervisor (Controlled_by_Supervisor)
● 9: Habilitado por el Supervisor (Released_by_Supervisor)
● 10: No se ha insertado el módulo configurado
● 11: Retorno del submódulo
● 12: Alarma de diagnóstico (saliente)
● 13: Aviso de conexión para comunicación directa
● 14: Aviso de cambio de vecindario
● 15: Aviso de sincronización de ciclo (desde el bus)
● 16: Aviso de sincronización de ciclo (desde el dispositivo)
● 17: Aviso de componentes de la red
● 18: Aviso de sincronización horaria (desde el bus)
● 19 a 29: Reservado
● 30: Upload-and-Retrieval-Alarm
● 31: Reservado
● 32 a 127: Alarma específica de fabricante
● 128 a 65535: Reservado

8 a 11

DWORD

API (Application Process Identifier)

12 a 13

WORD

Número de slot del componente que dispara la alarma (rango de valores de 0 a 65535)

14 a 15

WORD

Número de slot de submódulo del componente que dispara la alarma (rango de valores
de 0 a 65535)

16 a 19

DWORD

Identificación de módulo; información unívoca del origen de la alarma

2470

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Byte

Tipo de datos

Significado

20 a 23

DWORD

Identificación de submódulo; información unívoca del origen de la alarma

24 a 25

WORD

Alarm Specifier:
● Bits 0 a 10: Número de secuencia (rango de valores de 0 a 2047)
● Bit 11: Diagnóstico de canal:
0: No hay ningún diagnóstico de canal
1: Hay diagnóstico de canal
● Bit 12: Estado de diagnóstico específico de fabricante:
0: No hay ninguna información de estado específica de fabricante
1: Hay información de estado específica de fabricante
● Bit 13: Estado del diagnóstico en el submódulo:
0: No hay información de estado, se han eliminado todos los errores
1: Hay por lo menos un diagnóstico de canal y/o una información de estado
● Bit 14: Reservado
● Bit 15: Application Relationship Diagnosis State:
–

0: Ninguno de los módulos configurados dentro de esta AR notifica un diagnóstico

–

1: Por lo menos uno de los módulos configurados dentro de esta AR notifica un
diagnóstico

Estructura de la información adicional de alarma en las alarmas de PROFINET IO o de la
periferia centralizada

Programación del PLC
Manual de programación y manejo, 11/2019

2471

Instrucciones
4.1 Instrucciones
La información adicional de alarma con PROFINET IO depende del especificador de formato.
Puede estar compuesta por varios bloques de datos con el mismo o distinto especificador de
formato. Son posibles los siguientes especificadores de formato:
● W#16#0000 a W#16#7FFF: Diagnóstico específico de fabricante
Byte

Tipo de da‐
tos

Significado

0a1

WORD

Especificador de formato para la estructura de los datos que siguen
como información adicional de alarma:
W#16#0000 a W#16#7FFF: Diagnóstico específico de fabricante

2an

BYTE

Ver manual del fabricante.

● W#16#8000: Diagnóstico de canal
El diagnóstico de canal se emite en bloques de 6 bytes cada uno. La información adicional
de alarma (sin especificador de formato) se emite solo para los canales que presentan
fallos.
Byte

Tipo de da‐
tos

Significado

0a1

WORD

Especificador de formato para la estructura de los datos que siguen
como información adicional de alarma:
W#16#8000: Diagnóstico de canal

2a3

WORD

Número de canal del componente que dispara la alarma (rango de
valores de 0 a 65535):
● W#16#0000 a W#16#7FFF: Número de canal del submódulo/
módulo
● W#16#8000: Es el representante para todo el submódulo
● W#16#8001 a W#16#FFFF: Reservado

4

BYTE

Bits 0 a 2:

Reservado

Bits 3 a 4:

Tipo de error:
● 0: Reservado
● 1: Error entrante
● 2: Error saliente
● 3: Error saliente, hay más errores

Bits 5 a 7:

Tipo de canal:
● 0: Reservado
● 1: Canal de entrada
● 2: Canal de salida
● 3: Canal de entrada/salida

2472

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Byte

Tipo de da‐
tos

Significado

5

BYTE

Formato de datos:
● B#16#00: Formato de datos libre
● B#16#01: Bit
● B#16#02: 2 bits
● B#16#03: 4 bits
● B#16#04: Byte
● B#16#05: Palabra
● B#16#06: Palabra doble
● B#16#07: 2 palabras dobles
● B#16#08 a B#16#FF: Reservado

Programación del PLC
Manual de programación y manejo, 11/2019

2473

Instrucciones
4.1 Instrucciones
Byte

Tipo de da‐
tos

Significado

6a7

WORD

Tipo de error:
● W#16#0000: Reservado
● W#16#0001: Cortocircuito
● W#16#0002: Subtensión
● W#16#0003: Sobretensión
● W#16#0004: Sobrecarga
● W#16#0005: Sobretemperatura
● W#16#0006: Rotura de hilo
● W#16#0007: Límite superior rebasado
● W#16#0008: Rebase del límite inferior
● W#16#0009: Error
● W#16#000A: Simulación activa
● W#16#000B a W#16#000E: Reservado
● W#16#000F a W#16#001F: Específico del fabricante. Consulte el
manual de producto correspondiente.
● W#16#0020 a W#16#00FF: Reservado
● W#16#0100 a w#16#7FFF: Específico del fabricante. Consulte el
manual de producto correspondiente.
● W#16#8000: No es posible transferir datos
● W#16#8001: Error en el interlocutor
● W#16#8002: Error de redundancia de medio
● W#16#8003: Pérdida de sincronización
● W#16#8004: Error de sincronismo
● W#16#8005: Error de Multicast CR
● W#16#8006: Reservado
● W#16#8007: Error en cable de fibra óptica
● W#16#8008: Error de función del componente de red
● W#16#8009: Error de tiempo
● W#16#800A: Problema en DFP (DFP: dynamic frame packing)
● W#16#800B: Problema en MRPD (MRPD: media redundancy with
planned duplication)
● W#16#800C: Error de redundancia del sistema
● W#16#800D a W#16#FFFF: Reservado
No todos los canales soportan todos los tipos de error. Encontrará más
detalles en la descripción de los datos de diagnóstico del dispositivo
correspondiente.

Nota
La parte de "Número de canal" a "Tipo de error" puede aparecer entre 0 y n veces.

2474

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● W#16#8001: MULTIPLE (se transfieren diferentes tipos de información de diagnóstico). En
este caso, la información adicional de alarma se transfiere en estructura de bloque de
longitud variable.
Byte

Tipo de
datos

Significado

0a1

WORD

Especificador de formato para la estructura de los datos que siguen como
información adicional de alarma:
W#16#8001: Diagnóstico específico del fabricante y/o diagnóstico de canal

2a3

WORD

Tipo de bloque

4a5

WORD

Longitud del bloque

6

BYTE

Versión: high byte

7

BYTE

Versión: low byte

8 a 11

DWORD

API (solo si el low byte de la versión = 1)

12 a 13

WORD

Número de slot

14 a 15

WORD

Número de subslot

16 a 17

WORD

Número de canal

18 a 19

WORD

Propiedades de canal

20 a 21

WORD

Identificación de formato:
● W#16#0000 a W#16#7FFF: Diagnóstico específico de fabricante
● W#16#8000: Diagnóstico de canal
● W#16#8002: Diagnóstico avanzado de canal
● W#16#8003: Diagnóstico avanzado de canal escalonado
● W#16#8004 a W#16#80FF: Reservado

22 a n

BYTE

Datos en función del especificador de formato

Nota
La parte a partir de "Tipo de bloque" puede aparecer entre 1 y n veces.
● W#16#8002: Diagnóstico avanzado de canal
Byte

Significado

0a1

Identificación de formato W#16#8002

2a3

Número de canal

4a5

Propiedades de canal

6a7

Tipo de error

8a9

Valor de error adicional

10 a 13

Información adicional de error

Programación del PLC
Manual de programación y manejo, 11/2019

2475

Instrucciones
4.1 Instrucciones
● W#16#8003: Diagnóstico avanzado de canal escalonado
Byte

Significado

0a1

Identificación de formato W#16#8003

2a3

Número de canal

4a5

Propiedades de canal

6a7

Tipo de error

8a9

Valor de error adicional

10 a 13

Información adicional de error

14 a 17

Qualified Channel Qualifier

● W#16#8100: Información de mantenimiento
Byte

Significado

0a1

Identificación de formato W#16#8100

2a3

Tipo de bloque

4a5

Longitud del bloque

6a7

Versión del bloque

8a9

Reservado
Nota: en módulos centralizados faltan estos dos bytes. Existen en módulos descen‐
tralizados (conforme al estándar PROFINET).

10 a 13

Estado de mantenimiento

Nota
Encontrará información más detallada sobre la estructura de la información adicional de
alarma en el Manual de programación SIMATIC PROFINET IO De PROFIBUS DP a
PROFINET IO y en la versión más reciente de la norma IEC 61158-6-10-1.

Área de destino TINFO y AINFO
Área de destino TINFO y AINFO
Dependiendo del OB en el que se llame "RALRM (Página 2444)", las áreas de destino TINFO
y AINFO solo se escriben parcialmente. La tabla siguiente describe la información que se
registra en cada caso.
Tipo de alarma

Cla‐
se de
OB

TINFO
Información
de arranque
del OB

TINFO
Información ad‐
ministrativa

AINFO
Información
de encabeza‐
do

AINFO
Información de alarma adicional

Alarma de proceso

4x

Sí

Sí

Sí

Centralizado:

No

Descentraliza‐ Igual que la proporcio‐
do:
nada por el esclavo
PROFIBUS DP/dispo‐
sitivo PROFINET IO
Alarma de estado

2476

55

Sí

Sí

Sí

Sí

Sí

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tipo de alarma

Cla‐
se de
OB

TINFO
Información
de arranque
del OB

TINFO
Información ad‐
ministrativa

AINFO
Información
de encabeza‐
do

AINFO
Información de alarma adicional

Alarma de actualiza‐
ción

56

Sí

Sí

Sí

Sí

Sí

Alarma específica de
fabricante

57

Sí

Sí

Sí

Sí

Sí

Error de redundancia
de la periferia

70

Sí

Sí

No

No

No

Alarma de diagnóstico 82

Sí

Sí

Sí

Centralizado:

Estructura según la
norma PROFINET IO

Descentraliza‐ Igual que la proporcio‐
do:
nada por el esclavo
PROFIBUS DP/dispo‐
sitivo PROFINET IO
Alarma
83
de enchufe/desenchu‐
fe

Sí

Sí

Sí

Centralizado:

No

Alarma de extracción
especial:

83

Sí

Sí

Sí

Solo PROFINET IO

83

Sí

Sí

Sí

Solo PROFINET IO

Se ha insertado un mó‐ 83
dulo no configurado

Sí

Sí

Sí

Solo PROFINET IO

Fallo de rack/
fallo de estación

Sí

Sí

No

No

Sí

No

No

No

Descentraliza‐ Igual que la proporcio‐
do:
nada por el esclavo
PROFIBUS DP/dispo‐
sitivo PROFINET IO

Controlada por el su‐
pervisor
Alarma de inserción
especial:
Habilitada por el super‐
visor

86

... todos los demás OB

Ejemplo de programa para RALRM
Introducción
En el ejemplo siguiente se genera una rotura de hilo mediante un módulo de entradas y se
recibe la alarma junto con la información correspondiente. El ejemplo es válido para una CPU
S7-1500 o PROFINET IO.
Nota
Ubicar ejemplo
El ejemplo debe guardarse en la configuración en la que el módulo de entradas va a generar
una alarma (rotura de hilo).

Programación del PLC
Manual de programación y manejo, 11/2019

2477

Instrucciones
4.1 Instrucciones

Requisitos
● Se ha creado un módulo de entradas y el identificador de hardware se ha leído en las
propiedades del mismo. El identificador de hardware se guarda mediante el parámetro de
entrada F_ID ("alarmCheckID").
● Para generar una alarma, active para los canales de entrada la opción "Rotura de hilo".
Encontrará esta opción en el módulo de entradas en "Parámetros del módulo > Plantilla de
canal > Entradas".

● Para almacenar los datos es preciso crear siete variables y las estructuras
"TI_Diagnostic_Interrupt" y "Additional_Diag" en un bloque de datos global. La estructura
"TI_Diagnostic_Interrupt" se crea con el tipo de datos "TI_DiagnosticInterrupt".

2478

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Interconectar parámetros
La instrucción "RALRM" se llama en un OB de alarma de diagnóstico (OB82). Los parámetros
de la instrucción se interconectan del siguiente modo.

Resultado de RALRM
Nota
Disparar rotura de hilo
Para disparar la alarma, desenchufe uno de los cables de corriente de las entradas del módulo
de entradas y a continuación enchufe el cable nuevamente. Otra alternativa consiste en
desenchufar un puente de potencial del módulo de entradas y enchufarlo nuevamente.
Si se produce una rotura de hilo, el módulo de entradas genera una alarma. A continuación se
llama el OB de alarma de diagnóstico y se inicia la instrucción "RALRM".
Mediante el parámetro de entrada F_ID ("alarmCheckID"), la instrucción "RALRM" llama el
módulo de entradas. De acuerdo con el valor "2" del parámetro de entrada MODE
("alarmMode"), la instrucción "RALRM" comprueba si la alarma procede del módulo de
entradas. Si la alarma procede del módulo de entradas ("alarmCheckID" y "alarmFromID"
coinciden), el parámetro de salida NEW ("alarmReceived") se pone a "TRUE" y la información
de alarma se guarda mediante los parámetros TINFO ("TI_Diagnostivc_Interrupt") y AINFO
("Additional_Diag"). El identificador de hardware del módulo que ha generado la alarma se
muestra en el parámetro de salida ID ("alarmFromID").
La longitud de la información de alarma recibida se deposita en bytes en el parámetro de salida
LEN ("alarmLength"). De acuerdo con el valor del parámetro de entrada MLEN
("alarmMaxLength" tiene el valor "0"), la información que debe leerse para AINFO
("Additional_Diag") es ilimitada.

Programación del PLC
Manual de programación y manejo, 11/2019

2479

Instrucciones
4.1 Instrucciones
En el parámetro de salida STATUS ("alarmStatus") se indica el estado del bloque. La ejecución
transcurre sin errores.

Encontrará la evaluación de TINFO y AINFO en los apartados siguientes.

Detalles sobre el parámetro TINFO ("TI_Diagnostivc_Interrupt")
En el parámetro TINFO ("TI_Diagnostivc_Interrupt") se deposita la información de arranque del
OB y la información administrativa.
La alarma generada contiene, entre otras, la información siguiente:
● Información de arranque del OB: el OB82 utiliza información de arranque optimizada
("SI_Format" con el valor "254").
● Información administrativa:
– Se lee el módulo de entradas (véase "LADDR") con el estado "fallo" (véase el valor de
"IO_State").
– Se ha registrado una alarma para el canal "15" (véase el valor de "Channel").
– Se han leído varios fallos ("MutliError" con el valor "TRUE").
– Se ha leído una alarma para la estación "0" (véase el valor de "address").
– Se ha leído una estructura según el juego de datos de diagnóstico 0 (véase en valor de
"slv_prfl").
– La alarma ha sido disparada por un módulo descentralizado configurado (véase el valor
de "intr_type").

2480

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Detalles sobre el parámetro AINFO ("Additional_Diag")
En el parámetro oAINFO ("Additional_Diag") se deposita información sobre el encabezado e
información adicional sobre la alarma.
Nota
Estructura y alcance de la información de alarma
Este ejemplo está pensado para la recepción de un único error de hardware (rotura de hilo). En
consecuencia, si se produce un error múltiple solo se indica la información de alarma de uno
de los canales afectados.
● Para llamar la información adicional individualmente para cada canal se utiliza una llamada
múltiple de RALRM: Por cada llamada, consulte el canal
("TI_Diagnostivc_Interrupt.Channel") y guarde para cada canal la información de las
variables "ChannelErrorType" a "ErrorCode". Consulte también "Preguntas frecuentes
sobre el diagnóstico de canal con RALRM (https://support.industry.siemens.com/cs/ww/es/
view/109480387)".
● Tenga en cuenta la estructura que debe guardarse en el parámetro AINFO (Página 2469)
en función de la aplicación concreta.
La alarma generada contiene, entre otras, la información siguiente:
● El OB utilizado es un OB de alarma de diagnóstico ("InterruptType" con el valor "1").
● La alarma se notifica para un módulo en el slot "2" ("SlotNumber") y para los canales 8..15
(BYTE 1, "SubSlotNumber").
● Existe por lo menos un diagnóstico de canal y/o una información de estado para el
submódulo ("InterruptSpecifier" con el valor "16#2000").
● En este ejemplo se utiliza la estructura del diagnóstico de canal ("FormatIdentifier" con el
valor "16#8000").
● El número de canal del componente que ha disparado la alarma debe asignarse al
submódulo ("ChannelNumber" con el valor "16#0008").

Programación del PLC
Manual de programación y manejo, 11/2019

2481

Instrucciones
4.1 Instrucciones
● Se diagnostica un error entrante para un canal de entrada ("ChannelErrorType" con el valor
"16#28").
● El formato de datos utilizado es un bit ("DataFormat" con el valor "16#01").
● Se ha diagnosticado una rotura de hilo ("ErrorCode" con el valor "16#0006").

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Otro ejemplo
Encontrará un ejemplo más complejo aquí: "Preguntas frecuentes sobre el diagnóstico de
canal con RALRM (https://support.industry.siemens.com/cs/ww/es/view/109480387)".

D_ACT_DP: Activar / desactivar esclavos DP
Descripción
Con la instrucción "D_ACT_DP" se desactivan y activan de forma selectiva esclavos DP/
dispositivos PROFINET IO configurados. Además es posible averiguar, para cada esclavo DP
o dispositivo PROFINET IO utilizado, si el componente en cuestión está activado o
desactivado en un determinado momento.
Nota
CPU S7-1200
En las CPU S7-1200 la instrucción D_ACT_DP solo puede utilizarse con dispositivos
PROFINET IO. No se puede utilizar con esclavos PROFIBUS DP.

2482

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Una transición de red del tipo IE/PB Link PN IO no se desactiva / activa con la instrucción
"D_ACT_DP". Si, de todas formas, se aplica "D_ACT_DP" a la transición de red indicada, la
CPU devuelve el valor de retorno W#16#8093 (a la dirección indicada en LADDR no le
corresponde ningún objeto de hardware que pueda activarse o desactivarse).
A partir de la versión de firmware V1.8 de la CPU S7-1500 vale lo siguiente: Es posible
desactivar / activar esclavos DP conectados a una transición de red del tipo IE/PB Link PN IO
con la instrucción "D_ACT_DP".
Esta instrucción no se puede usar en aparatos de campo PROFIBUS PA que estén
conectados mediante DP/PA Link a un sistema maestro DP.
Nota
Para procesar una petición de desactivación o activación se requieren varios pasos por el
punto de control de ciclo. Por ello no se espera la finalización de una petición de este tipo
dentro de un bucle programado.

Funcionamiento
"D_ACT_DP" es una instrucción que funciona de forma asíncrona. Su ejecución se prolonga
a lo largo de varias llamadas. Para iniciar la petición, debe llamarse "D_ACT_DP" con REQ=1.
El estado de la petición se indica mediante los parámetros de salida RET_VAL y BUSY .
Consulte también: Diferencia entre las instrucciones que funcionan síncronamente y las que
funcionan asíncronamente (Página 618).

Campo de aplicación
Si en una de las CPU se configuran esclavos DP o dispositivos PROFINET IO que no existen
realmente o que actualmente no se necesitan, la CPU accederá de todos modos con
regularidad a dichos esclavos DP o dispositivos PROFINET IO. Una vez desactivados dichos
componentes, la CPU no vuelve a acceder a ellos. Con PROFIBUS DP, esto permite obtener
el ciclo de bus DP más rápido posible. Los correspondientes eventos de error ya no aparecen.

Ejemplos
En la fabricación de máquinas de serie, el fabricante dispone de una gran cantidad de opciones
de máquina. Sin embargo, cada máquina suministrada contiene una combinación única de
opciones seleccionadas.
Todas las opciones de máquina posibles son configuradas por el fabricante como esclavos DP
o dispositivos PROFINET IO, a fin de poder crear y llevar un programa de usuario común para
todas las opciones posibles. Con "D_ACT_DP" se desactivan en el arranque de la máquina
todos los esclavos DP o dispositivos PROFINET IO que no estén presentes en la configuración
real.
Algo similar sucede en el caso de las máquinas herramienta, que ofrecen una amplia gama de
herramientas pero solo utilizan unas pocas en cada momento concreto. En estos casos, las
herramientas se configuran como esclavos DP o dispositivos PROFINET IO. Con ayuda de
"D_ACT_DP", el programa de usuario activa las herramientas requeridas en cada momento y
desactiva las que no se van a utilizar hasta más adelante.

Programación del PLC
Manual de programación y manejo, 11/2019

2483

Instrucciones
4.1 Instrucciones

Identificación de una petición
Si se ha lanzado una petición de desactivación o activación y se vuelve a llamar a "D_ACT_DP"
antes de que finalice, el comportamiento posterior de la instrucción dependerá esencialmente
de si la nueva llamada corresponde a la misma petición. Si el parámetro de entrada LADDR
coincide, la llamada se considera una llamada consecutiva.

Desactivar esclavos DP o dispositivos PROFINET IO
Si se desactiva un esclavo DP o un dispositivo PROFINET IO con "D_ACT_DP", sus salidas de
proceso se ajustan a los valores sustitutivos configurados, o a 0 (estado seguro). A partir de
entonces, el correspondiente maestro DP o controlador PROFINET IO no volverá a llamar ese
componente. Los esclavos DP o dispositivos PROFINET IO desactivados no se identifican
como averiados o ausentes en los LEDs de error del maestro DP o controlador PROFINET IO
ni de la CPU.
La memoria imagen de proceso de las entradas de los esclavos DP o dispositivos PROFINET
IO desactivados se actualiza con 0. Por ello se actúa como si se tratase de esclavos DP o
dispositivos PROFINET IO averiados.
Si en el programa se accede mediante acceso directo a los datos de usuario de un esclavo DP
o dispositivo PROFINET IO desactivado anteriormente, se llama el OB de error de acceso a la
periferia y se guarda en el búfer de diagnóstico el correspondiente evento de arranque. Si
mediante una instrucción (p. ej. "RD_REC (Página 2504)") se accede a un esclavo DP o
dispositivo PROFINET IO desactivado, se recibe en RET_VAL la misma información de error
que con un esclavo DP o dispositivo PROFINET IO no disponible.
La desactivación de un esclavo DP o un dispositivo PROFINET IO no ocasiona el arranque del
OB de error de ejecución del programa, aunque las entradas y salidas de este pertenezcan a
la memoria imagen de proceso que debe actualizarse por el sistema.
Si una estación DP o PNIO falla después de haberla desactivado con "D_ACT_DP", el sistema
operativo no reconoce el fallo.
Para PROFIBUS DP se aplica lo siguiente: Si se desea desactivar un esclavo DP que participa
como emisor en la comunicación directa, se recomienda desactivar en primer lugar los
receptores que comparten los datos que el emisor envía a su maestro DP. Una vez hecho esto
ya se puede desactivar el emisor.

Activar esclavos DP o dispositivos PROFINET IO
Si se vuelve a activar un esclavo DP o dispositivo PROFINET IO con "D_ACT_DP", este
componente es configurado y parametrizado por el correspondiente maestro DP o controlador
PROFINET IO (igual que cuando se recupera una estación DP o PROFINET IO tras un fallo).
La activación ha finalizado cuando el componente está ya en disposición de transferir datos
útiles.
La activación de un esclavo DP o un dispositivo PROFINET IO no ocasiona el arranque del OB
de error de ejecución del programa, aunque las entradas y salidas de este pertenezcan a la
memoria imagen de proceso que debe actualizarse por el sistema.
Si intenta activar con "D_ACT_DP" un esclavo DP o dispositivo PROFINET IO no accesible (p.
ej. porque se ha desconectado físicamente del bus), la instrucción emite el código de error
W#16#80A7 una vez transcurrido el tiempo de parametrización configurado para la periferia
descentralizada. El esclavo DP o dispositivo PROFINET IO está activado y la inaccesibilidad

2484

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
del esclavo DP o dispositivo PROFINET IO activado da lugar a una indicación en el diagnóstico
del sistema.
Si el esclavo DP o dispositivo PROFINET IO vuelve a estar accesible a continuación, esto se
traducirá en el comportamiento normal del sistema (p. ej. la llamada del OB configurado a tal
efecto).
Nota
La activación de un esclavo DP o un dispositivo PROFINET IO puede tomar un tiempo
considerable. Para cancelar una petición de activación en curso, debe iniciarse "D_ACT_DP"
con el mismo valor para LADDR y MODE = 2. Debe repetirse la llamada de "D_ACT_DP" con
MODE = 2 tantas veces como sea necesario hasta que se señalice, mediante RET_VAL = 0,
que se ha cancelado la petición de activación.
Si se desea activar esclavos DP que participan en la comunicación directa, se recomienda
activar primero los emisores y luego los receptores (oyentes).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "D_ACT_DP":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Parámetro de control disparado por nivel

MODE

Input

USINT

I, Q, M, D, L o cons‐
tante

Identificador de petición
Valores posibles:

REQ=1: realizar activación o desactivación

● 0: Conocer si el componente llamado está
activado o desactivado (salida mediante el
parámetro RET_VAL)
● 1: Activar esclavo DP o dispositivo
PROFINET IO
● 2: Desactivar esclavo DP o dispositivo
PROFINET IO
LADDR

Input

HW_DEVICE

I, Q, M, D, L o cons‐
tante

Identificador de hardware del esclavo DP
(HW_DPSlave)/dispositivos PROFINET IO
(HW_Device)
El número puede adoptarse de la ficha "Cons‐
tantes de sistema" de la tabla de variables es‐
tándar.
En el caso de que allí se indiquen tanto el iden‐
tificador para el diagnóstico del dispositivo co‐
mo el identificador para las transiciones de es‐
tado operativo, deberá utilizar el del diagnósti‐
co del dispositivo.

Programación del PLC
Manual de programación y manejo, 11/2019

2485

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución de
la instrucción, el valor de respuesta contendrá
un código de error.

BUSY

Output

BOOL

I, Q, M, D, L

Identificación de componente activo:
● BUSY=1: La petición todavía está activa.
● BUSY=0: La petición ha finalizado.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Explicación
(W#16#...)
0000

La petición se ha ejecutado sin errores.

0001

El esclavo DP o dispositivo PROFINET IO está activado (este código de error solo es posible con MO‐
DE = 0.)

0002

El esclavo DP o dispositivo PROFINET IO está desactivado (este código de error solo es posible con
MODE = 0.)

7000

Primera llamada con REQ= 0. La petición definida mediante LADDR no está activa; BUSY tiene el valor
"0".

7001

Primera llamada con REQ= 1. Se ha lanzado la petición definida mediante LADDR; BUSY tiene el valor
"1".

7002

Llamada intermedia (REQ irrelevante). La petición activada todavía está procesándose; BUSY tiene el
valor "1".

8090

● No se ha configurado un módulo con la dirección especificada en LADDR.
● Se está utilizando la CPU como esclavo I / I-device y se ha indicado en LADDR una dirección de este
esclavo I / I-device.

8092

El proceso de desactivación en curso de un esclavo DP o un dispositivo PROFINET IO (MODE=2) no se
puede interrumpir activándolo (MODE=1). Active el componente en otro momento.

8093

A la dirección indicada en LADDR no le corresponde ningún esclavo DP o dispositivo PROFINET IO que
se pueda activar o desactivar, o bien no se conoce el parámetro MODE.

8094

Se ha intentado activar un dispositivo que podría ser interlocutor de un puerto de cambio de herramienta.
Sin embargo, en este momento hay otro dispositivo activado en ese puerto de cambio de herramienta. El
dispositivo activado permanece activado.

80A0

Error de comunicación entre la CPU y el controlador IO.

80A3

El maestro DP o controlador PROFINET IO afectado no soporta esta función.

80A4

La CPU no soporta esta función para maestros DP o controladores PROFINET IO externos.

80A7

Durante la activación se ha rebasado el tiempo: El dispositivo remoto no está accesible o bien el tiempo
de parametrización para la periferia centralizada y descentralizada es insuficiente. El estado del disposi‐
tivo remoto es "activado", pero no está accesible.

80AA

Activación con errores en el esclavo DP o dispositivo PROFINET IO: Diferencias en la configuración

80AB

Activación con errores en el esclavo DP o dispositivo PROFINET IO: Error de parametrización

80AC

Activación con errores en el esclavo DP o dispositivo PROFINET IO: mantenimiento necesario

2486

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error* Explicación
(W#16#...)
80C3

● Error temporal de recursos: En este momento la CPU está procesando el máximo posible de
peticiones de activación/desactivación (8).
● La CPU está recibiendo una configuración modificada. Debido a ello, en este momento no es posible
desactivar ni activar esclavos DP o dispositivos PROFINET IO.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

ReconfigIOSystem: Reconfigurar el sistema IO
ReconfigIOSystem: reconfigurar el sistema IO
Descripción
La instrucción "ReconfigIOSystem" permite transferir un registro a la interfaz PROFINET de la
CPU. Dicho registro (parámetro "CTRLREC") contiene la información siguiente para controlar
la configuración:
● Una lista de los dispositivos IO opcionales que deben activarse
● Una lista de los puertos del interlocutor que deben especificarse si en las propiedades de
puertos de dispositivos IO se ha ajustado la opción "Interlocutor activado en el programa de
usuario".
Nota
La instrucción "ReconfigIOSystem" usa internamente la instrucción "D_ACT_DP" en MODE 1
y en MODE 3 para activar y desactivar dispositivos IO. Por tanto, observe las reglas e
indicaciones en la descripción de esta instrucción.
Consulte también "D_ACT_DP: activar/desactivar esclavos DP (Página 2482)".

Dependencias entre versiones de instrucciones
La versión V1.1 de la instrucción "ReconfigIOSystem" exige la versión V1.1 de la instrucción
"WRREC".
La versión V1.0 de la instrucción "ReconfigIOSystem" exige la versión V1.1 de la instrucción
"WRREC".

Programación del PLC
Manual de programación y manejo, 11/2019

2487

Instrucciones
4.1 Instrucciones

Funcionamiento
"ReconfigIOSystem" es una instrucción que funciona de forma asíncrona. Su ejecución se
prolonga a lo largo de varias llamadas. Para iniciar la petición debe llamarse
"ReconfigIOSystem" con REQ=1.
El estado de la petición se indica a través de los parámetros de salida STATUS y BUSY.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "ReconfigIOSystem":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Parámetro de control disparado por flanco

I, Q, M, D, L o cons‐
tante

Con el parámetro MODE se controla el funcio‐
namiento de la instrucción. La descripción de‐
tallada del funcionamiento se explica a conti‐
nuación de esta tabla.

MODE

Input

UINT

REQ=1: realizar transferencia de datos

Valores posibles:
● 1: desactivar todos los dispositivos IO del
sistema IO para la fase de reequipamiento
● 2: reconfigurar el sistema IO según los
ajustes del registro (CTRLREC)
● 3: activar de nuevo todos los dispositivos
IO del sistema IO tras la reconfiguración
LADDR

Input

HW_INTERFA‐
CE

I, Q, M, D, L o cons‐
tante

Identificador de hardware de la interfaz PRO‐
FINET (controlador IO)

CTRLREC

Input

VARIANT

I, Q, M, D, L

Juego de datos para controlar la configuración
real del sistema IO

DONE

Output

BOOL

I, Q, M, D, L

0: instrucción no finalizada aún

BUSY

Output

BOOL

I, Q, M, D, L

1: instrucción finalizada
Identificación de componente activo:
0: instrucción activa
1: instrucción finalizada
ERROR

Output

BOOL

I, Q, M, D, L

0: la instrucción ha finalizado sin errores
1: instrucción finalizada con error

STATUS

Output

DWORD

I, Q, M, D, L

Resultado/identificación de error

ERR_INFO

Output

WORD

I, Q, M, D, L

Identificador de hardware del último dispositi‐
vo IO que causa el error.

Encontrará más información sobre los tipos de datos válidos en "Relación de los tipos de datos
válidos (Página 241)".

2488

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro MODE
Para el parámetro de entrada MODE pueden aplicarse los valores siguientes:
MODE

Descripción

1

Todos los dispositivos IO del sistema IO se desactivan mediante la llamada de la ins‐
trucción con Mode 1. Internamente, la instrucción "ReconfigIOSystem" utiliza la ins‐
trucción "D_ACT_DP". Los errores determinados mediante D_ACT_DP los indica "Re‐
configIOSystem" en los parámetros de salida siguientes:
● STATUS (código de error)
● ERR_INFO (identificador de hardware del dispositivo IO que causa el error).
En STATUS y ERR_INFO, la CPU registra el último error detectado o la última ID de
hardware detectada y al hacerlo sobrescribe un código de error ya existente. Por ello es
posible que existan otros errores además del registrado.

2

La instrucción transfiere el juego de datos para controlar la configuración real del sis‐
tema IO a la interfaz PROFINET direccionada mediante LADDR. La estructura del
juego de datos se describe en el apartado siguiente. Para la evaluación de errores
consulte el apartado siguiente del parámetro STATUS.

3

Se activan todos los dispositivos IO no opcionales del sistema IO así como los dispo‐
sitivo IO opcionales listados en el registro de control CTRLREC.
Los dispositivos IO opcionales que no se indican en el registro CTRLREC se mantienen
inactivos.
Si en el registro de control CTRLREC aparecen dispositivos IO que forman parte de
Docking Units, el sistema PN IO se comporta del siguiente modo:
● Los dispositivos IO de las Docking Units permanecen desactivados cuando se llama
ReconfigIOSystem con Mode 3.
Este comportamiento equivale al de una configuración sin dispositivos IO
controlados por configuración. Los dispositivos IO de las Docking Units están
desactivados en el ajuste estándar y no tienen que activarse en el programa de
usuario.

Estructura del juego de datos de control
Con el registro de control (parámetro "CTRLREC") se indica a la interfaz PROFINET de la CPU
qué dispositivos IO parametrizados opcionalmente se encuentran en el sistema IO real y qué
interconexiones de puertos deben activarse.
Para ello se requiere una configuración que permita adaptar el sistema IO real:
● Los dispositivos IO que figuran en el juego de datos de control deben estar activados como
"Dispositivo IO opcional" (propiedades del dispositivo IO: Interfaz PROFINET [X1] >
Opciones avanzadas > Opciones de interfaz).
● Las interconexiones de puertos indicadas en el juego de datos de control solo son posibles
si en los puertos correspondientes se ha ajustado el puerto interlocutor a "Interlocutor
activado en el programa de usuario".

Programación del PLC
Manual de programación y manejo, 11/2019

2489

Instrucciones
4.1 Instrucciones
El parámetro "CTRLREC" es del tipo de datos "VARIANT". El juego de datos de control
"CTRLREC" debe presentar la siguiente estructura:
● Hasta la versión V1.1 de ReconfigIOSystem: array de elementos del tipo de datos Word
(para direccionamiento numérico).
● A partir de la versión V1.2 de ReconfigIOSystem: array de elementos del tipo de datos UInt
(para direccionamiento simbólico o numérico), o array de elementos del tipo de datos Word
(para direccionamiento numérico).
A continuación se describe la estructura básica "CTRLREC" con el tipo de datos de elemento
WORD.
Los identificadores de hardware necesarios se leen directamente en la ficha "Constantes de
sistema" de la vista de redes o de la vista de dispositivos. Para ello se selecciona el objeto en
la vista de redes (dispositivo IO) o en la vista de dispositivos (interfaz PROFINET).
Recomendación: Si emplea el nombre de los identificadores de hardware, podrá hacer uso del
direccionamiento simbólico de dichos identificadores.
Nombre

Tipo de datos

Comentario

Version_High, Version_Low

Word

Versión del juego de datos de control(
High Byte: 01
Low Byte: 00

Number_of_opt_Devices_used

Word

Número de dispositivos IO opcionales que se usan en el siste‐
ma IO real. Los dispositivos IO opcionales que no se indican a
continuación se mantienen inactivos.

Activate_opt_Device_1

UINT / Hw_Device

Los dispositivos IO opcionales que están presentes en la con‐
figuración real se indican con sus identificadores de hardware.
Utilice la constante de sistema del objeto de dispositivo IO.
Ejemplo: el objeto de dispositivo IO tiene el nombre "IO-Devi‐
ce_4~IODevice" y es del tipo "Hw_Device".

Activate_opt_Device_2

UINT / Hw_Device

2º dispositivo IO opcional (por ejemplo con el valor 262)

...

...

...

Activate_opt_Device_n

UINT / Hw_Device

n. dispositivo IO opcional n (por ejemplo con el valor 282)

Number_of_Port_Interconnec‐
tions_used

Word

Número de interconexiones de puertos listadas a continuación.
Si no se especifican interconexiones de puertos, debe introdu‐
cirse un "0".
Para todos los puertos para los que se ha configurado "Inter‐
locutor activado en el programa de usuario" y que no se listan
a continuación, la CPU usa la configuración "Cualquier interlo‐
cutor".

Port_Interconnection_1_Local

UINT / Hw_Interface

1ª interconexión de puertos, ID de hardware del puerto local
Utilice la constante de sistema del objeto de puerto.
Ejemplo: El objeto de puerto tiene el nombre "IO-Devi‐
ce_2~PROFINET_interface~Port_2" y es del tipo "Hw_Interfa‐
ce".

Port_Interconnection_1_Remote

UINT / Hw_Interface

1ª interconexión de puerto, ID de hardware del puerto interlo‐
cutor

Port_Interconnection_2_Local

UINT / Hw_Interface

2ª interconexión de puertos, ID de hardware del puerto local

Port_Interconnection_2_Remote

UINT / Hw_Interface

2ª interconexión de puerto, ID de hardware del puerto interlo‐
cutor

...

...

...

2490

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Nombre

Tipo de datos

Comentario

Port_Interconnection_n_Local

UINT / Hw_Interface

nª interconexión de puertos, ID de hardware del puerto local

Port_Interconnectio_n_Remote

UINT / Hw_Interface

nª interconexión de puertos, ID de hardware del puerto local

Parámetro STATUS
El parámetro de salida STATUS contiene información de error. Encontrará la lista detallada de
los códigos de error posibles en el apartado siguiente. Si se interpreta STATUS como
ARRAY[1...4] of BYTE, la información de error tiene la estructura siguiente:
Elemento de cam‐
po

Nombre

Significado

STATUS[1]

Function_Num

B#16#DF: error al escribir un juego de datos, de lo contrario B#16#00.

STATUS[2]

Error_Decode

Si se produce un error se emite B#16#80 (leer y escribir juegos de datos en el
contexto conforme a IEC 61158-6).

STATUS[3]

Error_Code_1

B#16#AA en caso de error en la estructura del juego de datos

STATUS[4]

Error_Code_2

Extensión específica del fabricante de la identificación de error:
● B#16#00 Error en el juego de datos (p. ej. valores erróneos de byte de relleno
(diferente de 0)
● B#16#01 Reservado
● B#16#02 Como mínimo un número de estación de un dispositivo IO no es
válido en el juego de datos (no está configurado o designa un dispositivo IO no
opcional o tiene el valor 0 para un controlador IO)
● B#16#03 Como mínimo un puerto interlocutor especificado en el juego de
datos no es válido:
Ejemplos:
–

Falta la dirección de subslot de un puerto interlocutor

–

El puerto interlocutor no está bien configurado (el ajuste correcto es:
"Interlocutor activado en el programa de usuario")

–

El puerto interlocutor pertenece a un dispositivo IO que está desactivado

● B#16#10 Versión del registro de control CTRLREC no válida (la versión
indicada no se soporta)
● B#16#11 El número de dispositivos IO opcionales que deben activarse en el
registro de control CTRLREC no se soporta
● B#16#12 El número de interconexiones especificadas ("Interlocutor activado
en el programa de usuario") en el registro de control CTRLREC no se soporta
● B#16#13 Error en el cálculo interno del identificador de hardware en el número
de dispositivo. El parámetro de salida ERR_INFO contiene el identificador de
hardware del dispositivo que causa el error.
● B#16#14 Error de coherencia: la longitud del registro de control CTRLREC no
concuerda con las indicaciones del registro de control. Ejemplo: Se han
indicado 20 dispositivos IO opcionales, pero el registro de control solo tiene
una longitud de 10 bytes.

Programación del PLC
Manual de programación y manejo, 11/2019

2491

Instrucciones
4.1 Instrucciones

Códigos de error (parámetro STATUS)
Código de error

Descripción

16#0000_0000

Petición finalizada sin errores

16#0070_0000

Ninguna petición activa

16#0070_0100

Primera llamada de la instrucción

16#0070_0200

Llamada subsiguiente de la instrucción (instrucción sigue en curso, BUSY=1)

16#0080_8000

MODE no se soporta

16#0084_5100

Tipo de datos erróneo del juego de datos CRTLREC.
Utilice un array de UInt o un array de Word.

16#0080_9100

El parámetro LADDR no direcciona ninguna interfaz PROFINET (no existe o es del
tipo erróneo, p. ej. interfaz PROFIBUS).
La interfaz PROFINET no soporta el control de la configuración de sistemas IO.

16#0080_Cx00

Error temporal, p. ej. debido a falta temporal de recursos.

16#DF80_AAxy

Error en la estructura del juego de datos (MODE 2). Consulte arriba el significado
de "xy", definición de STATUS[4] Error_Code_2.

16#DF80_B6xy

Control de configuración imposible porque no se ha configurado ningún dispositi‐
vo IO opcional ni se ha parametrizado ningún puerto con "Interlocutor activado en
el programa de usuario". Esta configuración es requisito previo para llamar la
instrucción.
"xy" es irrelevante.

16#0080_9400

Códigos de error transferidos de la instrucción llamada internamente D_ACT_DP.

16#0080_A000

Consulte el significado de estos códigos de error en "D_ACT_DP (Página 2482)".

16#0080_A700

Los identificadores de hardware de los dispositivos IO causantes de fallos se
registran en ERR_INFO (la entrada se sobrescribe continuamente con los errores
sucesivos). Si hay varios dispositivos IO afectados, se recomienda efectuar el
diagnóstico online con STEP 7.

16#0080_AA00
16#0080_AB00
16#0080_AC00

Con configuración IRT: Los números de dispositivo de los dispositivos IO deben
seguir la interconexión topológica en orden ascendente a partir del controlador IO
(ver aquí).

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para ReconfigIOSystem (Página 2493).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

2492

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo de programa para ReconfigIOSystem
Introducción
En el ejemplo siguiente se va a configurar un sistema IO mediante el programa con ayuda del
juego de datos de control "CTRLREC". La configuración de destino debe estar compuesta por
una CPU S7-1500, un dispositivo IO (p. ej. ET 200MP) y un dispositivo IO opcional (p. ej. ET
200SP). Para ello, desactive un sistema IO existente, transfiera los valores de configuración a
la interfaz PROFINET de la CPU y active los dispositivos IO.
Encontrará información adicional sobre los juegos de datos en Descripción general de los tipos
de juegos de datos (Página 2375).

Requisitos
● Se ha creado una CPU S7-1500.
● Se han creado dos ET 200.
● Se ha creado una conexión PROFINET y se han realizado los ajustes de hardware.
– dispositivo IO (p. ej. ET 200MPIM 155-5 PN HF)
– dispositivo IO (p. ej. ET 200SPIM 155-6 PN ST)
– el sistema IO es configurado por el programa

Nota
Configuración hardware para un sistema IO creado por el programa
Proceda del siguiente modo:
1. Conecte los dos ET 200 a través de PROFINET con la CPU.
2. Asigne a los dos ET 200 la CPU como controlador IO. A continuación abra las
propiedades de la CPU.
3. Abra la entrada "Interfaz PROFINET [X1] > Opciones avanzadas > Puerto X1 P1 >
Interconexión de puertos > Puerto interlocutor". Seleccione la opción "Ajustar
interlocutor desde el programa de usuario". Haga lo mismo para "Puerto X1 P2".
4. Abra las propiedades del ET 200MP (...> Puerto X1 P1) y seleccione la opción
"Configurar interlocutor mediante programa de usuario" (ver paso 3).
5. Abra las propiedades del ET 200SP (...> Puerto X1 P1) y realice los ajustes siguientes:
– Seleccione la opción "Ajustar interlocutor desde el programa de usuario" (véase
paso 3).
– Abra "Interfaz PROFINET [X1] > Opciones avanzadas > Opciones de interfaz" y
active la opción "Dispositivo IO opcional".

Programación del PLC
Manual de programación y manejo, 11/2019

2493

Instrucciones
4.1 Instrucciones

Almacenamiento de datos
Para almacenar los datos es preciso crear las estructuras "operateMode" y "ctrlRec" y otras 13
variables más en un bloque de datos global.
La estructura "ctrlRec" contiene el juego de datos de control "CTRLREC".

Nota
Los valores de los identificadores de hardware ("laddr_interface", "ctrlRec") deben indicarse de
forma acorde al sistema.
P. ej. el identificador de hardware de la interfaz de la CPU ("laddr_interface") se determina del
siguiente modo:
Abra en la CPU la entrada "Variables PLC > Mostrar todas las variables > Constantes de
sistema" y busque el nombre <Local~PROFINET-Interface_1> con el tipo de datos
"Hw_Interface". La celda "Valor" correspondiente contiene el identificador de hardware.

2494

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Nota
Preste atención a las interfaces utilizadas.
● El puerto X1 P1 del dispositivo IO (ET 200MP / "<IO_device_1>") está conectado con el
puerto X1 P1 de la CPU ("<Local>").
● El puerto X1 P1 del dispositivo IO opcional (ET 200SP / "<IO_device_2>") está conectado
con el puerto X1 P2 de la CPU ("<Local>"). Del dispositivo IO opcional se necesita además
el identificador de hardware del dispositivo (tipo de datos "Hw_Device").

Programación del PLC
Manual de programación y manejo, 11/2019

2495

Instrucciones
4.1 Instrucciones

Interconectar parámetros en la FC "SLI_FC_start_reset_ReconfigIOS"
Para iniciar o reiniciar la instrucción "ReconfigIOSystem" es necesario crear la FC
"SLI_FC_start_reset_ReconfigIOS". Para reenviar los datos deben crearse las siguientes
variables locales en la FC.

Segmento 1: Para activar el parámetro de entrada REQ ("getExecute") se interconecta la
variable "start".

Segmento 2: Para desactivar "start" se crean las interconexiones siguientes.

Segmento 3: Para desactivar todos los valores de proceso activados se crean las
interconexiones siguientes. Parte 1 del segmento:

2496

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parte 2 del segmento:

Segmento 4: Para desactivar "reset" se crean las interconexiones siguientes.

Programación del PLC
Manual de programación y manejo, 11/2019

2497

Instrucciones
4.1 Instrucciones

Interconectar parámetros en la FC "SLI_FC_switchMode_ReconfigIOS"
Para reconfigurar de manera segura el sistema IO deben ejecutarse los tres modos de
"ReconfigIOSystem". Para no tener que conmutar personalmente los modos de la instrucción
"ReconfigIOSystem", cree en la FC "SLI_FC_switchMode_ReconfigIOS" un automatismo para
conmutar los modos.
Segmento 1: Para guardar la información en caso de fallo se crean las interconexiones
siguientes.

Segmento 2: Para iniciar automáticamente la instrucción "ReconfigIOSystem" en modo 2 o en
modo 3 se crean las interconexiones siguientes.

Segmento 3: El éxito de la ejecución de ReconfigIOSystem en el modo 1 se captura del modo
siguiente.

Segmento 4: Para conmutar de manera segura del modo 1 al modo 2 se crean las
interconexiones siguientes.

2498

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 5: El éxito de la ejecución de ReconfigIOSystem en el modo 2 se captura del modo
siguiente.

Segmento 6: Para conmutar de manera segura del modo 2 al modo 3 se crean las
interconexiones siguientes.

Segmento 7: El éxito de la ejecución de ReconfigIOSystem en el modo 3 se observa del modo
siguiente.

Programación del PLC
Manual de programación y manejo, 11/2019

2499

Instrucciones
4.1 Instrucciones

Segmento 8: Para finalizar la ejecución de ReconfigIOSystem se crean las interconexiones
siguientes.

Nota
Otra alternativa consiste en conmutar del modo 3 al modo 1 una vez terminada la ejecución.
Para ello, introduzca en la instrucción "MOVE" el valor "1".

Interconectar parámetros en el FB "SLI_FB_ReconfigIOSystem"
La instrucción "ReconfigIOSystem" se llama en un FB (SLI_FB_ReconfigIOSystem). Para
reenviar los datos deben crearse las siguientes variables locales en el FB. Las variables
"#recordAoWord" y "#recordStruct" se crean en forma de elemento AT. Las variables deben
tener el mismo tamaño (al igual que "ctrlRec").

2500

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Segmento 1: Para transferir el juego de datos ("ctrlRec") se crea la interconexión siguiente.

Segmento 2: La FC "SLI_FC_start_reset_ReconfigIOS" se interconecta del siguiente modo.

Segmento 3: La instrucción "ReconfigIOSystem" se interconecta del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2501

Instrucciones
4.1 Instrucciones
Segmento 4: La FC "SLI_FC_switchMode_ReconfigIOS" se interconecta del siguiente modo.

El FB ("SLI_FB_ReconfigIOSystem") se llama en un OB1.

Resultado (FB "SLI_FB_ReconfigIOSystem")
FB segmento 1:
A través de una instrucción MOVE se transfieren los valores del juego de datos ("ctrlRec") a un
Array of WORD ("#recordAoWord"). Para mayor claridad, las variables de las estructuras
"ctrlRec" y "#recordStruct" se muestran como nombres explícitos.
FB segmento 2:
Si el parámetro de entrada start ("start") devuelve el estado lógico "TRUE", la variable
"getExecute" y el parámetro de salida startDone ("startDone") se ponen a "TRUE". Mediante
la variable "getExecute" a "TRUE" se inicia la ejecución de la instrucción "ReconfigIOSystem".
Si el parámetro de entrada reset ("reset") devuelve el estado lógico "TRUE", se inicializan el
comando de arranque de ReconfigIOSystem, los valores de proceso de la ejecución e
información sobre el fallo.
FB segmento 3:
Si el parámetro de entrada REQ ("getExecute") devuelve el estado lógico "TRUE", se inicia la
instrucción "ReconfigIOSystem". Mediante el parámetro de entrada LADDR
("laddr_interface"), la instrucción "ReconfigIOSystem" llama la interfaz de la CPU.
A la instrucción "ReconfigIOSystem" se le transfiere el modo de operación a través del
parámetro de entrada MODE ("operateMode.value"). De acuerdo con el valor de arranque "1",
ReconfigIOSystem desactiva todos los sistemas IO existentes en la CPU. En el parámetro de
salida STATUS ("status") se indica el estado del bloque. En el ejemplo la ejecución transcurre
sin errores.
Solo en el modo 2 la instrucción "ReconfigIOSystem" llama al juego de datos en el parámetro
de entrada CTRLREC ("#recordAoWord"). Los valores de configuración del sistema IO que va
a crearse se transfieren de ReconfigIOSystem a la CPU (controlador IO).
En el modo 3, la instrucción "ReconfigIOSystem" activa el sistema IO. La conmutación de los
parámetros de entrada REQ ("getExecute") y MODE ("operateMode.value") se realiza en el
segmento 4 ("SLI_FC_switchMode_ReconfigIOS").

2502

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

FB segmento 4:
Si la instrucción "ReconfigIOSystem" se ha ejecutado correctamente en el modo 1 (la variable
"done" tiene el valor "TRUE"), la variable "operateMode.Disable_all_IO_devices_done" se
pone a "TRUE". Por ello, a continuación el parámetro de entrada REQ ("getExecute") se
inicializa a "FALSE". Tan pronto como ReconfigIOSystem está inactivo ("status" tiene el valor
"16#0070_0000"), se transfiere a la variable "operateMode.value" el valor "2". Después
ReconfigIOSystem se encuentra en el modo 2.
En el modo 2 el parámetro de entrada REQ ("getExecute") se pone automáticamente a "TRUE"
si para la instrucción "ReconfigIOSystem" se aplica lo siguiente:
● ReconfigIOSystem está inactivo ("busy" y "done" son "FALSE").
● No se produce ningún error ("error" es "FALSE").
● No se ha alcanzado el estado correcto del modo 2
("operateMode.Reconfigure_IO_system_done" es "FALSE").
Si la instrucción "ReconfigIOSystem" se ha ejecutado correctamente en el modo 2 (la variable
"done" tiene el valor "TRUE"), la variable "operateMode.Reconfigure_IO_system_done" se
pone a "TRUE". A continuación todo ocurre de modo similar al modo 1:
● La variable "getExecute" se inicializa a "FALSE".
● ReconfigIOSystem ("operateMode.value") pasa al modo 3.

Programación del PLC
Manual de programación y manejo, 11/2019

2503

Instrucciones
4.1 Instrucciones
En el modo 3 el parámetro de entrada REQ ("getExecute") se pone automáticamente a "TRUE"
si para la instrucción "ReconfigIOSystem" se aplica lo mismo que para el modo 2, con una
excepción:
● No se ha alcanzado el estado correcto del modo 3
("operateMode.Enable_all_IO_devices_done" es "FALSE").
El estado correcto del modo 3 (la variable "done" tiene el valor "TRUE") se consulta de igual
manera que para el modo 2. Una vez que la ejecución ha finalizado con éxito,
ReconfigIOSystem permanece en el modo 3 ("operateMode.value" conserva el valor).
Una vez finalizada la ejecución de los tres modos, la instrucción "ReconfigIOSystem" está
inactiva ("status" tiene el valor "16#0070_0000"). El sistema IO está creado: una CPU S7-1500
con un dispositivo IO y un dispositivo IO opcional. Ambos dispositivos IO están activados.

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
ReconfigIOSystem: reconfigurar el sistema IO (Página 2487)

Otras
RD_REC: Leer registro de periferia
Descripción
Esta instrucción permite leer el juego de datos con número RECNUM del componente que se
ha direccionado. Para iniciar la lectura, debe ajustarse a "1" el parámetro de entrada REQ . Si
la operación de lectura se ejecuta de inmediato, la instrucción devuelve el valor "0" en el
parámetro de salida BUSY . Si BUSY tiene el valor "1", la operación de lectura todavía no ha
finalizado.

2504

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Consulte también: Diferencia entre las instrucciones que funcionan síncronamente y las que
funcionan asíncronamente (Página 618). Una vez efectuada correctamente la transferencia de
datos, el juego de datos leído se guarda en el área de destino delimitada mediante RECORD .
Nota
Si se lee un juego de datos con número mayor que 1 desde un FM o un CP adquiridos antes
de febrero de 1997 (en lo sucesivo denominados "módulos antiguos"), "RD_REC" se comporta
de un modo diferente que con un módulo nuevo. Este caso especial se describe en la sección
"Uso de FM y CP S7-300 antiguos con n.º de juego de datos > 1" (ver abajo).
Si un esclavo DPV1 está configurado mediante archivo GSD (a partir de la rev. 3 de GSD) y la
interfaz DP del maestro DP está ajustada como "Compatible con S7", los módulos de E/S no
pueden leer en el programa de usuario los juegos de datos con "RD_REC". En este caso, el
maestro DP direcciona un slot incorrecto (slot configurado + 3).
Solución: Conmutar la interfaz del maestro DP a "DPV1".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RD_REC":
Parámetro

Declaración

Tipo de datos Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

REQ = 1: solicitud de lectura

LADDR

Input

HW_IO

I, Q, M, D, L o cons‐
tante

ID de hardware del módulo.

RECNUM

Input

BYTE

I, Q, M, D, L o cons‐
tante

Número del juego de datos (valores admisibles:
de 0 a 240)

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución de la
instrucción, el valor de respuesta contendrá un
código de error. Adicionalmente: Longitud en
bytes del juego de datos realmente transferido
(valores posibles: de +1 hasta +240), si el área
de destino es mayor que el juego de datos trans‐
ferido y no se ha producido ningún error durante
la transferencia.

BUSY

Output

BOOL

I, Q, M, D, L

BUSY = 1: la lectura todavía no ha finalizado.

RECORD

Output

VARIANT

I, Q, M, D, L

Área de destino del juego de datos leído. En caso
de procesamiento asíncrono de "RD_REC", de‐
be comprobarse que los parámetros actuales de
RECORD presenten la misma información de
longitud en todas las llamadas. Solo se admite el
tipo de datos BYTE .
Nota: Tenga en cuenta que en las CPU S7-300,
el parámetro RECORD siempre requiere que se
especifiquen por completo los parámetros de DB
(ej.: P#DB13.DBX0.0 byte 100). En las CPU
S7-300 no está permitido omitir un número de DB
explícito; de lo contrario se genera un aviso de
error en el programa de usuario.

Programación del PLC
Manual de programación y manejo, 11/2019

2505

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RECORD
Nota
Para asegurarse de que siempre se lea el juego de datos completo, debe seleccionarse un
área de destino con una longitud de 241 bytes. Si la transferencia de datos se realiza sin
errores, la longitud real del juego de datos se puede leer en RET_VAL .

Uso de FM y CP S7-300 antiguos con n.º de juego de datos > 1
Si se desea leer un juego de datos con número mayor que 1 con la instrucción "RD_REC"
desde un FM S7-300 antiguo o un CP S7-300 antiguo, debe tenerse en cuenta lo siguiente:
● Si el área de destino es mayor que la longitud real del juego de datos deseado, no se
registran datos en RECORD . En RET_VAL se escribe W#16#80B1.
● Si el área de destino es menor que la longitud real del juego de datos deseado, la CPU leerá
tantos bytes desde el principio del juego de datos como se indique en la longitud
especificada en RECORD y los registrará en RECORD . En RET_VAL se escribe "0".
● Si la indicación de longitud de RECORD es igual a la longitud real del juego de datos
deseado, la CPU lee el juego de datos en cuestión y lo guarda en RECORD ; RET_VAL se
ajusta a "0".

Parámetro RET_VAL
● Si se ha producido un error durante la ejecución de la función, el valor de respuesta
contendrá un código de error.
● Si no se ha producido ningún error durante la transferencia, RET_VAL contiene el valor
– 0 si toda el área de destino se ha llenado con datos del juego de datos seleccionado
(aunque el juego de datos esté incompleto).
– La longitud en bytes del juego de datos realmente transferido (valores posibles: de +1
hasta +240), si el área de destino es mayor que el juego de datos transferido.
Nota
Si se produce el error general W#16#8745, esto significa solo que durante la operación
de escritura no ha sido posible acceder a por lo menos un byte. El juego de datos se ha
leído correctamente desde el módulo y escrito correctamente en el área de memoria de
E/S.

2506

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Dentro de la información de error "verdadera" (códigos de error W#16#8xyz) de la tabla
siguiente se indican dos casos distintos:
● Errores temporales (códigos de error de W#16#80A2 a 80A3, 80Cx):
En este tipo de errores es posible que el error se elimine sin intervención del usuario. Por
ello, puede bastar con llamar de nuevo la instrucción (si es necesario, varias veces).
Ejemplo de error temporal: En este momento los recursos necesarios están ocupados
(W#16#80C3).
● Errores permanentes (códigos de error W#16#809x, 80A0, 80A1, 80Bx):
Los errores de este tipo no se eliminan sin intervención del usuario. Una vez que se haya
eliminado el error es necesario volver a llamar la instrucción. Ejemplo de error permanente:
Indicación de longitud errónea en RECORD (W#16#80B1).
Nota
Si se transfieren con "WR_REC (Página 2509)" juegos de datos a un esclavo DPV1 o se
leen juegos de datos RD_REC desde un esclavo DPV1 que funciona en modo DPV1, el
maestro DP evalúa de la siguiente manera la información de error recibida desde el
esclavo:
Si la información de error se encuentra en las áreas de W#16#8000 a W#16#80FF o de
W#16#F000 a W#16#FFFF, el maestro DP reenvía la información de error a la instrucción.
Si se encuentra fuera de estas áreas, reenvía a la instrucción el valor W#16#80A2 y
suspende el esclavo.
Encontrará la descripción de la información de error procedente de los esclavos DPV1 en
STATUS[3] Parámetro STATUS (Página 2447).

Parámetro RET_VAL para WR_REC y RD_REC
Código de error* Explicación
(W#16#...)

Restricción

0000

Ningún error

-

7000

Primera llamada con REQ=0: No hay ninguna transferencia de datos
activa; BUSY tiene el valor 0.

-

7001

Primera llamada con REQ=1: Transferencia de datos lanzada; BUSY
tiene el valor 1.

Periferia descentralizada

7002

Llamada intermedia (REQ irrelevante): Transferencia de datos ya
activa; BUSY tiene el valor 1.

Periferia descentralizada

8090

Dirección indicada no válida en el parámetro ADDR.

-

8092

En la referencia ANY se ha indicado un tipo distinto a BYTE.

-

8093

Esta instrucción no es válida para la ID de hardware indicada en
LADDR.

-

80A0

Acuse negativo al leer el módulo: Módulo extraído durante la opera‐ Solo con "RD_REC"
ción de lectura o módulo defectuoso

80A1

Acuse negativo al escribir en el módulo: Módulo extraído durante la
operación de escritura o módulo defectuoso

Solo con "WR_REC (Pági‐
na 2509)"

80A2

● Error de protocolo DP con Layer 2 (p. ej. fallo de esclavo o fallos
de bus)

Periferia descentralizada

● Con ET200S no es posible leer juegos de datos en el modo DPV0.

Programación del PLC
Manual de programación y manejo, 11/2019

2507

Instrucciones
4.1 Instrucciones
Código de error* Explicación
(W#16#...)

Restricción

80A3

Error de protocolo de DP con User-Interface/User

Periferia descentralizada

80A4

Fallo de comunicación en PROFIBUS.

-

80B0

● La instrucción no es posible para el tipo de módulo

-

● El módulo no conoce este juego de datos.
● El número de juego de datos 241 no es admisible.
● Con "WR_REC (Página 2509)" no se permiten los juegos de
datos 0 ni 1.
80B1

La indicación de longitud en el parámetro RECORD es errónea.

● Con "WR_REC
(Página 2509)": Longitud
errónea
● Con "RD_REC" (posible solo si
se usan FM S7-300 antiguas o
CP S7-300
antiguos):Indicación > longitud
juego de datos
● Con DPNRM_DG: Indicación <
longitud de juego de datos

80B2

El slot configurado no está ocupado.

80B3

El tipo de módulo real no coincide con el tipo de módulo configurado -

-

80B5

El esclavo DP o el módulo no está listo.

-

80B7

El esclavo DP o el módulo notifica un área no autorizada en un pa‐
rámetro o un valor.

Solo con "RD_REC"

80C0

Con "WR_REC (Página 2509)": Los datos solo se escriben en el es‐ Con "WR_REC (Página 2509)",
tado STOP de la CPU. Nota: En consecuencia, el programa de usua‐ "RD_REC" o "DPNRM_DG (Pági‐
rio no puede escribir. Solo es posible escribir datos online con la PG/ na 2541)"
el PC.
Con "RD_REC": El juego de datos está cargado en el módulo, pero
todavía no existen datos o los datos solo pueden leerse en el estado
STOP de la CPU. Nota: Si los datos solo pueden leerse en el estado
STOP de la CPU, el programa de usuario no puede evaluarlos. En tal
caso solo es posible leer los datos online con la PG/el PC.
Con "DPNRM_DG (Página 2541)": No existen datos de diagnóstico.

80C1

Los datos de la orden de escritura efectuada anteriormente en el
módulo para el mismo juego de datos no han sido procesados toda‐
vía por el módulo.

80C2

En este momento el módulo está procesando el máximo posible de
órdenes para una CPU.

80C3

En este momento los recursos necesarios (memoria, etc.) están ocu‐ pados.

80C4

Error temporal interno. No se ha podido ejecutar la orden.

-

-

Repita la orden. Si este error se produce a menudo, compruebe si hay
fuentes de perturbación en la instalación.
80C5

La periferia descentralizada no está disponible.

Periferia descentralizada

80C6

La transferencia de juegos de datos se ha cancelado por una inte‐
rrupción de la clase de prioridad (rearranque o segundo plano)

Periferia descentralizada

80Ex

Específico del fabricante. Consulte la documentación del módulo.

-

2508

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error* Explicación
(W#16#...)

Restricción

Información de
error general

-

Consulte también: GET_ERR_ID: Consultar ID de error localmente
(Página 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

WR_REC: Escribir registro en periferia
Descripción
La instrucción "WR_REC" permite transferir el registro RECORD al módulo direccionado.
Los datos que se deben transferir se leen del parámetro RECORD en la primera llamada. Si la
transferencia del registro dura más que una llamada, en las llamadas consecutivas de la
instrucción (para la misma petición), el contenido del parámetro RECORD ya no es relevante.
Para iniciar la escritura, debe ajustarse a "1" el parámetro de entrada REQ. Si la operación de
escritura se ha podido ejecutar de inmediato, la instrucción devuelve en el parámetro de salida
BUSY el valor "0". Si BUSY tiene el valor "1", la operación de escritura todavía no ha finalizado.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "WR_REC":
Parámetro

Declaración

Tipo de datos Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L, T, C o
constante

REQ = 1: solicitud para escribir

LADDR

Input

HW_IO

I, Q, M, D, L o cons‐
tante

ID de hardware del módulo.

RECNUM

Input

BYTE

I, Q, M, D, L o cons‐
tante

Número de registro

RECORD

Input

VARIANT

I, Q, M, D, L

Registro

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución de la
instrucción, el valor de respuesta contendrá un
código de error.

BUSY

Output

BOOL

I, Q, M, D, L

BUSY = 1: la escritura todavía no ha finalizado.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2509

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
Consulte también: RD_REC: Leer registro de periferia (Página 2504)
Nota
Si aparece el error general W#16#8544, esto solo significa que estaba bloqueado el acceso a
por lo menos un byte del área de memoria de E/S que contiene el registro. Se ha proseguido
la transferencia de datos.

DPRD_DAT: Leer datos coherentes de un esclavo DP normalizado
Descripción
La instrucción "DPRD_DAT" lee datos coherentes de un módulo E/S.
La instrucción se puede utilizar tanto para módulos del módulo central como para esclavos DP
normalizados y dispositivos PROFINET IO.
"DPRD_DAT" es necesaria porque con los comandos de carga que acceden a la periferia o a
la memoria imagen de proceso de las entradas solo se puede leer un máximo de cuatro bytes
de forma coherente. Para leer datos coherentes también puede usarse, en caso necesario, la
memoria imagen de proceso de las entradas. En la documentación de la CPU se puede
comprobar si dispone de esta función. Encontrará más información sobre datos coherentes de
un esclavo DP normalizado/dispositivo PROFINET IO en el apartado "Coherencia de datos
(Página 3942)".

2510

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En caso necesario, utilice la instrucción "DPRD_DAT" también para un área de datos a partir
de 1 byte. La longitud máxima de los datos se indica en la documentación de la CPU (p. ej. 64
bytes en una S7-1214).
● Mediante el parámetro LADDR se selecciona el módulo del esclavo DP normalizado/
dispositivo PROFINET IO. Si se produce un error de acceso se notifica el código de error
W#16#8090.
● Mediante el parámetro RECORD se define el área de destino de los datos leídos:
– El área de destino tiene que tener como mínimo la misma longitud que las entradas del
módulo seleccionado. Si el área de destino es más larga que las entradas del módulo,
se escribirá con los valores de las entradas empezando por delante; en las CPU
S7-1200, los bytes restantes del área de destino no cambian, mientras que en las CPU
S7-1500 se rellenan con ceros. En un esclavo DP normalizado con estructura modular
o con varias ID de DP, la llamada a "DPRD_DAT" solo permite acceder cada vez a los
datos de un solo módulo con la ID de hardware configurada. Si se selecciona un área de
destino demasiado pequeña, el parámetro RET_VAL devuelve el código de error 80B1.
– Se pueden utilizar los siguientes tipos de datos: BOOL, BYTE, CHAR, WCHAR, WORD,
LWORD, DWORD, INT, UINT, USINT, SINT, LINT, ULINT, DINT, UDINT, REAL,
LREAL. También está permitido el uso de estos tipos de datos en una estructura de
datos del tipo ARRAY o STRUCT.
– Los tipos de datos STRING y WSTRING no se soportan.
– Se soportan los tipos de datos PLC (UDT) y tipos de datos de sistema.
● Si no se ha producido ningún error durante la transferencia de datos, los datos leídos se
registran en el área de destino definida en el parámetro RECORD .

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DPRD_DAT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

LADDR

Input

HW_IO

I, Q, M, L o cons‐
tante

ID de hardware del módulo del que se deben leer
los datos.
El identificador de hardware se puede consultar
en las Constantes de sistema.

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución de la
instrucción, el valor de respuesta contendrá un
código de error.

RECORD

Output

VARIANT

I, Q, M, D, L

Área de destino para los datos de usuario leídos.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2511

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
Código de
error*
(W#16#...)

Explicación

0000

No se ha producido ningún error.

8090

● No se ha configurado ningún módulo para la identificación HW especificada, o bien
● No se ha tenido en cuenta la limitación de longitud de los datos coherentes, o
● No se ha indicado ninguna identificación HW como dirección en el parámetro LADDR .

8092

Tipo de datos no soportado en el parámetro RECORD

8093

Para el identificador de hardware indicado en LADDR no existe ningún módulo DP o ningún dispositivo
PROFINET IO del que puedan leerse datos de forma coherente. Si el módulo direccionado a través de
LADDR no dispone de entradas, este código de error también aparece.

80A0

Se ha detectado un error de acceso al acceder a la periferia.

80B1

La longitud del área de destino especificada en el parámetro RECORD es más corta que la longitud de datos
de usuario configurada.

80C0

Los datos todavía no se han leído.

Información
Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)
de error gene‐
ral
* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Parámetro STATUS (Página 2447)
Cambiar formatos de visualización en el estado del programa (Página 8529)

DPWR_DAT: Escribir datos coherentes de un esclavo DP normalizado
Descripción
La instrucción "DPWR_DAT" transfiere los datos del parámetro RECORD de forma coherente
al módulo direccionado del módulo central o del esclavo DP normalizado/dispositivo
PROFINET IO y, dado el caso, a la memoria imagen de proceso (cuando el área de direcciones
afectada del esclavo DP normalizado se ha configurado como área de coherencia en una
memoria imagen de proceso).
"DPWR_DAT" es necesaria porque con los comandos de transferencia que acceden a la
periferia o a la memoria imagen de proceso de las salidas solo se puede escribir un máximo de
cuatro bytes de forma coherente. En caso necesario, escriba datos coherentes usando
también la memoria imagen de proceso de las salidas. En la documentación de la CPU se
puede comprobar si dispone de esta función. Para escribir datos coherentes, no deben
utilizarse al mismo tiempo ambas posibilidades: Utilice o bien "DPWR_DAT" o bien la escritura
a través de la memoria imagen de proceso de las salidas. Encontrará más información sobre
datos coherentes de un esclavo DP normalizado/dispositivo PROFINET IO en el apartado

2512

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
"Coherencia de datos (Página 3942)". Con un esclavo DP normalizado con estructura modular
solo es posible acceder a un módulo del esclavo DP.
PRECAUCIÓN
Acceso a la periferia
Al utilizar "DPWR_DAT", evite acceder a áreas de la periferia que tengan asignadas
memorias imagen parcial de proceso vinculadas a OB6x (alarmas de sincronismo).
En caso necesario, la instrucción "DPRD_DAT" también se puede utilizar para un área de
datos a partir de 1 byte. La longitud máxima de los datos se indica en la documentación de su
CPU (p. ej. 64 bytes en una S7-1214).
● Mediante el parámetro LADDR se selecciona el esclavo DP normalizado/dispositivo
PROFINET IO. Si se produce un error de acceso al módulo direccionado, se visualiza el
código de error 8090.
● Mediante el parámetro RECORD se define el área fuente de los datos que se deben escribir:
– El área fuente tiene que tener como mínimo la misma longitud que las salidas del módulo
seleccionado. Solo se transmiten las salidas; el resto de los bytes no se tienen en
cuenta. Si el área fuente especificada en el parámetro RECORD tiene una longitud
mayor que las salidas del módulo configurado, tan solo se transferirán datos hasta la
longitud máxima de las salidas. Si el área fuente especificada en el parámetro RECORD
tiene una longitud menor que las salidas del módulo configurado, se visualiza el código
de error 80B1.
– Se pueden utilizar los siguientes tipos de datos: BOOL, BYTE, CHAR, WCHAR, WORD,
LWORD, DWORD, INT, UINT, USINT, SINT, LINT, ULINT, DINT, UDINT, REAL,
LREAL. También está permitido el uso de estos tipos de datos en una estructura de
datos del tipo ARRAY o STRUCT.
– Los tipos de datos STRING y WSTRING no se soportan.
– Se soportan los tipos de datos PLC (UDT) y tipos de datos de sistema.
La transferencia de datos se realiza de forma síncrona. Con la finalización de la instrucción ha
finalizado el proceso de escritura.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DPWR_DAT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

LADDR

Input

HW_IO

I, Q, M, L o constante ID de hardware del módulo en el que se deben
escribir los datos.
El identificador de hardware se puede consul‐
tar en las Constantes de sistema.

RECORD

Input

VARIANT

I, Q, M, D, L

Área fuente para los datos de usuario que se
deben escribir.

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución de
la instrucción, el valor de respuesta contendrá
un código de error.

Programación del PLC
Manual de programación y manejo, 11/2019

2513

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de
error*
(W#16#...)

Explicación

0000

No se ha producido ningún error.

8090

● No se ha configurado ningún módulo para la identificación HW especificada, o bien
● No se ha tenido en cuenta la limitación de longitud de los datos coherentes, o
● No se ha indicado ninguna identificación HW en el parámetro LADDR .

8092

Tipo de datos no soportado en el parámetro RECORD

8093

Para la ID de hardware indicada en LADDR no existe ningún módulo DP o dispositivo PROFINET IO en el
que se puedan escribir datos de forma coherente. Este código de error aparece cuando el esclavo DP
normalizado/dispositivo PROFINET IO direccionado a través de LADDR no dispone de salidas.

80A1

Se ha detectado un error de acceso al acceder a la periferia

80B1

La longitud del área fuente indicada en el parámetro RECORD es inferior a las salidas del esclavo DP
normalizado/dispositivo PROFINET IO configurado.

80C1

Los datos de la petición de escritura efectuada anteriormente no han sido procesados todavía por el esclavo
DP normalizado/dispositivo PROFINET IO.

Información
de error gene‐
ral

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Parámetro STATUS (Página 2447)

iDevice / iSlave
RCVREC: Recibir registro
Descripción
Un I-device puede recibir un juego de datos de un controlador superior. La recepción se
efectúa en el programa de aplicación con la instrucción "RCVREC" (receive record).
La instrucción tiene los siguientes modos de operación:
● Comprobar si el I-device ha recibido una solicitud para la recepción de un juego de datos.
● Preparar un juego de datos en los parámetros de salida.
● Enviar una respuesta al controlador superior.

2514

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para establecer cuál de estos modos de operación debe ejecutar la instrucción, se usa el
parámetro de entrada MODE (ver abajo).
El I-device debe encontrarse en el estado operativo RUN o en el estado operativo ARRANQUE.
Con MLEN se indica el máximo de bytes que se deben recibir. Seleccione un área de destino
RECORD con una longitud de por lo menos MLEN bytes.
Cuando se ha recibido un juego de datos (MODE=1 o MODE=2), en el parámetro de salida
NEW se indica que el juego de datos se ha guardado en RECORD. Asegúrese de que
RECORD tenga una longitud suficiente. El parámetro de salida LEN contiene la longitud real
en bytes del juego de datos recibido.
Para la respuesta positiva al controlador superior, se deben ajustar CODE1 y CODE2 a cero.
Si se rechaza el juego de datos recibido, debe enviarse con CODE1 el Error Code 1 y con
CODE2 el Error Code 2 de la respuesta negativa al controlador superior.
Nota
Si el I-Device ha recibido una solicitud de recepción de un juego de datos, es necesario haber
reconocido la emisión de dicha solicitud dentro de un período determinado. Una vez
reconocida la solicitud, debe haberse enviado al controlador superior una respuesta dentro del
mismo período. De lo contrario, se produce en el I-device un error de timeout, a consecuencia
del cual el sistema operativo del I-device envía una respuesta negativa al controlador superior.
El valor de la duración se puede consultar en la descripción de PRVREC (Página 2524).
Cuando se produce un error, el parámetro de salida STATUS contiene la información de error.

Modos de operación
El modo de operación de la instrucción "RCVREC" se define mediante el parámetro de entrada
MODE. Esto se explica en la siguiente tabla:
MODE
0

Significado
Comprobar si existe una solicitud para la recepción de un juego de datos.
Si en el I-device existe un juego de datos procedente del controlador superior, la instrucción escribirá solo en los
parámetros de salida NEW, SLOT, SUBSLOT, INDEX y LEN. Si se llama la instrucción varias veces consecutivas
con MODE=0, los parámetros de salida se refieren siempre a la misma solicitud.

1

Recibir un juego de datos para cualquier subslot del I-device
Si en el I-device existe un juego de datos procedente del controlador superior para cualquier subslot del I-device,
la instrucción escribe solo en los parámetros de salida y transfiere el juego de datos al parámetro RECORD.

2

Recibir un juego de datos para un determinado subslot del I-device
Si en el I-device existe un juego de datos procedente del controlador superior para un determinado subslot del Idevice, la instrucción escribe solo en los parámetros de salida y transfiere el juego de datos al parámetro RE‐
CORD.

3

Enviar respuesta positiva al controlador superior
La instrucción comprueba la solicitud de recepción de juego de datos procedente del controlador superior, acepta
el juego de datos existente y envía una respuesta positiva al controlador superior.

4

Enviar respuesta negativa al controlador superior
La instrucción comprueba la solicitud de recepción del juego de datos procedente del controlador superior,
rechaza el juego de datos existente y envía una respuesta negativa al controlador superior. El motivo del rechazo
puede indicarse en los parámetros de entrada CODE1 y CODE2.

Programación del PLC
Manual de programación y manejo, 11/2019

2515

Instrucciones
4.1 Instrucciones

Nota
Una vez llegado el juego de datos (NEW=1), debe llamarse "RCVREC" dos veces más para
garantizar que se procese por completo. Al hacerlo debe mantenerse el siguiente orden:
● Primera llamada con MODE=1 o MODE=2 (debe haberse completado antes de que
transcurra un segundo después de aparecer la solicitud, o la instrucción del controlador IO
solicitante se confirmará negativamente, es decir, el parámetro STATUS (elemento de
campo STATUS[3] equivale a Error_code_1): C2 (Resource busy))
● Segunda llamada con MODE=3 o MODE=4 (debe haberse completado antes de 10 s
después de la primera llamada con MODE=1 o MODE=2 . Una vez transcurrido el tiempo
de espera el controlador IO superior recibe en el parámetro STATUS de su instrucción
solicitante (RDREC) el siguiente error: El parámetro STATUS (elemento de campo
STATUS[3] equivale a Error_code_1): A7 (Application busy))

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RCVREC":
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

MODE

Input

INT

I, Q, M, D, L o cons‐
tante

Modo de operación

F_ID

Input

HW_SUBMO‐
DULE

I, Q, M, D, L o cons‐
tante

Subslot en el área de trasferencia del I-device
para el juego de datos que se debe recibir (re‐
levante solo para MODE=2). El high word debe
ajustarse siempre a cero.

MLEN

Input

INT*

I, Q, M, D, L o cons‐
tante

Longitud máxima en bytes del juego de datos
que se debe transferir.

CODE1

Input

BYTE

I, Q, M, D, L o cons‐
tante

"0" (para MODE=3) o Error Code 1 (para MO‐
DE=4)

CODE2

Input

BYTE

I, Q, M, D, L o cons‐
tante

"0" (para MODE=3) o Error Code 2 (para MO‐
DE=4)

NEW

Output

BOOL

I, Q, M, D, L

● MODE=0: Se ha recibido un juego de datos
nuevo
● MODE=1 o 2: El juego de datos se ha
transferido en RECORD

STATUS

Output

DWORD

I, Q, M, D, L

Información de error

SLOT

Output

HW_SUBMO‐
DULE

I, Q, M, D, L

Idéntico a F_ID

SUBSLOT

Output

HW_SUBMO‐
DULE

I, Q, M, D, L

Idéntico a F_ID

INDEX

Output

UINT

I, Q, M, D, L

Número del juego de datos recibido

LEN

Output

UINT

I, Q, M, D, L

Longitud del juego de datos recibido

RECORD

InOut

VARIANT

I, Q, M, D, L

Área de destino para el juego de datos recibi‐
do.

* En el lenguaje de programación AWL utilice el tipo de datos UINT.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

2516

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro STATUS
Para la interpretación del parámetro STATUS, véase el capítulo: Parámetro STATUS
(Página 2447)

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa de RCVREC mediante iDevice
(Página 2517).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Ejemplo de programa de RCVREC mediante iDevice
En el ejemplo siguiente se escribe un juego de datos desde el controlador IO al área de
transferencia y se recibe el juego de datos en el I-device correspondiente.

Requisitos
● Dos CPU S7-1500 con una versión de firmware >=v1.8
● Una de las CPU está configurada como I-device. La otra CPU está definida como
controlador IO de nivel superior. (Consultar las propiedades de la CPU > Modo de
operación)
● Si todavía no existen: cree dos áreas de transferencia. La primera área de transferencia
sirve para datos de entrada y la otra para datos de salida. Cada área de transferencia debe
tener una longitud de 1024 bytes. (Consultar las propiedades de la CPU > Modo de
operación > Área de transferencia)

CPU 1 (controlador IO): Almacenamiento de datos
Para almacenar los datos deben crearse las variables siguientes en un bloque de datos global.

El juego de datos es el siguiente.

Programación del PLC
Manual de programación y manejo, 11/2019

2517

Instrucciones
4.1 Instrucciones

CPU 1 (controlador IO) / FB "SLI_FB_WRREC_iDevice": Interconectar parámetros
La instrucción "WRREC" se llama en un FB. En el FB se crean las siguientes variables locales:

Segmento 1: La instrucción "WRREC" se inicia del siguiente modo.

Segmento 2: La instrucción "WRREC" se interconecta del siguiente modo.

2518

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 3: La variable "start" se desactiva del siguiente modo.

CPU 2 (I-device): Almacenamiento de datos
Para almacenar los datos deben crearse las variables siguientes en un bloque de datos global.

Programación del PLC
Manual de programación y manejo, 11/2019

2519

Instrucciones
4.1 Instrucciones

CPU 2 (I-device) / FB "SLI_FB_setMode_RCVREC": Interconectar parámetros
Para conmutar el modo de la instrucción "RCVREC", se crea el FB
"SLI_FB_setMode_RCVREC".
En el FB se crean las siguientes variables locales:

Segmento 1: Para conmutar el modo se crean las interconexiones siguientes.
Parte 1:

Parte 2:

2520

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parte 3:

Parte 4:

Programación del PLC
Manual de programación y manejo, 11/2019

2521

Instrucciones
4.1 Instrucciones

CPU 2 (I-device) / FB "SLI_FB_RCVREC_iDevice": Interconectar parámetros
La instrucción "RCVREC" se llama en un FB. En el FB se crean las siguientes variables locales:

Segmento 1: El bloque "SLI_FB_setMode_RCVREC" se interconecta del siguiente modo.

Segmento 2: La instrucción "PRVREC" se interconecta del siguiente modo.

CPU 1 / FB "SLI_FB_WRREC_iDevice": Resultado del segmento 1
Si la instrucción "Consultar flanco de señal ascendente de un operando" ("start") devuelve el
estado lógico "TRUE", las variables "memErrStatus" y "checkedValid" se desactivan.

2522

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CPU 1 / FB "SLI_FB_WRREC_iDevice": Resultado del segmento 2
Si el contacto NA ("start") devuelve el estado lógico "TRUE", se inicia la instrucción "WRREC".
WRREC escribe el juego de datos almacenado en el parámetro RECORD ("recordComm") en
varios ciclos en el área de transferencia de la CPU (consulte la variable "id"). La longitud del
juego de datos que debe escribirse es ilimitada, de acuerdo con el valor "0" del parámetro de
entrada MLEN ("maxLength"). El éxito del procesamiento (VALID es TRUE) se guarda con la
variable "checkedValid".

El controlador IO transmite al I-device, en base al parámetro de entrada ID ("id") de la
instrucción "WRREC", que ha escrito un juego de datos nuevo en el área de transferencia de
los datos de salida. Seguidamente, el I-device recibe este juego de datos mediante la
instrucción "RCVREC".

CPU 1 / FB "SLI_FB_WRREC_iDevice": Resultado del segmento 3
Si WRREC ha terminado su procesamiento pero se sigue ejecutando, la variable "start" se
desactiva y WRREC finaliza.

CPU 2 / FB "SLI_FB_RCVREC_iDevice": Resultado del segmento 1
En base a la variable "newDataReceived", en el FB "SLI_FB_setMode_RCVREC" se
determina si el modo "0" es válido o si la instrucción "RCVREC" debe ejecutar otro modo.

CPU 2 / FB "SLI_FB_RCVREC_iDevice": Resultado del segmento 2
La instrucción "RCVREC" se procesa de acuerdo con el modo especificado en el parámetro
MODE ("mode"). Si, en el modo "0", el parámetro de salida NEW ("newDataReceived")
devuelve el estado lógico "TRUE", RCVREC se procesa a continuación en el modo "1" y
posteriormente en el modo "3".
RCVREC recibe un juego de datos a través del área de transferencia del I-device y lo guarda
mediante el parámetro RECORD ("recordComm").

Programación del PLC
Manual de programación y manejo, 11/2019

2523

Instrucciones
4.1 Instrucciones

La longitud de los datos leídos por RCVREC se emite en el parámetro de salida "LEN"
("#statRLength", "receivelength"). De acuerdo con el valor "0" del parámetro de entrada MLEN
("maxLength"), la longitud de los datos es ilimitada.
El número del juego de los datos recibidos, siempre que el I-device lo conozca, se emite en el
parámetro de salida "INDEX" ("dataRecNbr").

Código del programa
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

PRVREC: Proveer registro
Descripción
Un I-device puede recibir desde un controlador superior la solicitud de preparar un juego de
datos. La preparación se efectúa en el programa de usuario con la instrucción "PRVREC"
(provide record).
La instrucción tiene los siguientes modos de operación:
● Comprobar si el I-device ha recibido una solicitud para preparar un juego de datos.
● Transferencia del juego de datos solicitado al controlador superior.
● Enviar una respuesta al controlador superior.

2524

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para establecer cuál de estos modos de operación debe ejecutar la instrucción, se usa el
parámetro de entrada MODE (ver abajo).
La instrucción PRVREC solo puede ejecutarse en el I-device en los estados operativos RUN
o ARRANQUE.
Si el I-device se encuentra en estado operativo STOP, PRVREC no puede ejecutarse y el
controlador IO superior recibe en STATUS de su instrucción solicitante (RDREC) el siguiente
error:
Parámetro STATUS (elemento de campo STATUS[3] equivale a Error_code_1): B5 (State
conflict).
Si el I-device se encuentra en ARRANQUE o RUN, primero tiene 1s de tiempo para responder
con PRVREC(MODE=1, …) o PRVREC(MODE=2, …) tras recibir la solicitud de lectura. De lo
contrario se transmite al controlador IO superior el error C2 (Resource busy).
Tras la llamada de PRVREC (modo=1/2) el I-device tiene 10 s de tiempo para completar la
instrucción con PRVREC (MODE=3) o PRVREC (MODE=4). De lo contrario se transmite al
controlador IO superior el error A7 (Application busy).
Con LEN se indica el máximo de bytes que debe tener el juego de datos que se desea enviar.
Seleccione un área de destino RECORD con una longitud de por lo menos LEN bytes.
Cuando existe una solicitud de preparación de un juego de datos (MODE=0), el parámetro de
salida NEW se ajusta a TRUE.
Si se acepta la solicitud de preparación de juego de datos, para la respuesta positiva al
controlador superior debe escribirse en RECORD el juego de datos solicitado, así como ajustar
CODE1 y CODE2 a cero. Si se desea rechazar una solicitud de preparar un juego de datos,
debe enviarse con CODE1 el Error Code 1 y con CODE2 el Error Code 2 de la respuesta
negativa al controlador superior.
Cuando se produce un error, el parámetro de salida STATUS contiene la información de error.

Modos de operación
El modo de operación de la instrucción "PRVREC" se define mediante el parámetro de entrada
MODE. Esto se explica en la siguiente tabla:
MODE

Significado

0

Comprobar si existe una solicitud de preparar un juego de datos.
Si en el I-device existe una solicitud de preparar un juego de datos procedente del controlador superior, la
instrucción escribirá solo en los parámetros de salida NEW, SLOT, SUBSLOT, INDEX y RLEN. Si se llama la
instrucción varias veces consecutivas con MODE=0, los parámetros de salida se refieren siempre a la misma
solicitud.

1

Recibir una solicitud de preparar un juego de datos para cualquier subslot del I-device
Si en el I-device existe una solicitud de ese tipo procedente del controlador superior para cualquier subslot del Idevice, la instrucción escribe solo en los parámetros de salida.

2

Recibir una solicitud de preparar un juego de datos para un determinado subslot del I-device
Si en el I-device existe una solicitud de ese tipo procedente del controlador superior para un determinado subslot
del I-device, la instrucción escribe solo en los parámetros de salida.

Programación del PLC
Manual de programación y manejo, 11/2019

2525

Instrucciones
4.1 Instrucciones
MODE

Significado

3

Preparar juego de datos y enviar respuesta positiva al controlador superior
La instrucción comprueba la solicitud de preparar un juego de datos procedente del controlador superior, pone
a disposición el juego de datos solicitado en RECORD y envía una respuesta positiva al controlador superior.

4

Enviar respuesta negativa al controlador superior
La instrucción comprueba la solicitud de preparar un juego de datos procedente del controlador superior, la
rechaza y envía una respuesta negativa al controlador superior. El motivo del rechazo puede indicarse en los
parámetros de entrada CODE1 y CODE2.

Nota
Una vez llegada la solicitud (NEW=1), debe llamarse la instrucción dos veces más para
garantizar que se procese por completo. Al hacerlo debe mantenerse el siguiente orden:
● Primera llamada con MODE=1 o MODE=2 (debe haberse completado antes de que
transcurra un segundo después de aparecer la solicitud, o la instrucción del controlador IO
solicitante se confirmará negativamente, es decir, el parámetro STATUS (elemento de
campo STATUS[3] equivale a Error_code_1): C2 (Resource busy))
● Segunda llamada con MODE=3 o MODE=4 (debe haberse completado antes de 10 s
después de la primera llamada con MODE=1 o MODE=2 . Una vez transcurrido el tiempo
de espera el controlador IO superior recibe en el parámetro STATUS de su instrucción
solicitante (RDREC) el siguiente error: El parámetro STATUS (elemento de campo
STATUS[3] equivale a Error_code_1): A7 (Application busy))

Sugerencia
Programe la segunda llamada justo a continuación de la primera.
Explicación: tras la primera llamada de la instrucción con modo 1 o modo 2, la CPU ya no
puede procesar ninguna otra instancia de la instrucción, es decir, ninguna otra petición de
juegos de datos. La CPU solamente puede procesar otra petición de juegos de datos una vez
procesada la segunda llamada con modo 3 o modo 4. Si, tras la primera llamada de la
instrucción con modo 1 o modo 2, se llama otra instancia de la instrucción, el estado devuelve
el valor 0xC080C300 (= Error, recurso no disponible).
Ejemplo: en el programa de usuario del I-Device se utilizan las funciones de juego de datos
Asset Management y la función PROFIenergy. Asset Management utiliza la instrucción
PRVREC, y PROFIenergy, la instrucción PE_I_DEV. PE_I_DEV también emplea internamente
las instrucciones PRVREC y RCVREC.

2526

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "PRVREC":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MODE

Input

INT

I, Q, M, D, L o cons‐
tante

Modo de operación

F_ID

Input

HW_SUBMO‐
DULE

I, Q, M, D, L o cons‐
tante

Subslot en el área de trasferencia del I-device
para el juego de datos que se debe enviar (rele‐
vante solo para MODE=2). El high word debe
ajustarse siempre a cero.
Si se llama a PRVREC para entregar un juego de
datos de Asset-Management al controlador IO
(n.º de juego de datos 0xF880), tiene que activar
F_ID = 0. Con F_ID = 0 se direcciona el disposi‐
tivo. (Solo relevante para MODE=2. Atención: En
caso de llamada con MODE=0 para IN‐
DEX=0xF880 de PRVREC para SLOT y SUBS‐
LOT se devuelve el valor 0.)

CODE1

Input

BYTE

I, Q, M, D, L o cons‐
tante

"0" (para MODE=3) o Error Code 1 (para MO‐
DE=4)

CODE2

Input

BYTE

I, Q, M, D, L o cons‐
tante

"0" (para MODE=3) o Error Code 2 (para MO‐
DE=4)

LEN

Input

UINT

I, Q, M, D, L o cons‐
tante

Longitud máxima en bytes del juego de datos
que se debe enviar.

NEW

Output

BOOL

I, Q, M, D, L

El controlador superior ha solicitado un nuevo
juego de datos.

STATUS

Output

DWORD

I, Q, M, D, L

Información de error

SLOT

Output

HW_SUBMO‐
DULE

I, Q, M, D, L

Idéntico a F_ID

SUBSLOT

Output

HW_SUBMO‐
DULE

I, Q, M, D, L

Idéntico a F_ID

INDEX

Output

UINT

I, Q, M, D, L

Número del juego de datos que se debe enviar

RLEN

Output

UINT

I, Q, M, D, L

Longitud del juego de datos que se debe enviar

RECORD

InOut

VARIANT

I, Q, M, D, L

Juego de datos preparado

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Para la interpretación del parámetro STATUS, véase el capítulo: Parámetro STATUS
(Página 2447)

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa de PRVREC mediante iDevice
(Página 2528).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Programación del PLC
Manual de programación y manejo, 11/2019

2527

Instrucciones
4.1 Instrucciones

Ejemplo de programa de PRVREC mediante iDevice
En el ejemplo siguiente se prepara un juego de datos en un I-device y se lee el juego de datos
en el controlador de nivel superior.

Requisitos
● Dos CPU S7-1500 con una versión de firmware >=v1.8
● Una de las CPU está configurada como I-device. La otra CPU está definida como
controlador IO de nivel superior. (Consultar las propiedades de la CPU > Modo de
operación)
● Si todavía no existen: cree dos áreas de transferencia. La primera área de transferencia
sirve para datos de entrada y la otra para datos de salida. Cada área de transferencia debe
tener una longitud de 1024 bytes. (Consultar las propiedades de la CPU > Modo de
operación > Área de transferencia)

CPU 1 (controlador IO): Almacenamiento de datos
Para almacenar los datos deben crearse las variables siguientes en un bloque de datos global.

CPU 1 (controlador IO) / FB "SLI_FB_RDREC_iDevice": Interconectar parámetros
La instrucción "RDREC" se llama en un FB. En el FB se crean las siguientes variables locales:

Segmento 1: La instrucción "RDREC" se inicia del siguiente modo.

2528

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 2: La instrucción "RDREC" se interconecta del siguiente modo.

Segmento 3: La variable "start" se desactiva del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2529

Instrucciones
4.1 Instrucciones

CPU 2 (I-device): Almacenamiento de datos
Para almacenar los datos deben crearse las variables siguientes en un bloque de datos global.

CPU 2 (I-device) / FB "SLI_FB_setMode_PRVREC": Interconectar parámetros
Para conmutar el modo de la instrucción "PRVREC", se crea el FB
"SLI_FB_setMode_PRVREC". En el FB se crean las siguientes variables locales:

Segmento 1: Para conmutar el modo se crean las interconexiones siguientes.
Parte 1:

2530

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parte 2:

Parte 3:

Programación del PLC
Manual de programación y manejo, 11/2019

2531

Instrucciones
4.1 Instrucciones

Parte 4:

CPU 2 (I-device) / FB "SLI_FB_PRVREC_iDevice": Interconectar parámetros
La instrucción "PRVREC" se llama en un FB "SLI_FB_PRVREC_iDevice". En el FB se crean
las siguientes variables locales:

Segmento 1: El bloque "SLI_FB_setMode_PRVREC" se interconecta del siguiente modo.

Segmento 2: La instrucción "PRVREC" se interconecta del siguiente modo.

2532

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CPU 1 / FB "SLI_FB_RDREC_iDevice": Resultado del segmento 1
Si la instrucción "Consultar flanco de señal ascendente de un operando" ("start") devuelve el
estado lógico "TRUE", las variables "length", "memErrStatus" y "checkedValid" se desactivan.

CPU 1 / FB "SLI_FB_RDREC_iDevice": Resultado del segmento 2
Si el contacto NA ("start") devuelve el estado lógico "TRUE", se inicia la instrucción "RDREC".
El controlador IO transmite al I-device, en base al parámetro de entrada ID ("id") de la
instrucción "RDREC", que desea leer un juego de datos. Seguidamente, el I-device
proporciona este juego de datos con la instrucción "PRVREC" a través del área de
transferencia de los datos de entrada.
RDREC lee el juego de datos en varios ciclos y guarda los valores mediante el parámetro
RECORD ("recordComm").

Programación del PLC
Manual de programación y manejo, 11/2019

2533

Instrucciones
4.1 Instrucciones
El éxito del procesamiento de la instrucción "RDREC" (el parámetro VALID tiene el valor
"TRUE") se guarda con la variable "checkedValid". Además, la longitud de los datos leídos se
guarda en la variable "length".

CPU 1 / FB "SLI_FB_RDREC_iDevice": Resultado del segmento 3
Si RDREC ha terminado su procesamiento pero se sigue ejecutando, la variable "start" se
desactiva y RDREC finaliza.

CPU 2 / FB "SLI_FB_PRVREC_iDevice": Resultado del segmento 1
En base a la variable "newDataCalled", en el FB "SLI_FB_setMode_PRVREC" se determina si
el modo "0" es válido o si la instrucción "PRVREC" debe ejecutar otro modo.

CPU 2 / FB "SLI_FB_PRVREC_iDevice": Resultado del segmento 2
La instrucción "PRVREC" se procesa de acuerdo con el modo especificado en el parámetro
MODE ("mode"). Si, en el modo "0", el parámetro de salida NEW ("newDataCalled") devuelve
el estado lógico "TRUE", PRVREC se procesa a continuación en el modo "1" y posteriormente
en el modo "3".
PRVREC transfiere el juego de datos almacenado en el parámetro RECORD ("recordComm")
al área de transferencia del I-device. La longitud de los datos que debe enviar el I-device se
emite en el parámetro de salida "RLEN" ("#statRLength", "length"). De acuerdo con el valor "0"
del parámetro de entrada MLEN ("maxLength"), la longitud de los datos es ilimitada.
El número del juego de los datos que deben enviarse, siempre que el I-device lo conozca, se
emite en el parámetro de salida INDEX ("dataRecNbr").

2534

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Código del programa
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

PROFIBUS
DPSYC_FR: Sincronizar esclavos DP / Congelar entradas
Descripción
Esta instrucción permite sincronizar uno o varios grupos de esclavos DP.
Para ello debe enviarse a los grupos en cuestión uno de los siguientes comandos de control
o una combinación de ellos:
● SYNC (emisión y congelación simultáneas de estados de salida en los esclavos DP)
● UNSYNC (anula el comando de control SYNC)
● FREEZE (congelación de estados de entrada en los esclavos DP y lectura de las entradas
congeladas)
● UNFREEZE (anula el comando de control FREEZE)
Antes de enviar los comandos de control mencionados, deben haberse dividido en grupos,
mediante configuración, los esclavos DP. Es necesario saber qué esclavo DP está asignado
a cada grupo y con qué número, así como las características de cada uno de los grupos en lo
que respecta al comportamiento de SYNC/FREEZE.
Nota
Debe tenerse en cuenta que los comandos de control SYNC y FREEZE mantienen su validez
incluso en caso de rearranque completo o arranque en frío.
También debe tenerse en cuenta que en cada momento solo puede estar lanzada una petición
SYNC/UNSYNC y solo una petición FREEZE/UNFREEZE.

Programación del PLC
Manual de programación y manejo, 11/2019

2535

Instrucciones
4.1 Instrucciones

Funcionamiento
"DPSYC_FR" es una instrucción que funciona de forma asíncrona. Su ejecución se prolonga
a lo largo de varias llamadas. Para iniciar la petición, debe llamarse "DPSYC_FR" con REQ=1.
El estado de la petición se indica a través de los parámetros de salida RET_VAL y BUSY.
Consulte también: Diferencia entre las instrucciones que funcionan síncronamente y las que
funcionan asíncronamente (Página 618).

Identificación de una petición
Si se ha lanzado una petición SYNC/FREEZE y se ha vuelto a llamar "DPSYC_FR" antes de
que finalice, el comportamiento posterior de la instrucción depende esencialmente de si la
nueva llamada corresponde a la misma petición. Si los parámetros de entrada LADDR,
GROUP y MODE coinciden entre sí, la llamada se considera una llamada consecutiva.

Escribir en salidas de módulos DP
La escritura en las salidas de los módulos DP se lanza mediante
● Comandos de transferencia a la periferia DP,
● La escritura de la memoria imagen de proceso de las salidas en los módulos (mediante el
sistema operativo al final del OB 1 o mediante llamada de la instrucción "UPDAT_PO
(Página 2368)"),
● La llamada de la instrucción "DPWR_DAT (Página 2512)".
En el caso normal, el maestro DP transfiere los datos de salida cíclicamente (en el ciclo del bus
PROFIBUS DP) a las salidas de los esclavos DP.
Si se desea transferir determinados datos de salida que pueden estar repartidos entre varios
esclavos a las salidas hacia el proceso de manera exactamente simultánea, debe enviarse el
comando de control SYNC al maestro DP correspondiente con la instrucción "DPSYC_FR".

¿Qué efecto produce SYNC?
Con el comando de control SYNC se ponen en modo de sincronización los esclavos DP de los
grupos especificados. El maestro DP transfiere los datos de salida actuales y ordena a los
esclavos DP implicados que congelen las salidas. En los siguientes telegramas de salida, los
esclavos DP guardan los datos de salida en un búfer interno; el estado de las salidas
permanece invariable.
Después de cada comando de control SYNC, los esclavos DP de los grupos seleccionados
depositan los datos de salida de su búfer interno en las salidas al proceso.

2536

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si el usuario envía el comando de control UNSYNC con la instrucción "DPSYC_FR", las
salidas se vuelven a actualizar cíclicamente.
Nota
Si, en el momento en que se envía el comando de control, algún esclavo DP del grupo o grupos
seleccionados no se encuentra conectado a la red o presenta un fallo, dichos esclavos
tampoco pasan al modo SYNC. Este hecho no se notifica mediante el valor de retorno de la
instrucción.

Leer entradas de módulos DP
Se leen los datos de entrada de los módulos DP
● Con comandos de carga a la periferia DP,
● Al actualizar la memoria imagen de proceso de las entradas (mediante el sistema operativo
al final del OB 1 o mediante llamada de la instrucción "UPDAT_PI (Página 2365)"),
● Llamando la instrucción "DPRD_DAT (Página 2510)".
En el caso normal, el maestro DP recibe estos datos de entrada cíclicamente (en el ciclo del
bus PROFIBUS DP) desde sus esclavos DP y los pone a disposición de la CPU.
Si se desea leer determinados datos de entrada que pueden estar repartidos entre varios
esclavos desde el proceso de manera exactamente simultánea, debe enviarse el comando de
control FREEZE al maestro DP correspondiente con la instrucción "DPSYC_FR".

¿Qué efecto produce FREEZE?
Con el comando de control FREEZE se ponen en modo de congelación los esclavos DP
afectados. El maestro DP ordena a los esclavos DP afectados que congelen el estado actual
de las entradas. A continuación transfiere los datos congelados al área de entrada de la CPU.
Después de cada comando de control FREEZE, los esclavos DP vuelven a congelar el estado
de las entradas.
Si el usuario envía el comando de control UNFREEZE con la instrucción "DPSYC_FR", el
maestro DP vuelve a recibir cíclicamente el estado actual de las entradas.
Nota
Si, en el momento en que se envía el comando de control, algún esclavo DP del grupo o grupos
seleccionados no se encuentra conectado a la red o presenta un fallo, dichos esclavos
tampoco pasan al modo Freeze. Este hecho no se notifica mediante el valor de retorno de la
instrucción.

Coherencia de datos
Debido al funcionamiento asíncrono y a la posibilidad de interrupción por clases de prioridad
superiores, al utilizar la instrucción "DPSYC_FR" debe asegurarse que las memorias imagen
de proceso sean coherentes con las entradas y salidas reales de la periferia.

Programación del PLC
Manual de programación y manejo, 11/2019

2537

Instrucciones
4.1 Instrucciones
Para garantizarlo, debe aplicarse una de las reglas de coherencia que se mencionan a
continuación:
● Defina memorias imagen parcial de proceso adecuadas (solo posible con S7-400) para las
salidas "SYNC" y las entradas "FREEZE". Llame la instrucción "UPDAT_PO (Página 2368)"
inmediatamente antes de cada primera llamada de una petición SYNC. Llame la instrucción
"UPDAT_PI (Página 2365)" inmediatamente después de cada última llamada de una
petición FREEZE.
● Alternativamente: Para las salidas afectadas por una petición SYNC, y para las entradas
afectadas por una petición FREEZE, utilice solo accesos directos a la periferia. Mientras
haya una petición SYNC en curso, no es posible escribir en las salidas afectadas, ni
tampoco leer las entradas afectadas mientras está en curso una petición FREEZE.

Uso de DPWR_DAT y DPRD_DAT
Si se utiliza la instrucción "DPWR_DAT (Página 2512)", esta debe estar finalizada antes de que
se envíe una petición SYNC para las salidas en cuestión.
Si se utiliza la instrucción "DPRD_DAT (Página 2510)", esta debe estar finalizada antes de que
se envíe una petición FREEZE para las entradas en cuestión.

Arranque y "DPSYC_FR"
El envío de los comandos de control SYNC y FREEZE en los OB de arranque es
responsabilidad exclusiva del usuario.
Si se desea que las salidas de uno o varios grupos empiecen a funcionar en el modo SYNC ya
desde el inicio del programa de usuario, deben inicializarse esas salidas en el arranque y
ejecutarse por completo la instrucción "DPSYC_FR" con el comando de control SYNC.
Si se desea que las entradas de uno o varios grupos empiecen a funcionar en el modo
FREEZE ya desde el inicio del programa de usuario, debe ejecutarse por completo para esas
entradas la instrucción "DPSYC_FR" con el comando de control FREEZE.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DPSYC_FR":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Parámetro de control disparado por nivel REQ=1:
Lanzar la petición SYNC/FREEZE

LADDR

Input

HW_INTER‐
FACE

I, Q, M, D, L o cons‐
tante

Identificador de hardware de la interfaz del maestro
DP
El número puede adoptarse de la ficha "Constantes
de sistema" de la tabla de variables estándar.

2538

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

GROUP

Input

BYTE

I, Q, M, D, L o cons‐
tante

Selección de grupo
Bit 0 = 1: Grupo 1 seleccionado
Bit 1 = 1: Grupo 2 seleccionado
:
Bit 7 = 1: Grupo 8 seleccionado
Pueden seleccionarse varios grupos por petición.
El valor B#16#0 no está permitido.

MODE

Input

BYTE

I, Q, M, D, L o cons‐
tante

ID de la petición (codificación según EN 50 170 Vo‐
lume 2, PROFIBUS)
Bit 0: Reservado (valor 0)
Bit 1: Reservado (valor 0)
Bit 2:
● = 1: UNFREEZE se ejecuta
●

= 0: Sin significado

Bit 3:
● = 1: FREEZE se ejecuta
●

= 0: Sin significado

Bit 4:
● = 1: UNSYNC se ejecuta
●

= 0: Sin significado

Bit 5:
● = 1: SYNC se ejecuta
●

= 0: Sin significado

Bit 6: Reservado (valor 0)
Bit 7: Reservado (valor 0)
Valores posibles:
● Con una y solo una ID por petición:
–

B#16#04 (UNFREEZE)

–

B#16#08 (FREEZE)

–

B#16#10 (UNSYNC)

–

B#16#20 (SYNC)

● Con varias ID por petición:

Programación del PLC
Manual de programación y manejo, 11/2019

–

B#16#14 (UNSYNC, UNFREEZE)

–

B#16#18 (UNSYNC, FREEZE)

–

B#16#24 (SYNC, UNFREEZE)

–

B#16#28 (SYNC, FREEZE)

2539

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución de la
instrucción, el valor de respuesta contendrá un có‐
digo de error.
Después de cada pasada del bloque debe evaluar‐
se RET_VAL .

BUSY

Output

BOOL

I, Q, M, D, L

BUSY=1:
La petición de SYNC/FREEZE todavía no ha finali‐
zado.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Nota
Si accede a esclavos DPV1, el maestro DP puede transferir la información de error de dichos
esclavos a la instrucción. Encontrará una descripción de esta información de error en
STATUS[3], parámetro STATUS (Página 2447).

Código de
error*
(W#16#...)

Explicación

0000

La petición se ha ejecutado sin errores.

7000

Primera llamada con REQ= 0. La petición definida mediante LADDR, GROUP y MODE no está activa; BUSY
tiene el valor 0.

7001

Primera llamada con REQ= 1. Se ha lanzado la petición definida mediante LADDR, GROUP y MODE ; BUSY
tiene el valor 1.

7002

Llamada intermedia (REQ irrelevante). La petición SYNC/FREEZE activada todavía está en curso; BUSY
tiene el valor 1.

8090

El módulo seleccionado mediante LADDR no es un maestro DP.

8093

Esta instrucción no es válida para el módulo seleccionado con LADDR (configuración o versión del maestro
DP).

8094

Parámetros GROUP erróneos

8095

Parámetros MODE erróneos

80A4

Fallo de comunicación en PROFIBUS.

80B0

El grupo seleccionado mediante GROUP no está configurado.

80B1

El grupo seleccionado mediante GROUP no está asignado a esta CPU.

80B2

La petición SYNC especificada mediante MODE no está permitida en el grupo seleccionado mediante
GROUP.

80B3

La petición FREEZEespecificada mediante MODE no está autorizada en el grupo seleccionado mediante
GROUP .

80C2

Falta de recursos temporal del maestro DP: En este momento el maestro DP está procesando el máximo
posible de peticiones para una CPU.

80C3

Esta petición SYNC/UNSYNCno se puede activar en este momento, ya que en cada momento determinado
solo puede estar lanzada una petición SYNC/UNSYNC. Compruebe el programa de usuario.

2540

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*
(W#16#...)

Explicación

80C4

Esta petición FREEZE/UNFREEZEno se puede activar en este momento, ya que en cada momento deter‐
minado solo puede estar lanzada una petición FREEZE/UNFREEZE. Compruebe el programa de usuario.

80C5

Cortocircuito en la proximidad inmediata de la interfaz DP

80C6

Interrupción de la petición debido a expulsión de la periferia por la CPU

80C7

Interrupción de la petición debido a rearranque completo (en caliente) o arranque en frío del maestro DP

Información
Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)
de error gene‐
ral
* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

DPNRM_DG: Leer datos de diagnóstico de un esclavo DP
Descripción
La instrucción "DPNRM_DG" lee los datos de diagnóstico actuales de un esclavo DP de la
forma establecida por EN 50 170 Volume 2, PROFIBUS.
La estructura fundamental del diagnóstico de esclavo se recoge en la siguiente tabla, y la
información más detallada, en los manuales de los esclavos DP.
Byte

Significado

0

Estado de estación 1

1

Estado de estación 2

2

Estado de estación 3

3

Número de estación maestra

4

Identificación de fabricante (high byte)

5

Identificación de fabricante (low byte)

6 ...

Otros diagnósticos específicos de esclavo

Los datos leídos se introducen en el área de destino determinada por RECORD tras la correcta
transferencia de los datos. El proceso de lectura se inicia ocupando el parámetro de entrada
REQ con "1" durante la llamada de la instrucción "DPNRM_DG".

Funcionamiento
La lectura se realiza de forma asíncrona, es decir, se puede prolongar a lo largo de varias
llamadas. El estado de la petición se indica a través de los parámetros de salida RET_VAL y
BUSY.
Consulte también: Diferencia entre las instrucciones que funcionan síncronamente y las que
funcionan asíncronamente (Página 618).

Programación del PLC
Manual de programación y manejo, 11/2019

2541

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DPNRM_DG":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐ REQ = 1: solicitud de lectura
tante

LADDR

Input

HW_DPSLAVE I, Q, M, D, L o cons‐ Identificador de hardware del esclavo DP
tante
Nota: El identificador se debe indicar en formato
hexadecimal. P. ej. el identificador de hardware
1022 significa: LADDR:=W#16#3FE.

RET_VAL

Return

DINT, INT,
LREAL, REAL

I, Q, M, D, L

Si se produce un error durante la ejecución de la
instrucción, el valor de respuesta contendrá un có‐
digo de error. Si no aparece ningún error, en
RET_VAL se especifica la longitud de los datos
realmente transferidos.

RECORD

Output

VARIANT

I, Q, M, D, L

Área de destino para los datos de diagnóstico leí‐
dos. Solo se admite el tipo de datos BYTE. La lon‐
gitud mínima del registro que se debe leer o del
área de destino es de 6. La longitud máxima del
registro que se debe leer es de 240. En los esclavos
normalizados en los que el número de datos de
diagnóstico normalizados es superior a 240 bytes y
tenga un máximo de 244 bytes, los primeros 240
bytes se transfieren al área de destino. A continua‐
ción, el correspondiente bit de desbordamiento se
activa en los datos.

BUSY

Output

BOOL

I, Q, M, D, L

BUSY = 1:
La lectura todavía no ha finalizado.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".
Encontrará información sobre la conversión de tipos de datos en los distintos lenguajes de
programación en "Sinopsis de las conversiones de tipos de datos (Página 576)".

Parámetro RECORD
La CPU valora la longitud real de los datos de diagnóstico leídos:
Si la indicación de longitud de RECORD
● es inferior al número de datos proporcionados, los datos se rechazan. En RET_VAL se
deposita la correspondiente información de error.
● es superior o igual al número de datos proporcionados, los datos se aceptan en el área de
destino y en RET_VAL se registra la longitud real como valor positivo.
Nota
Hay que asegurarse de que los parámetros actuales de RECORD coincidan en todas las
llamadas pertenecientes a una petición.
Una petición está claramente establecida por el parámetro de entrada LADDR.

2542

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Esclavos normalizados con datos de diagnóstico de más de 240 bytes
En esclavos normalizados con un número de datos de diagnóstico normalizados entre 241 y
244 bytes, debe tenerse en cuenta los siguiente:
Si la indicación de longitud de RECORD
● es inferior a 240 bytes, los datos se rechazan y en RET_VAL se deposita la correspondiente
información de error.
● es superior o igual a 240 bytes, los primeros 240 bytes de los datos de diagnóstico
normalizados se transfieren al área de destino y en los datos se activa el correspondiente
bit de desbordamiento.

Parámetro RET_VAL
● Si se ha producido un error durante la ejecución de la función, el valor de respuesta
contendrá un código de error.
● Si durante la transferencia no se ha producido ningún error, RET_VAL contiene la longitud
de los datos leídos en bytes como número positivo.
Nota
En un esclavo DP, el número de datos leídos depende de su estado de diagnóstico.
Para evaluar la información de error del parámetro RET_VAL, véase la tabla siguiente.
Código de error
(W#16#....)

Explicación

Restricción

7000

Primera llamada con REQ = 0: Ninguna transmisión de datos activa;
BUSY tiene el valor "0".

-

7001

Primera llamada con REQ = 1: Transmisión de datos iniciada; BUSY
tiene el valor "1".

Periferia descentralizada

7002

Llamada intermedia (REQ irrelevante): Transmisión de datos activa;
BUSY tiene el valor "1".

Periferia descentralizada

8090

Dirección indicada no válida en el parámetro LADDR.

-

8093

Esta instrucción no es válida para el módulo seleccionado con LADDR e
IOID.

-

80A2

● Error de protocolo DP con Layer 2 (p. ej. fallo de esclavo o fallos de
bus)

Periferia descentralizada

80A3

Error de protocolo de DP con User-Interface/User

Periferia descentralizada

80A4

Fallo de comunicación en PROFIBUS.

Periferia descentralizada

80B0

● La instrucción no es posible para el tipo de módulo

-

● Con ET200S no es posible leer registros en el modo DPV0.

● El módulo no conoce este registro.
● El número de registro 241 no es admisible.
● Con "WR_REC (Página 2401)" no se permiten los registros 0 ni 1.
80B1

La indicación de longitud en el parámetro RECORD es errónea.

Indicación < longitud de regis‐
tro

80B2

El slot configurado no está ocupado.

-

80B3

El tipo de módulo real no coincide con el tipo de módulo configurado

-

Programación del PLC
Manual de programación y manejo, 11/2019

2543

Instrucciones
4.1 Instrucciones
Código de error
(W#16#....)

Explicación

Restricción

80C0

No hay datos de diagnóstico.

-

80C1

Los datos de la petición de escritura efectuada anteriormente en el mó‐ dulo para el mismo juego de datos no han sido procesados todavía por
el módulo.

80C2

En este momento el módulo está procesando el máximo posible de pe‐ ticiones para una CPU.

80C3

En este momento los recursos necesarios (memoria, etc.) están ocupa‐ dos.

80C4

Error temporal interno. No se ha podido ejecutar la petición.

-

Repita la petición. Si este error se produce a menudo, compruebe si hay
fuentes de perturbación en la instalación.
80C5

La periferia descentralizada no está disponible.

Periferia descentralizada

80C6

La transferencia de juegos de datos se ha cancelado por una interrup‐
ción de la clase de prioridad (rearranque o segundo plano)

Periferia descentralizada

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Pá‐ gina 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Sinopsis de las conversiones de tipos de datos (Página 576)

DP_TOPOL: Determinar topología para sistema maestro DP
Descripción
Esta instrucción permite lanzar la determinación de topología para un sistema maestro
seleccionado. Al llamar esta instrucción, se accede a todos los repetidores de diagnóstico
conectados a un sistema maestro DP.
Nota
La determinación de topología puede efectuarse en cada momento concreto solo para un
sistema maestro DP.
La determinación de topología es imprescindible para poder visualizar con detalle la ubicación
de los eventuales errores de cable. Después del montaje del sistema maestro DP y de cada
modificación de su estructura física, debe efectuarse de nuevo la determinación de topología
con la instrucción "DP_TOPOL".

2544

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Se considera que se ha modificado la estructura física cuando:
● Se modifican longitudes de cables
● Se añaden o eliminan estaciones o componentes con función de repetidor
● Se modifican direcciones de estaciones
Si un repetidor de diagnóstico notifica un error, "DP_TOPOL" escribe en las salidas DPR y
DPRI a lo largo de la duración de un paso de "DP_TOPOL". Si varios repetidores de
diagnóstico del sistema maestro DP seleccionado notifican errores, "DP_TOPOL" envía a DPR
y DPRI información acerca del primer repetidor de diagnóstico que ha notificado errores. La
información de diagnóstico completa se puede leer con la instrucción "DPNRM_DG
(Página 2541)" o en la PG. Si ningún repetidor de diagnóstico notifica errores, las salidas DPR
y DPRI adquieren el valor "0".
Si, después de producirse un error, se desea volver a lanzar una determinación de topología,
en primer lugar debe restablecerse "DP_TOPOL". Para hacerlo, debe llamarse "DP_TOPOL"
con REQ=0 y R=1.

Funcionamiento
"DP_TOPOL" es una instrucción que funciona de forma asíncrona. Su ejecución se prolonga
a lo largo de varias llamadas. Para iniciar la determinación de topología de bus, debe llamarse
"DP_TOPOL" con REQ=1 . Para interrumpir la operación, debe llamarse "DP_TOPOL" con
R=1 .
El estado de la petición se indica a través de los parámetros de salida RET_VAL y BUSY .
Consulte también: Diferencia entre las instrucciones que funcionan síncronamente y las que
funcionan asíncronamente (Página 618).
Nota
La determinación de topología puede durar varios minutos.

Identificación de una petición
El parámetro de entrada DP_ID define una petición de manera unívoca.
Si se vuelve a llamar "DP_TOPOL" antes de que finalice la determinación de topología, el
comportamiento posterior de la instrucción depende de si la nueva llamada corresponde a la
misma petición. Si el parámetro DP_ID coincide con una petición todavía no finalizada, la
llamada se interpreta como llamada consecutiva, y en RET_VAL se registra el valor
W#16#7002. En cambio, si se trata de una petición diferente, la CPU la rechaza.

Programación del PLC
Manual de programación y manejo, 11/2019

2545

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DP_TOPOL":
Parámetro

Declaración

Tipo de datos Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

REQ=1: Lanzar determinación de topología

R

Input

BOOL

I, Q, M, D, L o cons‐
tante

R=1: Interrumpir la determinación de topología

DP_ID

Input

HW_IOSYS‐
TEM

I, Q, M, D, L o cons‐
tante

ID del sistema maestro DP cuya topología se
debe determinar

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución de la
instrucción, el valor de respuesta contendrá un
código de error.

BUSY

Output

BOOL

I, Q, M, D, L

BUSY=1: La determinación de topología todavía
no ha finalizado.

DPR

Output

BYTE

I, Q, M, D, L

Dirección PROFIBUS del repetidor de diagnós‐
tico que notifica errores

DPRI

Output

BYTE

I, Q, M, D, L

Segmento de medición del repetidor de diagnós‐
tico que notifica errores:
● Bit 0 = 1: Fallos temporales en el segmento
DP2
● Bit 1 = 1: Fallos permanentes en el segmento
DP2
● Bit 4 = 1: Fallos temporales en el segmento
DP3
● Bit 5 = 1: Fallos permanentes en el segmento
DP3

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Dentro de la información de error "verdadera" (códigos de error W#16#8xyz), debe distinguirse
entre dos casos:
● Errores temporales (códigos de error de W#16#80A2 a 80A4, 80C3, 80C5):
En este tipo de errores es posible que el error se elimine sin intervención del usuario. Puede
bastar con llamar de nuevo "DP_TOPOL" (varias veces si es necesario).
Ejemplo de error temporal: En este momento los recursos necesarios están ocupados
(W#16#80C3).
● Errores permanentes (códigos de error de W#16#8082, 80B0, 80B2):
Los errores de este tipo los debe eliminar el usuario. Una vez que se haya eliminado el error
es necesario volver a llamar "DP_TOPOL". Ejemplo de error permanente: El maestro DP o
la CPU no soportan este servicio (W#16#80B0).

2546

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Código de error* Explicación
(W#16#...)
0000

La petición se ha ejecutado sin errores.

7000

Primera llamada con REQ=0. No se ha lanzado ninguna determinación de topología. BUSY tiene el valor
"0".

7001

Primera llamada con REQ=1. Se ha lanzado la petición de determinación de topología. BUSY tiene el valor
"1".

7002

Llamada intermedia (REQ irrelevante): La determinación de topología todavía está procesándose. BUSY
tiene el valor "1".

7010

Se ha intentado interrumpir la determinación de topología. Sin embargo, no hay ninguna petición en curso
con la DP_IDindicada. BUSY tiene el valor "0".

7011

Primera llamada con R=1. Se ha lanzado la interrupción de la determinación de topología; BUSY tiene el
valor "1".

7012

Llamada intermedia: La interrupción de la determinación de topología todavía está procesándose. BUSY
tiene el valor "1".

7013

Última llamada: Se ha interrumpido la determinación de topología. BUSY tiene el valor "0".

8082

No está configurado ningún maestro DP con la DP_ID indicada.

80A2

Error en determinación de topología; encontrará información más detallada en los parámetros de salida
DPR y DPRI.

80A3

Error en determinación de topología: El tiempo de vigilancia ha finalizado (timeout).

80A4

Fallo de comunicación en PROFIBUS.

80B0

El maestro DP o la CPU no soportan este servicio.

80B2

Error en determinación de topología: No se ha detectado ningún repetidor de diagnóstico en el sistema
maestro DP seleccionado.

80C3

En este momento los recursos necesarios están ocupados. Causa posible: Ha iniciado una segunda
determinación de la topología (no está permitido determinar más de una topología en un determinado
instante).

80C5

El sistema maestro DP no está disponible en este momento.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Programación del PLC
Manual de programación y manejo, 11/2019

2547

Instrucciones
4.1 Instrucciones

ASi
ASI_CTRL: controlar comportamiento del maestro AS-i
Descripción ASI_CTRL
Descripción
La instrucción "ASI_CTRL" permite controlar el comportamiento del maestro AS-i a través del
programa de usuario del PLC. La instrucción procesa automáticamente el protocolo del
comando y permite la parametrización de maestros AS-i SIMATIC así como la lectura de datos
de información. Las posibilidades disponibles y el funcionamiento de la interfaz de comandos
se describen en el manual del maestro AS-i.
Se soportan maestros AS-i con conexión centralizada y maestros AS-i descentralizados vía
PROFIBUS DP. También son posibles combinaciones con PROFINET IO (ejemplo: IE/PB Link
PN IO).
La figura siguiente muestra esquemáticamente la funcionalidad de la instrucción "ASI_CTRL":

(VWDFLµQ6,0$7,&

0DHVWUR$6L

3URJUDPDGHXVXDULR
$6,B&75/
&RPDQGRGH

%¼IHUGHUHFHSFLµQ
Datos de respuesta

①
②
③
④
⑤
⑥

2548

Escribir
registro



Consultar
estado



Leer registro




STATUS

Interfaz de comandos

%¼IHUGHWUDQVPLVLµQ
N.º de comando /
Datos de petición

Inicio

'LUHFFLµQLQLFLDO0DHVWUR$6L



Ejecución de
comando



Inicio del procesamiento en el parámetro REQ.
El programa transmite al maestro AS-i el comando deseado mediante la instrucción
"RDREC".
El maestro AS-i ejecuta el comando.
El estado actual del maestro AS-i se deposita en el área de entrada de datos bina‐
rios (dirección base lógica).
La instrucción "ASI_CTRL" consulta cíclicamente los 4 bits de estado y los evalúa.
Si ha terminado la ejecución de comandos, la petición de comandos concluye me‐
diante "RDREC". En el campo de datos de "RDREC" se encuentran, para cada
comando, los datos de respuesta del mismo u otra información de estado.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Dependencias entre versiones de instrucciones
La versión V1.3 de la instrucción "ASI_CTRL" exige la versión V1.1 de la instrucción "WRREC".
La versión V1.2 de la instrucción "ASI_CTRL" exige la versión V1.1 de la instrucción "WRREC".

Diferencias en la llamada de comandos con IE/AS-i Link y DP/AS-i Links
Existen diferencias sustanciales en el procedimiento de intercambio de comandos entre un
controlador y un maestro AS-i.
● Con IE/AS-i Link (PROFINET) se utiliza la interfaz de juegos de datos. Los distintos
comandos son llamados por diferentes números de juegos de datos mediante "Escribir
registro" (instrucción "WRREC") o "Leer registro" (instrucción "RDREC").
● Los DP/AS-i Links (PROFIBUS) utilizan la interfaz de comandos. Todos los comandos son
llamados por el número de juego de datos 2 mediante una pareja de instrucciones "Escribir
registro" (instrucción "WRREC") y "Leer registro" (instrucción "RDREC"). El tipo de
comando lo define el contenido de datos al efectuarse la petición de escritura.

Funcionamiento de la instrucción "ASI_CTRL"
La instrucción "ASI_CTRL" es un bloque de función asíncrono. Su ejecución se prolonga a lo
largo de varias llamadas.
● Una petición se inicia con REQ = TRUE.
● Mediante los parámetros de salida BUSY y los dos bytes centrales del parámetro de salida
STATUS se muestra el estado de la petición.
● Mientras se procesa la petición, está activado el parámetro BUSY. En la primera llamada,
STATUS contiene el valor 00700100H. En todas las llamadas sucesivas pertenecientes a
esta petición, contiene el valor 00700200H. Al concluir la petición, el resultado se indica en
los parámetros DONE o ERROR.
– Si no se ha producido ningún error, se activa DONE. En peticiones con datos de
respuesta del maestro AS-i, dichos datos se ponen a disposición en el búfer de
recepción indicado. En este caso, además, en el parámetro STATUS se muestra la
cantidad de datos proporcionados en bytes. En peticiones sin datos de respuesta, en
STATUS se registra el valor 00000000H.
– Si durante el procesamiento de la petición se presenta un error, se activa ERROR. En
ese caso, el contenido del búfer de recepción no es válido. Para definir con más
precisión el error ocurrido, en el parámetro STATUS se registra un código de error.

Número de llamadas de comandos
Si se utiliza la instrucción "ASI_CTRL" para efectuar la petición de comandos, no deben
emitirse simultáneamente otros comandos al mismo maestro AS-i mediante "RDREC
(Página 2382)" y "WRREC (Página 2401)". Lo mismo se aplica a las llamadas múltiples de la
instrucción en el mismo maestro AS-i.
La instrucción "ASI_CTRL" no se puede ejecutar con posibilidad de interrupción. Por ello las
llamadas no se pueden programar en niveles de ejecución que se interrumpan recíprocamente
(p. ej. con llamada en el OB 1 y en el OB 35).

Programación del PLC
Manual de programación y manejo, 11/2019

2549

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "ASI_CTRL":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Con REQ = TRUE se inicia una petición nueva
siempre que no se esté ejecutando otra. No se
realiza ninguna evaluación de flancos.

LADDR

Input

HW_IO

I, Q, M, D, L o cons‐
tante

Identificador de hardware del maestro AS-i.

I, Q, M, D, L

Búfer de transmisión

SD

Input

VARIANT

La dirección figura en las propiedades del mó‐
dulo.
El parámetro remite a un área de memoria en
la que debe especificarse el comando (véase
"Comandos AS-i (Página 2552)").

RD

Input

VARIANT

I, Q, M, D, L

Búfer de recepción
Este búfer solo es relevante para comandos
que devuelven datos de respuesta. El paráme‐
tro remite a un área de memoria en la que se
guarda una respuesta al comando (véase "Co‐
mandos AS-i (Página 2552)").

DONE

Output

BOOL

I, Q, M, D, L

DONE = TRUE: petición finalizada sin errores.

BUSY

Output

BOOL

I, Q, M, D, L

BUSY = TRUE: petición en procesamiento.

ERROR

Output

BOOL

I, Q, M, D, L

ERROR = TRUE: petición cancelada con erro‐
res.

STATUS

Output

DWORD

I, Q, M, D, L

Estado de la petición / Código de error
Véase la descripción de "Parámetro STATUS".

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".
Nota
Parámetros LADDR, SD y RD
Los parámetros LADDR, SD y RD no pueden modificarse en ninguna ejecución del bloque
mientras se procesa una petición; deben permanecer constantes.

Parámetro STATUS
La tabla siguiente contiene las posibles indicaciones de STATUS en función de DONE y
ERROR.
DONE

BUSY

ERROR

STATUS

Significado

0

0

0

00700000H Primera llamada con REQ = FALSE; no hay ninguna petición activa.

0

1

0

00700100H Primera llamada con REQ = TRUE; petición lanzada.

0

1

0

00700200H Llamada sucesiva (REQ es irrelevante); se sigue procesando la petición.

1

0

0

00000000H Petición finalizada sin errores. Sin datos de respuesta.

1

0

0

0000xx00H Petición finalizada sin errores. Número de bytes xx de los datos de res‐
puesta.

2550

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
DONE

BUSY

ERROR

STATUS

Significado

0

0

1

C0818400

Tipo de datos del operando formal RD no admisible.

0

0

1

H

0

0

1

C0818500
H

Error de comunicación con el maestro AS-i (dirección configurada erró‐
neamente en el parámetro LADDR).

C0838100

Dirección errónea del esclavo AS-i.

H

0

0

1

0

0

1

C0838200

Esclavo AS-i no activado (no en LAS).

H

0

0

1

C0838300
H

Error en AS-Interface (es posible que se haya ajustado un valor insufi‐
ciente en el parámetro SD).

C0838400

En el estado actual del maestro AS-i este comando no está permitido.

H

0

0

1

0

0

1

C0838500

Existe un esclavo AS-i con dirección "0".

H

0

0

1

C0838600
H

El esclavo AS-i tiene datos de configuración no permitidos (E/S o códi‐
gos ID).

C083A100

El esclavo AS-i direccionado no se encuentra en el AS-Interface.

H

0

0

1

0

0

1

C083A200

Existe un esclavo AS-i con dirección "0".

H

C083A300

En el AS-Interface ya existe un esclavo AS-i con la dirección nueva.

H

0

0

1

C083A400

No es posible borrar la dirección del esclavo AS-i.

H

0

0

1

0

0

1

C083A500

No es posible establecer la dirección del esclavo AS-i.

H

C083A600

No es posible guardar permanentemente la dirección del esclavo AS-i.

H

0

0

1

C083A700

Error al leer el código Extended ID1.

H

0

0

1

C083A800
H

La dirección de destino no es plausible (p. ej., se utiliza una dirección de
esclavo B para un esclavo estándar).

0

0

1

C083B100

Se ha producido un error de longitud en la transferencia de string.

H

0

0

1

C083B200

Se ha producido un error de protocolo en la transferencia de string.

H

0

0

1

0

0

1

C083F800

Se desconoce el número de petición o el parámetro de la petición.

H

C083F900

El maestro AS-i ha detectado un error EEPROM.

H

Consulte también
RDREC: Leer registro (Página 2382)
WRREC: Escribir registro (Página 2401)
Cambiar formatos de visualización en el estado del programa (Página 8529)

Programación del PLC
Manual de programación y manejo, 11/2019

2551

Instrucciones
4.1 Instrucciones
GET_ERR_ID: Consultar ID de error localmente (Página 933)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

Comandos AS-i
Descripción
La interfaz de comandos permite intercambiar datos de parametrización e información entre el
controlador y el maestro AS-i.
Con estos comandos:
● se proporciona a la especificación del maestro AS-i la funcionalidad completa del perfil de
maestro M4;
● puede configurarse completamente el maestro AS-i desde el controlador.
Nota
Comandos AS-i soportados
En el manual del maestro AS-i correspondiente pueden consultarse los comandos AS-i
soportados y una descripción detallada de los mismos.

Estructura general del búfer de transmisión
La tabla siguiente muestra la estructura general del búfer de transmisión para comandos y
datos de peticiones. El área para el número de comando debe estar ocupada siempre. El
número de bytes para los datos de la petición se encuentran en la descripción de cada
comando (véase la documentación del maestro AS-i). En este caso, "q" equivale a la dirección
inicial del búfer de transmisión.
Byte

Bit 7

Bit 6

Bit 5

Bit 4

Bit 3

Bit 2

Bit 1

Bit 0

Significado

2552

q+0

Número del comando

q+1

Datos de la petición

q+2

Datos de la petición

q + ...

Datos de la petición

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Estructura general del búfer de recepción
La tabla siguiente muestra la estructura general del búfer de recepción para los datos de
respuesta del comando. El número de bytes para los datos de respuesta depende de cada
comando. Algunos comandos no devuelven datos de respuesta y, por tanto, necesitan la
especificación de un búfer de recepción virtual que no se rellene con datos. En este caso, "n"
equivale a la dirección inicial del búfer de recepción.
Byte

Bit 7

Bit 6

Bit 5

Bit 4

Bit 3

Bit 2

Bit 1

Bit 0

Significado
n+0

Datos de respuesta

n+1

Datos de respuesta

n+2

Datos de respuesta

n + ...

Datos de respuesta

ATENCIÓN
Las áreas de memoria pueden sobrescribirse
Si el búfer de recepción de la instrucción "ASI_CTRL" es demasiado corto, pueden
sobrescribirse las áreas de memoria colindantes. La longitud indicada en el puntero ANY del
parámetro RD durante la llamada de la instrucción "ASI_CTRL" es irrelevante. La longitud
necesaria del búfer de recepción debe consultarse en la descripción del comando.
Para los números de comando 39H, 41H, 42H, 43H y 44H se aplica lo siguiente:
el búfer de recepción debe tener 221 bytes de longitud (del byte 0 al byte 220) aun cuando el
comando devuelva menos datos. Dependiendo del comando, el maestro AS-i puede
sobrescribir con valores cero los bytes más altos contenidos en el búfer de recepción.

Comandos AS-i
La tabla siguiente muestra una selección posible de comandos AS-i.
Nombre

Parámetro

Retorno

Codificación

Configurar_valor_de_parámetro
(Set_Permanent_Parameter)

Dirección de esclavo, pará‐
metros

Leer_valor_de_parámetro_configurado

Dirección de esclavo

Parámetros

01 H

Dirección de esclavo, pará‐
metros

Eco de parámetro

02 H

(Write_Parameter)
Leer_valor_de_parámetro

Dirección de esclavo

Valor del parámetro

03 H

00 H

(Get_Permanent_Parameter)
Escribir_valor_de_parámetro

(Read_Parameter)
Configurar_valores_de_parámetros_reales

04 H

(Store_Actual_Parameters)
Configurar_datos_de_configuración

Programación del PLC
Manual de programación y manejo, 11/2019

Dirección de esclavo, confi‐
guración

25 H

2553

Instrucciones
4.1 Instrucciones
Nombre

Parámetro

Retorno

Codificación

Leer_datos_de_configuración_configurados

Dirección de esclavo

Datos de configuración
configurados

26 H

Configurar_datos_de_configuración_reales

07 H

(Store_Actual_Configuration)
Leer_datos_de_configuración_reales

Dirección de esclavo

Configurar_LPS

LPS

Datos de configuración
reales

28 H
29 H

Activar_modo_Offline

Modo

0A H

Seleccionar_autoprogramación

Modo

0B H

Activar_modo

Modo

0C H

Cambiar_dirección_esclavo_AS–i

Dirección1, dirección2

0D H

(Change_AS–iSlave_Address)
Leer_estado_esclavo_AS–i

Dirección de esclavo

Registro de errores del
esclavo AS-i

0F H

Leer_listas_y_flags

LDS, LAS, LPS, flags

30 H

Leer_configuración_total

Datos de configuración
reales, parámetros ac‐
tuales, LAS, flags

39 H

Configurar_configuración_total

Configuración total

3A H

Escribir_lista_parámetros

Lista de parámetros

3C H

Leer_lista_eco_parámetros
Escribir_petición_CTT2

Dirección de esclavo

Lista de ecos de pará‐
metros

33 H

String CTT2

44 H

String de versión

14 H

String CTT2
Leer_identificador_versión
Leer_ID_esclavo_AS–i

Dirección de esclavo

Código ID

17 H

Leer_Extended–ID1_esclavo_AS-i

Dirección de esclavo

Código Extended ID1

37 H

Escribir_Extended-ID1_esclavo_AS–i

Código Extended ID1

3F H

Leer_Extended–ID2_esclavo_AS-i

Dirección de esclavo

Código Extended ID2

38 H

Leer_ES_esclavo_AS–i

Dirección de esclavo

Configuración E/S

18 H

Leer_lista_errores_periferia
Escribir_string_parámetros_esclavo_AS–i

LPF
Dirección de esclavo, string
de parámetros

3E H
40 H

Leer_string_parámetros_esclavo_AS–i

Dirección de esclavo

String de parámetros

41 H

Leer_string_ID_esclavo_AS–i

Dirección de esclavo

String ID

42 H

Leer_string_diagnóstico_esclavo_AS–i

Dirección de esclavo

String de diagnóstico

43 H

Leer_contador_errores_línea_AS–i

4A H

Leer_y_borrar_contador_errores_línea_AS–i

4B H

Leer_contador_errores_esclavo_AS–i

Dirección de esclavo

4C H

Leer_y_borrar_contador_errores_esclavo_AS–i

Dirección de esclavo

4D H

Comando adicional para el DP/ AS-i F-Link:
Estado_AS-i/Diag_esclavos_F

2554

Estado / Diagnóstico
de todos los esclavos
ASIsafe

51 H

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Nota
Nueva inicialización de la interfaz de comandos del maestro AS-i
Otro comando no mencionado en la tabla es el comando 77 H. Con esta llamada se reinicializa
la interfaz de comandos del maestro AS-i. Si justo en este momento el maestro AS-i indicado
está ocupado con un comando, este se interrumpe.
A partir de la versión V2.1.20 de DP/AS-i LINK Advanced se ofrece el comando adicional 0E H.
Con esta llamada puede habilitarse o bloquearse la función de vigilancia de contacto a tierra
de una línea.

4.1.4.6

PROFIenergy

Descripción de PROFIenergy
PROFIenergy
PROFIenergy es un perfil de gestión energética con PROFINET independiente de cualquier
fabricante y cualquier dispositivo concreto. PROFIenergy permite desconectar los dispositivos
de forma coordinada y centralizada para reducir el consumo eléctrico durante pausas de
producción o durante interrupciones no planificadas.
3DXVD

&RQVXPRGHHQHUJ¯D

3DXVD

7LHPSR

Los dispositivos PROFINET o los módulos de potencia se desconectan mediante comandos
especiales en el programa de usuario del controlador PROFINET IO. No se requiere hardware
adicional. Los dispositivos PROFINET interpretan directamente los comandos PROFIenergy.

Programación del PLC
Manual de programación y manejo, 11/2019

2555

Instrucciones
4.1 Instrucciones

Controlador PROFIenergy (controlador PE)
El controlador PE es un PLC que activa o desactiva el estado de reposo de los dispositivos
subordinados. La desconexión o la reactivación de componentes de producción concretos o
de líneas de producción enteras se realiza mediante el programa de usuario. Los comandos (p.
ej. "Start_Pause" o "End_Pause") se emiten al dispositivo subordinado mediante las
instrucciones correspondientes (bloques de función). Los comandos se envían con el
protocolo de comunicación PROFINET.

Unidad PROFIenergy (unidad PE)
La unidad PE recibe los comandos PROFIenergy del controlador PE y los aplica de forma
correspondiente (p. ej. devolviendo un valor medido o activando un modo de ahorro de
energía). La aplicación de la unidad PE en un dispositivo con capacidad PROFIenergy
depende del tipo de dispositivo y del fabricante.
La unidad PE se puede aplicar, por ejemplo:
● En el Proxy de un módulo: los comandos PE son válidos para el módulo direccionado,
respectivamente, y dado el caso, para módulos subordinados.
● En el Proxy de una tarjeta: Los comandos PE son válidos para distintos módulos dentro de
la tarjeta, respectivamente.
&RQWURODGRU3(

'LVSRVLWLYR352),1(7,2

&RQWURODGRU3(

0µGXORGHLQWHUID]
,0 FRPRXQLGDG3(

0µGXORFRPRXQLGDG3(
&RPDQGR3(

'LVSRVLWLYR352),1(7,2

&RPDQGR3(

● En un módulo sin funcionalidad Proxy dentro de la red: en este caso, los comandos PE solo
son válidos para el módulo correspondiente.

2556

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Instrucciones PROFIenergy
● Instrucciones para controlador IO
– La manera más sencilla de activar o desactivar el estado de reposo de los dispositivos
PROFINET es el uso de la instrucción "PE_START_END (Página 2558)" (comandos
PROFIenergy "Start_Pause" y "End_Pause"). Esto ocurre con un flanco de señal
ascendente y descendente en la instrucción.
– La instrucción "PE_CMD (Página 2563)" transfiere todos los comandos PROFIenergy,
incluidos "Start_Pause" y "End_Pause". Además, con otros comandos puede
consultarse el estado actual de los dispositivos PROFINET o su comportamiento
durante las pausas, por ejemplo.
– Con la instrucción "PE_DS3_Write_ET200S (Página 2568)" se especifican los ajustes
para el comportamiento de conexión de un máximo de 8 slots del ET 200S. Esta
instrucción no es una instrucción PROFIenergy pero complementa las funciones
PROFIenergy de un ET 200S.
● Instrucción para iDevices
La instrucción "PE_I_DEV (Página 2594)" permite ejecutar PROFIenergy también en
iDevices. Esta instrucción recibe comandos PROFIenergy en el iDevice y los transfiere al
programa de usuario para ejecutarlos. Después de ejecutar el comando, el programa de
usuario llama otra vez a la instrucción "PE_I_DEV (Página 2594)" para enviar acuse al
controlador IO. Para responder, se dispone para cada comando de un bloque auxiliar
específico que proporciona a la instrucción "PE_I_DEV (Página 2594)" los datos de
respuesta.

Comandos PROFIenergy (comandos PE)
El controlador PE envía los comandos PE a la unidad PE. El comando PE puede ser un
comando de control para poner una unidad PE en un determinado modo de ahorro de energía,
o un comando para leer un estado o un valor medido:
● Comandos PE para el control
PROFIenergy soporta dos comandos de control que pueden ejecutarse mediante la
instrucción "PE_Start_End (Página 2558)" o mediante la instrucción "PE_CMD
(Página 2563)":
– Start_Pause: Iniciar un modo de ahorro de energía adecuado (PE Energy-saving mode)
– End_Pause: Finalizar el modo de ahorro de energía (paso al modo
PE_ready_to_operate)
● Comandos PE para leer un estado o un valor medido
Mediante los siguientes comandos de estado, el control puede leer con la instrucción
"PE_CMD (Página 2563)" determinada información de estado:
– PE_Identify: Leer qué comandos PE soporta la unidad PE.
– PEM_Status: Leer cuál es el modo activo de una unidad PE en el momento actual (p. ej.
PE_ready_to_operate).
– Query_Modes: Muestra una sinopsis de todos los modos de ahorro de energía
soportados, incluida la información de tiempo y energía
– Query_Measurement: Muestra los valores medidos de una unidad PE

Programación del PLC
Manual de programación y manejo, 11/2019

2557

Instrucciones
4.1 Instrucciones

Ejemplos de aplicación
Pueden consultarse ejemplos de aplicación de las instrucciones PROFIenergy en el artículo
"PROFIenergy - Ahorrar energía con SIMATIC S7 (http://
support.automation.siemens.com/WW/view/es/41986454)" del Industry Online Support.

Consulte también
Service & Support (http://support.automation.siemens.com/)

Controlador IO
PE_START_END: Iniciar y finalizar modo de ahorro de energía
Descripción
Con la instrucción "PE_START_END" se inicia y finaliza la pausa de ahorro de energía para la
unidad PE especificada (p. ej. el ET 200S).
La instrucción "PE_START_END" se emplea en el controlador PE preferentemente cuando en
los dispositivos PE asignados solo hay conectados aparatos de campo en los que no van a
leerse datos de energía. Para leer los datos de energía también puede emplearse la
instrucción "PE_CMD (Página 2563)".
Los modos de ahorro de energía se configuran en el programa de usuario del controlador PE.
Después de ejecutar "PE_START_END", la unidad PE responde notificando qué modo de
ahorro de energía se ha adoptado realmente y lo indica en el parámetro PE_MODE_ID.

Peticiones de escritura y lectura de la instrucción "PE_START_END"
La instrucción "PE_START_END" envía internamente mediante "WRREC (Página 2401)" un
comando PROFIenergy en forma de petición de escritura a la unidad PE. A continuación,
"PE_START_END" espera el acuse de la unidad PE. Para ello, cada 100 milisegundos se lee
el registro de acuse con la instrucción "RDREC (Página 2382)". Mientras no se reciba acuse
de la unidad PE, la petición de lectura se repite cada 100 milisegundos durante 10 segundos.
Los datos de respuesta de la unidad PE también se leen con la instrucción "RDREC
(Página 2382)".
La figura siguiente muestra el diagrama de ejecución de las peticiones de escritura y lectura:

2558

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
&RQWURODGRU352),HQHUJ\

'LVSRVLWLYR352),HQHUJ\

3(B67$57B(1'3(B&0'

5(4 

3(B,B'(9

3HWLFLµQGHHVFULWXUD
1(: 
5HVSXHVWDGHHVFULWXUD
SRVLWLYR

3HWLFLµQGHOHFWXUD

PV

5HVSXHVWDGHOHFWXUD
QHJDWLYRUHFXUVRRFXSDGRR\DXWLOL]DGR

V

3HWLFLµQGHOHFWXUD

5HVSXHVWDGHOHFWXUD SRVLWLYR

V

7LHPSR

7LHPSR

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "PE_START_END":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

START

Input

BOOL

I, Q, M, D, L o cons‐
tante

Transmisión del comando PE "Start_Pause" a
la unidad PE con la dirección en el parámetro
ID.

END

Input

BOOL

I, Q, M, D, L o cons‐
tante

Transmisión del comando PE "End_Pause" a
la unidad PE con la dirección en el parámetro
ID.

Programación del PLC
Manual de programación y manejo, 11/2019

2559

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ID

Input

HW_
SUBMODULE

I, Q, M, D, L o cons‐
tante

Dirección de la unidad PE
Para un dispositivo PROFINET IO utilice el ID
de hardware del módulo de cabecera. El iden‐
tificador de hardware figura en las constantes
de sistema del controlador IO asignado. El
nombre del módulo de cabecera se compone
del nombre del dispositivo IO y el complemen‐
to [Head] (ejemplo: "IO_Device_1[Head]").
Si la unidad PE es un I-Device, en lugar del
identificador de hardware debe indicarse un
área de transferencia.

PAUSE_TIME

Input

TIME

I, Q, M, D, L, P o cons‐ Duración planificada de la pausa.
tante
● Rango:
T#1MS a T#24D20H31M23S647MS
● Valor de arranque:
T#0MS

VALID

Output

BOOL

I, Q, M, D, L

Comando PE emitido correctamente.

BUSY

Output

BOOL

I, Q, M, D, L

Aún se está ejecutando el comando PE.

ERROR

Output

BOOL

I, Q, M, D, L

Se ha producido un error durante la ejecución.
El mensaje de error se indica en el parámetro
STATUS.

STATUS

Output

DWORD

I, Q, M, D, L, P

Estado de bloque o número de error (véase
"Parámetro STATUS")

PE_MODE_ID

Output

BYTE

I, Q, M, D, L, P

Número de identificación del modo de ahorro
de energía (nivel de ahorro de energía adop‐
tado durante la pausa).

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

2560

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro PAUSE_TIME
Con el parámetro PAUSE_TIME se predefine la duración de la pausa de ahorro de energía
para la unidad PE. En la unidad PE se comprueba si la pausa predefinida tiene duración
suficiente y si se puede aplicar. La duración mínima de pausa (Time_min_Pause) debe ser
mayor que la suma de los tiempos que el dispositivo necesita para cambiar al modo de ahorro
de energía (Time_to_Pause) y para volver al modo de operación (Time_to_Operate).
3(BUHDG\B
WRBRSHUDWH

3(BHQHUJ\B
VDYLQJBPRGH

6WDUWB3DXVH

7LPHBWRB3DXVH

(QGB3DXVH

7LPHBPLQBOHQJWKBRIBVWD\

7LPHBWRB2SHUDWH

W

7LPHBPLQB3DXVH
En el ET 200S se comprueba si la pausa planificada es mayor o igual que la duración mínima
de pausa (PM-E_Pause_Min) depositada en el ET 200S. Esta es de 10 segundos. Si se utiliza
una pausa menor, los módulos de potencia (PM-E) del ET 200S permanecen conectados.
Una vez transcurrido el tiempo de pausa no se produce ningún rearranque automático, sino
que el módulo permanece en estado OFF hasta que se emite el comando "END". De este
modo se evita una reconexión descoordinada, que podría provocar picos de carga indeseados.

Parámetro STATUS
En el parámetro de salida STATUS se muestra información de error. Si se interpreta como
ARRAY[1...4] of BYTE, la información de error tiene la estructura siguiente:
Elemento de cam‐
po

Nombre

Significado

STATUS[1]

Function_Num

Causa del error
● B#16#00: Ningún error
● B#16#DE: Error al leer el registro
● B#16#DF: Error al escribir el registro
● B#16#C0: Mensaje de error de la instrucción o de las instrucciones de
comunicación "RDREC (Página 2382)" y "WRREC (Página 2401)" empleadas
internamente.

STATUS[2]

Error_Decode

Ubicación de la identificación de error
● 80: Error DPV1 según la norma IEC 61158-6 o error específico de instrucción
● FE: Perfil DP/PNIO; error específico de PROFIenergy

Programación del PLC
Manual de programación y manejo, 11/2019

2561

Instrucciones
4.1 Instrucciones
Elemento de cam‐
po

Nombre

Significado

STATUS[3]

Error_Code_1

Identificación de error
● Con Error_Decode = 80:
–

80: Flancos ascendentes simultáneos en los parámetros de entrada
START y END.

–

81: Conflicto de longitud en los parámetros CMD_PARAM y
CMD_PARAM_LEN.

–

82-8F: Otros mensajes de error (reservado)

● Con Error_Decode = FE:

STATUS[4]

Error_Code_2

–

01: "Service Request ID" no válido

–

02: "Request_Reference" erróneo

–

03: "Modifier" no válido

–

04: "Data Structure Identifier RQ" no válido

–

05: "Data Structure Identifier RS" no válido

–

06: "PE energy-saving modes" no soportados

–

07: "Response" es demasiado largo (se ha rebasado la longitud máxima
transferible)

–

08: "Count" no válido

–

50: No hay ningún "energy mode" adecuado disponible.

–

51: El valor de tiempo indicado no se soporta.

–

52: "PE_Mode_ID" no admisible

–

53: El cambio a "PE energy-saving mode" no
es posible porque el dispositivo está en funcionamiento

–

54: Función no disponible actualmente. Dispositivo mal
parametrizado o configuración errónea.

–

55 a FF: reservado

Extensión específica de fabricante de la identificación de error

Nota
Mensajes de error de las instrucciones RDREC y WRREC
La instrucción "PE_START_END" utiliza para la comunicación las instrucciones "WRREC
(Página 2401)" y "RDREC (Página 2382)". Los mensajes de error de estas instrucciones se
emiten correspondientemente en los elementos de campo STATUS[1] a STATUS[4].
Consulte el significado de los códigos de error de las instrucciones "WRREC (Página 2401)"
y "RDREC (Página 2382)" en la descripción del parámetro STATUS (Página 2447)
correspondiente.

Consulte también
Descripción de PROFIenergy (Página 2555)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

2562

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

PE_CMD: Iniciar y finalizar modo de ahorro de energía / Leer información de estado
Descripción
La instrucción "PE_CMD" se emplea en el controlador PE e inicia o finaliza una pausa de
ahorro de energía en la unidad PE. Además, "PE_CMD" permite leer más información y
valores medidos de energía de una unidad PE.
La instrucción puede emplearse preferentemente en controladores PE en cuyos dispositivos
PE correspondientes estén conectados aparatos de campo de los que deban leerse valores
medidos de energía. Si esto no fuera así, para iniciar y finalizar las pausas también puede
emplearse la instrucción "PE_START_END (Página 2558)".

Transferencia de los comandos PROFIenergy (comandos PE)
La instrucción "PE_CMD" transfiere un comando PROFIenergy a una entidad PE.
La instrucción también puede emplearse si en el futuro se amplía el perfil PROFIenergy con
otros comandos. Los comandos que pueden utilizarse de acuerdo con el perfil PROFIenergy
actual se listan en la descripción de los parámetros CMD y CMD_MODIFIER (véase tabla
"Parámetros CMD y CMD_MODIFIER").
● Los diferentes comandos PE que se transfieren a la unidad PE mediante la instrucción
tienen asignadas "Service_Request_ID" definidas. Las Service_Request_ID 01...05 y 16 se
asignan en el parámetro CMD.
● Mediante el parámetro CMD_MODIFIER se especifican los dos comandos PE 04
(Query_Modes) y 16 (Query_Measurement).
● Para comandos PE concretos, en el parámetro CMD_PARA se transfieren valores
adicionales (véase la descripción de los distintos comandos PE). El parámetro
CMD_PARA_LEN define la longitud de datos en el parámetro CMD_PARA.
Los comandos se transfieren sin prueba de plausibilidad. Los datos de respuesta de la unidad
PE se depositan en el área de datos RESPONSE_DATA direccionada por el puntero VARIANT
(los contenidos de los telegramas de respuesta están en las descripciones de los
correspondientes comandos PE).

Peticiones de escritura y lectura de la instrucción "PE_CMD"
La instrucción "PE_CMD" envía mediante "WRREC (Página 2401)" un comando PROFIenergy
en forma de petición de escritura a la unidad PE. A continuación, "PE_CMD" espera el acuse
de la unidad PE. Para ello, cada 100 milisegundos se lee el registro de acuse con la instrucción
"RDREC (Página 2382)". Mientras no se reciba acuse de la unidad PE, la petición de lectura
se repite cada 100 milisegundos durante 10 segundos. Los datos de respuesta de la unidad PE
también se leen con la instrucción "RDREC (Página 2382)".
La figura siguiente muestra el diagrama de ejecución de las peticiones de escritura y lectura:

Programación del PLC
Manual de programación y manejo, 11/2019

2563

Instrucciones
4.1 Instrucciones
&RQWURODGRU352),HQHUJ\

'LVSRVLWLYR352),HQHUJ\

3(B67$57B(1'3(B&0'

5(4 

3(B,B'(9

3HWLFLµQGHHVFULWXUD
1(: 
5HVSXHVWDGHHVFULWXUD
SRVLWLYR

3HWLFLµQGHOHFWXUD

PV

5HVSXHVWDGHOHFWXUD
QHJDWLYRUHFXUVRRFXSDGRR\DXWLOL]DGR

V

3HWLFLµQGHOHFWXUD

V

5HVSXHVWDGHOHFWXUD SRVLWLYR

7LHPSR

7LHPSR

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "PE_CMD":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Inicia la transmisión del comando PE con
flanco ascendente.

ID

Input

HW_
SUBMODULE

I, Q, M, D, L o cons‐
tante

Dirección de la unidad PE
Para un dispositivo PROFINET IO utilice
el ID de hardware del módulo de cabece‐
ra. El identificador de hardware figura en
las constantes de sistema del controlador
IO asignado. El nombre del módulo de
cabecera se compone del nombre del dis‐
positivo IO y el complemento [Head]
(ejemplo: "IO_Device_1[Head]").
Si la unidad PE es un I-Device, en lugar
del identificador de hardware debe indi‐
carse un área de transferencia.

2564

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

CMD

Input

BYTE

I, Q, M, D, L, P o cons‐ Service-Request-ID del comando PRO‐
tante
FIenergy en función del perfil PROFIe‐
nergy (véase "Parámetros CMD y
CMD_MODIFIER").

Descripción

Si se amplía el perfil PROFIenergy son
posibles otras Service-Request-ID.
CMD_MODIFIER

Input

BYTE

I, Q, M, D, L, P o cons‐ Subcomando PROFIenergy
tante
(solo con CMD=3 o CMD=16, véase "Pa‐
rámetros CMD y CMD_MODIFIER")
Si se amplía el perfil PROFIenergy son
posibles otros subcomandos.

CMD_PARA

Input

VARIANT

I, Q, M, D, L

Parámetros de los comandos PE:
● Get mode: PE_mode_ID
● Get measurement values: List of
Measurement_Ids
Se registra el Service Data Request com‐
pleto.

CMD_PARA_LEN

Input

INT

I, Q, M, D, L, P o cons‐ Longitud real de los parámetros del co‐
tante
mando (la instrucción comprueba si es <=
a la longitud en CMD_PARA).

CMD_DA‐
Input
TA_STRUCTU‐
RE_IDENTIFIER_RQ

BYTE

I, Q, M, D, L, P o cons‐ Valor del Data Structure Identifier en la
tante
norma

RESPONSE_DATA

VARIANT

InOut

Nota: El parámetro CMD_DATA_STRUC‐
TURE_IDENTIFIER_RQ existe a partir de
la versión V2.0 de la instrucción.
I, Q, M, D, L

Información PROFIenergy
Dependiendo del comando, telegrama de
respuesta completo, incluido encabezado
de bloque.
Nota: si el búfer es demasiado pequeño
solo se registra el número de bytes, como
se indica en el puntero VARIANT.

VALID

Output

BOOL

I, Q, M, D, L

Comando emitido correctamente.

BUSY

Output

BOOL

I, Q, M, D, L

Aún se está ejecutando el comando.

ERROR

Output

BOOL

I, Q, M, D, L

Se ha producido un error durante la eje‐
cución.

STATUS

Output

DWORD

I, Q, M, D, L

Estado de bloque o número de error (véa‐
se "Parámetro STATUS"):

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2565

Instrucciones
4.1 Instrucciones

Parámetros CMD y CMD_MODIFIER
CMD

CMD_
MODIFIER

Comando PROFIenergy

Descripción

01

0

Start_Pause (Página 2584)

Inicia el modo de ahorro de energía o cambia a otro modo de
ahorro de energía.

02

0

End_Pause (Página 2584)

Sale del modo de ahorro de energía.

03

1

Query_Modes - List energy sa‐ Muestra los modos de ahorro de energía soportados.
ving Modes (Página 2585)

2

Query_Modes - Get Mode (Pá‐ Muestra los atributos del modo de ahorro de energía activa‐
do en el momento actual.
gina 2586)

04

0

PEM_Status (Página 2588)

Consulta el estado del modo de ahorro de energía.

05

0

PE_Identify (Página 2590)

Lectura del número de comandos PE soportados y descrip‐
ción de los mismos.

16

1

Query_Measurement Get_Measurement_List (Pági‐
na 2591)

Listado de los valores medidos soportados por la unidad PE.

2

Query_Measurement Get_Measurement_Values
(Página 2593)

Muestra los valores medidos de la unidad PE.

Parámetro STATUS
En el parámetro de salida STATUS se muestra información de error. Si se interpreta como
ARRAY[1...4] of BYTE, la información de error tiene la estructura siguiente:
Elemento de cam‐
po

Nombre

Significado

STATUS[1]

Function_Num

Causa del error
● B#16#00: Ningún error
● B#16#DE: Error al leer el registro
● B#16#DF: Error al escribir el registro
● B#16#C0: Mensaje de error de las instrucciones de comunicación "RDREC
(Página 2382)" y "WRREC (Página 2401)" empleadas internamente.

STATUS[2]

Error_Decode

Ubicación de la identificación de error
● 80: Error DPV1 según la norma IEC 61158-6 o error específico de instrucción
● FE: Perfil DP/PNIO; error específico de PROFIenergy

2566

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Elemento de cam‐
po

Nombre

Significado

STATUS[3]

Error_Code_1

Identificación de error
● Con Error_Decode = 80:
–

81: Conflicto de longitud en los parámetros CMD_PARA y
CMD_PARA_LEN o bien se ha excedido la longitud máxima del registro
(4095 bytes).

–

82-8F: Otros mensajes de error (reservado)

● Con Error_Decode = FE:

STATUS[4]

Error_Code_2

–

01: "Service Request ID" no válido

–

02: "Request_Reference" erróneo

–

03: "Modifier" no válido

–

04: "Data Structure Identifier RQ" no válido

–

05: "Data Structure Identifier RS" no válido

–

06: "PE energy-saving modes" no soportados

–

07: "Response" es demasiado largo (se ha rebasado la longitud máxima
transferible)

–

08: "Count" no válido

–

50: No hay ningún modo de ahorro de energía (energy mode) adecuado
disponible.

–

51: El valor de tiempo indicado no se soporta.

–

52: "PE_Mode_ID" no válido

Extensión específica de fabricante de la identificación de error

Nota
Mensajes de error de las instrucciones RDREC y WRREC
La instrucción "PE_CMD" utiliza para la comunicación las instrucciones "WRREC
(Página 2401)" y "RDREC (Página 2382)". Los mensajes de error de estas instrucciones se
emiten correspondientemente en los elementos de campo STATUS[1] a STATUS[4].
Consulte el significado de los códigos de error de las instrucciones "WRREC (Página 2401)"
y "RDREC (Página 2382)" en la descripción del parámetro STATUS (Página 2447)
correspondiente.

Consulte también
Descripción de PROFIenergy (Página 2555)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

Programación del PLC
Manual de programación y manejo, 11/2019

2567

Instrucciones
4.1 Instrucciones

PE_DS3_Write_ET200S: Ajustar el modo de activación de los módulos de potencia
Descripción
La instrucción "PE_DS3_Write_ET200S" envía al ET 200S configuraciones básicas sobre el
modo de activación de los módulos de potencia. La instrucción "PE_DS3_Write_ET200S"
permite definir el modo de activación de hasta 8 slots del ET 200S (p. ej. para módulos de
potencia).
Nota
Esta instrucción no forma parte del perfil PROFIenergy, sino que complementa funciones
específicas de SIMATIC.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "PE_DS3_Write_ET200S":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ENABLE

Input

BOOL

I, Q, M, D, L o cons‐
tante

Un flanco ascendente activa la transferencia
del registro. Transfiera el registro nuevamente
después de desconectar y volver a conectar la
tensión.

ID

Input

HW_SUBMO‐
DULE

I, Q, M, D, L o cons‐
tante

Dirección del ET 200S
Tome la dirección de la configuración hardwa‐
re.

SLOT_NO_X

Input

INT

I, Q, M, D, L, P o
constante

Número de slot del X.º módulo de potencia co‐
nectable.

FUNC_X

Input

INT

I, Q, M, D, L, P o
constante

Función del módulo en este slot. Mediante el
parámetro FUNC_X se define el modo de acti‐
vación del PM-E (módulo de potencia del
ET 200S):
● FALSE:
–

Con "PAUSE_START":
- no influye en el PM-E
- el PM-E continúa conectado

–

Con "PAUSE_STOP":
- se reconecta el PM-E

● TRUE:
–

Con "PAUSE_START":
- se desconecta el PM-E

–

Con "PAUSE_STOP":
- se reconecta el PM-E

BUSY

Output

BOOL

I, Q, M, D, L

La transferencia no ha finalizado todavía.

DONE

Output

BOOL

I, Q, M, D, L

La transferencia ha finalizado sin errores.

2568

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ERROR

Output

BOOL

I, Q, M, D, L

Transferencia finalizada con error.

STATUS

Output

DWORD

I, Q, M, D, L, P

Número de error (véase el parámetro STATUS
de la instrucción "PE_Start_End (Pági‐
na 2558)")

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Consulte también
Descripción de PROFIenergy (Página 2555)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

PE_WOL: Iniciar y finalizar modo de ahorro de energía mediante WakeOnLan
Descripción PE_WOL
Descripción
La instrucción "PE_WOL" envía los comandos PROFIenergy "Start_Pause" y "End_Pause" a
varios dispositivos compatibles con PROFIenergy en sistemas PROFINET I/O.
La instrucción permite la coordinación de varios dispositivos PE siempre que soporten la
función "Wake on LAN" a través de una conexión UDP.
La instrucción "PE_WOL" solo puede ejecutarse en una CPU con interfaz Ethernet integrada.
Esta CPU debe ser capaz de cargar bloques de un tamaño de aprox. 400 kB. Si estos están
conectados a través de un CP Ethernet, el bloque no se puede utilizar con sistemas
PROFINET IO.
La instrucción "PE_WOL" se ejecuta de forma asíncrona.
La instrucción "PE_WOL" solo soporta dispositivos con un número de dispositivo inferior al
256. Los dispositivos con un número superior a este no son considerados.

Definición: Wake on LAN
A través de Wake On LAN es posible activar nuevamente dispositivos desconectados
mediante la recepción de un paquete especial de Ethernet.
Para que funcione este procedimiento, el dispositivo de procesamiento de datos debe disponer
de un controlador de red equipado para poder recibir un paquete de este tipo.
Este paquete (Magic Packet™) tiene un formato especial. Contiene 15 veces la dirección MAC
del adaptador de red.

Programación del PLC
Manual de programación y manejo, 11/2019

2569

Instrucciones
4.1 Instrucciones

Selección de los dispositivos
La selección de los dispositivos se realiza por medio del bloque de datos de usuario en el
parámetro PENERGY (tipo: "PE_PLUS"). El DB de usuario representa la base de datos para
el procesamiento de varios dispositivos.
Antes de la inicialización de "PE_WOL" se debe guardar en el DB de usuario la siguiente
información, como mínimo:
● ID del sistema PROFINET I/O
● Datos de la conexión que se utiliza para "Wake On LAN"
● Número de puerto que se utiliza para "Wake On LAN"
● Para cada dispositivo
– Tiempo de pausa (PauseTime)
– Conmutación del dispositivo al PE_SLEEP_MODE (EnableSleep)
Con el parámetro COM_RST se inicializa la instrucción "PE_WOL". Tras la inicialización se
ejecutan las peticiones guardadas en el DB de usuario una tras otra.
El siguiente gráfico muestra a modo de ejemplo cómo se transmite el comando PE
"Start_Pause" a varios dispositivos:

%ORTXHGHGDWRVGHXVXDULR

'%GHLQVWDQFLD

Dir. diag.

Bit de
inicio

Bit de fin

8081
8082

1
0

0
0

8081

8083
8048
...

1
1
...

0
0
...

8048

3(B:2/

Diag.
Adr.

8083

(1)

Paso 1: El usuario pone a "1" el bit "CmdStartPause" de los dispositivos que se van a desco‐
nectar.

(2)

Paso 2: Las direcciones de diagnóstico de los dispositivos que se van a desconectar (CmdStart‐
Pause = "1") se encadenan en la lista de espera.

(3)

Paso 3: el bit "CmdStartPause" se desactiva automáticamente una vez encadenadas las peti‐
ciones.

(4)

Paso 4: la instrucción "PE_WOL" procesa las peticiones en cuanto estas están encadenadas.

A través de los parámetros START y END se puede enviar un comando PROFIenergy
"CmdStartPause" o "CmdEndPause" para todos los dispositivos detectados en el sistema
PROFINET IO.
Con el parámetro STATUS se indica el estado del procesamiento de la petición, así como
posibles errores durante su procesamiento.

2570

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Manejo de la instrucción a través del DB de usuario
El manejo de la instrucción "PE_WOL" solo se realiza a través del DB de usuario. A este
respecto se aplica un procedimiento básico:
1. Selección del comando que se va a ejecutar para un dispositivo:
– START_PAUSE ("CmdStartPause" en el DB de usuario)
– ENDE_PAUSE ("CmdEndPause" en el DB de usuario)
– UPDATE_STATUS ("CmdUpdateStatus" en el DB de usuario)
2. Activación del bit para la actualización ("Update" en el encabezado del DB de usuario)
Entre dos actualizaciones debería transcurrir como mínimo un ciclo de CPU con un
"Update" = False, ya que de lo contrario no se puede garantizar la detección de flancos.

Priorización de los comandos PE
El siguiente gráfico muestra la cronología de los tres comandos posibles.

CmdStartPause
CmdEndPause

CmdUpdateStatus

Update

Estos se procesan uno tras otro, independientemente de si el comando previo se ha ejecutado
correctamente o ha finalizado con errores.
En caso de activación simultánea de, p. ej., "CmdEndPause" y "CmdUpdateStatus" solo se
ejecutará un comando. Dentro del bloque existe una priorización:
● El comando "CmdStartPause" tiene la máxima prioridad y siempre se ejecuta mientras esté
seleccionado.
● El comando "CmdEndPause" tiene la segunda máxima prioridad.
● El comando "CmdUpdateStatus" tiene la mínima prioridad.
Si se activan los tres comandos a la vez, los que no se ejecuten permanecen
preseleccionados. En ese caso, en el siguiente flanco ascendente se ejecutará el siguiente
comando que corresponda.

Programación del PLC
Manual de programación y manejo, 11/2019

2571

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "PE_WOL":
Parámetro

Declaración

Input
COM_RST
(Página 2572)

Tipo de datos Área de memoria Descripción
BOOL

I, Q, M, D, L

Resetea el bloque y ejecuta una reinicialización. Mien‐
tras aquí esté ajustado True, comienza la operación
de inicialización pero no se ejecuta hasta el final.
La inicialización prosigue con el flanco descendente
y, una vez concluida esta, se pasa al modo de opera‐
ción normal.

START (Pági‐ Input
na 2574)

BOOL

I, Q, M, D, L

Con un flanco ascendente se ejecuta un comando
PROFIenergy "CmdStartPause" para todos los dispo‐
sitivos detectados que soporten esta función.

END (Pági‐
na 2575)

BOOL

I, Q, M, D, L

Con un flanco ascendente se ejecuta un comando
PROFIenergy "CmdEndPause" para todos los dispo‐
sitivos detectados que soporten esta función.

PENERGY
InOut
(Página 2575)

PE_PLUS

D

Puntero hacia el DB de usuario que contiene la base
de datos para el procesamiento de varios dispositivos.

STATUS (Pá‐
gina 2580)

DWORD

I, Q, M, D, L

Número de estado/error para el estado actual de la
instrucción (ver "Parámetro STATUS").

Input

Output

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Consulte también
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

Parámetro COM_RST
Desarrollo de la rutina de inicialización
Con el parámetro COM_RST se arranca la inicialización de la instrucción "PE_WOL".
El siguiente diagrama de flujo muestra la rutina de inicialización.

2572

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
INICIO

Clean Queue

Inicializar la lista de espera de
peticiones

Config Devices

Lectura de los dispositivos
configurados del sistema
PROFINET I/O

No. of
Devices
>0

Sí
Dev. Diag.

Determinar las direcciones de
diagnóstico

Order ID

Lectura de la OrderID

Connection
setup

Configuración de la conexión
WOL

PE_Identify

Identificación de los comandos PE
soportados para cada dispositivo

No

DB de
usuario

FIN
(Error)

Programación del PLC
Manual de programación y manejo, 11/2019

FIN
(Inicializado)

2573

Instrucciones
4.1 Instrucciones

Parámetro START
Desarrollo del comando CmdStartPause
El diagrama de flujo muestra las funciones utilizadas internamente y la interacción con un
dispositivo al ejecutar el comando CmdStartPause.

'%GHXVXDULR

'LVSRVLWLYR

&RQWURODGRU 3(B:2/
,1,&,2

/LVWDGHGLVSRVLWLYRV
FRQ
'LDJ,'
3DXVHB7LPH
:R/
6WDUWB3DXVHB%LW
ಹ

,QIRUPDFLµQDGLFLRQDO
HQHO'%
7LPHBWRBRSHUDWH
7LPHBPLQB3DXVH
3(B0RGHB,'
ಹ
:DNHB8SB0HWKRG
:DNHB8SB'DWDB/HQJW
:DNHB8SB'DWD
ಹ

(QDEOH6OHHS 

6¯

1R

6OHHS0RGH
6HOHFFLRQD
GR"

6¯

1R

'LVSRVLWLYR
SUHSDUDQGR
UHVSXHVWD

5HVSXHVWD
7LPHBWRBRSHUDWH
7LPHBPLQB3DXVH
:DNHB8SB0HWKRG
ಹ

*UDEDUUHVSXHVWD

3DXVHB7LPH
!
7LPHBPLQB
3DXVH

,QIRBVOHHSBPRGH

6¯

6WDUWBVOHHSBPRGH
*UDEDUUHVSXHVWD

'LVSRVLWLYRHQ
3(B6/((3B02'(

1R
6WDUWB3DXVH
*UDEDUUHVSXHVWD

4XHU\6WDWXV

'LVSRVLWLYRHQ
(1(5*<B6$9,1*B
02'(

3(0B6WDWXV
5HVSXHVWD

'LVSRVLWLYRHQ
(1(5*<B6$9,1*B
02'(

),1

2574

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro END
Desarrollo del comando CmdEndPause
El diagrama de flujo muestra las funciones utilizadas internamente y la interacción con un
dispositivo al ejecutar el comando CmdEndPause.

'%GHXVXDULR

'LVSRVLWLYR

&RQWURODGRU 3(B:2/
,1,&,2

/LVWDGHGLVSRVLWLYRV
FRQ
'LDJ,'
3DXVHB7LPH
:R/
6WDUWB3DXVHB%LW
ಹ

3(B0RGH
6OHHS0RGH

6¯

0DJLF3DFNHWറ
Y¯D7&20
'HIDXOW3RUW

1R

(QGB3DXVH
,QIRUPDFLµQDGLFLRQDO
HQHO'%

(QGB3DXVH

*UDEDUUHVSXHVWD

7LPHBWRBRSHUDWH
7LPHBPLQB3DXVH
3(B0RGHB,'
ಹ
:DNHB8SB0HWKRG
:DNHB8SB'DWDB/HQJW
:DNHB8SB'DWD
ಹ

'LVSRVLWLYRHQ
6OHHSBPRGH

:DLW772

3(0B6WDWXV

'LVSRVLWLYRHQ
(QHUJ\BVDYLQJBPRGH
B[

'LVSRVLWLYRHQ
5HDG\BWRBRSHUDWHBP
RGH

*UDEDUUHVSXHVWD

),1

Parámetro PENERGY
Bloque de datos en el parámetro PENERGY
El DB de usuario para la instrucción PROFIenergy "PE_WOL" constituye una base de datos
para el procesamiento de varios dispositivos.

Programación del PLC
Manual de programación y manejo, 11/2019

2575

Instrucciones
4.1 Instrucciones
El bloque de datos se divide generalmente en dos secciones. A saber:
● Sección de encabezado 110 bytes (header)
● Sección de dispositivos para un máximo de 256 dispositivos de 100 bytes cada uno
(Device). Estos incluyen:
– Datos específicos del dispositivo (Device)
– Datos específicos de PROFIenergy (PE)
– Datos de procesamiento de petición (Task)
– Datos de usuario (UserData)
El bloque de datos funciona con acceso optimizado.

Parámetro de conexión "Connection"
La instrucción "PE_WOL" reserva un recurso de conexión del área de "Open User
Communication". Este se utiliza como conexión UDP. Para ello, deben definirse los siguientes
parámetros en el bloque de datos:
● ID de conexión (parámetro "Connection.id")
La ID de conexión es un número entero entre 1 y 4095. Sirve para identificar los recursos
de comunicación asignados por el firmware, como el búfer de transmisión y de recepción.
La ID de conexión debe ser unívoca en toda la CPU.
● Número de puerto que se utiliza para la función "Wake On LAN" (parámetro
"Header.PortNo")
Número del puerto UDP a través del que se envía un paquete "Wake On LAN". Estos
números de puerto forman parte de los recursos de comunicación identificados por la ID de
la conexión y asignados por el firmware. El ajuste estándar utilizado aquí para el puerto de
2189 no está asignado actualmente por la IANA. El número de puerto se transfiere a la
configuración de conexiones y se aplica para el parámetro "Connection.local_tsap_id[1]". El
número de puerto y la longitud del puerto eliminado se definen mediante los parámetros
"Connection.rem_tsap_id[1]" y "Connection.rem_tsap_id_LEN" y deben asignarse
manualmente.

2576

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Estructura del bloque de datos
El bloque de datos tiene la siguiente estructura:
Nombre
Header
Update (1)

Tipo de datos

Offset

Comentario

PE_HEADER

-

Información de encabezado

BOOL

-

Señal que indica una modificación en el área de datos.
● True= indica una modificación por parte del usuario.
● False= indica la aplicación de las modificaciones.

Initialized

BOOL

-

Señal que indica el final de la inicialización.
● True= inicialización finalizada.
● False= indica que el bloque no se ha inicializado.

LinkUp

BOOL

-

Indica la configuración correcta de la interfaz Ethernet.
● True= interfaz lista para su uso.
● False= interfaz aún no configurada.

LinkDown

BOOL

-

Indica una interfaz sin configurar.
● True= interfaz no configurada.
● False= la interfaz está configurada o se está
configurando actualmente.

PROFINET_ID (1)

INT

-

ID del sistema PROFINET I/O

Reserved

ARRAY [1..37] OF
BYTE

-

Reservado

LastDeviceID

INT

-

Contiene la Device-ID más alta en este sistema PROFI‐
NET I/O.

PortNo (1)

WORD

-

Número de puerto que se utiliza para la función "Wake On
LAN" (valor predeterminado = 2189).

Connection

TCON_Param

-

Contiene la configuración de la conexión "Wake on LAN".

Programación del PLC
Manual de programación y manejo, 11/2019

2577

Instrucciones
4.1 Instrucciones
Nombre
BLOCK_LENGTH
ID (1)
CONNECTION_TYPE

(1)

ACTIVE_EST (1)

Tipo de datos

Offset

Comentario

UInt

-

Longitud de la estructura (siempre B#16#40).

CONN_OUC

-

ID de conexión

USINT

-

Tipo de conexión (UDP = B#16#13)

BOOL

-

Establecimiento activo de la conexión (siempre pasivo con
UDP)

LOCAL_DEVICE_ID (1)

USINT

-

Contiene la ID de interfaz (dependiente de la CPU).

LOCAL_TSAP_ID_LEN

USINT

-

Contiene la longitud en bytes del puerto UDP propio/local.

REM_SUB‐
NET_ID_LEN (1)

USINT

-

Sin utilizar (siempre B#16#00)

REM_STADDR_LEN (1)

USINT

-

Contiene la longitud de la dirección IP remota o B#16#00.

REM_TSAP_ID_LEN (1)

USINT

-

Contiene la longitud en bytes del puerto UDP remoto. La
longitud debe introducirse manualmente.

NEXT_STADDR_LEN (1) USINT

-

Contiene la longitud de la dirección del router predetermi‐
nado (no relevante).

LOCAL_TSAP_ID (1)

ARRAY[1..16] OF
BYTE

-

Contiene el número de puerto propio/local. El valor se toma
del parámetro PortNo durante la inicialización.

REM_SUBNET_ID (1)

ARRAY[1..6] OF
USINT

-

Sin utilizar (siempre B#16#00)

REM_STADDR (1)

ARRAY[1..6] OF
USINT

-

Contiene la dirección IP remota.

REM_TSAP_ID (1)

ARRAY[1..16] OF
BYTE

-

Contiene el número de puerto UDP remoto. El número de
puerto debe introducirse manualmente.

NEXT_STADDR (1)

ARRAY[1..6] OF
BYTE

-

Irrelevante

SPARE (1)

WORD

-

ARRAY[1..256]
OF PE_DEVICE

-

Matriz de los dispositivos

(1)

Device
Device

PE_DEV

-

Contiene datos de cada dispositivo.

DeviceID

HW_DEVICE

-

Identificador de hardware del dispositivo. Es asignada por
la configuración hardware.

PE_EntityID

HW_IO

-

Identificador de hardware de la entidad PROFIenergy. Es
asignada por la configuración hardware.

MACAdr

ARRAY[1..6] OF
BYTE

-

Contiene la dirección MAC del dispositivo.

IPAdr

ARRAY[1..4] OF
BYTE

-

Contiene la dirección IP del dispositivo.

OrderID_MxLen

Byte

-

Contiene la longitud máxima de OrderID.

OrderId_ActLen

Byte

Contiene la longitud actual de OrderID.

OrderID_Data

ARRAY[1..20] OF
CHAR

Contiene la OrderID del dispositivo.

PE

2578

PE_PE

-

Datos específicos de PROFIenergy.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Nombre
ModeID
Result

Tipo de datos

Offset

Comentario

BYTE

-

PE_MODE_ID conforme a especificación PROFIenergy.

BYTE

-

PE ErrorCode conforme a especificación PROFIenergy.

(1)

TIME

-

Contiene el tiempo de pausa en ms.

TimeToPause

TIME

-

Contiene el tiempo que necesita el dispositivo para pasar al
modo de pausa.

TimeToOperate

TIME

-

Contiene el tiempo que necesita el dispositivo para pasar al
modo de operación.

MinSleepTime

TIME

-

Contiene el tiempo mínimo del dispositivo en
PE_SLEEP_MODE.

SleepToOperate

TIME

-

Contiene el tiempo que necesita el dispositivo para estar
listo para el servicio desde PE_SLEEP_MODE.

StatusOperate

BOOL

-

Indica el modo de operación del dispositivo.

StatusPause

BOOL

-

Indica el modo de pausa del dispositivo.

StatusSleep

BOOL

-

Indica el PE_SLEEP_MODE del dispositivo.

StatusTransitOK

BOOL

-

Indica la transición de un estado de energía a otro.

StatusInTransit

BOOL

-

Indica una transición de estado actual.

StatusTransitNOK

BOOL

-

Indica que ha fallado el cambio de estado.

StatusError

BOOL

-

Indica un error con el dispositivo.

StatusRetryEx

BOOL

-

Indica la ejecución incorrecta de un comando. No se inten‐
ta ejecutar de nuevo este comando.

CmdStartPause (1)

BOOL

-

Posiciona un comando START_PAUSE para este disposi‐
tivo en la lista de espera.

CmdEndPause (1)

BOOL

-

Posiciona un comando END_PAUSE para este dispositivo
en la lista de espera.

CmdUpdateStatus (1)

BOOL

-

Posiciona un comando PEM_STATUS para este dispositi‐
vo en la lista de espera.

EnableSleep (1)

BOOL

-

Permite el PE_SLEEP_MODE para este dispositivo.

PauseTime

● True = el dispositivo debe pasar a PE_SLEEP_MODE
si la pausa dura lo suficiente.
● False= el dispositivo no debe pasar a
PE_SLEEP_MODE.
Services
UserData
Task

(2)

WORD

-

Indica todos los servicios PROFIenergy soportados.

ARRAY[1..24] OF
BYTE

-

Datos definidos por el usuario

PE_TASK

-

Procesamiento de la petición

Programación del PLC
Manual de programación y manejo, 11/2019

2579

Instrucciones
4.1 Instrucciones
Nombre

Tipo de datos

Offset

Comentario

Cmd

BYTE

-

Bits internos para el procesamiento de la petición

CmdJ

BYTE

-

Bits internos para el procesamiento de la petición

TimeStart

BOOL

-

Inicia un tiempo de retardo.

TimeStarted

BOOL

-

Acaba de iniciarse un tiempo de retardo.

TimeDone

BOOL

-

Indica la finalización del tiempo de retardo.

Done

BOOL

-

Indica que la petición está finalizándose.

DelayedCmd

BOOL

-

Indica que todavía hay pendiente un comando retardado.

IsV1_0

BOOL

-

Indica que este dispositivo es un dispositivo Spec. V1.0.

IsWakeOnLAN

BOOL

-

Indica que este dispositivo se activa por "Wake On LAN".

RetryCount

BYTE

-

Contador de repeticiones de PE_COMMANDS

Duration

TIME

-

Contiene el valor de retardo en ms.

StartTime

TIME

-

Contiene el punto de inicio del tiempo de retardo.

MachineState

INT

-

Contiene el estado interno de la petición.

(1)

Ajuste por parte del usuario.

(2)

Uso libre para el usuario.

Parámetro STATUS
Parámetro STATUS
El valor de salida del parámetro STATUS se divide en tres áreas:
● Bits 31 a 24: MESSAGE
● Bits 23 a 16: LOCATION
● Bits 15 a 0: INFORMATION
En las siguientes tablas se explica el significado de los diferentes códigos de error de las tres
áreas:
Tabla 4-30

Valores posibles de MESSAGE

Código de
error
(W#16#...)

Descripción

00

Ningún error.

50

Instrucción inicializada.

51

Se determina la configuración del sistema PROFINET I/O.

52

La instrucción no ha podido localizar dispositivos configurados en el sistema PROFINET I/O.

53

Se determinan las direcciones lógicas de los dispositivos configurados.

54

Se lee la información de interfaz de los dispositivos.

55

Se determinan los datos I&M (solo registro 0) de los dispositivos configurados.

56

Se configura la interfaz PROFINET para el envío de "Wake on LAN" MagicPaket™ a través de UDP.

57

Se determina la compatibilidad PROFIenergy de los dispositivos conectados.

62

Detectada ID no válida del sistema PROFINET I/O. El número causante se indica en el campo INFORMA‐
TION.

2580

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error
(W#16#...)

Descripción

70

La instrucción se ha inicializado y procesa peticiones. El valor del campo INFORMATION indica el número
de las peticiones activas actualmente.

80

La instrucción se ha desinicializado al procesar peticiones. Esto ocurre generalmente cuando vuelve a
cargarse el DB de instancia o bien el DB de usuario.

FF

Se ha producido un error desconocido.

Tabla 4-31

Valores posibles de LOCATION

Código de
error
(W#16#...)

Descripción

00

La instrucción no se ha inicializado o bien está inactiva.

70

La instrucción está esperando peticiones.

71

La instrucción introduce una petición en la lista de peticiones.

72

La instrucción prepara el envío de una petición.

73

La instrucción envía una petición a un dispositivo.

74

La instrucción espera la respuesta del dispositivo.

75

La instrucción evalúa la respuesta del dispositivo.

76

La instrucción elimina la petición de la lista de peticiones.

FF

Se ha producido un error desconocido.

Tabla 4-32

Valores posibles de INFORMATION

Código de
error
(W#16#...)

Descripción

0000

No hay información adicional disponible ni peticiones activas.

0001 -00FF

Actualmente se procesan 1 – 255 peticiones.

7000

Reinicialización iniciada con COM_RST, pero todavía no ejecutada por completo.

8001

Error en el 1.er parámetro

8002

Error en el 2.º parámetro

8003

Error en el 3.er parámetro

8004

Error en el 4.º parámetro

8005

Error en el 5.º parámetro Este error se indica si no hay ninguna interconexión con el DB de usuario o bien
hay una no válida.
Causas posibles:
● El DB de usuario es demasiado pequeño.
● El DB de usuario está protegido contra escritura.
● El DB de usuario no está disponible en la RAM.
● El DB de usuario no es válido para la CPU utilizada.

Programación del PLC
Manual de programación y manejo, 11/2019

2581

Instrucciones
4.1 Instrucciones
Código de
error
(W#16#...)
8085 a 80CE

Descripción

Error al establecer la conexión. Se emiten los mensajes de error de la instrucción de uso interno TCON.
Encontrará la descripción de los mensajes de error en la tabla correspondiente al parámetro STATUS
(Página 4048).

8100

Se han intentado posicionar más de las 256 peticiones posibles. Se trata de un error temporal que se
soluciona con la finalización de algunas peticiones. La petición que se ha intentado posicionar no ha sido
aceptada y debe volver a posicionarse.

8200

Se ha intentado enviar un comando PROFIenergy no válido o no soportado (PE_COMMAND).

8400

ID de conexión fuera del área admisible. Se ha cancelado la inicialización.
Compruebe la ID de la configuración de conexiones para "Wake on LAN". Ver el bloque de datos en el
parámetro PENERGY > Header > Connection > ID.

84xx

Se ha producido un error de comunicación. El número del dispositivo que ha provocado el error se indica en
"xx".

85xx

El dispositivo xx ha notificado un error. El número del dispositivo que ha provocado el error se indica en "xx".

8600

Actualmente no se soporta el método de WakeUp solicitado.

FFFF

Se ha producido un error desconocido.

Consulte también
Parámetro PENERGY (Página 2575)

Comandos PROFIenergy
Formato de los telegramas de respuesta
Estructura del telegrama de respuesta según el perfil PROFIenergy
La tabla siguiente muestra la estructura básica del telegrama de respuesta según el perfil
PROFIenergy. El telegrama de respuesta consta de una parte general (Header) y una parte
específica (Service Data Response). El contenido de la parte específica del telegrama de
respuesta se encuentra en la descripción del comando PROFIenergy correspondiente.
Definición de blo‐
que

Atributos

Valor

Tipo de datos

BlockHeader

BlockType

801 hex

WORD

BlockLength

2582

WORD

BlockVersionHigh

1 hex

BYTE

BlockVersionLow

0 hex

BYTE

Descripción

Número de bytes sin incluir los campos
BlockType y BlockLength.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Definición de blo‐
que

Atributos

Valor

Tipo de datos

Response Header

Service_Request_ID

1de hex a FF hex BYTE

Descripción
ID del comando PE ejecutado. La ID del co‐
mando PE procesado por la unidad PE se
devuelve en el telegrama de respuesta:
● 01: Start_Pause
● 02: End_Pause
● 03: Query_Modes
● 04: PEM_Status
● 05: PE_Identify
● de 06 a 09: Reservado
● 16: Query_Measurement
● de 11 a CF: Reservado
● de D0 a FF: Específico de fabricante

Service Header
Response

Request_Reference

1de hex a FF hex BYTE

Número unívoco de identificación del par
consulta-respuesta (lo devuelve el servidor
en la respuesta).

Status

1de hex a FF hex BYTE

Información acerca de si se ha ejecutado el
comando PE:
● 00: Reservado
● 01: Finalizado
● 02: Finalizado con error
● 03: Datos incompletos
● de 04 a CF: Reservado
● de D0 a FF: En función de la
Service_Request_ID

Data_Structure_
Identifier_RS

1de hex a FF hex BYTE

● 00: Reservado
● de 01 a FF: Estructura de datos en
función de Service_Request_ID
● 0xFF - Error

Service Data Res‐
ponse

En función de Service-Request-ID:
● Sobre las Service-Request-IDs,
consulte los parámetros CMD y
CMD_MODIFIER de la instrucción
"PE_CMD (Página 2563)".
● El contenido específico del telegrama de
respuesta se encuentra en la
descripción del comando PE
correspondiente (véase p. ej. el
comando "Start_Pause (Página 2584)").

Programación del PLC
Manual de programación y manejo, 11/2019

2583

Instrucciones
4.1 Instrucciones

Comando PE "Start_Pause"
Descripción
El comando PE "Start_Pause" inicia el modo de ahorro de energía. El comando Start_Pause
puede utilizarse para:
● Conmutar la unidad PE desde el estado "Listo para el funcionamiento"
(PE_ready_to_operate) a un modo de ahorro de energía (PE_energy_saving_mode).
● Conmutar la unidad PE de un modo de ahorro de energía a otro.
El consumo de energía puede aumentar o disminuir al cambiar el modo de ahorro de
energía.

Llamada del comando PE "Start_Pause"
La llamada del comando "Start_Pause" con la instrucción "PE_CMD (Página 2563)" se realiza
con los parámetros siguientes:
Parámetros

Valor

Descripción

CMD

1

Llamada del comando PE "Start_Pause".

CMD_MODIFIER

0

Para el comando "Start_Pause" no hay más especificaciones
respecto a la llamada.

CMD_PARA_LEN

4

Longitud del parámetro CMD_PARA de 4 bytes.

CMD_PARA

VARIANT

Puntero VARIANT al valor correspondiente a "Pause_Time"
(TIME).

Telegrama de respuesta (Service Data Response)
Los datos siguientes del telegrama de respuesta de la unidad PE se escriben en el bloque de
datos referenciado en el parámetro RESPONSE_DATA (véase la instrucción "PE_CMD
(Página 2563)"):
Atributo

Valor

Tipo de datos

Descripción

PE_Mode_ID

de 1 a 255

BYTE

Número de identificación del modo de aho‐
rro de energía

Reservado

0

BYTE

-

Comando PE "End_Pause"
Descripción
El comando PE "End_Pause" finaliza el modo de ahorro de energía en la unidad PE.

2584

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Llamada al comando PE "End_Pause"
La llamada del comando "End_Pause" con la instrucción "PE_CMD (Página 2563)" se realiza
con los parámetros siguientes:
Parámetros

Valor

Descripción

CMD

2

Llamada del comando PE "End_Pause".

CMD_MODIFIER

0

Para el comando "End_Pause" no hay más especificaciones
respecto a la llamada.

CMD_PARA_LEN

0

Longitud del parámetro CMD_PARA de 0 bytes.

CMD_PARA

irrelevante

-

Telegrama de respuesta (Service Data Response)
Los datos siguientes del telegrama de respuesta de la unidad PE se escriben en el bloque de
datos referenciado en el parámetro RESPONSE_DATA (véase "PE_CMD (Página 2563)"):
Atributo

Valor

Tipo de datos

Descripción

Time_to_operate

-

DWORD

Tiempo de espera para pasar al modo
"PE_ready_to_operate"

Comando PE "Query_modes" - "List_Energy_Saving_Modes"
Descripción
Con el comando PE "Query_modes" y el subcomando (Modifier) "List_Energy_Saving_Modes"
se indican todos los modos de ahorro de energía (PE_Mode_ID) soportados por la unidad PE.
El resultado de la consulta se escribe en forma de telegrama de respuesta en el bloque de
datos referenciado en el parámetro RESPONSE_DATA.

Llamada del comando PE "Query_modes" - "List_Energy_Saving_Modes"
La llamada del comando "List_Energy_Saving_Modes" con la instrucción "PE_CMD
(Página 2563)" se realiza con los parámetros siguientes:
Parámetro

Valor

Descripción

CMD

3

Llamada del comando PE "Query_modes".

CMD_MODIFIER

1

Especificación de la llamada del comando: seleccionar el sub‐
comando "List_Energy_Saving_Modes" para mostrar el núme‐
ro y los tipos de modos de ahorro de energía soportados.

CMD_PARA_LEN

0

Longitud del parámetro CMD_PARA de 0 bytes.

CMD_PARA

irrelevante

-

Programación del PLC
Manual de programación y manejo, 11/2019

2585

Instrucciones
4.1 Instrucciones

Telegrama de respuesta (Service Data Response)
Los datos siguientes del telegrama de respuesta de la unidad PE se escriben en el bloque de
datos referenciado en el parámetro RESPONSE_DATA (véase "PE_CMD (Página 2563)"):
Atributo

Valor

Tipo de datos

Descripción

Number_of_PE_
Mode_IDs

1

BYTE

La cantidad de modos de ahorro de energía.

PE_Mode_IDs

-

Array [...] of
BYTE

Matriz con las IDs de los modos de ahorro
de energía soportados. El significado de las
distintas IDs depende de la unidad PE.

Comando PE "Query_modes" - "Get_Mode"
Descripción
Con el comando PE "Query_modes" y el subcomando (Modifier) "Get_Mode" se indican los
atributos para el modo de ahorro de energía activado actualmente.

Llamada del comando PE "Query_modes" - "Get_Mode"
La llamada del comando con la instrucción "PE_CMD" se realiza con los siguientes parámetros:
Parámetro

Valor

Descripción

CMD

3

Llamada del comando PE "Query_modes"

CMD_MODIFIER

2

Especificación de la llamada del comando: Seleccionar el subcomando "Get_Mode"
para mostrar el estado del modo activado en el momento actual.

CMD_PARA_LEN

1

Longitud del parámetro CMD_PARA de 1 byte

CMD_PARA

VARIANT

Puntero VARIANT hacia el valor correspondiente a PE_MODE_ID

2586

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Telegrama de respuesta (Service Data Response)
Los datos siguientes del telegrama de respuesta de la unidad PE se escriben en el bloque de
datos referenciado en el parámetro RESPONSE_DATA (véase "PE_CMD (Página 2563)"):
Atributo

Valor

Tipo de datos

Descripción

PE_Mode_ID

● 0
Modo "PE_power_off"

BYTE

ID del modo de ahorro de energía activo
en el momento actual

● 1...254
Modo de ahorro de energía de la
unidad PE (específico de
fabricante)
● 255
Modo "PE_ready_to_operate"
PE_Mode_Attributes

Bit 0:

BYTE

● = 0: Solo están disponibles los
valores estáticos de consumo de
energía y de tiempo.
● = 1: Están disponibles los valores
dinámicos de consumo de energía
y de tiempo.
Bits de 1 a 7:
● Reservado
Time_min_Pause 1

Diferencia de tiempo sin fecha

DWORD

Tiempo mínimo de pausa para el modo
PE. El tiempo mínimo de pausa es la suma
de los valores de los siguientes atributos:
● Time_to_Pause
● Time_to_operate
● Time_min_length_of_stay
Véase la descripción de "Parámetro PAU‐
SE_TIME" de la instrucción
"PE_START_END: Iniciar y finalizar modo
de ahorro de energía (Página 2558)".

Time_to_Pause 1

Diferencia de tiempo sin fecha

DWORD

Tiempo de desconexión: Tiempo transcu‐
rrido desde la llamada del modo de ahorro
de energía hasta el inicio de este (tiempo
de transición de PE_ready_to_operate a
PE_energy_saving_mode). El tiempo de
desconexión depende de la unidad PE.

Time_to_operate 1

Diferencia de tiempo sin fecha

DWORD

Tiempo de conexión: Duración de la tran‐
sición del modo de ahorro de energía
(PE_energy_saving_mode) al modo de
disponibilidad (PE_ready_to_operate).
La duración es calculada dinámicamente
por la unidad PE en el momento de la sa‐
lida.

Time_min_length_
of_stay 1

DWORD

Duración mínima del modo de ahorro de
energía en la unidad PE

Time_max_length_
of_stay 1

DWORD

Duración máxima del modo de ahorro de
energía en la unidad PE

Programación del PLC
Manual de programación y manejo, 11/2019

2587

Instrucciones
4.1 Instrucciones
Atributo

Tipo de datos

Descripción

Mode_Power_
Consumption 2

Valor

REAL

Consumo de corriente de la unidad PE con
el modo de ahorro de energía activado

Energy_
Consumption_
to_pause 2

REAL

Consumo de energía de la unidad PE du‐
rante la transición del modo de disponibili‐
dad (PE_ready_to_operate) al modo de
ahorro de energía (PE_energy_sa‐
ving_mode)

Energy_
Consumption_
to_operate 2

REAL

Consumo de energía de la unidad PE du‐
rante la transición del modo de ahorro de
energía (PE_energy_saving_mode) al mo‐
do de disponibilidad (PE_ready_to_opera‐
te)

Unidad: kW

Unidad: kWh

Unidad: kWh
1

Si la duración es infinita, se devuelve el valor 0xFFFFFFFF. Si la duración es cero, se devuelve "0".

2

Si los datos de energía y consumo de corriente de la unidad PE no están definidos, se devuelve "0,0".

Comando PE "PEM_Status"
Descripción
Con el comando "PEM_Status" se consulta el estado de un modo de ahorro de energía
activado en el momento actual en una unidad PE.

Llamada al comando PE "PEM_Status"
La llamada del comando "PEM_Status" con la instrucción "PE_CMD" se realiza con los
parámetros siguientes:
Parámetros

Valor

Descripción

CMD

4

Llamada del comando PE "PEM_Status".

CMD_MODIFIER

0

Para el comando "PEM_Status" no hay más especificaciones respecto a la
llamada.

CMD_PARA_LEN

0

Longitud del parámetro CMD_PARA de 0 bytes.

CMD_PARA

irrelevante

-

2588

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Telegrama de respuesta (Service Data Response)
Los datos siguientes del telegrama de respuesta de la unidad PE se escriben en el bloque de
datos referenciado en el parámetro RESPONSE_DATA (véase "PE_CMD (Página 2563)"):
Atributo

Valor

Tipo de datos

Descripción

PE_Mode_ID_
Source

● 0
Modo "PE_power_off"

BYTE

Modo en el que se encuentra la unidad PE
antes de emitirse un comando PE.

BYTE

Modo en el que se encuentra la unidad PE
después de ejecutarse un comando PE.

DWORD

Tiempo de conexión: Duración de la tran‐
sición del modo de ahorro de energía
(PE_energy_saving_mode) al modo de
disponibilidad (PE_ready_to_operate).

● de 1 a 254
Modo de ahorro de energía de la
unidad PE (específico de
fabricante)
● 255
Modo "PE_ready_to_operate"
PE_Mode_ID_
Destination

● 0
Modo "PE_power_off"
● de 1 a 254
Modo de ahorro de energía de la
unidad PE (específico de
fabricante)
● 255
Modo "PE_ready_to_operate"

Time_to_operate

Diferencia de tiempo sin fecha.

La duración es calculada dinámicamente
por la unidad PE en el momento de la sa‐
lida.
Remaining_time_to_
destination

Diferencia de tiempo sin fecha.

DWORD

Tiempo restante para el paso al otro mo‐
do.

Mode_Power_
Consumption

REAL

Consumo de corriente de la unidad PE
con el modo de ahorro de energía activa‐
do.

Energy_
Consumption_
to_Destination

REAL

Consumo de energía para la transición
PE momentánea

Energy_
Consumption_
to_operate

REAL

Unidad: kW

Unidad: kWh
Consumo de energía de la unidad PE du‐
rante la transición del modo de ahorro de
energía (PE_energy-saving mode) al mo‐
do de disponibilidad (PE_ready_to_opera‐
te)
Unidad: kWh

Programación del PLC
Manual de programación y manejo, 11/2019

2589

Instrucciones
4.1 Instrucciones

Comando PE "PE_Identify"
Descripción
Con el comando PE "PE_Identify" se leen el número y la descripción de los comandos PE
soportados por la unidad PE. El tipo y la cantidad de comandos que se soporten dependen de
la unidad PE. Dado que el propio PE_Identify es un comando PE, en caso de respuesta
positiva se muestran por lo menos tres comandos PE soportados: Start_Pause, End_Pause y
PE_Identify.

Llamada al comando PE "PE_Identify"
La llamada del comando "PE_Identify" con la instrucción "PE_CMD (Página 2563)" se realiza
con los parámetros siguientes:
Parámetros

Valor

Descripción

CMD

5

Llamada del comando "PE_Identify".

CMD_MODIFIER

0

Para el comando "PE_Identify" no hay más especificaciones respecto a la
llamada.

CMD_PARA_LEN

0

Longitud del parámetro CMD_PARA de 0 bytes.

CMD_PARA

irrelevante

-

Telegrama de respuesta (Service Data Response)
Los datos siguientes del telegrama de respuesta de la unidad PE se escriben en el bloque de
datos referenciado en el parámetro RESPONSE_DATA (véase "PE_CMD (Página 2563)"):
Atributo

Valor

Tipo de datos

Descripción

Count 1

6

BYTE

Número de comandos PROFIenergy soportados

Start_Pause

1

BYTE

Primer comando PE (Service_Request_ID) soportado

End_Pause

2

BYTE

...

Query_Modes

3

BYTE

...

PEM_Status

4

BYTE

...

PE_Identify

5

BYTE

...

Query_Measurement

16

BYTE

Último comando PE (Service_Request_ID) soportado

El número de comandos soportados es específico del fabricante y depende de la unidad PE utilizada. Si se soportan los 6
comandos PE, los valores indicados son un ejemplo de telegrama de respuesta.

1

2590

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Comando PE "Query_Measurement" - "Get_Measurement_list"
Descripción
Con el comando PE "Query_Measurement" y el subcomando (Modifier)
"Get_measurement_list" se consultan los valores medidos que soporta la unidad PE. Los
valores medidos soportados se guardan en forma de lista en el bloque de datos referenciado
en el parámetro RESPONSE_DATA.

Llamada del comando PE "Query_Measurement" - "Get_Measurement_list"
La llamada del comando con la instrucción "PE_CMD (Página 2563)" se realiza con los
parámetros siguientes:
Parámetros

Valor

Descripción

CMD

16

Llamada del comando "Query_Measurement"

CMD_MODIFIER

1

Especificación de la llamada del comando: seleccionar el subcomando "Get_Mea‐
surement_List" para mostrar una lista de los valores medidos soportados.

CMD_PARA_LEN

0

Longitud del parámetro CMD_PARA de 0 bytes.

CMD_PARA

irrelevante

-

Telegrama de respuesta (Service Data Response)
Los datos siguientes del telegrama de respuesta de la unidad PE se escriben en el bloque de
datos referenciado en el parámetro RESPONSE_DATA (véase "PE_CMD (Página 2563)"):
Atributo

Valor

Tipo de datos

Descripción

Count

-

BYTE

Número de Measurement-IDs

reserved

-

BYTE

Measurement_ID

-

WORD

Primer Measurement_ID soportado. El Measurement_ID es especí‐
fico de fabricante. Encontrará más información en el manual de la
unidad PE en cuestión.

Accuracy_Domain

-

BYTE

Ver la tabla "Rangos de precisión".

Accuracy_Class

-

BYTE

Ver las tablas "Clases de precisión".

Range

-

REAL

Especifica el valor de fin de escala para el valor medido (solo con
rango de precisión 1). El atributo Range utiliza la misma unidad que
se haya definido con el atributo Measurement_ID (para cada Mea‐
surement_ID se utiliza solo una unidad).

Measurement_ID

-

WORD

Último Measurement_ID soportado

Accuracy_Domain

-

BYTE

Consulte la tabla "Rangos de precisión".

Accuracy_Class

-

BYTE

Consulte las tablas "Clases de precisión".

Range

-

REAL

Especifica el valor de fin de escala para el valor medido (solo con
rango de precisión 1). El atributo Range utiliza la misma unidad que
se haya definido con el atributo Measurement_ID (para cada Mea‐
surement_ID se utiliza solo una unidad).

...

...

Programación del PLC
Manual de programación y manejo, 11/2019

2591

Instrucciones
4.1 Instrucciones

Rangos de precisión
Rango de precisión

Descripción

0

Reservado

1

La desviación de precisión se expresa en porcentaje del valor de final de escala. El porcentaje de
desviación posible se divide en clases de precisión (ver tabla: Clases de precisión de los rangos de
precisión 1 y 2).

2

La desviación de precisión se expresa en porcentaje del valor medido real. El porcentaje de desvia‐
ción posible se divide en clases de precisión (ver tabla: Clases de precisión de los rangos de precisión
1 y 2).

3

La precisión de medida se define según la norma IEC 61557-12.
Las clases de potencia de funcionamiento para dispositivos de medición de potencia y supervisión
(PMD) sin sensores externos y las clases de potencia del sistema para PMD con sensores externos
están codificadas conforme a la tabla "Clases de precisión del rango de precisión 3".

4

La precisión se expresa de acuerdo con la norma EN 50470-3, capítulo 8 (ver también la tabla: Clases
de precisión del rango de precisión 4).

Clases de precisión
Tabla 4-33

Clases de precisión de los rangos de precisión 1 y 2

Clase de precisión
Significado

Clase de precisión
Significado

Tabla 4-34
Significado

Clase de precisión
Significado

2592

2

3

4

5

6

7

8

0,02%

0,05%

0,1%

0,2%

0,5%

1%

1,5%

9

10

11

12

13

14

15

>15

2%

2,5%

3%

5%

10%

20%

>20%

No definido

0

1

2

3

4

5

6

7

8

Reserva‐
do

0,02

0,05

0,1

0,2

0,5

1

1,5

2

9

10

11

12

13

14

>13

2,5

3

5

10

20

20%

No definido

Clases de precisión del rango de precisión 4

Clase de precisión
Significado

1
0,01%

Clases de precisión del rango de precisión 3

Clase de precisión

Tabla 4-35

0
Reserva‐
do

0

1

2

3

4

5

6

>7

Reserva‐
do

0,5

1,0

1,5

2,0

2,5

3,0

No definido

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Comando PE "Query_Measurement" - "Get_Measurement_values"
Descripción
Con el comando PE "Query_Measurement" y el subcomando (Modifier)
"Get_measurement_values" se indican los valores medidos soportados por la unidad PE. Los
valores medidos se guardan en forma de lista en el bloque de datos referenciado en el
parámetro RESPONSE_DATA.

Llamada del comando PE "Query_Measurement" - "Get_Measurement_values"
La llamada del comando con la instrucción "PE_CMD (Página 2563)" se realiza con los
parámetros siguientes:
Parámetros

Valor

Descripción

CMD

16

Llamada del comando "Query_Measurement"

CMD_MODIFIER

2

Especificación de la llamada del comando: Seleccionar el comando "Get_Measu‐
rement_Values" para mostrar una lista de los valores medidos soportados.

CMD_PARA_LEN

0

En función del número de valores medidos. La longitud del parámetro se obtiene
a partir del atributo count y la suma de las longitudes de los atributos de los valores
medidos transferidos.

CMD_PARA

VARIANT

Puntero VARIANT hacia la estructura de datos con listado de los valores medidos
que deben consultarse (véase "Parámetro CMD_PARA").

Parámetro CMD_PARA
La estructura que se indica mediante el puntero VARIANT en el parámetro CMD_PARA debe
tener la estructura siguiente:
Atributo

Valor

Tipo de datos

Descripción

Count

-

BYTE

Número de valores medidos (Measurement-IDs)

reserved

0

BYTE

Sin utilizar

Measurement_ID

-

WORD

Primer valor medido consultado

-

WORD

Último valor medido consultado

...
Measurement_ID

Telegrama de respuesta (Service Data Response)
Los datos siguientes del telegrama de respuesta de la unidad PE se escriben en el bloque de
datos referenciado en el parámetro RESPONSE_DATA (véase "PE_CMD (Página 2563)"):
Atributo

Valor

Tipo de datos

Descripción

Count

-

BYTE

Número de valores medidos (Measurement-IDs)

reserved

0

BYTE

Sin utilizar

Length_of_Structure

de 2 a 65535

WORD

Longitud de la estructura en bytes.

1

Programación del PLC
Manual de programación y manejo, 11/2019

2593

Instrucciones
4.1 Instrucciones
Atributo

Valor

Measurement_Da‐
ta_Structure_ID

1 = simple value BYTE

Tipo de datos

Descripción
Define la siguiente estructura.

Measurement_ID

de 0 a 65535

WORD

ID del valor medido soportado.

Status_of_
Measurement_Value

de 1 a 3

BYTE

Estado del valor medido:
● 1: Válido
● 2: No soportado
● 3: No válido

Transmission_Da‐
ta_Type

-

REAL

End_of_demand

-

TOD

Sellado de tiempo opcional con el tipo de datos TimeOfDay.

Length_of_Structure

-

WORD

Longitud de la estructura en bytes.

Measurement_Da‐
ta_Structure_ID

-

BYTE

Define la siguiente estructura.

Measurement_ID

-

WORD

ID del valor medido soportado.

Status_of_Measure‐
ment_Value

-

BYTE

Estado del valor medido:

...

● 1: Válido
● 2: No soportado
● 3: No válido

Transmission_Da‐
ta_Type

-

REAL

End_of_demand

-

TOD

Sellado de tiempo opcional con el tipo de datos TimeOfDay.

Si la longitud de datos de los valores medidos consultados supera el tamaño de la PDU (Protocol Data Unit) del nivel de
protocolo, los datos se transfieren de modo incompleto y solo se devuelven los valores medidos soportados.
1

iDevice / iSlave
PE_I_DEV: Forzar comandos PROFIenergy en el iDevice
Descripción
La instrucción "PE_I_DEV" se utiliza para desarrollar el perfil PROFIenergy en el dispositivo IO
inteligente (iDevice).
● el programa de usuario del iDevice llama cíclicamente la instrucción "PE_I_DEV", que
recibe todos los comandos PROFIenergy;
● la respuesta de PROFIenergy es generada por parametrización de un bloque auxiliar. La
reacción en la pausa puede programarse libremente. Los datos de respuesta deben
prepararse en 10 segundos, pues en caso contrario en el parámetro STATUS de la
instrucción del controlador IO aparece "Stateconflict 0x80B5".
Nota: Las funciones son realizadas por el firmware en un dispositivo IO normal compatible con
PROFIenergy, p. ej. el ET 200S.
Para utilizar la instrucción no se requieren conocimientos explícitos del estándar
PROFIenergy.

2594

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Bloques auxiliares PROFIenergy (bloques auxiliares PE)
Con los bloques auxiliares PE se genera el telegrama de respuesta. Para ello, indique los datos
de respuesta (en texto explícito) en los parámetros de entrada del bloque correspondiente.
● Para cada comando PROFIenergy hay un bloque auxiliar correspondiente a una respuesta
positiva:
– comando PE "Start_Pause": PE_Start_RSP (Página 2599)
– comando PE "End_Pause": PE_End_RSP (Página 2601)
– comando PE "Query_modes" - "List_Energy_Saving_Modes": PE_List_Modes_RSP
(Página 2602)
– comando PE "Query_modes" - "Get_Mode": PE_Get_Mode_RSP (Página 2603)
– comando PE "PEM_Status": PE_PEM_Status_RSP (Página 2605)
– comando PE "PE_Identify": PE_Identify_RSP (Página 2607)
– comando PE "Query_Measurement" "Get_Measurement_list": PE_Measurement_List_RSP (Página 2609)
– comando PE "Query_Measurement" "Get_Measurement_values": PE_Measurement_Value_RSP (Página 2610)
● Con independencia del comando PROFIenergy utilizado, además hay un bloque auxiliar
común para una respuesta negativa (véase PE_Error_RSP (Página 2598)).

Interconexión de los bloques auxiliares
La instrucción "PE_I_DEV" y los bloques auxiliares están adaptados mutuamente. Los
parámetros se interconectan en parte de manera sencilla. El gráfico siguiente muestra qué
parámetros deben interconectarse.

3(B,B'(9
,1,'

,13DU£PHWURV
HVSHF¯ILFRVGH&0'

,15(6(7
(YDOXDFLµQ\
UHDFFLµQGHO
XVXDULR

%ORTXHDX[LOLDU3(

287&0'

8VXDULR

287&0'B02',),(5
,Q2XW&0'B3$5$

287(5525

287,1'(;

28767$786
,Q2XW$&7,9$7(

287(5525

8VXDULR

28767$786
,19$/,'
2871(:
,Q2XW'$7$B(5525563
287&0'
287&0'B02',),(5

,Q2XW9$/,'
,13(B,B'(9B1(:
,Q2XW'$7$B(5525563
,1&0'
,1&0'B02',),(5

,QWHUFRQH[LµQLPSUHVFLQGLEOH

Programación del PLC
Manual de programación y manejo, 11/2019

2595

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "PE_I_DEV":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RESET

Input

BOOL

I, Q, M, D, L o cons‐
tante

Restablece la instrucción.

ID

Input

HW_SUBMO‐
DULE

I, Q, M, D, L o cons‐
tante

Dirección del área de transferencia que recibe
los datos para PROFIenergy en el controlador
IO.
El identificador de hardware se puede consul‐
tar en las constantes de sistema.

VALID

Input

BOOL

I, Q, M, D, L o cons‐
tante

CMD_PARA

Output

VARIANT

I, Q, M, D, L

Los datos de respuesta del controlador PRO‐
FIenergy están preparados y pueden enviarse.
Parámetros de:
● Get mode: PE_mode_ID
● Get measurement values: lista de
Measurement_ID (lista de ID de las
variables que deben leerse; es posible leer
una sola variable o varias a la vez).
Longitud máxima: 234 bytes
Nota: en S7-1200, el puntero no debe apuntar
a tipos de datos de 64 bits (es decir, a los tipos
de datos LWORD, LINT y ULINT).

DA‐
TA_ERRORR
SP

InOut

VARIANT

I, Q, M, D, L

Puntero al área de datos que contiene los da‐
tos de acuse del controlador PROFIenergy.
Debe coincidir con el puntero utilizado en los
bloques auxiliares.
Nota: en S7-1200, el puntero no debe apuntar
a tipos de datos de 64 bits (es decir, a los tipos
de datos LWORD, LINT y ULINT).

INDEX

Output

INT

I, Q, M, D, L

Número del juego de datos PROFIenergy
(0x80A0 fijo)

CMD

Output

INT

I, Q, M, D, L

Service-Request-ID del comando PROFIe‐
nergy en función del perfil PROFIenergy (véa‐
se "Parámetros CMD y CMD_MODIFIER").
Si se amplía el perfil PROFIenergy son posi‐
bles otros comandos PE (Service-RequestIDs).

CMD_
MODIFIER

Output

INT

I, Q, M, D, L

Subcomando PROFIenergy:
● solo con CMD=3 o CMD=16, véase
"Parámetros CMD y CMD_MODIFIER";
● en todos los demás comandos: "0".
Si se amplía el perfil PROFIenergy son posi‐
bles otros subcomandos.

NEW

Output

BOOL

I, Q, M, D, L

Nuevos datos disponibles para el controlador
PROFIenergy.

ERROR

Output

BOOL

I, Q, M, D, L

Comando finalizado con error.

STATUS

Output

DWORD

I, Q, M, D, L

Información de error (véase "Parámetro STA‐
TUS")

2596

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetros CMD y CMD_MODIFIER
CMD

CMD_
MODIFIER

Comando PROFIenergy

Descripción

01

0

Start_Pause

Inicia el modo de ahorro de energía o cambia a otro modo de
ahorro de energía.

02

0

End_Pause

Sale del modo de ahorro de energía.

03

1

Query_Modes - List energy sa‐ Muestra los modos de ahorro de energía soportados.
ving Modes

2

Query_Modes - Get Mode

Muestra los atributos del modo de ahorro de energía activa‐
do en el momento actual.

04

0

PEM_Status

Consulta el estado del modo de ahorro de energía.

05

0

PE_Identify

Lectura del número de comandos PE soportados y descrip‐
ción de los mismos.

16

1

Query_Measurement Get_Measurement_List

Listado de los valores medidos soportados por la unidad PE.

2

Query_Measurement Get_Measurement_Values

Muestra los valores medidos de la unidad PE.

Parámetro STATUS
En el parámetro de salida STATUS se muestra información de error. Si se interpreta como
ARRAY[1...4] of BYTE, la información de error tiene la estructura siguiente:
Elemento de cam‐
po

Nombre

Significado

STATUS[1]

Function_Num

Causa del error
● B#16#00: Ningún error
● B#16#DE: Error al leer el juego de datos
● B#16#DF: Error al escribir el juego de datos
● B#16#C0: mensaje de error de la instrucción "PE_I_DEV" o de las instrucciones
de comunicación de uso interno "PRVREC (Página 2524)" y "RCVREC
(Página 2514)".

STATUS[2]

Error_Decode

Ubicación de la identificación de error
● 80: Error DPV1 según la norma IEC 61158-6 o error específico de instrucción

STATUS[3]

Error_Code_1

Identificación del error (con Error_Decode = 80):
● B1: Write length error (error en la longitud de escritura o indicación de longitud
insuficiente mediante el tipo de datos VARIANT).

STATUS[4]

Error_Code_2

Programación del PLC
Manual de programación y manejo, 11/2019

Con error PROFINET: salida del mensaje de error del controlador IO. Si no se ha
producido ningún error PROFINET, el valor de STATUS[4] = "0".

2597

Instrucciones
4.1 Instrucciones

Nota
Mensajes de error de las instrucciones "PRVREC" y "RCVREC"
La instrucción "PE_I_DEV" utiliza para la comunicación las instrucciones "PRVREC
(Página 2524)" y "RCVREC (Página 2514)". Los mensajes de error de estas instrucciones se
emiten correspondientemente en los elementos de campo STATUS[1] a STATUS[4].
Encontrará el significado de los códigos de error de las instrucciones "PRVREC" y "RCVREC"
en la descripción del parámetro STATUS (Página 2447) correspondiente.

Consulte también
WRREC: Escribir registro (Página 2401)
RDREC: Leer registro (Página 2382)
Descripción de PROFIenergy (Página 2555)

Módulos auxiliares de la instrucción PE_I_DEV
PE_Error_RSP: Generación de respuesta negativa a comando
Descripción
El bloque auxiliar "PE_Error_RSP" (Response with failure) genera una respuesta negativa si el
comando solicitado no es soportado con carácter general o temporalmente. La respuesta se
genera con independencia del comando solicitado.

Parámetros
La tabla siguiente muestra los parámetros del bloque auxiliar "PE_Error_RSP":
Parámetro

Declaración

Tipo de datos

Área de memoria

PE_I_DEV_NEW

Input

BOOL

I, Q, M, D, L o cons‐ El parámetro debe estar interconectado con el
tante
parámetro de salida NEW de la instrucción
"PE_I_DEV (Página 2594)". Si el parámetro
tiene el valor "1", el bloque auxiliar se ejecuta.

ERROR_CODE

Input

BYTE

I, Q, M, D, L o cons‐ Número de error
tante

2598

Descripción

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ACTIVATE

InOut

BOOL

I, Q, M, D, L

Con un flanco ascendente en la entrada ACTI‐
VATE, esta instrucción copia los parámetros
de entrada en el área de datos DA‐
TA_ERROR_RSP. Después la instrucción res‐
tablece el parámetro.
El parámetro debe activarse en un tiempo de
10 segundos después de que en el parámetro
NEW de la instrucción "PE_I_DEV (Pági‐
na 2594)" se haya detectado un flanco ascen‐
dente.

VALID

InOut

BOOL

I, Q, M, D, L

El parámetro debe estar interconectado con la
entrada VALID de la instrucción "PE_I_DEV
(Página 2594)".
Cuando los datos de respuesta para el contro‐
lador PROFIenergy están disponibles y pue‐
den enviarse, el bloque auxiliar activa el pará‐
metro.

DATA_
ERRORRSP

InOut

VARIANT

D

ERROR

Output

BOOL

I, Q, M, D, L

Puntero hacia el área de datos en la que se
guardan los datos de respuesta. El parámetro
es idéntico al puntero de DATA_ERRORRSP
de la instrucción "PE_I_DEV (Página 2594)".
El área de datos direccionada contiene el tele‐
grama PROFIenergy completo.
Longitud mínima: 244 bytes
● "0": Ningún error
● "1": Con errores

STATUS

Output

WORD

I, Q, M, D, L

● "0": Ningún error
● "0x80B1": Error en la indicación de
VARIANT, p. ej. área errónea

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

PE_Start_RSP: Generar respuesta a comando para iniciar pausa
Descripción
El bloque auxiliar "PE_Start_RSP" (Iniciar pausa) genera la respuesta al comando
PE Start_Pause (Página 2584). La instrucción devuelve el estado de ahorro de energía que
adopta el dispositivo (parámetro PE_MODE_ID).
Si las reacciones a pausas de distinta duración son diferentes, se puede indicar en la
notificación mediante el estado de ahorro de energía adoptado (PE_Mode_ID = 1 para una
pausa corta, PE_Mode_ID = 2 para una pausa más larga, etc.).

Programación del PLC
Manual de programación y manejo, 11/2019

2599

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros del bloque auxiliar "PE_Start_RSP":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

PE_I_DEV_NE
W

Input

BOOL

I, Q, M, D, L o cons‐ El parámetro debe estar interconectado con el
tante
parámetro de salida NEW de la instrucción
"PE_I_DEV (Página 2594)". Si el parámetro
tiene el valor "1", el bloque auxiliar se ejecuta.

CMD

Input

INT

I, Q, M, D, L o cons‐ Service-Request-ID del comando PROFIe‐
tante
nergy
El parámetro debe estar interconectado con el
parámetro de salida CMD de la instrucción
"PE_I_DEV (Página 2594)".

PE_MODE_ID

Input

BYTE

I, Q, M, D, L o cons‐ Modo PE que adopta el proceso
tante

ACTIVATE

InOut

BOOL

I, Q, M, D, L

Con un flanco ascendente en la entrada ACTI‐
VATE, esta instrucción copia los parámetros
de entrada en el área de datos DA‐
TA_ERROR_RSP. Después la instrucción res‐
tablece el parámetro.
El parámetro debe activarse en un tiempo de
10 segundos después de que en el parámetro
NEW de la instrucción "PE_I_DEV (Pági‐
na 2594)" se haya detectado un flanco ascen‐
dente.

VALID

InOut

BOOL

I, Q, M, D, L

El parámetro debe estar interconectado con la
entrada VALID de la instrucción "PE_I_DEV
(Página 2594)".
Cuando los datos de respuesta para el contro‐
lador PROFIenergy están disponibles y pue‐
den enviarse, el bloque auxiliar activa el pará‐
metro.

DATA_
ERRORRSP

InOut

VARIANT

D

Puntero hacia el área de datos en la que se
guardan los datos de respuesta. El parámetro
es idéntico al puntero de DATA_ERRORRSP
de la instrucción "PE_I_DEV (Página 2594)".
El área de datos direccionada contiene el tele‐
grama PROFIenergy completo.
Longitud mínima: 244 bytes

ERROR

Output

BOOL

I, Q, M, D, L

● "0": Ningún error
● "1": Con errores

STATUS

Output

WORD

I, Q, M, D, L

● "0": Ningún error
● "0x80B1": Error en la indicación de
VARIANT, p. ej. área errónea

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

2600

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

PE_End_RSP: Generar respuesta a comando para final de pausa
Descripción
El bloque auxiliar "PE_End_RSP" genera la respuesta al comando PE End_Pause
(Página 2584). Para cambiar del estado operativo actual al estado operativo
"Ready_To_Operate", se devuelve como respuesta el tiempo necesario.

Parámetros
La tabla siguiente muestra los parámetros del bloque auxiliar "PE_End_RSP":
Parámetro

Declaración

Tipo de datos

Área de memo‐
ria

Descripción

PE_I_DEV_NEW

Input

BOOL

I, Q, M, D, L o
constante

El parámetro debe estar interconectado con el
parámetro de salida NEW de la instrucción
"PE_I_DEV (Página 2594)". Si el parámetro
tiene el valor "1", el bloque auxiliar se ejecuta.

CMD

Input

INT

I, Q, M, D, L o
constante

Service-Request-ID del comando PROFIe‐
nergy
El parámetro debe estar interconectado con el
parámetro de salida CMD de la instrucción
"PE_I_DEV (Página 2594)".

Time_to_Operate

Input

DWORD

I, Q, M, D, L o
constante

Tiempo para cambiar del estado operativo ac‐
tual a "Ready_To_Operate".

ACTIVATE

InOut

BOOL

I, Q, M, D, L

Con un flanco ascendente en la entrada ACTI‐
VATE, esta instrucción copia los parámetros
de entrada en el área de datos DA‐
TA_ERROR_RSP. Después la instrucción res‐
tablece el parámetro.
El parámetro debe activarse en un tiempo de
10 segundos después de que en el parámetro
NEW de la instrucción "PE_I_DEV (Pági‐
na 2594)" se haya detectado un flanco ascen‐
dente.

VALID

InOut

BOOL

I, Q, M, D, L

El parámetro debe estar interconectado con la
entrada VALID de la instrucción "PE_I_DEV
(Página 2594)".
Cuando los datos de respuesta para el contro‐
lador PROFIenergy están disponibles y pue‐
den enviarse, el bloque auxiliar activa el pará‐
metro.

DATA_
ERRORRSP

InOut

VARIANT

D

Puntero hacia el área de datos en la que se
guardan los datos de respuesta. El parámetro
es idéntico al puntero de DATA_ERRORRSP
de la instrucción "PE_I_DEV (Página 2594)".
El área de datos direccionada contiene el tele‐
grama PROFIenergy completo.
Longitud mínima: 244 bytes

Programación del PLC
Manual de programación y manejo, 11/2019

2601

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memo‐
ria

Descripción

ERROR

Output

BOOL

I, Q, M, D, L

● "0": Ningún error
● "1": Con errores

STATUS

Output

WORD

I, Q, M, D, L

● "0": Ningún error
● "0x80B1": Error en la indicación de
VARIANT, p. ej. área errónea

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

PE_List_Modes_RSP: Generar modos de ahorro de energía como respuesta
Descripción
El bloque auxiliar "PE_List_Modes_RSP" genera la respuesta al comando
PE List_Energy_Saving_Modes (Página 2585). La respuesta generada contiene el número de
los estados de ahorro de energía soportados y sus ID.

Parámetros
La tabla siguiente muestra los parámetros del bloque auxiliar "PE_List_Modes_RSP":
Parámetro

Declaración

Tipo de datos

Área de memoria

PE_I_DEV_NEW

Input

BOOL

I, Q, M, D, L o cons‐ El parámetro debe estar interconectado con el
tante
parámetro de salida NEW de la instrucción
"PE_I_DEV (Página 2594)". Si el parámetro tiene
el valor "1", el bloque auxiliar se ejecuta.

Descripción

CMD

Input

INT

I, Q, M, D, L o cons‐ Service-Request-ID del comando PROFIenergy
tante
El parámetro debe estar interconectado con el
parámetro de salida CMD de la instrucción
"PE_I_DEV (Página 2594)".

CMD_MODIFIER

Input

INT

I, Q, M, D, L o cons‐ Subcomando PROFIenergy (la evaluación solo
tante
tiene lugar si CMD=3 o CMD=16). El parámetro
debe estar interconectado con el parámetro de
salida CMD_MODIFIER de la instrucción
"PE_I_DEV".

Number_of_PE_
Mode_IDs

Input

BYTE

I, Q, M, D, L o cons‐ Número de estados de ahorro de energía sopor‐
tante
tados.

PE_MODE_ID

Input

VARIANT

I, Q, M, D, L

Valores permitidos: de 1 a 254
Señala el área en la que se guardan las ID de los
estados de ahorro de energía soportados
(PE_Mode_ID).
Área permitida: de 1 a 254.

2602

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ACTIVATE

InOut

BOOL

I, Q, M, D, L

Con un flanco ascendente en la entrada ACTI‐
VATE, esta instrucción copia los parámetros de
entrada en el área de datos DA‐
TA_ERROR_RSP. Después la instrucción resta‐
blece el parámetro.
El parámetro debe activarse en un tiempo de 10
segundos después de que en el parámetro NEW
de la instrucción "PE_I_DEV (Página 2594)" se
haya detectado un flanco ascendente.

VALID

InOut

BOOL

I, Q, M, D, L

El parámetro debe estar interconectado con la
entrada VALID de la instrucción "PE_I_DEV (Pá‐
gina 2594)".
Cuando los datos de respuesta para el controla‐
dor PROFIenergy están disponibles y pueden
enviarse, el bloque auxiliar activa el parámetro.

DATA_
ERRORRSP

InOut

VARIANT

D

Puntero hacia el área de datos en la que se guar‐
dan los datos de respuesta. El parámetro es
idéntico al puntero de DATA_ERRORRSP de la
instrucción "PE_I_DEV (Página 2594)". El área
de datos direccionada contiene el telegrama
PROFIenergy completo.
Longitud mínima: 244 bytes

ERROR

Output

BOOL

I, Q, M, D, L

● "0": Ningún error

STATUS

Output

WORD

I, Q, M, D, L

● "0": Ningún error

● "1": Con errores
● "0x80B1": Error en la indicación de
VARIANT, p. ej. área errónea

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

PE_Get_Mode_RSP: Generar respuesta con datos de energía consultados
Descripción
El bloque auxiliar "PE_Get_Mode_RSP" genera la respuesta al comando Get_Mode
(Página 2586). La respuesta contiene los tiempos y los datos de potencia o de energía de cada
estado de ahorro de energía concreto.

Programación del PLC
Manual de programación y manejo, 11/2019

2603

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros del bloque auxiliar "PE_Get_Mode_RSP":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

PE_I_DEV_NEW

Input

BOOL

I, Q, M, D, L o cons‐ El parámetro debe estar interconectado con el
tante
parámetro de salida NEW de la instrucción
"PE_I_DEV (Página 2594)". Si el parámetro
tiene el valor "1", el bloque auxiliar se ejecuta.

CMD

Input

INT

I, Q, M, D, L o cons‐ Service-Request-ID del comando PROFIe‐
tante
nergy
El parámetro debe estar interconectado con el
parámetro de salida CMD de la instrucción
"PE_I_DEV (Página 2594)".

CMD_MODIFIER

Input

INT

I, Q, M, D, L o cons‐ Subcomando PROFIenergy (la evaluación so‐
tante
lo tiene lugar si CMD=3 o CMD=16). El pará‐
metro debe estar interconectado con el pará‐
metro de salida CMD_MODIFIER de la instruc‐
ción "PE_I_DEV".

PE_Mode_ID

Input

BYTE

I, Q, M, D, L o cons‐ ID del modo de ahorro de energía activo en el
tante
momento actual.

PE_Mode_Attributes

Input

BYTE

I, Q, M, D, L o cons‐ Información adicional sobre el modo de ahorro
tante
de energía

Time_min_Pause

Input

DWORD

I, Q, M, D, L o cons‐ Duración mínima de pausa para este modo de
tante
ahorro de energía PE.
Está formada por la suma de tres parámetros:
● Time_to_Pause
● Time_to_operate
● Time_min_length_of_stay

Time_to_Pause

Input

DWORD

I, Q, M, D, L o cons‐ Duración desde el flanco en el parámetro
tante
START (véase "PE_I_DEV (Página 2594)")
hasta que se alcanza el modo de ahorro de
energía PE solicitado.

Time_to_Operate

Input

DWORD

I, Q, M, D, L o cons‐ Tiempo de conexión máximo hasta
tante
"PE_ready_to_operate". El parámetro "Ti‐
me_to_operate" puede utilizarse directamente
para los cálculos correspondientes. El valor
puede ser un valor máximo estático o bien pue‐
de calcularlo dinámicamente la unidad PE.

Time_min_Lenght_
of_stay

Input

DWORD

I, Q, M, D, L o cons‐ Tiempo mínimo durante el que la unidad PE
tante
debe permanecer en este modo PE.

Ti‐
me_max_Lenght_of_
stay

Input

DWORD

I, Q, M, D, L o cons‐ Tiempo máximo durante el que la unidad PE
tante
puede permanecer en este modo PE.

Mode_Power_
Consumption

Input

DWORD

I, Q, M, D, L o cons‐ Consumo de energía en el modo PE actual, en
tante
[kW].

Energy_Consum_
to_Pause

Input

DWORD

I, Q, M, D, L o cons‐ Consumo de energía desde
tante
"PE_ready_to_operate" hasta el modo PE ac‐
tual, en [kWh].

Energy_Consum_
to_operate

Input

DWORD

I, Q, M, D, L o cons‐ Consumo de energía desde el modo PE actual
tante
hasta "PE_ready_to_operate", en [kWh].

2604

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ACTIVATE

InOut

BOOL

I, Q, M, D, L

Con un flanco ascendente en la entrada ACTI‐
VATE, esta instrucción copia los parámetros
de entrada en el área de datos DA‐
TA_ERROR_RSP. Después la instrucción res‐
tablece el parámetro.
El parámetro debe activarse en un tiempo de
10 segundos después de que en el parámetro
NEW de la instrucción "PE_I_DEV (Pági‐
na 2594)" se haya detectado un flanco ascen‐
dente.

VALID

InOut

BOOL

I, Q, M, D, L

El parámetro debe estar interconectado con la
entrada VALID de la instrucción "PE_I_DEV
(Página 2594)".
Cuando los datos de respuesta para el contro‐
lador PROFIenergy están disponibles y pue‐
den enviarse, el bloque auxiliar activa el pará‐
metro.

DATA_
ERRORRSP

InOut

VARIANT

D

Puntero hacia el área de datos en la que se
guardan los datos de respuesta. El parámetro
es idéntico al puntero de DATA_ERRORRSP
de la instrucción "PE_I_DEV (Página 2594)". El
área de datos direccionada contiene el telegra‐
ma PROFIenergy completo.

ERROR

Output

BOOL

I, Q, M, D, L

● "0": Ningún error

Longitud mínima: 244 bytes
● "1": Se han producido errores
STATUS

Output

WORD

I, Q, M, D, L

● "0": Ningún error
● "0x80B1": Error en la indicación de
VARIANT, p. ej. área errónea

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

PE_PEM_Status_RSP: Generar respuesta con estado PEM
Descripción
El bloque auxiliar "PE_PEM_Status_RSP" genera la respuesta al comando PEM_Status
(Página 2588).

Programación del PLC
Manual de programación y manejo, 11/2019

2605

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros del bloque auxiliar "PE_PEM_Status_RSP":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

PE_I_DEV_NEW

Input

BOOL

I, Q, M, D, L o cons‐
tante

El parámetro debe estar interconectado con el
parámetro de salida NEW de la instrucción
"PE_I_DEV (Página 2594)". Si el parámetro tiene
el valor "1", el bloque auxiliar se ejecuta.

CMD

Input

INT

I, Q, M, D, L o cons‐
tante

Service-Request-ID del comando PROFIenergy
El parámetro debe estar interconectado con el
parámetro de salida CMD de la instrucción
"PE_I_DEV (Página 2594)".

PE_MODE_ID_
Source

Input

BYTE

I, Q, M, D, L o cons‐
tante

Source y Destination para PEM_STATUS.

PE_MODE_ID_
Destination

Input

BYTE

I, Q, M, D, L o cons‐
tante

● 0x00: PE_POWER_OFF

Valores:
● 0x01 – 0xFE: específico del fabricante
● 0xFF: PE_READY_TO_OPERATE

Time_to_Operate

1

Input

DWORD

I, Q, M, D, L o cons‐
tante

Tiempo de conexión máximo hasta
"PE_ready_to_operate".
"Time_to_operate" puede utilizarse directamente
para los cálculos correspondientes. El valor pue‐
de ser un valor máximo estático o bien puede
calcularlo dinámicamente la unidad PE.

Remaining_time_
to_destination1

Input

DWORD

I, Q, M, D, L o cons‐
tante

Opcionalmente: tiempo restante hasta el modo
PE solicitado. Valor dinámico o valor máximo es‐
tático

Mode_Power_
Consumption2

Input

DWORD

I, Q, M, D, L o cons‐
tante

Consumo de energía en el modo PE actual, en
[kW].

Energy_
Consumption_
to_Destination2

Input

DWORD

I, Q, M, D, L o cons‐
tante

Consumo de energía hasta el modo PE solicita‐
do, en [kW].

Energy_
Consumption_
to_operate2

Input

DWORD

I, Q, M, D, L o cons‐
tante

Consumo de energía desde el modo PE actual
hasta "PE_ready_to_operate", en [kWh].

ACTIVATE

InOut

BOOL

I, Q, M, D, L

Con un flanco ascendente en la entrada ACTI‐
VATE, esta instrucción copia los parámetros de
entrada en el área de datos DA‐
TA_ERROR_RSP. Después la instrucción resta‐
blece el parámetro.
El parámetro debe activarse en un tiempo de 10
segundos después de que en el parámetro NEW
de la instrucción "PE_I_DEV (Página 2594)" se
haya detectado un flanco ascendente.

VALID

InOut

BOOL

I, Q, M, D, L

El parámetro debe estar interconectado con la
entrada VALID de la instrucción "PE_I_DEV (Pá‐
gina 2594)".
Cuando los datos de respuesta para el controla‐
dor PROFIenergy están disponibles y pueden
enviarse, el bloque auxiliar activa el parámetro.

2606

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

DATA_
ERRORRSP

InOut

VARIANT

D

Puntero hacia el área de datos en la que se guar‐
dan los datos de respuesta. El parámetro es
idéntico al puntero de DATA_ERRORRSP de la
instrucción "PE_I_DEV (Página 2594)". El área
de datos direccionada contiene el telegrama
PROFIenergy completo.
Longitud mínima: 244 bytes

ERROR

Output

BOOL

I, Q, M, D, L

● "0": Ningún error
● "1": Con errores

STATUS

Output

WORD

I, Q, M, D, L

● "0": Ningún error
● "0x80B1": Error en la indicación de
VARIANT, p. ej. área errónea

1

Si la duración es ilimitada, puede indicarse el valor máximo "0xFFFFFFFF". Si la duración es "cero", puede utilizarse "0x00".

2

Si el consumo de energía no está definido, puede indicarse "0,0".

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

PE_Identify_RSP: Generar respuesta con comandos PROFIenergy soportados
Descripción
El bloque auxiliar "PE_Identify_RSP" genera la respuesta al comando PE_Identify
(Página 2590). En la respuesta al comando se indican los comandos PROFIenergy que se
soportan. Tenga en cuenta que PE_IDENTIFY es en sí mismo un comando PE y debe
indicarse correspondientemente en la respuesta.

Parámetros
La tabla siguiente muestra los parámetros del bloque auxiliar "PE_Identify_RSP":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

PE_I_DEV_NE
W

Input

BOOL

I, Q, M, D, L o cons‐
tante

El parámetro debe estar interconectado con el
parámetro de salida NEW de la instrucción
"PE_I_DEV (Página 2594)". Si el parámetro
tiene el valor "1", el bloque auxiliar se ejecuta.

CMD

Input

INT

I, Q, M, D, L o cons‐
tante

Service-Request-ID del comando PROFIe‐
nergy
El parámetro debe estar interconectado con el
parámetro de salida CMD de la instrucción
"PE_I_DEV (Página 2594)".

Programación del PLC
Manual de programación y manejo, 11/2019

2607

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

Start_Pause

Input

BOOL

I, Q, M, D, L o cons‐
tante

Un parámetro para cada comando PROFIe‐
nergy:

End_Pause

Input

BOOL

I, Q, M, D, L o cons‐
tante

● 0: este comando PE no se soporta

Query_Modes

Input

BOOL

I, Q, M, D, L o cons‐
tante

PEM_Status

Input

BOOL

I, Q, M, D, L o cons‐
tante

PE_Identify

Input

BOOL

I, Q, M, D, L o cons‐
tante

Query_
Measurement

Input

BOOL

I, Q, M, D, L o cons‐
tante

ACTIVATE

InOut

BOOL

I, Q, M, D, L

● 1: este comando PE se soporta

Con un flanco ascendente en la entrada ACTI‐
VATE, esta instrucción copia los parámetros
de entrada en el área de datos DA‐
TA_ERROR_RSP. Después la instrucción res‐
tablece el parámetro.
El parámetro debe activarse en un tiempo de
10 segundos después de que en el parámetro
NEW de la instrucción "PE_I_DEV (Pági‐
na 2594)" se haya detectado un flanco ascen‐
dente.

VALID

InOut

BOOL

I, Q, M, D, L

El parámetro debe estar interconectado con la
entrada VALID de la instrucción "PE_I_DEV
(Página 2594)".
Cuando los datos de respuesta para el contro‐
lador PROFIenergy están disponibles y pue‐
den enviarse, el bloque auxiliar activa el pará‐
metro.

DATA_
ERRORRSP

InOut

VARIANT

D

ERROR

Output

BOOL

I, Q, M, D, L

Puntero hacia el área de datos en la que se
guardan los datos de respuesta. El parámetro
es idéntico al puntero de DATA_ERRORRSP
de la instrucción "PE_I_DEV (Página 2594)".
El área de datos direccionada contiene el tele‐
grama PROFIenergy completo.
Longitud mínima: 244 bytes
● "0": Ningún error
● "1": Con errores

STATUS

Output

WORD

I, Q, M, D, L

● "0": Ningún error
● "0x80B1": Error en la indicación de
VARIANT, p. ej. área errónea

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

2608

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

PE_Measurement_List_RSP: Generar respuesta con lista de valores medidos soportados
Descripción
El bloque auxiliar "PE_Measurement_List_RSP" genera la respuesta al
comando Get_measurement_list (Página 2591). En la respuesta se indican los valores
medidos (Measurement-IDs) que se soportan.

Parámetros
La tabla siguiente muestra los parámetros del bloque auxiliar "PE_Measurement_List_RSP":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

PE_I_DEV_NE
W

Input

BOOL

I, Q, M, D, L o cons‐
tante

El parámetro debe estar interconectado con el
parámetro de salida NEW de la instrucción
"PE_I_DEV (Página 2594)". Si el parámetro
tiene el valor "1", el bloque auxiliar se ejecuta.

CMD

Input

INT

I, Q, M, D, L o cons‐
tante

Service-Request-ID del comando PROFIe‐
nergy
El parámetro debe estar interconectado con el
parámetro de salida CMD de la instrucción
"PE_I_DEV (Página 2594)".

CMD_MODI‐
FIER

Input

INT

I, Q, M, D, L o cons‐
tante

Subcomando PROFIenergy (la evaluación so‐
lo tiene lugar si CMD=3 o CMD=16). El pará‐
metro debe estar interconectado con el pará‐
metro de salida CMD_MODIFIER de la instruc‐
ción "PE_I_DEV".

Count

Input

BYTE

I, Q, M, D, L o cons‐
tante

Número de valores medidos soportados (Mea‐
surement-ID)

Measurement_
List

Input

VARIANT

D

Puntero hacia la matriz con las Measure‐
ment_ID soportadas.
Consulte la estructura de la matriz según el
perfil PROFIenergy en: Comando PE
"Query_Measurement" - "Get_Measure‐
ment_list" (Página 2591)

ACTIVATE

InOut

BOOL

I, Q, M, D, L

Con un flanco ascendente en la entrada ACTI‐
VATE, esta instrucción copia los parámetros
de entrada en el área de datos DA‐
TA_ERROR_RSP. Después la instrucción res‐
tablece el parámetro.
El parámetro debe activarse en un tiempo de
10 segundos después de que en el parámetro
NEW de la instrucción "PE_I_DEV (Pági‐
na 2594)" se haya detectado un flanco ascen‐
dente.

Programación del PLC
Manual de programación y manejo, 11/2019

2609

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

VALID

InOut

BOOL

I, Q, M, D, L

El parámetro debe estar interconectado con la
entrada VALID de la instrucción "PE_I_DEV
(Página 2594)".
Cuando los datos de respuesta para el contro‐
lador PROFIenergy están disponibles y pue‐
den enviarse, el bloque auxiliar activa el pará‐
metro.

DATA_
ERRORRSP

InOut

VARIANT

D

ERROR

Output

BOOL

I, Q, M, D, L

Puntero hacia el área de datos en la que se
guardan los datos de respuesta. El parámetro
es idéntico al puntero de DATA_ERRORRSP
de la instrucción "PE_I_DEV (Página 2594)".
El área de datos direccionada contiene el tele‐
grama PROFIenergy completo.
Longitud mínima: 244 bytes
● "0": Ningún error
● "1": Con errores

STATUS

Output

WORD

I, Q, M, D, L

● "0": Ningún error
● "0x80B1": Error en la indicación de
VARIANT, p. ej. área errónea

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

PE_Measurement_Value_RSP: Generar respuesta con valores medidos solicitados
Descripción
El bloque auxiliar "PE_Measurement_Value_RSP" genera la respuesta al
comando Get_measurement_values (Página 2593). En la respuesta se devuelven los valores
de los valores medidos solicitados.

Parámetros
La tabla siguiente muestra los parámetros del bloque auxiliar "PE_Measurement_Value_RSP":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

PE_I_DEV_NE
W

Input

BOOL

I, Q, M, D, L o cons‐
tante

El parámetro debe estar interconectado con el
parámetro de salida NEW de la instrucción
"PE_I_DEV (Página 2594)". Si el parámetro tiene
el valor "1", el bloque auxiliar se ejecuta.

CMD

Input

INT

I, Q, M, D, L o cons‐
tante

Service-Request-ID del comando PROFIenergy

2610

El parámetro debe estar interconectado con el
parámetro de salida CMD de la instrucción
"PE_I_DEV (Página 2594)".

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

CMD_MODI‐
FIER

Input

INT

I, Q, M, D, L o cons‐
tante

Subcomando PROFIenergy (la evaluación solo
tiene lugar si CMD=3 o CMD=16). El parámetro
debe estar interconectado con el parámetro de
salida CMD_MODIFIER de la instrucción
"PE_I_DEV".

Count

Input

BYTE

I, Q, M, D, L o cons‐
tante

Número de valores medidos (Measurement_Va‐
lues).

Measure‐
ment_Values

Input

VARIANT

D

Puntero hacia la matriz con los valores medidos
(Measurement_IDs).
Consulte la estructura de la matriz según el perfil
PROFIenergy en Comando PE "Query_Measu‐
rement" - "Get_Measurement_values" (Pági‐
na 2593)

ACTIVATE

InOut

BOOL

I, Q, M, D, L

Con un flanco ascendente en la entrada ACTI‐
VATE, esta instrucción copia los parámetros de
entrada en el área de datos DA‐
TA_ERROR_RSP. Después la instrucción resta‐
blece el parámetro.
El parámetro debe activarse en un tiempo de 10
segundos después de que en el parámetro NEW
de la instrucción "PE_I_DEV (Página 2594)" se
haya detectado un flanco ascendente.

VALID

InOut

BOOL

I, Q, M, D, L

El parámetro debe estar interconectado con la
entrada VALID de la instrucción "PE_I_DEV (Pá‐
gina 2594)".
Cuando los datos de respuesta para el controla‐
dor PROFIenergy están disponibles y pueden
enviarse, el bloque auxiliar activa el parámetro.

DATA_
ERRORRSP

InOut

VARIANT

D

Puntero hacia el área de datos en la que se guar‐
dan los datos de respuesta. El parámetro es
idéntico al puntero de DATA_ERRORRSP de la
instrucción "PE_I_DEV (Página 2594)". El área
de datos direccionada contiene el telegrama
PROFIenergy completo.
Longitud mínima: 244 bytes

ERROR

Output

BOOL

I, Q, M, D, L

● "0": Ningún error

STATUS

Output

WORD

I, Q, M, D, L

● "0": Ningún error

● "1": Con errores
● "0x80B1": Error en la indicación de
VARIANT, p. ej. área errónea

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2611

Instrucciones
4.1 Instrucciones

4.1.4.7

Parametrización del módulo

Escribir y leer registros
Principio
Algunos módulos poseen un área de datos del sistema a la que solo es posible acceder desde
el programa mediante escritura. Esta área contiene registros con los números de 0 a 240,
aunque no todos los módulos poseen todos los registros (ver la tabla siguiente).
Además, los módulos pueden poseer también un área de datos del sistema. Al área de datos
del sistema solo es posible acceder desde el programa en modo de lectura. Esta área contiene
registros con los números de 0 a 240, aunque no todos los módulos poseen todos los registros.
Nota
Algunos módulos poseen ambas áreas de datos del sistema. Se trata de áreas distintas desde
el punto de vista físico, que solo tienen en común la división lógica en registros.

Área de datos del sistema solo accesible por escritura
La tabla siguiente muestra el formato del área de datos del sistema solo accesible por
escritura. Indica el tamaño que puede ocupar cada uno de los registros y con qué instrucciones
pueden escribirse.
Número de regis‐ Contenido
tro

Tamaño

Con acceso de escritura me‐
diante instrucción

0

Parámetros

-

WR_DPARM (Página 2623)

1

Parámetros

-

WR_DPARM (Página 2623)

de 2 a 127

Datos del usuario

Cada uno ≤ 240 bytes

WR_DPARM (Página 2623)
WR_REC (Página 2509)

de 128 a 240

Parámetros

Cada uno ≤ 240 bytes

WR_DPARM (Página 2623)
WR_REC (Página 2509)

2612

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Área de datos del sistema solo accesible por lectura
La tabla siguiente muestra el formato del área de datos del sistema solo accesible por lectura.
Indica el tamaño que pueden ocupar los distintos registros y con qué instrucciones pueden
leerse.
Número de
registro

Contenido

Tamaño

Con acceso de lectura median‐
te instrucción

0

Datos de diagnóstico es‐ 4 bytes
pecíficos de módulo (defi‐
nidos de modo homogé‐
neo para el sistema)

RD_REC (Página 2504)

1

Datos de diagnóstico es‐
pecíficos de canal

de 4 a 220 bytes

RD_REC (Página 2504)

de 2 a 127

Datos del usuario

Cada uno ≤ 240 bytes

RD_REC (Página 2504)

de 128 a 240

Datos de diagnóstico

Cada uno ≤ 240 bytes

RD_REC (Página 2504)

(incl. registro 0)

Recursos del sistema
Si se lanzan consecutivamente varias transferencias de registro de funcionamiento asíncrono,
se garantiza que todas las peticiones se ejecuten y que no se produzcan interferencias
recíprocas.
En el momento en que se alcanza el límite de los recursos del sistema, se envía una
notificación mediante RET_VAL. Elimine el estado de fallo temporal repitiendo la petición.
El número máximo de peticiones activas "simultáneamente" para un mismo tipo de instrucción
depende de la CPU.

RD_DPAR: Leer registro de un módulo
Descripción
Esta instrucción permite leer el juego de datos con número INDEX del componente
direccionado desde los datos del sistema configurados. Puede tratarse de un módulo central
o de un componente descentralizado (PROFIBUS DP o PROFINET IO).
El valor TRUE del parámetro de salida VALID indica que el juego de datos se ha transferido
correctamente al área de destino RECORD. En ese caso, el parámetro de salida LEN contiene
la longitud en bytes de los datos leídos.
Si se ha producido un error durante la transferencia del juego de datos, se señaliza mediante
el parámetro de salida ERROR . En ese caso, el parámetro de salida STATUS contiene la
información de error.
Nota
Información sobre los juegos de datos
La información sobre los números y la estructura de los juegos de datos está disponible en el
manual de producto del módulo correspondiente.

Programación del PLC
Manual de programación y manejo, 11/2019

2613

Instrucciones
4.1 Instrucciones

Funcionamiento
La instrucción "RD_DPAR" es una instrucción asíncrona, de modo que la ejecución se
prolonga a lo largo de varias llamadas. Para iniciar la transferencia del juego de datos, debe
llamarse "RD_DPAR" con REQ = 1.
Mediante el parámetro de salida BUSY y los bytes 2 y 3 del parámetro de salida STATUS se
muestra el estado de la petición. Los bytes 2 y 3 de STATUS corresponden al parámetro de
salida RET_VAL de las instrucciones asíncronas.
Consulte también: Diferencia entre las instrucciones que funcionan síncronamente y las que
funcionan asíncronamente (Página 618).
Cuando el parámetro de salida BUSY ha adoptado el valor FALSE, la transferencia del juego
de datos se puede dar por finalizada.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RD_DPAR":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

REQ = 1: solicitud de lectura

LADDR

Input

HW_IO

I, Q, M, D, L o cons‐
tante

Identificador de hardware del módulo (p. ej.
módulo de entrada).
Este número se asigna automáticamente.

INDEX

Input

INT

I, Q, M, D, L o cons‐
tante

Número del juego de datos

RECORD

InOut

VARIANT

I, Q, M, D, L

Área de destino del juego de datos leído

VALID

Output

BOOL

I, Q, M, D, L

El nuevo juego de datos se ha recibido y es
válido

BUSY

Output

BOOL

I, Q, M, D, L

BUSY = 1: la petición no ha finalizado todavía.

ERROR

Output

BOOL

I, Q, M, D, L

ERROR = 1: se ha producido un error durante
la lectura.

STATUS

Output

DWORD

I, Q, M, D, L

● Identificación de llamada (bytes 2 y 3) o
código de error
● Byte 1: B#16#00, si no hay ningún error.
De lo contrario, ID de función de DPV1PDU: En caso de error al leer el juego de
datos B#16#DE, en caso de error al
escribir el juego de datos B#16#DF. Si no
se utiliza ningún elemento de protocolo
DPV1: B#16#C0.
● Byte 4: Extensión específica del fabricante
de la identificación de error

LEN

Output

INT

I, Q, M, D, L

Longitud de la información leída del juego de
datos

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

2614

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro STATUS
Código de error* Explicación

Restricción

(W#16#...)
0000

Ningún error

-

7000

Primera llamada con REQ=0: Ninguna transmisión de datos activa;
BUSY tiene el valor "0".

-

7001

Primera llamada con REQ=1: Transmisión de datos iniciada; BUSY
tiene el valor "1".

Periferia descentralizada

7002

Llamada intermedia (REQ irrelevante): Transmisión de datos activa;
BUSY tiene el valor "1".

Periferia descentralizada

8092

Tipo no admisible con puntero VARIANT

-

8093

La dirección indicada en el parámetro LADDR no es válida.

-

80B0

Instrucción no posible con este tipo de módulo, o el módulo no conoce
el juego de datos.

-

80B1

La longitud del juego de datos que se debe transferir es errónea.

80C3

En este momento los recursos necesarios (memoria, etc.) están ocu‐
pados.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente
(Página 933)

-

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
En el siguiente ejemplo se lee el juego de parámetros completo de un módulo de entradas
digitales.
Encontrará información adicional sobre juegos de datos en la descripción general de los tipos
de juegos de datos (Página 2375).
Para almacenar los datos es preciso crear nueve variables y la estructura "record" en un
bloque de datos global. (Encontrará la configuración de la estructura más adelante.)

Interconectar parámetro: FC "SLI_itemiseByte_RD_DPAR"
Para reenviar los valores de una secuencia de bits (0..7) debe crearse la FC
"SLI_itemiseByte_RD_DPAR".
Programación del PLC
Manual de programación y manejo, 11/2019

2615

Instrucciones
4.1 Instrucciones
En ella se crean las siguientes variables locales.

Segmento 1: Siguiendo el ejemplo del segmento 1 se crean interconexiones para todos los bits
(0..7).

Interconectar parámetro: FB "SLI_FB_RD_DPAR"
En el FB "SLI_FB_RD_DPAR" se crean las siguientes variables locales.

Segmento 1: Los parámetros de la instrucción "RD_DPAR" se interconectan del siguiente
modo.

2616

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 2: Para convertir la variable "Mode_Channel0" a modo de ejemplo, esta se
interconecta del siguiente modo. Se interconectan todas las entradas y salidas (0..7) de la FC
"SLI_itemiseByte_RD_DPAR".

Identificador de hardware
Cree un módulo de entradas y lea el identificador de hardware en las propiedades del mismo.
El identificador de hardware se almacena mediante el parámetro de entrada LADDR ("laddr").
Resultado (FB "SLI_FB_RD_DPAR")
Si el parámetro de entrada REQ ("start") devuelve el estado lógico "TRUE", se inicia la
instrucción "RD_DPAR". Mediante el parámetro de entrada LADDR ("laddr"), la instrucción
"RD_DPAR" llama el módulo. Mediante el parámetro de entrada INDEX ("dataRecNbr") se
llama el juego de datos del número "128" del módulo. Durante varias llamadas, la instrucción
"RD_DPAR" lee el juego de datos y lo guarda mediante el parámetro RECORD ("record").
Programación del PLC
Manual de programación y manejo, 11/2019

2617

Instrucciones
4.1 Instrucciones
La longitud del juego de datos leído se recoge en el parámetro de salida LEN ("lengthRec"). De
acuerdo con el valor del parámetro de entrada MLEN ("maxLen" tiene el valor "0"), la
información del juego de datos que debe leerse es ilimitada.
Durante la ejecución, el parámetro de salida BUSY ("busy") está ajustado a "TRUE" y VALID
("checkedValid") a "FALSE". Una lectura correcta ("checkedValid" a "TRUE") no se indica
hasta finalizar la ejecución. En el parámetro de salida STATUS ("status") se indica el estado
del bloque. La ejecución transcurre sin errores.

El juego de datos 128 contiene información de los parámetros de todos los canales del módulo.
El valor "2" de la variable "ByteOfDataRec" hace referencia a la longitud de los datos por canal.
Para cada canal hay información relacionada con el estado y el modo de operación.
Extracto del juego de datos leído hasta el canal 1:

Para obtener una explicación más detallada de los datos del juego de datos 128, convierta los
valores de BYTE en una secuencia de bits. He aquí un ejemplo del modo de operación del
canal 0: Puesto que los bits 1 y 2 están puestos a "TRUE", el canal 0 tiene un retardo a la
entrada de 3,2 ms. Encontrará la explicación de la estructura del juego de parámetros o canal
en el manual de producto del módulo.

2618

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
RD_DPARM: Leer registro de los datos de sistema configurados (Página 2621)
Cambiar formatos de visualización en el estado del programa (Página 8529)

RD_DPARA: Leer registro de un módulo de forma asíncrona
Descripción
Esta instrucción permite leer el registro con número RECNUM del módulo seleccionado desde
los datos del sistema configurados. El registro leído se guarda en el área de destino definida
mediante el parámetro RECORD .
Nota
Información sobre los juegos de datos
La información sobre los números y la estructura de los juegos de datos está disponible en el
manual de producto del módulo correspondiente.

Funcionamiento
La instrucción "RD_DPARA" es una instrucción asíncrona, de modo que la ejecución se
prolonga a lo largo de varias llamadas. Para iniciar la lectura debe llamarse la instrucción con
REQ = 1.
El estado de la petición se indica por medio de los parámetros de salida RET_VAL y BUSY .
Consulte también: Diferencia entre las instrucciones que funcionan síncronamente y las que
funcionan asíncronamente (Página 618).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RD_DPARA":
Parámetro

Declaración

Tipo de datos

Área de memoria

REQ

Input

BOOL

I, Q, M, D, L o constan‐ REQ = 1: solicitud de lectura
te

LADDR

Input

HW_IO

I, Q, M, D, L o constan‐ Identificador de hardware del módulo (p. ej.
te
módulo de entrada).
Este número se asigna automáticamente.

RECNUM

Input

BYTE

I, Q, M, D, L o constan‐ Número del juego de datos
te

Programación del PLC
Manual de programación y manejo, 11/2019

Descripción

2619

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución
de la instrucción, el valor de respuesta con‐
tendrá un código de error.
Si no se han producido errores durante la
transferencia, deben distinguirse los siguien‐
tes casos:
● RET_VAL contiene la longitud en bytes
del registro realmente leído, en caso de
que el área de destino sea mayor que el
registro leído.
● RET_VAL contiene "0" en caso de que la
longitud del registro leído sea igual a la
longitud del área de destino.

BUSY

Output

BOOL

I, Q, M, D, L

BUSY = 1: la petición no ha finalizado todavía.

RECORD

Output

VARIANT

I, Q, M, D, L

Área de destino para el juego de datos leído.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Explicación

Restricción

(W#16#...)
0000

Ningún error

-

7000

Primera llamada con REQ=0: No hay ninguna transferencia de datos
activa; BUSY tiene el valor 0.

-

7001

Primera llamada con REQ=1: Transmisión de datos iniciada; BUSY
tiene el valor "1".

Periferia descentralizada

7002

Llamada intermedia (REQ irrelevante): Transmisión de datos activa;
BUSY tiene el valor "1".

Periferia descentralizada

8092

En el parámetro RECORD se ha indicado un tipo de datos diferente a
(Array of) secuencias de bits o enteros.

-

8093

La dirección indicada en el parámetro LADDR no es válida.

-

80B0

Instrucción no posible con este tipo de módulo, o el módulo no conoce
el juego de datos.

-

80B1

La longitud del juego de datos que se debe transferir es errónea.
Con RD_DPARM (Página 2621): La longitud del área de destino deli‐
mitada por RECORD es insuficiente.

-

80C3

En este momento los recursos necesarios (memoria, etc.) están ocu‐
pados.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente
(Página 933)

-

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

2620

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

RD_DPARM: Leer registro de los datos de sistema configurados
Utilización
Nota
Limitación de uso
La instrucción "RD_DPARM" está pensada solo para la migración de las CPU S7-300/400 a las
CPU S7-1500. En todos los demás casos utilice la instrucción "RD_DPARA".

Descripción
Esta instrucción permite leer el juego de datos con número RECNUM del módulo direccionado
de los datos de sistema configurados. El juego de datos leído se guarda en el área de destino
delimitada por el parámetro RECORD.
Nota
Información sobre los juegos de datos
La información sobre los números y la estructura de los juegos de datos está disponible en el
manual de producto del módulo correspondiente.

Funcionamiento
La instrucción "RD_DPARM" es una instrucción asíncrona, de modo que la ejecución se
prolonga a lo largo de varias llamadas.
El estado de la petición se indica a través del parámetro de salida RET_VAL.
Consulte también: Diferencia entre las instrucciones que funcionan síncronamente y las que
funcionan asíncronamente (Página 618).

Programación del PLC
Manual de programación y manejo, 11/2019

2621

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RD_DPARM":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IOID

Input

BYTE

I, Q, M, D, L o cons‐
tante

Identificador del área de direcciones:
● B#16#54 = entrada de periferia (PI)
● B#16#55 = salida de periferia (PQ)
Si se trata de un módulo mixto, debe indicarse
la identificación de área de la dirección más
baja. Si las direcciones son idénticas, debe in‐
dicarse B#16#54.

LADDR

Input

HW_IO

I, Q, M, D, L o cons‐
tante

Identificador de hardware del módulo (p. ej.
módulo de entrada).
Este número se asigna automáticamente.

RECNUM

Input

BYTE

I, Q, M, D, L o cons‐
tante

Número del juego de datos (valores admisi‐
bles: de 0 a 240)

RET_VAL

Return

INT

I, Q, M, D, L

Longitud en bytes del juego de datos leído, si
el juego de datos leído cabe en el área de des‐
tino y no se ha producido ningún error durante
la transferencia.
Si se produce un error durante la ejecución de
la instrucción, el valor de respuesta contendrá
un código de error.

RECORD

Output

VARIANT

I, Q, M, D, L

Área de destino para el juego de datos leído.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Explicación

Restricción

(W#16#...)
0000

Ningún error

-

7001

Primera llamada: transferencia de datos iniciada

Periferia descentralizada

7002

Llamada intermedia: transferencia de datos ya activa

Periferia descentralizada

8090

La dirección base lógica indicada no es válida.

-

8092

En la referencia VARIANT del parámetro RECORD se ha indicado un
tipo diferente a BYTE .

-

8093

Esta instrucción no es válida para el módulo seleccionado con LADDR. -

80B0

Instrucción no posible con este tipo de módulo, o el módulo no conoce
el juego de datos

80B1

La longitud del área de destino delimitada por RECORD es insuficiente. -

80C3

En este momento los recursos necesarios (memoria, etc.) están ocu‐
pados.

2622

-

-

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error* Explicación

Restricción

(W#16#...)
Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente
(Página 933)

-

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

WR_DPARM: Transferir registro
Descripción
La instrucción "WR_DPARM" permite transferir el juego de datos con número RECNUM desde
los datos de configuración al módulo direccionado. El juego de datos puede ser estático o
dinámico.
Nota
Información sobre los juegos de datos
La información sobre los números y la estructura de los juegos de datos está disponible en el
manual de producto del módulo correspondiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "WR_DPARM":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

REQ = 1: Solicitud de escritura

LADDR

Input

HW_IO

I, Q, M, D, L o cons‐
tante

Identificador de hardware del módulo (p. ej.
módulo de entrada).
Este número se asigna automáticamente.

RECNUM

Input

BYTE

I, Q, M, D, L o cons‐
tante

Número del juego de datos

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución de
la instrucción, el valor de respuesta contendrá
un código de error.

BUSY

Output

BOOL

I, Q, M, D, L

BUSY = 1: La escritura todavía no ha finaliza‐
do.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2623

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
Código de error* Explicación

Restricción

(W#16#...)
0000

Ningún error

-

7000

Primera llamada con REQ=0: No hay ninguna transferencia de datos
activa; BUSY tiene el valor 0.

-

7001

Primera llamada con REQ=1: Transmisión de datos iniciada; BUSY
tiene el valor "1".

Periferia descentralizada

7002

Llamada intermedia (REQ irrelevante): Transmisión de datos activa;
BUSY tiene el valor "1".

Periferia descentralizada

8093

La dirección indicada en el parámetro LADDR no es válida.

-

80A1

Respuesta negativa al enviar el juego de datos al módulo (módulo de‐ senchufado durante la transferencia o defectuoso).

80A2

Error de protocolo DP con Layer 2, posible error de hardware/interfaz
en el esclavo DP.

Periferia descentralizada

80A3

Error de protocolo DP con User-Interface/User.

Periferia descentralizada

80A9

Función no soportada

-

80B0

Instrucción no posible con este tipo de módulo, o el módulo no conoce
el juego de datos.

-

80B1

La longitud del juego de datos que se debe transferir es errónea.

-

80B2

El slot configurado no está ocupado.

-

80B3

El tipo de módulo real no coincide con el tipo de módulo configurado.

-

80B6

Acceso denegado

-

80C1

Los datos de la petición de escritura efectuada anteriormente en el
módulo para el mismo juego de datos no han sido procesados todavía
por el módulo.

-

80C3

En este momento los recursos necesarios (memoria, etc.) están ocu‐
pados.

80C4

Error temporal interno. No se ha podido ejecutar la petición.

-

Repita la petición. Si este error se produce a menudo, compruebe si hay
fuentes de perturbación en la instalación.
80C5

Periferia descentralizada no disponible o desactivada.

Periferia descentralizada

80C6

La transferencia del juego de datos se ha cancelado por una interrup‐
ción de la clase de prioridad (rearranque o segundo plano).

Periferia descentralizada

80D0

No hay entradas para el módulo.

-

80D1

El número del juego de datos no está configurado para el módulo (se
descartan los números >241).

-

80D2

Módulo no parametrizable según la identificación del módulo.

-

80D5

El juego de datos es estático.

-

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente
(Página 933)

-

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

2624

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

4.1.4.8

Alarmas

ATTACH: Asignar OB a evento de alarma
Descripción
La instrucción "ATTACH" asigna un bloque de organización (OB) a un evento de alarma de
proceso.
● En el parámetro OB_NR se especifica la denominación simbólica o numérica del bloque de
organización que se asigna al evento indicado en el parámetro EVENT.
● En el parámetro EVENT se selecciona el evento de alarma de proceso. Los eventos de
alarma de proceso ya creados se listan en las variables PLC bajo "Constantes de sistema".
Si el evento indicado en el parámetro EVENT ocurre tras haberse ejecutado correctamente la
instrucción "ATTACH", se llama el bloque de organización especificado en el parámetro
OB_NR y se ejecuta el programa correspondiente.
Con el parámetro ADD se determina si se deben deshacer o conservar las asignaciones
existentes del bloque de organización a otros eventos. Si el parámetro ADD está puesto a "0",
las asignaciones existentes se sustituyen por la asignación actual.

Eventos de alarma de proceso
Cuando los eventos no están pendientes el tiempo suficiente, pueden emplearse las alarmas
de proceso. Estas reaccionan a los eventos en tiempo de ejecución. A las alarmas de proceso
se les puede asignar bloques OB de alarma de proceso que contengan la reacción a un evento
determinado.
Las alarmas de proceso pueden crearse para diferentes eventos. Ejemplos:
● La detección de flancos ascendentes o descendentes en entradas digitales.
● El rebase por exceso y por defecto de un valor límite definido en entradas analógicas.
● En caso de inversión de sentido, inicialización externa, rebase por exceso/defecto, etc. en
contadores rápidos.

Programación del PLC
Manual de programación y manejo, 11/2019

2625

Instrucciones
4.1 Instrucciones

Funcionamiento
Toda alarma de proceso puede asignarse a un OB de alarma de proceso que se ponga en la
cola de espera para el procesamiento cuando se produzca el evento de alarma de proceso. La
asignación de OB y evento puede llevarse a cabo durante la configuración o el tiempo de
ejecución:
● Para asignar un OB a un evento durante la configuración, debe seleccionarse en la
configuración hardware un OB de alarma de proceso para un evento en "Alarmas de
proceso".
● Para ejecutar la asignación durante el tiempo de ejecución, use la instrucción ATTACH. La
asignación de evento y OB de alarma de proceso se lleva a cabo mediante los parámetros
EVENT y OB_NR.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "ATTACH":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OB_NR

Input

OB_ATT

I, Q, M, D, L o constante Bloque de organización (se soportan núme‐
ros hasta 32767).

EVENT

Input

EVENT_ATT

I, Q, M, D, L o constante Evento de alarma de proceso que debe asig‐
narse al OB.
El evento de alarma de proceso primero de‐
be activarse en la configuración de disposi‐
tivos del hardware para entradas o contado‐
res rápidos.

ADD

Input

BOOL

I, Q, M, D, L o constante Efectos en las asignaciones existentes:
● ADD=0 (valor predeterminado): este
evento reemplaza todas las
asignaciones de evento actuales para el
OB.
● ADD=1: este evento se agrega a los
eventos actualmente asignados al OB.

RET_VAL

Return

INT

I, Q, M, D, L

Estado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Descripción
(W#16#....)
0

Ningún error

8090

El OB no existe

8091

El OB es del tipo erróneo

8093

El evento no existe

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

2626

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
En el ejemplo siguiente se asignará un OB de alarma de proceso (OB40) a un evento de alarma
de proceso generado.
Requisitos:
Cree un módulo de entradas (DI) y configure un evento de alarma de proceso para un flanco
ascendente en "Propiedades > Entradas 0-15 > ... > Canal 0".

En el parámetro de entrada EVENT ("event") se almacena el siguiente identificador de
hardware del evento de alarma de proceso configurado.

Almacenamiento de datos
Para almacenar los datos es preciso crear nueve variables en un bloque de datos global. A
través del parámetro de entrada OB_NR ("obNbr") de la instrucción "ATTACH" se guarda el
número del OB que debe asignarse (OB40).

Para llamar el evento de alarma de proceso, cree una tabla de variables con una variable PLC
(dirección "I0.0").

Programación del PLC
Manual de programación y manejo, 11/2019

2627

Instrucciones
4.1 Instrucciones
Interconexión
Los parámetros de la instrucción se interconectan del siguiente modo.

Para llamar el evento de alarma de proceso debe interconectarse la variable PLC del siguiente
modo.
Segmento 2:

Segmento 3:

Para resetear, interconecte "testValue2" y "SLI_ATTACH_force" del siguiente modo.
Segmento 4:

Cree la interconexión siguiente en el OB40:

2628

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Procesamiento
Si el contacto NA ("start") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"ATTACH" y se asigna el evento al OB. Con el valor "FALSE" del parámetro de entrada ADD
("add"), el evento reemplaza todas las asignaciones de eventos actuales del OB40. En el
parámetro de salida RET_VAL ("returnValue") se indica que la ejecución se ha realizado sin
errores.
Si en el segmento 2 el contacto NA ("signal") devuelve el estado lógico "TRUE", la variable PLC
"SLI_ATTACH_force" se pone al estado lógico "TRUE" y se ejecuta el OB40. Durante la
llamada del OB40, el valor de "testValue1" se transfiere a "testValue2".
Si los contactos NA ("start" y "signal") devuelven el estado lógico "FALSE", en el segmento 4
se resetean los valores de "testValue2" y "SLI_ATTACH_force".

Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

DETACH: Deshacer asignación entre OB y evento de alarma
Descripción
La instrucción deshace en el tiempo de ejecución la asignación que existe entre un bloque de
organización y uno o varios eventos de alarma de proceso.

Programación del PLC
Manual de programación y manejo, 11/2019

2629

Instrucciones
4.1 Instrucciones
En el parámetro OB_NR se especifica la denominación simbólica o numérica del bloque de
organización. La asignación al evento indicado en el parámetro EVENT se deshace.
● Si se ha seleccionado un solo evento de alarma de proceso en el parámetro EVENT, se
deshace la asignación del OB a este evento de alarma de proceso. Todas las demás
asignaciones existentes en ese momento se conservan. Un evento de alarma de proceso
individual se selecciona en la lista desplegable del comodín del operando.
● Si no se ha seleccionado ningún evento de alarma de proceso, se deshace la asignación
de todos los eventos asignados actualmente a este bloque de organización OB_NR.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DETACH":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OB_NR

Input

OB_ATT

I, Q, M, D, L o constante Bloque de organización (se soportan nú‐
meros hasta 32767).

EVENT

Input

EVENT_ATT

I, Q, M, D, L o constante Evento de alarma de proceso

RET_VAL

Return

INT

I, Q, M, D, L

Estado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error*

Descripción

(W#16#....)
0

Ningún error

1

No existe ninguna asignación (advertencia)

8090

El OB no existe

8091

El OB es del tipo erróneo

8093

El evento no existe

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
En el ejemplo siguiente se asignará un evento de alarma de proceso a un OB de alarma de
proceso (OB41) y seguidamente se deshará la asignación.
Requisitos:
Se ha creado previamente un OB de alarma de proceso (OB41 con el nombre
"SLI_iOB_DETACH"). Cree un módulo de entradas (DI) y configure un evento de alarma de
proceso para un flanco ascendente en "Propiedades > Entradas 0-15 > ... > Canal 1".

2630

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

En el parámetro de entrada EVENT ("event") se almacena el siguiente identificador de
hardware del evento de alarma de proceso configurado ("Rising edge 1").

Almacenamiento de datos:
Para almacenar los datos es preciso crear diez variables en un bloque de datos global. En el
parámetro de entrada OB_NR ("obNbr") de las instrucciones "ATTACH" y "DETACH" se
guarda el número del OB que debe asignarse (OB41).

Para llamar el evento de alarma de proceso, cree una tabla de variables con una variable PLC
(dirección "I1.0").

Interconexión:
Para llamar las instrucciones debe crearse un FB ("SLI_FB_DETACH").
Segmento 1: Los parámetros de la instrucción "ATTACH" se interconectan del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2631

Instrucciones
4.1 Instrucciones

Segmento 2: Para llamar el evento de alarma de proceso debe interconectarse la variable PLC
del siguiente modo.

Segmento 3: La llamada del evento de alarma de proceso se transfiere del siguiente modo.

Segmento 4: Los parámetros de la instrucción "DETACH" se interconectan del siguiente modo.

Segmento 5: Para resetear, interconecte "testValue2" y "SLI_DETACH_event" del siguiente
modo.

2632

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cree la interconexión siguiente en el OB41:

Procesamiento
Si el contacto NA ("startAttach") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"ATTACH" y se asigna el evento al OB41. Con el valor "FALSE" del parámetro de entrada ADD
("add"), el evento reemplaza todas las asignaciones de eventos actuales del OB41. En el
parámetro de salida RET_VAL ("retValAtt") se indica que la ejecución se ha realizado sin
errores.

Si en el segmento 2 el contacto NA ("signal") devuelve el estado lógico "TRUE", el evento de
alarma de proceso ("SLI_DETACH_event") se ajusta a "TRUE". Se llama el OB41 y en el OB41
el valor de "testValue1" se transfiere a "testValue2". Mientras el evento de alarma de proceso
devuelva el estado lógico "TRUE" se llamará el OB41 y se mostrará en el segmento 3 por
medio de la bobina ("scannedSignal").

Programación del PLC
Manual de programación y manejo, 11/2019

2633

Instrucciones
4.1 Instrucciones

Si "testValue1" y "testValue2" devuelven el mismo valor, se ejecuta la instrucción "DETACH"
y el evento se disocia del OB41. En el parámetro de salida RET_VAL ("retValDet") se indica
que la ejecución se ha realizado sin errores.

Si la variable "startAttach" devuelve el estado lógico "FALSE", en el segmento 5 se resetean
los valores de "testValue2" y de la variable PLC.
Encontrará información adicional y el código del programa del ejemplo anterior aquí:Sample
Library for Instructions (Página 615)

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

2634

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Alarma cíclica
SET_CINT: Ajustar parámetros de alarma cíclica
Descripción
Con la instrucción se configuran los parámetros para un OB de alarma cíclica. El momento de
inicio de un OB de alarma cíclica resulta del correspondiente intervalo de tiempo del OB y del
desfase.
● El intervalo de tiempo de un OB es el intervalo en el que se llama el OB regularmente. Si el
intervalo de tiempo p. ej. es de 100 μs, el OB se llama cada 100 μs durante la ejecución del
programa.
● El desfase es el intervalo de tiempo que se aplaza la llamada de un OB de alarma cíclica.
El desfase se puede utilizar para procesar bloques de organización de baja prioridad en una
escala de tiempos exacta.
Si no existe el OB o no se soporta el intervalo de tiempo utilizado, se emite el correspondiente
mensaje de error en el parámetro RET_VAL.
Un intervalo de tiempo de "0" en el parámetro CYCLE significa que el OB no se llama.

Funcionamiento
Si se llaman un OB de baja prioridad y un OB de alta prioridad en el mismo intervalo de tiempo,
el OB de baja prioridad no se llama hasta que se haya procesado el OB de alta prioridad. El
momento de llamada del OB de baja prioridad se puede retardar según la longitud del periodo
de procesamiento del OB de alta prioridad.

/ODPDGDGH2%VLQGHVIDVH

W

W

W

W

W

W

W

W

2%
GHPD\RU
SULRULGDG

2%
GHPHQRU
SULRULGDG

Si para el OB de baja prioridad se ha configurado un desfase y este es mayor que el
correspondiente tiempo de procesamiento actual del OB de alta prioridad, el bloque se llama
según un modelo de tiempos fijo.

Programación del PLC
Manual de programación y manejo, 11/2019

2635

Instrucciones
4.1 Instrucciones
/ODPDGDGH2%FRQGHVIDVH

W

W

W

W

W

W

W

2%
GHPD\RU
SULRULGDG
W
2%
GHPHQRU
SULRULGDG

'HVIDVH

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SET_CINT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OB_NR

Input

OB_CYCLIC

I, Q, M, D, L o constante Número de OB (<32768)

CYCLE

Input

UDINT

I, Q, M, D, L o constante Intervalo de tiempo en microsegundos

PHASE

Input

UDINT

I, Q, M, D, L o constante Desfase en microsegundos

RET_VAL

Return

INT

I, Q, M, D, L

Estado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Descripción
(W#16#....)
0

Ningún error

8090

El OB no existe o el OB es del tipo incorrecto

8091

Intervalo de tiempo incorrecto

8092

Desfase incorrecto

80B2

Ningún evento asignado al OB

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para funciones de alarma cíclica
(Página 2638).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

2636

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

QRY_CINT: Consultar parámetros de alarma cíclica
Descripción
La instrucción QRY_CINT emite los parámetros siguientes de un OB de alarma cíclica:
● Ciclo de reloj
● Desfase
● Estado de la alarma cíclica (habilitada, retardada, transcurrida...).
El OB de alarma cíclica se identifica con el parámetro OB_NR.
Los valores de los parámetros consultados de la alarma cíclica se corresponden con los del
momento de ejecución de la instrucción "QRY_CINT".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "QRY_CINT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OB_NR

Input

OB_CYCLIC
(INT)

I, Q, M, D, L o constante Número de OB (<32768) o direccionamien‐
to simbólico mediante los nombres del OB
(p. ej., OB_MyOB)

CYCLE

Output

UDINT

I, Q, M, D, L

Ciclo de reloj en microsegundos

PHASE

Output

UDINT

I, Q, M, D, L

Desfase

STATUS

Output

WORD

I, Q, M, D, L

Estado de la alarma cíclica:
● Bit 0 a bit 4: Véase el parámetro
STATUS
● Otros bits: Siempre "0"

RET_VAL

Return

INT

I, Q, M, D, L

Estado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Bit

Valor

Significado

0

0

No utilizado (siempre "0").

1
2
3

0

La alarma cíclica está habilitada.

1

La alarma cíclica está retardada.

0

La alarma cíclica no está activada o ha expirado.

1

La alarma cíclica está activada.

0

No utilizado (siempre "0").

Programación del PLC
Manual de programación y manejo, 11/2019

2637

Instrucciones
4.1 Instrucciones
Bit

Valor

Significado

4

0

El OB con el número indicado no existe.

1

El OB con el número indicado existe.

Otros bits

No utilizado (siempre "0").

Parámetro RET_VAL
Si aparece un error, el correspondiente código de error se muestra en el parámetro RET_VAL
y el parámetro STATUS se pone a "0".
Código de error*

Descripción

(W#16#....)
0

Ningún error.

8090

El OB no existe o es del tipo incorrecto.

80B2

Ningún evento asignado al OB.

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para funciones de alarma cíclica
(Página 2638).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Ejemplo de programa para funciones de alarma cíclica
Introducción
En el ejemplo siguiente se leerán la fase y el ciclo de un OB de alarma cíclica (OB31) y se
establecerá un ciclo nuevo.
El OB31 tiene los siguientes ajustes predeterminados:

2638

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Requisitos
● Para la llamada debe crearse un OB31.
● Para almacenar los datos es preciso crear doce variables en un bloque de datos global.

Interconectar parámetro: FC "SLI_itemiseStatus_CINT"
Para evaluar la información de estado se crea una FC "SLI_itemiseStatus_CINT".
En ella se crean las siguientes variables locales.

Para todos los bits relevantes se crean interconexiones.
Segmento 1:

Segmento 2:

Programación del PLC
Manual de programación y manejo, 11/2019

2639

Instrucciones
4.1 Instrucciones

Segmento 3:

Interconectar parámetro: FB "SLI_FB_SET_CINT"
Para llamar las instrucciones debe crearse un FB ("SLI_FB_SET_CINT"). En el FB
"SLI_FB_SET_CINT" se crean las siguientes variables locales.

Segmento 1: Los parámetros de la instrucción "QRY_CINT" se interconectan del siguiente
modo.

Segmento 2: Los parámetros de la instrucción "SET_CINT" se interconectan del siguiente
modo.

2640

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 3: El parámetro de la FC "SLI_itemiseStatus_CINT" se interconecta del siguiente
modo.

Interconectar parámetros: OB31
Cree las interconexiones siguientes en el OB31.

Resultado de "QRY_CINT"
En el parámetro de entrada OB_NR ("obNbr") de las instrucciones "QRY_CINT" y "SET_CINT"
está almacenado el número del OB que debe llamarse (OB31).
Si el contacto NA ("executeQry") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"QRY_CINT" y se leen los datos del OB31.
En el parámetro de salida CYCLE ("qryCycle") se devuelve el ciclo. En el parámetro de salida
PHASE ("qryPhase") se devuelve el desfase.
El parámetro de salida STATUS ("#statWord") indica el estado del OB31. En el parámetro de
salida RET_VAL ("returnValueQry") se indica que la ejecución se ha realizado sin errores.

Programación del PLC
Manual de programación y manejo, 11/2019

2641

Instrucciones
4.1 Instrucciones
La información de estado actual ("#statWord") del OB31 se interpreta en el segmento 3
mediante la FC "SLI_itemiseStatus_CINT" y se devuelve mediante la estructura
"itemiseStatus".

El valor de la variable "#statWord" se refleja en la estructura "itemiseStatus":

Resultado de "SET_CINT"
Si el contacto NA ("executeSet") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"SET_CINT". Mediante el parámetro de entrada CYCLE ("setCycle") de la instrucción
"SET_CINT" se transfiere un ciclo nuevo al OB31. En el parámetro de entrada PHASE
("setPhase") está almacenado el valor de desfase "0".
En el parámetro de salida RET_VAL ("returnValueSet") se indica que la ejecución se ha
realizado sin errores.

2642

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Tras la ejecución de la instrucción "SET_CINT", el OB31 conserva los nuevos datos de alarma
cíclica hasta que se produce un STOP de la CPU. El contacto NA ("executeSet") puede volver
a ponerse al estado lógico "FALSE" después de la ejecución. Las propiedades
predeterminadas del OB31 no se ven influidas por la ejecución del "SET_CINT".

Resultado del OB31
Si el contacto NA ("executeSet") devuelve el estado lógico "TRUE", en el OB31 se inicia un
temporizador CEI "TP". El temporizador CEI se para al cabo de 2 minutos.

Código del programa
Encontrará información adicional y el código del programa para el ejemplo anterior
aquí: Sample Library for Instructions (Página 615).

Programación del PLC
Manual de programación y manejo, 11/2019

2643

Instrucciones
4.1 Instrucciones

Alarma horaria
SET_TINT: Ajustar alarma horaria
Descripción
La instrucción "SET_TINT" permite ajustar la fecha y hora de inicio de los bloques de
organización de la alarma horaria desde el programa de usuario sin necesidad de realizar
ajustes en la configuración hardware.
● En el parámetro OB_NR se indica el número del OB de alarma horaria para el que desee
ajustar la fecha y hora de inicio.
● Con los parámetros SDT y PERIOD se indica cuándo y con qué frecuencia debe llamarse
el OB de alarma horaria:
– Llamada única: Indique la fecha y hora en el parámetro SDT. Utilice el valor "0" en el
parámetro PERIOD.
– Llamada múltiple: indique en el parámetro SDT la fecha y hora de la primera llamada.
Ajuste con el parámetro PERIOD el intervalo de tiempo en el que deben efectuarse las
llamadas consecutivas del OB.
Tenga en cuenta lo siguiente al ajustar la fecha y hora de inicio:
● La fecha y hora de inicio especificadas en el parámetro SDT hacen referencia a la hora del
sistema.
● Si al fijar la hora de inicio se indican segundos y milisegundos, la indicación se ignora y se
sustituye por "0".
● Si desea fijar el arranque mensual de un OB de alarma horaria, solo pueden usarse para la
fecha de inicio los días 1, 2, ... 28. Esta restricción evita un salto de la llamada mensual (p.
ej. en meses de 30 días o en febrero).
Como alternativa para los días 29, 30 y 31 de un mes, en el parámetro PERIOD se puede
utilizar el ajuste "Final de mes" (W#16#2001).
Tras ajustar la alarma horaria con "SET_TINT", aún deberá activarla con la instrucción
"ACT_TINT".
Nota
Información adicional sobre los OB de alarma horaria
En la descripción de los bloques de organización de la respectiva CPU encontrará otras
particularidades sobre la utilización de los OB de alarma horaria:
Para el S7-1200: AUTOHOTSPOT
Para el S7-1500: AUTOHOTSPOT
Los ajustes en los parámetros SDT y PERIOD se corresponden con los ajustes asociados a la
alarma horaria en las propiedades del OB de alarma horaria.

2644

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SET_TINT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OB_NR

Input

OB_TOD

I, Q, M, D, L o cons‐
tante

Número del OB de alarma horaria
● Para los OB de alarma horaria están
disponibles los números 10 a 17.
● Alternativamente también se puede
asignar un número de OB a partir de 123.
El número de OB se visualiza en la carpeta
"Bloques de programa" y en las constantes de
sistema.

SDT

Input

DT

D, L o constante

Fecha y hora de inicio

PERIOD

Input

WORD

I, Q, M, D, L o cons‐
tante

Intervalos de ejecución desde el punto de par‐
tida SDT :
● W#16#0000 = Ejecución única
● W#16#0201 = Una vez por minuto
● W#16#0401 = Una vez por hora
● W#16#1001 = Una vez al día
● W#16#1201 = Una vez por semana
● W#16#1401 = Una vez al mes
● W#16#1801 = Una vez al año
● W#16#2001 = A final de mes

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución de
la instrucción, el parámetro actual de
RET_VAL contendrá un código de error.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Descripción
(W#16#...)
0000

No se ha producido ningún error.

8090

Error en el parámetro OB_NR (ningún OB de alarma horaria direccionado).

8091

Error en el parámetro SDT (indicación de fecha y hora no válida).

8092

Entrada errónea en el parámetro PERIOD.

80A1

El momento inicial ajustado se encuentra en el pasado. Este código de error solo aparece si PERIOD =
W#16#0000.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

2645

Instrucciones
4.1 Instrucciones

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para funciones de alarma horaria
(Página 2652).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
ACT_TINT: Activar alarma horaria (Página 2650)

SET_TINTL: Ajustar alarma horaria
Descripción
La instrucción "SET_TINTL" permite ajustar la fecha y hora de inicio de los bloques de
organización de la alarma horaria desde el programa de usuario sin necesidad de realizar
ajustes en la configuración hardware.
● En el parámetro OB_NR se indica el número del OB de alarma horaria para el que desee
ajustar la fecha y hora de inicio.
● Con los parámetros SDT y PERIOD se indica cuándo y con qué frecuencia debe llamarse
el OB de alarma horaria:
– Llamada única: Indique la fecha y hora en el parámetro SDT. Utilice el valor "0" en el
parámetro PERIOD.
– Llamada múltiple: indique en el parámetro SDT la fecha y hora de la primera llamada.
Ajuste con el parámetro PERIOD el intervalo de tiempo en el que deben efectuarse las
llamadas consecutivas del OB.
● Con el parámetro LOCAL se determina si la indicación de la hora en el parámetro SDT hace
referencia a la hora local o a la hora del sistema.
● Con el parámetro ACTIVATE se indica en qué momento deben aplicarse en el bloque de
organización los ajustes realizados:
– ACTIVATE = true: los ajustes realizados se aplican directamente.
– ACTIVATE = false: los ajustes solo se aplican después de la llamada de "ACT_TINT
(Página 2650)".
Tenga en cuenta lo siguiente al ajustar la fecha y hora de inicio:
● Si al fijar la hora de inicio se indican segundos y milisegundos, la indicación se ignora y se
sustituye por "0".
● Si desea fijar el arranque mensual de un OB de alarma horaria, solo pueden usarse para la
fecha de inicio los días 1, 2, ... 28. Esta restricción evita un salto de la llamada mensual (p.
ej. en meses de 30 días o en febrero).
Como alternativa para los días 29, 30 y 31 de un mes, en el parámetro PERIOD se puede
utilizar el ajuste "Final de mes" (W#16#2001).

2646

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tenga en cuenta lo siguiente al utilizar la hora local:
● Cambio del horario de verano al de invierno: Si llama bloques de organización de alarma
horaria con una hora de inicio dentro de la segunda hora con cambio horario de verano a
invierno, utilice una alarma de retardo adicional durante la primera hora del cambio de hora.
● Cambio del horario de invierno al de verano: si para el día del cambio al horario de verano
indica como hora el salto de hora, con una ejecución única (PERIOD = W#16#0000) se
visualizará el código de error 16#8091.
Nota
Información adicional sobre los OB de alarma horaria
En la descripción de los bloques de organización de la respectiva CPU encontrará otras
particularidades sobre la utilización de los OB de alarma horaria:
Para el S7-1200: AUTOHOTSPOT
Para el S7-1500: AUTOHOTSPOT
Los ajustes en los parámetros SDT y PERIOD se corresponden con los ajustes asociados a la
alarma horaria en las propiedades del OB de alarma horaria.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SET_TINTL":
Parámetro

Declaración

Tipo de datos Área de memoria

Descripción

OB_NR

Input

OB_TOD

Número del OB de alarma horaria

I, Q, M, D, L o cons‐
tante

● Para los OB de alarma horaria están
disponibles los números 10 a 17.
● Alternativamente también se puede asignar
un número de OB a partir de 123.
El número de OB se visualiza en la carpeta
"Bloques de programa" y en las constantes de
sistema.

SDT

Input

DTL

D, L o constante

Fecha y hora de inicio

LOCAL

Input

BOOL

I, Q, M, D, L o cons‐
tante

● true: utilizar hora local

I, Q, M, D, L o cons‐
tante

Intervalos de ejecución desde el punto de parti‐
da SDT:

PERIOD

Input

WORD

● false: utilizar hora del sistema

● W#16#0000 = Ejecución única
● W#16#0201 = Una vez por minuto
● W#16#0401 = Una vez por hora
● W#16#1001 = Una vez al día
● W#16#1201 = Una vez por semana
● W#16#1401 = Una vez al mes
● W#16#1801 = Una vez al año
● W#16#2001 = A final de mes

Programación del PLC
Manual de programación y manejo, 11/2019

2647

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos Área de memoria

Descripción

ACTIVATE

Input

BOOL

I, Q, M, D, L o cons‐
tante

● true: ajustar y activar alarma horaria

I, Q, M, D, L

Si se produce un error durante la ejecución de la
instrucción, el parámetro actual de RET_VAL
contendrá un código de error.

RET_VAL

Return

INT

● false: ajustar alarma horaria y activar
exclusivamente al llamar "ACT_TINT
(Página 2650)"

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Descripción
(W#16#...)
0000

No se ha producido ningún error.

8090

Error en el parámetro OB_NR (ningún OB de alarma horaria direccionado).

8091

Error en el parámetro SDT (indicación de fecha y hora no válida).

8092

Entrada errónea en el parámetro PERIOD.

80A1

El momento inicial ajustado se encuentra en el pasado. Este código de error solo aparece si PERIOD =
W#16#0000.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

CAN_TINT: Anular alarma horaria
Descripción
La instrucción "CAN_TINT" permite borrar la fecha y hora de inicio de un bloque de
organización de alarma horaria. La alarma horaria se desactiva y el bloque de organización ya
no se llama.
Para volver a utilizar la alarma horaria, primero debe ajustarse de nuevo el instante de inicio
(instrucción "SET_TINTL (Página 2646)" o "SET_TINT (Página 2644)").

2648

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
A continuación deberá activar nuevamente la alarma horaria:
● Si para ajustar la alarma horaria ha utilizado la instrucción "SET_TINT (Página 2644)" o
"SET_TINTL (Página 2646)" con el parámetro ACTIVE=false, llame "ACT_TINT
(Página 2650)".
● En el caso de la instrucción "SET_TINTL (Página 2646)" también es posible activar la
alarma horaria directamente con el parámetro ACTIVE=true.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "CAN_TINT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OB_NR

Input

OB_TOD

I, Q, M, D, L o constante Número del OB de alarma horaria cuya fe‐
cha y hora de inicio se deben borrar.

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución
de la instrucción, el parámetro actual de
RET_VAL contendrá un código de error.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Descripción
(W#16#...)
0000

No se ha producido ningún error.

8090

Error en el parámetro OB_NR.

80A0

No se ha establecido ninguna fecha/hora de inicio para el OB de alarma horaria correspondiente.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para funciones de alarma horaria
(Página 2652).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Programación del PLC
Manual de programación y manejo, 11/2019

2649

Instrucciones
4.1 Instrucciones

ACT_TINT: Activar alarma horaria
Descripción
La instrucción "ACT_TINT" permite activar un bloque de organización de alarma horaria desde
el programa de usuario. Para la ejecución de la instrucción es imprescindible que la fecha y
hora de inicio para el OB de alarma horaria hayan sido ajustadas previamente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "ACT_TINT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OB_NR

Input

OB_TOD

I, Q, M, D, L o cons‐
tante

Número del OB de alarma horaria
● Para los OB de alarma horaria están
disponibles los números 10 a 17.
● Alternativamente también se puede
asignar un número de OB a partir de 123.
El número de OB se visualiza en la carpeta
"Bloques de programa" y en las constantes de
sistema.

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución de
la instrucción, el parámetro actual de
RET_VAL contendrá un código de error.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Descripción
(W#16#...)
0000

No se ha producido ningún error.

8090

Error en el parámetro OB_NR (ningún OB de alarma horaria direccionado).

80A0

La fecha y hora de inicio no están ajustadas para el OB de alarma horaria correspondiente.

80A1

La hora activada se encuentra en el pasado. El error solo aparece si la alarma horaria debe ejecutarse una
única vez.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para funciones de alarma horaria
(Página 2652).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

2650

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

QRY_TINT: Consultar estado de alarma horaria
Descripción
La instrucción muestra el estado de un bloque de organización de alarma horaria en el
parámetro de salida STATUS.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "QRY_TINT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OB_NR

Input

OB_TOD

I, Q, M, D, L o constante Número del OB de alarma horaria cuyo es‐
tado debe consultarse.
El número de OB se visualiza en la carpeta
"Bloques de programa" y en las constantes
de sistema.

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución
de la instrucción, el parámetro actual de
RET_VAL contendrá un código de error.

STATUS

Output

WORD

I, Q, M, D, L

Estado de la alarma horaria (véase a conti‐
nuación)

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Descripción
(W#16#...)
0000

No se ha producido ningún error.
Excepción: aviso de estado "0" en el bit 4 (ningún OB creado con este número).

8090

Error en el parámetro OB_NR. Causas posibles:
● El valor en el parámetro OB_NR no es un número de OB soportado por la CPU (<1 o >32767).
● El número de OB no direcciona ningún OB de alarma horaria.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

2651

Instrucciones
4.1 Instrucciones

Parámetro STATUS
Si aparece un error (véase parámetro RET_VAL), en el parámetro STATUS se muestra "0".
Bit

Valor

Significado

0

Siempre
"0"

Irrelevante

1

0

La alarma horaria está habilitada.

1

La alarma horaria está bloqueada.

0

La alarma horaria no está activada o ha expirado.

1

La alarma horaria está activada.

0

El OB con el número de OB indicado en el parámetro OB_NR no existe.

1

El OB con el número de OB indicado en el parámetro OB_NR existe.

0

La base de la alarma horaria es la hora del sistema

1

La base de la alarma horaria es la hora local

2
4
6
Otros

Siempre "0"

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para funciones de alarma horaria
(Página 2652).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Ejemplo de programa para funciones de alarma horaria
Introducción
En el ejemplo siguiente se leerá el estado de un OB de alarma horaria (OB10) y se
establecerán el tiempo de inicio y la frecuencia de llamada. Una vez se haya iniciado el OB10,
volverá a desactivarse el OB10.
El OB10 tiene los siguientes ajustes predeterminados:

2652

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Requisitos
Para almacenar los datos es preciso crear 13 variables y una estructura en un bloque de datos
global.

Interconectar parámetro: FC "SLI_itemiseStatus_TINT"
Para evaluar la información de estado se crea una FC "SLI_itemiseStatus_TINT".
En ella se crean las siguientes variables locales.

Para todos los bits relevantes se crean interconexiones.
Segmento 1:

Segmento 2:

Programación del PLC
Manual de programación y manejo, 11/2019

2653

Instrucciones
4.1 Instrucciones

Segmento 3:

Segmento 4:

Segmento 5:

Interconectar parámetro: FC "SLI_retrievetime_TINT"
Para leer la fecha (hora del sistema) y definir el tiempo de inicio del OB10 se crea una FC
"SLI_retrievetime_TINT". En la FC se crean las siguientes variables locales.

Segmento 1: Los parámetros se interconectan del siguiente modo. "RD_SYS_T" lee la hora del
sistema. Mediante "T_ADD" se agregan 5 minutos a la hora del sistema.

2654

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Interconectar parámetro: FB "SLI_FB_SET_TINT"
Para llamar las instrucciones debe crearse un FB ("SLI_FB_SET_TINT"). En el FB
"SLI_FB_SET_TINT" se crean las siguientes variables locales.

Segmento 1: Los parámetros de la instrucción "QRY_TINT" se interconectan del siguiente
modo.

Segmento 2: La FC "SLI_retrievetime_TINT" se llama en el segmento 2 del FB.

Segmento 3: Los parámetros de la instrucción "SET_TINT" se interconectan del siguiente
modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2655

Instrucciones
4.1 Instrucciones

Segmento 4: Los parámetros de la instrucción "ACT_TINT" se interconectan del siguiente
modo.

Segmento 5: Los parámetros de la instrucción "CAN_TINT" se interconectan del siguiente
modo.

Segmento 6: Los parámetros que deben restablecerse con la ejecución de "CAN_TINT" se
interconectan del siguiente modo.

Segmento 7: El parámetro de la FC "SLI_itemiseStatus_TINT" se interconecta del siguiente
modo.

2656

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Interconectar parámetros: OB10
Cree las interconexiones siguientes en el OB10.

Resultado de QRY_TINT
Mediante el parámetro de entrada OB_NR ("obNbr") se notifica a las instrucciones el número
del OB que debe llamarse (OB10).
Segmento 1:
Si el contacto NA ("executeQry") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"QRY_TINT" y se leen los datos del OB10. El parámetro de salida STATUS ("#statWord")
indica el estado del OB10. En el parámetro de salida RET_VAL ("returnValueQry") se indica
que la ejecución se ha realizado sin errores.

El valor de la variable "#statWord" se refleja en la estructura "itemiseStatus":

Programación del PLC
Manual de programación y manejo, 11/2019

2657

Instrucciones
4.1 Instrucciones

Resultado de SET_TINT
Segmento 3: Si el contacto NA ("executeSet") devuelve el estado lógico "TRUE", se ejecuta la
instrucción "SET_TINT". Mediante el parámetro de entrada SDT ("startDateTime") se
transfiere el tiempo de inicio definido (ver el segmento 2) al OB10. En el parámetro de entrada
PERIOD ("periodOfExecute") está almacenada la frecuencia de llamada "cada minuto" (valor
"16#0201").
En el parámetro de salida RET_VAL ("returnValueSet") se indica que la ejecución se ha
realizado sin errores.
Con la ejecución de SET_TINT, la bobina ("executeAct") se pone a "TRUE" y la instrucción
"ACT_TINT" se ejecuta en el segmento 4.

Resultado de ACT_TINT
Segmento 4: La instrucción "ACT_TINT" activa el OB10. En el parámetro de salida RET_VAL
("returnValueAct") se indica que la ejecución se ha realizado sin errores. Mediante la
desactivación ("executeSet") en el estado lógico "TRUE" finaliza automáticamente la
ejecución de la instrucción "SET_TINT" y, por consiguiente, también la de la instrucción
"ACT_TINT".
Nota
Tras la ejecución de la instrucción "SET_TINT", el OB10 conserva los nuevos datos de llamada
hasta que se produce un STOP de la CPU. Las propiedades predeterminadas del OB10 no se
ven influidas por la ejecución de la instrucción "SET_TINT".

2658

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Resultado del OB10
Cada vez que se llama el OB10 se ejecuta la instrucción "ADD" y la variable "testCurrCount"
se incrementa en "1". La llamada del OB10 se produce cada minuto (de acuerdo con el valor
de "periodOfExecute").

Resultado de CAN_TINT
Segmento 5: Si el OB10 está ajustado y activado ("#statWord" tiene el valor "16#0014"), el
comparador devuelve el estado lógico "TRUE" y CAN_TINT puede ejecutarse.

Si el contacto NA ("executeCan") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"CAN_TINT". La instrucción desactiva el OB10 y borra los datos de llamada del OB10 que se
establecieron mediante SET_TINT. En el parámetro de salida RET_VAL ("returnValueCan") se
indica que la ejecución se ha realizado sin errores.
Con la ejecución de CAN_TINT, la bobina ("#statMem") se pone a "TRUE" y se ejecuta el
segmento 6.

Programación del PLC
Manual de programación y manejo, 11/2019

2659

Instrucciones
4.1 Instrucciones

Resultado del reset
Segmento 6: Si el contacto NA ("#statMem") devuelve el estado lógico "TRUE", a través de la
instrucción "MOVE" la variable "testCurrCount" se pone al valor "0". Además, mediante el
reseteador ("executeCan") en el estado lógico "TRUE" finaliza automáticamente la ejecución
de la instrucción "CAN_TINT".

Resultado de la información de estado "#statWord"
En el segmento 7 se llama la FC "SLI_itemiseStatus_TINT". Los bits significativos de la
variable "#statWord" se evalúan y se devuelven como variable booleana con nombres en texto
explícito. Si una variable de la estructura "itemiseStatus" devuelve el estado lógico "TRUE", su
enunciado es cierto.

Información adicional
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Alarma de retardo
Usar alarmas de retardo
Definición
Después de llamar la instrucción "SRT_DINT (Página 2661)", el sistema operativo genera una
alarma una vez transcurrido el tiempo de retardo parametrizado. A continuación se llama el OB
de alarma de retardo parametrizado.

Requisitos para la llamada
Para que el sistema operativo pueda llamar un OB de alarma de retardo, deben cumplirse los
siguientes requisitos:
● El OB de alarma de retardo debe haber sido activado mediante la instrucción "SRT_DINT
(Página 2661)".
● El OB de alarma de retardo no debe haber sido desactivado mediante configuración.
● El OB de alarma de retardo debe estar presente en la CPU.

Finalidad de las instrucciones "SRT_DINT", "CAN_DINT" y "QRY_DINT"
Con estas instrucciones, las alarmas de retardo se pueden
● Iniciar ("SRT_DINT (Página 2661)")
● Anular ("CAN_DINT (Página 2663)")
● Consultar ("QRY_DINT (Página 2664)").

2660

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Repercusiones en la alarma de retardo
La tabla siguiente muestra qué efectos producen las distintas situaciones en las alarmas de
retardo.
Si ...

y ...

Se inicia una alarma de re‐ La alarma de retardo ya se
ha iniciado,
tardo (llamada de
"SRT_DINT (Página 2661)")
El OB de alarma de retardo
no está presente en el mo‐
mento de la llamada,

entonces ...
Se sobrescribe la alarma de retardo; se
inicia de nuevo la alarma de retardo.
Se efectúa una entrada en el búfer de
diagnóstico y la CPU continúa funcionan‐
do.

Se ha iniciado la alarma en La llamada al OB de alarma de retardo se
un OB de arranque y el tiem‐ pospone hasta que la CPU esté en RUN.
po de retardo expira antes
de que la CPU esté en RUN,
El tiempo de retardo ha
transcurrido

Un OB de alarma de retardo
iniciado anteriormente toda‐
vía está procesándose,

El sistema operativo genera un error de
tiempo (llamada del OB 80; si el OB 80 no
está presente, la CPU continúa funcio‐
nando).

Comportamiento en rearranque completo (en caliente) o arranque en frío
En rearranque completo (en caliente) o arranque en frío, se borran todos los ajustes de alarma
de retardo especificados en el programa de usuario mediante instrucciones.

Inicio en un OB de arranque
Una alarma de retardo puede iniciarse en un OB de arranque. Para llamar el OB de alarma de
retardo deben cumplirse dos condiciones:
● El tiempo de retardo ha expirado.
● La CPU está en el estado operativo RUN.
Si el tiempo de retardo ha expirado y la CPU todavía no se encuentra en el estado operativo
RUN, la llamada del OB de alarma de retardo se pospone hasta que la CPU se encuentre en
dicho estado operativo. Tras ello, el OB de alarma de retardo se llama antes de la primera
instrucción en el OB Main [OB 1].

SRT_DINT: Iniciar alarma de retardo
Descripción
La instrucción "SRT_DINT" inicia una alarma de retardo que llama un OB de alarma de retardo
una vez transcurrido el tiempo de retardo especificado en el parámetro DTIME. El OB de
alarma de retardo se ejecuta una vez para la alarma de retardo.

Programación del PLC
Manual de programación y manejo, 11/2019

2661

Instrucciones
4.1 Instrucciones
Si la alarma de retardo no se ha ejecutado aún y se llama de nuevo la instrucción "SRT_DINT",
se borra la alarma de retardo existente y se inicia una nueva alarma de retardo.
Nota
Tiempo de retardo
Si el tiempo de retardo utilizado es menor o igual que el tiempo de ciclo de CPU utilizado
actualmente y se llama cíclicamente a SRT_DINT, el OB de alarma de retardo se ejecuta con
cada ciclo de la CPU.
Asegúrese de elegir un tiempo de retardo mayor que el tiempo de ciclo de la CPU.
En el parámetro SIGN se puede indicar un identificador específico de usuario para señalizar el
inicio de la alarma de retardo. Los valores de los parámetros DTIME y SIGN se visualizan en
la información de arranque del bloque de organización llamado.

Precisión
El tiempo entre la llamada de la instrucción "SRT_DINT" y el arranque del OB de alarma de
retardo es como máximo un milisegundo superior al tiempo de retardo parametrizado, siempre
y cuando no ocurran eventos de interrupción que retarden la llamada.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SRT_DINT":
Parámetro

Declaración

Tipo de datos

Área de memoria

OB_NR

Input

OB_DELAY
(INT)

I, Q, M, D, L o constante Número del OB que se ejecuta tras un
tiempo de retardo

Descripción

DTIME

Input

TIME

I, Q, M, D, L o constante Tiempo de retardo (de 1 a 60000 ms)
Para alcanzar tiempos más prolongados,
es posible utilizar p. ej. un contador en un
OB de alarma de retardo.

SIGN

Input

WORD

I, Q, M, D, L o constante Identificación que aparece en la informa‐
ción de evento de arranque al llamar el
OB de alarma de retardo.

RET_VAL

Return

INT

I, Q, M, D, L

Estado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error* Descripción
(W#16#...)
0000

Ningún error

8090

Parámetro erróneo OB_NR

8091

Parámetro erróneo DTIME

2662

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error* Descripción
(W#16#...)
Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para funciones de alarma de retardo
(Página 2665).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

CAN_DINT: Anular alarma de retardo
Descripción
La instrucción anula una alarma de retardo iniciada y, con ello, también la llamada del OB de
alarma de retardo que debe ejecutarse una vez transcurrido el tiempo de retardo
parametrizado. El número del bloque de organización cuya llamada debe anularse se
especifica en el parámetro OB_NR.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "CAN_DINT":
Parámetro

Declaración

Tipo de datos

Área de memoria

OB_NR

Input

OB_DELAY
(INT)

I, Q, M, D, L o constante Número del OB cuya llamada debe anu‐
larse

Descripción

RET_VAL

Return

INT

I, Q, M, D, L

Estado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2663

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
Código de error* Descripción
(W#16#...)
0000

Ningún error

8090

Parámetro erróneo OB_NR

80A0

No se ha iniciado la alarma de retardo.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para funciones de alarma de retardo
(Página 2665).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

QRY_DINT: Consultar estado de una alarma de retardo
Descripción
La instrucción "QRY_DINT" permite consultar el estado de una alarma de retardo.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "QRY_DINT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OB_NR

Input

OB_DELAY
(INT)

I, Q, M, D, L o cons‐
tante

Número de OB cuyo estado debe consultarse.

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecución de
la instrucción, el parámetro actual de
RET_VAL contendrá un código de error. En el
parámetro STATUS se muestra "0" como valor.

STATUS

Output

WORD

I, Q, M, D, L

Estado de la alarma de retardo; véase la si‐
guiente tabla.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Bit

Valor

Significado

0

0

Irrelevante

1

0

La alarma de retardo está habilitada por el sistema operativo.

1

Alarma de retardo bloqueada.

2664

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Bit

Valor

Significado

2

0

Alarma de retardo no activada o expirada.

1

Alarma de retardo activada.

3

-

-

4

0

El OB de alarma de retardo con el número indicado no existe.

1

El OB de alarma de retardo con el número indicado existe.

Otros bits

Siempre "0"

Parámetro RET_VAL
Código de error*

Descripción

(W#16#...)
0000

No se ha producido ningún error.

8090

Indicación errónea en el parámetro OB_NR

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para funciones de alarma de retardo
(Página 2665).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Ejemplo de programa para funciones de alarma de retardo
Introducción
En el ejemplo siguiente se leerá el estado de un OB de alarma de retardo (OB20), se ajustará
un tiempo de retardo y se iniciará o desactivará el OB20.

Programación del PLC
Manual de programación y manejo, 11/2019

2665

Instrucciones
4.1 Instrucciones

Requisitos
Para almacenar los datos es preciso crear diez variables y una estructura en un bloque de
datos global.

Interconectar parámetro: FC "SLI_itemiseStatus_DINT"
Para evaluar la información de estado se crea una FC "SLI_itemiseStatus_DINT".
En ella se crean las siguientes variables locales.

Para todos los bits relevantes se crean interconexiones.
Segmento 1:

Segmento 2:

2666

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 3:

Interconectar parámetro: FB "SLI_FB_SRT_DINT"
Para llamar las instrucciones debe crearse un FB "SLI_FB_SRT_DINT". En el FB
"SLI_FB_SRT_DINT" se crean las siguientes variables locales.

Segmento 1: Los parámetros de la instrucción "QRY_DINT" se interconectan del siguiente
modo.

Segmento 2: Los parámetros de la instrucción "SRT_DINT" se interconectan del siguiente
modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2667

Instrucciones
4.1 Instrucciones

Segmento 3: Los parámetros de la instrucción "CAN_DINT" se interconectan del siguiente
modo.

Segmento 4: Los parámetros que deben restablecerse con la ejecución de "CAN_DINT" se
interconectan del siguiente modo.

Segmento 5: El parámetro de la FC "SLI_itemiseStatus_DINT" se interconecta del siguiente
modo.

El FB "SLI_FB_SRT_DINT" se llama en un OB de ciclo (OB1).

2668

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Interconectar parámetros: OB20
Cree las interconexiones siguientes en el OB20.

Resultado de QRY_DINT
Mediante el parámetro de entrada OB_NR ("obNbr") se notifica a las instrucciones el número
del OB que debe llamarse (OB20).
Segmento 1:
Si el contacto NA ("executeQry") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"QRY_DINT" y se leen los datos del OB20. El parámetro de salida STATUS ("#statWord")
indica el estado del OB20. En el parámetro de salida RET_VAL ("returnValueQry") se indica
que la ejecución se ha realizado sin errores.

El valor de la variable "#statWord" se refleja en la estructura "itemiseStatus":

Programación del PLC
Manual de programación y manejo, 11/2019

2669

Instrucciones
4.1 Instrucciones

Resultado de SRT_DINT
Segmento 2: Si el contacto NA ("executeSrt") devuelve el estado lógico "TRUE", se ejecuta la
instrucción "SRT_DINT". Mediante el parámetro de entrada DTIME ("delayTime") se transfiere
el tiempo de retardo (6 s) al OB20 y se activa el OB20.
Nota
A partir del momento de activación del OB20 comienza a contar su tiempo de retardo. Después
se llama el OB20 a menos que anteriormente se le haya transferido otra vez el tiempo de
retardo en un nuevo ciclo de la CPU.
En el parámetro de entrada SIGN ("sign") está almacenado el identificador seleccionado (valor
"16#0001") que debe emitirse al ejecutar el OB20. El identificador aparece en la información
del evento de arranque del OB20. En el parámetro de salida RET_VAL ("returnValueSrt") se
indica que la ejecución se ha realizado sin errores.
Si después de procesarse correctamente SRT_DINT el contacto NA ("executeSrt") devuelve
el estado lógico "FALSE", al OB20 no se le transfiere de nuevo el tiempo de retardo. Una vez
transcurrido el tiempo de retardo se ejecuta el OB20 una sola vez.
Nota
El comportamiento que hemos explicado del OB20 en combinación con el parámetro EN solo
se aplica si el tiempo de ciclo utilizado de la CPU es menor que el tiempo de retardo del OB20.

Resultado del OB20
Cuando se llama el OB20 se ejecuta la instrucción "ADD" y la variable "testCurrCount" se
incrementa en "1". El OB20 solo se llama una vez tras finalizar el tiempo de retardo definido
mediante SRT_DINT. Tras su llamada, el OB20 vuelve a estar en estado "desactivado".

2670

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Resultado de CAN_DINT
Segmento 3: Mientras el OB20 esté ajustado y activado ("#statWord" tiene el valor "16#0014"),
el comparador devuelve el estado lógico "TRUE" y CAN_DINT puede ejecutarse.

Si el contacto NA ("executeCan") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"CAN_DINT". La instrucción desactiva el OB20 y borra los datos de llamada del OB20.
En el parámetro de salida RET_VAL ("returnValueCan") se indica que la ejecución se ha
realizado sin errores.
Con la ejecución de CAN_DINT, la bobina ("#statMem") se pone a "TRUE" y se ejecuta el
segmento 4.

Resultado del reset
Segmento 4: Si el contacto NA ("#statMem") devuelve el estado lógico "TRUE", a través de la
instrucción "MOVE" la variable "testCurrCount" se pone al valor "0". Además, mediante el
reseteador ("executeCan") en el estado lógico "TRUE" finaliza automáticamente la ejecución
de la instrucción "CAN_DINT".

Resultado de la información de estado "#statWord"
En el segmento 7 se llama la FC "SLI_itemiseStatus_DINT". Los bits significativos de la
variable "#statWord" se evalúan y se devuelven como variable booleana con nombres en texto
explícito. Si una variable de la estructura "itemiseStatus" devuelve el estado lógico "TRUE", su
enunciado es cierto.

Código del programa
Encontrará información adicional y el código del programa para el ejemplo anterior
aquí: Sample Library for Instructions (Página 615).

Programación del PLC
Manual de programación y manejo, 11/2019

2671

Instrucciones
4.1 Instrucciones

Eventos de errores síncronos
Enmascarar eventos de errores sincrónicos
Introducción
Los eventos de errores sincrónicos son eventos de error de programación y acceso. Estos
eventos de error se producen cuando se emplean en la programación áreas o números de
operando erróneos o direcciones erróneas. Enmascarar estos eventos de error significa lo
siguiente:
● Los eventos de error enmascarados no desencadenan ningún OB de error y no provocan
ninguna reacción sustitutiva.
● La CPU "anota" en un registro de estado de eventos los errores enmascarados que se han
producido.
Para enmascarar errores se debe llamar la instrucción "MSK_FLT (Página 2678)".
Desenmascarar eventos de error significa anular un enmascaramiento efectuado
anteriormente y borrar el bit correspondiente en el registro de estado de eventos de la clase de
prioridad actual. El enmascaramiento se anula
● llamando la instrucción "DMSK_FLT (Página 2679)".
● cuando ha terminado la clase de prioridad actual.
Si se produce un evento de error después de ser desenmascarado, el sistema operativo inicia
el correspondiente OB de error.
Los eventos de error enmascarados y detectados se pueden leer con la instrucción
"READ_ERR (Página 2680)".
Nota
Independientemente de que estén enmascarados o desenmascarados, con el S7-1500 los
eventos de error se registran en el búfer de diagnóstico y se enciende el LED de error de grupo
de la CPU.

2672

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Tratamiento de errores en general
Cuando se producen errores de programación y acceso a la periferia en un programa de
usuario, puede reaccionarse ante ello de diferentes maneras:
● Se puede programar un OB de error, que el sistema operativo llamará cuando se produzca
un evento de error relevante.
● Se puede bloquear la llamada al OB de error por separado para cada clase de prioridad. Si
se produce un error relevante en la clase de prioridad bloqueada, la CPU no pasa a STOP.
La CPU guarda en un registro de estado de eventos los errores que se producen. Sin
embargo, esta entrada del registro no permite saber cuándo y cuántas veces se ha
producido el error en cuestión.
(YHQWRGHHUURUV¯QFURQR

1R

(UURUHQPDVFDUDGR"

6¯

/ODPDGDGHXQ2%GH
HUURU 6LHO2%GHHUURUQR
HVW£SURJUDPDGROD&38
SDVDD6723

%ORTXHRGHODOODPDGDGH
XQ2%GHHUURU 6LVH
SURGXFHXQHUURUOD&38
QRSDVDD6723

(QHO2%HVW£SURJUDPD
GDODUHDFFLµQGHVHDGD
DQWHXQHUURU

(QHOUHJLVWURGHHVWDGR
GHHYHQWRVVHLQWURGXFH
XQHYHQWRGHHUURU

Los eventos de errores síncronos están asignados a un determinado patrón de bits, la máscara
de error. Esta máscara de error se reproduce también en los parámetros de entrada y salida
de las instrucciones "MSK_FLT (Página 2678)", "DMSK_FLT (Página 2679)" y "READ_ERR
(Página 2680)".
En los eventos de errores síncronos se distingue entre los errores de programación y los de
acceso, que pueden enmascararse con dos máscaras de error distintas. Encontrará las
correspondientes máscaras de error en las siguientes imágenes.

Programación del PLC
Manual de programación y manejo, 11/2019

2673

Instrucciones
4.1 Instrucciones

Máscara de error de programación
La siguiente imagen muestra el patrón de bits de la máscara de error para errores de
programación. La máscara para errores de programación se encuentra en los parámetros
"PRGFLT_..." (ver a continuación "Error de programación, palabra menos significativa" o "Error
de programación, palabra más significativa").

3DODEUDPHQRV ; ; ; ; ; ;
VLJQLILFDWLYD

 1|GHELW

 

;
(UURUGHFRQYHUVLµQ%&'
(UURUGHORQJLWXGGH£UHDDOOHHU
(UURUGHORQJLWXGGH£UHDDOHVFULELU
(UURUGH£UHDDOOHHU
(UURUGH£UHDDOHVFULELU
(UURUGHQ¼PHURGHWHPSRUL]DGRU
(UURUGHQ¼PHURGHFRQWDGRU
(UURUGHDOLQHDFLµQDOOHHU
(UURUGHDOLQHDFLµQDOHVFULELU





3DODEUDP£V
VLJQLILFDWLYD

 1|GHELW

; ; ; ;

;

(UURUGHHVFULWXUDEORTXHGHGDWRV
(UURUGHGDWRVEORTXHGHGDWRVGHLQVWDQFLD
(UURUGHQ¼PHURGHEORTXH'%
(UURUGHQ¼PHURGHEORTXH',
(UURUGHQ¼PHURGHEORTXH)&
(UURUGHQ¼PHURGHEORTXH)%
'%QRFDUJDGR
)&QRFDUJDGR
6)&QRFDUJDGR
)%QRFDUJDGR
6)%QRFDUJDGR
/H\HQGD

; 1RUHOHYDQWH

Los bits "x" no relevantes para los parámetros de entrada y salida de las instrucciones
"MSK_FLT (Página 2678)", "DMSK_FLT (Página 2679)" y "READ_ERR (Página 2680)" se
ponen a "0".

2674

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Máscara de errores de acceso
La siguiente imagen muestra el patrón de bits de la máscara de errores de acceso. La máscara
de errores de acceso se encuentra en los parámetros ACCFLT_...

 
3DODEUD
; ; ; ; ; ; ; ; ; ; ; ;
PHQRV
VLJQLILFDWLYD

 1|GHELW
; ;
(UURUGHDFFHVRDODSHULIHULDDOOHHU
(UURUGHDFFHVRDODSHULIHULDDOHVFULELU



 1|GHELW
3DODEUD
P£V
; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
VLJQLILFDWLYD

/H\HQGD

; LUUHOHYDQWH

Ejemplo: la siguiente figura muestra el aspecto de la palabra menos significativa de la máscara
de errores de acceso con todos los errores enmascarados.
● Como parámetro de entrada para "MSK_FLT (Página 2678)"
● Como parámetro de salida para "MSK_FLT (Página 2678)"
3DU£PHWUR
GHHQWUDGD



 

 1|GHELW

               
(UURUHVHQPDVFDUDGRV


3DU£PHWUR
GHVDOLGD

/H\HQGD

 

 1|GHELW

; ; ; ; ; ; ; ; ; ; ; ;   ; ;
(UURUHVHQPDVFDUDGRV

;

1RUHOHYDQWH



1RHQPDVFDUDGRV



(QPDVFDUDGRV

Programación del PLC
Manual de programación y manejo, 11/2019

2675

Instrucciones
4.1 Instrucciones

Error de programación, palabra menos significativa
La tabla siguiente contiene los errores que están asignados a la palabra menos significativa de
la máscara para errores de programación. Los distintos errores se muestran emparejados con
sus posibles causas.
Error

ID de evento
(W#16#...)

Causa posible del error

BCD - Error de conversión

2521

El error que se debe convertir no es un número BCD (p. ej. 5E8).

Error de longitud de área durante
lectura

2522

Un operando direccionado no se encuentra por completo dentro del área
de operandos posible.
Ejemplo: Debe leerse MW 320, aunque el área de marca solo ocupa 256
bytes.

Error de longitud de área durante
escritura

2523

Un operando direccionado no se encuentra por completo dentro del área
de operandos posible.
Ejemplo: Debe escribirse un valor en MW 320, aunque el área de marca
solo ocupa 256 bytes.

Error de área durante lectura

2524

En un direccionamiento indirecto interárea se ha especificado una iden‐
tificación de área errónea para el operando.
Ejemplo:
● Correcto: LAR1 P#E 12.0
L W[AR1, P#0.0]
● Erróneo: LAR1 P#12.0
L W[AR1, P#0.0] Con esta operación se notifica el error de área.

Error de área durante escritura

2525

En un direccionamiento indirecto interárea se ha especificado una iden‐
tificación de área errónea para el operando.
Ejemplo:
● Correcto: LAR1 P#E 12.0
T W[AR1, P#0.0]
● Erróneo: LAR1 P#12.0
T W[AR1, P#0.0] Con esta operación se notifica el error de área.

Error de número de temporizador
(no implementado en el S7-1500)

2526

Se accede a un temporizador no existente.
Ejemplo:
● SI T [MW 0] con MW 0 = 129; se solicita iniciar el temporizador 129
aunque solo existen 128 temporizadores.

Error de número de contador (no
implementado en el S7-1500)

2676

2527

Se accede a un contador no existente.
● Ejemplo: CU C [MW 0] con MW 0 = 600; se accede al contador 600
aunque solo existen 512 contadores.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Error

ID de evento
(W#16#...)

Error de alineación durante lectura 2528

Causa posible del error
Se direcciona un operando de byte, palabra o palabra doble con una
dirección de bit ≠ 0.
Ejemplo:
● Correcto: LAR1 P#M12.0
L B[AR1, P#0.0]
● Erróneo: LAR1 P#M12.4
L B[AR1, P#0.0]

Error de alineación durante escri‐
tura

2529

Se direcciona un operando de byte, palabra o palabra doble con una
dirección de bit ≠ 0.
Ejemplo:
● Correcto: LAR1 P#M12.0
T B[AR1, P#0.0]
● Erróneo: LAR1 P#M12.4
T B[AR1, P#0.0]

Error de programación, palabra más significativa
La tabla siguiente contiene los errores que están asignados a la palabra más significativa de
la máscara para errores de programación. Los distintos errores se muestran emparejados con
sus posibles causas.
Error

ID de evento
(W#16#...)

Causa posible del error

Error de escritura bloque de datos 2530

El bloque de datos en el que se escribe está protegido contra escritura.

Error de datos bloque de datos de
instancia

2531

El bloque de datos de instancia en el que se escribe está protegido contra
escritura.

Error de número de bloque DB

2532

El número del bloque de datos excede el número máximo admisible.

Error de número de bloque DI

2533

El número del bloque de datos de instancia excede el número máximo
admisible.

Error de números de bloque FC

2534

El número de una función (FC) invocada excede el número máximo ad‐
misible.

Error de número de bloque FB

2535

El número de un bloque de función (FB) invocado excede el número
máximo admisible.

DB no cargado

253A

El bloque de datos no está cargado.

Instrucción no cargada

253C a 253F La instrucción que se desea llamar no está cargada.

Programación del PLC
Manual de programación y manejo, 11/2019

2677

Instrucciones
4.1 Instrucciones

Error de acceso
La tabla siguiente contiene los errores que están asignados a la máscara de errores de acceso.
Los distintos errores se muestran emparejados con sus posibles causas.
Error

ID de evento
(W#16#...)

Causa posible del error

Error de acceso a la periferia al
leer

2942

● La dirección del área de periferia no tiene asignado ningún módulo de
señales.

Error de acceso a periferia al es‐
cribir

2943

● El acceso a dicha área de periferia no se ha acusado dentro del
tiempo de vigilancia de módulo ajustado (retardo de acuse).

MSK_FLT: Enmascarar eventos de error síncrono
Descripción
Esta instrucción permite controlar la reacción de la CPU ante eventos de errores sincrónicos.
Para ello se enmascaran los correspondientes eventos de errores sincrónicos (para las
máscaras de error, ver Enmascarar eventos de errores sincrónicos (Página 2672)). Llamando
a "MSK_FLT" se enmascaran los eventos de errores sincrónicos en la clase de prioridad actual.
Si en los parámetros de entrada se ajustan a "1" algunos bits de las máscaras de errores
sincrónicos, los otros bits, ya ajustados anteriormente, mantienen el valor "1". Así se obtienen
nuevas máscaras de error que pueden leerse a través de los parámetros de salida. Los
eventos de errores sincrónicos enmascarados por el usuario no llaman ningún OB, sino que
únicamente se consignan en un registro de estado de eventos. El registro de estado de
eventos se lee con la instrucción "READ_ERR (Página 2680)".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "MSK_FLT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

PRGFLT_SET_MASK

Input

DWORD

I, Q, M, D, L o constante Errores de programación que de‐
ben enmascararse

ACCFLT_SET_MASK

Input

DWORD

I, Q, M, D, L o constante Errores de acceso que deben en‐
mascararse

RET_VAL

Return

INT

I, Q, M, D, L

Información de error

PRGFLT_MASKED

Output

DWORD

I, Q, M, D, L

Errores de programación enmas‐
carados

ACCFLT_MASKED

Output

DWORD

I, Q, M, D, L

Errores de acceso enmascarados

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

2678

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
Código de error* Descripción
(W#16#...)
0000

Ninguno de los errores estaba ya enmascarado.

0001

Por lo menos uno de los errores estaba ya enmascarado. Sin embargo, los otros errores se enmascaran.

-

Información de error general
Consulte también: Consultar ID de error localmente mediante GetErrorID (Página 1982)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa con eventos de errores síncronos.
(Página 2682).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Consulte también
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Cambiar formatos de visualización en el estado del programa (Página 8529)

DMSK_FLT: Desenmascarar eventos de error síncrono
Descripción
Esta instrucción se utiliza para desenmascarar los eventos de error enmascarados con
"MSK_FLT (Página 2678)". Para ello deben ajustarse a "1" en los parámetros de entrada los
bits correspondientes de las máscaras de error. Llamando a "DMSK_FLT" se desenmascaran
los correspondientes eventos de errores sincrónicos de la clase de prioridad actual. Al mismo
tiempo se borran las entradas consultadas en el registro de estado de eventos. Las nuevas
máscaras de error se leen a través de los parámetros de salida.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DMSK_FLT":
Parámetro

Declaración

Tipo de datos

Área de memoria

PRGFLT_RE‐
SET_MASK

Input

DWORD

I, Q, M, D, L o constante Errores de programación que deben
desenmascararse

ACCFLT_RE‐
SET_MASK

Input

DWORD

I, Q, M, D, L o constante Errores de acceso que deben desen‐
mascararse

RET_VAL

Return

INT

I, Q, M, D, L

Programación del PLC
Manual de programación y manejo, 11/2019

Descripción

Información de error

2679

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

PRGFLT_MAS‐
KED

Output

DWORD

I, Q, M, D, L

Errores de programación todavía en‐
mascarados

ACCFLT_MAS‐
KED

Output

DWORD

I, Q, M, D, L

Errores de acceso todavía enmascara‐
dos

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error*
(W#16#...)

Descripción

0000

Se han desenmascarado todos los errores especificados.

0001

Por lo menos uno de los errores no estaba enmascarado. Sin embargo, los otros errores se desen‐
mascaran.

-

Información de error general
Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 1982)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa con eventos de errores síncronos.
(Página 2682).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

READ_ERR: Leer registro de estado de eventos
Descripción
Esta instrucción permite leer el registro de estado de eventos. El registro de estado de eventos
tiene una estructura equivalente a la de las máscaras de errores de programación y acceso.
Estas pueden programarse como parámetros de entrada con "MSK_FLT (Página 2678)" y
"DMSK_FLT (Página 2679)".
En los parámetros de entrada se especifican los eventos de errores sincrónicos que se desean
consultar en el registro de estado de eventos. Llamando "READ_ERR" se leen (y al mismo
tiempo se borran) las entradas deseadas del registro de estado de eventos.
En el registro de estado de eventos se puede averiguar cuáles de los errores sincrónicos
enmascarados se han producido al menos una vez en la clase de prioridad actual. Un bit
activado significa que el error sincrónico correspondiente ha aparecido por lo menos una vez.

2680

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "READ_ERR":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

PRGFLT_QUERY

Input

DWORD

I, Q, M, D, L o constante Consulta de los errores de programa‐
ción

ACCFLT_QUERY

Input

DWORD

I, Q, M, D, L o constante Consulta de los errores de acceso

RET_VAL

Return

INT

I, Q, M, D, L

Información de error

PRGFLT_CLR

Output

DWORD

I, Q, M, D, L

Errores de programación que se han
producido

ACCFLT_CLR

Output

DWORD

I, Q, M, D, L

Errores de acceso que se han produci‐
do

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de error*

Descripción

(W#16#...)
0000

Todos los errores consultados están enmascarados.

0001

Por lo menos uno de los errores consultados no está enmascarado.

-

Información de error general
Consulte también: Consultar ID de error localmente mediante GetErrorID (Página 1982)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa con eventos de errores síncronos.
(Página 2682).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Consulte también
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Cambiar formatos de visualización en el estado del programa (Página 8529)

Programación del PLC
Manual de programación y manejo, 11/2019

2681

Instrucciones
4.1 Instrucciones

Ejemplo de programa con eventos de errores síncronos.
Introducción
En el ejemplo siguiente se enmascaran eventos de errores síncronos (errores de programa)
mediante la instrucción "MSK_FLT", se desenmascara una parte de los eventos de errores
síncronos mediante la instrucción "DMSK_FLT" y se lee el registro de estado de eventos
mediante la instrucción "READ_ERR". Si el error de programa no está enmascarado, se llama
un OB de error de programa.

Almacenamiento de datos
Para almacenar los datos deben crearse en un bloque de datos global las estructuras y
variables siguientes.
● Variables para MSK_FLT:

● MSK_FLT / Contenido de la estructura "progErrMask_Details":

Encontrará la estructura completa aquí: Enmascarar eventos de errores sincrónicos
(Página 2672)
● MSK_FLT / Contenido de la estructura "accessErrMask_Details":

● Variables para DMSK_FLT:

2682

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● Variables para READ_ERR:

La composición de las estructuras "occProgErrMask_Details" y "occAccErrMask_Details"
es similar a la de las estructuras "progErrMask_Details" y "accessErrMask_Details".
● Variables para el evento de prueba:

Interconectar parámetro: FB "SLI_FB_genErr_SyncErrEv"
Para generar un error de programa se crea un FB "SLI_FB_genErr_SyncErrEv".
En el se crean las siguientes variables locales.

En el FB se crean las interconexiones siguientes.

Programación del PLC
Manual de programación y manejo, 11/2019

2683

Instrucciones
4.1 Instrucciones

Interconectar parámetro: FC "SLI_itemiseDW_SyncErrEv"
Para reeenviar una secuencia de bits del tamaño de una DWORD debe crearse una FC
"SLI_itemiseDW_SyncErrEv".
En él se crean las siguientes variables locales (entradas y salidas de 1 a 31).
● Extracto de las entradas:

● Extracto de las salidas:

En la FC se crean, siguiendo el ejemplo del segmento 1 para las entradas y salidas, las
siguientes interconexiones.
Segmento 1:

Interconectar parámetro: FC "SLI_mask_SyncErrEv"
Para convertir las máscaras que se activarán para errores de programa y de acceso se crea
la FC "SLI_mask_SyncErrEv".
En ella se crean las siguientes variables locales.

2684

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 1:
Los parámetros de la FC "SLI_itemiseDW_SyncErrEv" se interconectan según el ejemplo
siguiente.

Encontrará la estructura completa de los errores de programa ("progErrMask_Details") aquí:
Enmascarar eventos de errores sincrónicos (Página 2672).
Segmento 2:
El bit 2 de la DWORD de los errores de acceso se interconecta del siguiente modo.

Segmento 3:
El bit 3 de la DWORD de los errores de acceso se interconecta del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2685

Instrucciones
4.1 Instrucciones

Interconectar parámetro: FC "SLI_occured_SyncErrEv"
Para convertir errores de programa o de acceso leídos debe crearse la FC
"SLI_occured_SyncErrEv".
En ella se crean las siguientes variables locales.

Segmento 1:
Los parámetros de la FC "SLI_itemiseDW_SyncErrEv" se interconectan según el ejemplo
siguiente.

Encontrará la estructura completa de los errores de programa ("occProgErrMask_Details")
aquí: Enmascarar eventos de errores sincrónicos (Página 2672).
Segmento 2:
El bit 2 de la DWORD de los errores de acceso se interconecta del siguiente modo.

2686

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 3:
El bit 3 de la DWORD de los errores de acceso se interconecta del siguiente modo.

Interconectar parámetro: OB "SLI_peOB_SyncErrEV"
En caso de un error de programa no enmascarado debe crearse el OB
"SLI_peOB_SyncErrEV".
Segmento 1:
En el OB se crea la interconexión siguiente.

Programación del PLC
Manual de programación y manejo, 11/2019

2687

Instrucciones
4.1 Instrucciones

Interconectar parámetro: FC "SLI_FC_MSK_FLT"
Para llamar parte del programa debe crearse la FC "SLI_FC_MSK_FLT".
Segmento 1:
Los parámetros de la FC "SLI_mask_SyncErrEv" y de las variables "peOB_unmased_active",
"MSK_FLT.execute" y "maskedProgErrs" se interconectan del siguiente modo.

Segmento 2:
Los parámetros de la instrucción "MSK_FLT" se interconectan del siguiente modo.

Segmento 3:
Los parámetros de la instrucción "DMSK_FLT" se interconectan del siguiente modo.

2688

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 4:
Los parámetros de la FC "SLI_FB_genErr_SyncErrEv" se interconectan del siguiente modo.

Segmento 5:
Los parámetros de la instrucción "READ_ERR" se interconectan del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2689

Instrucciones
4.1 Instrucciones

Segmento 6:
Los parámetros de la FC "SLI_occured_SyncErrEv" se interconectan del siguiente modo.

Resultado del OB "SLI_peOB_SyncErrEv"
Si se ha activado un error de programa y no está enmascarado por un filtro, se ejecuta el OB
de error de programa "SLI_peOB_SyncErrEv".
En el segmento 1 del OB la variable "READ_ERR.peOB_unmasked_active" se ajusta a
"TRUE".

Resultado de la FC "SLI_FC_MSK_FLT"
Segmento 1 (FC "SLI_mask_SyncErrEv"):
Al llamar la FC "SLI_mask_SyncErrEv", las estructuras de errores de programa y errores de
acceso se convierten al tipo de datos DWORD ("progErrSetMask" y "accessErrSetMask").
Como el valor "TRUE" de la variable "READ_ERR.peOB_unmasked_active" se sigue
mostrando después de la llamada del OB de error de programa, es necesario restablecer el

2690

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
valor. Si la instrucción "MSK_FLT" no se ejecuta ("MSK_FLT.execute" tiene el valor "FALSE"),
se desactiva la variable "maskedProgErrs".
Segmento 2 ("MSK_FLT"):
Si el contacto NA ("MSK_FLT.execute") devuelve el estado lógico "TRUE", se ejecuta la
instrucción "MSK_FLT".
En función de las variables "progErrMask_Details" y "accessErrMask_Details", los eventos de
errores síncronos que deben controlarse están especificados:
● Con "progErrMask_Details" se indica el error de programa que debe enmascararse.
● En el ejemplo no se enmascara ningún error de acceso ("accessErrMask_Details").
Mediante los parámetros de entrada PRGFLT_SET_MASK ("MSK_FLT.progErrSetMask") y
ACCFLT_SET_MASK ("MSK_FLT.accessErrSetMask"), los eventos de errores síncronos que
deben controlarse se encuentran en el tipo de datos DWORD.
En el parámetro de salida RET_VAL ("MSK_FLT.returnValue") se indica que ninguno de los
errores está enmascarado. En los parámetros de salida "PRGFLT_MASKED"
("maskedProgErrs") y ACCFLT_MASKED ("maskedAccessErrs") se indican los eventos de
errores síncronos enmascarados actualmente.

Segmento 3 ("DMSK_FLT"):
Si el contacto NA ("DMSK_FLT.execute") devuelve el estado lógico "TRUE", se ejecuta la
instrucción "DMSK_FLT". Mediante los parámetros de entrada PRGFLT_RESET_MASK
("DMSK_FLT.progErrResetMask") y ACCFLT_RESET_MASK
("DMSK_FLT.accessErrResetMask"), los eventos de errores sincrónicos que deben
desenmascararse están depositados en el tipo de datos DWORD.
En el parámetro de salida RET_VAL ("DMSK_FLT.returnValue") se indica que se han
desenmascarado todos los errores indicados.

En los parámetros de salida "PRGFLT_MASKED" ("maskedProgErrs") y ACCFLT_MASKED
("maskedAccessErrs") se indican los eventos de errores síncronos enmascarados
actualmente.

Programación del PLC
Manual de programación y manejo, 11/2019

2691

Instrucciones
4.1 Instrucciones
Segmento 4 (FB "SLI_FB_genErr_SyncErrEv"):
Si la variable "testErrorEvent.index" devuelve un valor mayor que "10", se activa en error de
programa.
Segmento 5 ("READ_ERR"):
La instrucción "READ_ERR" lee el registro de estado del evento. Mediante los parámetros de
entrada PRGFLT_QUERY ("READ_ERR.progErrSetMask") y ACCFLT_QUERY
("READ_ERR.accessErrSetMask"), los eventos de errores síncronos que deben leerse se
encuentran en el tipo de datos DWORD.
● Caso 1 - El error de programa no se ha activado. No se han activado máscaras:
En el parámetro de salida RET_VAL ("READ_ERR.returnValue") se indica que por lo
menos uno de los errores consultados no está enmascarado.
En los parámetros de salida "PRGFLT_CLR" ("READ_ERR.occuredMskProgErrs") y
ACCFLT_CLR ("READ_ERR.occuredMskAccessErrs") se indican los eventos de errores
producidos actualmente.

● Caso 2 - El error de programa se ha activado y no está enmascarado:
MSK_FLT, DMSK_FLT están inactivos. Se ejecuta el OB de error de programa.

2692

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● Caso 3 - El error de programa activado se enmascara:
MSK_FLT está activo. DMSK_FLT y el OB de error de programa están inactivos.

Según la estructura "occProgErrMask_Details" se ha producido el siguiente error de
programa:

● Caso 4 - El error de programa activado se desenmascara:
MSK_FLT, DMSK_FLT y el OB de error de programa están activos.

Segmento 6 (FC "SLI_occured_SyncErrEv"):
Al llamar la FC "SLI_occured_SyncErrEv", los errores de programa ("occuredMskProgErrs") y
errores de acceso ("occuredMskAccessErrs") leídos se convierten en las estructuras
"occProgErrMask_Details" y "occAccErrMask_Details".

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Programación del PLC
Manual de programación y manejo, 11/2019

2693

Instrucciones
4.1 Instrucciones

Consulte también
MSK_FLT: Enmascarar eventos de error síncrono (Página 2678)
DMSK_FLT: Desenmascarar eventos de error síncrono (Página 2679)
READ_ERR: Leer registro de estado de eventos (Página 2680)

Evento de error asíncrono
DIS_IRT: Bloquear evento de interrupción
Descripción
La instrucción "DIS_IRT" permite bloquear el procesamiento de nuevos eventos de alarma y
de errores asíncronos. Bloquear significa que el sistema operativo de la CPU, al producirse un
evento de interrupción,
● ni llama un OB de alarma o un OB de error asíncrono,
● ni desencadena la reacción definida en caso de que no haya ningún OB de alarma ni ningún
OB de error asíncrono programado.
El bloqueo del procesamiento de eventos de alarma o de errores asíncronos es válido en todas
las clases de prioridad. El bloqueo solo puede eliminarse con la instrucción "EN_IRT
(Página 2696)" o con un rearranque completo (en caliente) o un arranque en frío.
Nota
Tenga en cuenta que al programar la instrucción "DIS_IRT" se descartan todas las alarmas
que se produzcan.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DIS_IRT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MODE

Input

BYTE

I, Q, M, D, L o constante Indica qué eventos de alarma y errores
asíncronos se bloquean.

OB_NR

Input

INT

I, Q, M, D, L o constante Número de OB

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la ejecu‐
ción de la instrucción, el valor de respues‐
ta contendrá un código de error.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

2694

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro MODE
MODE
(B#16#...)

Significado

00

Se bloquean todos los eventos de alarma y errores asíncronos nuevos que se produzcan (con excepción del
error de programación y del error durante el acceso directo a los datos periféricos y a los OB de Motion
Control). Asigne al parámetro OB_NR el valor "0". Se siguen registrando los eventos en el búfer de diag‐
nóstico.

01

Se bloquean todos los eventos nuevos que se produzcan de la clase de alarma indicada. Para identificar la
clase de alarma, haga lo siguiente:
● Alarmas horarias: 10
● Alarmas de retardo: 20
● Alarmas cíclicas: 30
● Alarmas de proceso: 40
● Alarmas para DPV1: 50
● Alarma de sincronismo: 60
● Alarmas de error de redundancia: 70
● Alarmas de error asíncrono: 80
Se siguen registrando los eventos en el búfer de diagnóstico.

02

Se bloquean todos los eventos nuevos que se produzcan de la alarma indicada. Para identificar la alarma se
usa el número de OB. Se siguen registrando los eventos en el búfer de diagnóstico.

Parámetro RET_VAL
Código de
error*

Descripción

(W#16#...)
0000

No se ha producido ningún error.

8090

El parámetro de entrada OB_NR contiene un valor no permitido.

8091

El parámetro de entrada MODE contiene un valor no permitido.

Información
Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)
de error gene‐
ral
* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa con DIS_IRT y EN_IRT (Página 2697).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Programación del PLC
Manual de programación y manejo, 11/2019

2695

Instrucciones
4.1 Instrucciones

EN_IRT: Habilitar evento de interrupción
Descripción
La instrucción permite habilitar el procesamiento de nuevos eventos de alarma y errores
asíncronos que se ha bloqueado anteriormente con la instrucción "DIS_IRT (Página 2694)".
Habilitar significa que el sistema operativo de la CPU, al producirse un evento de interrupción,
● llama un OB de alarma o un OB de error asíncrono
o
● dispara la reacción definida en caso de que no haya ningún OB de alarma ni ningún OB de
error asíncrono programado.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "EN_IRT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MODE

Input

BYTE

I, Q, M, D, L o constante Indica qué eventos de alarma y errores
asíncronos se habilitan (ver abajo).

OB_NR

Input

INT

I, Q, M, D, L o constante Número de OB

RET_VAL

Return

INT

I, Q, M, D, L

Si se produce un error durante la eje‐
cución de la instrucción, el valor de res‐
puesta contendrá un código de error.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro MODE
MODE

Significado

0

Se habilitan todos los eventos de alarma y errores asíncronos nuevos que se produzcan (con excepción del error
de programación y del error durante el acceso directo a los datos periféricos y a los OB de Motion Control).

1

Se habilitan todos los eventos nuevos que se produzcan de la clase de alarma indicada. Para identificar la clase
de alarma, haga lo siguiente:
● Alarmas horarias: 10
● Alarmas de retardo: 20
● Alarmas cíclicas: 30
● Alarmas de proceso: 40
● Alarmas para DPV1: 50
● Alarma de sincronismo: 60
● Alarmas de error de redundancia: 70
● Alarmas de error asíncrono: 80

2

2696

Se habilitan todos los eventos nuevos que se produzcan de la alarma indicada. Para identificar la alarma se usa
el número de OB.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
Código de error* Descripción
(W#16#...)
0000

No se ha producido ningún error.

8090

El parámetro de entrada OB_NR contiene un valor no permitido.

8091

El parámetro de entrada MODE contiene un valor no permitido.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa con DIS_IRT y EN_IRT (Página 2697).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Ejemplo de programa con DIS_IRT y EN_IRT
Introducción
En el ejemplo siguiente se bloquea el procesamiento de un OB de alarma cíclica (OB33)
mediante la instrucción "DIS_IRT" y se libera de nuevo el OB33 mediante la instrucción
"EN_IRT".

Programación del PLC
Manual de programación y manejo, 11/2019

2697

Instrucciones
4.1 Instrucciones

Almacenamiento de datos
Para almacenar los datos deben crearse en un bloque de datos global las estructuras y
variables siguientes.

OB "SLI_ciOB_AsyncEvent"
Se crea un OB "SLI_ciOB_AsyncEvent" y se observa su comportamiento al bloquear/
desbloquear.
Segmento 1: En el OB se llama la instrucción "TP" y se crean las interconexiones siguientes.

Segmento 2: La variable "testOB.execute" se desactiva del siguiente modo.

2698

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

FC "SLI_FC_AsyncEvent"
Para llamar parte del programa debe crearse la FC "SLI_FC_AsyncEvent".
En la FC se crean las siguientes variables locales.

Segmento 1: Los parámetros de la instrucción "DIS_IRT" se interconectan del siguiente modo.

Segmento 2: La variable "DIS_IRT.execute" se desactiva del siguiente modo.

Segmento 3: Los parámetros de la instrucción "EN_IRT" se interconectan del siguiente modo.

Segmento 4: La variable "EN_IRT.execute" se desactiva del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2699

Instrucciones
4.1 Instrucciones

Resultado del OB "SLI_ciOB_AsyncEvent"
Si el contacto NA ("testOB.execute") devuelve una vez el estado lógico "TRUE", se ejecuta la
instrucción "TP". Para la variable "testOB.execute" se restablece automáticamente el estado
lógico "FALSE". El valor de la variable "testTime" se incrementa hasta que se corresponda con
el valor de la variable "testTimeLimit".

Resultado de la FC "SLI_FC_AsyncEvent"
Segmento 1:
Si el contacto NA ("DIS_IRT.execute") devuelve el estado lógico "TRUE", se ejecuta la
instrucción "DIS_IRT". De acuerdo con el parámetro de entrada MODE ("DIS_IRT.mode"),
está especificado el modo de operación "2" que debe utilizarse. Según el parámetro de entrada
OB_NR ("DIS_IRT.obNbr") se direcciona el OB33 y se bloquea su procesamiento.
En el parámetro de salida RET_VAL ("DIS_IRT.returnValue") se indica que la ejecución del
ejemplo se ha realizado sin errores. El procesamiento de "DIS_IRT" se guarda en la variable
"DIS_IRT.done". Además, desactive la variable "EN_IRT.done".
El valor de la variable "testOB.testTime" ya no se incrementa. No obstante, el temporizador
CEI de la instrucción "TP" continúa contando en segundo plano.

2700

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 2:
Si el contacto NA ("#tempDIS") devuelve el estado lógico "TRUE", se desactiva la variable
"DIS_IRT.execute".
Segmento 3:
Si el contacto NA ("EN_IRT.execute") devuelve el estado lógico "TRUE", se ejecuta la
instrucción "EN_IRT". De acuerdo con el parámetro de entrada MODE ("EN_IRT.mode"), está
especificado el modo de operación "2" que debe utilizarse. Según el parámetro de entrada
OB_NR ("EN_IRT.obNbr") se direcciona el OB33 y se bloquea de nuevo su procesamiento.
En el parámetro de salida RET_VAL ("EN_IRT.returnValue") se indica que la ejecución del
ejemplo se ha realizado sin errores. El procesamiento de "EN_IRT" se guarda en la variable
"EN_IRT.done". Además, desactive la variable "DIS_IRT.done".
El valor de la variable "testOB.testTime" se sigue incrementando o variando en función del
temporizador CEI de la instrucción "TP".

Programación del PLC
Manual de programación y manejo, 11/2019

2701

Instrucciones
4.1 Instrucciones

Segmento 4:
Si el contacto NA ("#tempEN") devuelve el estado lógico "TRUE", se desactiva la variable
"EN_IRT.execute".

Código del programa
Encontrará información adicional y el código del programa para el ejemplo anterior
aquí: Sample Library for Instructions (Página 615).

Consulte también
DIS_IRT: Bloquear evento de interrupción (Página 2694)
EN_IRT: Habilitar evento de interrupción (Página 2696)

DIS_AIRT: Retardar tratamiento de eventos de alarma y errores asíncronos de mayor prioridad
Descripción
"DIS_AIRT" retarda el procesamiento de OB de alarma cuya prioridad es superior a la del
bloque de organización actual.
"DIS_AIRT" se puede llamar varias veces en un bloque de organización. El sistema operativo
cuenta las llamadas de "DIS_AIRT". Cada vez que se ejecuta "DIS_AIRT", la ejecución se
retarda aún más. Para revocar un retardo es preciso ejecutar la instrucción "EN_AIRT
(Página 2703)". El retardo de ejecución se aplica hasta que el número de ejecuciones de
"EN_AIRT (Página 2703)" sea igual al número de llamadas de "DIS_AIRT" o se haya ejecutado
el OB actual hasta el final.

2702

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Toda llamada de "DIS_AIRT" aumenta el número de retardos; el valor actual se obtiene del
parámetro RET_VAL.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DIS_AIRT":
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

RET_VAL

Return

INT

I, Q, M, D, L

Número de retardos

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Valor de retor‐ Descripción
no
n

Una vez finalizada la instrucción, "n" indica el número de retardos de procesamiento, es decir, de llamadas
de "DIS_AIRT". Utilice EN_AIRT (Página 2703) para anular los retardos.

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa con DIS_AIRT y EN_AIRT (Página 2704).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

EN_AIRT: Habilitar tratamiento de eventos de alarma y errores asíncronos de mayor prioridad
Descripción
Cuando ocurren alarmas, "EN_AIRT" habilita el procesamiento de bloques de organización
retardado por la instrucción "DIS_AIRT (Página 2702)".
Ejecutando la instrucción "EN_AIRT" se revoca el retardo de procesamiento que el sistema
operativo ha registrado en una llamada de "DIS_AIRT (Página 2702)". Para revocar todos los
retardos, el número de ejecuciones de "EN_AIRT" debe ser igual al número de llamadas de
"DIS_AIRT (Página 2702)". Ejemplo: "DIS_AIRT (Página 2702)" se ha llamado cinco veces.
Con ello, el procesamiento también se ha retardado cinco veces. Por tanto, la instrucción
"EN_AIRT" deberá ejecutarse cinco veces para poder revocar los cinco retardos.
En el parámetro RET_VAL de la instrucción "EN_AIRT" se especifica el número de retardos de
alarma aún no habilitados tras la ejecución de "EN_AIRT". Si el parámetro RET_VAL tiene el
valor "0", significa que se han revocado todos los retardos activados por "DIS_AIRT
(Página 2702)".

Programación del PLC
Manual de programación y manejo, 11/2019

2703

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "EN_AIRT":
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

RET_VAL

Return

INT

I, Q, M, D, L

Número de retardos aún programados

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Valor de retorno/ Descripción
Código de error*
(W#16#...)
n

Una vez finalizada la instrucción, "n" indica el número de retardos de procesamiento todavía no habilita‐
dos. El procesamiento de alarmas no vuelve a habilitarse hasta que n = 0.

8080

Aunque el procesamiento de la alarma ya se ha habilitado anteriormente, se ha llamado la instrucción.

Información de
error general

Consulte también: GET_ERR_ID: Consultar ID de error localmente (Página 933)

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa con DIS_AIRT y EN_AIRT (Página 2704).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Ejemplo de programa con DIS_AIRT y EN_AIRT
Introducción
En el ejemplo siguiente se retarda el procesamiento de un OB de alarma cíclica o de otros OB
de alarma de mayor prioridad mediante las instrucciones "DIS_AIRT" y "EN_AIRT". Al llamar
las instrucciones, una alarma no interrumpe un programa de prueba.
Mediante el programa de prueba se guardan datos de tiempo y de diagnóstico en una memoria
de datos.
● Para ello, en un OB de alarma cíclica se lee la hora de la CPU mediante la instrucción
"TIME_TCK", y los datos de diagnóstico mediante la instrucción "GET_DIAG".
● En un OB de alarma cíclica (OB1) se lee además la hora del sistema del reloj de la CPU
mediante la instrucción "RD_SYS_T".

2704

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Almacenamiento de datos
Para la memoria de datos, cree el tipo de datos PLC "testAIRT".

Programación del PLC
Manual de programación y manejo, 11/2019

2705

Instrucciones
4.1 Instrucciones
Para almacenar los datos deben crearse en un bloque de datos global las estructuras y
variables siguientes.
● Para "DIS_AIRT", "EN_AIRT" y el recuento de tiempo:

● Para el diagnóstico:
Nota
Buscar identificador de hardware ("laddr")
El identificador de hardware se encuentra en "Variables PLC > Constantes de sistema".
Para una CPU S7-1500: Busque "Local~Common" con el tipo de datos "HW_Submodule".
La celda "Valor" correspondiente contiene el identificador de hardware.

● Para la memoria de datos:

Interconectar parámetro: en la FC "SLI_FC_itemise_IOState_AIRT"
Para evaluar adicionalmente los datos de diagnóstico de la instrucción "GET_DIAG" debe
crearse la FC "SLI_FC_itemise_IOState_AIRT".
En la FC se crean las siguientes variables locales.

2706

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 1: Cree las interconexiones siguientes.

Programación del PLC
Manual de programación y manejo, 11/2019

2707

Instrucciones
4.1 Instrucciones

Interconectar parámetro: en el OB "SLI_ciOB_diagProg_AIRT"
Se crea un OB de alarma cíclica "SLI_ciOB_diagProg_AIRT" y se observa su comportamiento
de retardo.
En el OB se crea la siguiente variable local.

Segmento 1: En el OB se llama la instrucción "GET_DIAG" y se crean las interconexiones
siguientes.

2708

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 2: Se registra la hora de la CPU del siguiente modo y se incrementa la variable "pos"
según la siguiente condición.

Programación del PLC
Manual de programación y manejo, 11/2019

2709

Instrucciones
4.1 Instrucciones
Segmento 3: La variable "startOB_ci" se desactiva del siguiente modo.

Interconectar parámetro: en la FC "SLI_FC_saveDiag_AIRT"
Para leer la hora del sistema y agrupar datos de tiempo y de diagnóstico se debe crear la FC
"SLI_FC_saveDiag_AIRT".
En la FC se crean las siguientes variables locales.

Segmento 1: Cree las interconexiones siguientes.

Segmento 2: La variable "startOB1" se desactiva del siguiente modo.

2710

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Interconectar parámetro: en la FC "SLI_FC_delayAIRT"
Para llamar el programa de prueba es necesario crear la FC "SLI_FC_delayAIRT".
Segmento 1: Los parámetros de la instrucción "DIS_AIRT" se interconectan del siguiente
modo.

Segmento 2: La FC "SLI_FC_saveDiag_AIRT" se interconecta del siguiente modo.

Segmento 3: Los parámetros de la instrucción "EN_AIRT" se interconectan del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2711

Instrucciones
4.1 Instrucciones

Procedimiento para el arranque del escenario de prueba
Para arrancar el programa de prueba proceda del siguiente modo:
Nota
Si no desea ejecutar retardadamente el OB de alarma cíclica ("SLI_ciOB_diagProg_AIRT"),
omita los pasos 1 y 2.
1. Ponga la variable "delay.executeDel" a "TRUE".
2. Ponga la variable "delay.executeEn" a "TRUE".
3. Ponga la variable "startOB1" a "TRUE". A continuación, la variable "startOB_ci" se activa
automáticamente.
Tanto la variable "startOB1" como la variable "startOB_ci" se desactivan automáticamente
cuando se ha llenado la memoria de datos.

Procedimiento para finalizar el procesamiento de DIS_AIRT y EN_AIRT
Para cerrar el procesamiento retardado del OB de alarma cíclica
("SLI_ciOB_diagProg_AIRT"), proceda del siguiente modo:
1. Ponga la variable "delay.executeEn" a "FALSE".
2. Ponga la variable "delay.executeDel" a "FALSE".

Resultado del OB "SLI_ciOB_diagProg_AIRT"
El OB de alarma cíclica ("SLI_ciOB_diagProg_AIRT") se llama cada 100 ms y lee datos de
diagnóstico a través de la instrucción "GET_DIAG" e indica la hora de la CPU.
Si el contacto NA ("startOB_ci") devuelve el estado lógido "TRUE" y la variable "pos" devuelve
un valor mayor que "3", se incrementa la variable "pos". Si la variable "pos" devuelve el valor
"3", se desactiva la variable "startOB_ci".

Si el OB de alarma cíclica ("SLI_ciOB_diagProg_AIRT") no se ejecuta con retardo, los valores
visualizados de la memoria de datos son aproximadamente los siguientes:

2712

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Resultado de la FC "SLI_FC_delayAIRT"
Segmento 1:
Si el contacto NA ("delay.executeDel") devuelve el estado lógico "TRUE", se ejecuta la
instrucción "DIS_AIRT". Se retarda la ejecución del OB de alarma cíclica
("SLI_ciOB_diagProg_AIRT") o de un OB de alarma de mayor prioridad. En el parámetro de
salida RET_VAL ("delay.nbrOfDelays") se indica que está activo un retardo en el OB llamante
(OB1).
Segmento 2:
Si el contacto NA ("startOB1") devuelve el estado lógico "TRUE", se ejecuta el programa de
prueba de la FC "SLI_FC_saveDiag_AIRT".
En la FC "SLI_FC_saveDiag_AIRT":
Mediante la instrucción "RD_SYS_T" se lee la hora del sistema y se deposita en la memoria de
datos "dataStorage". La celda que va a utilizarse de la memoria de datos está determinada por
la variable "pos".
También se transfiere a la memoria de datos la hora de la CPU ("outCPUtimer"). Si la variable
"diag.itemiseIOState.Error" devuelve el estado lógico "TRUE", en la memoria de datos la
variable "errorHW" se pone a "TRUE".
A continuación se resuelve lo siguiente:
● Si "pos" tiene el valor "0": El valor de la variable "startOB_ci" se pone a "TRUE". De este
modo la variable "pos" puede incrementarse en el OB de alarma cíclica
("SLI_ciOB_diagProg_AIRT").
● Si "pos" tiene el valor "3": Se desactivan las variables "startOB1" y "pos".
Si el OB de alarma cíclica ("SLI_ciOB_diagProg_AIRT") se ejecuta con retardo, los valores
visualizados de la memoria de datos son aproximadamente los siguientes:

Programación del PLC
Manual de programación y manejo, 11/2019

2713

Instrucciones
4.1 Instrucciones

Segmento 3:
Si el contacto NA ("delay.executeEn") devuelve el estado lógico "TRUE", se ejecuta la
instrucción "EN_AIRT". Se habilita de nuevo la ejecución del OB de alarma cíclica
("SLI_ciOB_diagProg_AIRT") o de un OB de alarma de mayor prioridad. En el parámetro de
salida RET_VAL ("delay.nbrOfDelays") se indica que después no está activo ningún retardo en
el OB llamante (OB1). El procesamiento del ejemplo transcurre sin fallos.

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
DIS_AIRT: Retardar tratamiento de eventos de alarma y errores asíncronos de mayor prioridad
(Página 2702)
EN_AIRT: Habilitar tratamiento de eventos de alarma y errores asíncronos de mayor prioridad
(Página 2703)

2714

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

4.1.4.9

Avisos

Program_Alarm: Crear aviso de programa con valores asociados
Descripción
La instrucción "Crear aviso de programa con valores asociados" vigila una señal y genera un
aviso de programa cuando hay un cambio de señal en el parámetro SIG (en cuanto a la
definición, véase también: Introducción a la configuración de avisos (Página 8319)). Si la señal
cambia de 0 a 1, se genera un aviso de programa entrante; si la señal cambia de 1 a 0, se
genera un aviso de programa saliente. El aviso de programa se lanza de modo síncrono a la
ejecución del programa.
Al aviso de programa se pueden adjuntar hasta diez valores asociados en los parámetros SD_i
(0 ≤ i ≤10). Los valores asociados se captan en el momento del cambio de señal en el
parámetro SIG y a continuación se asignan al aviso de programa. En los apartados siguientes
encontrará más información sobre la estructura de los valores asociados: Insertar valores
asociados en los avisos (Página 8338), Ejemplos de valores asociados (Página 8342).
Todos los avisos, tanto los entrantes como los salientes, se dotan con un sello horario:
● A tal efecto, en caso de producirse un cambio de señal, se utiliza por defecto la hora de
sistema actual del PLC (valor predeterminado en el parámetro TIMESTAMP).
● Si desea un sello horario diferente a este, puede crearlo en el parámetro TIMESTAMP.
El valor de tiempo debe indicarse siempre como hora del sistema (es decir, UTC), que es
la hora que se utiliza para la sincronización horaria de toda la instalación.
● Si un aviso ha de sellarse con una hora local determinada, entonces es necesario intercalar
un bloque de conversión que convierta la hora local a la hora del sistema. Solo de esta
manera se puede garantizar que los sellos horarios se representen correctamente en el
aviso.
Para utilizar de nuevo la hora de sistema actual de la CPU, ajuste el parámetro TIMESTAMP
a su valor predeterminado (LDT#1970-01-01-00:00:00.0).

Tamaño total de los valores asociados para avisos de programa
El procedimiento de aviso de la CPU S7-1500 proporciona un máximo de 512 bytes para
valores asociados (parámetros SD) de la instrucción "Program_Alarm".
ProDiag requiere una parte de este tamaño total de los valores asociados para informaciones
internas. Así pues, en ProDiag se dispone de un máximo de 400 bytes para los tres valores
asociados posibles en el campo de texto específico.
Este tamaño se indicaba simplemente con una advertencia durante la compilación en
versiones del TIA Portal anteriores a V14. A partir del TIA Portal V14 SP1 se lleva a cabo una
comprobación más estricta. Si se excede este tamaño, durante la compilación se emite un
error con el fin de excluir escenarios de error en tiempo de ejecución. A partir de ahora, esta
comprobación ya no hace referencia al tamaño real de los parámetros SD en el momento de
llamar la instrucción "Program_Alarm", sino al tamaño máximo posible de los parámetros SD.
Por consiguiente, hay que considerar de antemano la longitud con la que se declararán las
variables de secuencias de caracteres que se transferirán, pues ocupan muchos bytes.

Programación del PLC
Manual de programación y manejo, 11/2019

2715

Instrucciones
4.1 Instrucciones

Llamada de la instrucción "Crear aviso de programa con valores asociados"
La instrucción solo puede llamarse en un bloque de función (FB). El bloque se procesa de
forma síncrona. En cuanto finaliza el bloque se dispara una alarma. Si se produce un error
durante su procesamiento, se emite un código de error.
Una vez insertada la instrucción en el FB, en la sección "Static" de la interfaz del FB se crea una
multiinstancia del tipo de datos "Program_Alarm". El nombre de la multiinstancia se puede
elegir libremente en el cuadro de diálogo que aparece. Al mismo tiempo es el nombre del aviso
de programa.
A continuación, complete los parámetros de la instrucción conforme a sus necesidades (véase
la tabla "Parámetros").

Configuración del aviso de programa
Si selecciona el nombre del aviso de programa en la sección "Static" o en el segmento del FB,
los ajustes del aviso de programa se muestran en la ventana "Propiedades". Seleccione la
categoría de aviso, la prioridad, etc. y edite el texto del aviso.
Los ajustes aquí efectuados también se pueden editar en el árbol del proyecto. Para ello, abra
en "Supervisiones y avisos del PLC" la ficha "Avisos" y, dentro de ella, la ficha "Avisos de
programa". En la tabla "Tipos de aviso" se muestran todos los avisos de programa creados
hasta el momento.

2716

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Crear aviso de programa con
valores asociados":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SIG

Input

BOOL

I, Q, M, D, L, T, C o
constante

La señal que debe vigilarse.
● Flanco de señal
ascendente: se genera
un aviso de programa
entrante
● Flanco de señal
descendente: se genera
un aviso de programa
saliente

Programación del PLC
Manual de programación y manejo, 11/2019

2717

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

TIMESTAMP

Input

LDT

M, D, L o constante Estos parámetros se utilizan
para dotar una alarma de un
sello horario que procede,
por ejemplo, de una señal de
entrada sellada de forma des‐
centralizada. El valor de tiem‐
po debe indicarse siempre
como hora del sistema (es
decir, UTC) debido a que es‐
ta hora se utiliza para la sin‐
cronización horaria de toda
la instalación.

Descripción

● "No interconectado"
significa que la hora de
sistema de la CPU se
utiliza como sello horario
para la alarma en caso de
un cambio de señal (valor
predeterminado).
● La transferencia de una
hora de sistema implica
que esta se utiliza como
sello horario para la
alarma en caso de un
cambio de señal.
Nota: si una alarma ha de se‐
llarse con una hora local de‐
terminada, será necesario in‐
tercalar un bloque de conver‐
sión que convierta la hora lo‐
cal a la hora del sistema. So‐
lo de esta manera se puede
garantizar que el sello hora‐
rio se represente correcta‐
mente en la alarma.
Nota: Al confirmar el aviso se
utiliza como sello de tiempo
siempre la hora del sistema
del PLC.
SD_i

Input

VARIANT

I, Q, M, D, L

Valor asociado n.º i (1 ≤ i ≤
10)
Puede usar como valores
asociados números binarios,
números enteros, números
en coma flotante o cadenas
de caracteres.

2718

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

Error

Output

BOOL

I, Q, M, D, L

Parámetro de estado Error
Error = TRUE significa que
se ha producido un error du‐
rante el procesamiento. La
posible causa del error se vi‐
sualiza en el parámetro Sta‐
tus.

Status

Output

WORD

I, Q, M, D, L

Parámetro de estado Status
Visualización de la informa‐
ción de error (véase "Pará‐
metros Error y Status").

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetros Error y Status
La tabla siguiente contiene toda la información de error específica que se devuelve mediante
los parámetros Error y Status.
Error

Status*

Explicación

0

0000

No hay error o la instrucción no se ejecutó porque no había cambio de flanco en
el parámetro SIG.

1

0085

Aviso del tipo "Solo información".

1

8001

Información de aviso estática no válida

1

8002

No hay información de aviso estática válida.

1

8004

Los valores asociados del aviso han alcanzado el tamaño máximo de 512 bytes.

1

8005

En el parámetro SIG hay un flanco de señal ascendente y hay un aviso sin
acusar.

1

8007

Aviso saliente sin que le preceda un aviso entrante.

1

8087

Avisos estáticos desactivados

1

8089

Aviso demasiado largo.

1

80Ax

Valor no válido en el parámetro SD_i.

1

80C1

La CPU no genera avisos en este momento, ya que hay rutinas de inicialización
en curso. (Esto sucede, p. ej., tras descargar en RUN.) Vuelva a intentarlo más
tarde.

1

80C2

Se ha enviado el número máximo de avisos permitido por unidad de tiempo.
Vuelva a intentarlo más tarde.

1

80C3

Todas las instancias de aviso dinámicas están en uso. Vuelva a intentarlo más
tarde.

1

80C4

Se emite un aviso, que no se puede sobrescribir. Vuelva a intentarlo más tarde.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecima‐
les. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte tam‐
bién".

Ejemplo
En el siguiente ejemplo se genera un aviso de programa con valor asociado para un cambio de
señal.

Programación del PLC
Manual de programación y manejo, 11/2019

2719

Instrucciones
4.1 Instrucciones
Para almacenar el valor de señal que se desea vigilar, se crea una variable en un bloque de
datos global.

La instrucción se llama en un bloque de función. Para interconectar la instrucción, cree cuatro
parámetros para el bloque de función.

Los parámetros de la instrucción se interconectan del siguiente modo.

El bloque de función se llama en un OB.

2720

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Al crear la instrucción se genera automáticamente un aviso de PLC. Abra el cuadro de diálogo
Supervisiones y avisos del PLC y seleccione el aviso que desea editar en la ficha Avisos >
Avisos de programa. En Propiedades > Ajustes básicos del aviso, cree el texto del aviso, que
debe incluir dos palabras clave.
Nota: Al hacer clic con el botón derecho en el campo de texto, se puede insertar una palabra
clave, una variable o una lista de textos.
La secuencia de caracteres "@1%s@" lee el valor del parámetro SD_1 ("#MyStaticText") y lo
emite como cadena de caracteres.
Consulte también:
● Insertar valores asociados en los avisos (Página 8338)
● Ejemplos de valores asociados (Página 8342)
● Palabras clave para textos de aviso (Página 8343)

Si el parámetro SIG ("CreateAlarm") devuelve el estado lógico "TRUE", se emite el aviso de
PLC. En el parámetro de salida STATUS ("OUTPUT_Status") se indica, mediante el valor
"0001", que se ha producido un cambio de señal. A continuación se indica que ya no se
realizan más ejecuciones (el valor es "0000"). En el parámetro SD_1 ("#MyStaticText") se
emite el valor asociado del aviso de PLC.
Puede enviarse una etiqueta de fecha/hora al parámetro TIMESTAMP. Si no está
interconectado, el parámetro TIMESTAMP emite la hora local del reloj de la CPU. En el
parámetro de salida ERROR ("OUTPUT_Error") se muestra que la instrucción se ha ejecutado
sin errores.

Programación del PLC
Manual de programación y manejo, 11/2019

2721

Instrucciones
4.1 Instrucciones

Para emitir el aviso de PLC utilice, p. ej., el servidor web de la CPU. Para poder usar el servidor
web, se requiere lo siguiente:
● El servidor web debe estar activado en la configuración de la CPU.
En el navegador de Internet se abre el servidor web (con la dirección IP de la CPU) y se inicia
sesión en el menú del servidor web. La CPU emitirá el texto de aviso mientras la señal vigilada
("CreateAlarm") devuelva el valor "TRUE".

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615)

Ejemplo
Encontrará un ejemplo de aplicación detallado en el Siemens Industry Online Support (https://
support.industry.siemens.com/cs/document/98210758?dti=0&lc=es-WW).

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)

2722

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Get_AlarmState: Emitir estado del aviso
Descripción
La instrucción "Emitir estado del aviso" devuelve el estado de un aviso de programa.
Un aviso puede tener tres posibles estados:
● Aparecido
● Desaparecido
● Acusado
La emisión del estado del aviso se refiere a un aviso de programa generado mediante la
instrucción "Crear aviso de programa con valores asociados".
La selección del aviso de programa se efectúa mediante el parámetro de entrada Alarm. En el
parámetro Alarm se indica el DB de instancia de la instrucción "Crear aviso de programa con
valores asociados".

A través del parámetro de salida AlarmState se emite el estado del aviso en un byte. El
significado de los diferentes bits se ilustra en la siguiente figura:
$6B67$7(B,1)2

9

7

7

2*

2&

$*

$&

6
















(VWDGRGHODYLVR
6 $SDUHFLGR
6 'HVDSDUHFLGR
(VWDGRGHODYLVR
$& VHDFXVµXQDDODUPDDSDUHFLGD
$* VHDFXVµXQDDODUPDGHVDSDUHFLGD
'HVERUGDPLHQWR 6LJQDO2YHUIORZ
2& GHVERUGDPLHQWRHQDYLVRVDSDUHFLGRV
2* GHVERUGDPLHQWRHQDYLVRVGHVDSDUHFLGRV
5HVHUYDGD
(VWDGRLQIRUPDFLµQGHODYLVR
9 LQIRUPDFLµQGHODYLVRQRY£OLGD
9 LQIRUPDFLµQGHODYLVRY£OLGD

Mediante los parámetros de salida Error y STATUS se indica el estado de ejecución de la
instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

2723

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Emitir estado del aviso":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

Alarm

Input

ALARM_BASE

D

Instancia de la instrucción
"Crear aviso de programa
con valores asociados"
● Alarm.Messagetype =
Alarm_AP, entonces el
bit Ac tiene el estado
lógico 0 o 1 y el bit Ag el
estado lógico 1
–

no activo: 0x86 (1000
0110)

–

activo/no acusado:
0x85 (1000 0101)

–

activo/acusado: 0x87
(1000 0111)

–

desaparecido/no
acusado: 0x84 (1000
0100)

● Alarm.Messagetype =
Notify_AP, entonces los
bits Ac y Ag tienen ambos
el estado lógico 1
–

no activo: 0x86 (1000
0110)

–

activo: 0x87 (1000
0111)

● Alarm.Messagetype =
Inforeport_AP, entonces
los bits Ac y Ag tienen
ambos el estado lógico 1
–

no activo: 0x86 (1000
0110)

–

(temporal)
activo:0x87 (1000
0111)

Si una alarma no está activa,
el bit S tiene por principio el
estado lógico 0.
AlarmState

2724

Output

BYTE

I, Q, M, D, L

Estado del aviso como mapa
de bits

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

Error

Output

BOOL

I, Q, M, D, L

Parámetro de estado
● 0: Ningún error
● 1: Se ha producido un
error al ejecutar la
instrucción.
El parámetro STATUS con‐
tiene información más deta‐
llada.

STATUS

Output

WORD

I, Q, M, D, L

Parámetro de estado
El parámetro solo está acti‐
vado durante una llamada.
Por ello, para visualizar el es‐
tado debe copiarse el STA‐
TUS en un área de datos li‐
bre.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro STATUS
Código de
error*
(W#16#...)

Explicación

8001

Instancia de aviso estática no válida

8002

ID del aviso no válida

8003

No hay avisos activos dentro de la categoría de aviso.
● Alarm_AP: la alarma ha desaparecido y está acusada.
● Notify_AP: la alarma ha desaparecido.
● Informe
El bit V se pone el estado lógico "0".

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecima‐
les. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte tam‐
bién".

Ejemplo
En el siguiente ejemplo se emite el estado de un aviso de programa.
Para almacenar los datos es preciso crear cuatro variables en un bloque de datos global.

Programación del PLC
Manual de programación y manejo, 11/2019

2725

Instrucciones
4.1 Instrucciones
La instrucción "Get_AlarmState" se llama junto con la instrucción "Program_Alarm" en un
bloque de función. Para interconectar las instrucciones, cree cuatro parámetros para el bloque
de función.

Los parámetros de las instrucciones se interconectan del siguiente modo.

El bloque de función se llama en un OB.
Al crear la instrucción "Program_Alarm" se genera automáticamente un aviso de PLC. Abra el
cuadro de diálogo Supervisiones y avisos del PLC y seleccione el aviso que desea editar en la
ficha Avisos > Avisos de programa. Cree el texto del aviso, que debe incluir dos palabras clave.
Seleccione los siguientes ajustes para el aviso.

2726

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Si el parámetro de entrada SIG ("CreateAlarm") de la instrucción "Program_Alarm" devuelve
el estado lógico "TRUE", se emite el aviso de PLC.
Con la instrucción "Get_AlarmState" sucede lo siguiente: Mediante el parámetro de entrada
ALARM se envía el aviso de PLC a la instrucción "Get_AlarmState". En el parámetro de salida
AlarmState ("AS_statusBYTE") se indica que el aviso está activo conforme a la categoría "No
Acknowledgement".
En los parámetros de salida ERROR ("outputERROR") y STATUS ("outputSTATUS") se indica
que la instrucción se ha ejecutado sin errores.

Para emitir el aviso de PLC, utilice el servidor web de la CPU.
Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615)

Ejemplo
Encontrará un ejemplo de aplicación detallado en el Siemens Industry Online Support (https://
support.industry.siemens.com/cs/document/98210758?dti=0&lc=es-WW).

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Program_Alarm: Crear aviso de programa con valores asociados (Página 2715)
Crear y editar avisos (Página 8335)

Programación del PLC
Manual de programación y manejo, 11/2019

2727

Instrucciones
4.1 Instrucciones

Gen_UsrMsg: Crear avisos de diagnóstico de usuario
Descripción
La instrucción "Gen_UsrMsg" permite generar un aviso que se introduce en el búfer de
diagnóstico.
Con el parámetro Mode se elige si debe generarse un aviso entrante o saliente:
● Si Mode = 1: se genera un aviso entrante.
● Si Mode = 2: se genera un aviso saliente.
● Independientemente de si se genera un aviso entrante o saliente, el aviso tiene siempre el
atributo "Solo información".
La entrada en el búfer de diagnóstico se crea de forma síncrona. La transmisión del aviso se
realiza de forma asíncrona.
Si al ejecutar la instrucción se produce un error, este se visualiza a través del parámetro
RET_VAL.

Contenido del aviso
El contenido del aviso se define a través de una lista de textos:
● Con el parámetro TextListID se indica la lista de textos que se desea utilizar. Para ello, abra
el cuadro de diálogo "Listas de textos de aviso PLC" del árbol del proyecto. Expanda la
columna "ID" en el cuadro de diálogo "Listas de textos". Aplique la ID en el parámetro
TextListID.
● Con el parámetro TextID se selecciona la entrada de la lista de textos que se desea escribir
en el búfer de diagnóstico. Para ello, seleccione en el cuadro de diálogo "Entradas de la lista
de textos" una entrada en la que se debe aplicar el número que figura en las columnas
"Rango de / Rango hasta" del parámetro TextID. Para ello, debe utilizarse el mismo número
para la entrada de la lista de textos "Rango de" y "Rango hasta", respectivamente.
● Encontrará más información sobre las listas de texto en: AUTOHOTSPOT

Definir valores asociados
En la entrada de la lista de textos se definen adicionalmente valores asociados que
complementan el aviso:
● Los valores asociados se definen al complementar la entrada de la lista de textos con la
siguiente información:
@<número del valor asociado><tipo de elemento><formato>@
● Mediante el tipo de datos de sistema AssocValues se especifica qué valor asociado debe
complementarse al generar el aviso.
● Encontrará más información sobre la estructura de los valores asociados en: Estructura de
los valores asociados (Página 8332)

2728

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Gen_UsrMsg":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

Mode

Input

UInt

I, Q, M, D, L o
constante

Parámetro para seleccionar
el estado del aviso:
● 1: aviso entrante
● 2: aviso saliente

TextID

Input

UInt

I, Q, M, D, L o
constante

ID de la entrada de la lista de
textos que debe utilizarse pa‐
ra el texto del aviso.

TextListID

Input

UInt

I, Q, M, D, L o
constante

ID de la lista de textos que
contiene la entrada de la lista
de textos.

Ret_Val

Return

Int

I, Q, M, D, L

Código de error de la instruc‐
ción.

AssocValues

InOut

AssocValues

D, L

Puntero hacia el tipo de da‐
tos de sistema AssocValues
con el que se definen los va‐
lores asociados.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro AssocValues
Con el tipo de datos de sistema AssocValues se define qué valores asociados deben enviarse
adjuntos. Se admiten como máximo 8 valores asociados. La estructura del tipo de datos de
sistema se crea introduciendo "AssocValues" como tipo de datos en un bloque de datos.
Los valores asociados se seleccionan al introducir los números de los valores asociados en los
parámetros Value[x]. Para ello, considere lo siguiente:
● La instrucción procesa los valores para TextID y TextListID como los valores asociados que
se van a enviar. De este modo, "1" y "2" ya están asignados como números para el
direccionamiento de valores asociados. No utilice los números "1" o "2" para direccionar
valores asociados.
● Direccione el valor asociado en el parámetro Value [1] como número "3", en el parámetro
Value [2] como número "4", etc.
Byte

Parámetro

Tipo de datos

Valor de arran‐
que

Descripción

Número del
valor asocia‐
do

0..1

Value[1]

UINT

0

Primer valor
asociado del
aviso.

3

2..3

Value[2]

UINT

0

Segundo valor
asociado del
aviso.

4

4..5

Value[3]

UINT

0

...

5

Programación del PLC
Manual de programación y manejo, 11/2019

2729

Instrucciones
4.1 Instrucciones
Byte

Parámetro

Tipo de datos

Valor de arran‐
que

Descripción

Número del
valor asocia‐
do

6..7

Value[4]

UINT

0

...

6

8..9

Value[5]

UINT

0

...

7

10..11

Value[6]

UINT

0

...

8

12..13

Value[7]

UINT

0

...

9

14..15

Value[8]

UINT

0

Octavo valor
asociado del
aviso.

10

Parámetro RET_VAL
La tabla siguiente contiene toda la información de error específica que se emite a través del
parámetro RET_VAL.
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

8080

Valor del parámetro Mode no soportado.

80C1

Escasez de recursos debido a demasiadas llamadas paralelas.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecima‐
les. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte tam‐
bién".

Ejemplo
En el siguiente ejemplo se genera un aviso que se registra en el búfer de diagnóstico.
Para almacenar los datos se crean cinco variables y una estructura "AssocValues" (con el tipo
de datos AssocValues) en un bloque de datos global.

2730

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los parámetros de la instrucción se interconectan del siguiente modo.

Para el aviso, cree una lista de textos y una entrada de lista de textos mediante la entrada
"Listas de textos". El identificador de la lista de textos se adopta en el parámetro TextListID
("myLIST"). El identificador (Rango...) de la entrada de lista de textos se adopta en el
parámetro TextID ("myTEXT"). El aviso se parametriza del modo siguiente.

Si el contacto NA ("execute") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"Gen_UsrMsg". De acuerdo con el valor del parámetro Mode ("myMODE"), se genera un aviso
entrante. El aviso que debe emitirse se da a conocer a la instrucción mediante los parámetros
TextListID ("myLIST") y TextID ("myTEXT"). El parámetro AssocValues ("AssocValues") envía
los valores asociados al aviso.
Al generar el aviso, la cadena de caracteres contenida en el texto de aviso "@5I%6d@" se
interpreta del modo siguiente:
● El valor asociado con el número "5" se lee en el tipo de datos INT. El número corresponde
al parámetro Value[3] de la estructura "AssocValues".
● El valor asociado se emite como número decimal. El número decimal está limitado a seis
cifras.
En el parámetro de salida Ret_Val ("returnValue") se muestra que la instrucción se ha
ejecutado sin errores.

Programación del PLC
Manual de programación y manejo, 11/2019

2731

Instrucciones
4.1 Instrucciones

Para emitir el aviso, abra en una CPU de la serie S7-1500 la opción "Online y diagnóstico >
Búfer de diagnóstico".

Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615).

Ejemplo
Encontrará un ejemplo de aplicación detallado en el Siemens Industry Online Support (https://
support.industry.siemens.com/cs/document/98210758?dti=0&lc=es-WW).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Crear y editar avisos (Página 8335)

2732

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Get_Alarm: Leer aviso existente
Descripción
La instrucción "Leer aviso pendiente" permite iniciar sesión en el programa de usuario para
avisos creados con el fin de copiar un aviso entrante o saliente en un bloque de datos
referenciado. De este modo, es posible transferir avisos a un equipo de control en forma de
STRING, por ejemplo.
Si se llama esta instrucción con "OperateMode = 1" y se inicia sesión con él, es necesario
indicar uno o varios discriminadores en la entrada "DispClassNr". Después de iniciar sesión ya
no se pierden más avisos, ni entrantes ni salientes.
Si el inicio de sesión se ha realizado correctamente, los parámetros de salida presentan los
valores siguientes:
DataReady = 0; Busy = 0; Error = 0; Init = 1; Status = 16#0000.
Si el inicio de sesión no se ha realizado correctamente, los valores de los parámetros de salida
son los siguientes:
DataReady = 0; Busy = 0; Error = 1; Init = 0; Status = 16#8xxx (en función del error).
Con "OperateMode = 2", los avisos se procesan secuencialmente, empezando por el más
antiguo. Se leen y se guardan en el área de destino seleccionada de la CPU. A continuación
es posible reenviar los datos a un equipo de control, p. ej., mediante la instrucción "TSEND_C".
Con la instrucción "Get_Alarm" en "OperateMode = 2", pueden producirse los siguientes
estados operativos:
Estados operativos

Descripción

Busy = TRUE

DataReady = FAL‐ Error = FALSE Hay avisos presentes: se ejecuta el procesa‐
SE
miento de avisos

Busy = FALSE

DataReady =
TRUE

Busy = FALSE

DataReady = FAL‐ Error = FALSE No hay avisos nuevos
SE

Busy = FALSE

DataReady = FAL‐ Error = TRUE
SE

Error = FALSE Hay un nuevo aviso en el búfer de recepción >
Recoger datos*)

Se ha producido un error (los datos no son vá‐
lidos)

)* Los datos deben copiarse en el mismo ciclo de programa, puesto que solo son válidos hasta
la siguiente llamada de la instrucción.
Con "OperateMode = 2", la instrucción lee el contenido del aviso de forma asíncrona, con lo
que se evitan tiempos de ejecución prolongados del bloque de función "Get_Alarm [FB702]",
que podrían provocar un desbordamiento del ciclo. La instrucción debe llamarse
repetidamente en un bloque de organización cíclico.
Con "OperateMode = 1" y "OperateMode = 3", la instrucción funciona de forma síncrona, es
decir, la ejecución se efectúa inmediatamente tras la llamada.
Dado que el bloque de función "Get_Alarm [FB702]" necesita por cada aviso recogido hasta 11
llamadas por idioma solicitado, en el parámetro Busy el estado lógico "1" puede permanecer
hasta durante 33 llamadas. La recogida de un mensaje no habrá concluido hasta que el
parámetro Busy vuelva a tener el estado lógico "0".

Programación del PLC
Manual de programación y manejo, 11/2019

2733

Instrucciones
4.1 Instrucciones
Por ello el tiempo de llamada recomendado para "Get_Alarm [FB702]" es de entre 20 ms y 200
ms. Si el tiempo de llamada > 1,8 segundos, se puede producir un cierre de sesión automático
del "Get_Alarm [FB702]". El cierre de sesión provoca que ya no se lean más avisos.
En los casos siguientes es necesario iniciar de nuevo sesión de la instrucción mediante la
entrada "OperateMode = 1".
● Tras el cierre automático de sesión debido a que se ha llamado con frecuencia insuficiente
al bloque de función "Get_Alarm [FB702]".
● Con un cambio del estado operativo "STOP" > "RUN".
● En cuanto cambian las configuraciones de avisos existentes, p. ej. el Program_Alarm o las
vigilancias ProDiag, se cierra automáticamente la sesión de la instrucción.
Esta instrucción puede utilizarse para avisos de los ámbitos siguientes:
● ProDiag
● Diagnóstico del sistema
● GRAPH
● Program_Alarm
● Motion Control
Nota
Propiedad de la CPU "Administración de avisos centralizada en el PLC"
Si en la configuración de dispositivos no se activa la propiedad de la CPU "Administración de
avisos centralizada en el PLC", en lugar de los textos de aviso (texto de aviso, texto de
información y los textos de aviso complementarios 1 - 9) se muestran solo las ID de los campos
de textos de aviso.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Leer aviso pendiente":
Parámetro Declara‐
ción

Tipo de
datos

Área de me‐
moria

Descripción

EN *)

Input

BOOL

I, Q, M, D, L

Entrada de habilitación

Output

BOOL

I, Q, M, D, L

Salida de habilitación

Input

BYTE

I, Q, M, D, L

Hay tres posibles valores:

ENO

*)

Operate‐
Mode

● 1: Iniciar sesión
● 2: Leer datos
● 3: Cerrar sesión

2734

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro Declara‐
ción

Tipo de
datos

Área de me‐
moria

Descripción

DataMode Input

BYTE

I, Q, M, D, L

Hay cuatro posibles valores:
● 0: Solo se leen los títulos de las columnas
(Producer-ID, ID_1, ID_2, Prio, Timestamp,
State)
● 1: Se leen los títulos de las columnas y el texto
de aviso con los valores asociados.
● 2: Se leen los títulos de las columnas, el texto
de aviso con los valores asociados y el texto
informativo.
● 3: Se leen los títulos de las columnas, el texto
de aviso con los valores asociados, el texto
informativo y los textos de aviso adicionales.

Disp‐
ClassNr
(Display
class
number)

Input

ARRAY[0. I, Q, M, D, L
.31] of
UINT

Es posible definir hasta 32 discriminadores distin‐
tos:
● 0 ... 16: Discriminadores definidos por el
usuario que pueden ajustarse en un
dispositivo HMI
● 257: Diagnóstico del sistema
● 259: Security (seguridad informática)
Si no se utiliza el parámetro, el primer valor (índice
0 del array) conserva el valor preajustado 65535.
Esto significa que recibirá notificaciones de todos
los discriminadores.
Atención:
Si no desea leer el discriminador 0, asigne el valor
256 a todos los índices no utilizados del array.
La modificación del discriminador solo se aplica si
se inicia sesión correctamente (OperateMode =
1).

Lcid (Lo‐
cale ID)

Input

UDINT

I, Q, M, D, L

Hay varios posibles valores:
● 0: Todos los idiomas
● 1: Primer idioma con el número LC más
pequeño
● 2: Primer idioma más segundo idioma con el
segundo número LC más pequeño
● 3: Todos los idiomas
● o bien: Introduzca el número LC exacto para
seleccionar un idioma concreto.

Data

InOut

Programación del PLC
Manual de programación y manejo, 11/2019

"AlarmDa‐ I, Q, M, D, L
ta"

Área de destino para los datos de aviso leídos.
Estructura de los textos de aviso del tipo de datos
PLC "AlarmData" de acuerdo con el valor del pa‐
rámetro "DataMode".

2735

Instrucciones
4.1 Instrucciones
Parámetro Declara‐
ción

Tipo de
datos

Área de me‐
moria

Descripción

Data‐
Ready

BOOL

I, Q, M, D, L

Parámetros de estado:

Output

● 0: No hay datos disponibles.
● 1: Hay datos disponibles.
Los datos solo son válidos hasta la siguiente
llamada de la instrucción. Por ello deben
procesarse en el mismo ciclo de programa, p.
ej. mediante una instrucción Move.

Busy

Output

BOOL

I, Q, M, D, L

Parámetros de estado:
● 0: Aún no se ha iniciado la ejecución de la
instrucción, o ha concluido la ejecución
asíncrona. Puede consultarse más
información sobre el estado de ejecución en el
parámetro STATUS.
● 1: Ejecución de la instrucción no finalizada.
Hay más entradas

Error

Output

BOOL

I, Q, M, D, L

Parámetros de estado:
● 0: Ningún error
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro STATUS contiene información más
detallada.

Init

Output

BOOL

I, Q, M, D, L

Parámetros de estado:
● 0: No se requiere acción alguna.
● 1: Debe inicializarse el almacenamiento de
datos de aviso. Los datos de aviso leídos
hasta ahora ya no son válidos.
Esto puede ser necesario en los siguientes casos:
● Ha vuelto a iniciar sesión. Se deben volver a
leer los datos de aviso actuales.
● La CPU cambia de "STOP" al estado
operativo "RUN".
● Los avisos se han reconfigurado y los cambios
se han efectuado mediante "Cargar en
dispositivo" en el estado operativo "RUN", p.
ej., un cambio en la estructura del texto de
aviso.

Status

Output

WORD

I, Q, M, D, L

Información de error y de estado

*): La entrada de habilitación EN y la salida de habilitación ENO solo son visibles en los lenguajes de
programación KOP y FUP.

2736

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro Status
La tabla siguiente muestra el significado de los valores del parámetro Status:
Código de
estado*
(W#16#...)

Explicación

0000

Ningún error

0001

Hay nuevos datos disponibles.

8001

El valor del parámetro OperateMode no es válido.

8002

El parámetro Data tiene el tipo de datos erróneo.

8003

El parámetro Lcid no es válido, o no está cargado un idioma seleccionado en el parámetro
Lcid.

8004

Ya se había iniciado sesión en el programa de usuario mediante el parámetro Operate‐
Mode = 1 con el fin de leer los avisos pendientes. En este caso, solo será posible y
necesario volver a iniciar sesión cuando se cierre la sesión actual con OperateMode = 3,
se hayan reconfigurado avisos o se haya ejecutado una transición STOP > RUN.

8005

El valor del parámetro DataMode no es válido.

8085

● No se ha indicado ningún discriminador en el inicio de sesión.
● Se ha cerrado la sesión de la instrucción durante la reconfiguración de supervisiones
(ProDiag).
● Cierre automático de sesión debido a que se ha llamado con frecuencia insuficiente
al bloque de función "Get_Alarm [FB702]".
● Cierre de sesión automático debido al estado del sistema SYNCUP (solo con CPU
S7-1500 R/H)

80C5

Ha intentado iniciar sesión mientras el sistema estaba en estado SYNCUP. Esto no es
posible. Vuelva a intentarlo más tarde (solo con CPU S7-1500 R/H).

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Tipo de datos PLC "AlarmData"
El tipo de datos PLC "AlarmData" reproduce la estructura de un aviso.
Nombre

Tipo de datos

Valor predeter‐
minado

Descripción

ProducerID

UINT

0

Hay varios posibles valores:
● 0: Program_Alarm
● 4: Diagnóstico del sistema
● 5: Standard Motion Control (T-CPU)
● 6: Security (p. ej. inicio de sesión erróneo)
● 7: SINUMERIK
● 8: GRAPH
● 9: ProDiag

ID_1

UINT

0

ID de aviso
Esta ID se muestra también en el editor de avisos.

Programación del PLC
Manual de programación y manejo, 11/2019

2737

Instrucciones
4.1 Instrucciones
Nombre

Tipo de datos

Valor predeter‐
minado

Descripción

ID_2

UINT

0

ID de la instancia runtime de aviso
Esta es una ID de rango interna que tiene significado
en ProDiag y en cadenas secuenciales:
● En ProDiag es la ID de vigilancia.
● En una cadena secuencial es el número de
etapa.
En la instrucción "Program_Alarm" es 0 y en el diag‐
nóstico del sistema no tiene significado.

PRIO

UINT

0

TimeStamp

LDT

DT#1970-01-0 Sello horario
1-0:0:0.000000 El sello de tiempo se basa en la hora UTC (Universal
000
Time Coordinated) o en la hora del sistema.

Prioridades: de 0 a 16

State

BYTE

16#0

Parámetros de estado:
● 0: Saliente
● 1: Entrante

LC_ID

ARRAY[0..2] of UINT

Devuelve el valor indicado en la entrada "Lcid".
● 0: Todos los idiomas
● 1: Primer idioma con el número LC más pequeño
● 2: Primer idioma más segundo idioma con el
segundo número LC más pequeño
● 3: Todos los idiomas
o bien: Introduzca el número LC exacto para selec‐
cionar un idioma concreto.

AlarmText

ARRAY[0..2] of WSTRING

Texto de aviso con 254 caracteres (508 bytes) como
máximo. Si el texto es más largo, se trunca en el
carácter 251, p. ej. WSTRING#'Meld... .

InfoText

ARRAY[0..2] of WSTRING

Texto de información

AddText_1 9

ARRAY[0..2] of WSTRING

Texto adicional 1 - 9

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para Get_Alarm y Ack_Alarms - Parte 1
(Página 2740).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Insertar valores asociados en los avisos (Página 8338)

2738

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Ejemplos de valores asociados (Página 8342)
Introducción a la configuración de avisos (Página 8319)

Ack_Alarms: Confirmar avisos
Descripción
Mediante la instrucción "Confirmar avisos" es posible acusar con un solo comando todos los
avisos entrantes y salientes del código del programa.
La instrucción se llama en cuanto hay un flanco ascendente, ya sea en la entrada de
habilitación EN (KOP / FUP) o como operación lógica precedente (AWL / SCL), y en el
parámetro MODE se ha ajustado el valor = 1. La instrucción funciona asíncronamente, con lo
que se previenen tiempos de ejecución prolongados del bloque de función "Ack_Alarms
[FC701]", que podrían provocar un desbordamiento del ciclo. La CPU confirma todos los
avisos entrantes y salientes e informa de dicha confirmación a todos los dispositivos HMI. Los
avisos que pueda haber pendientes en los displays desaparecen en cuanto "han salido".
En cada caso solo es posible realizar una confirmación (máx. 100 avisos de confirmación
obligatoria). Si hay otros avisos pendientes, se confirman automáticamente los 100 avisos de
confirmación (acuse) obligatoria siguientes.
La instrucción puede utilizarse también para avisos de supervisión de ProDiag

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Confirmar avisos":
Parámetro Declara‐
ción

Tipo de
datos

Área de me‐
moria

Descripción

EN *)

BOOL

I, Q, M, D, L

Entrada de habilitación

ENO

Input
*)

MODE

Output

BOOL

I, Q, M, D, L

Salida de habilitación

Input

UINT

I, Q, M, D, L

Hay dos posibles valores:
● 0: No se ejecuta la instrucción.
● 1: Confirmar todos los avisos.
Se confirman todos los avisos activos que
pueden confirmarse.

ERROR

Output

BOOL

I, Q, M, D, L

Parámetros de estado:
● 0: Ningún error
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro STATUS contiene información más
detallada.

STATUS

Output

WORD

I, Q, M, D, L

Información de error y de estado

*): La entrada de habilitación EN y la salida de habilitación ENO solo son visibles en los lenguajes de
programación KOP y FUP.

Programación del PLC
Manual de programación y manejo, 11/2019

2739

Instrucciones
4.1 Instrucciones

Parámetro STATUS
La tabla siguiente muestra el significado de los valores del parámetro STATUS:
Código de
estado*
(W#16#...)

Explicación

0000

Ningún error

7001

No ha ocurrido ningún error, y se confirman los 100 avisos de confirmación obligatoria
(acuse obligatorio) siguientes.

8001

El valor del parámetro MODE no es válido.

80C5

Actualmente ya hay en marcha un proceso de confirmación. Vuelva a intentarlo más tarde.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para Get_Alarm y Ack_Alarms - Parte 1
(Página 2740).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Insertar valores asociados en los avisos (Página 8338)
Ejemplos de valores asociados (Página 8342)
Introducción a la configuración de avisos (Página 8319)

Ejemplo de programa para Get_Alarm y Ack_Alarms
Ejemplo de programa para Get_Alarm y Ack_Alarms - Parte 1
Introducción
En el ejemplo siguiente se capturan todos los avisos de la CPU 1 (S7-1500 a partir de la v2.0
de firmware) y se memorizan. A continuación, utilice una conexión programada con la CPU 2
(S7-1500) para enviar los avisos (en forma abreviada; en el tipo de datos PLC "rcvGetAlarm")
de la CPU 1 a la CPU 2. En la CPU 2 se memorizan igualmente los avisos.
En la primera parte del ejemplo de programa para Get_Alarm y Ack_Alarms se tratan los
requisitos y la interconexión de los parámetros.

2740

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará los resultados y el procedimiento para la conexión aquí: Ejemplo de programa para
Get_Alarm y Ack_Alarms - Parte 2 (Página 2758).
Nota
Tamaño de los arrays de memoria para los avisos
Según la configuración descrita, los arrays de memoria para los avisos ("alarmStorage" y
"rcvdStorage") pueden acoger como máximo 16 avisos.
Si desea modificar el tamaño de memoria es necesario modificar el tamaño del array
correspondiente y el valor máximo "maxPosition".
&38

&38

*HWB$ODUP

76(1'B&

75&9B&

FXUU5HFRUG

VHQG6WUXFW

WUFY6WUXFW

UFY*HW$ODUP

UFY*HW$ODUP

DODUP'DWD
DODUP6WRUDJH
>[@

UFYG6WRUDJH
>[@

6*HW$ODUP

UFY*HW$ODUP

Requisitos para una conexión programada
Se crean dos CPU (S7-1500) y se conectan entre sí mediante PROFINET. La conexión se deja
sin parametrizar.
Nota
Utilizar Get_Alarm y Ack_Alarms
La CPU 1 (para llamar a Get_Alarm y Ack_Alarms) debe tener como mínimo firmware v2.0.
Además, para la CPU1 debe estar activada la propiedad de la CPU "Administración de avisos
centralizada en el PLC (Página 2733)".
Nota
Permitir acceso de lectura y escritura
En Propiedades > Protección de la CPU se ajusta un nivel de protección bajo para garantizar
que se permitan accesos de lectura y escritura.

Programación del PLC
Manual de programación y manejo, 11/2019

2741

Instrucciones
4.1 Instrucciones

CPU 1: Requisitos de programa
Crear tipos de datos PLC
Para transferir y almacenar los avisos se necesitan los tipos de datos PLC siguientes:
● "SGetAlarm" para almacenar los avisos, incluida información sobre la pérdida actual de
lectura.

● "rcvGetAlarm" para transferir los avisos mediante TSEND_C..

2742

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Almacenamiento de datos
Para almacenar los datos deben crearse en un bloque de datos global ("SLI_gDB_GAalarm")
las estructuras y variables siguientes.
● Para parametrizar TSEND_C:

● Para parametrizar Get_Alarm:

Programación del PLC
Manual de programación y manejo, 11/2019

2743

Instrucciones
4.1 Instrucciones
● Como parte de la estructura "GetAlarm", para guardar los avisos en el array de memoria:

● Para parametrizar Ack_Alarms:

Aviso de ProDiag
Para un escenario de prueba es preciso crear tres variables en un bloque de datos global
("SLI_gDB_testAlarm_GAA").

Para lanzar un aviso ProDiag es preciso crear la regla siguiente en el bloque de datos global
("SLI_gDB_testAlarm_GAA"). Para ello, abra el bloque de datos global > las propiedades de la
variable "startPump" > Supervisiones > Agregar nueva supervisión.

CPU 2: Requisitos de programa
Creación del tipo de datos PLC
Cree el tipo de datos PLC "rcvGetAlarm" como se ha descrito para la CPU 1.

2744

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Almacenamiento de datos
Para almacenar los datos deben crearse en un bloque de datos global ("SLI_gDB_trcv_GAA")
las estructuras y variables siguientes.

CPU 1: FB "SLI_FB_send_GAA" - Interconectar parámetros
Para establecer la conexión entre la CPU 1 y la CPU 2 y transmitir los datos es preciso crear
el FB "SLI_FB_send_GAA".
En el FB se crean las siguientes variables locales.

Programación del PLC
Manual de programación y manejo, 11/2019

2745

Instrucciones
4.1 Instrucciones
En el FB utilice:
● Interconexiones para cancelar ("TSEND_C.stop") la transmisión de datos,
● Interconexiones para iniciar ("#do2") la transmisión de datos,
● Interconexiones para iniciar una nueva transmisión de datos ("#initiateSending", "#do"),
● La instrucción "TSEND_C" para el establecimiento de la conexión y la transmisión de datos.

Nota
Interconexión del parámetro de entrada CONNECT de la instrucción "TSEND_C"
Para interconectar el parámetro de entrada CONNECT debe abrirse el asistente de la
instrucción "TSEND_C" mediante sus "Propiedades > Configuración".
Realice los siguientes ajustes para la conexión de TSEND_C:
● Punto final: seleccione las CPU correspondientes mediante la lista desplegable. La
interfaz, la subred y la dirección se introducen automáticamente.
● Datos de conexión: seleccionando "Nuevo" en la lista desplegable se crea un bloque de
datos para cada CPU. El bloque de datos es necesario para almacenar los datos de
conexión. El nombre del bloque de datos se puede elegir libremente en cada CPU
(interlocutor de comunicación).
● Seleccione el tipo de conexión "TCP" y el modo de configuración "Utilizar bloque de
programa". Estos ajustes proporcionan una conexión Ethernet con el protocolo "TCP",
y como conexión programada.
● Introduzca una ID de conexión de su elección. Utilice una ID de conexión que no haya
sido asignada todavía.
● Introduzca un valor para el puerto del interlocutor. El valor debe ser >=2000.
Encontrará más información sobre la configuración de TSEND_C (Página 3984)
aquí: Ejemplo de programa para funciones de transmisión (Página 4009).
Encontrará más información sobre la estructura y las interconexiones del FB
"SLI_FB_send_GAA" en el código del programa del ejemplo, en Sample Library for Instructions
(Página 615).

2746

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CPU 1: FC "SLI_FC_switchMode_GAA" - Interconectar parámetros
Para controlar la instrucción "Get_Alarm", se crea la FC "SLI_FC_switchMode_GAA".
En la FC se crean las siguientes variables locales.

En la FC se crean las interconexiones siguientes.
Segmento 1: Para iniciar el procesamiento de Get_Alarm, es preciso crear las interconexiones
siguientes.

Segmento 2: Para iniciar el procesamiento de Get_Alarm, es preciso crear las interconexiones
siguientes (parte 2).

Segmento 3: Para el inicio de sesión de Get_Alarm es preciso crear las interconexiones
siguientes.

Programación del PLC
Manual de programación y manejo, 11/2019

2747

Instrucciones
4.1 Instrucciones

Segmento 4: Para conmutar al modo "Lectura" de Get_Alarm es preciso crear las
interconexiones siguientes.

Segmento 5: Para procesar el modo "Lectura" de Get_Alarm es preciso crear las
interconexiones siguientes.

2748

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 6: Para procesar el modo "Lectura" de Get_Alarm es preciso crear las
interconexiones siguientes (parte 2).

Programación del PLC
Manual de programación y manejo, 11/2019

2749

Instrucciones
4.1 Instrucciones
Segmento 7: Para finalizar la ejecución de Get_Alarm se crean las interconexiones siguientes.

Segmento 8: Para finalizar el procesamiento de Get_Alarm es preciso crear las
interconexiones siguientes (parte 2).

Segmento 9: Para finalizar el procesamiento de Get_Alarm, es preciso crear las
interconexiones siguientes (parte 3).

2750

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CPU 1: FB "SLI_FB_saveAlarms_GAA" - Interconectar parámetros
El FB "SLI_FB_saveAlarms_GAA" se crea para copiar los avisos en el array de memoria
"GetAlarm.alarmStorage".
En el FB se crean las siguientes variables locales.

En el FB se crean las interconexiones siguientes.
Segmento 1: La copia de los avisos en el array de memoria "GetAlarm.alarmStorage" se
decide del modo siguiente:

Programación del PLC
Manual de programación y manejo, 11/2019

2751

Instrucciones
4.1 Instrucciones

Segmento 2: Para guardar el número de celda del array de memoria utilizado en último lugar
y para contar los avisos se crean las interconexiones siguientes.

Segmento 3: El incremento o el restablecimiento del número de celda del array de memoria se
decide del modo siguiente:

2752

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 4: Para guardar la copia efectuada correctamente en el array de memoria se crean
las interconexiones siguientes.

Segmento 5: Para finalizar la ejecución de "SLI_FB_saveAlarms_GAA" se crean las
interconexiones siguientes.

Programación del PLC
Manual de programación y manejo, 11/2019

2753

Instrucciones
4.1 Instrucciones

CPU 1: FB "SLI_FBCall_GetAlarm_AckA" - Interconectar parámetros
El FB "SLI_FBCall_GetAlarm_AckA" se crea para los fines siguientes:
● para llamar y forzar Get_Alarm
● para llamar los bloques para procesos de copia y transmisión
● para llamar a Ack_Alarms.
En el FB se crean las siguientes variables locales.

En el FB se crean las interconexiones siguientes.
Segmento 1: Los parámetros del FB "SLI_FB_send_GAA" se interconectan del siguiente modo.

Segmento 2: Los parámetros de la FC "SLI_FC_switchMode_GAA" se interconectan del
siguiente modo.

2754

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 3: Los parámetros de la instrucción "Get_Alarm" se interconectan del siguiente
modo.

Segmento 4: Los parámetros del FB "SLI_FB_saveAlarms_GAA" se interconectan del
siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2755

Instrucciones
4.1 Instrucciones

Segmento 5: Para probar el aviso de ProDiag es preciso crear las interconexiones siguientes.

Segmento 6: Los parámetros de la instrucción "Ack_Alarms" se interconectan del siguiente
modo.

CPU 2: FB "SLI_FB_rcvdAlarms_GAA" - Interconectar parámetros
El FB "SLI_FB_rcvdAlarms_GAA" se crea para copiar los avisos en el array de memoria
"GetAlarm.rcvdStorage". La estructura y las interconexiones son similares a las del FB
"SLI_FB_saveAlarms_GAA".
Encontrará más información sobre la estructura y las interconexiones del FB
"SLI_FB_rcvdAlarms_GAA" en el código del programa del ejemplo, en Sample Library for
Instructions (Página 615).

CPU 2: FB "SLI_FBCall_trcv_GAA" - Interconectar parámetros
El FB "SLI_FBCall_trcv_GAA" se crea para llamar y procesar "TRCV_C" y todos los procesos
subsiguientes.
En el FB se crean las siguientes variables locales.

2756

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

En el FB se crean las interconexiones siguientes.
Segmento 1: Los parámetros de la instrucción "TRCV_C" se interconectan del siguiente modo.
Configure el parámetro CONNECT de TRCV_C mediante el asistente de TRCV_C.
Encontrará más información sobre la configuración de TRCV_C (Página 3999) aquí: Ejemplo
de programa para funciones de transmisión (Página 4009).

Segmento 2: Para guardar el estado en caso de error de TRCV_C se interconecta el parámetro
del siguiente modo.

Segmento 3: Los parámetros del FB "SLI_FB_rcvdAlarms_GAA" se interconectan del
siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2757

Instrucciones
4.1 Instrucciones

Requisitos y procedimiento
Encontrará los resultados y el procedimiento para la conexión de comunicación aquí: Ejemplo
de programa para Get_Alarm y Ack_Alarms - Parte 2 (Página 2758).

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
Ack_Alarms: Confirmar avisos (Página 2739)

Ejemplo de programa para Get_Alarm y Ack_Alarms - Parte 2
Introducción
En la segunda parte del ejemplo de programa para Get_Alarm y Ack_Alarms se aprenden los
resultados de la configuración y del aviso de ProDiag.
Encontrará los requisitos y la interconexión de los parámetros aquí: Ejemplo de programa para
Get_Alarm y Ack_Alarms - Parte 1 (Página 2740).

Procedimiento para establecer la conexión entre la CPU 1 y la CPU 2
Tenga en cuenta el orden de los pasos a seguir:
1. Para la CPU 2, ponga la variable "TRCV_C.start" a "TRUE".
2. Para la CPU 2, ponga la variable "TRCV_C.comControl" a "TRUE".
3. Para la CPU 1, ponga la variable "TSEND_C.start" a "TRUE".
4. Para la CPU 1, ponga la variable "TSEND_C.comControl" a "TRUE".

2758

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Procedimiento deshacer la conexión entre la CPU 1 y la CPU 2
Tenga en cuenta el orden de los pasos a seguir:
1. Para la CPU 1, ponga la variable "TSEND_C.stop" a "TRUE".
2. Para la CPU 2, ponga la variable "TRCV_C.start" a "FALSE".
3. Para la CPU 2, ponga la variable "TRCV_C.comControl" a "FALSE".
4. Para la CPU 1, ponga la variable "TSEND_C.start" a "FALSE" y la variable "TSEND_C.stop"
a "FALSE".
5. Para la CPU 1, ponga la variable "TSEND_C.comControl" a "FALSE".

Resultado de la CPU 1: FB "SLI_FBCall_GetAlarm_AckA" - Segmento 1
Si el contacto NA ("TSEND_C.start") devuelve el estado lógico "TRUE", se inicia la instrucción
"TSEND_C". Si el parámetro de entrada CONNECT ("TSEND_C.comControl") devuelve el
estado lógico "TRUE", la instrucción "TSEND_C" crea una conexión de comunicación entre las
CPU 1 y CPU 2.
Con el parámetro de salida DONE ("TSEND_C.done") a "TRUE" ("TSEND_C.status" a "0000")
se indica la transmisión correcta del juego de datos (#sendStruct). Una vez transferido el juego
de datos (#sendStruct) a la CPU 2, la conexión de comunicación se sigue vigilando (estado
"7004").
Si el contacto NA ("TSEND_C.stop") devuelve el estado lógico "TRUE", se detiene la
instrucción "TSEND_C".

Encontrará más información sobre el funcionamiento de TSEND_C (Página 3984) y TRCV_C
(Página 3999) aquí: Ejemplo de programa para funciones de transmisión (Página 4009).

Programación del PLC
Manual de programación y manejo, 11/2019

2759

Instrucciones
4.1 Instrucciones

Resultado de la CPU 1: FB "SLI_FBCall_GetAlarm_AckA" - Segmento 2
Si el contacto NA ("GetAlarm.start") devuelve el estado lógico "TRUE", se inicia la instrucción
"Get_Alarm". Para ello, se llama la instrucción "Get_Alarm" en el modo 1
("GetAlarm.operateMode.value"), y a continuación cambia al modo 2. Una vez procesada, la
variable "GetAlarm.start" se restablece automáticamente a "FALSE".
Si el contacto NA ("GetAlarm.stop") devuelve el estado lógico "TRUE", se detiene la instrucción
"Get_Alarm". Para ello, se llama la instrucción "Get_Alarm" en el modo 3
("GetAlarm.operateMode.value"), y a continuación cambia a inactividad (modo 0). El requisito
para el comando de parada es que se haya iniciado correctamente la sesión de Get_Alarm
("GetAlarm.operateMode.Logon_done" es "TRUE"). Una vez procesada, la variable
"GetAlarm.stop" se restablece automáticamente a "FALSE".
Nota
Modo 0
Si se utiliza el valor "0" en el parámetro OPERATEMODE ("GetAlarm.operateMode.value") la
instrucción "Get_Alarm" devuelve como estado un error de parametrización. Motivo: La
instrucción "Get_Alarm" desconoce el modo 0. Sin embargo, el valor "0" en el parámetro
OPERATEMODE es necesario, por ejemplo, para poder mantener la instrucción "Get_Alarm"
en un estado de completa inactividad. En caso contrario la instrucción "Get_Alarm" debería
ejecutarse siempre en uno de los modos (iniciar sesión o cerrar sesión)

Se mantiene en cada caso el estado correcto del modo procesado de Get_Alarm:
● "GetAlarm.operateMode.Logon_done" es "TRUE" = el modo 1 ha finalizado correctamente.
● "GetAlarm.operateMode.ReadData_ready" es "TRUE" = el modo 2 está activado.
Get_Alarm está preparada para lectura.
● "GetAlarm.operateMode.ReadData_active" es "TRUE" = Get_Alarm está en modo 2 y
leyendo datos.
● "GetAlarm.operateMode.Logoff_done" es "TRUE" = el modo 3 ha finalizado correctamente.

2760

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Nota
Cierre de sesión imprevisto de Get_Alarm
Si se ha cerrado la sesión de Get_Alarm en modo 2, el parámetro de salida INIT
("GetAlarm.initiateLogin") devuelve el estado lógico "TRUE". En la FC
"SLI_FC_switchMode_GAA", este evento se cuenta como pérdida de lectura
("GetAlarm.currReadLoss"), y el parámetro (INOUT) MODE2REINIT
("GetAlarm.check.anew") pasa de "SLI_FC_switchMode_GAA" a "TRUE". Así se restablecen
las variables "GetAlarm.dataReady" y "GetAlarm.initiateLogin", y la instrucción "Get_Alarm"
realiza automáticamente un rearranque completo en modo 1. A continuación, Get_Alarm está
de nuevo preparada para lectura en modo 2.

Resultado de la CPU 1: FB "SLI_FBCall_GetAlarm_AckA" - Segmento 3
Si el parámetro de entrada OPERATEMODE ("GetAlarm.operateMode.value") muestra el
valor "2", la instrucción "Get_Alarm" lee todos los avisos de la CPU 1. Para ello, en el parámetro
de entrada DATA ("GetAlarm.currRecord") se registra el aviso correspondiente.

En el parámetro de salida DATAREADY ("#dataReady"), con el estado estado lógico "TRUE"
se hace referencia a un aviso nuevo. Como el valor de "#dataReady" (al igual que el de
"#initiate) solo está activado durante un ciclo, el estado se guarda mediante la variable
"GetAlarm.dataReady".

Programación del PLC
Manual de programación y manejo, 11/2019

2761

Instrucciones
4.1 Instrucciones
Si el parámetro de salida INIT ("#initiate") devuelve en el modo 2 el estado lógico "TRUE",
significa que se ha cerrado la sesión de Get_Alarm y es necesario abrir la sesión de nuevo.
Véase al respecto la nota del segmento 2. En el modo 1, "#initiate" / "GetAlarm.initiateLogin"
indica que el inicio de sesión ha sido correcto.
En caso de fallo, el estado de Get_Alarm ("GetAlarm.status") se guarda mediante las variables
"GetAlarm.memErrStatus" y "GetAlarm.memErr", y Get_Alarm pasa al modo 3 para el cierre de
sesión. Si debe cerrarse la sesión de Get_Alarm y no se produce ningún fallo
("GetAlarm.status" tiene el valor "16#0000"), el cierre de sesión se guarda mediante
"GetAlarm.operateMode.Logoff_done" con el valor "TRUE".

Mediante el parámetro de entrada DATAMODE ("GetAlarm.outputMode") con el valor "16#03"
se predefine que los avisos deben leerse completos (con toda la información). El parámetro de
entrada DISPCLASSNR no está interconectado. Así, Get_Alarm lee todos los discriminadores.
Mediante el parámetro de entrada LCID ("GetAlarm.languageCodeID") con el valor "0" se
predefine que deben leerse los avisos en todos los idiomas.

Resultado de la CPU 1: FB "SLI_FBCall_GetAlarm_AckA" - Segmento 4
Con las condiciones siguientes, el aviso leído actualmente ("GetAlarm.currRecord") y las
pérdidas de lectura contadas hasta el momento ("GetAlarm.currReadLoss") se guardan como
un juego de datos compuesto en el array de memoria "GetAlarm.alarmStorage":
● "GetAlarm.dataReady" devuelve el estado lógico "TRUE". En consecuencia, Get_Alarm ha
leído un aviso nuevo.
● Además, el juego de datos del aviso leído ("GetAlarm.currRecord") no está vacío. Para ello
se prueba su texto de aviso.

2762

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

A continuación, la posición utilizada ("#posForAlarm") en el array de memoria
"GetAlarm.alarmStorage" se guarda en la variable global "GetAlarm.posForAlarm". Además
se cuentan los avisos, y el valor actual se memoriza mediante la variable global
"GetAlarm.countAlarms".
Se incrementa la indicación de posición ("#posForAlarm"), de manera que es posible guardar
un aviso nuevo en una celda distinta del array de memoria. El requisito para que se realice el
incremento es que no se rebase el rango límite del array de memoria
("GetAlarm.maxPositon"). Si se rebasa el rango límite, se señala tal circunstancia
("GetAlarm.limitReach"), y la indicación de posición ("#posForAlarm") se pone al valor "0". De
ese modo los avisos siguientes sobrescribirían las entradas de avisos antiguos en el array de
memoria.
La copia correcta se indica mediante la variable "GetAlarm.savingDone". La variable
"GetAlarm.initiateSending" se activa para iniciar posteriormente la transmisión del aviso.
Para terminar el procesamiento de "SLI_FB_saveAlarms_GAA", la variable
"GetAlarm.dataReady" (y las variables locales) se restablece a "FALSE". El programa de
"SLI_FB_saveAlarms_GAA" solo se ejecuta de nuevo si "GetAlarm.dataReady" devuelve el
valor "TRUE".

Programación del PLC
Manual de programación y manejo, 11/2019

2763

Instrucciones
4.1 Instrucciones

Resultado de la CPU 1: FB "SLI_FBCall_GetAlarm_AckA" - Segmento 5
Si tanto el contacto NA ("startPump") como el contacto NC ("closeValve") devuelven el estado
lógico "TRUE", se genera el aviso de ProDiag configurado.

Get_Alarm lee el aviso y lo guarda en la variable asignada ("GetAlarm.currRecord"). A
continuación, en el segmento 4 el aviso se copia en el array de memoria
("GetAlarm.alarmStorage").

Resultado de la CPU 1: FB "SLI_FBCall_GetAlarm_AckA" - Segmento 1 (transmisión de datos)
Si la variable "GetAlarm.initiateSending" devuelve el estado lógico "TRUE", la posición
guardada ("GetAlarm.posForAlarm") en el array de memoria se transfiere a una variable local
de igual nombre ("#posForAlarm") y se reenvía el comando para una nueva transmisión de
datos. La variable "#initiateSending" se pone a "TRUE".
Si además no se avisa de ningún fallo y TSEND_C está alerta ("TSEND_C.error" y
"TSEND_C.busy" son "FALSE"), el aviso correspondiente ("GetAlarm.alarmStorage[..]") se
transfiere abreviado a la estructura "#sendStruct". Si no se ha ordenado ningún comando de
parada ("TSEND_C.stop" en "TRUE"), la variable "TSEND_C.start" se pondrá a "TRUE".
Mediante el comando de inicio de la transmisión de datos ("TSEND_C.start" es "TRUE"), el
aviso abreviado ("#sendStruct") se envía a la CPU 2 a lo largo de varios ciclos.

2764

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Resultado de la CPU 1: FB "SLI_FBCall_GetAlarm_AckA" - Segmento 6
Si el contacto NA ("AckAlarm.executeAck") devuelve el estado lógico "TRUE", se inicia la
instrucción "Ack_Alarms". De acuerdo con el valor "1" del parámetro de entrada MODE
("#acknowledge"), Ack_Alarms confirma todos los avisos activos. El procesamiento del
ejemplo transcurre sin fallos ("AckAlarm.error" es "FALSE" y "AckAlarm.status" tiene el valor
"16#0000").
Para ver las confirmaciones se utiliza un dispositivo HMI o el servidor web de la CPU.

Resultado de la CPU 2: FB "SLI_FBCall_trcv_GAA" - Segmento 1
Si el contacto NA ("TRCV_C.start") devuelve el estado lógico "TRUE", se inicia la instrucción
"TRCV_C". Si el parámetro de entrada CONNECT ("TRCV_C.comControl") devuelve el estado
lógico "TRUE", la instrucción "TRCV_C" creará una conexión de comunicación entre CPU 2 y
CPU 1.
Con el parámetro de salida DONE ("TRCV_C.done" y "TRCV_C.dataReceived") a "TRUE"
("TRCV_C.status" tiene el valor "0000") se indica la transmisión correcta del juego de datos
(#trcvStruct). Una vez transferido el juego de datos (#trcvStruct) a la CPU 2, la conexión de
comunicación se sigue vigilando y TRCV_C está preparada para la recepción (estado "7006").
La longitud en Byte del juego de datos realmente transferido se captura mediante el parámetro
de salida RCVD_LEN ("TRCV_C.rcvLen").

Encontrará más información sobre el funcionamiento de TSEND_C (Página 3984) y TRCV_C
(Página 3999) aquí: Ejemplo de programa para funciones de transmisión (Página 4009).

Resultado de la CPU 2: FB "SLI_FBCall_trcv_GAA" - Segmento 2
Si el contacto NA ("TRCV_C.error") devuelve el estado lógico "TRUE", se guarda el estado
("TRCV_C.status") del caso de error ("TRCV_C.memErrStatus").

Programación del PLC
Manual de programación y manejo, 11/2019

2765

Instrucciones
4.1 Instrucciones

Resultado de la CPU 2: FB "SLI_FBCall_trcv_GAA" - Segmento 3
Con las condiciones siguientes, en el array de memoria "GetAlarm.rcvdStorage" se guarda un
aviso:
● "TRCV_C.dataReceived" devuelve el estado lógico "TRUE". En consecuencia, se ha
enviado a TRCV_C un juego de datos nuevo.
● Además, el juego de datos recién recibido (#trcvStruct) no está vacío.

A continuación, la posición utilizada ("#posForAlarm") en el array de memoria
"GetAlarm.rcvdStorage" se guarda en la variable global "GetAlarm.posForAlarm". Además se
cuentan los avisos, y el valor actual se memoriza mediante la variable global
"GetAlarm.countAlarms".
Se incrementa la indicación de posición ("#posForAlarm"), de manera que es posible guardar
un aviso nuevo en una celda distinta del array de memoria. El requisito para que se realice el
incremento es que no se rebase el rango límite del array de memoria
("GetAlarm.maxPositon"). Si se rebasa el rango límite, se señala tal circunstancia
("GetAlarm.limitReach"), y la indicación de posición ("#posForAlarm") se pone al valor "0". De
ese modo los avisos siguientes sobrescribirían las entradas de avisos antiguos en el array de
memoria.
La copia correcta se indica mediante la variable "GetAlarm.savingDone".
Para terminar el procesamiento de "SLI_FB_rcvdAlarms_GAA", la variable
"TRCV_C.dataReceived" (y las variables locales) se restablece a "FALSE". El programa de
"SLI_FB_rcvdAlarms_GAA" solo se ejecuta de nuevo si "TRCV_C.dataReceived" devuelve el
valor "TRUE".

2766

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parte 1 del ejemplo de programa:
Encontrará los requisitos y la interconexión de los parámetros aquí: Ejemplo de programa para
Get_Alarm y Ack_Alarms - Parte 1 (Página 2740).

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

4.1.4.10

Diagnóstico

RD_SINFO: Leer información de arranque del OB actual
Descripción
La instrucción "RD_SINFO" permite leer la información de arranque
● del último OB llamado que todavía no se ha procesado completamente o
● del último OB de arranque iniciado.
Ambas informaciones de arranque carecen de sello de tiempo. Si la llamada se produce en el
OB 100, el OB 101 o el OB 102, se devuelven dos informaciones de arranque idénticas.

Programación del PLC
Manual de programación y manejo, 11/2019

2767

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "RD_SINFO":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RET_VAL

Return

TOP_SI

Output

INT

I, Q, M, D, L

Información de error

VARIANT

D, L

Información de arranque del OB actual

START_UP_SI

Output

VARIANT

D, L

Información de arranque del último OB de
arranque iniciado

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

SDT del parámetro TOP_SI
La tabla siguiente muestra los SDT posibles del parámetro TOP_SI:
Bloques de organización (OB)

Tipos de datos de sistema (SDT)

Números de los tipos de datos de siste‐
ma

Todos

SI_classic

592

SI_none

593

ProgramCycleOB

SI_ProgramCycle

594

TimeOfDayOB

SI_TimeOfDay

595

TimeDelayOB

SI_Delay

596

CyclicOB

SI_Cyclic

597

ProcessEventOB

SI_HWInterrupt

598

SI_HWInterrupt_Extended

616

SI_Submodule

601

SynchronousCycleOB

SI_SynchCycle

602

IOredundancyErrorOB

SI_IORedundancyError

604

CPUredundancyErrorOB

SI_CPURedundancyError

605

TimeErrorOB

SI_TimeError

606

DiagnosticErrorOB

SI_DiagnosticInterrupt

607

PullPlugEventOB

SI_PlugPullModule

608

PeripheralAccessErrorOB

SI_AccessError

609

RackStationFailureOB

SI_StationFailure

610

ServoOB

SI_Servo

611

IpoOB

SI_Ipo

612

StartupOB

SI_Startup

613

ProgrammingErrorOB

SI_ProgIOAccessError

614

SI_CPURedundancyError_V2

617

ProfileEventOB
StatusEventOB
UpdateEventOB

IOaccessErrorOB
CPURedundancyErrorOB

2768

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

SDT del parámetro START_UP_SI
La tabla siguiente muestra los SDT posibles del parámetro START_UP_SI:

Tipos de datos de sistema (SDT)

Números de los tipos de datos de sistema

SI_classic

592

SI_none

593

SI_Startup

613

Estructuras
Las siguientes tablas muestran el significado de los elementos estructurales de las diferentes
estructuras:
Tabla 4-36

Estructura SI_classic

Elemento de estructura Tipo de datos

Descripción

EV_CLASS

● Bits de 0 a 3: ID de evento

BYTE

● Bits de 4 a 7: Clase de evento
EV_NUM

BYTE

Número de evento

PRIORITY

BYTE

Número del nivel de ejecución
(Significado de B#16#FE: El OB no existe, está bloqueado o no puede arran‐
carse en el actual estado operativo.)

NUM

BYTE

Número de OB

TYP2_3

BYTE

ID de datos 2_3:
Identifica la información registrada en ZI2_3

TYP1

BYTE

ID de datos 1:
Identifica la información registrada en ZI1

ZI1

WORD

Información adicional 1

ZI2_3

DWORD

Información adicional 2_3

Tabla 4-37

Estructura SI_none

Elemento de estructura Tipo de datos

Descripción

SI_Format

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

Programación del PLC
Manual de programación y manejo, 11/2019

2769

Instrucciones
4.1 Instrucciones
Tabla 4-38

Estructura SI_ProgramCycle

Elemento de estructura Tipo de datos

Descripción

SI_Format

USINT

● 16#FF = Sin indicaciones

OB_Class

USINT := 1

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

Initial_Call

BOOL

Para OB_Class = 1, 30, 52, 61, 65

Remanence

BOOL

Para OB_Class = 1

● 16#FE = Información de arranque optimizada

Tabla 4-39

Estructura SI_TimeOfDay

Elemento de estructura Tipo de datos

Descripción

SI_Format

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT := 10

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

CaughtUp

BOOL

Para OB_Class = 10

SecondTime

BOOL

Para OB_Class = 10

Tabla 4-40

Estructura SI_Delay

Elemento de estructura Tipo de datos

Descripción

SI_Format

USINT

● 16#FF = Sin indicaciones

OB_Class

USINT := 20

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

Sign

WORD

Para OB_Class = 20

● 16#FE = Información de arranque optimizada

Tabla 4-41

Estructura SI_Cyclic

Elemento de estructura Tipo de datos

Descripción

SI_Format

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT := 30

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

Initial_Call

BOOL

Para OB_Class = 1, 30, 52, 61, 65

Event_Count

INT

Para OB_Class = 30, 51, 52, 61, 65, 91, 92

2770

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-42

Estructura SI_HWInterrupt

Elemento de estructura Tipo de datos

Descripción

SI_Format

USINT

● 16#FF = Sin indicaciones

OB_Class

USINT := 40

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

LADDR

HW_IO

Para OB_Class = 40, 51, 55, 56, 57, 70, 82, 83, 85, 86, 91, 92

USI

WORD

Para OB_Class = 40

IChannel

USINT

Para OB_Class = 40

EventType

BYTE

Para OB_Class = 40

● 16#FE = Información de arranque optimizada

Tabla 4-43

Estructura SI_HWInterrupt_Extended

Elemento de estructura Tipo de datos

Byte

Descripción

SI_Format

0

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT := 40

1

Clase de OB para "Sin indicaciones" o "Información de arranque
optimizada"

OB_Nr

UINT

2

N.º de OB (1 ... 32767)

LADDR

HW_IO

4

Para OB_Class = 40, 51, 55, 56, 57, 70, 82, 83, 85, 86, 91, 92

USI

WORD

6

Para OB_Class = 40

IChannel

USINT

8

Para OB_Class = 40

EventType

BYTE

9

Para OB_Class = 40

PointAddr

DWORD

12

Para OB_Class = 40

Tabla 4-44

Estructura SI_Submodule

Elemento de estructura Tipo de datos

Descripción

SI_Format

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

LADDR

HW_IO

Para OB_Class = 40, 51, 55, 56, 57, 70, 82, 83, 85, 86, 91, 92

Slot

UINT

Para OB_Class = 55, 56, 57

Specifier

WORD

Para OB_Class = 55, 56, 57

Tabla 4-45

Estructura SI_SynchCycle

Elemento de estructura Tipo de datos

Descripción

SI_Format

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT := 61

Programación del PLC
Manual de programación y manejo, 11/2019

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

2771

Instrucciones
4.1 Instrucciones
Elemento de estructura Tipo de datos

Descripción

OB_Nr

UINT

N.º de OB (1 ... 32767)

Initial_Call

BOOL

Para OB_Class = 1, 30, 52, 61, 65

PIP_Input

BOOL

Para OB_Class = 61, 91, 92

PIP_Output

BOOL

Para OB_Class = 61, 91, 92

IO_System

USINT

Para OB_Class = 61, 91, 92

Event_Count

INT

Para OB_Class = 30, 51, 52, 61, 65, 91, 92

SyncCycleTime

LTIME

Tiempo de ciclo calculado

Tabla 4-46

Estructura SI_IORedundancyError

Elemento de estructura Tipo de datos

Descripción

SI_Format

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT := 70

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

LADDR

HW_ANY

Para OB_Class = 40, 51, 55, 56, 57, 70, 82, 83, 85, 86, 91, 92

Event_Class

BYTE

Para OB_Class = 70, 83, 85, 86

Fault_ID

BYTE

Para OB_Class = 70, 80, 83, 85, 86

Tabla 4-47

Estructura SI_CPURedundancyError

Elemento de estructura Tipo de datos

Descripción

SI_Format

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT := 72

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

Switch_Over

BOOL

Para OB_Class = 72

Tabla 4-48

Estructura SI_TimeError

Elemento de estructura Tipo de datos

Descripción

SI_Format

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT := 80

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

Fault_ID

BYTE

Para OB_Class = 70, 80, 83, 85, 86

Csg_OBnr

OB_ANY

Para OB_Class = 80

Csg_Prio

UINT

Para OB_Class = 80

2772

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-49

Estructura SI_DiagnosticInterrupt

Elemento de estructura Tipo de datos

Descripción

SI_Format

USINT

● 16#FF = Sin indicaciones

OB_Class

USINT := 82

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

IO_State

WORD

Para OB_Class = 82

LADDR

HW_ANY

Para OB_Class = 40, 51, 55, 56, 57, 70, 82, 83, 85, 86, 91, 92

Channel

UINT

Para OB_Class = 82

MultiError

BOOL

Para OB_Class = 82

Tabla 4-50

Estructura SI_PlugPullModule

● 16#FE = Información de arranque optimizada

Elemento de estructura Tipo de datos

Descripción

SI_Format

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT := 83

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

LADDR

HW_IO

Para OB_Class = 40, 51, 55, 56, 57, 70, 82, 83, 85, 86, 91, 92

Event_Class

BYTE

Para OB_Class = 70, 83, 85, 86

Fault_ID

BYTE

Para OB_Class = 70, 80, 83, 85, 86

Tabla 4-51

Estructura SI_AccessError

Elemento de estructura Tipo de datos

Descripción

SI_Format

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT := 85

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

LADDR

HW_IO

Para OB_Class = 40, 51, 55, 56, 57, 70, 82, 83, 85, 86, 91, 92

Event_Class

BYTE

Para OB_Class = 70, 83, 85, 86

Fault_ID

BYTE

Para OB_Class = 70, 80, 83, 85, 86

IO_Addr

UINT

Para OB_Class = 85

IO_LEN

UINT

Para OB_Class = 85

Tabla 4-52

Estructura SI_StationFailure

Elemento de estructura Tipo de datos

Descripción

SI_Format

USINT

● 16#FF = Sin indicaciones

OB_Class

USINT := 86

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

● 16#FE = Información de arranque optimizada

Programación del PLC
Manual de programación y manejo, 11/2019

2773

Instrucciones
4.1 Instrucciones
Elemento de estructura Tipo de datos

Descripción

LADDR

HW_IO

Para OB_Class = 40, 51, 55, 56, 57, 70, 82, 83, 85, 86, 91, 92

Event_Class

BYTE

Para OB_Class = 70, 83, 85, 86

Fault_ID

BYTE

Para OB_Class = 70, 80, 83, 85, 86

Tabla 4-53

Estructura SI_Servo

Elemento de estructura Tipo de datos

Descripción

SI_Format

USINT

● 16#FF = Sin indicaciones

OB_Class

USINT := 91

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

Initial_Call

BOOL

Para OB_Class = 1, 30, 52, 61, 65

PIP_Input

BOOL

Para OB_Class = 61, 91, 92

PIP_Output

BOOL

Para OB_Class = 61, 91, 92

IO_System

USINT

Para OB_Class = 61, 91, 92

Event_Count

INT

Para OB_Class = 30, 51, 52, 61, 65, 91, 92

Synchronous

BOOL

● 16#FE = Información de arranque optimizada

Tabla 4-54

Estructura SI_Ipo

Elemento de estructura Tipo de datos

Descripción

SI_Format

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT := 92

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

Initial_Call

BOOL

Para OB_Class = 1, 30, 52, 61, 65

PIP_Input

BOOL

Para OB_Class = 61, 91, 92

PIP_Output

BOOL

Para OB_Class = 61, 91, 92

IO_System

USINT

Para OB_Class = 61, 91, 92

Event_Count

INT

Para OB_Class = 30, 51, 52, 61, 65, 91, 92

Reduction

UINT

Para OB_Class = 92

Tabla 4-55

Estructura SI_Startup

Elemento de estructura Tipo de datos

Descripción

SI_Format

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT := 100

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

LostRetentive

BOOL

Para OB_Class = 100

LostRTC

BOOL

Para OB_Class = 100

2774

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-56

Estructura SI_ProgIOAcessError

Elemento de estructura Tipo de datos

Descripción

SI_Format

USINT

● 16#FF = Sin indicaciones

OB_Class

USINT

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

BlockNr

UINT

Para OB_Class = 121, 122

Reaction

USINT

Para OB_Class = 121, 122

Fault_ID

BYTE

Para OB_Class = 121, 122

BlockType

USINT

Para OB_Class = 121, 122

Area

USINT

Para OB_Class = 121, 122

DBNr

DB_ANY

Para OB_Class = 121, 122

Csg_OBNr

OB_ANY

Para OB_Class = 121, 122

Csg_Prio

USINT

Para OB_Class = 121, 122

Width

USINT

Para OB_Class = 121, 122

● 16#FE = Información de arranque optimizada

Tabla 4-57

Estructura de SI_CPURedundancyError_V2

Elemento de estructura Tipo de datos

Descripción

SI_Format

● 16#FF = Sin indicaciones

USINT

● 16#FE = Información de arranque optimizada
OB_Class

USINT := 72

Clase de OB para "Sin indicaciones" o "Información de arranque optimizada"

OB_Nr

UINT

N.º de OB (1 ... 32767)

LADDR

HW_ANY

Para OB_Class = 40, 51, 55, 56, 57, 70, 82, 83, 85, 86, 91, 92

Event_Class

BYTE

Para OB_Class = 70, 83, 85, 86

Fault_ID

BYTE

Para OB_Class = 70, 80, 83, 85, 86

Nota
Si un OB se ha creado con la propiedad de bloque "Estándar", el contenido de los elementos
especificados en la estructura SI_classic es idéntico al de las variables temporales del OB.
Sin embargo, debe tenerse en cuenta que, en los distintos OB, las variables temporales
pueden tener otros nombres y tipos de datos. También debe tenerse en cuenta que la interfaz
de llamada de los OB contiene además la fecha y hora en que se solicitó el OB.
Los bits de 4 a 7 del elemento estructural EV_CLASS contienen la clase de evento. Aquí son
posibles los siguientes valores:
● 1: Eventos de arranque de OB estándar
● 2: Eventos de arranque de OB de errores síncronos
● 3: Eventos de arranque de OB de errores asíncronos
El elemento estructural PRIORITY devuelve la clase de prioridad correspondiente al OB actual.
Además de estos dos elementos, también es importante NUM . NUM contiene el número del
OB actual o del último OB de arranque iniciado.

Programación del PLC
Manual de programación y manejo, 11/2019

2775

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

8081

La información de arranque del OB actual no concuerda con el tipo de datos de sistema especificado

8083

La información de arranque del último OB de arranque iniciado no concuerda con el tipo de datos de sistema
especificado

Ejemplo
Supongamos que el último OB llamado, que todavía no se ha procesado por completo, es el
OB 80, y el último OB de arranque llamado es el OB 100.
La tabla siguiente muestra la correspondencia entre los elementos estructurales del parámetro
TOP_SI de la instrucción "RD_SINFO" y las correspondientes variables locales del OB 80.
TOP_SI
Tipo de datos
Elemento de estructura

OB 80 - Variable local correspondiente

Tipo de datos

EV_CLASS

BYTE

OB80_EV_CLASS

BYTE

EV_NUM

BYTE

OB80_FLT_ID

BYTE

PRIORITY

BYTE

OB80_PRIORITY

BYTE

NUM

BYTE

OB80_OB_NUMBR

BYTE

TYP2_3

BYTE

OB80_RESERVED_1

BYTE

TYP1

BYTE

OB80_RESERVED_2

BYTE

ZI1

WORD

OB80_ERROR_INFO

WORD

ZI2_3

DWORD

OB80_ERR_EV_CLASS

BYTE

OB80_ERR_EV_NUM

BYTE

OB80_OB_PRIORITY

BYTE

OB80_OB_NUM

BYTE

La tabla siguiente muestra la correspondencia entre los elementos estructurales del parámetro
START_UP_SI de la instrucción "RD_SINFO" y las correspondientes variables locales del
OB 100.
START_UP_SI
Tipo de datos
Elemento de estructura

OB 100 - Variable local

Tipo de datos

EV_CLASS

BYTE

OB100_EV_CLASS

BYTE

EV_NUM

BYTE

OB100_STRTUP

BYTE

PRIORITY

BYTE

OB100_PRIORITY

BYTE

NUM

BYTE

OB100_OB_NUMBR

BYTE

TYP2_3

BYTE

OB100_RESERVED_1

BYTE

TYP1

BYTE

OB100_RESERVED_2

BYTE

ZI1

WORD

OB100_STOP

WORD

ZI2_3

DWORD

OB100_STRT_INFO

DWORD

2776

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
En el siguiente ejemplo se lee la información de arranque del último OB de ciclo de programa
llamado y del último OB de arranque iniciado de una CPU.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Llame a la instrucción "RD_SINFO" en un OB1. Los parámetros de la instrucción "RD_SINFO"
se interconectan del siguiente modo.
Para la CPU en el ejemplo utilice únicamente el OB.

Si el parámetro de entrada EN devuelve el estado lógico "TRUE", se ejecuta la instrucción
"RD_SINFO". La instrucción "RD_SINFO" lee la información de arranque del último OB de ciclo
de programa llamado (OB1) y la devuelve en el parámetro de salida TOP_SI
("SI_ProgrammCycle"). En el parámetro de salida START_UP_SI ("SI_Startup") se emite la
información de arranque del último OB de arranque iniciado.
De acuerdo con el valor del parámetro "SI_Format", el OB1 utiliza información de arranque
optimizada. Además se lee la clase del OB ("OB_Class") y el número de OB asignado
("OB_Nr"). Para el OB de arranque ("SI_Startup") no se lee ningún número ("OB_Nr" con el
valor "0"), puesto que la CPU no utiliza ningún OB de arranque. Además, para el OB de
arranque se indican valores estándar ("SI_Format", "OB_Class").
En el parámetro de salida RET_VAL ("returnValue") se indica que la ejecución del ejemplo se
ha realizado sin errores (el valor es "0").

Programación del PLC
Manual de programación y manejo, 11/2019

2777

Instrucciones
4.1 Instrucciones

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)

RT_INFO: Leer estadísticas del tiempo de ejecución
Descripción
Con la instrucción "RT_INFO" se generan estadísticas del tiempo de ejecución de
determinados bloques de organización, de la comunicación o del programa de usuario.
La información que debe devolverse se selecciona en el parámetro MODE:
● MODE 1 a 3 devuelven datos relativos al tiempo de ejecución de un bloque de organización
determinado, cuyo número se ha indicado previamente en el parámetro OB.
● MODE 10 y 11 miden durante un periodo de 1 s y devuelven el valor medio de la proporción
de OB de mayor prioridad (MODE 10) o el valor medio de la proporción de comunicación
(MODO 11) en el tiempo de ejecución total.
● MODE 20 y 21 devuelven para el último ciclo del programa información sobre qué
porcentajes del tiempo de ejecución corresponden a la comunicación y al programa de
usuario.
● MODE 23 a 25 emiten el tiempo de ciclo más corto, más largo y actual.
● MODE 30 a 32 devuelven datos sobre ajustes configurados del programa de usuario.
● MODE 50 a 55 devuelven datos sobre el estado del sistema SYNCUP de un sistema
S7-1500 R/H
En la transición de la CPU de arranque a RUN se vuelven a iniciar todas las mediciones.

2778

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El tiempo de ejecución de un OB solo está disponible cuando ha concluido la primera ejecución
del OB; el tiempo de ciclo solo está disponible cuando ha concluido el primer ciclo.
Si se llama RT_INFO antes de que haya concluido la primera medición, en INFO se escribe el
valor predeterminado del correspondiente valor medido, y RET_VAL recibe el valor 0. En la
tabla siguiente se muestran los valores de inicialización para MODE = 1, 2, 3, 23, 24 y 25.

MODE

Valor de inicialización

1

0

2

0

3

0x FFFF FFFF FFFF FFFF

23

0

24

0x FFFF FFFF FFFF FFFF

25

Tiempo de ciclo mínimoparametrizado

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RT_INFO":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MODE

Input

UINT

I, Q, M, D, L o cons‐
tante

Con el parámetro MODE se selecciona la
información que debe leerse (consulte la ta‐
bla "Parámetro MODE").

OB

Input

OB_ANY

I, Q, M, D, L o cons‐
tante

Con el parámetro OB se elige el OB cuya
información se desea leer.

RET_VAL

Return

INT

I, Q, M, D, L

Información de error (véase "Parámetro
RET_VAL")

INFO

InOut

VARIANT

I, Q, M, D, L

Puntero al área en la que deben escribirse
los datos leídos. El tipo de datos necesario
para INFO depende del parámetro MODE
(véase la tabla "Parámetro MODE").

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2779

Instrucciones
4.1 Instrucciones

Parámetro MODE
La tabla siguiente muestra la información que se devuelve para los valores del parámetro
MODE.
MODE
(deci‐
mal)

Descripción

Nota

Valor en el
parámetro
OB

Tipo de
datos de
INFO

Disponible
a partir de
la versión
de CPU

1

Tiempo de ejecución de un
OB determinado

Número
de OB

LTIME

S7-1500
V1.5

2

Tiempo de ejecución máxi‐
mo de un OB determinado

Número
de OB

LTIME

S7-1500
V1.5

3

Tiempo de ejecución mínimo
de un OB determinado

En este caso se entiende por tiempo de
ejecución de un OB el tiempo durante el
que la CPU ejecuta los comandos del OB.
Por tanto, no incluye el tiempo necesario
para la ejecución de los OB de mayor prio‐
ridad o de tareas de comunicación que in‐
terrumpen el OB.

Número
de OB

LTIME

S7-1500
V1.5

El cálculo del valor medio se realiza en el
periodo de 1 s.

Irrelevante

UINT

S7-1500
V1.5

El cálculo del valor medio se realiza en el
periodo de 1 s.

Irrelevante

UINT

S7-1500
V1.5

Si, por el contrario, se desea determinar el
tiempo total que transcurre entre la ejecu‐
ción del primero y del último comando del
OB (es decir, incluyendo la ejecución de
los OB de mayor prioridad y de tareas de
comunicación que interrumpen el OB), se
utiliza la instrucción "RUNTIME".
10

Valor medio de la proporción
de OB de mayor prioridad en
el tiempo de ejecución total
Se indica el tiempo de ejecu‐
ción de todos los OB utiliza‐
dos en el programa de usua‐
rio con mayor prioridad que
los OB de programa cíclicos
(ProgramCycle). General‐
mente se incluyen entre ellos
todos los tipos de OB, excep‐
tuando los OB de arranque.
Los OB que pueden utilizar‐
se y la prioridad que estos
tienen dependen de la CPU y
se describen en los capítulos
dedicados a los principios
básicos de la programación.

11

Valor medio de la proporción
de comunicación en el tiem‐
po de ejecución total
Se indica qué porcentaje tie‐
nen los procesos de comuni‐
cación en el tiempo de ejecu‐
ción total del programa de
usuario.

2780

La proporción de comunicación devuelta
puede ser mayor que la especificada con el
parámetro de CPU "Carga del ciclo por co‐
municación". Esto puede ocurrir cuando se
especifica un tiempo de ciclo mínimo y el
programa de usuario no lo necesita en su
totalidad. En tal caso, el tiempo restante
puede utilizarse nuevamente para proce‐
sos de comunicación.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
MODE
(deci‐
mal)

Descripción

Nota

Valor en el
parámetro
OB

Tipo de
datos de
INFO

Disponible
a partir de
la versión
de CPU

20

Idéntico a MODE 10, con la
diferencia de que la evalua‐
ción se basa en el último ci‐
clo de programa ejecutado.

Irrelevante

UINT

S7-1500
V1.7

21

Idéntico a MODE 11, con la
diferencia de que la evalua‐
ción se basa en el último ci‐
clo de programa ejecutado.

● Si el punto de inicio del último ciclo
tiene más de 2 s de antigüedad desde
la última llamada de RT_INFO, el
cálculo no se realizará. La instrucción
devuelve el valor 65535 (0xFFFF).

Irrelevante

UINT

S7-1500
V1.7

LTIME

S7-1500
V1.7

LTIME

S7-1500
V1.7

LTIME

S7-1500
V1.7

● Si el punto de inicio del último ciclo
tiene menos de 1 ms de antigüedad
desde la última llamada de RT_INFO,
la evaluación ya comenzará 1 ms antes
de la llamada de RT_INFO.
● Si la duración del último ciclo fue
inferior a 1 ms, la evaluación tendrá
una duración de 1 ms. De ese modo se
puede prolongar durante varios ciclos.
Parametrizando un tiempo de ciclo
mínimo en las propiedades de la CPU
puede evitarse el rebase por defecto
del tiempo de ciclo de 1 ms.
● Para MODE 21: La proporción de
comunicación devuelta puede ser
mayor que la especificada con el
parámetro de CPU "Carga del ciclo por
comunicación". Esto puede ocurrir
cuando se especifica un tiempo de
ciclo mínimo y el programa de usuario
no lo necesita en su totalidad. En tal
caso, el tiempo restante puede
utilizarse nuevamente para procesos
de comunicación.

23

Tiempo de ciclo más largo
Duración del ciclo más largo
desde la última transición de
STOP a RUN.

24

Tiempo de ciclo más corto
Duración del ciclo más corto
desde la última transición de
STOP a RUN.

25

Tiempo de ciclo último o ac‐
tual

Los tiempos corresponden a los valores
Irrelevante
"Tiempos de ciclo medidos" del cuadro de
diálogo "Tiempo de ciclo" del TIA Portal. El
cuadro de diálogo se abre a través de On‐
line y diagnóstico > Diagnóstico > Tiempo
Irrelevante
de ciclo.

Irrelevante

Duración del último ciclo.

Programación del PLC
Manual de programación y manejo, 11/2019

2781

Instrucciones
4.1 Instrucciones
MODE
(deci‐
mal)

Descripción

30

Nota

Valor en el
parámetro
OB

Tipo de
datos de
INFO

Disponible
a partir de
la versión
de CPU

Tiempo de vigilancia del ciclo Los tiempos corresponden a los valores
Duración máxima permitida "Tiempo de ciclo parametrizado" del cua‐
del programa de la CPU. Si dro de diálogo "Tiempo de ciclo" del TIA
el tiempo de ciclo excede el Portal. El cuadro de diálogo se abre a tra‐
tiempo de vigilancia del ciclo, vés de Online y diagnóstico > Diagnóstico
la CPU pasa al estado ope‐ > Tiempo de ciclo.

Irrelevante

LTIME

S7-1500
V1.5

31

Se indica el tiempo de ciclo
mínimo configurado para el
programa de usuario Si se
ha parametrizado un tiempo
de ciclo mínimo en las pro‐
piedades de la CPU, el siste‐
ma operativo retarda el inicio
de un nuevo ciclo hasta que
se alcanza el tiempo de ciclo
mínimo.

Irrelevante

LTIME

S7-1500
V1.5

32

La proporción de la carga de ciclo sobre la Irrelevante
Se indica, en porcentaje, la
carga máxima por comunica‐ comunicación que puede suprimirse se es‐
ción configurada
tablece en las propiedades de la CPU en el
apartado "Carga de comunicación".

UINT

S7-1500
V1.5

50

Número de datos estáticos
que deben transferirse en el
estado del sistema SYNCUP

Irrelevante

LINT

S7-1500
V2.6

51

Número de datos estáticos
que ya se han transferido en
el estado del sistema
SYNCUP

-

Irrelevante

LINT

S7-1500
V2.6

52

Número de datos dinámicos que deben transferirse en el
estado del sistema SYNCUP

Irrelevante

LINT

S7-1500
V2.6

53

Número de datos dinámicos
que ya se han transferido en
el SYNCUP

-

Irrelevante

LINT

S7-1500
V2.6

54

Retardo máximo entre las
CPU primaria y de reserva
en que puede sincronizarse
la CPU de reserva

-

Irrelevante

LTIME

S7-1500
V2.6

55

Retardo actual entre las
CPU primaria y de reserva
en la fase de sincronización
de la CPU de reserva

-

Irrelevante

LTIME

S7-1500
V2.6

rativo STOP o llama un OB
de error de tiempo.

2782

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0

Ningún error

8080

El valor del parámetro MODE no está soportado.

8081

El bloque de organización seleccionado en el parámetro OB no existe en el programa de usuario.

8092

El parámetro seleccionado MODE no está soportado por esta versión de CPU.

80C3

Recursos insuficientes. Intente llamar la instrucción más tarde.

8452

Tipo de datos incorrecto en el parámetro INFO. Compruebe si se ha seleccionado el tipo de datos correcto en
función del parámetro MODE.

Ejemplo
En el ejemplo siguiente se lee el tiempo de ejecución de un bloque de organización de ciclo.
Para almacenar los datos es preciso crear cuatro variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

● Cree un bloque nuevo del tipo "Program cycle". El número de OB se indica en el parámetro
OB.
● En el parámetro MODE se introduce "1" (leer el tiempo de ejecución de un OB concreto).
● En el parámetro INFO se indica una variable con el tipo de datos LTIME (en este caso
"infoData").
● En el parámetro RET_VAL se indica una variable con el tipo de datos INT para emitir los
mensajes de error de la instrucción.
Tras llamar la instrucción, el tiempo de ejecución medido se escribe en la variable "infoData".

Programación del PLC
Manual de programación y manejo, 11/2019

2783

Instrucciones
4.1 Instrucciones

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)

LED: Leer estado del LED
Descripción
La instrucción "LED" lee el estado (p. ej. "On" u "Off") de un determinado LED de módulo.
● El parámetro LADDR direcciona la CPU o la interfaz.
● El parámetro LED selecciona el LED del módulo cuyo estado actual se va a leer con la
instrucción.
● El parámetro RET_VAL indica el estado del LED seleccionado al llamar la instrucción.
Dependiendo del LED seleccionado, solo puede mostrarse cierta información de estado.
Por ejemplo, algunos LED solo tienen un color. La información sobre qué estado es posible
para un determinado LED se especifica en la documentación de hardware del módulo
correspondiente.
Nota
LED LINK RX/TX de las CPU S7-1500
Tenga en cuenta que no es posible leer el estado del LED LINK RX/TX en ninguna CPU
S7-1500.

2784

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "LED":
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

LADDR

Input

HW_IO

I, Q, M, L o constante Identificador de HW de la CPU o de la interfaz
El número se asigna automáticamente y se
guarda en las propiedades de la CPU o de la
interfaz en la configuración hardware (Nombre
de la CPU + ∼Common).

LED

Input

UINT

I, Q, M, D, L o cons‐
tante

Número de identificación del LED:
● 1: STOP/RUN
● 2: ERROR
● 3: MAINT (mantenimiento)
● 5: Link (verde)
● 6: Rx/Tx (amarillo)

RET_VAL

Return

INT

I, Q, M, D, L

Estado del LED

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
RET_VAL

Descripción

0a9

Estado del LED:
● 0 = LED no existe o información de estado no disponible
● 1 = apagado permanentemente
● 2 = color 1 (p. ej., en LED STOP/RUN: verde) encendido permanentemente
● 3 = color 2 (p. ej., en LED STOP/RUN: naranja) encendido permanentemente
● 4 = color 1 parpadea con 2 Hz
● 5 = color 2 parpadea con 2 Hz
● 6 = color 1 y 2 parpadean alternativamente con 2 Hz
● 7 = LED activo, color 1
● 8 = LED activo, color 2
● 9 = LED no existe o información de estado no disponible
Por motivos de compatibilidad, este valor de RET_VAL ENO se pone a FALSE.

8086

El sistema R/H no está en el estado del sistema RUN-Redundant. Por este motivo, los datos de la otra CPU
no están disponibles.

8091

El componente de hardware direccionado con el parámetro LADDR no existe.

8092

Con el parámetro LADDR se ha direccionado un componente de hardware que no devuelve la información
deseada.

8093

El número de identificación indicado en el parámetro LED no está definido.

80Bx

La CPU indicada en el parámetro LADDR no soporta la instrucción "LED".

Programación del PLC
Manual de programación y manejo, 11/2019

2785

Instrucciones
4.1 Instrucciones

Ejemplo
En el ejemplo siguiente se lee el estado del LED de la CPU.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los parámetros de la instrucción se interconectan del siguiente modo.

El parámetro LADDR ("myLADDR") da a conocer el identificador de HW de la CPU a la
instrucción "LED". El LED de la CPU sometido a vigilancia se da a conocer mediante el
parámetro LED ("myLED"). Se consulta el estado del LED de la CPU (STOP/RUN). Si la CPU
pasa de STOP al estado operativo RUN, en el parámetro de salida RET_VAL ("returnValue")
se muestra el valor "6" (alternando verde y naranja). A continuación se muestra como estado
del LED ("returnValue") el valor "2" (verde permanente).

Nota: El significado de los colores para el LED STOP/RUN es el siguiente:
Color

Significado

Rojo

STOP

Verde

RUN

Alternando verde y naranja

La CPU está cargando

Alternando rojo y verde

Programa en ejecución

Encontrará más información sobre el significado de los colores del LED en la descripción del
hardware de la CPU.

2786

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Get_IM_Data: Leer datos de identificación y mantenimiento
Descripción
La instrucción "Get_IM_Data" lee los datos de identificación y mantenimiento (datos I&M) de
un dispositivo. Con el parámetro LADDR se selecciona el identificador de hardware del
dispositivo cuyos datos I&M desean leerse.
Con el parámetro IM_TYPE se definen los datos que deben leerse mediante la instrucción:
● IM_TYPE = 0: datos I&M 0
Los datos I&M 0 ofrecen información básica de un dispositivo, como la identificación del
fabricante, la referencia, el número de serie o la versión de hardware y firmware. Los datos
I&M 0 solo permiten un acceso de lectura. Esta información también se muestra en el TIA
Portal en la vista "Online y diagnóstico" de un dispositivo.
● IM_TYPE = 11: datos I&M 1 de los datos de parametrización de la CPU
Los datos I&M 1 contienen una descripción del funcionamiento del dispositivo así como el
identificador de situación, es decir, cómo se ha designado o identificado el dispositivo
dentro de la instalación.
● IM_TYPE = 12: datos I&M 2 de los datos de parametrización de la CPU
Los datos I&M 2 contienen la fecha de incorporación, es decir, la fecha en que se instaló el
dispositivo en la instalación.
● IM_TYPE = 13: datos I&M 3 de los datos de parametrización de la CPU
Los datos I&M 3 contienen información adicional sobre el dispositivo instalado. La
información adicional es un texto cualquiera que puede introducirse a discreción.
Los datos I&M leídos se escriben en el área direccionada en el parámetro DATA.
El estado de procesamiento de la orden de lectura se indica a través de los parámetros de
salida BUSY, DONE, ERROR y los dos bytes centrales del parámetro de salida STATUS.

Definición: datos de identificación y mantenimiento (I&M)
Los datos de identificación y mantenimiento (I&M) son datos almacenados en un módulo que
ayudan a comprobar la configuración del sistema, a buscar modificaciones en el hardware de
una instalación o a solucionar errores.
● Los datos de identificación (datos I) son datos invariables de un dispositivo a los que solo
puede accederse para su lectura.
● Los datos de mantenimiento (datos M) son informaciones dependientes del sistema como,
p. ej. lugar y fecha de montaje. Los datos de mantenimiento se generan durante la
configuración y se escriben en el módulo.

Programación del PLC
Manual de programación y manejo, 11/2019

2787

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Get_IM_Data":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

LADDR

Input

HW_IO

I, Q, M, D, L o cons‐ Identificador de hardware del dispositivo. El nú‐
tante
mero se asigna automáticamente y se guarda en
las propiedades del dispositivo, en la configura‐
ción hardware.

IM_TYPE

Input

UINT

I, Q, M, D, L o cons‐ Número de datos de identificación y manteni‐
tante
miento
Valores posibles:
● 0: datos I&M 0
● 11: datos I&M 1 de los datos de
parametrización de la CPU
● 12: datos I&M 2 de los datos de
parametrización de la CPU
● 13: datos I&M 3 de los datos de
parametrización de la CPU

DATA

InOut

VARIANT

I, Q, M, D, L

Área para el almacenamiento de los datos de
identificación y mantenimiento leídos (ver abajo).

DONE

Output

BOOL

I, Q, M, D, L

La instrucción se ha ejecutado correctamente.
Los datos I&M se han transferido al parámetro
DATA.

BUSY

Output

BOOL

I, Q, M, D, L

Parámetro de estado
● 0: Ejecución de la instrucción finalizada o no
iniciada.
● 1: Ejecución de la instrucción no finalizada.

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado
● 0: Ningún error.
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro STATUS contiene información más
detallada.

STATUS

Output

WORD

I, Q, M, D, L

Parámetro de estado
El parámetro solo está activado durante una lla‐
mada. Por ello, para la visualización debe co‐
piarse el valor de STATUS en un área de datos
libre.

Encontrará más información sobre los tipos de datos en "Vista general de los tipos de datos
válidos (Página 241)".

2788

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro DATA para datos I&M 0
Para almacenar los datos I&M 0 utilice un array (ARRAY of BYTE) o una estructura de datos
especial:
● Si se direcciona un array (ARRAY of BYTE) en el parámetro DATA, los datos I&M 0 se
copian a DATA como secuencia de bytes. Si el array direccionado es más largo que los
datos leídos, se asigna el valor cero a los bytes no necesarios.
● Para los datos I&M 0 también puede utilizarse la estructura "IM0_Data" siguiente en el
parámetro DATA:
Parámetro

Tipo de datos Bytes

Descripción

Manufacturer_ID

UINT

2

Identificación de fabricante (p. ej., "42"
para SIEMENS)

Order_ID

STRING[20]

20

Referencia

Serial_Number

STRING[16]

16

Número de serie

Hardware_Revision

UINT

2

Versión de hardware

Software_Revision

STRUCT

4

Versión de firmware

Type

CHAR

1

-

Functional

USInt

1

-

Bugfix

USInt

1

-

Internal

USInt

1

-

Revision_Counter

UINT

2

Contador de revisiones

Profile_ID

UINT

2

Perfil

Profile_Specific_Type

UINT

2

Clase de dispositivo

IM_Version

WORD

2

Versión I&M

I&M_Supported

WORD

2

Datos I&M soportados por el dispositi‐
vo (I&M 0-I&M 4)

Si en el parámetro DATA se utiliza un tipo de datos diferente, se emite el código de error 8093
en el parámetro STATUS.

Parámetro DATA para datos I&M 1, I&M 2 e I&M 3
Para almacenar los datos I&M utilice una cadena de caracteres (STRING), un array (ARRAY
of CHAR/BYTE) o una estructura de datos (STRUCT):
● Si en el parámetro DATA se direcciona una cadena de caracteres (tipo de datos STRING),
la longitud de la cadena de caracteres se ajusta automáticamente a la longitud de los datos
I&M leídos (254 caracteres como máximo).
● Si en el parámetro DATA se direcciona una estructura de datos (ARRAY of CHAR/BYTE o
STRUCT), los datos I&M leídos se escriben en los diferentes componentes del tipo de datos
utilizado. Si la estructura de datos direccionada es más larga que los datos leídos, se asigna
el valor cero a los componentes restantes.
● Si en el parámetro DATA se crea una estructura de datos del tipo STRUCT, debe utilizarse
un bloque de datos sin acceso a bloque optimizado (ver categoría "Atributos" de las
propiedades del bloque).

Programación del PLC
Manual de programación y manejo, 11/2019

2789

Instrucciones
4.1 Instrucciones
Si en el parámetro DATA se utiliza un tipo de datos diferente a STRING, ARRAY of BYTE/
CHAR o STRUCT, se emite el código de error 8093 en el parámetro STATUS.
Nota
Información adicional sobre los datos I&M
Encontrará información adicional sobre los datos I&M, entre otros, en las páginas web de
PROFIBUS & PROFINET International (enlace: http://www.profibus.com (http://
www.profibus.com)).

Parámetro STATUS
Código de
error*
(W#16#...)

Descripción

0

Ningún error

7001

Primera llamada de la instrucción asíncrona "Get_IM_Data". La ejecución de la instrucción aún no ha finali‐
zado (BUSY = 1, DONE = 0).

7002

Una llamada más de la instrucción asíncrona "Get_IM_Data". La ejecución de la instrucción aún no ha
finalizado (BUSY = 1, DONE = 0).

8086

El sistema R/H no está en el estado del sistema RUN-Redundant. Por este motivo, los datos de la otra CPU
no están disponibles.

8091

No existe el dispositivo direccionado en el parámetro LADDR.

8092

LADDR direcciona un dispositivo que no soporta la emisión de datos I&M.

8093

El tipo de datos del parámetro DATA no está soportado.

80A1

LADDR direcciona un dispositivo que no soporta la salida de datos I&M 1, I&M 2 o I&M 3.

80B1

No existen datos válidos. (El (sub)módulo no soporta los datos I&M o bien no se han configurado datos I&M
para este dispositivo.)

80B2

El valor del parámetro IM_TYPE no es válido o bien la CPU o el dispositivo direccionado no soporta el
IM_TYPE seleccionado.

80C3

Se ha superado el máximo de 10 ejecuciones paralelas de las instancias:
● Evite más de 10 llamadas paralelas.
● Repita la llamada en otro momento ya que se trata de un error temporal.

8752

El área de memoria indicada en el parámetro DATA es demasiado pequeña para guardar todos los datos
I&M. Los datos I&M leídos se guardan solo hasta la longitud máxima del área de memoria indicada.

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
En el ejemplo siguiente se leerán los datos IM0 de una CPU S7-1500. Los datos IM0 ofrecen
información básica de un dispositivo, como la identificación del fabricante, la referencia, el
número de serie o la versión de hardware y firmware.
Para almacenar los datos IM0 es preciso crear cuatro variables y una estructura del tipo de
datos IM0_Data en un bloque de datos global. El nombre de la estructura (en este caso
"MyPLC_IM_Data") es de libre elección.

2790

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

En el parámetro LADDR se introduce el identificador de hardware de la CPU, que identifica de
forma unívoca el dispositivo. Para determinar el identificador de hardware de la CPU, abra la
tabla de variables PLC y la ficha Constantes de sistema. Busque la CPU en la columna
Nombre. El valor correspondiente es el identificador de hardware que se introduce en el
parámetro LADDR .

Una vez ejecutada correctamente la instrucción, los datos IM0 se escriben en el bloque de
datos.

Programación del PLC
Manual de programación y manejo, 11/2019

2791

Instrucciones
4.1 Instrucciones

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

2792

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

GET_NAME: Leer el nombre de un dispositivo IO o de un esclavo DP
Descripción
La instrucción "GET_NAME" lee el nombre de un dispositivo IO o de un esclavo DP. El nombre
se indica en la vista de redes y en las propiedades del dispositivo IO o del esclavo DP. La
siguiente captura de pantalla lo muestra con el ejemplo de un dispositivo IO.

El dispositivo IO o el esclavo DP se selecciona mediante el ID de hardware del sistema
PROFINET IO o del sistema maestro DP (en el parámetro LADDR) y del número del dispositivo
IO o de la dirección PROFIBUS del esclavo DP (parámetro STATION_NR).
Una vez ejecutada la instrucción correctamente, el nombre del dispositivo IO o del esclavo DP
se escribe en el área direccionada por el parámetro DATA.
El nombre leído varía en función del tipo de dispositivo de periferia:
● En un esclavo DP o un dispositivo IO se visualiza el nombre del módulo de cabecera.
● En un esclavo I o un I-Device se visualiza el nombre del módulo de interfaz.
● En un panel HMI se visualiza el nombre de la interfaz.
● En una estación PC se visualiza el nombre del módulo de interfaz.
● En los dispositivos GSD se visualiza el nombre del Device Access Point (DAP) (nombre de
la interfaz o del módulo de cabecera).
La longitud del nombre se indica en el parámetro LEN. Si el nombre supera la longitud del área
indicada en el parámetro DATA, el nombre se escribe solo hasta la longitud máxima del área
direccionada.

Programación del PLC
Manual de programación y manejo, 11/2019

2793

Instrucciones
4.1 Instrucciones
La longitud máxima del nombre es de 128 caracteres.
Nota
Lectura del nombre de la CPU (a partir de la versión 1.1)
Si aplica un "0" en los parámetros LADDR y STATION_NR, respectivamente, la instrucción
muestra el nombre de la CPU.
Con el sistema R/H en el estado operativo RUN-Redundant, la instrucción devuelve el nombre
de la CPU primaria.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GET_NAME":
Parámetro

Declaración

Tipo de datos

LADDR

Input

HW_IOSYSTEM I, Q, M, D, L o cons‐
tante

Área de memoria

Identificador de hardware del sistema PROFI‐
NET IO o maestro DP. El número se toma de
las constantes de sistema o las propiedades
del sistema PROFINET IO o maestro DP.

Descripción

STATION_NR Input

UINT

I, Q, M, D, L o cons‐
tante

Número de dispositivo del dispositivo PROFI‐
NET IO o dirección PROFIBUS del esclavo
DP. Se indica en la vista de redes y en las pro‐
piedades del dispositivo IO o del esclavo DP.

DATA

InOut

VARIANT

I, Q, M, D, L

Puntero hacia el área en el que se escribe el
nombre.

DONE

Output

BOOL

I, Q, M, D, L

La instrucción se ha ejecutado correctamente.
El nombre del dispositivo IO o del esclavo DP
se ha transferido al área en el parámetro DA‐
TA.

BUSY

Output

BOOL

I, Q, M, D, L

Parámetro de estado
● 0: Ejecución de la instrucción finalizada.
● 1: Ejecución de la instrucción no finalizada.

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado
● 0: Ningún error.
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro STATUS contiene información
más detallada.

LEN

Output

DINT

I, Q, M, D, L

STATUS

Output

WORD

I, Q, M, D, L

Longitud del nombre del dispositivo IO o del
esclavo DP (número de caracteres).
Parámetro de estado
El parámetro solo está activado durante una
llamada. Por ello, para visualizar el estado co‐
pie el STATUS en un área de datos libre.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

2794

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro STATUS
Código de
error*
(W#16#...)

Explicación

0

Ningún error

7001

Primera llamada de la instrucción asíncrona "GET_NAME". La ejecución de la instrucción aún no ha finali‐
zado (BUSY = 1, DONE = 0).

7002

Una llamada más de la instrucción asíncrona "GET_NAME". La ejecución de la instrucción aún no ha fina‐
lizado (BUSY = 1, DONE = 0).

8090

El identificador de hardware indicado en el parámetro LADDR no existe en el proyecto.

8092

El valor del parámetro LADDR no direcciona ningún sistema PROFINET IO ni ningún sistema maestro DP.

8093

La instrucción no soporta el tipo de datos del parámetro DATA.

8095

● El número de dispositivo (parámetro STATION_NR) no existe en el sistema PROFINET IO seleccionado
o bien no direcciona ningún dispositivo IO.

80B1

La CPU utilizada no soporta la instrucción.

80C3

Error temporal de recursos: en este momento la CPU está procesando el máximo posible de llamadas de
bloque simultáneas. "GET_NAME" no se ejecuta antes de haber finalizado como mínimo una llamada de
bloque.

8852

El área indicada en el parámetro DATA es demasiado corta para el nombre completo del dispositivo IO o del
esclavo DP. El nombre solo se escribirá hasta la longitud máxima posible.

● La dirección PROFIBUS (parámetro STATION_NR) no existe en el sistema maestro DP seleccionado.

Para poder leer el nombre completo, utilice un área de datos más larga en el parámetro DATA. Para ello, el
área debe abarcar como mínimo el número de caracteres del parámetro LEN.
* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
El ejemplo siguiente muestra cómo se lee el nombre de estación de un HMI Panel.
Configuración del HMI Panel:
● El HMI Panel con el nombre de estación "HMI_IO-Device" se ha creado en la vista de redes
y está asignado al mismo sistema PROFINET IO que la CPU.
● Para el HMI Panel se ha activado el modo de operación "Dispositivo IO" en las propiedades
de la configuración hardware y la CPU se ha asignado como controlador IO.
● En "Direcciones Ethernet" de las propiedades se ha asignado el número de dispositivo "20".

Programación del PLC
Manual de programación y manejo, 11/2019

2795

Instrucciones
4.1 Instrucciones
Para almacenar los datos deben crearse las variables siguientes en un bloque de datos global.

Parametrización de la instrucción "GET_NAME":
● En el parámetro LADDR se introduce el identificador de hardware del sistema IO (262).
● En el parámetro de entrada STATION_NR se introduce el número de dispositivo del panel
HMI (2).
● Los restantes parámetros de la instrucción "GET_NAME" se interconectan del siguiente
modo.

2796

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Ejecución de la instrucción:
● Una vez ejecutada la instrucción, el nombre de estación del HMI Panel (HMI_IO-Device) se
escribe en el parámetro DATA ("moduleName").
● En el parámetro LEN se indica el número de caracteres del nombre (13).
● Como tras la lectura correcta del dispositivo IO no se ha detenido GET_NAME, el parámetro
de salida BUSY ("busy") tiene el valor "TRUE" y el parámetro de salida STATUS ("status")
tiene el valor "16#7002".

Código del programa
Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

GetStationInfo: leer información de un dispositivo IO
Descripción
La instrucción "GetStationInfo" permite leer información de un dispositivo PROFINET IO. La
instrucción también permite leer información de un dispositivo IO que se encuentre en un
sistema IO subordinado (conexión con CP/CM).
El dispositivo IO se direcciona mediante el identificador de hardware de la estación en el
parámetro LADDR. El identificador de hardware se muestra en la vista "Dispositivos y redes",
en las propiedades de la estación.
Con el parámetro MODE se selecciona la información que debe leerse.

Programación del PLC
Manual de programación y manejo, 11/2019

2797

Instrucciones
4.1 Instrucciones
En el parámetro DATA se indica el área de datos en la que deben escribirse los datos de
dirección leídos. Para almacenar la dirección IP, utilice la estructura "IF_CONF_v4", y para
almacenar la dirección MAC, la estructura "IF_CONF_MAC".
Mediante el parámetro de control REQ se activa la lectura de los datos de dirección. Para ello
debe poder accederse al dispositivo IO.
El estado de procesamiento de la petición de lectura se indica a través de los parámetros de
salida BUSY, DONE, ERROR y STATUS.
Nota
Direccione el dispositivo IO exclusivamente con el identificador de hardware de la estación
La estación, el dispositivo IO y la interfaz PROFINET tienen cada uno un identificador de
hardware propio. Utilice exclusivamente el identificador de hardware de la estación para la
instrucción "GetStationInfo".
Si mediante el parámetro LADDR se direcciona una interfaz PROFINET, p. ej., los datos de
dirección no se leen y se emite el código de error 8092.
Para leer los datos de dirección de una interfaz PROFINET integrada o de un CM/CP con la
configuración centralizada, utilice la instrucción "RDREC".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GetStationInfo":
Parámetro

Declaración

Tipo de datos Área de memo‐
ria

REQ

Input

BOOL

I, Q, M, D, L

Descripción
Parámetro de control Request
Activa la lectura de la información
cuando REQ = "1".

LADDR

Input

HW_DEVICE I, Q, M, D, L o
constante

Identificador de hardware de la esta‐
ción del dispositivo IO
El número se aplica en la vista de re‐
des adoptándose de las propiedades
de la estación o de la ficha "Constantes
del sistema" de la tabla de variables
estándar.

DETAIL

Input

HW_SUB‐
MODULE

I, Q, M, D, L o
constante

El parámetro DETAIL no se utiliza. No
asigne ningún valor al parámetro.

MODE

Input

UINT

I, Q, M, D, L o
constante

Selección de los datos de dirección
que se leerán:
● MODE = 1: parámetros de
dirección según IPv4 (CPU
S7-1500 a partir de la versión de
firmware V1.1)
● MODE = 2: dirección MAC (CPU
S7-1500 a partir de la versión de
firmware V1.5)

2798

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos Área de memo‐
ria

Descripción

DATA

InOut

VARIANT

D, L

Puntero hacia el área en la que se es‐
criben los datos de dirección del dispo‐
sitivo IO. Si MODE = 1, utilice la estruc‐
tura "IF_CONF_v4" y si MODE = 2, la
estructura "IF_CONF_MAC".

DONE

Output

BOOL

I, Q, M, D, L

La instrucción se ha ejecutado correc‐
tamente. Los datos de dirección se han
transferido al parámetro DATA.

BUSY

Output

BOOL

I, Q, M, D, L

Parámetro de estado
● 0: Ejecución de la instrucción
finalizada.
● 1: Ejecución de la instrucción no
finalizada.

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado
● 0: Ningún error.
● 1: Se ha producido un error al
ejecutar la instrucción.
El parámetro STATUS contiene infor‐
mación más detallada.

STATUS

Output

WORD

I, Q, M, D, L

Parámetro de estado
El parámetro solo está activado duran‐
te una llamada. Por ello, para visuali‐
zar el estado debe copiarse el STA‐
TUS en un área de datos libre.

Encontrará más información sobre los tipos de datos en "Vista general de los tipos de datos
válidos (Página 241)".

Parámetro DATA
● Utilice en el parámetro DATA la estructura "IF_CONF_v4" para el almacenamiento de los
parámetros de dirección según IPv4.
Byte

Parámetro

Tipo de datos Valor de
arranque

Descripción

0 … 1 Id

UINT

30

ID de la estructura "IF_CONF_v4".

2 … 3 Length

UNIT

18

Longitud de los datos leídos en BYTE.

4 ... 5 Mode

UNIT

0

No relevante para la instrucción "GetStatio‐
nInfo" (se deja en "0").

-

Dirección IP del dispositivo IO en formato
IP_V4, p. ej. para 192.168.3.10:

6 ... 9 InterfaceAddress ARRAY
[1..4] of
BYTE

● addr[1] = 192
● addr[2] = 168
● addr[3] = 3
● addr[4] = 10

Programación del PLC
Manual de programación y manejo, 11/2019

2799

Instrucciones
4.1 Instrucciones
Byte

Parámetro

Tipo de datos Valor de
arranque

Descripción

10 …
13

SubnetMask

ARRAY
[1..4] of
BYTE

Máscara de subred del dispositivo IO en for‐
mato IP_V4, p. ej. para 255.255.255.0:

-

● addr[1] = 255
● addr[2] = 255
● addr[3] = 255
● addr[4] = 0

14 ...
17

DefaultRouter

ARRAY
[1..4] of
BYTE

-

Dirección IP del router en formato IP_V4,
p. ej. para 192.168.3.1:
● addr[1] = 192
● addr[2] = 168
● addr[3] = 3
● addr[4] = 1

● Utilice la estructura "IF_CONF_MAC" en el parámetro DATA para almacenar la dirección
MAC.
Byte

Parámetro

Tipo de datos Valor de
arranque

Descripción

0 … 1 Id

UINT

3

ID de la estructura "IF_CONF_MAC".

2 … 3 Length

UNIT

12

Longitud de los datos leídos en BYTE.

4 ... 5 Mode

UNIT

0

No relevante para la instrucción "GetStatio‐
nInfo" (se deja en "0").

6 ...
11

ARRAY
[1..6] of
BYTE

-

Dirección MAC del dispositivo IO, p. ej. para
08-00-06-12-34-56

MACAddress

● Mac[1] = 8
● Mac[2] = 0
● Mac[3] = 6
● Mac[4] = 12
● Mac[5] = 34
● Mac[6] = 56

Parámetro STATUS

2800

Código de
error*
(W#16#...)

Explicación

0

Ningún error

7000

Ninguna petición en proceso.

7001

Primera llamada de la instrucción asíncrona "GetStationInfo". La ejecución de la ins‐
trucción aún no ha finalizado (BUSY = 1, DONE = 0).

7002

Una llamada más de la instrucción asíncrona "GetStationInfo". La ejecución de la ins‐
trucción aún no ha finalizado (BUSY = 1, DONE = 0).

8080

El valor del parámetro MODE no está soportado.

8090

La ID de hardware indicada en el parámetro LADDR no está configurada.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*
(W#16#...)

Explicación

8092

El parámetro LADDR no direcciona ningún dispositivo PROFINET IO.

8093

Tipo de datos no válido en el parámetro DATA.

80A0

La información solicitada no puede leerse.

80C0

No puede accederse al dispositivo IO direccionado.

80C3

Se ha alcanzado el número máximo de llamadas simultáneas de la instrucción "GetS‐
tationInfo" (10 instancias).

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecima‐
les. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte tam‐
bién".

Ejemplo
En el ejemplo siguiente se leerán los datos de la dirección IP de un dispositivo IO con la
instrucción „GetStationInfo“ y se escribirá la información en un bloque de datos. Los datos de
dirección IP abarcan la dirección IP, la máscara de subred y, en caso de utilizarse, los datos
de dirección del router.
La instrucción se ejecuta en el controlador IO y lee los datos de dirección IP de un dispositivo
IO subordinado (en este caso un ET200MP como ejemplo).

Para almacenar los datos de dirección es preciso crear cinco variables y una estructura del tipo
de datos IF_CONF_v4 en un bloque de datos global. Asigne el nombre de la estructura (en este
caso "IP_Address") a discreción.

Programación del PLC
Manual de programación y manejo, 11/2019

2801

Instrucciones
4.1 Instrucciones

Seguidamente, llame la instrucción "GetStationInfo":
● La estructura IF_CONF_v4 se utiliza en el parámetro DATA.
● En el parámetro LADDR se introduce el identificador de hardware del dispositivo IO, que
identifica de forma unívoca el dispositivo. Para determinar el identificador de hardware del
dispositivo IO, abra la tabla de variables PLC y la ficha Constantes de sistema. Ahora,
busque el dispositivo en la columna Nombre y „Hw_Device“ en la columna Tipo de datos.
El valor correspondiente es el identificador de hardware que se introduce en el parámetro
LADDR.
● Para el parámetro MODE elija "1" (lectura de los parámetros de dirección según IPv4).

Con REQ= 1 (TRUE) se inicia la lectura de los datos de dirección. Una vez ejecutada
correctamente la instrucción, los datos de dirección IP se escriben en el bloque de datos.
Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

2802

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

GetChecksum: Leer suma de verificación
Descripción
La instrucción "GetChecksum" lee la suma de verificación de un grupo de objetos. La selección
de los objetos se realiza con el parámetro "Scope".
Nota
Formación de la suma de verificación en bloques
La suma de verificación se forma de manera diferente en bloques estándar y en bloques de
seguridad. Encontrará más información al respecto en la ayuda del paquete opcional STEP 7
Safety .

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GetChecksum":
Parámetro

Declaración

Tipo de datos

Descripción

Scope

Input

UINT

Con el parámetro "Scope" se seleccionan los
objetos cuya suma de verificación desea leer:
● 1: Bloques estándar (es decir, no bloques de
seguridad)
● 2: Bloques de seguridad
● 3: Listas de textos

Range (oculto)

Input

UINT

"Range" debe tener el valor 0.

Subrange (ocul‐ Input
to)

UINT

"Subrange" debe tener el valor 0.

Done

Output

BOOL

La instrucción se ha ejecutado correctamente.
La suma de verificación se ha transferido al pa‐
rámetro "Checksum".

Busy

Output

BOOL

Parámetro de estado
● 0: Ejecución de la instrucción finalizada.
● 1: Ejecución de la instrucción no finalizada
todavía.

Error

Output

BOOL

Parámetro de estado
● 0: Ningún error.
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro "Status" contiene información más
detallada.

Programación del PLC
Manual de programación y manejo, 11/2019

2803

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Descripción

Status

Output

WORD

Parámetro de estado
El parámetro solo está activado durante una lla‐
mada. Por ello, para visualizar el estado debe
copiarse el STATUS en un área de datos libre.

Checksum

InOut

VARIANT

Suma de verificación
El parámetro "Checksum" debe apuntar a una
variable del tipo de datos ARRAY[0..7] of BYTE;
los bytes no utilizados se ponen a 0.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro "Status"
Código de
error*
(W#16#...)

Explicación

0

Ningún error

7001

Primera llamada: iniciada la formación de la suma de verificación

7002

Llamada intermedia: la formación de la suma de verificación ya está activada

8080

Valor no válido del parámetro "Scope"

8081

El parámetro "Range" no se soporta en esta versión de firmware y debe tener el valor 0.

8082

El parámetro "Subrange" no se soporta en esta versión de firmware y debe tener el valor
0.

8091

La CPU no asiste la instrucción "GetChecksum", o bien los objetos direccionados no
están disponibles, p. ej. porque en la CPU no existe ningún programa de seguridad.

8852

La variable a la que señala el parámetro "Checksum" tiene un tipo de datos erróneo.

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de progra‐
mas. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte tam‐
bién".

Ejemplo
En el siguiente ejemplo se lee la suma de verificación de los bloques estándar de una CPU
S7-1500.
Para almacenar los datos deben crearse las variables siguientes en un bloque de datos global.

2804

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Se crea un FB. En el FB se crean las siguientes variables locales.

Segmento 1: Los parámetros de la instrucción "GetChecksum" se interconectan del siguiente
modo.

Segmento 2: En caso de fallo, guarde el estado del siguiente modo.

Si el contacto NA ("execute") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"GetChecksum". De acuerdo con el valor "1" del parámetro de entrada SCOPE ("scope") se lee
la suma de verificación de los bloques estándar. En el parámetro CHECKSUM ("checksum")
se visualiza la suma de verificación. El estado correcto de GetChecksum se indica en el
parámetro de salida DONE ("done").
En los parámetros de salida STATUS ("#status" y "memErrStatus") y ERROR ("error") se
indica que el procesamiento del ejemplo se ha ejecutado sin errores.

Programación del PLC
Manual de programación y manejo, 11/2019

2805

Instrucciones
4.1 Instrucciones

La suma de verificación también se encuentra en las propiedades de la CPU.

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Comparación de programas PLC a partir de las sumas de verificación (Página 8417)

GetSMCinfo: Leer información sobre la SIMATIC Memory Card
Descripción
Con la instrucción "GetSMCinfo" se lee información sobre la SIMATIC Memory Card insertada.
La información que debe leerse se selecciona con el parámetro "Mode":
● Mode = 0, 1, 2, 3: admisible con CPU estándar
● Mode = 10 ... 13 y 20 ... 23: admisible con CPU S7-1500 R/H
Los valores 10 ... 13 de Mode hacen referencia a la CPU con ID de redundancia 1.
Los valores 20 ... 23 de Mode hacen referencia a la CPU con ID de redundancia 2.

2806

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Mediante el parámetro de control REQ se activa la lectura de la Memory Card. El estado de
ejecución de la orden se indica mediante los parámetros de salida Done, Busy, Error y Status.

Programación del PLC
Manual de programación y manejo, 11/2019

2807

Instrucciones
4.1 Instrucciones

Dependencia de la información que puede leerse del estado del sistema R/H
● Capacidad de memoria
Estado del sistema y, en su
caso, rol de la CPU

Estado de acopla‐
miento de las CPU

Valores admisibles de Mode

RUN-Solo, CPU primaria

No hay acoplamiento ● ID de redundancia=1: Mode=10 (SMC
propia)
● ID de redundancia=2: Mode=20 (SMC
propia)
Hay acoplamiento

● ID de redundancia=1:
–

Mode=10 (SMC propia) o

–

Mode=20 (SMC de la otra CPU)

● ID de redundancia=2:

SYNCUP, CPU primaria

-

–

Mode=10 (SMC de la otra CPU) o

–

Mode=20 (SMC propia)

● ID de redundancia=1:
–

Mode=10 (SMC propia) o

–

Mode=20 (SMC de la otra CPU)

● ID de redundancia=2:

RUN-Redundant

-

–

Mode=10 (SMC de la otra CPU) o

–

Mode=20 (SMC propia)

● ID de redundancia=1:
–

Mode=10 (SMC propia) o

–

Mode=20 (SMC de la otra CPU)

● ID de redundancia=2:
–

Mode=10 (SMC de la otra CPU) o

–

Mode=20 (SMC propia)

● Espacio de memoria ocupado

2808

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Estado del sistema y, en su
caso, rol de la CPU

Estado de acopla‐
miento de las CPU

Valores admisibles de Mode

RUN-Solo, CPU primaria

irrelevante

● ID de redundancia=1: Mode=11 (SMC
propia)
● ID de redundancia=2: Mode=21 (SMC
propia)

SYNCUP, CPU primaria

-

La información podrá leerse o no en función
del instante de inicio de GetSMCinfo y de la
sincronización de las dos CPU.
Si puede leerse:
● ID de redundancia=1:
–

Mode=11 (SMC propia) o

–

Mode=21 (SMC de la otra CPU)

● ID de redundancia=2:

RUN-Redundant

-

–

Mode=11 (SMC de la otra CPU) o

–

Mode=21 (SMC propia)

● ID de redundancia=1:
–

Mode=11 (SMC propia) o

–

Mode=21 (SMC de la otra CPU)

● ID de redundancia=2:
–

Mode=11 (SMC de la otra CPU) o

–

Mode=21 (SMC propia)

Nota
Determinación del espacio ocupado en memoria por tarjetas de memoria de diferente
capacidad
Si en las dos CPU de un sistema R/H se utilizan tarjetas de memoria de diferente
capacidad, la determinación del espacio ocupado en memoria puede dar resultados
distintos aunque el contenido de la memoria sea idéntico. La causa de ello es el tamaño
distinto del clúster de las tarjetas de memoria.

Programación del PLC
Manual de programación y manejo, 11/2019

2809

Instrucciones
4.1 Instrucciones
● Porcentaje consumido de la vida útil
Estado del sistema y, en su
caso, rol de la CPU

Estado de acopla‐
miento de las CPU

Valores admisibles de Mode

RUN-Solo, CPU primaria

irrelevante

● ID de redundancia=1: Mode=12 (SMC
propia)
● ID de redundancia=2: Mode=22 (SMC
propia)

SYNCUP, CPU primaria

-

La información podrá leerse o no en función
del instante de inicio de GetSMCinfo y de la
sincronización de las dos CPU.
Si puede leerse:
● ID de redundancia=1:
–

Mode=12 (SMC propia) o

–

Mode=22 (SMC de la otra CPU)

● ID de redundancia=2:

RUN-Redundant

-

–

Mode=12 (SMC de la otra CPU) o

–

Mode=22 (SMC propia)

● ID de redundancia=1:
–

Mode=12 (SMC propia) o

–

Mode=22 (SMC de la otra CPU)

● ID de redundancia=2:
–

Mode=12 (SMC de la otra CPU) o

–

Mode=22 (SMC propia)

● Umbral parametrizado de la vida útil

2810

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Estado del sistema y, en su
caso, rol de la CPU

Estado de acopla‐
miento de las CPU

Valores admisibles de Mode

RUN-Solo, CPU primaria

irrelevante

● ID de redundancia=1:
–

Mode=13 (SMC propia) o

–

Mode=23 (SMC de la otra CPU)

● ID de redundancia=2:

SYNCUP, CPU primaria

-

–

Mode=13 (SMC de la otra CPU) o

–

Mode=23 (SMC propia)

● ID de redundancia=1:
–

Mode=13 (SMC propia) o

–

Mode=23 (SMC de la otra CPU)

● ID de redundancia=2:

RUN-Redundant

-

–

Mode=13 (SMC de la otra CPU) o

–

Mode=23 (SMC propia)

● ID de redundancia=1:
–

Mode=13 (SMC propia) o

–

Mode=23 (SMC de la otra CPU)

● ID de redundancia=2:

Programación del PLC
Manual de programación y manejo, 11/2019

–

Mode=13 (SMC de la otra CPU) o

–

Mode=23 (SMC propia)

2811

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GetSMCinfo":
Parámetro

Declaración

Tipo de datos

Descripción

REQ

Input

BOOL

Parámetro de control Request
Activa la lectura de la Memory Card cuando REQ = "1".

2812

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Descripción

Mode

Input

UINT

Con el parámetro "Mode" se selecciona la información que quiere leerse
sobre la SIMATIC Memory Card:
● 0: tamaño de memoria en KiB (1 KiB = 1024 bytes)
● 1: espacio de memoria ocupado, en KiB
● 2: Información de mantenimiento: Porcentaje consumido hasta el
momento de la vida útil
Nota:
–

En los controladores por software S7-1500 y en S7-PLCSIM se
registra siempre 0x00 en Info con Mode=2 (no hay información
de mantenimiento).

–

En las SIMATIC Memory Cards que por norma general no
soportan esta información o que no pueden suministrarla con el
firmware actual de la CPU, se registra 0xFF en Info.

● 3: Porcentaje parametrizado de la vida útil en %, a cuyo término la
CPU crea una entrada en el búfer de diagnóstico y se activa el LED
de mantenimiento
Nota:
–

Esta información no se lee de la Memory Card sino de los datos
de configuración. En caso de que se haya bloqueado la
generación de la alarma de diagnóstico, se registra 0xFF en Info.

–

En los controladores por software S7-1500 y S7-PLCSIM, en
Mode=3 siempre se registra 0xFF en Info.

● 10 o 20: equivale a Mode 0 en las CPU estándar
–

Mode 10: capacidad de memoria de la SMC en la CPU con ID de
redundancia 1

–

Mode 20: capacidad de memoria de la SMC en la CPU con ID de
redundancia 2

● 11 o 21: equivale a Mode 1 en las CPU estándar
–

Mode 11: espacio de memoria ocupado de la SMC en la CPU
con ID de redundancia 1

–

Mode 21: espacio de memoria ocupado de la SMC en la CPU
con ID de redundancia 2

● 12 o 22: equivale a Mode 2 en las CPU estándar
–

Mode 12: porcentaje consumido de la vida útil en la CPU con ID
de redundancia 1

–

Mode 22: porcentaje consumido de la vida útil en la CPU con ID
de redundancia 2

● 13 o 23: equivale a Mode 3 en las CPU estándar

Done

Output

BOOL

Programación del PLC
Manual de programación y manejo, 11/2019

–

Mode 13: umbral parametrizado de la vida útil en la CPU con ID
de redundancia 1

–

Mode 23: umbral parametrizado de la vida útil en la CPU con ID
de redundancia 2

1: La instrucción se ha ejecutado correctamente. La información leída
se ha transferido al parámetro Info.

2813

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Descripción

Busy

Output

BOOL

Parámetro de estado
● 0: Ejecución de la instrucción finalizada.
● 1: Ejecución de la instrucción no finalizada.

Error

Output

BOOL

Parámetro de estado
● 0: Ningún error.
● 1: Se ha producido un error al ejecutar la instrucción.
El parámetro Status contiene información más detallada.

Status

Output

WORD

Código de error

Info

InOut

UDINT

Búfer para la información leída

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".
Nota
Determinación de los datos I&M 0
Los datos I&M 0 de la SIMATIC Memory Card no pueden determinarse con la instrucción
GetSMCinfo. Para ello debe utilizarse la instrucción "Get_IM_Data (Página 2787)".

Parámetro Status
Código de error*
(W#16#...)

Explicación

0

Ningún error.

7000

Ninguna orden en proceso.

7001

Primera llamada: Orden lanzada (Busy = 1, Done = 0).

7002

Llamada intermedia: Orden ya activa (Busy =1, Done =0).

8080

Valor no válido del parámetro "Mode".

8081 (solo S7-1200)

No hay insertada ninguna SIMATIC Memory Card.

8086

El sistema R/H no está en el estado del sistema RUN-Redundant. Por este motivo, los datos de la otra
CPU no están disponibles.

8091

El valor seleccionado del parámetro "Mode" solo está permitido con las CPU S7-1500 R/H.

8092

No hay datos, p. ej. porque la CPU no soporta "GetSMCinfo".

80C3

Se ha alcanzado el número máximo de llamadas simultáneas de la instrucción "GetSMCinfo".

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
En el siguiente ejemplo se determina el tamaño de memoria de la SIMATIC Memory Card
utilizada.
Para almacenar los datos deben crearse las variables siguientes en un bloque de datos global.

2814

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Se crea un FB. En el área de estado del FB se crea una variable local "#done" con el tipo de
datos Bool.
Los parámetros de la instrucción "GetSMCinfo" se interconectan del siguiente modo.

Cuando el parámetro de entrada REQ ("execute") devuelve el estado lógico "TRUE", se
ejecuta la instrucción "GetSMCinfo". Mediante el parámetro de entrada MODE ("mode") se
guarda en la SIMATIC Memory Card el modo que debe utilizarse para la lectura. De acuerdo
con el valor "0", se lee la capacidad de memoria de la SIMATIC Memory Card y se indica en
KB en el parámetro INFO ("getInfo"). El estado correcto de GetSMCinfo se muestra en el
parámetro de salida DONE ("#done") y se guarda en la variable "done".
En los parámetros de salida STATUS ("status") y ERROR ("error") se indica que el
procesamiento del ejemplo se ha ejecutado sin errores.

Programación del PLC
Manual de programación y manejo, 11/2019

2815

Instrucciones
4.1 Instrucciones
Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

GetClockStatus: Leer estado del reloj de la CPU
Descripción
La instrucción "GetClockStatus" permite leer la información siguiente sobre el reloj interno de
la CPU:
● Información sobre si está activada la sincronización horaria vía servidor NTP (bit 1 del
parámetro ClockStatus) en las propiedades de la CPU.
● Información sobre si se han omitido sincronizaciones horarias (bit 0 del parámetro
ClockStatus).
● Información sobre si está activado el horario de verano o la hora estándar (bit 2 del
parámetro ClockStatus).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GetClockStatus":
Parámetros

Declaración

Tipo de datos

Descripción

ClockStatus

Output

WORD

Estado del reloj interno de la CPU:
● Bit0: Información sobre si se han omitido sincronizaciones horarias
–

Bit0 = 1: Se han omitido una o varias sincronizaciones horarias.

–

Bit0 = 0: No se ha omitido ninguna sincronización horaria.

Nota sobre la evaluación del bit0: El Bit0 solo se puede evaluar si la
sincronización horaria está activada, es decir, si Bit1 = 1.
El Bit0 se pone a 0 en los casos siguientes:
–

Tras un rearranque de la CPU

–

Después de ajustar la hora

Tenga en cuenta que, en el caso de una CPU S7-1500, la transición
a 1 no se produce hasta tres minutos después de una sincronización
horaria omitida.
● Bit1 = 1: La sincronización horaria está activada.
● Bit2
–

= 1: Horario de verano activado

–

= 0: Hora estándar activada

● Bits 3 a 15: 0 (reservado)
Ret_Val

2816

Output

INT

Valor de retorno

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en Vista general de los tipos de
datos válidos (Página 241)

Parámetro Ret_Val
Código de error*
(W#16#...)

Explicación

0

Ningún error

8092

No hay datos disponibles, p. ej. porque la CPU no asiste "GetClockStatus".

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
En el ejemplo siguiente se determina el estado del reloj interno de la CPU.
Para almacenar los datos se crean una variable y una estructura con cinco variables en un
bloque de datos global.

Interconectar parámetros
La instrucción "GetClockStatus" se llama en una FC. En la FC se crean las siguientes variables
locales:

Segmento 1: Los parámetros de la instrucción "GetClockStatus" se interconectan del siguiente
modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2817

Instrucciones
4.1 Instrucciones
Para descifrar la información de estado del reloj interno de la CPU, la variable "#clockStatus"
se interconecta del siguiente modo.
Segmento 2:

Segmento 3:

Segmento 4:

2818

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Resultado
Si la CPU está en RUN se ejecuta la instrucción "GetClockStatus". En el parámetro de salida
CLOCKSTATUS ("#clockStatus") se emite el estado del reloj interno de la CPU con el tipo de
datos WORD. En los segmentos siguientes (2 a 4) se descifra este valor de estado y se emite
en la estructura "itemiseClockStatus" en forma de nombre explícito.
En el parámetro de salida RET_VAL ("returnValue") se indica que la ejecución se ha realizado
sin errores.

Código del programa
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

DeviceStates: Leer la información de estado de los módulos en un sistema IO
Descripción
Con la instrucción "DeviceStates" se consulta una determinada información de estado de
todos los módulos de un sistema IO, es decir:
● o bien de todos los dispositivos IO de un sistema PROFINET IO,
● o bien de todos los esclavos DP de un sistema maestro DP
Se indica en forma de valor booleano en qué módulos se cumple el estado seleccionado. Por
ejemplo, lea qué dispositivos IO están desactivados en un sistema PROFINET IO.
Además, se indica si la información de estado que se va a leer se cumple en al menos uno de
los dispositivos IO o esclavos DP.
La instrucción puede llamarse tanto en el OB cíclico como en el OB de alarma (p. ej. OB82 alarma de diagnóstico).

Programación del PLC
Manual de programación y manejo, 11/2019

2819

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DeviceStates":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

LADDR

Input

HW_IOSYSTEM I, Q, M, L o constante

MODE

Input

UINT

I, Q, M, D, L o constante Selección de la información de estado
que se va a leer (ver descripción abajo)

RET_VAL

Return

INT

I, Q, M, D, L

Estado de la instrucción (ver descripción
abajo)

STATE

InOut

VARIANT

I, Q, M, D, L

Búfer para el estado del dispositivo IO o
del esclavo DP (ver descripción abajo)

ID de hardware del sistema PROFINET
IO o maestro DP (ver descripción abajo)

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro LADDR
El sistema PROFINET IO o maestro DP se selecciona en el parámetro LADDR mediante la ID
de hardware.
La ID de hardware se puede consultar:
● o bien en las propiedades del sistema PROFINET IO o maestro DP en la vista de redes,
● o bien en la tabla de variables PLC, en la lista de constantes del sistema con el tipo de datos
HW_IOSYSTEM.

Parámetro MODE
Seleccione la información de estado que se va a leer con el parámetro MODE. Se puede leer
una de las siguientes informaciones de estado para todo el sistema PROFINET IO o maestro
DP:
● 1: Los dispositivos IO/esclavos DP están configurados
● 2: Los dispositivos IO/esclavos DP fallan
● 3: Los dispositivos IO/esclavos DP están desactivados
● 4: Los dispositivos IO/esclavos DP están disponibles
● 5: Los dispositivos IO/esclavos DP presentan problemas. Por ejemplo:
– Mantenimiento necesario o recomendado
– No accesible
– No disponible
– Se han producido errores

Parámetro STATE
El parámetro STATE emite el estado del dispositivo IO/esclavo DP seleccionado con el
parámetro MODE.

2820

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si el estado seleccionado con MODE se cumple en un dispositivo IO/esclavo DP, los
siguientes bits se ponen a "1" en el parámetro STATE.
● Bit 0 = 1: Indicador de grupo. El bit n de al menos un dispositivo IO/esclavo DP se ha puesto
en "1".
● Bit n = 1: El estado seleccionado mediante MODE se aplica al dispositivo IO/esclavo DP.
– En un sistema PROFINET IO el bit n equivale al número de dispositivo del dispositivo IO
correspondiente (ver Propiedades de la interfaz PROFINET en la vista de dispositivos
y redes).
– En un sistema PROFIBUS DP el bit n equivale a la dirección PROFIBUS del esclavo DP
(ver Propiedades del esclavo DP en la vista de dispositivos y redes).
Como tipo de datos se utiliza BOOL o Array of BOOL:
● Para emitir exclusivamente el bit del indicador de grupo de la información de estado, se
puede utilizar el tipo de datos BOOL en el parámetro STATE.
● Para emitir información de estado de todos los dispositivos IO/esclavos DP, utilice Array of
BOOL con la siguiente longitud:
– Sistema PROFINET IO: 1024 bits
– Sistema maestro DP: 128 bits

Parámetro RET_VAL
Código de
error*

Descripción

(W#16#...)
0

Ningún error

8091

ID de hardware del parámetro LADDR no disponible. Compruebe (p. ej. en las constantes del sistema) si
existe el valor de LADDR en el proyecto.

8092

LADDR no direcciona ningún sistema PROFINET IO o maestro DP.

8093

Tipo de datos no válido en el parámetro STATE.

80B1

La instrucción "DeviceStates" no está soportada por la CPU.

80B2

El parámetro seleccionado MODE no está soportado por la CPU utilizada para el sistema IO indicado en el
parámetro LADDR.

8452

La información de estado completa no cabe en la variable configurada en el parámetro STATE.
Nota: Al comprobar si la variable configurada en STATE tiene suficiente longitud de campo se llama la
instrucción CountOfElements. Esta también cuenta los elementos de relleno cuando el tipo de datos VA‐
RIANT señala a un Array of BOOL; con un Array [0...120] of BOOL, por ejemplo, se determina 128 como
longitud de campo. Como consecuencia, DeviceStates no devuelve el código de error W#16#8452 hasta que
el número de elementos de campo especificado por el usuario más el número de elementos de relleno
generados por la CPU no rebasen 1024 o 128 por defecto.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

2821

Instrucciones
4.1 Instrucciones

Ejemplo: Detección de presencia en el sistema maestro PROFINET IO
En el siguiente ejemplo se consulta la existencia de dispositivos IO en un sistema IO. El
sistema IO está compuesto por dos CPU de la serie S7-1500. La CPU "PLC_14" debe contener
el programa, incluida la instrucción "DeviceStates". La CPU "PLC_13" debe estar configurada
como dispositivo IO.
En la CPU "PLC_14": Para almacenar los datos se crean tres variables y una estructura
"mySTATE" (del tipo de datos Array of BOOL) en un bloque de datos global.

En la CPU "PLC_14": La instrucción se llama en un OB cíclico. Los parámetros de la instrucción
se interconectan del siguiente modo.

En la CPU "PLC_13": En las propiedades de la CPU "PLC_13", se configura esta como
dispositivo IO. El dispositivo IO recibe el número de dispositivo 1.

2822

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

En la vista de redes se muestra un sistema IO.

En la CPU "PLC_14": El parámetro LADDR ("myLADDR") da a conocer el identificador HW del
sistema IO a la instrucción "DeviceStates". De acuerdo con el valor "4" del parámetro MODE
("myMODE"), se buscan dispositivos IO en el sistema IO.
En el parámetro STATE ("mySTATE") se indica la existencia de los dispositivos IO (de acuerdo
con el valor del parámetro MODE) . El bit 0 sirve como valor general e indica que existen
dispositivos IO. El bit 1 indica que está presente el dispositivo IO con el número de dispositivo
1.
En el parámetro de salida RET_VAL ("returnValue") se indica que la ejecución se ha realizado
sin errores.

Programación del PLC
Manual de programación y manejo, 11/2019

2823

Instrucciones
4.1 Instrucciones
Código del programa
Encontrará información adicional y el código del programa para el ejemplo anterior aquí:
Sample Library for Instructions (Página 615).

Ejemplo: lectura de las estaciones averiadas de un sistema maestro PROFINET IO.
Un sistema PROFINET IO contiene 4 dispositivos IO con los números de dispositivo 1, 2, 3 y
4. El dispositivo IO con el número 2 está averiado.
La instrucción "DeviceStates" se ejecuta para el sistema PROFINET IO con MODE = 2
(averiado/no averiado).
En el parámetro STATE se activan los siguientes bits:
● Bit 0 = 1: Existe una avería en al menos uno de los dispositivos IO.
● Bit 1 = 0: El dispositivo IO con el número de dispositivo 1 no está averiado.
● Bit 2 = 1: El dispositivo IO con el número de dispositivo 2 está averiado.
● Bit 3 = 0: El dispositivo IO con el número de dispositivo 3 no está averiado.
● Bit 4 = 0: El dispositivo IO con el número de dispositivo 4 no está averiado.
● Bit 5 = 0: Irrelevante
● Bit 6 = 0: Irrelevante
● ...

Ejemplo: lectura de las estaciones averiadas de un sistema maestro PROFIBUS DP
Un sistema maestro DP contiene 4 esclavos DP con las direcciones PROFIBUS 3, 4, 5 y 6. El
esclavo DP con la dirección 4 está averiado.
La instrucción "DeviceStates" se ejecuta para el sistema maestro DP con MODE = 2 (averiado/
no averiado).
En el parámetro STATE se activan los siguientes bits:
● Bit 0 = 1: Existe una avería en al menos uno de los esclavos DP.
● Bit 1 = 0: Irrelevante
● Bit 2 = 0: Irrelevante
● Bit 3 = 0: El esclavo DP con la dirección 3 no está averiado.
● Bit 4 = 1: El esclavo DP con la dirección 4 está averiado.
● Bit 5 = 0: El esclavo DP con la dirección 5 no está averiado.
● Bit 6 = 0: El esclavo DP con la dirección 6 no está averiado.
● Bit 7 = 0: Irrelevante
● Bit 8 = 0: Irrelevante
● ...

2824

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

ModuleStates: Leer información de estado del submódulo de un módulo
Descripción
Con la instrucción "ModuleStates" se lee información de estado de los módulos de un
dispositivo PROFINET IO o un esclavo PROFIBUS DP.
Se indica en forma de valor booleano en qué módulos se cumple el estado seleccionado. Por
ejemplo, se puede leer qué módulos están desactivados en un dispositivo PROFINET IO.
Además, se indica si la información de estado que se va a leer se cumple en al menos uno de
los módulos.
La instrucción puede llamarse tanto en el OB cíclico como en el OB de alarma (p. ej. OB82 alarma de diagnóstico).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "ModuleStates":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

LADDR

Input

HW_DEVICE

I, Q, M, D, L o cons‐
tante

ID de hardware de la estación (ver descripción
abajo)

MODE

Input

UINT

I, Q, M, D, L o cons‐
tante

Selección de la información de estado de los
módulos que se va a leer (ver descripción aba‐
jo)

RET_VAL

Return

INT

I, Q, M, D, L

Estado de la instrucción (ver descripción aba‐
jo)

STATE

InOut

VARIANT

I, Q, M, D, L

Búfer para el estado de los módulos (ver des‐
cripción abajo)

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro LADDR
El dispositivo IO o el maestro DP se selecciona en el parámetro LADDR mediante el ID de
hardware de la estación.
El ID de hardware se puede consultar:
● O bien en la vista de redes, en las propiedades de la estación del dispositivo IO o del
esclavo DP,
● o bien en la tabla de variables PLC, en la lista de constantes del sistema con el tipo de datos
HW_DEVICE (para un dispositivo IO) o con el tipo de datos HW_DPSLAVE (para un
esclavo DP).

Programación del PLC
Manual de programación y manejo, 11/2019

2825

Instrucciones
4.1 Instrucciones

Parámetro MODE
Seleccione la información de estado que se va a leer con el parámetro MODE. Se puede leer
en cada caso una de las siguientes informaciones de estado de los módulos:
● 1: Los módulos están configurados
● 2: Los módulos están averiados
● 3: Los módulos están desactivados
● 4: Los módulos están disponibles
● 5: Los módulos presentan problemas. Por ejemplo:
– Mantenimiento necesario o recomendado
– No accesible
– No disponible
– Se han producido errores

Parámetro STATE
El parámetro STATE emite el estado seleccionado con el parámetro MODE de los módulos.
Si el estado seleccionado con MODE se cumple en un módulo, los siguientes bits se ponen a
"1":
● Bit 0 = 1: Indicador de grupo. El bit n de al menos un módulo se ha puesto a "1".
● Bit n = 1: El estado seleccionado mediante MODE se cumple en el módulo del slot n-1
(ejemplo: bit 3 = slot 2).
Como tipo de datos se utiliza BOOL o Array of BOOL:
● Para emitir exclusivamente el bit del indicador de grupo de la información de estado, utilice
el tipo de datos BOOL en el parámetro STATE.
● Para emitir la información de estado de todos los módulos, utilice Array of BOOL con una
longitud de 128 bits.

Parámetro RET_VAL
Código de error* Descripción
(W#16#...)
0

Ningún error

8091

ID de hardware del parámetro LADDR no disponible. Compruebe (p. ej. en las constantes del sistema) si
existe el valor de LADDR en el proyecto.

8092

LADDR no direcciona ningún dispositivo IO o esclavo DP.

8093

Tipo de datos no válido en el parámetro STATE.

80B1

La instrucción "ModuleStates" no está soportada por la CPU.

80B2

El parámetro seleccionado MODE no está soportado por la CPU utilizada para el sistema IO o el esclavo
DP indicado en el parámetro LADDR.

2826

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error* Descripción
(W#16#...)
8452

La información de estado completa no cabe en la variable configurada en el parámetro STATE.
Nota: Al comprobar si la variable configurada en STATE tiene suficiente longitud de campo se llama la
instrucción CountOfElements. Esta también cuenta los elementos de relleno cuando el tipo de datos
VARIANT señala a un Array of BOOL; con un Array [0...120] of BOOL, por ejemplo, se determina 128 como
longitud de campo. Como consecuencia, ModuleStates no devuelve el código de error W#16#8452 hasta
que el número de elementos de campo especificado por el usuario más el número de elementos de relleno
generados por la CPU no rebasen por defecto el valor 128.

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
En el siguiente ejemplo se consulta la presencia de módulos de un dispositivo PROFINET IO.
El sistema IO está compuesto por dos CPU de la serie S7-1500. La CPU "PLC_14" debe
contener el programa, incluida la instrucción "ModuleStates". La CPU "PLC_13" debe estar
configurada como dispositivo IO.
En la CPU "PLC_14": Para almacenar los datos se crean tres variables y una estructura
"mySTATE" (del tipo de datos Array of BOOL) en un bloque de datos global.

En la CPU "PLC_14": La instrucción se llama en un OB cíclico. Los parámetros de la instrucción
se interconectan del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2827

Instrucciones
4.1 Instrucciones

En la CPU "PLC_13": En las propiedades de la CPU "PLC_13", se configura esta como
dispositivo IO.

En la vista de redes se muestra un sistema IO.

En la CPU "PLC_14": Hay un módulo en el slot 1 del dispositivo IO.

2828

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En la CPU "PLC_14": El parámetro LADDR ("myLADDR") da a conocer el identificador HW del
dispositivo IO a la instrucción "ModuleStates". De acuerdo con el valor "4" del parámetro
MODE ("myMODE"), se buscan módulos en el dispositivo IO.
En el parámetro STATE ("mySTATE") se indica la presencia de los módulos (de acuerdo con
el valor del parámetro MODE) . El bit 0 sirve como valor general e indica que existen módulos.
El bit 2 indica que hay un módulo en el slot 1.
En el parámetro de salida RET_VAL ("returnValue") se indica que la ejecución se ha realizado
sin errores.

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Ejemplo
Un dispositivo IO contiene 4 módulos en los slots 1 a 4. El módulo del slot 2 está averiado.
La instrucción "ModuleStates" se ejecuta para el dispositivo IO con MODE = 2 (averiado/no
averiado).
En el parámetro STATE se activan los siguientes bits:
● Bit 0 = 1: Al menos uno de los módulos está averiado.
● Bit 1 = 0: Número de slot 0 (ocupado por dispositivo IO)
● Bit 2 = 0: El módulo del slot número 1 no está averiado.
● Bit 3 = 1: El módulo del slot número 2 está averiado.
● Bit 4 = 0: El módulo del slot número 3 no está averiado.
● Bit 5 = 0: El módulo del slot número 4 no está averiado.
● Bit 6 = 0: Irrelevante
● Bit 7 = 0: Irrelevante

Programación del PLC
Manual de programación y manejo, 11/2019

2829

Instrucciones
4.1 Instrucciones

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

GEN_DIAG: Generar información de diagnóstico
Descripción
La instrucción "GEN_DIAG" genera información de diagnóstico sobre componentes de
hardware de otros fabricantes para utilizarla en el diagnóstico del TIA Portal. Para poder usar
la instrucción, debe haberse instalado previamente el archivo GSD(GSDL/GSDML)
suministrado por el fabricante.
La instrucción genera todos los eventos de diagnóstico (también para mantenimiento
necesario).
● El parámetro LADDR permite seleccionar los componentes de hardware para los que se
desea generar un evento de diagnóstico.
● El parámetro MODE permite especificar si el evento es entrante o saliente.
● El parámetro DiagEvent permite definir el evento de diagnóstico en la estructura
DiagnosticDetail. Si se define una variable en el parámetro DiagEvent, la estructura se crea
de forma automática en la interfaz local del bloque.
La información de diagnóstico se proporciona de modo síncrono. La transmisión de la
información de diagnóstico y la emisión de avisos se producen de modo asíncrono.

ATENCIÓN
No se permiten mensajes de error específicos de seguridad (fail-safe)
Si se define información de diagnóstico específica de seguridad en el parámetro DiagEvent,
la instrucción lo comprueba y se emite el código de error 80A1.

2830

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GEN_DIAG":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

LADDR

Input

HW_ANY

I, Q, M, D, L o cons‐
tante

Número de identificación del componente de
hardware

MODE

Input

UINT

I, Q, M, D, L o cons‐
tante

Selección de la información entrante/saliente:
● 1: El evento de diagnóstico especificado es
un evento entrante
● 2: El evento de diagnóstico especificado es
un evento saliente
● 3: Todos los eventos de diagnóstico son
salientes. Según esta información, no
existe ningún fallo en el componente de
hardware (símbolo de diagnóstico verde).
El parámetro DiagEvent no se evalúa si
MODE = 3.

DiagEvent

InOut

DiagnosticDetail

L, D

Especifica el evento de diagnóstico (véase
"Parámetro DiagEvent").

RET_VAL

Return

INT

I, Q, M, D, L

Estado de la instrucción/mensaje de error
(véase "Parámetro RET_VAL").

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2831

Instrucciones
4.1 Instrucciones

Parámetro DiagEvent
La estructura DiagnosticDetail es un tipo de datos de sistema para especificar el evento de
diagnóstico con el siguiente formato:
Parámetro

Tipo de datos

Descripción

DiagnosticDe‐ Struct
tail
Channe‐
lInfo

WORD

Propiedades del canal (0...7)

ALID

UINT

ID local del aviso. Con la ID se identifica el aviso de forma unívoca.

TextID

UINT

ID de un texto de aviso en una lista de textos.

Channel‐ UINT
Number

Número de canal específico del fabricante (0x0000 — 0x7FFF)

Addval_0 DWORD

Comodines para información adicional. El valor/la lista de valores depende del error de
conexión.

TextID2

Textos para la reacción de la CPU (estado operativo, llamadas de OB, etc.).

UINT

LADDR

HW_ANY

Idéntico al parámetro LADDR.

TextLis‐
tId

UINT

● 0: Sin lista de textos
● ≠0: ID de la lista de textos

Channel‐ UINT
Direction

● 0000: Irrelevante
● FFF1: Input
● FFF2: Output
● FFF3: Input/Output

Addval_1 DWORD

Comodines para información adicional sobre el fallo de canal (en función del archivo
GSD).
En relación con los tipos de fallos de canal, véase también: norma IEC 61158 (PROFINET
IO Type 10 and PROFIBUS DP Type 3).

Parámetro RET_VAL
Código de
error*
(W#16#...)

Explicación

0

Ningún error

8080

Valor del parámetro MODE no soportado.

8090

Número de identificación para el componente de hardware del parámetro LADDR no disponible.

8091

No es posible generar información de diagnóstico para el componente de hardware direccionado con el
parámetro LADDR.

80A1

● Contenido de la estructura DiagnosticsDetail del parámetro DiagEvent no válida o incoherente.
● Información de diagnóstico específica de seguridad (fail-safe) definida en el parámetro DiagEvent (no
permitido).

80A4

Componente de hardware direccionado no accesible.

80C1

Recursos insuficientes para la ejecución paralela.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

2832

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

GET_DIAG: Leer información de diagnóstico
Descripción
La instrucción "GET_DIAG" permite leer la información de diagnóstico de un componente de
hardware. La selección del componente de hardware se realiza con el parámetro LADDR. El
parámetro MODE selecciona qué información de diagnóstico se va a leer. La CPU S7-1200
ignora el parámetro LADDR si MODE=0.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "GET_DIAG":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MODE

Input

UINT

I, Q, M, D, L o constante El parámetro MODE selecciona qué da‐
tos de diagnóstico se deben emitir.

LADDR

Input

HW_ANY
(UINT)

I, Q, M, L o constante

Identificador de hardware del componen‐
te de hardware

RET_VAL

Return

INT

I, Q, M, D, L

Estado de la instrucción

CNT_DIAG

Output

UINT

I, Q, M, D, L

Reservado (siempre "0").

DIAG

InOut

VARIANT

I, Q, M, D, L

Consulte en la siguiente tabla la informa‐
ción de diagnóstico en función del modo
seleccionado

DETAIL

InOut

VARIANT

I, Q, M, D, L

Parámetro ocultado. No use este paráme‐
tro.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

2833

Instrucciones
4.1 Instrucciones

Parámetro MODE
En función del valor del parámetro MODE, se emiten datos de diagnóstico distintos a través de
los parámetros de salida DIAG, CNT_DIAG y DETAIL.
MODE

Descripción

DIAG

CNT_DIAG

0

Salida de toda la información de diag‐
nóstico soportada para un componen‐
te de hardware como DWORD, en la
que bit X=1 indica que el modo X se
soporta.

Bits del tipo de datos DWORD:

0

● Bit 0 = 1: Se soporta el MODE 0
● Bit 1 = 1: Se soporta el MODE 1
● Bit 2 = 1: Se soporta el MODE 2
● Bits 3 a 31: No relevante
Si MODE=0, la CPU S7-1200 igno‐
ra el parámetro LADDR.

1

Salida del estado de diagnóstico del
componente de hardware direcciona‐
do.

Estructura DIS (ver descripción más 0
adelante):
● MaintenanceState
● ComponentStateDetail
● OwnState
● IOState
● OperatingState

2

Salida del estado de todos los compo‐ Estructura DNN (ver descripción
nentes subordinados del componente más adelante):
de hardware direccionado.
● SubordinateState

0

● SubordinateIOState
● DNNmode

Estructura DIS
En el parámetro MODE = 1 se emite la información de diagnóstico conforme a la estructura
DIS. En tal caso indique como tipo de datos el tipo de datos del sistema "DIS" en la declaración
de variables.
Nota
Determinación del OperatingState
Para determinar el OperatingState de una CPU estándar hay que seleccionar LADDR = 52
(identificador de hardware de CPUExecUnit).
Para determinar el OperatingState de una CPU de un sistema R/H hay que seleccionar LADDR
= 65147 (identificador de hardware de Local1~HCPUredCtrl) o LADDR = 65347 (identificador
de hardware de Local2~HCPUredCtrl).
Para determinar el estado del sistema de un sistema R/H hay que seleccionar LADDR = 34
(identificador de hardware de Local1~RHSystem).

2834

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el significado de los valores individuales de los parámetros.
Parámetro

Tipo de
datos

Valor

MaintenanceS‐ DWOR
tate
D

Enum
0

Descripción

Reglas para crear el parámetro
MaintenanceState depende de Compo‐
nentStateDetail.

Bueno

● El bit 15 de ComponentStateDetail es
siempre 1.
● Los bits 11 a 14 de
ComponentStateDetail pueden tener el
valor 0 o 1.
● El bit 3 de ComponentStateDetail puede
ser 1.
● Los demás bits de
ComponentStateDetail son 0.

1

El componente de hardware está desac‐ ● Si el bit 16 de ComponentStateDetail es
tivado.
1.
● Si el bit 17 de ComponentStateDetail es
1.

2

-

-

3

-

-

4

-

-

5

Mantenimiento necesario

Si el bit 4 de ComponentStateDetail es 1.

6

Mantenimiento solicitado

Si el bit 5 de ComponentStateDetail es 1.

7

Error

Si el bit 6 de ComponentStateDetail es 1.

8

Estado desconocido/error en el compo‐
nente de hardware de nivel superior

● Si los bits 11 a 14 de
ComponentStateDetail tienen el valor 3.
● Si los bits 7 a 10 de
ComponentStateDetail tienen el valor 3
o 4.

9

-

-

10

Las entradas/salidas no están disponi‐
bles.

● Si los bits 11 a 14 de
ComponentStateDetail tienen el valor 2.
● Si los bits 7 a 10 de
ComponentStateDetail tienen el valor 1
o 2.
● Si el bit 18 de ComponentStateDetail es
1.
● Si el bit 19 de ComponentStateDetail es
1.

Programación del PLC
Manual de programación y manejo, 11/2019

2835

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de
datos

Valor

Descripción

Reglas para crear el parámetro

ComponentS‐
tateDetail

DWOR
D

Matriz
de bits

Estado:

-

● Bits de 0 a 15: Estado del
componente de hardware
● Bits 16 a 31: Estado de la CPU

0a2
Información adicional:
(Enum) ● 0: No hay información adicional

-

● 1: No se puede aplicar
3

Bit 3 = 1, si se dispone como mínimo de
un diagnóstico cualificado

-

4

Bit 4 = 1: Mantenimiento necesario en
por lo menos un canal o del componente

5

Bit 5 = 1: Mantenimiento solicitado en por lo menos un canal o del componente

6

Bit 6 = 1: Error en por lo menos un canal
o del componente

-

de 7 a ● 0: Own - El componente de hardware
10
está disponible
(Enum)
● 1: Application Ready Pending Ningún acceso E/S

-

● 2: Locked by Superordinated - Sin
acceso al componente de hardware
● 3: Locked by IOController - Sin
acceso al componente de hardware
● 4: Locked by IOSupervisor - Sin
acceso al componente de hardware
de 11 a ● 0 (bit 11 = 0, bit 12 = 0, bit 13 = 0, bit
14
14 = 0): OK - el elemento correcto
(Enum)
está presente.

-

● 1 (bit 11 = 1, bit 12 = 0, bit 13 = 0, bit
14 = 0): Substitute - el elemento se ha
sustituido por un elemento
compatible.
● 2 (bit 11 = 0, bit 12 = 1, bit 13 = 0, bit
14 = 0): Wrong - el elemento se ha
reemplazado por un elemento no
compatible (el elemento está
accesible pero no está listo).
● 3 (bit 11 = 1, bit 12 = 1, bit 13 = 0, bit
14 = 0): No Submodule - el elemento
no existe.
15

Reservado (siempre "1")

de 16 a Información de estado de los módulos
31
generada por la CPU:

-

● Bit 16 = 1: submódulo o módulo
desactivado

2836

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de
datos

Valor

Descripción

Reglas para crear el parámetro

● Bit 17 = 1: operación CiR activa
● Bit 18 = 1: entrada no disponible
● Bit 19 = 1: salida no disponible
● Bit 20 = 1: desbordamiento del búfer
de diagnóstico
● Bit 21 = 1: diagnóstico no disponible
● Bit 22 = 1: Partial device failure (en
PNIO para Shared iDevices)
● Bits 23 - 31: reservado (siempre 0)
OwnState

UINT

Enum

Estado de mantenimiento

OwnState depende de MaintenanceState.

0

Bueno

Si MaintenanceState tiene el valor 0.

1

Desactivado

Si MaintenanceState tiene el valor 1.

2

Mantenimiento necesario

Si MaintenanceState tiene el valor 5.

3

Mantenimiento solicitado

Si MaintenanceState tiene el valor 6.

4

Error

Si MaintenanceState tiene el valor 7.

5

No accesible

Si MaintenanceState tiene el valor 8.

6

Estado de diagnóstico desconocido

Valor predeterminado para componentes
que no proporcionan ningún evento de diag‐
nóstico.

7

IO not available - Las entradas/salidas
no están disponibles.

Si MaintenanceState tiene el valor 10.

Programación del PLC
Manual de programación y manejo, 11/2019

2837

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de
datos

Valor

Descripción

Reglas para crear el parámetro

IOState

WORD

Matriz
de bits

Estado de E/S del componente de hard‐ Pueden estar activados uno o varios bits.
ware
IOState depende de ComponentStateDetail.

Bit 0 =
1

Bueno

● El bit 15 de ComponentStateDetail es
siempre 1.
● Los bits 11 a 14 de
ComponentStateDetail pueden tener el
valor 0 o 1.
● El bit 3 de ComponentStateDetail puede
ser 1.
● Los demás bits de
ComponentStateDetail son 0.
Si el bit 0 es 1, los bits 1 a 5 y el bit 7 son 0.

Bit 1 =
1

Desactivado

● Si el bit 16 de ComponentStateDetail es
1.
● Si el bit 17 de ComponentStateDetail es
1.
Si el bit 1 = 1, todos los demás bits = 0.

Bit 2 =
1

Mantenimiento necesario

Si el bit 4 de ComponentStateDetail es 1.

Bit 3 =
1

Mantenimiento solicitado

Si el bit 5 de ComponentStateDetail es 1.

Bit 4 =
1

Error

Si el bit 6 de ComponentStateDetail es 1.

Bit 5 =
1

Hardware component not reachable Componente de hardware no accesible.

● Si los bits 11 a 14 de
ComponentStateDetail tienen el valor 3.
● Si los bits 7 a 10 de
ComponentStateDetail tienen el valor 3
o 4.
Si el bit 5 es 1, todos los demás bits son 0.

Bit 6 =
1

Qualified: Bit 6 = 1, si se dispone como
mínimo de un diagnóstico cualificado

Si el bit 3 de ComponentStateDetail es 1.

Bit 7 =
1

I/O data not available - Datos de E/S no
disponibles

● Si los bits 11 a 14 de
ComponentStateDetail tienen el valor 2.

En tal caso, se activan los bits 0, 2 o 3.

● Si los bits 7 a 10 de
ComponentStateDetail tienen el valor 1
o 2.
● Si el bit 18 de ComponentStateDetail es
1.
● Si el bit 19 de ComponentStateDetail es
1.
de 8 a
14

Reservado (siempre "0")

-

Bit 15

Error de red / hardware:

-

● S7-1200: Reservado (siempre "0")
● S7-1500: Si el bit 4 = 1 o el bit 5 = 1:

2838

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de
datos

Valor

Descripción

Programación del PLC
Manual de programación y manejo, 11/2019

–

Bit 15 = 0: Error de red

–

Bit 15 = 1: Error de hardware

Reglas para crear el parámetro

2839

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de
datos

OperatingState UINT

2840

Valor

Descripción

Enum

Reglas para crear el parámetro
-

0

Not Supported - OperatingState siempre
tiene el valor 0 para módulos E/S.

-

1

STOP / actualización del firmware

-

2

STOP / borrado total

-

3

STOP / autoarranque

-

4

STOP

-

5

Borrado total

-

6

Arranque

-

7

-

-

8

RUN

-

9

RUN-Redundant

-

10

PARADA

-

11

-

-

12

-

-

13

DEFECTUOSO (nota: solo se ve en las
entradas del búfer de diagnóstico)

-

14

-

-

15

Sin tensión (nota: solo se ve en las en‐
tradas del búfer de diagnóstico)

-

16

CiR

-

17

STOP sin ODIS

-

18

RUN ODIS

-

19

PgmTest

-

20

RunPgmTest (estado de la CPU primaria
cuando la CPU de reserva está en modo
de test)

-

21

Run-Syncup (solo CPU primaria en el
estado de sistema SYNCUP)

-

22

SYNCUP (solo CPU de reserva en esta‐ do del sistema SYNCUP)

31

Se desconoce el estado desconocido de
la otra CPU (p. ej. cuando la otra CPU no
está disponible)

-

32

-

-

33

Estado del sistema STOP

-

34

reservado

-

35

Estado del sistema ARRANQUE

-

36

reservado

-

37

Estado del sistema RUN-Solo

-

38

Estado del sistema SYNCUP

-

39

reservado

-

40

Estado del sistema RUN-Redundant

-

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Estructura DNN
En el parámetro MODE = 2 se emiten los detalles de la información de diagnóstico conforme
a la estructura DNN. En tal caso indique como tipo de datos el tipo de datos del sistema "DNN"
en la declaración de variables.
La tabla siguiente muestra el significado de los valores individuales de los parámetros.
Parámetro

Tipo de datos

Valor

Descripción

SubordinateState

UINT

Enum

Estado del componente subordinado (véase el parámetro OwnS‐
tate de la estructura DIS)

SubordinateIOState

WORD

Bitarray

Estado de las entradas y salidas del componente subordinado
(véase el parámetro IO State de la estructura DIS)

DNNmode

WORD

Bitarray

● Bit 0 = 0: Diagnóstico activado
● Bit 0 = 1: Diagnóstico desactivado
● Bits de 1 a 15: Reservado

Parámetro RET_VAL
Código de error* Descripción
(W#16#...)
0

Ningún error

n

El área de datos del parámetro DETAIL es demasiado pequeña. No se emiten todos los detalles de los
datos de diagnóstico.

8080

Valor del parámetro MODE no soportado.

8081

El tipo del parámetro DIAG no es soportado por el modo seleccionado (parámetro MODE).

8082

El tipo del parámetro DETAIL no es soportado por el modo seleccionado (parámetro MODE).

8090

LADDR no existe

80C1

Recursos insuficientes para la ejecución paralela.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
En el siguiente ejemplo se lee la información de diagnóstico de una CPU.
Para almacenar los datos se crean cuatro variables y una estructura "myDIAG" (del tipo de
datos DIS) en un bloque de datos global.

Programación del PLC
Manual de programación y manejo, 11/2019

2841

Instrucciones
4.1 Instrucciones

Los parámetros de la instrucción se interconectan del siguiente modo.

El parámetro LADDR ("myLADDR") da a conocer el identificador de HW de la CPU a la
instrucción "GET_DIAG". De acuerdo con el valor "1" del parámetro MODE ("diagMODE"), se
aplica lo siguiente:
● La instrucción lee el estado del objeto de hardware direccionado (la CPU).
● En el parámetro DIAG ("myDIAG") se emite la información de diagnóstico en una estructura
(tipo de datos DIS).
Para comprender la información de diagnóstico es necesario convertir los valores
hexadecimales a código binario. En el parámetro DIAG ("myDIAG") se indica lo siguiente:
● MaintenanceState: de acuerdo con el valor "0", la CPU no requiere mantenimiento.
● ComponentStateDetail: de acuerdo con el valor hexadecimal "0000_8000", el bit 15 está
activado.
● OwnState: de acuerdo con el valor "0", no se ha producido ninguna avería.
● IOState: de acuerdo con el valor hexadecimal "0001", no se requiere mantenimiento.
● OperatingState: devuelve "0".
En el parámetro de salida RET_VAL ("returnValue") se indica que la ejecución se ha realizado
sin errores. El parámetro de salida CNT_DIAG ("CountDiagDetails") indica que se han emitido
"0" detalles de diagnóstico del parámetro DETAIL.

2842

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Nota: Por ejemplo, puede leerse individualmente el bit 3 (diagnóstico de canal sí/no) de la
variable ComponentStateDetail.
● Direccione el bit del modo siguiente: ComponentStateDetail.%X3.
Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Ejemplo - Diagnóstico de un dispositivo IO
En el siguiente ejemplo se lee la información de diagnóstico de un dispositivo IO. Para el
diagnóstico se utiliza, por un lado, la vista de dispositivos del dispositivo IO, y por otro la
instrucción GET_DIAG.
Diagnóstico en la vista de dispositivos
Uno de los módulos del dispositivo IO notifica un error. El estado del dispositivo cambia y se
muestra del siguiente modo:

El módulo y el módulo de cabecera del dispositivo IO indican en la vista de dispositivos un
estado colectivo. Por ello, en ambos se indica un error.

Programación del PLC
Manual de programación y manejo, 11/2019

2843

Instrucciones
4.1 Instrucciones

Diagnóstico mediante la instrucción GET_DIAG
Para leer la información de diagnóstico del dispositivo IO se direcciona (a través de LADDR)
el módulo de cabecera del dispositivo IO.
● En el modo 1 (MODE tiene el valor 1) se lee el estado del dispositivo IO.
● En el modo 2 (MODE tiene el valor 2) se lee el estado de los módulos subordinados.
Llamada MODO 1: Autodiagnóstico

Llamada MODO 2: Resumen de los diagnósticos subordina‐
dos

LADDR (ID de hardware) = IM151-3pn~IODevice

LADDR (ID de hardware) = IM151-3pn~IODevice

DIAG (Estructura DIS) = #DeviceData.DeviceState

DIAG (Estructura DNN) = #DeviceData.SubState

DIS.OwnState = 0 (Sin error)

DNN.SubordinateState = 4 (Error)

DIS.IOState = Secuencia de bits 0000 0000 0000 0001

DNN.SubordianteIOState = Secuencia de bits 1000 0000
0001 0001

Resultado
Al contrario que en la vista de dispositivos, la instrucción GET_DIAG no devuelve el estado
colectivo del dispositivo IO. El error del módulo subordinado no se lee hasta el modo 2.

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

2844

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

4.1.4.11

Impulso

CTRL_PWM: Modulación del ancho de impulso
Descripción
La instrucción "CTRL_PWM" permite activar o desactivar por software un generador de
impulsos soportado por la CPU.
● La identificación de hardware del generador de impulsos que debe controlarse mediante la
instrucción se especifica en la entrada PWM.
● Cuando está activado el bit en la entrada ENABLE de la instrucción, el generador de
impulsos se activa.
– Si ENABLE tiene el valor TRUE, el generador genera impulsos con las propiedades
definidas en la configuración de dispositivos.
– Si se desactiva el bit en la entrada ENABLE o la CPU pasa a STOP, se desactiva el
generador de impulsos y ya no se generan impulsos.
Puesto que el S7-1200 activa el generador de impulsos cuando se ejecuta la instrucción
"CTRL_PWM", BUSY tiene siempre el valor FALSE en el S7-1200.
Si la entrada de habilitación EN devuelve el estado lógico "1" y si no han ocurrido errores
durante la ejecución de la instrucción, se activa la salida de habilitación ENO.
Nota
Uso de la tabla de forzado con PWM y PTO
Las entradas y salidas digitales que se usan para PWM y PTO no se pueden forzar. Las
entradas y salidas digitales asignadas mediante la configuración de dispositivos no se pueden
controlar con la tabla de forzado permanente ni con la tabla de observación.
Nota
Memoria imagen de proceso de las salidas PTO/PWM
No utilice las salidas de PTO/PWM en la memoria imagen de proceso (p. ej. en accesos del
programa de usuario, en funciones online o en HMI). La frecuencia de actualización de la
memoria imagen de proceso es notablemente inferior a la velocidad de los cambios de señal.
Por ello, la indicación en la memoria imagen de proceso no refleja el curso de la señal.

Requisitos
Para poder ejecutar la instrucción correctamente es preciso que el generador de impulsos
especificado esté activado en la configuración hardware.
Para ello, abra las Propiedades del módulo en la Vista de dispositivos. Abra el PTO/PWM
deseado en "Generadores de impulsos (PTO/PWM)" y active la función "Activar este
generador de impulsos" en "General".

Programación del PLC
Manual de programación y manejo, 11/2019

2845

Instrucciones
4.1 Instrucciones
Ajuste las Opciones de impulso en "Parametrización".
Nota
Un generador de impulsos se parametriza exclusivamente en la configuración de dispositivos
y no mediante la instrucción "CTRL_PWM". Por ello, solo es posible modificar los parámetros
que afectan a la CPU cuando esta está en estado operativo STOP. Una excepción es el
cambio de la duración de impulso.

Cambio de la duración de impulso desde el programa de usuario
El ajuste efectuado en el cuadro de diálogo "Opciones de impulso" para definir la duración de
impulso se puede modificar desde el programa de usuario.
El valor ajustado para "Duración de impulso inicial" se escribe en los bytes de salida del
generador de impulsos. La dirección inicial y la dirección final se visualizan en las propiedades
del generador de impulsos en "Direcciones E/S".
Para modificar la duración de impulso, escriba los valores deseados en la dirección de palabra
de salida indicada en la configuración de dispositivos.
Ejemplo:
● Para "Duración de impulso inicial" se utiliza el valor 500 (decimal). La dirección inicial del
PTO/PWM es "1000", la dirección final "1001".
● En ambos bytes de salida se escribe el valor binario "0000000111110100" (=500 decimal).
– Dirección inicial (AB1000): 0000_0001 (BIN)
– Dirección final (AB1001): 1111_0100 (BIN)
Observe que la duración de impulso varía siempre en función del Formato de duración de
impulso parametrizado (centésima, milésima, ...).

Modificar el tiempo de ciclo desde el programa de usuario
Active la casilla de verificación "Permitir modificar el tiempo de ciclo en tiempo de ejecución"
en las "Opciones de impulso" del correspondiente generador de impulsos. Si la casilla de
verificación está activada, los dos primeros bytes de salida contienen la duración de impulso
y del tercero al sexto contienen el tiempo de ciclo.
Durante el tiempo de ejecución del generador de impulsos existe la posibilidad de modificar el
valor de la palabra doble al final de la memoria asignada de las salidas. Con ello se modifica
el tiempo de ciclo de la señal PWM.
Ejemplo: Se activa la casilla de verificación de modo que la CPU asigne seis bytes de salida
a PWM1 y se seleccionan los bytes QB1008 a QB1013. Después de cargar el programa en la
CPU e iniciar el generador de impulsos, es posible modificar la duración de impulso
escribiendo QW1008 y el tiempo de ciclo escribiendo QD1010.

཰
ཱ

2846

ཱ

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Figura 4-1

PWM_ejemplo

① Tiempo de ciclo
② Duración de impulso
Parámetros
La tabla siguiente muestra los parámetros de la instrucción "CTRL_PWM":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

PWM

Input

HW_PWM

I, Q, M, D, L o cons‐
tante

Identificación de hardware del generador de
impulsos
La ID de hardware se puede consultar en las
propiedades del generador de impulsos en la
Vista de dispositivos. Las ID de hardware de
los generadores de impulsos también figuran
en las constantes de sistema.

ENABLE

Input

BOOL

I, Q, M, D, L o cons‐
tante

El generador de impulsos se activa con ENA‐
BLE = TRUE y se desactiva con ENABLE =
FALSE.

BUSY

Output

BOOL

I, Q, M, D, L

Estado de ejecución

STATUS

Output

WORD

I, Q, M, D, L

Estado de la instrucción (véase a continua‐
ción).

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de error*
(W#16#...)

Descripción

0

Ningún error

80A1

La identificación de hardware del generador de impulsos no es válida.

80D0

El generador de impulsos con el identificador HW especificado no está activado. Active el generador de
impulsos en las propiedades de la CPU en el apartado "Generadores de impulsos (PTO/PWM)".

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

CTRL_PTO: Emitir una secuencia de impulsos con una frecuencia predefinida
Descripción
La instrucción "CTRL_PTO" prepara una secuencia de impulsos con una frecuencia
predefinida. Para ello no se necesitan DB de ejes de un objeto tecnológico.
Programación del PLC
Manual de programación y manejo, 11/2019

2847

Instrucciones
4.1 Instrucciones

Requisitos
Para utilizar la instrucción "CTRL_PTO" es imprescindible disponer de un generador de
impulsos activado. Este se activa en la configuración hardware, donde también se elige el tipo
de señal. El generador de impulsos debe indicarse en el parámetro "PTO" y el parámetro
"REQ" debe ponerse a TRUE.
Nota
Uso de un generador de impulsos
Un generador de impulsos puede ser utilizado únicamente por una instrucción a la vez.
Nota
Uso de la tabla de forzado permanente con PWM y PTO
Las entradas y salidas digitales que se usan para PWM y PTO no se pueden forzar
permanentemente. Las entradas y salidas digitales asignadas mediante la configuración de
dispositivos no se pueden controlar con la tabla de forzado permanente ni con la tabla de
observación.
Nota
Memoria imagen de proceso de las salidas PTO/PWM
No utilice las salidas de PTO/PWM en la memoria imagen de proceso (p. ej. en accesos del
programa de usuario, en funciones online o en HMI). La frecuencia de actualización de la
memoria imagen de proceso es notablemente inferior a la velocidad de los cambios de señal.
Por ello, la indicación en la memoria imagen de proceso no refleja el curso de la señal.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "CTRL_PTO":
Parámetro

Declaración

Tipo de datos

Descripción

REQ

Input

BOOL

● REQ=1: pone la frecuencia del generador de impulsos al valor de
FREQUENCY
REQ=1 y FREQUENCY=0 desactiva el generador de impulsos

PTO

Input

HW_PTO

● REQ=0: sin cambios en el generador de impulsos
Identificador de hardware del generador de impulsos
Lo encontrará en las propiedades del generador de impulsos, dentro de la
vista de dispositivos o de la lista de constantes de sistema.
FRE‐
QUENCY

Input

UDINT

DONE

Output

BOOL

Frecuencia de la secuencia de impulsos que se emitirá, en Hz
Parámetro de estado con los valores siguientes:
● 0: Petición no iniciada aún o en ejecución
● 1: Petición finalizada sin errores

BUSY

Output

BOOL

Estado de ejecución
Puesto que el S7-1200 activa el generador de impulsos cuando se ejecuta la
instrucción "CTRL_PTO", BUSY tiene siempre el valor FALSE en el S7-1200.

2848

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Descripción

ERROR

Output

BOOL

Parámetro de estado
● 0: Ningún error
● 1: Se ha producido un error al ejecutar la instrucción.

STATUS

Output

WORD

Estado de la instrucción (véase a continuación)

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro Status
Código de
error*
(W#16#...)

Explicación

0

Ningún error

8090

El generador de impulsos con el ID de hardware especificado ya se utiliza.

8091

Rebase por exceso del rango en el parámetro "FREQUENCY"; consulte el manual para más información.

80A1

El parámetro "PTO" no direcciona ninguna ID de hardware de un generador de impulsos.

80D0

El generador de impulsos con la ID de HW especificada no está activado o no tiene la propiedad "PTO".
Active el generador de impulsos en las propiedades de la CPU, en el apartado "Generadores de impulsos
(PTO/PWM)", y elija el tipo de señal "PTO".

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

4.1.4.12

Recetas y Data Logging

Funciones de receta
Descripción general de las funciones de receta
Descripción
Las instrucciones "RecipeExport" y "RecipeImport" permiten transferir datos de receta
● de un bloque de datos de receta a un archivo CSV de la Memory Card de la CPU
("RecipeExport")
● de un archivo CSV de la Memory Card de la CPU a un bloque de datos de receta
("RecipeImport")

Programación del PLC
Manual de programación y manejo, 11/2019

2849

Instrucciones
4.1 Instrucciones

Nota
Vida útil de las Memory Card
La vida útil de las Memory Cards es limitada. Encontrará más información aquí:
AUTOHOTSPOT

Protección de los datos de receta
Las instrucciones "RecipeExport" y "RecipeImport" no son aptas para aplicaciones que
requieran una protección especial para los datos de receta. Para una mayor protección de los
datos, utilice la función de receta de HMI.

Ubicación del bloque de datos de receta en "RecipeExport"
El bloque de datos que contiene los datos de receta exportados mediante "RecipeExport"
puede encontrarse en la memoria de trabajo o en la memoria de carga. Si el bloque de datos
está presente tanto en la memoria de trabajo como en la memoria de carga, se utilizan los
valores de la memoria de trabajo.

Separadores
Pueden utilizarse distintos separadores para separar los valores de la línea de la receta. Tenga
en cuenta que si el archivo CSV con los datos de receta exportados se abre en Excel, por
ejemplo, puede que las comas sean sustituidas por puntos y viceversa. La razón es que no
todos los idiomas utilizan el mismo separador decimal. Esto puede repercutir en la importación
de archivos CSV. Para "RecipeImport" se aplica la siguiente convención: el primer posible
separador detectado es el que se utilizará para todos los valores de una fila de la tabla.
● Ejemplo 1: Si el primer separador detectado es un punto y coma, al importar se presupone
que también se utiliza el punto y coma como separador para el resto de los valores. Como
separador decimal en un valor del tipo REAL se utiliza una coma.
● Ejemplo 2: Si el primer separador detectado es una coma, al importar se presupone que
también se utiliza la coma como separador para el resto de los valores. Como separador
decimal en un valor del tipo REAL se utiliza un punto.
Si el juego de datos de la receta contiene una cadena de caracteres, asegúrese de que dicha
cadena no contiene el separador utilizado. Asimismo, deberá asegurarse de que la cadena no
contiene caracteres de control que indiquen un salto de línea (en ASCII: LF, CR LF, CR).
Nota: Los espacios en blanco y los tabuladores no se utilizan como separadores. En caso
contrario, al realizar la importación se emitirá el código de error 80B2.
Nota
Procesamiento asíncrono de las funciones de receta
Debido al procesamiento asíncrono de las funciones de receta, los datos del área de origen
deben mantenerse coherentes hasta que el parámetro DONE o el parámetro ERROR se
ponga a "1".

2850

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

RecipeExport: exportar receta
Descripción
La instrucción "RecipeExport" exporta los datos de receta de un bloque de datos a un archivo
CSV en la memoria de carga.
En las CPU S7-1500, el DB que se va a exportar puede estar presente tanto en la memoria de
trabajo como en la memoria de carga. Si está presente en ambas memorias, se exportan los
valores de la memoria de trabajo. En las CPU S7-1200, el DB que se va a exportar debe estar
en la memoria de carga.
El archivo CSV se crea en la memoria de carga. En las CPU S7-1500 es la Memory Card, en
las CPU S7-1200 la memoria de carga interna o externa (en caso de que exista una Memory
Card).
Al exportar se crea el archivo CSV en la carpeta "Recipes", en el directorio de la memoria de
carga. El archivo CSV creado recibe el nombre del bloque de datos. Si ya hay un archivo CSV
con el mismo nombre, dicho archivo se sobrescribirá durante la exportación.
Cada registro de receta genera una fila en el archivo CSV. Estas filas están estructuradas del
siguiente modo:
● La primera fila contiene la entrada "Índice", así como los nombres de los componentes de
la receta.
● Cada una de las filas siguientes contiene el número del registro de receta (índice), así como
sus respectivos componentes.
Si se toman como base los tipos de datos del DB de receta, el tamaño máximo de un registro
es de 5000 bytes. Si se excede este límite, se devuelve el código de error W#16#8092. Esta
limitación a 5000 bytes es válida en correspondencia para el tamaño del encabezado. Si el
encabezado tiene un tamaño superior a 5000 bytes, en una CPU S7-1500 se exporta hasta un
límite de 5000 bytes y la exportación se continúa con el primer registro de receta. En este caso,
una CPU S7-1200 rechaza la exportación completamente y devuelve el código de error
W#16#8092.
Las CPU S7-1200 vigilan además el número de columnas. No se deben exceder las 255
columnas (la columna del índice no está incluida en esta cifra).
Si el DB de receta es un DB con acceso estándar y está formado por más componentes de los
permitidos (p. ej. dos ARRAYs y una estructura), solo se exporta el primer ARRAY y STATUS
se pone a W#16#0000.

Funcionamiento
La exportación se inicia a través del parámetro REQ. Durante la exportación el parámetro
BUSY se pone a "1". Tras ejecutar la instrucción, BUSY se restablece a "0" y en el parámetro
DONE se indica con "1" que la instrucción ha finalizado.
Si se produce algún error durante la ejecución, se indicará mediante los parámetros ERROR
y STATUS.

Programación del PLC
Manual de programación y manejo, 11/2019

2851

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RecipeExport":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L, T, C o
constante

Parámetro de control REQUEST: Activa la ex‐
portación con un flanco ascendente.

(T y C solo están dis‐
ponibles en S7-1500
en KOP y FUP)
RECIPE_DB

InOut

VARIANT

D

DONE

Output

BOOL

I, Q, M, D, L

Puntero hacia el bloque de datos de receta.
Consulte la estructura del bloque de datos
en: Estructura de un DB de receta (Pági‐
na 2857)
Parámetro de estado
● 0: La orden aún no se ha iniciado o todavía
se está ejecutando.
● 1: Orden finalizada sin errores.

BUSY

Output

BOOL

I, Q, M, D, L

Parámetro de estado
● 0: No se ejecuta la instrucción.
● 1: Se ejecuta la instrucción.

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado
● 0: Ni advertencia ni error.
● 1: Hay un error. STATUS devuelve
información detallada sobre el tipo de error.

STATUS

Output

WORD

I, Q, M, D, L

Parámetro de estado
Véase tabla "Parámetro STATUS".

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de
error*
(W#16#...)

Explicación

0

No ha ocurrido ningún error

7000

No se está procesando ninguna orden

7001

Inicio de la ejecución de la orden. Parámetro BUSY = 1, DONE = 0.

7002

Llamada intermedia (REQ irrelevante): la instrucción ya está activa; BUSY tiene el valor "1".

8090

El nombre del archivo CSV contiene caracteres no válidos. El nombre del archivo CSV es idéntico al del
bloque de datos.

8091

La estructura de datos referenciada mediante RECIPE_DB no puede procesarse o el número de columnas
de datos en una CPU S7-1200 excede el valor máximo permitido de 255 columnas. Es posible que el archivo
CSV se haya escrito parcialmente.

8092

La estructura de datos del parámetro RECIPE_DB excede los 5000 bytes.
Para las CPU S7-1200 adicionalmente: El tamaño del encabezado es superior a 5000 bytes. La exportación
se rechaza.

2852

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*
(W#16#...)

Explicación

80B3

No hay espacio suficiente en la Memory Card o en la memoria de carga interna.

80B4

La Memory Card tiene activada la protección contra escritura.

80B6

(Solo en las CPU S7-1200) El atributo "Depositar solo en la memoria de carga" del bloque de datos de receta
no está activado.

80C0

Archivo CSV bloqueado temporalmente.

80C1

Bloque de datos de receta bloqueado temporalmente.

80C3

Recursos insuficientes

8624

RECIPE_DB apunta a un área no admisible, p. ej., a datos locales.

8652

La variable en RECIPE_DB es insuficiente. El archivo CSV no se ha escrito.

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para funciones de receta (Página 2860).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

RecipeImport: importar receta
Descripción
La instrucción "RecipeImport" importa los datos de receta de un archivo CSV de la memoria de
carga al bloque de datos del parámetro RECIPE_DB.
En las CPU S7-1500 el archivo CSV está en la Memory Card, en las CPU S7-1200 en la
memoria de carga interna o externa (en caso de que haya una Memory Card).
En este proceso se sobrescriben los valores existentes en el bloque de datos. En las CPU
S7-1500, el DB al que se van a importar los datos de receta puede estar presente tanto en la
memoria de trabajo como en la memoria de carga. Si está presente en ambas memorias, se
importan los datos al DB presente en la memoria de trabajo. En las CPU S7-1200, el DB al que
se van a importar los datos de receta debe estar en la memoria de carga.
La receta solo se conserva de forma permanente si se importa a un DB de la memoria de carga.
Si se importa a un DB de la memoria de trabajo pero se necesita de forma permanente,
después de la importación deberá transferirse a un DB de la memoria de carga mediante la
instrucción WRIT_DBL.

Programación del PLC
Manual de programación y manejo, 11/2019

2853

Instrucciones
4.1 Instrucciones
Para importar el archivo CSV, tenga en cuenta lo siguiente:
● El archivo CSV debe estar en el directorio "Recipes" de la memoria de carga.
● El nombre del archivo CSV debe ser idéntico al nombre del bloque de datos del parámetro
RECIPE_DB.
● Cada fila del archivo CSV corresponde a un registro de receta. La primera fila (encabezado)
del archivo CSV contiene los nombres de los componentes de la receta (véase
también: Estructura de un DB de receta (Página 2857)). La primera fila se ignora durante
la importación. Los nombres de los componentes de la receta del archivo CSV y del bloque
de datos no se comparan durante la importación, y también el número de entradas es
irrelevante.
● El primer valor de cada fila del archivo CSV es el índice de la receta. Las recetas
individuales se importan siguiendo el orden del índice. Por lo tanto, el índice del archivo
CSV debe ser ascendente y no contener espacios vacíos (de lo contrario se emitirá el aviso
de error 80B0 en el parámetro STATUS).
● El archivo CSV no debe contener más registros de receta de los previstos en el bloque de
datos. El número máximo de registros en el bloque de datos viene determinado por los
límites de la matriz.
● Si un valor del archivo CSV no concuerda con el respectivo tipo de datos del DB, la
importación se rechaza. De ser necesario, las cadenas de caracteres se cortan al alcanzar
su longitud máxima permitida.
Si el tipo de datos del DB es BOOL, una CPU S7-1500 acepta todos los valores enteros,
reproduciendo el valor 1 en TRUE y todos los demás valores en FALSE. Una CPU S7-1200
solo acepta los valores 0 y 1, todos los demás valores se rechazan.
● Si en el archivo CSV se han definido valores del tipo de datos DATE_AND_TIME y hay
valores de este tipo fuera del rango admisible, estos valores se ajustan al valor
predeterminado al importarlos al bloque de datos.
● Si el DB de receta es un DB con acceso estándar y está formado por más componentes de
los permitidos (p. ej. dos ARRAYs y una estructura), los datos de receta solo se importarán
al primer ARRAY y STATUS se pondrá a W#16#0000.

Funcionamiento
La importación se inicia a través del parámetro REQ. Durante la importación el parámetro
BUSY se pone a "1". Tras ejecutar la instrucción, BUSY se restablece a "0" y en el parámetro
DONE se indica con "1" que la instrucción ha finalizado.
Si se produce algún error durante la ejecución, se indicará mediante los parámetros ERROR
y STATUS.

2854

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RecipeImport":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L, T, C o
constante

Parámetro de control REQUEST: Activa la im‐
portación con un flanco ascendente

(T y C solo están dis‐
ponibles en S7-1500
en KOP y FUP)
RECIPE_DB

InOut

VARIANT

D

DONE

Output

BOOL

I, Q, M, D, L

Puntero hacia el bloque de datos de receta.
Consulte la estructura del bloque de datos
en: Estructura de un DB de receta (Pági‐
na 2857)
Parámetro de estado
● 0: La orden aún no se ha iniciado o todavía
se está ejecutando.
● 1: Orden finalizada sin errores.

BUSY

Output

BOOL

I, Q, M, D, L

Parámetro de estado
● 0: No se ejecuta la instrucción.
● 1: Se ejecuta la instrucción.

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado
● 0: Ni advertencia ni error.
● 1: Hay un error. STATUS devuelve
información detallada sobre el tipo de error.

STATUS

Output

WORD

I, Q, M, D, L

Parámetro de estado
Véase tabla "Parámetro STATUS".

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de
error*
(W#16#...)

Explicación

0

No ha ocurrido ningún error

7000

No se está procesando ninguna orden

7001

Inicio de la ejecución de la orden. Parámetro BUSY = 1, DONE = 0.

7002

Llamada intermedia (REQ irrelevante): la instrucción ya está activa; BUSY tiene el valor "1".

8090

El nombre de archivo contiene caracteres no válidos.

8091

La estructura de datos referenciada con RECIPE_DB no puede procesarse, p. ej. porque el bloque de datos
no existe.

8092

No se ha encontrado ningún archivo CSV concordante para la importación. Causa posible: el nombre del
archivo CSV no coincide con el nombre del DB de receta.

80C0

El archivo CSV está bloqueado temporalmente.

80C1

El bloque de datos de receta está bloqueado temporalmente.

Programación del PLC
Manual de programación y manejo, 11/2019

2855

Instrucciones
4.1 Instrucciones
Código de
error*
(W#16#...)

Explicación

80B0

La numeración del índice del archivo CSV no es homogénea, no es ascendente o supera el número máximo
(límite de la matriz) del bloque de datos.

80B1

La estructura del bloque de datos de receta y del archivo CSV no coinciden: el archivo CSV tiene demasiados
campos.

80B2

La estructura del bloque de datos de receta y del archivo CSV no coinciden: el archivo CSV no tiene sufi‐
cientes campos.
Nota: Las filas del archivo CSV se leen una tras otra. Si una de las filas del archivo CSV contiene más de lo
esperado por la CPU, se devuelve el código de error W#16#80B2, independientemente de cuántas celdas
se hayan detectado.

80B6

(Solo en las CPU S7-1200) El atributo "Depositar solo en la memoria de carga" del bloque de datos de receta
no está activado.

80C3

Recursos insuficientes

80D0 +n

La estructura del bloque de datos de receta y del archivo CSV no coinciden: el tipo de datos del campo n no
coincide (n <= 46).

80FF

La estructura del bloque de datos de receta y del archivo CSV no coinciden: el tipo de datos del campo n no
coincide (n > 46).

8624

RECIPE_DB apunta a un área no admisible, p. ej., a datos locales.

8630

El destino está protegido contra escritura, p. ej. un DB con protección contra escritura.

8652

La variable en RECIPE_DB es insuficiente. El bloque de datos no se ha escrito.

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para funciones de receta (Página 2860).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

2856

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Estructura de un DB de receta
Introducción
A continuación se describe la estructura de un DB de receta mediante un sencillo ejemplo. El
DB de receta se compone de cinco registros, de los cuales se utilizan tres. El cuarto y el quinto
registro se dejan libres para extensiones posteriores. Cada registro contiene una receta, que
a su vez se compone de un nombre de receta y ocho ingredientes.
product‐
name

water

barley

wheat

hops

yeast

wa‐
terTmp

mashT mashTi‐
mp
me

QTest

Pils

10

9

3

280

39

40

30

100

0

Lager

10

9

3

150

33

50

30

120

0

Black‐
Beer

10

9

3

410

47

60

30

90

1

Not_use
d

0

0

0

0

0

0

0

0

0

Not_use
d

0

0

0

0

0

0

0

0

0

Estructura del bloque de datos de receta
En un bloque de datos global, los datos de receta se disponen del siguiente modo:
● La plantilla para todas las recetas es el tipo de datos PLC "Beer_Recipe" con los
componentes de receta "procutname", "water", etc. con los correspondientes tipos de datos.
● En un bloque de datos global, el tipo de datos PLC se utiliza como Array [1.. 5] of
"Beer_Recipe". El número máximo de recetas que puede contener el DB lo determinan los
límites de la matriz (en este caso de 1 a 5).
● Los valores de los componentes de receta se añaden al bloque de datos como valores de
arranque.
● A través del parámetro InOut RECIPE_DB se interconecta el DB global con la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

2857

Instrucciones
4.1 Instrucciones

Exportar a archivo CSV
Tras ejecutar la instrucción "RecipeExport (Página 2851)", los datos del DB se escriben en un
archivo CSV con la siguiente estructura:
Recipe_DB.csv
index,productname,water,barley,wheat,hops,yeast,waterTmp,mashTmp,mashTime,QTest
1,”Pils”,10,9,3,280,39,40,30,100,0
2,”Lager”,10,9,3,150,33,50,30,120,0
3,”BlackBeer”,10,9,3,410,47,60,30,90,1
4,”Not_used”,0,0,0,0,0,0,0,0,0
5,”Not_used”,0,0,0,0,0,0,0,0,0

Representación en Excel
El archivo CSV se puede abrir para con Excel para visualizarlo de forma clara y editarlo. Si al
abrirlo no se reconocen las comas como carácter de separación, utilice la función de
importación de Excel para mostrar los datos de forma estructurada:

Edición del archivo CSV
El archivo CSV se carga y edita en el PC o la programadora a través del servidor web. Después
de la edición se puede volver a cargar en la CPU el archivo modificado, Para ello debe
eliminarse el archivo CSV ya existente.
La instrucción "RecipeImport (Página 2853)" permite volver a importar los datos modificados
del archivo CSV al bloque de datos.
Recuerde que para ello los datos modificados también tienen que ser compatibles con el
bloque de datos. Es decir:
● En la tabla no se deben realizar modificaciones en la estructura (por ejemplo, añadiendo
ingredientes en una nueva columna).
● Si añade registros adicionales al archivo, al importarlo al bloque de datos debe tener en
cuenta que los límites de la matriz que determinan el número máximo de registros deben
coincidir como mínimo con el número de registros.

2858

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● Durante la exportación al archivo CSV se genera automáticamente un índice. Si crea
registros adicionales, añádalos conforme al número de índice correlativo.
● Los valores de las celdas de la tabla deben corresponderse con los tipos de datos utilizados
en el bloque de datos, tanto en formato como en longitud.
– Ejemplo 1: Si en el bloque de datos se ha utilizado el tipo de datos INT, en la tabla solo
podrán utilizarse números enteros.
– Ejemplo 2: Si en el bloque de datos se ha utilizado el tipo de datos SINT, en la tabla solo
podrán utilizarse números enteros con los valores -128 a +127.
Si realiza cambios en la tabla, observe en general los tipos de datos y áreas de datos
permitidos, tal y como se relacionan en la tabla siguiente.
Tipo de datos

Formato

Nota

Números en LReal
coma flotante Real

+9.9999999999999E+999

Siempre en notación exponencial

+9.999999E+99

Siempre en notación exponencial

LInt

+9999999999999999999

Rango de valores para enteros con signo:
-9223372036854775808 .. +9223372036854775807

DInt

+9999999999

Rango de valores para enteros: -2147483648 a +2147483647

Int

+99999

Rango de valores para enteros: -32768 a +32767

SInt

+999

Rango de valores para enteros: -128 a +127

ULInt

+99999999999999999999

Rango de valores enteros: 0 a +18446744073709551615

UDInt

+9999999999

Rango de valores enteros: 0 a +4294967295

UInt

+99999

Rango de valores enteros: 0 a +65535

USInt

+999

Rango de valores enteros: 0 a +255

LWord

+99999999999999999999

Rango de valores enteros: 0 a +18446744073709551615

Enteros con
signo

Enteros sin
signo

Números bi‐
narios

DWord

+9999999999

Rango de valores enteros: 0 a +4294967295

Word

+99999

Rango de valores enteros: 0 a +65535

Byte

+999

Rango de valores enteros: 0 a +255

Bool

9

Rango de valores: 0 o 1

dddddd:hh:mm:ss.999_999_9
99

Formato ISO con milisegundos, microsegundos y nanosegun‐
dos

TIME

hhh:mm:ss.999

Formato ISO con milisegundos

S5TIME

hhh:mm:ss.999

Formato ISO con milisegundos

LDT

YYYY-MM-DD
hh:mm:ss.999_999_999

Formato ISO con milisegundos, microsegundos y nanosegun‐
dos

DTL

YYYY-MM-DD
hh:mm:ss.999_999_999

Formato ISO con milisegundos, microsegundos y nanosegun‐
dos

DT

YYYY-MM-DD hh:mm:ss.999

Formato ISO con milisegundos

DATE

YYYY-MM-DD

Formato ISO

LTi‐
me_Of_Da
y

hh:mm:ss.999_999_999

Formato ISO

TOD

hh:mm:ss.999

Formato ISO

Fecha y hora LTIME

Programación del PLC
Manual de programación y manejo, 11/2019

2859

Instrucciones
4.1 Instrucciones
Tipo de datos
Carácter

WString

Formato

Nota

"abcd"

● Cadena de caracteres entre comillas dobles. Al importar
un DB de receta pueden omitirse las comillas dobles.
● Longitud actual
● Una cadena de caracteres del tipo de datos WString está
compuesta de elementos del tipo de datos WChar. Al
exportar un DB de receta, el contenido de caracteres del
tipo de datos WChar se limita a 16#FF (p. ej.: 16#1255
cambia a 16#55).

String

"abcd"

WChar

"a"

Carácter individual entre comillas dobles. Al importar un DB de
receta pueden omitirse las comillas dobles. Al exportar un DB
de receta, el contenido de caracteres del tipo de datos WChar
se limita a 16#FF (p. ej.: 16#1255 cambia a 16#55).

Char

"a"

Carácter individual entre comillas dobles. Al importar un DB de
receta pueden omitirse las comillas dobles.

● Cadena de caracteres entre comillas dobles. Al importar
un DB de receta pueden omitirse las comillas dobles.
● Longitud actual

Ejemplo de programa para funciones de receta
En el ejemplo siguiente se exportan los datos de receta de un bloque de datos (DB de receta)
a un archivo CSV y se importan nuevos datos de receta al bloque de datos.

Requisitos
Cree un tipo de datos PLC "Beer_Recipe" para utilizarlo como plantilla para los datos de receta.

Para guardar todos los juegos de datos se crea un DB de receta. Encontrará más información
sobre cómo crear un DB de receta en "Estructura de un DB de receta (Página 2857)".

2860

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Para almacenar los datos de la interconexión se crean doce variables en un bloque de datos
global.

Para visualizar y guardar un archivo CSV se utiliza el servidor web de la CPU. Para poder usar
el servidor web y editar el archivo CSV, se requiere lo siguiente:
● El servidor web debe estar activado en la configuración de la CPU.
● Debe haberse creado un perfil de usuario en las propiedades de servidor web de la CPU
con los ajustes siguientes:
– El usuario debe poder leer archivos.
– El usuario debe poder escribir/borrar archivos.

Interconexión de los parámetros
Las instrucciones se llaman en un bloque de función.

Programación del PLC
Manual de programación y manejo, 11/2019

2861

Instrucciones
4.1 Instrucciones
Segmento 1: Los parámetros de la instrucción "RecipeExport" se interconectan del siguiente
modo.

Segmento 3: Los parámetros de la instrucción "RecipeImport" se interconectan del siguiente
modo.

Segmentos 2 y 4: puesto que los parámetros STATUS ("expSTATUS" y "impSTATUS") solo
son válidos durante un ciclo, léalos con una instrucción "MOVE". En los parámetros de salida
OUT1 ("outputErr_EXP" o "outputErr_IMP") se emite el estado en caso de error.
Los parámetros del segmento 2 se interconectan del siguiente modo.

2862

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Los parámetros del segmento 4 se interconectan del siguiente modo.

Instrucción "RecipeExport"
El DB de receta que se exportará debe interconectarse en el parámetro RECIPE_DB. Si el
parámetro REQ ("expREQ") devuelve el estado "TRUE", se inicia la exportación. A partir de los
datos del DB de receta se genera un archivo CSV que se deposita en la carpeta de recetas de
la memoria de la CPU. En el parámetro de salida STATUS ("expSTATUS") se indica que se ha
producido un cambio de señal. A continuación se indica que ya no se realizan más ejecuciones
(el valor es "7000").
En el parámetro de salida ERROR ("expERROR") se muestra que la instrucción se ha
ejecutado sin errores.

Programación del PLC
Manual de programación y manejo, 11/2019

2863

Instrucciones
4.1 Instrucciones

Instrucción "RecipeImport"
El DB de receta que se importará debe interconectarse en el parámetro RECIPE_DB. Si el
parámetro REQ ("impREQ") devuelve el estado "TRUE", se inicia la exportación. En el DB de
receta existente se cargan todos los datos de receta del archivo CSV correspondiente, que
está en la carpeta de recetas de la memoria de la CPU. En el parámetro de salida STATUS
("impSTATUS") se indica que se ha producido un cambio de señal. A continuación se indica
que ya no se realizan más ejecuciones (el valor es "7000").
En el parámetro de salida ERROR ("impERROR") se muestra que la instrucción se ha
ejecutado sin errores.

2864

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Visualización y almacenamiento del archivo CSV
Abrir el servidor web
En el navegador de Internet se abre el servidor web (con la dirección IP de la CPU) y se inicia
sesión en el menú del servidor web.
En la pestaña "Navegador de archivos" abra la carpeta "Recetas" en la memoria de la CPU.
La CPU muestra el archivo CSV en cuanto se ejecuta la instrucción "RecipeExport". Para
poder ver el estado actual del archivo CSV en todo momento, haga clic en el botón "Actualizar
automáticamente". A continuación se indica que la función está "activa".

Programación del PLC
Manual de programación y manejo, 11/2019

2865

Instrucciones
4.1 Instrucciones
Editar el archivo CSV
Para editar el archivo CSV existen las posibilidades siguientes:
● Abrir el archivo CSV en el servidor web.
● Guardar el archivo CSV en la programadora o el PC.
– Nota: para cargar el archivo CSV editado desde el PC a la memoria de la CPU borre
primero el archivo CSV con el mismo nombre en la memoria de la CPU.

– Tras editarlo, cargue el archivo CSV en la memoria de la CPU mediante el servidor web.

Cambiar los valores de los componentes en tiempo de ejecución
Para cambiar los valores de los componentes del DB de receta (p. ej. Recipe_DB.Product[4])
en tiempo de ejecución, utilice una tabla de observación.

Código del programa
Encontrará información adicional y el código del programa para el ejemplo anterior
aquí: Sample Library for Instructions (Página 615).

2866

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Data Logging
Data Logging - Übersicht
Guardar valores de proceso
Las instrucciones de Data Logging se utilizan en el programa de usuario para guardar valores
de proceso en Data Logs. Los Data Logs pueden guardarse en la Memory Card (MC) o en la
memoria de carga interna. Los Data Logs se guardan en formato CSV (Comma Separated
Values).
ATENCIÓN
Caracteres especiales en cadenas
Si dentro del Data Log se utilizan cadenas de caracteres, se desaconseja utilizar el separador
del archivo CSV dentro de las cadenas. En caso de ignorar esta recomendación, es posible
que se produzcan problemas al abrir el archivo CSV, p. ej. con MS Excel. Utilice un carácter
que no sea el separador del archivo CSV, p. ej. "-", "/" o el espacio " ".
El carácter que indica el final de una cadena, así como CR y LF, se consideran igualmente
caracteres especiales en una cadena. Las instrucciones no los procesan correctamente y
causan errores.
Los tipos de datos se convierten en una cadena de caracteres siguiendo las reglas que se
indican a continuación:
Tipo de datos

Formato

Nota

Números en LReal
coma flotante Real

+9.9999999999999E+999

Siempre en notación exponencial

Enteros con
signo

Enteros sin
signo

Números bi‐
narios

+9.9999999E+99

Siempre en notación exponencial

LInt

+9999999999999999999

Rango de valores para enteros con signo:
-9223372036854775808 .. +9223372036854775807

DInt

+9999999999

Rango de valores para enteros: -2147483648 a +2147483647

Int

+99999

Rango de valores para enteros: -32768 a +32767

SInt

+999

Rango de valores para enteros: -128 a +127

ULInt

+99999999999999999999

Rango de valores enteros: 0 a +18446744073709551615

UDInt

+9999999999

Rango de valores enteros: 0 a +4294967295

UInt

+99999

Rango de valores enteros: 0 a +65535

USInt

+999

Rango de valores enteros: 0 a +255

LWord

+99999999999999999999

Rango de valores enteros: 0 a +18446744073709551615

DWord

+9999999999

Rango de valores enteros: 0 a +4294967295

Word

+99999

Rango de valores enteros: 0 a +65535

Byte

+999

Rango de valores enteros: 0 a +255

Bool

9

Rango de valores: 0 o 1

Programación del PLC
Manual de programación y manejo, 11/2019

2867

Instrucciones
4.1 Instrucciones
Tipo de datos

Formato

Nota

Fecha y hora LTIME

dddddd:hh:mm:ss.999_999_9
99

Formato ISO con milisegundos, microsegundos y nanosegun‐
dos

TIME

hhh:mm:ss.999

Formato ISO con milisegundos

S5TIME

hhh:mm:ss.999

Formato ISO con milisegundos

LDT

YYYY-MM-DD
hh:mm:ss.999_999_999

Formato ISO con milisegundos, microsegundos y nanosegun‐
dos

DTL

YYYY-MM-DD
hh:mm:ss.999_999_999

Formato ISO con milisegundos, microsegundos y nanosegun‐
dos

DT

YYYY-MM-DD hh:mm:ss.999

Formato ISO con milisegundos

DATE

YYYY-MM-DD

Formato ISO

LTi‐
me_Of_Da
y

hh:mm:ss.999_999_999

Formato ISO

TOD

hh:mm:ss.999

Formato ISO

WString

"abcd"

● Cadena de caracteres entre comillas dobles

Carácter

● La longitud actual se rellena con espacios hasta la longitud
máxima.
● Una cadena de caracteres del tipo de datos WString está
compuesta de elementos del tipo de datos WChar. Al
guardar un Data Log, el contenido de los caracteres del
tipo de datos WChar se limita a 16#FF (p. ej.: 16#1255
cambia a 16#55).
String

"abcd"

● Cadena de caracteres entre comillas dobles
● La longitud actual se rellena con espacios hasta la longitud
máxima.

WChar

"a"

Carácter individual entre comillas dobles. Al guardar un Data
Log, el contenido de los caracteres del tipo de datos WChar se
limita a 16#FF (p. ej.: 16#1255 cambia a 16#55).

Char

"a"

Carácter individual entre comillas dobles

Las instrucciones de Data Logging se utilizan en el programa para crear o abrir un Data Log,
para escribir una entrada y para cerrar el archivo Data Log.
ADVERTENCIA
Tiempo de ejecución de las instrucciones Data Logging
Las condiciones indicadas a continuación ralentizan las instrucciones Data Logging. Este
efecto aumentará cuanto mayor sea el tamaño y el número de los archivos Data Log.
● Gran tamaño del archivo Data Log
● Elevado número de archivos Data Log en la Memory Card
● Acceso simultáneo a un archivo Data Log desde el servidor Web
El tiempo de ejecución de algunas instrucciones Data Logging no se suele ver afectado por
el tamaño y el número de los Data Logs (p. ej. "DataLogWrite"). Por el contrario, las
instrucciones "DataLogCreate", "DataLogNewFile", "DataLogClear" y "DataLogOpen" sí que
presentan el comportamiento arriba indicado.

2868

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Nota
Instrucciones Data Logging con las que se transfieren datos
Debido al procesamiento asíncrono de las instrucciones Data Logging, los datos del área de
origen deben mantenerse coherentes hasta que el parámetro DONE o el parámetro ERROR
se ponga a "1".
Se puede decidir qué valores de programa se guardarán en el Data Log al crear el búfer de
datos. El búfer de datos se utiliza como memoria para nuevas entradas Data Log. Los valores
nuevos se deben escribir en el búfer antes de la llamada de "DataLogWrite (Página 2887)".
Cuando se ejecuta la instrucción "DataLogWrite (Página 2887)" los datos del búfer se escriben
en un juego de datos Data Log.

&38
3/&
'$7$

'DWD$UFKLYHV
'HVFDUJD

FVY
6HUYLGRUZHE
0HPRU\
&DUG

:HEEURZVHU

,QVWUXFFLRQHV
'DWD/RJ

9DORUHVGH
SURFHVR

Los archivos Data Log se pueden copiar en el PC de la siguiente manera:
● Si la interfaz PROFINET está conectada con el PC, es necesario utilizar un navegador web
para acceder a los Data Logs a través del servidor web. La CPU puede estar en modo
"RUN" o "STOP". Si la CPU está funcionando en modo "RUN", el programa continúa
mientras el servidor web efectúa una transferencia de datos.
● Si en la CPU hay una Memory Card, esta puede retirarse e introducirse en una unidad
insertable estándar para tarjetas SD (Secure Digital) o tarjetas MMC (MultiMediaCard) de
un PC o una programadora. Utilice el administrador de archivos para transferir los archivos
Data Log de la Memory Card al PC. Si se extrae la Memory Card, la CPU pasa a "STOP".

Programación del PLC
Manual de programación y manejo, 11/2019

2869

Instrucciones
4.1 Instrucciones

Nota
Vida útil de las Memory Card
La vida útil de las Memory Cards es limitada. Encontrará más información aquí:
AUTOHOTSPOT

Propiedades de Data Log
Los juegos de datos de un Data Log se escriben según el principio de un búfer en anillo. Los
juegos de datos nuevos se van añadiendo hasta que se alcanza el número máximo de juegos
de datos (parámetro RECORD). El siguiente juego de datos sobrescribe entonces el juego de
datos "más antiguo" del Data Log.
Si quiere evitar que se sobrescriban juegos de datos, utilice la instrucción "DataLogNewFile
(Página 2893)" para crear un archivo Data Log basado en el Data Log actual. Los nuevos
juegos de datos se escriben entonces en el Data Log nuevo.

Crear Data Logs
La instrucción "DataLogCreate (Página 2872)" crea un archivo Data Log en el directorio
""\DataLogs" de la memoria de carga.
● El nombre asignado en el parámetro NAME es la designación del Data Log. Este nombre
también se utiliza como nombre de archivo para el archivo CSV. El archivo se guarda en el
directorio "DataLogs".
● El parámetro de bloque DATA determina el búfer de datos para el nuevo objeto Data Log
así como las columnas y tipos de datos del Data Log. Las columnas y los tipos de datos de
un juego de datos del Data Log se originan a través de elementos de la declaración de
estructura o de la declaración de array de este búfer de datos. Cada elemento de una
estructura o de un array se corresponde con una columna en una fila del Data Log.
● Con el parámetro de bloque HEADER se puede asignar un título en el encabezado a cada
columna.
● La instrucción "DataLogCreate (Página 2872)" devuelve una ID. Las demás instrucciones
de Data Logging utilizan esta ID como referencia para el Data Log creado.

Abrir Data Logs
Las instrucciones "DataLogOpen" (S7-1200 y S7-1500) abren un Data Log existente en la
Memory Card. Un Data Log tiene que estar abierto para escribir en él nuevos juegos de datos.
Durante la ejecución de las instrucciones "DataLogCreate (Página 2872)" y "DataLogNewFile
(Página 2893)", el Data Log se abre automáticamente.

2870

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Se pueden tener abiertos simultáneamente 10 Data Logs como máximo. El Data Log que se
va a abrir se puede seleccionar con la ID o con el nombre del Data Log.
● Si se indica tanto la ID como el nombre del Data Log en los parámetros ID y NAME, el Data
Log se identifica con la ID. No se compara el nombre del Data Log.
● Si se selecciona el Data Log con el parámetro NAME y se indica 0 como ID, la ID
perteneciente al Data Log se muestra en el parámetro ID al abrir el Data Log.
● Si se selecciona el Data Log con el parámetro ID y no se indica ningún nombre, el nombre
no se muestra en el parámetro NAME al abrir el Data Log.
Con el parámetro MODE se selecciona si los juego de datos del Data Log se deben borrar al
abrirlo.
Se puede realizar una comprobación de coherencia para "DataLogOpen" (S7-1500).

Escribir en el Data Log
Para escribir un juego de datos en un Data Log es imprescindible tener un Data Log abierto
(instrucción "DataLogOpen (Página 2881)"). La instrucción "DataLogWrite (Página 2887)"
escribe un juego de datos en el Data Log.
Nota
Modificar el contenido de los archivos Data Log
Dado que los archivos Data Log pueden ser enormes (500.000 kB), puede ocurrir que no sea
posible verificar el contenido de dichos archivos ni en la conexión ni antes de ejecutar
"DataLogWrite". No está permitido modificar el contenido fuera de la CPU puesto que podría
dañar un archivo.

Cerrar Data Logs
Con la instrucción "DataLogClose (Página 2889)", el usuario cierra un Data Log abierto. El
Data Log se selecciona mediante el parámetro ID.
El Data Log se cierra automáticamente cuando la CPU pasa a STOP o en caso de rearranque.

Borrar Data Logs
La instrucción "DataLogDelete (Página 2891)" (S7-1500) borra un archivo Data Log existente
en la Memory Card. El Data Log y los juego de datos que contiene solo pueden borrarse si el
Data Log se ha creado mediante la instrucción "DataLogCreate (Página 2872)".
Los parámetros NAME e ID permiten seleccionar el Data Log que debe borrarse. El parámetro
ID es el primero que se evalúa. Si existe un Data Log con la ID correspondiente, el parámetro

Programación del PLC
Manual de programación y manejo, 11/2019

2871

Instrucciones
4.1 Instrucciones
NAME no se evalúa. Si el parámetro ID tiene el valor "0", en el parámetro NAME debe utilizarse
un valor del tipo de datos STRING.
Nota
Borrado de Data Logs de la Memory Card
Los Data Logs de una Memory Card pueden copiarse utilizando un lector de tarjetas para PC,
pero dicho lector no puede utilizarse para modificar ni borrar los Data Logs.
Además de las instrucciones Data Log, se recomienda utilizar el servidor web para visualizar,
descargar (copiar) y borrar los Data Logs.
Si se llama directamente el sistema de archivos de la Memory Card en el explorador de
archivos, existe el riesgo de que se borren o modifiquen accidentalmente archivos Data Log u
otros archivos del sistema, de modo que posiblemente algún archivo quede dañado o la
Memory Card quede inutilizada. Los cambios en Data Logs de la Memory Card que se realizan
fuera del PLC provocan un incremento del tiempo de conexión del PLC.

Vaciar Data Logs
La instrucción "DataLogClear (Página 2885)" (S7-1500) borra todos los juegos de datos de un
Data Log existente. No se borra el encabezado opcional del archivo CSV (véase la descripción
del parámetro HEADER de la instrucción "DataLogCreate (Página 2872)").
Con el parámetro ID se selecciona el Data Log del que se van a borrar los juegos de datos.
Para borrar los juegos de datos, el Data Log tiene que estar abierto.

Archivo nuevo para Data Logs
Las instrucciones "DataLogNewFile (Página 2893)" (S7-1200) y "DataLogTypedNewFile
(Página 2895)" (S7-1500) crean un Data Log nuevo con las mismas propiedades que un Data
Log ya existente. De esta forma es posible obtener los contenidos de un Data Log existente.
Al ser llamada, la instrucción crea un Data Log en la Memory Card o en la memoria de carga
interna con el nombre definido en el parámetro NAME. Con el parámetro ID se indica la ID del
Data Log antiguo cuyas propiedades se quieren adoptar para el Data Log nuevo. Con el
parámetro ID se indica a continuación la ID del Data Log nuevo.
El tamaño de archivo del Data Log nuevo se indica con el parámetro RECORDS de la
instrucción.
Se puede realizar una comprobación de coherencia para "DataLogTypedNewFile
(Página 2895)" (S7-1500).

DataLogCreate: Crear Data Log
Descripción
Con la instrucción "DataLogCreate", el usuario crea un Data Log.
El Data Log se guarda en la Memory Card o en la memoria de carga interna en el directorio
"\DataLogs". La cantidad de datos que se guarda en un Data Log depende de la memoria

2872

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
disponible en la Memory Card o en la memoria de carga interna de la CPU utilizada. El tamaño
máximo del archivo CSV generado es de 500.000.000 bytes para las CPU S7-1200 y de
1.000.000.000 bytes para las CPU S7-1500.
El número máximo de registros que se guardan en un Data Log se indica en el parámetro
RECORDS. Una vez que se alcanza el número máximo de registros en el Data Log, se va
sobrescribiendo el registro más antiguo. Para evitar que se sobrescriban los registros
existentes, se puede utilizar la instrucción "DataLogNewFile (Página 2893)". Al alcanzar el
número indicado en el parámetro RECORDS (valor de retorno 1 del parámetro STATUS de la
instrucción "DataLogWrite (Página 2887)") se utiliza la instrucción para crear un nuevo Data
Log con la misma estructura. Los registros se guardan entonces en el nuevo Data Log.
El nombre del Data Log se asigna en el parámetro NAME. El Data Log se crea en formato CSV
(Comma Separated Values). Con el parámetro HEADER se puede crear un encabezado
(opcional) para el Data Log.
Tras la creación, el Data Log se abre automáticamente. Esto significa que se pueden escribir
datos.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DataLogCreate":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, L, D, T, C o
constante

Ejecución de la instrucción

I, Q, M, L, D o cons‐
tante

Número máximo de registros en el Data Log

El Data Log se crea cuando se detecta un flanco
(T y C solo están dis‐ ascendente en el parámetro REQ.
ponibles en S7-1500
en KOP y FUP)

RECORDS

FORMAT

Input

Input

UDInt

UInt

I, Q, M, L, D o cons‐
tante

Si con la instrucción "DataLogWrite (Página 2887)"
se escriben más regiistros que los especificados en
este parámetro, el registro más antiguo se sobres‐
cribe.
Formato de datos:
● 0: Interno (no soportado)
● 1: CSV (Comma separated values)

TIMESTAMP

Input

UInt

Programación del PLC
Manual de programación y manejo, 11/2019

I, Q, M, L, D o cons‐
tante

Sellado de tiempo; consulte los detalles más abajo
Si el sello horario está activado, se agregan auto‐
máticamente columnas adicionales en el encabe‐
zado.

2873

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

NAME

Input

VARIANT

L, D

Nombre del Data Log
El nombre asignado también se utiliza como nom‐
bre de archivo del archivo CSV.
En las CPU S7-1200 rigen las siguientes restriccio‐
nes para el nombre del Data Log:
● El nombre no debe tener más de 35 caracteres.
● Se permiten todos los caracteres ASCII entre
0x20 y 0x7E con la excepción de \ ' / " : ; [ ] | = .
*?<>
En las CPU S7-1500 rigen las siguientes restriccio‐
nes para el nombre del Data Log:
● El nombre no debe tener más de 55 caracteres.
● Se admiten los siguientes caracteres: 0 ... 9, a ...
z, A ... Z así como - y _

ID

InOut

DWORD

I, Q, M, L, D

ID de objeto del Data Log (solo Output)
El ID del Data Log se necesita para otras instruc‐
ciones de Data Logging a fin de direccionar el Data
Log creado.

HEADER

InOut

VARIANT

D

Encabezado del Data Log (opcional)
El parámetro se oculta después de insertar la ins‐
trucción.
El encabezado se escribe en la primera fila del ar‐
chivo CSV.

DATA

InOut

VARIANT

D

Puntero a la estructura de datos que debe escribir‐
se como registro al ejecutar la instrucción "Data‐
LogWrite (Página 2887)".

DONE

Output

BOOL

I, Q, M, L, D

Parámetro de estado:
● 0: Ejecución de la instrucción no finalizada
todavía.
● 1: Ejecución de la instrucción finalizada
correctamente.

BUSY

Output

BOOL

I, Q, M, L, D

Parámetro de estado:
● 0: la ejecución de la instrucción aún no ha
comenzado, no ha finalizado o se ha
interrumpido.
● 1: La instrucción se está ejecutando.

2874

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ERROR

Output

BOOL

I, Q, M, L, D

Parámetro de estado:
● 0: Ningún error.
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro STATUS contiene información más
detallada.

STATUS

Output

WORD

I, Q, M, L, D

Información de estado detallada:
En el parámetro STATUS se visualiza información
de estado y error detallada. El parámetro solo está
activado durante una llamada. Por ello, para visua‐
lizar el estado debe copiarse el parámetro STATUS
en un área de datos libre.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro HEADER
El parámetro HEADER es un puntero VARIANT a un bloque de datos que define un
encabezado para el archivo CSV (Header). El encabezado siempre es la primera fila en la
representación de un archivo CSV.
● El encabezado indicado por HEADER se transfiere al archivo CSV. En este proceso no se
comprueba si es coherente con el Data Log restante. En concreto, no se comprueba si el
número de columnas separadas por coma coincide con el número de columnas de datos.
● Como tipo de datos se puede utilizar para la designación de las columnas un STRING,
Array of BYTE o Array of CHAR. Si se utiliza STRING la longitud está limitada a 254 bytes.
Si se utilizan Array of BYTE y Array of CHAR se admiten 5000 elementos.
Si en el parámetro HEADER no se indica ningún valor o si HEADER está en la memoria de
carga, no se creará ningún encabezado.
Con los valores 1, 3 y 5 de TIMESTAMP se inserta el texto siguiente al principio del
encabezado: "Record, Date, UTC Time,".
Con los valores 2 y 4 de TIMESTAMP se inserta el texto siguiente al principio del encabezado:
"Record, Date, Loc Time,".

Parámetro TIMESTAMP
La tabla siguiente muestra todos los valores posibles de TIMESTAMP.

Programación del PLC
Manual de programación y manejo, 11/2019

2875

Instrucciones
4.1 Instrucciones

Valor

Formato de DATE_AND_TI‐
ME

Origen de la hora

Observación

0

-

sin sello de tiempo

obligatorio

1

● S7 1200: mm/dd/aaaa,
hh:mm:ss

hora del sistema

obligatorio

hora local

opcional

hora del sistema

opcional

hora local

opcional

hora del sistema

opcional

● S7 1500: aaaa-mm-dd,
hh:mm:ss.999
2

● CPU S7-1200: mm/dd/
aaaa, hh:mm:ss
● CPU S7-1500 a partir de
la versión de firmware
V2.6:
mm/dd/aaaa,
hh:mm:ss[.999]
(formato de 24 horas,
[milisegundos
opcionales])

3

CPU S7-1500 a partir de la
versión de firmware V2.6:
mm/dd/aaaa, hh:mm:ss[.999]
(formato de 24 horas, [milise‐
gundos opcionales])

4

CPU S7-1500 a partir de la
versión de firmware V2.6:
aaaa-mm-dd, hh:mm:ss.[999]
(formato de 24 horas, [milise‐
gundos opcionales])

5

CPU S7-1500 a partir de la
versión de firmware V2.6:
aaaa-mm-dd, hh:mm:ss.[999]
(formato de 24 horas, [milise‐
gundos opcionales])

Parámetro DATA
El parámetro DATA es un puntero VARIANT a un tipo de datos simple, una estructura o un
array de un bloque de datos. Un elemento de una estructura o matriz se corresponde con una
columna en el Data Log con un tipo de datos determinado.
Tenga en cuenta lo siguiente en la creación del bloque de datos:
● Por lo general, el número de columnas debe corresponderse con el número de columnas
definido en el parámetro HEADER. Sin embargo, no está especificado.
● Cada elemento de la estructura o del array tiene asignada una entrada en la columna del
archivo CSV. Por tanto, si se utiliza el tipo de datos STRUCT no se pueden utilizar
anidamientos de estructura (STRUCT en STRUCT). No obstante, sí se permite el uso de
arrays dentro de un tipo de datos STRUCT, con la excepción siguiente: no se permiten
arrays cuyos elementos sean del tipo de datos "Tipo de datos PLC (UDT)".

2876

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● La estructura puede contener hasta 256 elementos. Si contiene más de 256 elementos, se
emite el código de error 8C52 en el parámetro STATUS.
● Las variables del bloque de datos pueden ajustarse como remanentes o no remanentes.
Sin embargo, el ajuste de remanencia tiene que ser igual para todas las variables del
bloque de datos.

Parámetro STATUS (S7-1200)
Código de error* Descripción
(W#16#...)
0

Ningún error.

7000

No se está procesando ninguna orden.

7001

Inicio de la ejecución de la orden. Parámetro BUSY = 1, DONE = 0.

7002

Llamada intermedia (REQ irrelevante): la instrucción ya está activa; BUSY tiene el valor "1".

8070

El número máximo de instrucciones DataLogCreate activas simultáneamente ya se ha alcanzado en este
momento.

8090

Nombre de archivo no admisible (véase la descripción del parámetro NAME).

8093

El Data Log ya existe.

8097

La longitud del archivo sobrepasa el límite del sistema de archivos o el límite específico de la CPU.

80A2

Error de escritura devuelto por el sistema,

80B2

Se ha excedido el número máximo de DataLogs

80B3

No hay espacio de memoria suficiente en la Memory Card.

80B4

La Memory Card tiene activada la protección contra escritura.

80C0

Acceso no disponible actualmente.

80C1

Demasiados Data Logs abiertos.

8253

Valor no válido en el parámetro RECORDS.

8353

Selección de formato no válida

8453

Sello horario no válido

8B24

Asignación no válida en el parámetro HEADER (por ejemplo: señala la memoria local).

8B51

Tipo de datos no admisible en el parámetro HEADER o la longitud excede el tamaño máximo.

8C24

Asignación no válida en el parámetro DATA (por ejemplo: señala la memoria local).

8C51

Tipo de datos no autorizado en el parámetro DATA / La estructura de datos no puede utilizarse.

8C52

La estructura del parámetro DATA contiene más de 256 elementos.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Parámetro STATUS (S7-1500)
Código de error* Descripción
(W#16#...)
0

Ningún error.

7000

No se está procesando ninguna orden.

7001

Inicio de la ejecución de la orden. Parámetro BUSY = 1, DONE = 0.

Programación del PLC
Manual de programación y manejo, 11/2019

2877

Instrucciones
4.1 Instrucciones
Código de error* Descripción
(W#16#...)
8070

El número máximo de instrucciones DataLogCreate activas simultáneamente ya se ha alcanzado en este
momento.

8090

Nombre de archivo no admisible (véase la descripción del parámetro NAME).

8091

El parámetro "NAME" no es un string.

8093

El Data Log ya existe.

8097

La longitud del archivo sobrepasa el límite del sistema de archivos o el límite específico de la CPU.

80A2

Error de escritura devuelto por el sistema,

80B2

Se ha excedido el número máximo de DataLogs

80B3

No hay espacio de memoria suficiente en la Memory Card.

80B4

La Memory Card tiene activada la protección contra escritura.

80C0

Acceso no disponible actualmente.

80C1

Demasiados Data Logs abiertos.

8253

Valor no válido en el parámetro RECORDS.

8353

Selección de formato no válida.

8453

Sello horario no válido.

8B24

Asignación no válida en el parámetro HEADER (por ejemplo: señala la memoria local).

8B51

Tipo de datos no admisible en el parámetro HEADER o la longitud excede el tamaño máximo.

8C24

Asignación no válida en el parámetro DATA (por ejemplo: señala la memoria local).

8C51

Tipo de datos no autorizado en el parámetro DATA / La estructura de datos no puede utilizarse.

8C52

La estructura del parámetro DATA contiene más de 256 elementos.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo de DataLogCreate
En el ejemplo siguiente se crea un Data Log sencillo con un sello horario y tres valores de
proceso.
Variables del bloque de datos global
Los valores para los parámetros de entrada del Data Log están guardados en el bloque de
datos global "DataLogDB":
● DataLogName (String): la variable contiene el nombre del Data Log que también se usa
como nombre del archivo CSV.
● DataLogID (DInt): en esta variable se escribe el ID del Data Log cuando se llama la
instrucción.
– La instrucción asigna automáticamente el ID.
– La variable "DataLogID" se utiliza en otras instrucciones de DataLog para direccionar el
Data Log correspondiente.

2878

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● MyHeader (String): la variable contiene el encabezado del DataLog, es decir, los títulos de
columna para los valores de proceso.
● MyData (Struct): la variable contiene los tres valores de proceso que se escriben en el Data
Log. Cada vez que se escribe un registro (instrucción "DataLogWrite (Página 2887)"), los
valores actuales se escriben en un nuevo registro.

Llamada de la instrucción "DataLogCreate"
La instrucción se llama con los siguientes parámetros de entrada:
● REQ (BOOL): Si REQ = "TRUE" se crea el Data Log.
● RECORD (3): en el Data Log se pueden escribir como máximo tres registros. A
continuación se sobrescribe el registro más antiguo.
● FORMAT (1): el Data Log se crea como archivo CSV.
● TIMESTAMP (1): activado. Para el Data Log se crean automáticamente dos columnas
adicionales (fecha y hora). El sello horario actual se escribe en el registro cada vez que se
ejecuta "DataLogWrite (Página 2887)".
● NAME (VARIANT): puntero hacia la variable "DataLogName" en el bloque de datos
"DataLogDB".
● ID (DWORD): puntero hacia la variable "DataLogID" en el bloque de datos "DataLogDB"
(solo Output).
● HEADER (VARIANT): puntero hacia la variable "MyHeader" en el bloque de datos
"DataLogDB".
● DATA (VARIANT): puntero hacia la variable "MyData" en el bloque de datos "DataLogDB".

Programación del PLC
Manual de programación y manejo, 11/2019

2879

Instrucciones
4.1 Instrucciones

Lectura del Data Log a través del servidor web
A través del servidor web se lee el Data Log creado:
● Active el servidor web en las propiedades de la CPU. Para leer el Data Log debe estar
activada la autorización "Leer archivos..." para el servidor web.
● A través del navegador de Internet se puede acceder al servidor web, introduzca para ello
la dirección IP de la CPU como URL.
● En "Filebrowser" se ha creado automáticamente el directorio "\DataLogs" que contiene el
Data Log. Como alternativa también puede consultar el menú bajo "DataLogs".
● Si la instrucción "DataLogWrite (Página 2887)" aún no se ha ejecutado, el DataLog solo
contiene la entrada "//END". Tras ejecutar por primera vez "DataLogWrite (Página 2887)"
se escribe el primer registro.

Ejemplo para DataLogCreate y otras instrucciones
Encontrará el ejemplo aquí: Programa de ejemplo para trabajar con Data Logs (Página 2897).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

2880

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Data Logging - Übersicht (Página 2867)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

DataLogOpen: Abrir Data Log
DataLogOpen: Abrir Data Log
Descripción
La instrucción "DataLogOpen" abre un Data Log existente en la Memory Card. Un Data Log
tiene que estar abierto para escribir en él nuevos juegos de datos.
Durante la ejecución de las instrucciones "DataLogCreate (Página 2872)" y "DataLogNewFile
(Página 2893)", el Data Log se abre automáticamente.
Se pueden tener abiertos simultáneamente 10 Data Logs como máximo. El Data Log que se
va a abrir se puede seleccionar con el ID o con el nombre del Data Log.
● Si se indica tanto el ID como el nombre del Data Log en los parámetros ID y NAME, el Data
Log se identifica con el ID. No se compara el nombre del Data Log.
● Si se selecciona el Data Log con el parámetro NAME y se indica 0 como ID, el ID
perteneciente al Data Log se muestra en el parámetro ID al abrir el Data Log.
● Si se selecciona el Data Log con el parámetro ID y no se indica ningún nombre, el nombre
no se muestra en el parámetro NAME al abrir el Data Log.
Con el parámetro MODE se selecciona si los juegos de datos del Data Log se deben borrar al
abrirlo.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DataLogOpen":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐ Ejecución de la instrucción con flanco ascendente.
tante

MODE

Input

UInt

I, Q, M, L, D o cons‐ Modo para abrir el Data Log:
tante
● MODE= "0"
Los juegos de datos del Data Log se mantienen
● MODE= "1"
Los juegos de datos del Data Log se borran, el
encabezado se mantiene

NAME

Input

VARIANT

L, D

Nombre (de archivo) del Data Log.

ID

InOut

DWORD

I, Q, M, L, D

ID de objeto del Data Log.

Programación del PLC
Manual de programación y manejo, 11/2019

2881

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

DONE

Output

BOOL

I, Q, M, L, D

La instrucción se ha ejecutado correctamente.

BUSY

Output

BOOL

I, Q, M, L, D

Ejecución de la instrucción no finalizada.

ERROR

Output

BOOL

I, Q, M, L, D

● 0: Ningún error.
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro STATUS contiene información más
detallada.

STATUS

Output

WORD

I, Q, M, L, D

Parámetro de estado
El parámetro solo está activado durante una llama‐
da. Por ello, para visualizar el estado debe copiarse
el parámetro STATUS en un área de datos libre.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de error*
(W#16#...)

Descripción

0

Ningún error.

2

Advertencia: el archivo Data Log ya fue abierto por esta aplicación.

7000

No se está procesando ninguna orden.

7001

Inicio de la ejecución de la orden. Parámetro BUSY = 1, DONE = 0.

7002

Llamada intermedia (REQ irrelevante): la instrucción ya está activa; BUSY tiene el valor "1".

8070

El número máximo de instrucciones DataLogOpen activas simultáneamente ya se ha alcanzado en este
momento.

8090

Hay incoherencias entre la definición Data Log y los datos Data Log existentes.

8091

En el parámetro NAME se ha utilizado un tipo de datos diferente a String.

8092

El Data Log no existe.

80B4

La Memory Card o el archivo Data Log está protegido contra escritura.

80C0

Acceso no disponible actualmente. Este puede ser el caso, p. ej., cuando se carga en RUN.

80C1

Demasiados archivos abiertos.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Programa de ejemplo para trabajar con Data Logs (Página 2897).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

2882

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Data Logging - Übersicht (Página 2867)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

DataLogOpen: Abrir Data Log
Descripción
La instrucción "DataLogOpen" abre un Data Log existente en la Memory Card. Un Data Log
tiene que estar abierto para poder escribir nuevos juegos de datos en él.
Durante la ejecución de las instrucciones "DataLogCreate (Página 2872)" y "DataLogNewFile
(Página 2893)", el Data Log se abre automáticamente.
Se pueden tener abiertos simultáneamente 10 Data Logs como máximo. El Data Log que se
va a abrir se puede seleccionar con el ID o con el nombre del Data Log.
● Si se indica tanto el ID como el nombre del Data Log en los parámetros ID y NAME, el Data
Log se identifica con el ID. No se compara el nombre del Data Log.
● Si se selecciona el Data Log con el parámetro NAME y se indica 0 como ID, el ID
perteneciente al Data Log se muestra en el parámetro ID al abrir el Data Log.
● Si se selecciona el Data Log con el parámetro ID y no se indica ningún nombre, el nombre
no se muestra en el parámetro NAME al abrir el Data Log.
Con el parámetro MODE se selecciona si los juegos de datos del Data Log se deben borrar al
abrirlo.
El parámetro DATA permite comprobar la coherencia entre el Data Log que se va a abrir y la
definición del Data Log de la instrucción "DataLogCreate (Página 2872)". Se comprueba si el
tipo de datos del parámetro DATA es idéntico al tipo de datos en "DataLogCreate". De no ser
así, el parámetro STATUS emite el código de error W#16#8090.
Nota
Cargar una estructura de datos modificada con Datalog (registro de datos) abierto
Si hay un Datalog abierto y se carga una estructura de datos que forma parte de dicho Datalog,
el Datalog queda dañado.

Programación del PLC
Manual de programación y manejo, 11/2019

2883

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DataLogOpen":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, L, D, T, C o
constante

Ejecución de la instrucción con flanco ascendente.

(T y C solo están dis‐
ponibles en
S7-1500 en KOP y
FUP)
MODE

Input

UInt

I, Q, M, L, D o cons‐ Modo para abrir el Data Log:
tante
● MODE= "0"
Los juegos de datos del Data Log se mantienen
● MODE= "1"
Los juegos de datos del Data Log se borran, el
encabezado se mantiene

NAME

Input

VARIANT

L, D

Nombre (de archivo) del Data Log.

ID

InOut

DWORD

I, Q, M, L, D

ID de objeto del Data Log.

DATA

InOut

VARIANT

D

Durante la prueba de coherencia: Puntero hacia el
área de datos del parámetro DATA de la instruc‐
ción "DataLogCreate (Página 2872)".

DONE

Output

BOOL

I, Q, M, L, D

La instrucción se ha ejecutado correctamente.

BUSY

Output

BOOL

I, Q, M, L, D

Ejecución de la instrucción no finalizada.

ERROR

Output

BOOL

I, Q, M, L, D

● 0: Ningún error.
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro STATUS contiene información más
detallada.

STATUS

Output

WORD

I, Q, M, L, D

Parámetro de estado
El parámetro solo está activado durante una llama‐
da. Por ello, para visualizar el estado debe copiarse
el parámetro STATUS en un área de datos libre.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de error*
(W#16#...)

Descripción

0

Ningún error.

2

Advertencia: el archivo Data Log ya fue abierto por esta aplicación.

7000

No se está procesando ninguna orden.

7001

Inicio de la ejecución de la orden. Parámetro BUSY = 1, DONE = 0.

7002

Llamada intermedia (REQ irrelevante): la instrucción ya está activa; BUSY tiene el valor "1".

8070

El número máximo de instrucciones DataLogOpen activas simultáneamente ya se ha alcanzado en este
momento.

2884

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error*
(W#16#...)

Descripción

8090

Tipos de datos incoherentes. El Data Log del parámetro ID utiliza otros tipos de datos que los indicados
en el parámetro DATA.

8091

En el parámetro NAME se ha utilizado un tipo de datos diferente a String.

8092

El Data Log no existe.

80B4

La Memory Card o el archivo Data Log está protegido contra escritura.

80C0

Acceso no disponible actualmente. Este puede ser el caso, p. ej., cuando se carga en RUN.

80C1

Demasiados archivos abiertos.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Programa de ejemplo para trabajar con Data Logs (Página 2897).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Data Logging - Übersicht (Página 2867)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

DataLogClear: Vaciar Data Log
Descripción
La instrucción "DataLogClear" borra todos los registros de un Data Log existente. No se borra
el encabezado opcional del archivo CSV (véase la descripción del parámetro HEADER de la
instrucción "DataLogCreate (Página 2872)").
Con la ID de parámetro se selecciona el Data Log del que se van a borrar los registros.

Requisitos
Para borrar los registros, el Data Log tiene que estar abierto (véase la instrucción
"DataLogOpen (Página 2881)").

Programación del PLC
Manual de programación y manejo, 11/2019

2885

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DataLogClear":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, L, D, T, C o
constante

Ejecución de la instrucción con flanco ascen‐
dente.

(T y C solo están dis‐
ponibles en S7-1500
en KOP y FUP)
ID

InOut

DWORD

I, Q, M, D, L

ID de objeto del Data Log

DONE

Output

BOOL

I, Q, M, D, L

La instrucción se ha ejecutado correctamente.

BUSY

Output

BOOL

I, Q, M, D, L

Ejecución de la instrucción no finalizada.

ERROR

Output

BOOL

I, Q, M, D, L

● 0: Ningún error.
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro STATUS contiene información
más detallada.

STATUS

Output

WORD

I, Q, M, D, L

Parámetro de estado
El parámetro solo está activado durante una
llamada. Por ello, para visualizar el estado de‐
be copiarse el parámetro STATUS en un área
de datos libre.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de
error*
(W#16#...)

Explicación

0000

Ningún error.

7000

No se está procesando ninguna petición.

7001

Inicio de la ejecución de la petición. Parámetro BUSY = 1, DONE = 0.

7002

Llamada intermedia (REQ irrelevante): la instrucción ya está activa; BUSY tiene el valor "1".

8070

El número máximo de instrucciones DataLogClear activas simultáneamente ya se ha alcanzado en este
momento.

8080

El archivo Data Log seleccionado a través del parámetro ID no será procesado por la instrucción "DataLog‐
Clear".

8092

El Data Log no existe.

80A2

Error de escritura devuelto por el sistema de archivos.

80B0

El Data Log no está abierto.

80B4

La Memory Card tiene activada la protección contra escritura.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

2886

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Data Logging - Übersicht (Página 2867)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

DataLogWrite: Escribir Data Log
Descripción
Con la instrucción "DataLogWrite", el usuario crea un registro en un Data Log existente. Por
medio del parámetro ID se selecciona el Data Log en el que debe escribirse el registro. Para
crear un nuevo registro, el Data Log tiene que estar abierto. La instrucción crea un nuevo
registro con el formato que se había indicado en el parámetro DATA al crear el Data Log.
Antes de la llamada de la instrucción "DataLogWrite" transfiera los datos a la variable que se
conecta al parámetro DATA de la instrucción "DataLogCreate". Durante la ejecución de la
instrucción "DataLogWrite" los datos transferidos se copian en el Data Log.
ATENCIÓN
Pérdida de datos del Data Log por interrupción de la alimentación de la CPU
Si se interrumpe la alimentación mientras se está ejecutando la instrucción "DataLogWrite",
se pierde el registro que se va a transferir.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DataLogWrite":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, L, D, T, C o
constante

Ejecución de la instrucción con flanco ascendente.

(T y C solo están dis‐
ponibles en
S7-1500 en KOP y
FUP)
ID

InOut

DWORD

I, Q, M, L, D

ID de objeto del Data Log

DONE

Output

BOOL

I, Q, M, L, D

La instrucción se ha ejecutado correctamente.

BUSY

Output

BOOL

I, Q, M, L, D

Ejecución de la instrucción no finalizada.

Programación del PLC
Manual de programación y manejo, 11/2019

2887

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

ERROR

Output

BOOL

I, Q, M, L, D

● 0: Ningún error.
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro STATUS contiene información más
detallada.

STATUS

Output

WORD

I, Q, M, L, D

Parámetro de estado
El parámetro solo está activado durante una llama‐
da. Por ello, para visualizar el estado debe copiarse
el parámetro STATUS en un área de datos libre.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS (S7-1200)
Código de error* Descripción
(W#16#...)
0

Ningún error

0001

Último juego de datos posible creado al final del archivo. Cuando se crea un registro nuevo, se sobrescribe
otro más antiguo.

7000

No se está procesando ninguna orden.

7001

Inicio de la ejecución de la orden. Parámetro BUSY = 1, DONE = 0

7002

Llamada intermedia (REQ irrelevante): la instrucción ya está activa; BUSY tiene el valor "1".

8070

El número máximo de instrucciones DataLogWrite activas simultáneamente ya se ha alcanzado en este
momento.

8090

La definición del Data Log no coincide con el Data Log existente.

8092

El Data Log no existe.

8093

Se ha modificado la dirección de origen del DataLog (p. ej. por una carga).

80A2

Error de escritura devuelto por el sistema de archivos.

80B0

El Data Log no está abierto.

80B3

No hay espacio de memoria suficiente en la Memory Card.

80B4

La Memory Card tiene activada la protección contra escritura.

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Parámetro STATUS (S7-1500)
Código de error* Descripción
(W#16#...)
0

Ningún error

0001

Último juego de datos posible creado al final del archivo. Cuando se crea un registro nuevo, se sobrescribe
otro más antiguo.

7000

No se está procesando ninguna orden.

7001

Inicio de la ejecución de la orden. Parámetro BUSY = 1, DONE = 0

2888

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error* Descripción
(W#16#...)
8070

El número máximo de instrucciones DataLogWrite activas simultáneamente ya se ha alcanzado en este
momento.

8090

La definición del Data Log no coincide con el Data Log existente.

8092

El Data Log no existe.

8093

Se ha modificado la dirección de origen del DataLog (p. ej. por una carga).

80A2

Error de escritura devuelto por el sistema de archivos.

80B0

El Data Log no está abierto.

80B3

No hay espacio de memoria suficiente en la Memory Card.

80B4

La Memory Card tiene activada la protección contra escritura.

* Los códigos de error se representan como valores enteros o hexadecimales en el editor de programas. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Programa de ejemplo para trabajar con Data Logs (Página 2897).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Data Logging - Übersicht (Página 2867)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

DataLogClose: Cerrar Data Log
Descripción
Con la instrucción "DataLogClose", el usuario cierra un Data Log abierto. El Data Log se
selecciona mediante el parámetro ID.
Nota
Cierre automático de Data Logs
El Data Log se cierra automáticamente cuando la CPU pasa a STOP o en caso de rearranque.

Programación del PLC
Manual de programación y manejo, 11/2019

2889

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DataLogClose":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, L, D, T, C o
constante

Ejecutar función con flanco ascendente.

(T y C solo están dis‐
ponibles en S7-1500
en KOP y FUP)
ID

InOut

DWORD

I, Q, M, L, D

ID de objeto del Data Log

DONE

Output

BOOL

I, Q, M, L, D

La instrucción se ha ejecutado correctamente.

BUSY

Output

BOOL

I, Q, M, L, D

Ejecución de la instrucción no finalizada.

ERROR

Output

BOOL

I, Q, M, L, D

● 0: Ningún error.
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro STATUS contiene información más
detallada.

STATUS

Output

WORD

I, Q, M, L, D

Parámetro de estado
El parámetro solo está activado durante una lla‐
mada. Por ello, para visualizar el estado debe
copiarse el parámetro STATUS en un área de
datos libre.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS (S7-1200)
Código de error* Descripción
(W#16#...)
0

Ningún error

1

El Data Log no está abierto

7000

No se está procesando ninguna petición.

7001

Inicio de la ejecución de la petición. Parámetro BUSY = 1, DONE = 0

7002

Llamada intermedia (REQ irrelevante): la instrucción ya está activa; BUSY tiene el valor "1".

8070

El número máximo de instrucciones DataLogClose activas simultáneamente ya se ha alcanzado en este
momento.

8092

El Data Log no existe.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

2890

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro STATUS (S7-1500)
Código de error* Descripción
(W#16#...)
0

Ningún error

1

El Data Log no está abierto

7000

No se está procesando ninguna petición.

7001

Inicio de la ejecución de la petición. Parámetro BUSY = 1, DONE = 0

8070

El número máximo de instrucciones DataLogClose activas simultáneamente ya se ha alcanzado en este
momento.

8092

El Data Log no existe.

80B4

La Memory Card tiene activada la protección contra escritura.

80C0

Acceso no disponible actualmente.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Programa de ejemplo para trabajar con Data Logs (Página 2897).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Consulte también
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

DataLogDelete: Borrar Data Log
Descripción
La instrucción "DataLogDelete" borra un archivo Data Log existente en la Memory Card. El
Data Log y los registros que contiene se borran si el Data Log ha sido creado con las
instrucciones "DataLogCreate" o "DataLogNewFile".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DataLogDelete":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, L, D, T, C o
constante

Ejecución de la instrucción con flanco ascen‐
dente.

(T y C solo están dis‐
ponibles en S7-1500
en KOP y FUP)
NAME

Input

VARIANT

Programación del PLC
Manual de programación y manejo, 11/2019

L, D

Nombre del archivo Data Log

2891

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

DELFILE

Input

BOOL

I, Q, M, D, L o cons‐
tante

● 0: El Data Log se conserva.

I, Q, M, D, L

ID de objeto del Data Log

ID

InOut

DWORD

● 1: El Data Log se borra.

DONE

Output

BOOL

I, Q, M, D, L

La instrucción se ha ejecutado correctamente.

BUSY

Output

BOOL

I, Q, M, D, L

Borrado del Data Log aún no finalizado.

ERROR

Output

BOOL

I, Q, M, D, L

● 0: Ningún error.
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro STATUS contiene información
más detallada.

STATUS

Output

WORD

I, Q, M, D, L

Parámetro de estado
El parámetro solo está activado durante una
llamada. Por ello, para visualizar el estado de‐
be copiarse el parámetro STATUS en un área
de datos libre.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetros NAME e ID
Los parámetros NAME e ID permiten seleccionar el Data Log que debe borrarse. El parámetro
ID es el primero que se evalúa. Si existe un Data Log con el ID correspondiente, el parámetro
NAME no se evalúa. Si el parámetro ID tiene el valor "0", en el parámetro NAME debe utilizarse
un valor del tipo de datos STRING.

Parámetro RET_VAL
Código de
error*
(W#16#...)

Explicación

0

Ningún error.

7000

No se está procesando ninguna orden.

7001

Inicio de la ejecución de la orden. Parámetro BUSY = 1, DONE = 0

7002

Llamada intermedia (REQ irrelevante): la instrucción ya está activa; BUSY tiene el valor "1".

8070

El número máximo de instrucciones DataLogDelete activas simultáneamente ya se ha alcanzado en este
momento.

8091

En el parámetro NAME se utiliza un tipo de datos diferente de STRING.

8092

El Data Log no existe.

80A2

Error de escritura devuelto por el sistema de archivos.

80B4

La Memory Card tiene activada la protección contra escritura.

80C0

Acceso no disponible actualmente.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

2892

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
Encontrará el ejemplo aquí: Programa de ejemplo para trabajar con Data Logs (Página 2897)
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
DataLogCreate: Crear Data Log (Página 2872)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

DataLogNewFile: Data Log en archivo nuevo
DataLogNewFile: Data Log en archivo nuevo
Descripción
Mediante la instrucción "DataLogNewFile", el usuario crea un nuevo Data Log con las mismas
propiedades que un Data Log existente. De esta forma es posible obtener los contenidos de un
Data Log existente.
Al ser llamada, la instrucción crea un Data Log en la Memory Card o en la memoria de carga
interna con el nombre definido en el parámetro NAME. Con el parámetro ID se indica el ID del
Data Log antiguo cuyas propiedades se quieren adoptar para el Data Log nuevo. Con el
parámetro ID se indica a continuación el ID del Data Log nuevo.
El tamaño de archivo del Data Log nuevo se indica con el parámetro RECORDS de la
instrucción.
Una vez creado, el Data Log nuevo se abre automáticamente. Esto significa que se pueden
escribir datos.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "DataLogNewFile":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, L, D o cons‐
tante

Ejecución de la instrucción con flanco ascendente.

RECORDS

Input

UDInt

I, Q, M, L, D o cons‐
tante

Número de juegos de datos del Data Log nuevo.

NAME

Input

VARIANT

L, D

Nombre de archivo del Data Log nuevo.

ID

InOut

DWORD

I, Q, M, L, D

ID de objeto del Data Log
● In: ID del Data Log ya existente
● Out: ID del Data Log nuevo

Programación del PLC
Manual de programación y manejo, 11/2019

2893

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

DONE

Output

BOOL

I, Q, M, L, D

La instrucción se ha ejecutado correctamente.

BUSY

Output

BOOL

I, Q, M, L, D

Ejecución de la instrucción no finalizada.

ERROR

Output

BOOL

I, Q, M, L, D

● 0: Ningún error.
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro STATUS contiene información más de‐
tallada.

STATUS

Output

WORD

I, Q, M, L, D

Parámetro de estado
El parámetro solo está activado durante una llamada.
Por ello, para visualizar el estado debe copiarse el
parámetro STATUS en un área de datos libre.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de error* Descripción
(W#16#...)
0

Ningún error.

7000

No se está procesando ninguna orden.

7001

Inicio de la ejecución de la orden. Parámetro BUSY = 1, DONE = 0.

7002

Llamada intermedia (REQ irrelevante): la instrucción ya está activa; BUSY tiene el valor "1".

8070

El número máximo de instrucciones DataLogNewFile activas simultáneamente ya se ha alcanzado en
este momento.

8090

Nombre de archivo no válido.

8091

El tipo de datos del parámetro NAME no es STRING.

8092

El Data Log de origen no existe.

8093

El Data Log nuevo ya existe.

8097

La longitud del archivo sobrepasa el límite del sistema de archivos.

80A0

Tipos de datos incoherentes. El Data Log del parámetro ID utiliza otros tipos de datos que los indicados
en el parámetro DATA.

80A2

Error de escritura devuelto por el sistema de archivos.

80B2

Se ha excedido el número máximo de DataLogs o se han agotado los recursos de DataLogs

80B3

Memoria de carga insuficiente.

80B4

La Memory Card tiene activada la protección contra escritura.

80C0

Acceso no disponible actualmente

80C1

Demasiados archivos abiertos.

8253

Valor no válido en el parámetro RECORDS.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

2894

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
Encontrará el ejemplo aquí: Programa de ejemplo para trabajar con Data Logs (Página 2897).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Consulte también
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

DataLogNewFile: Data Log en archivo nuevo
Descripción
Mediante la instrucción "DataLogNewFile", el usuario crea un nuevo Data Log con las mismas
propiedades que un Data Log existente. De esta forma es posible obtener los contenidos de un
Data Log existente.
Al ser llamada, la instrucción crea un Data Log en la Memory Card o en la memoria de carga
interna con el nombre definido en el parámetro NAME. Con el parámetro ID se indica la ID del
Data Log antiguo cuyas propiedades se quieren adoptar para el Data Log nuevo. Con el
parámetro ID se indica a continuación la ID del Data Log nuevo.
El tamaño de archivo del Data Log nuevo se indica con el parámetro RECORDS de la
instrucción.
El parámetro DATA permite comprobar la coherencia entre el Data Log que se va a crear y la
definición del Data Log de la instrucción "DataLogCreate (Página 2872)". Se comprueba si el
tipo de datos del parámetro DATA es idéntico al tipo de datos en "DataLogCreate". De no ser
así, el parámetro STATUS emite el código de error W#16#80A0.
Una vez creado, el Data Log nuevo se abre automáticamente. Esto significa que se pueden
escribir datos.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "DataLogNewFile":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, L, D, T, C o
constante

Ejecución de la instrucción con flanco ascendente.

(T y C solo están dis‐
ponibles en S7-1500
en KOP y FUP)
RECORDS

Input

UDInt

I, Q, M, L, D o cons‐
tante

Número de juegos de datos del Data Log nuevo.

NAME

Input

VARIANT

L, D

Nombre de archivo del Data Log nuevo.

Programación del PLC
Manual de programación y manejo, 11/2019

2895

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

ID

InOut

DWORD

I, Q, M, L, D

ID de objeto del Data Log
● In: ID del Data Log ya existente
● Out: ID del Data Log nuevo

DATA

InOut

VARIANT

D

Tipo de datos para comprobación de coherencia

DONE

Output

BOOL

I, Q, M, L, D

La instrucción se ha ejecutado correctamente.

BUSY

Output

BOOL

I, Q, M, L, D

Ejecución de la instrucción no finalizada.

ERROR

Output

BOOL

I, Q, M, L, D

● 0: Ningún error.
● 1: Se ha producido un error al ejecutar la
instrucción.
El parámetro STATUS contiene información más de‐
tallada.

STATUS

Output

WORD

I, Q, M, L, D

Parámetro de estado
El parámetro solo está activado durante una llamada.
Por ello, para visualizar el estado debe copiarse el
parámetro STATUS en un área de datos libre.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de
error*

Descripción

(W#16#...)
0

Ningún error.

7000

No se está procesando ninguna petición.

7001

Inicio de la ejecución de la petición. Parámetro BUSY = 1, DONE = 0.

7002

Llamada intermedia (REQ irrelevante): la instrucción ya está activa; BUSY tiene el valor "1".

8070

El número máximo de instrucciones DataLogNewFile activas simultáneamente ya se ha alcanzado en este
momento.

8090

Nombre de archivo no válido

8091

El tipo de datos del parámetro NAME no es STRING.

8092

El Data Log de origen no existe.

8093

El Data Log nuevo ya existe.

8097

La longitud del archivo sobrepasa el límite del sistema de archivos o los límites específicos de la CPU.

80A0

Tipos de datos incoherentes. El Data Log del parámetro ID utiliza otros tipos de datos que los indicados en
el parámetro DATA.

80A2

Error de escritura devuelto por el sistema de archivos.

80B2

Se ha excedido el número máximo de DataLogs o se han agotado los recursos de DataLogs

80B3

Memoria de carga insuficiente.

80B4

La Memory Card tiene activada la protección contra escritura.

80C0

Acceso no disponible actualmente.

80C1

Demasiados archivos abiertos.

2896

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*

Descripción

(W#16#...)
8253

Valor no válido en el parámetro RECORDS.

* Los códigos de error en el editor de programas se representan como valores enteros o hexadecimales. Encontrará más
información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Programa de ejemplo para trabajar con Data Logs (Página 2897).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

Programa de ejemplo para trabajar con Data Logs
Introducción
En el siguiente programa de ejemplo se creará un Data Log, se escribirá en el Data Log uno
o varios juegos de datos, se cerrará y abrirá el Data Log y se creará un nuevo archivo
basándose en el Data Log. En el ejemplo también se da una posibilidad para borrar Data Logs.
El ejemplo incluye además la posibilidad de procesar hasta ocho Data Logs.
Para buscar información detallada sobre las diferentes instrucciones abra la descripción
correspondiente de la ayuda utilizando los enlaces correspondientes.

Indicaciones generales sobre el uso de Data Logs
● Tras ejecutar las instrucciones "DataLogCreate" y "DataLogNew", el Data Log creado se
abre automáticamente.
● Después de que la CPU pase de RUN a STOP o se produzca un rearranque completo de
la CPU, los Data Logs se cierran automáticamente.
● Para que la instrucción "DataLogWrite" se ejecute, el Data Log tiene que estar abierto.
● Con las CPU S7-1200 pueden estar abiertos al mismo tiempo un máximo de ocho Data
Logs (diez en el caso de las CPU S7-1500).

Programación del PLC
Manual de programación y manejo, 11/2019

2897

Instrucciones
4.1 Instrucciones

Requisitos
En las propiedades de la CPU se realizan los siguientes ajustes:
● Active el acceso al servidor web en "Interfaz PROFINET > Acceso al servidor web".
● Active el servidor web para el módulo en la entrada "Servidor web".
● En la sección "Administración de usuarios" cree un usuario con derechos de lectura,
escritura y borrado.

Almacenamiento de datos
Para poder llamar y ejecutar un Data Log se necesitan el nombre y el ID del Data Log. Para que
los datos no se pierdan, cree una memoria para las entradas del Data Log. La estructura de
una entrada Data Log se define mediante un tipo de datos PLC "stackDataLog".

Para almacenar los datos deben crearse las variables siguientes en un bloque de datos global
("SLI_gDB_Datalogging"). En ellas se encuentran también la memoria para las entradas Data
Log y las variables para controlar la memoria.
Nota: Si se desea que los Data Logs se borren también físicamente de la memoria de carga de
la CPU es necesario utilizar la variable "DLdelete.deleteMode" con el valor "TRUE".

2898

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

El DB ("SLI_gDB_Datalogging") se utiliza para crear un Data Log (DataLogCreate
(Página 2872)) o para borrarlo (DataLogDelete (Página 2891)). Como valores de proceso se
utilizan las tres entradas de la estructura "myData": count, temerature y pressure. Estos tres
valores se guardan temporalmente en el bloque de datos para transferirlos posteriormente a
un Data Log como juego de datos con la instrucción "DataLogWrite (Página 2887)".
Después de esto, un juego de datos se compone de las entradas siguientes:
● El número de juego de datos (se asigna automáticamente)
● La fecha (se asigna automáticamente cuando con DataLogCreate se utiliza "1" en el
parámetro TIMESTAMP).
● La hora (se asigna automáticamente cuando con DataLogCreate se utiliza "1" en el
parámetro TIMESTAMP).
● El valor actual de "count" proveniente de la estructura "myData".
● El valor actual de "temperature" proveniente de la estructura "myData".
● El valor actual de "pressure" proveniente de la estructura "myData".
Los valores de proceso para escribir un juego de datos (DataLogWrite (Página 2887)) se
proporcionan a través del bloque de datos global "SLI_gDB_DataLogW".

Programación del PLC
Manual de programación y manejo, 11/2019

2899

Instrucciones
4.1 Instrucciones

FC "SLI_FC_saveEntry_DataLog": Interconectar parámetros
Para guardar el nombre y el ID de un Data Log se utiliza una FC "SLI_FC_saveEntry_DataLog".
En ella se crean las siguientes variables locales.

2900

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Segmento 1: Mediante los parámetros de entrada "#name" y "#logID" se transfieren los valores
de las variables "name" y "logID".

Segmento 2: La variable "nextPosInstack" designa la ubicación que va a utilizarse para una
entrada del Data Log en el array "dataLogEntries". La variable "maxPosEntry" designa la última
celda del array "dataLogEntries". Para continuar el procesamiento, los valores de las variables
"nextPosInstack" y "maxPosEntry" se interconectan de la siguiente forma:

Segmento 3: El nombre y el ID se guardan en el array "dataLogEntries" del siguiente modo:

Segmento 4: Para garantizar el almacenamiento de los datos de un Data Log nuevo en otra
entrada de la memoria es necesario incrementar la variable "nextPosInStack".
Nota: Cuando se alcanza el límite de memoria ("#maxPosEntry"), la variable "nextPosInStack"
no se incrementa, sino que se restablece al valor "0". Como consecuencia de ello los datos de
un Data Log nuevo sobrescriben los datos de un Data Log antiguo.

Programación del PLC
Manual de programación y manejo, 11/2019

2901

Instrucciones
4.1 Instrucciones

FC "SLI_FC_callEntry_DataLog": Interconectar parámetros
Para guardar el nombre y el ID de un Data Log seleccionado se crea una FC
"SLI_FC_callEntry_DataLog". En ella se crean las siguientes variables locales. La selección de
la entrada Data Log se especifica mediante la variable "callEntry".

Segmento 1: Para continuar el procesamiento, el valor de la variable "callEntry" se
interconecta de la siguiente forma:

Segmento 2: Para llamar al nombre y al ID del Data Log creado proceda de la siguiente forma.

2902

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 3: Mediante los parámetros de salida "#name" y "#logID" se transfieren los valores
de las variables "dataLogEntries.name" y "dataLogEntries.ID".

FC "SLI_FC_deleteEntry_DataLog": Interconectar parámetros
Para borrar los datos de una entrada Data Log se utiliza una FC
"SLI_FC_deleteEntry_DataLog". En ella se crean las siguientes variables locales.

Segmento 1: A continuación asegúrese de que la variable temporal "#tempEntry" posea un
valor.

Programación del PLC
Manual de programación y manejo, 11/2019

2903

Instrucciones
4.1 Instrucciones
Segmento 2: Si el valor de la variable "callEntry" no sobrepasa el valor de la variable
"maxPosEntry" ocurrirá lo siguiente:
● En el parámetro de entrada #deleteEntry se transfiere el valor de la variable "callEntry". El
Data Log que va a borrarse se selecciona mediante la variable "callEntry".
● Se inicializan las variables "dataLogEntries.name", "dataLogEntries.ID" y
"dataLogEntries.DLclosed" de la entrada seleccionada del Data Log.
Las interconexiones presentan el siguiente aspecto.

FC "SLI_FC_memCloseEntry_DataLog": Interconectar parámetros
Para guardar el estado (abierto o cerrado) del Data Log se utiliza una FC
"SLI_FC_memCloseEntry_DataLog". En ella se crean las siguientes variables locales.

Segmento 1: Para seleccionar la entrada Data Log se transfiere el valor del parámetro de
entrada "#callEntry". Además, mediante el parámetro de entrada "#memClose" se transfiere el
estado del Data Log.

Segmento 2: El estado del Data Log se guarda en la entrada adecuada del Data Log. Las
interconexiones presentan el siguiente aspecto.

2904

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

FB "SLI_FB_DataLogging": Interconectar parámetros
Como bloque central del ejemplo de programa se crea un FB "SLI_FB_DataLogging". En él se
crean las siguientes variables locales.

En el FB se crean las interconexiones siguientes. El FB se llama en un OB de ciclo (OB1).
Segmento 1: Un flanco ascendente en el parámetro de entrada REQ ("DLcreate.execute") de
la instrucción "DataLogCreate (Página 2872)" inicia la creación del Data Log.

Programación del PLC
Manual de programación y manejo, 11/2019

2905

Instrucciones
4.1 Instrucciones
El parámetro de salida DONE ("#createDone") de DataLogCreate solo es válido durante un
ciclo. Por ello, guarde su valor en la variable "DLcreate.dlogCreated". Se inicializa la variable
"DLcreate.execute".
En caso de error, el estado ("DLcreate.status") se guarda en la variable
"DLcreate.memErrStatus".

Segmento 2: El nombre y el ID del Data Log se guarda mediante la FC
"SLI_FC_saveEntry_DataLog". Se guarda cuando el parámetro DONE ("#createDone")
devuelve el estado lógico "TRUE".

Segmento 3: Un flanco ascendente dispara el momento en el que se guardan nuevos valores
de proceso en la estructura "myData" . Este paso sirve para guardar temporalmente los valores
de proceso deseados en el bloque de datos "SLI_gDB_DataLogging".
Además, con ayuda de la FC "SLI_FC_callEntry_DataLog" se llama al Data Log deseado. La
variable "callEntry" permite seleccionar el Data Log mediante su entrada en el array
"dataLogEntries".

2906

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 4: Si se ha creado un Data Log y el valor de la variable "logID" no es "0", se activa
la entrada EN de DataLogWrite (Página 2887). El motivo de la consulta es que un proceso de
creación dura varios ciclos y tiene que haber terminado para que pueda realizarse un proceso
de escritura. Con un flanco ascendente en el parámetro de entrada REQ ("DLwrite.execute")
se inicia el proceso de escritura de un DataLog.
El estado correcto de DataLogWrite ("#writeDone" es "TRUE") se guarda con la variable
"DLwrite.memDone". Se inicializa la variable "DLwrite.execute".
En caso de error, el estado ("DLwrite.status") se guarda en la variable
"DLwrite.memErrStatus". Con el estado "16#0001" la instrucción "DataLogWrite" dispara
automáticamente el cierre del Data Log ("DLclose.execute" es "TRUE").

Programación del PLC
Manual de programación y manejo, 11/2019

2907

Instrucciones
4.1 Instrucciones

Nota
Número de juegos de datos del Data Log
El Data Log se ha creado para cinco juegos de datos (véase el segmento 1).
Lo que significa:
● que, después de cinco juegos de datos, en la instrucción "DataLogWrite (Página 2887)" se
devolverá el valor "0001" en el parámetro STATUS ("DLwrite.status").
● Se ha creado el último juego de datos posible al final del archivo. Cuando se crea un juego
de datos nuevo, se sobrescribe otro más antiguo.
Segmento 5: Antes de cerrar un Data Log se selecciona el Data Log que va a cerrarse
(mediante "callEntry"). Si el contacto NA ("DLclose.execute") devuelve el estado lógico
"TRUE", se llama al Data Log deseado mediante su entrada en el array "dataLogEntries".
Además "#executeClose" se pone a "TRUE". Para ello, cree las interconexiones siguientes:

Segmento 6: Cierre el Data Log después de que se haya escrito el último juego de datos o de
que haya terminado el procesamiento del Data Log.
Para ello, se activa la entrada REQ ("#executeClose") que ejecuta la instrucción
"DataLogClose (Página 2889)". Si el Data Log está cerrado no es posible escribir más juegos
de datos.
El estado correcto de DataLogClose ("#closeDone" es "TRUE") se guarda con la variable
"DLclose.memDone".

2908

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 7: Inicialice automáticamente la variable "DLclose.execute" del siguiente modo.

Segmento 8: La interconexión siguiente permite guardar el estado "cerrado"
("DLclose.memDone" es "TRUE") del Data Log en la entrada Data Log
("dataLogEntries.DLclosed" es "TRUE").

Segmento 9: Antes de abrir un Data Log se selecciona el Data Log que va a abrirse (mediante
"callEntry"). Si el contacto NA ("DLopen.execute") devuelve el estado lógico "TRUE", se llama
al Data Log deseado mediante su entrada en el array "dataLogEntries". Para ello, cree las
interconexiones siguientes:

Programación del PLC
Manual de programación y manejo, 11/2019

2909

Instrucciones
4.1 Instrucciones

Segmento 10: Para poder escribir otro juego de datos más adelante, el Data Log debe volver
a abrirse con la instrucción "DataLogOpen (Página 2883)". Si ahora se escribe otro juego de
datos con DataLogWrite (Página 2887), siempre se sobrescribirá el juego de datos más
antiguo.
El estado correcto de DataLogOpen ("#openDone" es "TRUE") se guarda con la variable
"DLopen.memDone". El estado negado de "#openDone" se guarda con la variable
"#memOpenDone".

Segmento 11: Inicialice automáticamente la variable "DLopen.execute" del siguiente modo.

2910

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Segmento 12: La interconexión siguiente permite guardar el estado "abierto" del Data Log en
la entrada del Data Log ("#memClose" o "dataLogEntries.DLclosed" es "FALSE").

Segmento 13: Para poder crear un archivo nuevo basándose en un Data Log es necesario
seleccionar antes el Data Log que va a utilizarse (mediante "callEntry"). Si el contacto NA
("DLnewfile.execute") devuelve el estado lógico "TRUE", se llama al Data Log deseado
mediante su entrada en el array "dataLogEntries". Para ello, cree las interconexiones
siguientes:

Segmento 14: Si no desea sobrescribir los juegos de datos más antiguos, la instrucción
"DataLogNewFile (Página 2895)" ofrece la posibilidad de crear un Data Log nuevo con la
misma estructura. Para ello, en el parámetro ID de la instrucción especifique el ID del Data Log
existente cuya estructura desea copiar. Después de que se haya ejecutado la instrucción
"DataLogNewFile", se asigna un valor ID nuevo e inequívoco al nuevo Data Log.
Con el flanco ascendente en el parámetro de entrada REQ ("#stateMem5") se inicia el proceso
de creación. El estado correcto de DataLogNewFile ("#newFileDone" es "TRUE") se guarda
con la variable "DLnewfile.memDone". En caso de error, el estado ("#newFileStatus") se
guarda en la variable "DLnewfile.memErrStatus".

Programación del PLC
Manual de programación y manejo, 11/2019

2911

Instrucciones
4.1 Instrucciones

Nota
Llamada en varios ciclos
Tenga en cuenta que la llamada de DataLogNewFile (Página 2895) también se extiende varios
ciclos. Por ejemplo, podría evitarse una ejecución prematura de la instrucción
"DataLogNewFile" consultando el parámetro BUSY de la instrucción DataLogWrite
(Página 2887).
Segmento 15: Inicialice automáticamente la variable "DLnewfile.execute" del siguiente modo.

Segmento 16: El nombre y el ID del Data Log se guarda mediante la FC
"SLI_FC_saveEntry_DataLog". Se guarda cuando el parámetro DONE ("#newFileDone")
devuelve el estado lógico "TRUE".

2912

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Segmento 17: Para poder borrar un Data Log es necesario seleccionar antes el Data Log que
va a borrarse (mediante "callEntry"). Si el contacto NA ("DLdelete.execute") devuelve el estado
lógico "TRUE", se llama al Data Log deseado mediante su entrada en el array
"dataLogEntries". Para ello, cree las interconexiones siguientes:

Segmento 18: Borre los Data Logs que no vayan a utilizarse mediante la instrucción
"DataLogDelete (Página 2891)".
Con el flanco ascendente en el parámetro de entrada REQ ("#stateMem6") se inicia el proceso
de borrado de un Data Log. El estado correcto de DataLogDelete ("DONE" es "TRUE") se
guarda mediante la variable "DLdelete.dlogDeleted". En caso de error, el estado
("#deleteStatus") se guarda en la variable "DLdelete.memErrStatus".

Segmento 19: Inicialice automáticamente la variable "DLdelete.execute" del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

2913

Instrucciones
4.1 Instrucciones

Segmento 20: La entrada del Data Log se borra mediante la FC
"SLI_FC_deleteEntry_DataLog". Se borra cuando el parámetro DONE ("#deleteDone")
devuelve el estado lógico "TRUE".

Resultado
Apertura de los datos escritos desde el servidor web
Los Data Logs creados con el programa de ejemplo se visualizan en el servidor web. Para ello,
abra el servidor web desde el navegador de Internet y abra el directorio "\DataLogs".
Contenidos de los archivos CSV
● Al crear el Data Log con la instrucción DataLogCreate se ha ajustado un número máximo
de juegos de datos de "5". Si dicho número todavía no se ha rebasado, el Data Log contiene
todos los juegos de datos escritos.

● Si se agrega un juego de datos nuevo, se sobrescribe el más antiguo (Record 1).

2914

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

4.1.4.13

Funciones de bloques de datos

CREATE_DB: Generar bloque de datos
Descripción
La instrucción "CREATE_DB" permite crear un bloque de datos en la memoria de carga y/o en
la memoria de trabajo.
La instrucción "CREATE_DB" no modifica la suma de verificación del programa de usuario.
Un bloque de datos que solo se ha creado en la memoria de trabajo tiene las características
siguientes:
● Tras un borrado total o una desconexión y conexión (POWER OFF/ON), el bloque ya no
existe.
● Durante la carga o en caso de paso de STOP a RUN su contenido no cambia.

Número del bloque de datos
El bloque de datos creado recibe el número libre más bajo del área definida por los parámetros
LOW_LIMIT (límite inferior) y UP_LIMIT (límite superior). Este número se devuelve en el
parámetro DB_NUM. Si se encuentra un número en el área permitida de la CPU, se crea el DB.
Para crear un DB con un número determinado, asigne el mismo número al límite superior y al
límite inferior del área especificada. Si ya existe en la memoria de trabajo y/o en la memoria de
carga un DB con el mismo número, o si el DB existe ya como variante copiada, la instrucción
finaliza y se devuelve un mensaje de error en el parámetro RET_VAL.

Valores de arranque del bloque de datos
Con el parámetro SRCBLK se definen los valores de arranque del DB que va a generarse. El
parámetro SRCBLK es un puntero hacia un DB o un área DB del o de la que se toman los
valores de arranque. El DB direccionado en el parámetro SRCBLK ha tenido que crearse con
acceso estándar (atributo "Acceso optimizado al bloque" desactivado).
● Si el área indicada en el parámetro SRCBLK es mayor que el DB generado, los valores
hasta la longitud completa del DB generado se consideran valores de arranque.
● Si el área indicada en el parámetro SRCBLK es menor que el DB generado, los valores
restantes se rellenan con "0".

Programación del PLC
Manual de programación y manejo, 11/2019

2915

Instrucciones
4.1 Instrucciones
Para garantizar la coherencia de los datos, no se debe modificar esa área de datos durante el
procesamiento de "CREATE_DB" (es decir, mientras el parámetro BUSY tenga el valor TRUE).
Nota
SRCBLK apunta a una variable TEMP
Las variables TEMP de bloques estándar se encuentran en el área de datos locales temporal.
Por ello, una referencia en SRCBLK a una variable TEMP tiene como consecuencia que se
emita el valor 80A3 como RET_VAL (el bloque de datos en el parámetro SRCBLK no se ha
creado con acceso estándar).

Funcionamiento
La instrucción "CREATE_DB" es una instrucción que funciona de forma asíncrona. Su
ejecución se prolonga a lo largo de varias llamadas. Para iniciar la orden, debe llamarse
"CREATE_DB" con REQ = 1.
El estado de la orden se indica por medio de los parámetros de salida RET_VAL y BUSY.
Consulte también: Diferencia entre las instrucciones que funcionan síncronamente y las que
funcionan asíncronamente (Página 618)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "CREATE_DB":
Parámetro

Declara‐
ción

Tipo de
datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Parámetro de control disparado por nivel "request to activate"

LOW_LIMIT Input

UINT

I, Q, M, D, L o cons‐
tante

Límite inferior del área para la asignación de un número de DB.
El número más bajo posible de DB es 60000.

UP_LIMIT

Input

UINT

I, Q, M, D, L o cons‐
tante

Límite superior del área de la cual "CREATE_DB" extrae el nú‐
mero que se asigna al DB (número de DB más alto posible:
60999)

COUNT

Input

UDINT

I, Q, M, D, L o cons‐
tante

El valor de contaje indica el número de bytes que se desea re‐
servar para el DB creado. El número de bytes debe ser un nú‐
mero par. La longitud máxima es de 65534 bytes.

2916

REQ = 1: solicitud para crear el bloque de datos

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción

Tipo de
datos

Área de memoria

Descripción

ATTRIB

Input

BYTE

I, Q, M, D, L o cons‐
tante

Con los primeros 4 bits del byte en el parámetro ATTRIB se
definen las propiedades del bloque de datos *:
● Bit 0 = 0: Atributo "Depositar solo en la memoria de carga" no
activado.
● Bit 0 = 1: Atributo "Depositar solo en la memoria de carga"
activado. Con esta configuración, el DB no ocupa espacio en
la memoria de trabajo y no se integra en el programa. No es
posible acceder al DB con comandos de bit. Si bit 0 = 1, la
selección para el bit 2 resulta irrelevante.
Por motivos de compatibilidad con STEP 7 V5.x, los bits 0 y 3
deben considerarse conjuntamente (véase más abajo).
● Bit 1 = 0: Atributo "Bloque de datos protegido contra escritura
en el dispositivo" no activado.
● Bit 1 = 1: Atributo "Bloque de datos protegido contra escritura
en el dispositivo" activado.
● Bit 2 = 0: DB remanente (solo DB creados en la memoria de
carga y trabajo). El DB se considera remanente si se ha
ajustado como remanente al menos un valor.
● Bit 2 = 1: DB no remanente
La remanencia no se soporta en DB que solo se depositan en la
memoria de carga o solo en la memoria de trabajo. Si se llama la
instrucción "CREATE_DB" con una de las combinaciones "re‐
manente y solo memoria de carga" o "remanente y solo memoria
de trabajo", el DB se creará y marcará como no remanente.
● Bit 3 = 0: Creación del DB en la memoria de carga o en la
memoria de trabajo (selección mediante bit 0, ver arriba)
● Bit 3 = 1: Creación del DB en la memoria de carga y en la
memoria de trabajo (bit 0 irrelevante)
Por motivos de compatibilidad con STEP 7 V5.x, los bits 0 y 3
deben utilizarse conjuntamente. Si el bit 3 = 1, el bit 0 es irrele‐
vante.
Bit 0

Bit 3

Creación de DB

0

0

Solo en la memoria de trabajo
Nota: los DB que solo se encuentran en la
memoria de trabajo no pueden ser modifica‐
dos por clientes externos como dispositivos
HMI.

1

0

Solo en la memoria de carga

Irrele‐
vante

1

Memoria de trabajo y memoria de carga

● Bit 4 = 0: valores de arranque sin predefinir (los valores de
entrada en el parámetro SRCBLK se ignoran).
● Bit 4 = 1: predefinir valores de arranque (los valores
corresponden al DB direccionado mediante el parámetro
SRCBLK).
SRCBLK

Input

VA‐
RIANT

D

Programación del PLC
Manual de programación y manejo, 11/2019

Puntero hacia el bloque de datos con cuyos valores se iniciali‐
zará el bloque de datos que se va a crear.

2917

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción

Tipo de
datos

Área de memoria

Descripción

RET_VAL

Return

INT

I, Q, M, D, L

Información de error

BUSY

Output

BOOL

I, Q, M, D, L

BUSY = 1: la operación todavía no ha finalizado.

DB_NUM

Output

DB_DY I, Q, M, D, L
N (UINT)

Número del DB creado.

* Las propiedades seleccionadas aquí corresponden a los atributos de las propiedades de un bloque de datos.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro RET_VAL
Código de
error*
(W#16#...)

Descripción

0000

Ningún error

0081

El