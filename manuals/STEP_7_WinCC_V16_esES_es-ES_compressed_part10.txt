tive la opción "Enviar aviso si el estado cambia de/a activado o desactivado", si desea que
aparezca un aviso cuando se produzca un cambio de estado. Para utilizar esta opción, debe
utilizar la instrucción "D_ACT_DP" en modo 3/4 y haber seleccionado la llamada del FB de
diagnóstico del OB 86 en el grupo "Configuración OB".

2.4.9.4

Ajustes para los bloques de diagnóstico del sistema
Los bloques de diagnóstico del sistema tienen predefinidos los siguientes valores:
Bloque

Nombre

Número

FB de diagnóstico

RSE_FB

49

DB de diagnóstico

RSE_DB

49

primer DB global

RSE_GLOBAL_DB

50

FC de diagnóstico

RSE_FC

49

No obstante, es posible asignar a estos bloques otros números o nombres, siempre y cuando
aún no estén en uso.

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

3681

Diagnosticar dispositivos y redes
2.5 Diagnóstico del sistema para PLC S7-1500

2.4.10

Exportar e importar ajustes de diagnóstico de sistema

2.5

Diagnóstico del sistema para PLC S7-1500

2.5.1

Introducción

Introducción
Los componentes de hardware y los dispositivos de terceros (esclavos cuyas propiedades
están determinadas por su archivo GSD) pueden lanzar una reacción del sistema al producirse
un error de sistema. Los componentes de hardware ofrecen información sobre el error de
sistema ocurrido.
El diagnóstico del sistema ofrece para los PLC S7-1500 una manera cómoda de evaluar esta
información de diagnóstico y visualizarla en forma de avisos.
Además, la información de diagnóstico adicional permite especificar el error con mayor
precisión, p. ej., canal "Interruptor_Arriba", rotura de hilo o rebase del rango de medición.

2.5.2

Principios básicos del diagnóstico del sistema
El diagnóstico del sistema permite analizar los errores del sistema y generar avisos con la
descripción textual del error y su ubicación.
Estos avisos se definen para cada componente que emite avisos (p. ej., fallo de canal o fallo
de rack).

Procedimiento recomendado
Lleve a cabo los ajustes para el diagnóstico del sistema y la estructura de los avisos.
Los siguientes capítulos ofrecen información detallada.

2.5.3

Visualización de los ajustes del diagnóstico del sistema

Requisitos
Se encuentra en la carpeta "Datos comunes" del árbol del proyecto.

3682

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Diagnosticar dispositivos y redes
2.5 Diagnóstico del sistema para PLC S7-1500

Procedimiento
Para mostrar y editar las propiedades del diagnóstico del sistema, proceda del siguiente modo:
1. Haga doble clic en la entrada "Ajustes de diagnóstico de sistema".
2. En el diagnóstico del sistema puede ver y editar los distintos ajustes.

2.5.4

Configuración

2.5.4.1

Configuración general

Activar el diagnóstico de sistema para este PLC
Esta opción está activada por defecto y no puede desactivarse.

Nota
Si esta opción está desactivada, en el servidor web y en el visor de diagnóstico tampoco se
leerán datos de diagnóstico aunque la opción esté activada allí.
Si esta opción se desactiva en un PLC en el que estaba activada previamente, todos los datos
de diagnóstico se borrarán la próxima vez que se compile la configuración hardware.

No notificar errores de red como errores, sino como solicitud de mantenimiento
Si activa esta opción, los errores de red se notificarán como "Mantenimiento solicitado".

2.5.4.2

Ajustes de avisos
Para las categorías de aviso listadas a continuación se puede definir si emitir un aviso y si el
aviso debe ser de acuse obligatorio o no.
● Error
● Mantenimiento solicitado
● Mantenimiento necesario
● Información
Active para ello los botones de opción deseados en las columnas "Aviso" y "Acuse".
En la columna "Categoría" se indica la categoría de aviso ajustada.
En la columna "Prioridad" se muestra la prioridad ajustada para la categoría.

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

3683

Diagnosticar dispositivos y redes
2.5 Diagnóstico del sistema para PLC S7-1500

2.5.5

Exportar e importar ajustes de diagnóstico de sistema

2.5.5.1

Principios básicos para exportar e importar ajustes de diagnóstico de sistema

Descripción
Los ajustes de diagnóstico del sistema de un proyecto pueden exportarse e importarse a otro
proyecto. La ventaja de esto es que evita tener que crear estos ajustes individualmente para
cada proyecto.
Los ajustes de diagnóstico del sistema se guardan en un archivo de datos (*.dat).

2.5.5.2

Exportar ajustes de diagnóstico de sistema

Requisitos
Hay un proyecto abierto.

Procedimiento
Para exportar los ajustes de diagnóstico del sistema, proceda del siguiente modo:
1. En el árbol del proyecto haga clic en la carpeta "Datos comunes" y haga doble clic en la
entrada "Ajustes de diagnóstico del sistema".
2. En el diagnóstico del sistema haga clic en el icono "Exportar ajustes de diagnóstico del
sistema" de la barra de herramientas. Se abre el cuadro de diálogo "Guardar como".
3. Seleccione la ruta en la que se debe depositar el archivo de exportación.
4. Haga clic en el botón "Guardar".

Resultado
En la ubicación seleccionada se crea un archivo .dat.

2.5.5.3

Importar ajustes de diagnóstico del sistema

Requisitos
El proyecto al que se van a exportar los ajustes de diagnóstico del sistema está abierto.

3684

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Procedimiento
Para importar los ajustes de diagnóstico del sistema, proceda del siguiente modo:
1. En el árbol del proyecto haga clic en la carpeta "Datos comunes" y haga doble clic en la
entrada "Ajustes de diagnóstico del sistema".
2. En el diagnóstico del sistema haga clic en el icono "Importar ajustes de diagnóstico del
sistema" de la barra de herramientas. Se abre el cuadro de diálogo "Abrir".
3. Seleccione la ruta en la que está depositado el archivo que debe importarse.
4. Seleccione el archivo .dat que desee.
5. Haga clic en el botón "Abrir".
Nota
El icono "Importar" se muestra en gris si el proyecto abierto está protegido contra escritura (p.
ej. proyecto de referencia).
Si se producen errores durante la importación, aparecerá un mensaje y el proceso se
interrumpirá.

Resultado
Se muestran los ajustes de diagnóstico del sistema.

2.6

Utilizar posibilidades de diagnóstico adicionales

2.6.1

Diagnosticar el hardware

2.6.1.1

Mostrar valores actuales y no modificables de propiedades de módulos parametrizables

Mostrar propiedades generales e información relevante para la instalación relacionadas con un módulo
¿Dónde está la información buscada?
Las propiedades generales y la información relevante para la instalación relacionadas con un
módulo están en el grupo "General" de la carpeta "Diagnóstico" de la vista online y de
diagnóstico del módulo que debe diagnosticarse.

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

3685

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Estructura del grupo "General"
El grupo "General" incluye las áreas siguientes:
● Módulo
● Información del módulo
● Información del fabricante

Área "Módulo"
En S7-300 y S7-400, esta área muestra además el siguiente dato del módulo:
● Versión del bootloader

Área "Información del módulo"
En S7-300 y S7-400, esta área muestra además los siguientes datos del módulo, que se han
ajustado durante la configuración del hardware:
● Nombre de la estación (que se asignó en la vista de redes.)
● Identificador de instalación
Si una CPU, un esclavo, un dispositivo IO o un módulo de la estación soporta la
parametrización de un identificador de instalación unívoco en toda la instalación, se
muestra aquí (el identificador de instalación permite identificar de modo unívoco partes de
la instalación con criterios funcionales. Tiene una estructura jerárquica conforme a IEC
1346-1.). Permite, p. ej., identificar una CPU desde el programa de usuario. El identificador
de instalación puede leerse con la instrucción "RDSYSST".
● Identificador de ubicación
Si una CPU, un esclavo, un dispositivo IO o un módulo de la estación soporta la
parametrización de un identificador de ubicación unívoco en toda la instalación, se muestra
aquí (el identificador de ubicación forma parte del identificador de recursos, que caracteriza
p. ej. la posición exacta de un punto de instrumentación y control dentro de una instalación
técnica de proceso, de modo análogo a como se ubica una calle en el plano de una ciudad).

Área "Información del fabricante"
En S7-300 y S7-400, esta área muestra además el siguiente dato del módulo:
● Entrada de derechos de autor

Ver las propiedades de comunicación de un módulo
¿Dónde está la información buscada?
Las propiedades de comunicación de un módulo están en el grupo "Comunicación" de la
carpeta "Diagnóstico" de la vista online y de diagnóstico del módulo que debe diagnosticarse.

3686

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales
Se trata de las siguientes propiedades:
● Carga del ciclo por comunicación, configurada:
Valor ajustado del parámetro "Carga de ciclo por comunicación", es decir, aquella parte del
rendimiento de la CPU de la que se dispone en el ciclo para la comunicación.
● Recursos de conexión, número máximo:
Indica el número máximo posible de recursos de conexión disponibles en el módulo.
Siempre hay un determinado número de los recursos de conexión reservado para la
comunicación PG y OP, y en S7-300 (a excepción de la CPU 318-2 DP), para la
comunicación básica S7. Sin embargo, además de esto pueden crearse también otras
conexiones para PG u OP; en tal caso, el número de los recursos de conexión no ocupados
se reducirá proporcionalmente.

Ver las interfaces y las propiedades de interfaces de un módulo
¿Dónde está la información buscada?
Las interfaces y las propiedades de interfaces de un módulo están en los siguientes grupos de
la carpeta "Diagnóstico" de la vista online y de diagnóstico del módulo que debe
diagnosticarse:
● Interfaz MPI
● Interfaz MPI/DP
● Interfaz DP
● Interfaz PROFINET

Grupo "Interfaz MPI"
Este grupo muestra el siguiente dato:
● Velocidad de transferencia:
La velocidad de transferencia ajustada actualmente en la interfaz MPI del sistema de
automatización

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

3687

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Grupo "Interfaz MPI/DP"
Este grupo muestra los siguientes datos:
● Velocidad de transferencia:
La velocidad de transferencia ajustada actualmente en la interfaz MPI/DP del sistema de
automatización
● Modo de operación DP:
Modo de compatibilidad de la interfaz MPI/DP ajustada al tipo de interfaz "PROFIBUS". En
los módulos que soportan el modo de operación "DPV1", este puede adoptar los valores
"Compatible con S7" y "DPV1".
Nota
Si la interfaz MPI/DP está ajustada al tipo de interfaz "MPI", el campo "Modo de operación
DP" no contiene ningún valor válido.

Grupo "Interfaz DP"
Este grupo muestra los siguientes datos:
● Modo de operación DP:
Modo de compatibilidad de la interfaz DP. En los módulos que soportan el modo de
operación "DPV1", este puede adoptar los valores "Compatible con S7" y "DPV1".

Grupo "Interfaz PROFINET"
Este grupo se divide en las siguientes áreas:
● "Dirección Ethernet" con las subáreas "Conexión de red" y "Parámetro IP"
● "Puertos"
● "Estadística" (esta área no se contempla aquí, ya que no se trata de valores reales de
propiedades de módulo configurables.)
Nota
Las áreas "Dirección Ethernet" y "Puertos" ya se han descrito fuera del capítulo "Utilizar
posibilidades de diagnóstico adicionales", ya que son aplicables a S7-1200 y S7-300/S7-400.

Ver las áreas de operandos, bloques de organización y bloques de sistema de una CPU
¿Dónde se encuentra la información buscada?
Las áreas de operandos, los bloques de organización y los bloques de sistema de una CPU
están en el grupo "Datos de rendimiento" de la carpeta "Diagnóstico" de la vista Online y
diagnóstico del módulo que debe diagnosticarse.

3688

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Grupo "Datos de rendimiento"
En el grupo "Datos de rendimiento" se muestra la siguiente información acerca de la CPU
correspondiente:
● Áreas de operandos:
Esta tabla informa acerca de
– El tipo de operando, p. ej., memoria imagen de proceso de las entradas, contadores
– El número de operandos o su tamaño de área
– El área de direcciones disponible de los operandos, p. ej. de E0.0 a E127.7
● Bloques de organización:
Todos los bloques de organización (OBs) junto con su función
Las líneas de la tabla pueden ordenarse de la siguiente manera: Haciendo clic en un rótulo
de columna, las líneas de la tabla se ordenan de manera que los contenidos de dicha
columna aparecen en orden alfabético descendente.
● Bloques de sistema:
Todas las funciones de sistema (SFCs) y todos los bloques de función de sistema (SFBs)
Las líneas de la tabla pueden ordenarse de la siguiente manera: Haciendo clic en un rótulo
de columna, las líneas de la tabla se ordenan de manera que los contenidos de dicha
columna aparecen en orden alfabético descendente.

Ver las propiedades del sistema horario de un módulo
¿Dónde están las funciones buscadas?
Las propiedades del sistema horario de un módulo se encuentran en su vista online y de
diagnóstico, en el grupo "Ajustar hora" de la carpeta "Funciones".

Estructura del grupo "Ajustar hora"
El grupo "Ajustar hora" incluye las áreas siguientes:
● Área para la lectura y ajuste de la hora (esta área no se contempla aquí)
● Sistema horario

Estructura del área "Sistema horario"
El área "Sistema horario" está compuesta por las siguientes subáreas:
● "Reloj"
● "Sincronización"

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

3689

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Subárea "Reloj"
La subárea "Reloj" incluye los elementos siguientes:
● Resolución:
Indica la precisión con la que se realiza el cálculo y la presentación de la hora
● Reloj en tiempo real:
Indica si la CPU está provista de reloj en tiempo real: En caso afirmativo, "existente", y en
caso negativo, "no existente"
● Factor de corrección:
Factor de corrección parametrizado para el reloj en tiempo real del módulo. El factor de
corrección compensa la desviación diaria del reloj.

Subárea "Sincronización"
Los mecanismos de sincronización permiten sincronizar los relojes de diferentes sistemas
parciales. Los ajustes para la sincronización horaria se realizan al parametrizar el módulo.
El reloj en tiempo real integrado -si existe- puede sincronizar los relojes de otros módulos
(modo maestro) o puede ser sincronizado por los relojes de otros dispositivos (modo esclavo),
o bien puede no participar en la sincronización. La sincronización puede realizarse en el AS o
en MPI.

2.6.1.2

Mostrar valores actuales de propiedades de módulos dinámicas

Mostrar el estado actual de los LEDs y el selector de modo de una CPU
¿Dónde está la información buscada?
El estado actual de los LEDs y el selector de modo de una CPU se encuentra en el área de
visualización de la paleta "Panel de control de la CPU" de la Task Card "Herramientas online".

Área de visualización de la paleta "Panel de control de la CPU" de la Task Card "Herramientas online"
Esta área contiene los indicadores siguientes:
● Nombre de estación y tipo de CPU
● Error (equivale al LED "SF" en las CPUs S7-300)
● RUN (equivale al estado operativo "RUN" de la CPU)
● STOP (equivale al estado operativo "STOP" de la CPU)
● FORCE (equivale al estado operativo "FRCE" de la CPU)
● Posición actual del selector de modo
Nota
Puede suceder que, en las CPUs S7-300 con selector de modo, se muestre erróneamente
la posición "RUN-P". En este caso, el selector de modo se encuentra en la posición "RUN".

3690

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Ver los recursos de conexión todavía no ocupados y las conexiones ocupadas y reservadas de una CPU
¿Dónde está la información buscada?
Los recursos de conexión todavía no ocupados y las conexiones ocupadas y reservadas de
una CPU se encuentran en el grupo "Comunicación" de la carpeta "Diagnóstico" en la vista
online y de diagnóstico.
El área "Recursos de conexión" contiene los valores actuales de las siguientes propiedades
dinámicas de módulos:
● Número de recursos de conexión todavía no ocupados
Se encuentran en el apartado "No ocupados".
Nota
Si ya hay recursos de conexión reservados para determinados tipos de comunicación, los
no ocupados no siempre pueden utilizarse para cualquier tipo de conexión.
● Comunicación PG "reservada" y "ocupada":
Número de recursos de conexión que están reservados u ocupados para conexiones entre
el módulo y las PGs.
Nota
El número de recursos de conexión ocupados puede ser mayor que el número de recursos
de conexión reservados, ya que, siempre dentro del número máximo, pueden utilizarse
recursos de conexión todavía libres para la comunicación PG. En las CPUs S7-300 con
recursos de conexión parametrizables, es posible aumentar el número de recursos de
conexión para la comunicación PG a costa de la comunicación básica S7.
● Comunicación OP "reservada" y "ocupada":
Número de recursos de conexión que están reservados u ocupados para conexiones entre
el módulo y los dispositivos HMI (TDs, OPs).
Nota
El número de recursos de conexión ocupados puede ser mayor que el número de recursos
de conexión reservados, ya que, siempre dentro del número máximo, pueden utilizarse
recursos de conexión todavía libres para la comunicación OP. En las CPUs S7-300 con
recursos de conexión parametrizables, es posible aumentar el número de recursos de
conexión para la comunicación OP a costa de la comunicación básica S7.
● Comunicación S7 "reservada" y "ocupada":
Se visualiza en las CPUs S7-400, así como en la CPU 318-2 y en la CPU 317-2 PN/DP.
Recursos reservados u ocupados para conexiones S7 configuradas que permiten
intercambiar datos en el programa de usuario mediante la llamada de bloques de función
de comunicación (SFBs). Estas conexiones pueden contemplarse como si estuvieran
cableadas de modo permanente (p. ej. conexiones CPU-CPU). Pueden establecerse
automáticamente al inicio de la comunicación o bien establecerse o deshacerse mediante
instrucciones de programación. La comunicación S7 es posible a través de MPI,
PROFIBUS e Industrial Ethernet.

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

3691

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales
● Comunicación básica S7 "reservada" y "ocupada":
Se visualiza en las CPUs S7-300 (no en la CPU 318-2 DP ni en la CPU 317-2 PN/DP).
Recursos reservados u ocupados para conexiones no configuradas que permiten
intercambiar datos en el programa de usuario mediante la llamada de funciones de
comunicación (SFCs). La comunicación básica S7 solo es posible a través de MPI o dentro
del sistema de automatización.
● Otra comunicación "ocupada"
Otros recursos de conexión ocupados que no tienen reservados recursos de conexión.
Ejemplos:
– Comunicación de una CPU S7-300 a través de un CP (solo en las CPUs con recursos
de conexión parametrizables)
– Gateway (routing S7) en CPUs S7-400
Nota
Los recursos de conexión ocupados por una función de servidor en la comunicación S7 (es
decir, cuando una CPU S7-400 se comunica a través de las SFCs "PUT" o "GET" con una CPU
S7-300) se muestran en las CPUs S7-300 en los siguientes recursos:
● Si la CPU no posee recursos de conexión parametrizables: En "Comunicación básica S7"
● Si la CPU posee recursos de conexión parametrizables: En las CPUs 317-2 PN/DP y 318-2,
en "Comunicación S7", y en todas las demás en "Otra comunicación"

Ver los datos estadísticos de las transferencias de datos realizadas a través de la interfaz Ethernet
¿Dónde está la información buscada?
Los datos estadísticos de las transferencias de datos realizadas a través de la interfaz Ethernet
se encuentran en el área "Estadística" del grupo "Interfaces PROFINET" en la carpeta
"Diagnóstico" de la vista online y de diagnóstico.

Área "Estadística"
● Visualización
Se muestran las estadísticas de paquetes de datos enviados y recibidos. Con ayuda de
estos datos se puede evaluar la calidad de la transferencia de datos.
El inicio del registro de las estadísticas se indica en la primera línea ("Paquetes de datos
desde:"). Cada reinicio de los datos estadísticos reinicia ese tiempo (botón "Resetear").
La visualización de datos estadísticos se actualiza de modo continuo.
● Botón "Resetear"
El tiempo "Paquetes de datos desde" se reinicia y los datos estadísticos se ponen a "0".

3692

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Ver información acerca de los contadores de horas de funcionamiento de una CPU
¿Dónde está la información buscada?
La información acerca de los contadores de horas de funcionamiento está en el grupo
"Contador de horas de funcionamiento" de la carpeta "Diagnóstico" de la vista online y de
diagnóstico.

Grupo "Contador de horas de funcionamiento"
En el grupo "Contador de horas de funcionamiento" se muestra la siguiente información acerca
de los contadores de horas de funcionamiento activos:
● N.º del contador de horas de funcionamiento junto con la información de si se trata de un
contador de 16 bits o de 32 bits
● Horas de funcionamiento transcurridas
● Estado
● Información sobre si se ha producido un desbordamiento
Si la CPU tiene uno o varios contadores de horas de funcionamiento de 32 bits, al pasar de
32767 (valor máximo de un contador de horas de funcionamiento de 16 bits) el icono
correspondiente aparece rodeado de un marco rojo. En la columna "Desbordamiento" aparece
"no" si el contador de horas de funcionamiento no ha rebasado todavía el valor máximo de un
contador de 32 bits.
El contador de horas de funcionamiento de 32 bits se activa, inicia, detiene y lee con la
instrucción "RTM".

2.6.1.3

Comprobar los fallos de un módulo

Realizar el diagnóstico específico de canal de módulos no CPU
¿Dónde se muestran los resultados del diagnóstico específico de canal de los módulos no CPU?
Los resultados del diagnóstico específico de canal de los módulos no CPU se muestran en el
grupo "Diagnóstico de canal" en su vista online y de diagnóstico.

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

3693

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Grupo "Diagnóstico de canal"
La visualización está compuesta por los siguientes elementos para cada resultado:
● Slot del módulo averiado
● Número del canal averiado
Tenga en cuenta que en esta visualización el recuento de los números de canal empieza
por 0.
● Tipo de error
Nota
Alarmas de diagnóstico
Sólo es posible notificar una alarma de diagnóstico a la CPU si el módulo es apto para esta
función y se ha habilitado la alarma de diagnóstico.
La visualización de la alarma de diagnóstico es una captura instantánea. Los fallos
esporádicos de un módulo se detectan en el búfer de diagnóstico de la CPU
correspondiente.
Al seleccionar una línea en la tabla de los errores de canal, se ofrece información adicional
acerca de ese error (si existe).

Efectuar un diagnóstico de comunicación de los puertos PROFINET
¿Cómo se muestran los errores específicos de puerto de los puertos PROFINET?
Los errores específicos de puertos de los puertos PROFINET se muestran en el apartado
"Interfaz PROFINET" del grupo "Diagnóstico de comunicación" de la carpeta "Diagnóstico" de
la vista online y de diagnóstico del módulo que debe diagnosticarse.

Estructura del grupo "Diagnóstico de comunicación"
El grupo "Diagnóstico de comunicación" incluye las áreas siguientes:
● Tabla de errores específicos de puertos
● Campo de texto "Detalles del evento"
● Campo de texto "Ayuda del evento"

Estructura de la tabla de errores específicos de puertos
Cada línea de la tabla de errores corresponde a un error.
La tabla contiene las columnas siguientes:
● Nombre: N.º de puerto y denominación de puerto, así como el icono de diagnóstico
● Error: Descripción del error sucedido en ese puerto

3694

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Campo de texto "Detalles"
Al seleccionar una línea en la tabla de errores, el campo de texto "Detalles" contiene
información acerca del error correspondiente (si existe).

Campo de texto "Ayuda para la línea de diagnóstico seleccionada"
Al seleccionar una línea en la tabla de errores, el campo de texto "Ayuda para la línea de
diagnóstico seleccionada" contiene información de ayuda acerca del error correspondiente (si
existe).

Diagnosticar componentes de PROFINET IO
¿Cómo se diagnostican los componentes de PROFINET IO?
El diagnóstico de los componentes PROFINET IO se realiza en el grupo "Diagnóstico de
PROFINET IO" del apartado "Interfaz PROFINET" de la carpeta "Diagnóstico" de la vista
online y de diagnóstico.

Grupo "Diagnóstico de PROFINET IO"
En esta área se muestran textos de diagnóstico, específicos de fabricante, para el dispositivo
IO o para el módulo seleccionado del dispositivo IO.
Si puede leerse el diagnóstico desde el controlador IO, se muestran errores de comunicación
y errores de configuración (diferencia online/offline).

Iniciar el diagnóstico de NCM S7
Requisitos
● No es necesario que haya conexión online con el módulo.

Procedimiento
Para iniciar el diagnóstico NCM S7, proceda del siguiente modo:
1. Abra el módulo en la vista online y de diagnóstico.
2. Elija el grupo "Diagnóstico especial" de la carpeta "Funciones".
3. Haga clic en el botón "Iniciar diagnóstico especial" del área "Diagnóstico especial".

Resultado
Se inicia el diagnóstico de NCM S7.

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

3695

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Conexiones online para diagnóstico especial y cargador de firmware
Diagnóstico especial: establecer conexión online
Algunos componentes de red (CP S7-300/400, CP PC y transiciones de red) proporcionan
datos de diagnóstico avanzados en el diagnóstico especial.
Requisitos:
Una interfaz PG/PC está conectada físicamente al dispositivo de destino, p. ej. mediante un
cable Ethernet.
Procedimiento:
Para iniciar el diagnóstico especial proceda del siguiente modo:
1. Abra la vista online y de diagnóstico del módulo.
2. Seleccione el grupo "Diagnóstico especial" de la carpeta "Funciones".
3. Haga clic en el botón "Iniciar diagnóstico especial" del área "Diagnóstico especial".
Con STEP 7 Professional V14 o superior y para algunos CP, desde la estación de ingeniería
solo es posible establecer una única conexión online a través del CP. Dicha conexión puede
establecerse con STEP 7 o con el diagnóstico especial.
Si no se ha iniciado el diagnóstico especial a través de los pasos mencionados anteriormente
y se emite un aviso de error, proceda del siguiente modo:
1. Deshaga la conexión online existente con la estación.
2. Abra de nuevo la vista online y de diagnóstico del módulo como se ha descrito
anteriormente e inicie el diagnóstico especial.
Aplicaciones de 32 bits: diagnóstico NCM S7, cargador de firmware
Si se ha establecido una conexión con un CP PC desde una aplicación de 32 bits y se desea
establecer otra conexión online a través de la misma interfaz del CP PC, primero hay que
finalizar la conexión de la aplicación de 32 bits.

Diagnóstico especial y cargador de firmware: GUI en chino
Si abre el diagnóstico especial o el cargador de firmware con la GUI en chino, deberá ajustar
a chino el idioma para aplicaciones no Unicode en el sistema operativo.

3696

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

2.6.1.4

Modificar las propiedades de un módulo o de la PG/el PC

Particularidad al cambiar el estado operativo de una CPU S7-400
Preselección del tipo de arranque de una CPU S7-400 al cambiar al estado operativo "RUN"
Para pasar una CPU S7-400 al estado operativo "RUN", elija uno de los tipos de arranque
siguientes:
● Rearranque (en caliente)
● Arranque en frío
● Rearranque

Registrarse en la CPU para acceder a avisos y resultados de diagnóstico del sistema
Requisitos
● A través de la interfaz PG/PC puede accederse a uno o varios dispositivos de una subred.

Procedimiento
1. Abra la vista online y de diagnóstico de la CPU en cuestión.
2. Seleccione el grupo "Accesos online".
3. En el área "Avisos", active la casilla de verificación "Recibir avisos".

Resultado
La próxima vez que se conecte online, la PG/el PC se registrará en la CPU en cuestión para
acceder a avisos y resultados de diagnóstico del sistema.
Nota
Para visualizar los avisos, se requiere una conexión online permanente con cada una de las
CPUs de las que se reciban avisos.

Registrarse con una conexión online ya existente
Si la conexión online con una CPU ya está establecida, es posible registrarse o darse de baja
para avisos posteriormente de la siguiente manera:
● Con el comando "Recibir avisos" del menú "Online"
● En el árbol del proyecto, mediante el menú contextual de la CPU

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

3697

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales
● En la vista de dispositivos de la configuración de hardware, mediante el menú contextual de
la CPU
● En la vista de redes de la configuración de hardware, mediante el menú contextual de la
CPU

Consulte también
Recibir avisos (Página 3350)

Comprimir la memoria y copiarla de RAM a ROM
¿Dónde está la información buscada?
La reorganización de la memoria y su copia de RAM a ROM se encuentra en el área de
comandos de la paleta "Memoria" de la Task Card "Herramientas online".
La reorganización de la memoria se encuentra también en el área de comandos del grupo
"Memoria" de la carpeta "Diagnóstico" de la vista online y de diagnóstico del módulo que debe
diagnosticarse.

Área de comandos de la paleta "Memoria" de la Task Card "Herramientas online"
Esta área puede contener los botones siguientes:
● Comprimir
Con este botón se reorganiza la memoria para aumentar el tamaño de la mayor área de
memoria coherente libre.
● Copiar de RAM a ROM
Con este botón se copia el contenido de la memoria de carga RAM (programa de usuario)
a una FEPROM:
– En la Memory Card insertada en la CPU
– En la FEPROM integrada
Nota
Los botones se muestran siempre únicamente en el caso de que el módulo soporte la función
en cuestión.

Área de comandos del grupo "Memoria" de la carpeta "Diagnóstico" en la vista online y de diagnóstico
Esta área contiene los botones siguientes:
● Comprimir
Con este botón se reorganiza la memoria para aumentar el tamaño de la mayor área de
memoria coherente libre.

3698

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Inicialización de los parámetros de interfaz PROFINET de una CPU S7-300 o S7-400
Requisitos
● Se utiliza una CPU S7-300 de cualquier versión de firmware o una CPU S7-400 con versión
de firmware >= V6.0.
● No hay ninguna Memory Card insertada en la CPU.
● Existe una conexión online con la CPU cuyos parámetros de interfaz PROFINET deben
inicializarse.
● Dicha CPU está en estado operativo STOP.
Nota
Si la CPU todavía está en estado operativo RUN, se puede pasar a STOP tras responder
afirmativamente a una consulta de seguridad al iniciar el proceso de restablecimiento de la
configuración de fábrica.

Procedimiento
Para inicializar los parámetros de interfaz PROFINET de una CPU S7-300 o S7-400, proceda
del siguiente modo:
1. Abra la vista Online y diagnóstico de la CPU.
2. Seleccione en la carpeta "Funciones" el grupo "Restablecimiento de los parámetros de
interfaz PROFINET".
Nota
El aspecto de la interfaz de usuario del grupo "Restablecimiento de los parámetros de
interfaz PROFINET" de la vista Online y diagnóstico depende de cómo se ha abierto dicha
vista:
● Si la vista se abre desde el árbol de proyecto a través de "Actualizar dispositivos
accesibles", la dirección MAC del módulo correspondiente se conoce y en consecuencia
aparece atenuada.
● Si se abre la vista desde el contexto de proyecto, debe introducirse la correspondiente
dirección MAC. De lo contrario, el botón "Restablecer" aparece en color gris.
3. Haga clic en el botón "Resetear".
4. Responda la consulta de seguridad haciendo clic en "Aceptar".

Resultado
El módulo pasará al estado operativo STOP en caso necesario y se restablecerán los
parámetros de la interfaz PROFINET. Esto significa que:
● Se restablecerán las configuraciones de la interfaz Ethernet.
● La dirección IP se borrará.

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

3699

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Iniciar el cargador de firmware para un CP S7-300 o S7-400.
Requisitos
● El CP que se debe actualizar soporta actualización de firmware.
● No es necesario que haya conexión online con el CP.

Procedimiento
Para iniciar el cargador de firmware para un CP S7-300 o S7-400, proceda del siguiente modo:
1. Abra el CP en la vista Online y diagnóstico.
2. Elija el grupo "Actualización de firmware" de la carpeta "Funciones".
3. Haga clic en el botón "Iniciar cargador de firmware" del área "Actualización de firmware".

Resultado
Se inicia el cargador de firmware
Nota
La actualización del firmware de los CP S7-300 y S7-400 con el cargador de firmware difiere
de los mecanismos estándar de actualización de firmware.

Actualizar el firmware de un TIM 3V / TIM 4R
Validez
Las descripciones siguientes son válidas para los siguientes módulos TIM del SIMATIC
S7-300 / 400:
● ST7-TIM
– TIM 3V‑IE
– TIM 3V‑IE Advanced
– TIM 4R‑IE
– TIM 4R‑IE Standalone
● DNP3-TIM
– TIM 3V‑IE DNP3
– TIM 4R‑IE DNP3

3700

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Orden a seguir en la actualización
Para actualizar el firmware de estos módulos TIM se dispone de distintos archivos:
● Archivos de firmware
● Paquetes de drivers
Nota
Orden a seguir en la actualización
Tenga en cuenta el orden a seguir para actualizar el firmware.
1. Actualice primero los paquetes de drivers (*.Z).
2. Actualice solo entonces los archivos del firmware (*.FWL).
Si actualiza primero los archivos del firmware y selecciona accidentalmente un archivo
equivocado puede suceder que ya no pueda accederse al módulo TIM.

Archivos para la actualización del firmware
Los archivos para actualizar el firmware se ponen a disposición en forma de archivos
comprimidos. Estos archivos comprimidos contienen los archivos de los paquetes de drivers
y el firmware, así como los archivos Léame que contienen indicaciones sobre la versión del
firmware.
Para cada uno de los siguientes módulos TIM hay disponible un archivo comprimido.
● Fichero para ST7-TIM 3V..
– TIM 3V‑IE
– TIM 3V‑IE Advanced
● Fichero para ST7-TIM 4R..
– TIM 4R‑IE
– TIM 4R‑IE Standalone
● Fichero para TIM 3V‑IE DNP3
● Fichero para TIM 4R‑IE DNP3
Para guardar un archivo comprimido, haga lo siguiente:
1. Copie el archivo comprimido en el sistema de archivos de su estación de ingeniería.
Durante el proceso de actualización, indique el directorio en el cuadro de diálogo online.
Recomendación:
Copie los ficheros para las versiones de firmware de distintos tipos de módulos en distintos
directorios.
2. Copie el archivo comprimido en el sistema de archivos de su estación de ingeniería.

Consulte también
Conexiones online para diagnóstico especial y cargador de firmware (Página 3696)

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

3701

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Asignación de una dirección IP a un dispositivo PROFINET IO
Principios básicos para asignar una dirección IP a un dispositivo PROFINET IO
Resumen
Para seleccionar una dirección IP hay básicamente dos posibilidades:
● La dirección IP es asignada por el usuario.
● La dirección IP se obtiene de un servidor DHCP (no es posible con todos los dispositivos
IO). En este caso, dependiendo de la opción seleccionada, al servidor DHCP se le
transfiere el ID de cliente, la dirección MAC o el nombre del dispositivo IO.

Requisitos
Para los pasos siguientes se presupone que la dirección IP del dispositivo IO se puede obtener
también de un servidor DHCP. Así ocurre, p. ej., en algunos CPs S7-300.

Abrir la asignación de dirección mediante "Dispositivos accesibles"
Requisitos
● Los dispositivos a los que se accede por medio de la interfaz correspondiente de la PG/el
PC se muestran en el árbol del proyecto (esto se consigue haciendo doble clic en
"Actualizar dispositivos accesibles" dentro del árbol del proyecto o bien seleccionando el
comando "Dispositivos accesibles..." del menú "Online").
● La vista Online y diagnóstico se abre después de hacer doble clic en "Accesos online" ->
<interfaz seleccionada> -> <dispositivo PROFINET IO> -> "Online y diagnóstico".

Procedimiento para la asignación de la dirección IP por parte del usuario
Para asignar al dispositivo IO una dirección IP preseleccionada, proceda del siguiente modo:
1. Abra la vista Online y diagnóstico del dispositivo IO.
2. Elija el grupo "Asignar dirección IP" de la carpeta "Funciones".
3. Seleccione la opción "Utilizar parámetros IP".
4. Introduzca la dirección IP que desee.
5. Introduzca la máscara de subred.
6. Si hay que utilizar un router, active la casilla de verificación "Utilizar router" e introduzca su
dirección IP.
7. Haga clic en el botón "Asignar dirección IP".

3702

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Procedimiento para obtener la dirección IP desde un servidor DHCP
Para asignar al dispositivo IO una dirección IP preseleccionada de un servidor DHCP, proceda
del siguiente modo:
1. Abra la vista Online y diagnóstico del dispositivo IO.
2. Elija el grupo "Asignar dirección IP" de la carpeta "Funciones".
3. Seleccione la opción "Obtener la dirección IP de un servidor DHCP".
4. Si el servidor DHCP debe identificar el dispositivo de destino por su ID de cliente,
seleccione la opción "ID de cliente" Introduzca el ID de cliente en el cuadro de entrada
homónimo.
Nota
El ID de cliente es una secuencia de 63 caracteres como máximo. Solo se permiten los
caracteres siguientes: a-z, A-Z, 0 a 9 y - (guión)
5. Alternativa: Si el servidor DHCP debe identificar el dispositivo de destino por su dirección
MAC, seleccione la opción "Dirección MAC".
6. Alternativa: Si el servidor DHCP debe identificar el dispositivo de destino por su nombre,
seleccione la opción "Nombre de dispositivo".
Nota
Si se ha especificado que el servidor DHCP debe identificar el dispositivo de destino por su
nombre, previamente ha debido asignarse al mismo un nombre.
7. Haga clic en el botón "Asignar dirección IP".

Resultado
Al dispositivo IO se le asigna la dirección IP con carácter permanente. Dicha dirección se
conserva incluso después de un arranque o un fallo de tensión.

Abrir la asignación de dirección desde el contexto de proyecto
Requisitos
● Existe una conexión online con el dispositivo PROFINET IO.
● Se ha abierto la vista Online y diagnóstico del dispositivo PROFINET IO desde el contexto
de proyecto.

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

3703

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

Procedimiento
1. Abra el grupo "Asignar dirección IP" de la carpeta "Funciones". La opción "Utilizar
parámetros IP" está activada.
2. Haga clic en el botón "Dispositivos accesibles" para determinar los dispositivos accesibles
a través de direcciones MAC. Una vez efectuada la búsqueda, seleccione el dispositivo IO
con la dirección MAC que conozca.
3. Haga clic en el botón "Asignar dirección IP".

Resultado
Al dispositivo IO se le asigna la dirección IP con carácter permanente. Dicha dirección se
conserva incluso después de un arranque o un fallo de tensión.

2.6.2

Diagnosticar conexiones

2.6.2.1

Diagnosticar conexiones detalladamente

Determinar los detalles de conexión de una conexión NCM
¿Dónde se determinan los detalles de conexión de una conexión NCM?
Los detalles de conexión de una conexión NCM están indicados en el grupo "Detalles de
conexión". Este grupo se encuentra en el área "Diagnóstico > Información de conexión" de la
ventana de inspección.

¿Cuándo está ocupado el grupo "Detalles de conexión"?
Para que el grupo "Detalles de conexión" de la ficha "Información de conexión" esté ocupado,
deben cumplirse los siguientes requisitos:
● Existe una conexión online con el módulo en cuestión.
● Se ha seleccionado una línea en la tabla de conexión.

Estructura del grupo "Detalles de conexión" de una conexión NCM
En una conexión NCM, el grupo "Detalles de conexión" incluye los elementos siguientes:
● ID de conexión local (hex)
● Nombre de conexión
● Estado de la conexión
● Estado de envío
● Estado de transmisión

3704

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales
● Número de bytes enviados
● Número de bytes recibidos
● Botón "Diagnóstico especial"
El hacer clic en este botón se inicia el diagnóstico de conexión NCM.

Consulte también
Iniciar el diagnóstico de NCM S7 (Página 3695)

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

3705

Diagnosticar dispositivos y redes
2.6 Utilizar posibilidades de diagnóstico adicionales

3706

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético
*
*.cer, 476
*.dat, 476
*.p12, 476

:
:P, 1007, 1520

3
3964(R)
Recibir datos, 1736
Transferir datos, 1735

A
Abreviaturas para los idiomas, 1633
Abrir archivo de registro
Eventos de filtrado de paquetes, 473
Eventos de seguridad, 472
Eventos de sistema, 471
Abrir Siemens Industry Online Support, 35
Acceder a las preguntas frecuentes sobre un
módulo, 35
Acceder a los manuales de un módulo, 35
Acceso
~ directo a la periferia, 899
Acceso a la web, 1464, 1465
Acceso directo a la periferia, 899, 1007, 1520
Acceso libre Layer 2, 298
Access Point
Canales superpuestos, 2625
Sinopsis, 2621
Acelerar el arranque (PROFINET), 3228
ACL, 2441
Acoplador DP/DP, 3005, 3087
Acoplador PN/PN
Acoplar subredes Ethernet, 3331
Agrupar, 3331
Acoplamiento de racks, 1257, 1258
Acoplamiento punto a punto, 1703
Acoplamiento punto a punto ((3964(R), CPU
31xC), 887

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Acoplamiento punto a punto ((ASCII), CPU
31xC), 880
Acoplamiento punto a punto ((RK 512), CPU
31xC), 892
Acoplamiento punto a punto (CPs, ET 200S
1SI), 1756
ACT_TINT, 833
Activación y desactivación de dispositivos IO, 3224
Activar autonegotiation, 3157
Activar cortafuegos
SCALANCE S, 500, 502
Activar la comunicación tunelada
CP 343-1 Adv. / 443-1 Adv., 534
SCALANCE S, 500, 502
Actualización, 1577
Actualización automática, 1273
Actualización de firmware
desde el árbol del proyecto, 3640
desde el contexto del proyecto, 3640
Principios básicos, 3638
Actualización del firmware, 1024
desde el árbol del proyecto, 3640
desde el contexto del proyecto, 3640
Principios básicos, 3638
Acumuladores, 898
Adaptación del tiempo de ciclo de emisión, 3177
Administración de componentes, 3306
Administración de usuarios, 841, 3374
Servidor web, 1467
Administrador de certificados, 342, 1077
Administrador de certificados (global), 765
Administrador de certificados (local), 1078
Administrador del equilibrio de carga de red
(NLB), 1689
Advanced Encryption Algorithm, 747
AES, 747
AES-128, 436
Aging Time, 2445, 2449
Ajustar la carga de comunicación, 107
Ajuste de la hora, 612, 616, 2303, 2642, 2861
Ajustes de avisos, 1024
Ajustes de seguridad, 633, 1077, 2340, 2672, 2883
Funciones y derechos, 766
Ajustes IKE, 443
Ajustes IPSec, 444
Alarma
enviar en el I-Slave, 3034

3707

Índice alfabético

Alarma cíclica
Configuración, 834
OB 30 a OB 38 (S7-300, S7-400), 912
Alarma de actualización, 1577
Alarma de actualización (S7-1500), 1103
Alarma de enchufe/desenchufe (ET 200M), 3581
Alarma de estado, 1577
Alarma de estado (S7-1500), 1102
Alarma de proceso
Configuración, 831
ejemplo, 1019
Funcionamiento, 1527
I-Slave, 3066
OB 40 a OB 47 (S7-300, S7-400), 914
Alarma de proceso (S7-1500), 1108
Alarma de retardo
Configuración, 831
OB 20 a OB 23 (S7-300, S7-400), 910
Alarma de retardo (S7-1500), 1105
Alarma de sincronismo, 835
Alarma horaria, 832
Ajustar y activar, 1574
Anular, 1574
Consultar estado, 1574
Función, 1574
OB 10 a OB 17 (S7-300, S7-400), 907
Reglas, 1574
Alarma horaria (S7-1500), 1099
Alarmas
Alarma cíclica (S7-300, S7-400), 912
Alarma de cambio de módulo (S7-300,
S7-400), 933
Alarma de diagnóstico (S7-300, S7-400), 930
Alarma de proceso (S7-300, S7-400), 914
Alarma horaria (S7-300, S7-400), 907
Con direcciones comprimidas, 3030, 3109
OBs para DPV1, 3057
Retardo (S7-300, S7-400), 910
Algoritmo SHA, 634, 2341, 2673, 2883
Alimentación
vigilancia, 654
Alisamiento, 3505
Ampliación del ET 200SP con módulos ET
200AL, 3523
Ampliación del ET 200SP, 3523
Analizador espectral, 2727
Ancho de banda (comunicación IRT), 3187
Aplicación web, 1471, 1608
Aplicaciones posibles del módulo de
comunicación, 1808
Árbol del proyecto
Agregar dispositivo, 42

3708

Archivo de exportación para OPC UA, 1340
Archivos de idioma
para visor de diagnóstico, 3385
Archivos GSD
Borrar, 3053, 3111
Borrar archivos GSD no utilizados, 3054, 3112,
3172
configurar dispositivos (PROFIBUS), 3055, 3113
Creación para I-Devices, 3258
Instalar, 3052, 3110
revisiones GSD (PROFIBUS), 3051, 3109
Archivos GSD (PROFINET), 3168
Borrar, 3171
Cambiar versión, 3173
Exportar, 3211
Instalar, 3170
Área de datos de la periferia
Acceso, 819
Datos de diagnóstico, 820
Datos de parámetros, 820
Datos de usuario, 819
Registros del módulo, 820
Área de datos del proceso
Dirección inicial de un módulo, 1520
Direccionamiento de la periferia, 822
Direccionamiento de módulos, 821, 1520
Área de direcciones
modificar, 1263, 1598
Área de memoria
Áreas de memoria remanentes, 1517
de las entradas y salidas, 898
Distribución, 805
Memoria de carga, 1514
Memoria de trabajo, 1515
PI y PQ, 899
Área de módulos no enchufados, 20
Área de operandos, 811, 1515
Mostrar, 3688
Área de transferencia, 3040, 3041, 3063, 3250
Áreas de memoria
Base de cálculo, 810
Memoria de carga, 806
Memoria de sistema, 806
Memoria de trabajo, 806
ARP, 528
Diagnóstico, 528
Tabla, 528
Arranque, 1004
Actividades de arranque,
Bloques de organización, 1572
Cancelación,
Comportamiento remanente,

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

Función,
Rearranque (en caliente),
Rearranque completo (en caliente),
Rearranque completo (en caliente) automático,
Rearranque completo (en caliente) automático sin
respaldo,
Rearranque completo (en caliente) manual,
Vista general, 798
Arranque de dispositivos IO, 3224
Arranque en frío, 791
Arranque en frío (S7-300, S7-400), 954
Arranque preferente (PROFINET), 3228
Arranque priorizado, 3115, 3224
Asignación de direcciones, 1261
Datos de usuario con DPV1, 3064
Asignación de direcciones (información de
calidad), 1010
Asignación de recursos de conexión, 197, 199
Asignación de TSAP
Ejemplos, 146
Asignación online (nombres de dispositivo
PROFINET), 3129
Asignar derechos de acceso específicos de
elementos OPC, 1671, 1680
Asignar dirección IP
desde el contexto del proyecto, 3642, 3704
mediante "Dispositivos accesibles", 3641, 3702
Principios básicos, 3641, 3702
Asignar la vía de conexión, 231
Asignar símbolo, 1276, 1600
Asignar variable, 1276, 1600
AS-Interface, 3115
Ataque, 1074, 1563
Ataque "man in the middle", 749
Ataque Brute Force, 1074, 1563
ATTACH, 1527
Aumentar/reducir vista, (Véase Zoom)
Autenticación, 635, 2342, 2535, 2674, 2884
Autonegotiation, 3158
Aviso de grupo, 1074, 1563
Avisos
Registrarse para ello en la CPU, 3697
Avisos de CPU - Servidor OPC, 1691
AWP_In_Variable, 1616
AWP_Out_Variable, 1479, 1615

B
Backup, 676, 2382, 2926
BA-Send, 3523
BA-Send 1xFC, 3523
BCC, 1734

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Bit de datos (DBX), 1515
Bit de datos locales (L), 1515
Bit de marca (M), 1515
Bloque de datos, 1006
Bloque de datos 196, 3510, 3569, 3591
Bloque de datos 197, 3510, 3569, 3591
Bloque de organización, 1273
Bloque de organización (OB)
Mostrar, 3688
OB de alarma de actualización (OB 56) (S7-300,
S7-400), 918
OB de alarma de diagnóstico (OB 82) (S7-300,
S7-400), 930
OB de alarma de estado (OB 55) (S7-300,
S7-400), 916
OB de alarma de proceso (de OB 40 a OB 47)
(S7-300, S7-400), 914
OB de alarma de sincronismo (de OB 61 a OB 64)
(S7-300, S7-400), 923
OB de alarmas específicas del fabricante (OB 57)
(S7-300, S7-400), 921
OB de arranque en frío (OB 102) (S7-300,
S7-400), 954
OB de cambio de módulo (OB83) (S7-300,
S7-400), 933
OB de error de acceso a la periferia (OB 122)
(S7-300, S7-400), 963
OB de error de comunicación (OB 87) (S7-300,
S7-400), 950
OB de error de ejecución del programa (OB 85)
(S7-300, S7-400), 939
OB de error de fuente de alimentación (OB 81)
(S7-300, S7-400), 927
OB de error de hardware en CPU (OB 84)
(S7-300, S7-400), 937
OB de error de programación (OB 121) (S7-300,
S7-400), 960
OB de error de tiempo (OB 80) (S7-300,
S7-400), 924
OB de fallo del rack (OB 86) (S7-300,
S7-400), 943
OB de interrupción del procesamiento (OB 88)
(S7-300, S7-400), 951
OB de rearranque (OB 101) (S7-300,
S7-400), 954
OB de rearranque completo (en caliente) (OB 100)
(S7-300, S7-400), 954
OB de tarea no prioritaria (OB 90) (S7-300,
S7-400), 953
OBs de alarma cíclica (de OB 30 a OB 38)
(S7-300, S7-400), 912

3709

Índice alfabético

OBs de alarma de retardo (de OB 20 a OB 23)
(S7-300, S7-400), 910
OBs de alarma horaria (de OB 10 a OB 17)
(S7-300, S7-400), 907
Programa cíclico (OB1) (S7-300, S7-400), 906
Vista general de todos los OB, 903
Bloque de organización ProDiag, 1122
Bloque de sistema
Mostrar, 3688
Bloque lógico, 1000
Bloques de datos web, 1492, 1624, 1625
Bloques específicos, 1157
Bootstrap Router, 2237
Borrado total, 801, 994, 1004, 1511
ejecutar, 3633
Borrado total de la CPU, 801
Borrar
Componente de hardware, 61
Boundaries, 3160
Bridge, 603, 690, 2851, 2949
Bridge Priority, 603, 690, 2851, 2949
Root Bridge, 603, 690, 2851, 2949
Bridge Max Age, 603, 2851
Bridge Max Hop Count, 604, 2852
Bridge Priority, 2591
Broadcast, 253, 299, 404, 412, 1739, 1817, 2450
Con UDP, 286
Brute Force, 1074, 1563
BSR Border, 2237
Búfer de diagnóstico, 1073, 1458, 1563
Organización, 817, 3652
Principios básicos, 817, 1519, 3652
Búfer de peticiones, 298, 299, 300
Búfer de recepción, 1731, 1776, 1815
Búsqueda
Catálogo de hardware, 32
Byte de datos (DBB), 1515
Byte de datos locales (LB), 1515
Byte de entrada (IB), 1515
Byte de marca (MB), 1515
Byte de salida (QB), 1515

C
Cable multimaestro RS232/PPI, 1551
Cables de conexión, 1710, 1714, 1717
Calibración, 3647
Resumen, 3647
Cambiador de herramientas, (Véase Docking Station)
Cambiar el estado operativo, 3632
Cambiar nombre, 60
Cambio de DPV0 a DPV1, 3059

3710

Cambio de idioma, 1500, 1501, 1634
Campo de aplicación, 3330
Canal de referencia, 3531
Canal de referencia del módulo, 3576
Cancelación del proceso de calibración, 3649
Capa 2, 361
Capa 3, 361
Capacidad de memoria, 810
Capacidad de memoria flexible, 810
Capacidad de relectura de parámetros de
conexión, 142
Capacidades del búfer de recepción, 1702
Carácter de comprobación de bloque, 1782
Carácter de control de bloque, 1734
Carácter de fin, 1806
Carácter de inicio, 1727
Caracteres de control, 1782
en textos de aviso, 1802
Caracteres especiales
en variables para servidor web, 1478, 1614
Carga de ciclo, 1037, 1539
Carga de ciclo por comunicación, 828
Carga de comunicación, 1539
Carga de firmware en CPs PROFIBUS S7-300/400 a
través del CP 5612 / CP 5622, 1659
Carga de la memoria, 1001
Carga por comunicación, 1024, 1037, 1531
Cargador de firmware ‑ GUI en chino, 3696
Cargar
Aplicaciones isócronas, 3334, 3340
Conexión online, 3346
Configuraciones con PROFIBUS, 3340
Configuraciones con PROFINET, 3341
Configuraciones con servidor web, 3339
Configuraciones de dispositivos, 3337
Dispositivo proxy, 3340, 3343
Dispositivos HMI, 3345
en dispositivo, 3334
en PG/PC, 3335
Esclavo I, 3340
GSDML, 3342
I-device, 3343
IE/PB-Link, 3344
Periferia descentralizada, 3338
Shared Devices, 3345
Subredes, 3338
Catálogo, (véase Catálogo de hardware)
Catálogo de hardware
Acoplador DP/DP, 3005, 3087
Agregar dispositivo, 42
Esclavo DP, 3004, 3086
Esclavo I, 3004, 3087

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

examinar, 32
Selección de los componentes HW, 44
Selección de módulos centrales, 1252
Selección de módulos de seguridad, 46, 1254
Task Card, 30
CD, (Véase Comunicación directa)
CER, 768
Certificado, 342, 442
Asignar, 347
Exportar, 342
firmado por el usuario, 348
firmado por una entidad emisora, 348
Importar, 342
reemplazar, 349
renovar, 348
sustituir, 349
Certificado CA, 344, 347, 349, 579, 2821
Certificado de dispositivo, 579, 2821
Certificado de entidad final, 752
Certificado de grupo CA, 349
Certificado de servidor, 579, 1355, 2821
Certificado raíz, 752
Certificados
asignar, 1082
Autofirmados, 1080
borrar (global), 772
borrar (local), 1084
Crear, 1080
exportar (global), 768
exportar (local), 1083
Importar, 767
mostrar, 771
para el servidor web, 1084
para servidor OPC UA, 1085
reemplazar, 771
renovar, 770
Certificados autofirmados, 750, 1080
Certificados de dispositivo, 1079
Certificados digitales, 749
Certificate Authority, 344
Certificates, 719, 2978
Ciclo de aplicación, 3197
Ciclo de datos, 1094
Ciclo de procesamiento, 3069
Ciclo DP
Tiempo para ciclo DP equidistante, 3068
Ciclos de bus, 3067
Ciclos de procesamiento sincronizados, 3069
Cierre de sesión
automático, 647, 2684, 2897
Cifrado asimétrico, 747
Cifrado simétrico, 747

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Clase de evento, 965
Clase de evento 1 - Eventos de OB estándar, 966
Clase de evento 2 - Eventos de error síncronos, 966
Clase de evento 3 - Eventos de error
asíncronos, 967
Clase de evento 4 - Eventos de parada y otras
transiciones de estado operativo, 970
Clase de evento 5 - Eventos de procesamiento de
estado operativo, 974
Clase de evento 6 – Eventos de comunicación, 975
Clase de evento 8 - Eventos de diagnóstico para
módulos, 976
Clase de evento 9 - Eventos de usuario
estándar, 978
Clase de prioridad, 909, 970
Clase de visualización de mensajes, 1471
Clase RT, 3114
Clase RT PROFINET, 3114
Clases de evento A y B - Eventos libres de
usuario, 980
Clases de evento reservadas, 980
Class of Service, 2387
Client Supplicant, 2770
Cliente
Sinopsis, 2627
Cliente DNS, 2309
Cliente OPC UA
Autenticación, 1447
Certificado, 1445
Principios básicos, 1305
Cliente OPC UA, 1688
Cliente SMTP, 2326, 2664
Cliente Syslog, 649, 2356, 2685, 2898
Clipping, 3545
Coeficiente de temperatura, 3504, 3574
Coherencia
Reglas para slots, 49
Coherencia de datos, 208
Color
Diagnóstico de cables Ethernet, 3610
Diagnóstico de puertos, 3610
Comando AWP, 1475, 1478, 1612, 1613
Comando de control SYNC/FREEZE, 3019
Comandos de teclado, 38
Comparación de dispositivos, 71
Comparación offline/online avanzada
Asignación automática de dispositivos, 333
Comparar offline/online
Asignación automática de dispositivos, 330
Compatibilidad
Versiones de firmware de CPU S7-1200, 1595
Compatibilidad hardware, 1024

3711

Índice alfabético

Compatibilidad hardware soportada, 1024
Compensación de temperatura, 3491, 3534
Comportamiento cíclico, 827
Comportamiento de arranque, 1884
Comportamiento de remanencia tras un corte de la
alimentación, 794
Comportamiento de sobrecarga, 1018
Comportamiento operativo
Configuración estándar, 823
Configurar y cargar parámetros, 823
Parámetros del módulo, 823
Uso de marcas de ciclo, 1064, 1557
Uso de marcas de sistema, 1063, 1556
Utilizar funciones de reloj, 837, 1061, 1540
Utilizar marcas de ciclo, 839
Utilizar temporizadores y contadores, 819
Comportamiento remanente, 829
Compresión de direcciones, 3023, 3102
comprimidas
Alarma con direcciones, 3109
Comprimir
Memoria en la vista online y de diagnóstico, 3698
Comunicación, 1073, 1562
Carga de ciclo, 1037, 1539
Número de conexiones (PROFINET/
PROFIBUS), 188
Open User Communication, 230
Recursos de conexión, 842
Comunicación a través de la instrucción PUT/GET
Borrar conexión, 176
Crear y parametrizar la conexión, 175
Iniciar la parametrización de la conexión, 174
Principios básicos de la instrucción PUT/
GET, 170
Requisitos, 171
Resumen de la parametrización de la
conexión, 171
Comunicación directa, (Véase Comunicación directa)
Configurar, 3046
Crear, 3045
Esclavo DP - esclavo I, 3007, 3009
Esclavo DP - maestro DP, 3007
Funcionamiento, 3043
PROFIBUS, 3044
Comunicación E/S, 3129
Comunicación Isochronous Real-Time (IRT), 3115
Comunicación Modbus, 1738
Comunicación punto a punto (PtP), 1547
Protocolo Freeport, 1547
Comunicación S7, 196
Comunicación USS, 1744

3712

Comunicar errores del sistema, (Véase Report
System Errors)
Concepto de protección, 1066, 1073, 1076, 1559,
1562
Conectar dispositivos en red
Conectar varias interfaces en red al mismo
tiempo, 75
Conexión en red en caso de existir una
subred, 77
Conexión en red en caso de no existir ninguna
subred, 75
Editar direcciones de interfaz, 81
Editar parámetros de interfaz, 80
Editar parámetros de red, 80
Principios básicos de la configuración de redes
S7, 73
Redes dentro de un proyecto, 74
Requisitos, 80
Tipos de comunicación, 73
Conectar en red en la vista de dispositivos
Posibilidades de la conexión en red, 78
Procedimiento, 79
Conexión, 148, 158, 232
borrar, 121
Con una estación concreta de un proyecto
cualquiera, 227
Configurar, 211
Configurar cuando falta la asignación de red o
ésta no es unívoca, 163, 239
Configurar cuando falta la interconexión, 243
Correo electrónico, 211, 215, 217, 219
Crear, 117, 231
Detalles de dirección, 3665
FDL, 211, 215, 217, 219
Influencia de la interconexión: comportamiento
cuando falta la conexión en red, 233
ISO-on-TCP, 211, 215, 217, 219
ISO-Transport, 211, 215, 217, 219
No especificada, 232
Programada, 229, 230
Sin especificación del puerto, 228
TCP, 211, 215, 217, 219
UDP, 211, 215, 217, 219
Ver ocupadas y reservadas, 3691
Conexión de comunicación, 211
Conexión de correo electrónico
Configurar, 304
Conexión de correo electrónico ‑ Configuración
DNS, 3369
Conexión FDL
Acceso libre Layer 2, 298
Con Broadcast, 299

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

Con Multicast, 300
No especificada, 298
Conexión HMI, 148, 1073, 1562
Conexión NCM
Detalles de conexión, 3704
Conexión no especificada
Características, 254
Configuración gráfica, 251
Configurar a través de cuadros de diálogo, 252
Conexión S7, 158
TSAP, 169, 261
Conexión UDP/Conexión FDL
No especificada, 253
Conexión VPN
Estado, 600, 2848
Estado cliente OpenVPN, 602, 2850
Conexiones
Configuración gráfica, 236
Número de conexiones (PROFINET/
PROFIBUS), 188
Conexiones no especificadas
En Industrial Ethernet, 227
En PROFIBUS, 227
Configuración, 3552
Cargar en dispositivo, 3334
Cargar en PG/PC, 3335
Esclavo DP, 3003, 3016, 3096
Esclavo DP, sencillo, 3005, 3087
Esclavo I, 3008
Hardware, 40
Módulos centrales, 1240
Periferia descentralizada, 3002
PPP, 683
Variable HART, 3487
Configuración de conexiones, 211
Gráfica, 231
Mediante cuadros de diálogo, 231
Configuración de conexiones con el servidor
OPC, 226
Configuración de fábrica
restablecer, 3636
Configuración de hardware
Agregar dispositivo, 41
Agregar módulo, 49
Configuración de línea PROFIBUS
Anillo óptico, 106
Configuración de puerto, 654, 2364, 2699
Configuración de submódulo, 1010
Configuración FTP, 3378
Tabla de asignación File, 3378

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Configuración futura, 3025, 3028, 3104, 3107,
(Véase Control de configuración (ET 200MP)),
(Véase Control de configuración (ET 200SP))
Configuración futura (ver Control de
configuración), 1278, 1638, 3515, 3558, 3591
Configuración futura para redes, (Ver Control de
configuración de sistemas IO)
Configuración hardware, 1000
Resumen de los ajustes, 11
Configuración LDB, 1662
Configuración LSAP, 1660
Configuración máxima de una S7-1500, 1245
Configuración OPC, 1661
Configuración XDB, 1668
Configurar
Comunicación directa, 3046
CP como esclavo I, 3037
CPU como esclavo I, 3038
Direcciones de diagnóstico en el I-device, 3209
Direcciones de diagnóstico en el I-Slave, 3034
Esclavo DP como esclavo I, 3039
Esclavo I, 3032, 3099
Configurar conexiones
Mediante cuadros de diálogo, 240
Configurar la red vía Ethernet, 83
Ajustar la dirección IP, 83
Ajustar la máscara de subred, 83
Conectar redes, 85
Crear subredes privadas, 84
Relación entre la dirección IP y la máscara de
subred, 84
Configurar manualmente nodos de red IP, 519
Configurar manualmente nodos de red MAC, 520
Configurar manualmente subredes internas, 520,
557
Configurar una subred PROFIBUS
Ajustar parámetros de bus, 101
Significado de los parámetros de bus, 102
Sintonizar parámetros entre sí, 101
Configuration Mode, 613
conjuntos de reglas IP, 363
conjuntos de reglas MAC, 363
Constante de usuario, 1275
Contador de horas de funcionamiento, 839
Ver información, 3693
Contador descendente de 32 bits, 3495
Contador rápido
Configurar, 1544
Funcionamiento, 1542
Generalidades, 1541
Contador, rápido, 1541
Contaje (8 DI NAMUR), 3493

3713

Índice alfabético

Contaje (CPU 31xC), 846
Contraseña, 1076
Opciones, 2532, 2753
para protección de acceso de la CPU, 1024,
1531
Recomendaciones para asignar
contraseñas, 1468
Control de acceso, 2441
Aprendizaje automático, 2441
Control de configuración, 1267, 1278, 1638, 3271,
3510, 3515, 3558, 3569, 3591
Control de configuración con ET 200AL, 3558
Control de configuración con ET 200pro, 3591
Control de configuración con ET 200SP, 3510
Control de configuración con ET 200MP, 3569
Control de configuración de sistemas IO, 3271, 3282,
3296
Control de configuración para sistemas IO, 1292
Control de la configuración, 1288, 1647
Control del flujo de datos, 1549, 1702, 1710, 1718
Hardware, 1719
Software, 1719
Control del flujo de datos de hardware, 1719
Control del flujo de datos de software, 1719
Control del flujo de datos por hardware, 1549
Control del flujo de datos por software, 1550
Control interface, 1215
Controlador IO
Dispositivos y módulos, 3139
Interfaz PN, 3139
Visualización en el dispositivo IO, 3140
Convertidor de medios, 3148
Cookie, 1483, 1617
Coordenadas geográficas, 619, 2306, 2645, 2865
Copiar
Componente de hardware, 56
Correo electrónico
Enviar, 306
Cortafuegos, 1462
Administrar grupos de servicios, 389, 393
Crear grupos de servicios, 389, 392
Definir servicios ICMP, 387
Reglas de cortafuegos, 362
Cortocircuito a L+, 3530
Cortocircuito a masa, 3529
CoS, 2387
Cola de espera, 2387
CoS (Class of Service), 568, 2202, 2574, 2805
CP
Acoplamiento punto a punto, 1756
Como esclavo I, 3037
con una dirección MPI propia, 1261

3714

CP PC, 333
CP S7, 333
C-PLUG, 657, 2691, 2901
formatear, 658, 2371, 2693, 2903
guardar configuración, 658, 2693, 2903
CPU
Cambiar el estado operativo, 3632
Como esclavo I, 3038
Conexiones ocupadas y reservadas, 3691
Insertar Signal Board, 1602
Leer el búfer de diagnóstico, 3627
Mostrar estado actual de los LEDs, 3621
Nivel de llenado de todos los tipos de
memoria, 3622, 3623
Número de conexiones de comunicación, 188
Parámetros, 824
Propiedades, 1530
Recursos de conexión no ocupados, 3691
Registrarse para acceder a avisos, 3697
Selección del catálogo de hardware, 44
CPU 1516-3 PN/DP, 1048
CPU 1518-4 PN/DP, 1048
CPU F, 46
CPU S7
Área de operandos, 811, 1515
Áreas de memoria, 805
Memoria de carga, 1514
Memoria de trabajo, 1515
CPU sin especificar, 43
CPUs S7-400
Tipos de memoria, 808
CRC, 1740, 1818
Crear
Comunicación directa, 3045
Crear una ruta, 510
Criterio de fin, 1771
carácter de fin, 1772
longitud fija de telegrama, 1774
Tiempo de retardo de caracteres
transcurrido, 1771
CRL, 768
CRT, 768
CTS, 1711
Cuadro de diálogo ", 1665
Cuadro de diálogo "Configuración del equipo de
destino", 1665
Cyclic interrupt, 1580
Cyclic interrupt (S7-1500), 1107

D
D_ACT_DP, 1267

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

D_ACT_DP (activación y desactivación de
dispositivos IO), 3224
Data Log, 1607
Datos de diagnóstico, 820
Datos de parámetros, 820
Datos de rendimiento, 3689
Datos de servicio
Guardar, 3631
Datos de usuario, 819
Área, 1007, 1520
Direcciones, 3063
Slots, 3063
Datos estadísticos, 3692
Datos I&M
Cargar en dispositivos PROFINET IO, 3650
Datos útiles
Área, 822
DB de Web Control, 1494, 1627
DB E-Mail, 307
DCD, 1711
Dead Peer Detection, 583, 2825
Dead-Peer-Detection (DPD), 459
Declaración de disponibilidad para la comunicación
- establecimiento de conexión pasivo, 227
Dependencias de derechos, 355
DER, 768
Derechos de usuario, 3374
DES, 436
Descarga, (Véase Carga en dispositivo)
Descarga de firmware vía web, 3385
Descripción de la conexión
Bloque de datos, 124, 127, 129, 131, 133, 134
Estructura, 124, 128, 130, 132, 133, 135
Modificar valores de parámetros, 142
Desfase (S7-1500), 1107
Deshacer la conexión online, 3656
Designated Forwarder, 2237
Designated Router, 2236
Desplazar
Componentes de hardware, 58
Desplazar la imagen
Comandos de teclado, 39
Navegación general, 13, 16, 23
Detalles de conexión, 3664
Detalles sobre el establecimiento de la conexión, 264,
270, 277
Detección de fin de un telegrama de
recepción, 1806
Detección de hardware, 44
Detección de topología, 3160
Determinar automáticamente la vía de
conexión, 237

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Determinar el estado de diagnóstico, 3624
Determinar la hora, 3634
Device replacement, 1191
Device Tool, 3332, 3333
DHCP
Client, 665, 2915
Cliente, 2327, 2665
Configuración de servidores, 514
DHCPv6
Cliente, 2337
Delegación de prefijo, 2337, 2338
Subcliente PD, 2338
DHCPv6 Relay Agent
Ajustes generales, 2508
Diagnostic error interrupt, 1584
Diagnostic error interrupt (S7-1500), 1114
Diagnóstico, 463, 1755, 1885, 3504
Componentes de PROFINET IO, 3626, 3695
Esclavo I, 3041
Específico de canal, 3693
PROFINET, 3182
Diagnóstico de canal, 3694
Diagnóstico de comunicación, 3625, 3694
Diagnóstico de conexiones
Detalladamente, 3662
Sinopsis, 3660
Diagnóstico de hardware, 3601
Diagnóstico de segmento
Iconos, 3658
Visualización gráfica, 3659
Visualización mediante texto, 3659
Diagnóstico del I-Device, 3217
Diagnóstico del puerto
Diagnóstico SFP, 661, 2381
Diagnóstico del sistema
Bloques creados, 3673
DB de estado de diagnóstico, 3676
Introducción, 3670, 3682
Diagnóstico especial, 3696
Diagnóstico especial ‑ GUI en chino, 3696
Diagnóstico específico de canal, 3693
Diagnóstico online, 466
Diagnóstico SFP, 661, 2381
Diagnóstico web, 3385
Dirección, (Véase Dirección inicial de un módulo)
Dirección de canal, (Véase Dirección inicial de un
módulo)
Dirección de diagnóstico, 1261, 1263
Asignar, 3057
Configurar, 3034, 3209
Esclavo I, 3032
I-device, 3207

3715

Índice alfabético

Dirección de dispositivo, 1261, 1262, 1597
Dirección de periferia, 1007, 1261, 1262, 1520, 1597
Dirección de subred IP, 1048
Dirección I, 1262, 1597
Dirección inicial, 1008, 1261, 1262, 1520, 1597
Dirección inicial de módulo, (Véase Dirección inicial
de un módulo)
Dirección inicial de un módulo, 1008
Dirección IP, 83, 85, 3119, (Véase Display)
Configuración, 698, 2956
Dirección IP del router, 510
Dirección IP WAN
Definir, 460
Dirección Q, 1262, 1597
Direccionamiento, 1007, 1520
general, 1261, 1262, 1597
modificar, 1263, 1598
Direccionamiento de la periferia, 822
Direccionamiento de módulos, 821, 1520
Direccionamiento IP a través de DHCP, 228
Direcciones, 3444
Alarma con direcciones, 3030
Alarmas en el esclavo I, 3035
asignar, 1276, 1600
Comprimir, 3023, 3102
Datos de usuario con DPV1, 3063
Descomprimir, 3024, 3103
Esclavo DP, 3065
Informaciones de sistema, 3065
Interfaces DP, 3063
Direcciones IP
PROFINET, 3174
Direcciones IPv4, 403
Direcciones IPv6, 404
DIRECT_OPERATE, 2008
Discriminador, 841
Diseño de página
en textos de aviso, 1802
Display, 1035
Display (CPU), 1076
Display de la CPU, (Véase Display)
Disposición de los módulos, 49
Dispositivo
Agregar a una configuración de hardware, 41
borrar, 61
cambiar nombre, 329
copiar, 56
desplazar, 58
Dispositivos defectuosos, 3602
Selección múltiple, 53
Dispositivo de campo, 3055, 3113, 3170, 3171,
3211

3716

Dispositivo IO
Conectar en red, 3145
Tiempo de actualización, 3149
Tiempo de supervisión de respuesta, 3151
Visualización del controlador IO, 3140
Dispositivo IO inteligente, 3203
Dispositivo IO opcional, 3285
Dispositivo normalizado, 3168
Dispositivo online, 3602
Dispositivo PROFINET IO
Asignación de nombre en el cuadro de
diálogo, 3646
Asignación de nombre en la vista Online y
diagnóstico, 3644, 3645
Asignar nombre, 3643
Dispositivo proxy, 3340, 3343
Dispositivo S1 conmutado, 1145
Dispositivos accesibles, 3160
Dispositivos defectuosos, 3602
Distributed I/O, 3523
DLE, 1734
DM 370 Dummy, 1241
Docking Station, 3226
Docking System, 3226
Docking Unit, 3224, 3226
Dominio DNS, 2309
Dominio MRP, 3241, 3619
Dominio predeterminado, 3186
Dominio Sync, 3160, 3186, 3187, 3618
DPRD_DAT, 1267
DPSYC_FR, 1267
DPV0/DPV1, 3055
DPV1, 835
Configurar ET 200S, 3029, 3108
Evaluación de informaciones de alarma, 3060
Evaluación de informaciones de
diagnóstico, 3061
Modelo de slot, 3063
OBs para alarmas, 3057
DPWR_DAT, 1267
Driver ASCII, 1768
Búfer de recepción, 1776
Enviar datos, 1769
Recibir datos, 1770, 1805
Señales cualificadoras RS232C, 1777, 1802
Driver de impresora
Salida del texto de aviso, 1804
Textos de aviso, 1802
Drivers de impresora
Cadena de formato, 1803
Ejemplos, 1803
Handshake de software, 1804

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

Procedimiento Handshake, 1804
Señal BUSY, 1805
Variables, 1802
DSCP, 2388
DSL
Sinopsis, 2846
DSR, 1711
DST
Horario de verano, 638, 639, 2344, 2345, 2676,
2677, 2887, 2888
DTR, 1711
Duración de certificados, 440
Duración del período (CPU 31xC), 859

E
Editar conexión en red
Copiar subred, 82
Copiar subredes y dispositivos, 83
Editar conexiones en red
Eliminar conexión de red, 81
Editor de comparación
Comparación de dispositivos, 71
Editor de hardware
Catálogo de hardware, 30
Componentes, 10
Función, 9
Ventana de inspección, 24
Editor de hardware y redes
Vista de dispositivos, 15
Vista de redes, 12
Vista topológica, 22
Editor de redes
Catálogo de hardware, 30
Componentes, 10
Función, 9
Ventana de inspección, 24
Editor topológico, 85
Efecto de Ti
Modo isócrono, 3194
Efecto de To
Modo isócrono, 3195
Eje lineal (CPU 31xC), 870, 877
Eje rotativo (CPU 31xC), 870, 878
Ejecución cíclica del programa
Posibilidades de interrupción, 1572
Programar, 1572
Ejecución del programa, 1157
Cíclica, 1572
Ejemplo
Configuración ET 200AL, 3553
Especificar un valor sustitutivo, 964

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Encabezado de la petición, 298, 299, 300
Encabezado de telegrama
Estructura del telegrama de orden RK512, 1791
Encriptación, 335
Entidades emisoras, 749
Entidades emisoras de certificados de origen, 345
Entrada (I), 1515
Entrada de contador, 1543
Entrada de periferia, 1515
Entrada principal, 1749
Enumeraciones
Servidor web, 1487, 1621
Enviar datos
Driver ASCII, 1769, 1804
Procedimiento 3964(R), 1783
RK512, 1793
Equidistancia, 3069
Activación en la red PROFIBUS, 3078
Composición de los ciclos de bus, 3067
Definición, 3067
Requisitos, 3068
Tiempo para ciclo DP equidistante, 3068
Equilibrio de potencia, 3568
Error asíncrono
Configuración, 832
Error de acceso a periferia, 813, 1518
Error de acceso a periferia (PZF), 813
Error en canal de referencia, 3574
Errores síncronos
OB 121 (S7-300, S7-400), 960
OB 122 (S7-300, S7-400), 963
esclavo, 1812
Esclavo DP
Ajustar el modo isócrono, 3080
Asignar sistema maestro DP, 3016, 3095
Catálogo de hardware, 3004, 3086
Como esclavo I, 3039
Con preprocesamiento, (Véase Esclavo I)
Conectar en red, 3017, 3096
Configurar, 3003, 3005, 3016, 3087, 3096
Desconectar del sistema maestro DP, 3015,
3095
Direcciones, 3065
Grupos SYNC/FREEZE, 3019
Insertar en el sistema maestro DP, 3015, 3094
inteligente, (Véase Esclavo I)
Intercambio de datos, 3005, 3087
Reglas para slots, 3003, 3015, 3094
Tipos, 3014, 3094
Visualización del maestro DP, 3011, 3091
Esclavo DP inteligente, 3039, 3040, (Véase Esclavo I)
Esclavo DP normalizado, 3055, 3113

3717

Índice alfabético

Esclavo I, 3008, 3031, 3039, 3040, 3088, 3098
Acceso a datos, 3099
Catálogo de hardware, 3004, 3087
Comunicación directa, 3009
Configurar, 3008, 3032, 3099
Configurar CP, 3037
Configurar CPU, 3038
Configurar esclavo DP, 3039
Direcciones de diagnóstico, 3032
Dispositivo proxy, 3340
Dispositivos, 3004
enviar alarma con SALRM, 3034
Intercambio de datos, 3008, 3088
Maestro DP, 3008
Esclavo I (esclavo DP inteligente)
Diagnóstico, 3041
Respuesta a alarmas, 3041
Esclavo normalizado, 3055, 3113
Escribir variable, 1616
Establecer conexión online, 3654
Establecer una conexión online, 1048
Estación
borrar, 61
cambiar nombre, 329
copiar, 56
desplazar, 58
Selección múltiple, 53
Estación PC
Conexiones, 226
Configuración OPC, 1651, 1660, 1661
Configuración XDB, 1668
Insertar componentes, 1650
Insertar submódulos, 1650
Reglas para slots, 1649
Estaciones activas, 455
Estadísticas de Ethernet
Error de telegrama, 2269, 2270, 2612
Estadística de interfaz, 2267, 2609
Longitud de telegrama, 2268, 2610
Tipo de telegrama, 2269, 2611
Estadísticas WLAN
Error, 2632
Telegramas de datos enviados, 2636
Telegramas de datos recibidos, 2636
Estado, 1577
Módulo averiado, 3625
Estado de conexión
Ver mediante iconos, 3661
Estado de diagnóstico
determinar y visualizar online, 3603
Estado de error, 597, 2255, 2605, 2837
Estado de la conexión online, 3654

3718

Estado de LED, 3690
Estado operativo, 533
ARRANQUE, 989, 1507
Eventos de procesamiento, 974
Introducción, 987, 1505
PARADA, 800
Prioridad, 790
RUN, 800, 993, 1510
Sinopsis, 788
STOP, 790, 993, 994, 1511
Transiciones, 789, 970, 988, 1506
Estado operativo ARRANQUE, 1152
Estado operativo RUN, 1154
Estado operativo STOP, 1153
Estructura, 3508, 3568
Estructura de la trama, 1739
Estructura de llamadas, 1000, 1001
Estructura del telegrama, 1817
Estructuras
Servidor web, 1489, 1490
ET 200AL, 3486, 3515
ET 200eco, 3486
ET 200eco PN, 3486, 3502
ET 200iSP, 3484
ET 200L, 3484
ET 200M, 3082, 3484, 3581
Definición, 3580
Reglas para slots, 3003
ET 200MP, 3484, 3567
Modulación del ancho de impulso, 3579
ET 200pro, 3486
ET 200R, 3486
ET 200S, 3082, 3484
configuración futura, 3025, 3028, 3107
Modo DPV1, 3029, 3108
Reglas de slots, 3020, 3100
Uniones frías, 3021, 3100
ET 200S 1SI, 1756
ET 200S COMPACT, 3484
ET 200SP, 3484, 3508, 3515
Campo de aplicación, 3508
ET 200AL, 3523, 3555
Campo de aplicación, 3552
Ejemplo de configuración, 3553
ET 200SP, 3523
ET-Connection, 3523
Ethernet, 83, 85
Número de conexiones de comunicación, 188
ETX, 1734
Evaluar
Informaciones de alarma con DPV1, 3060
Informaciones de diagnóstico con DPV1, 3061

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

Evaluar informaciones de alarma con DPV1, 3060
Evento, 965
Evento de arranque de OB, 1016
Evento de diagnóstico
Para módulos, 976
Evento de error asíncrono
ID de evento, 967
Evento de seguridad, 1073, 1074, 1563
Eventos
Configuración, 2321
Filtro Severity, 2325, 2663
Tabla de registro, 593, 2253, 2602, 2833
Eventos de alarma, 628
Eventos de comunicación, 975
Eventos de error síncronos, 966
Eventos de OB estándar, 966
Eventos de parada, 970
Eventos de seguridad, 472
Eventos de sistema, 471
Eventos de usuario estándar, 978
eventos del sistema
Configuración, 625, 2660, 2874
Filtros de severidad, 628, 2878
Eventos e ID del evento, 965
Eventos libres de usuario, 980
Explorador de archivos, 1458
Exportar servidores NTP, 434
ExtendedKeyUsage, 1080

F
Facilidad, 410
Fallo de estación, (Error de rack)
Falta la tensión de alimentación, 3573
Falta tensión de alimentación, 3531
FAQ
Descargar el certificado, 1470
Página de usuario como página de inicio, 1477
Fast Start-Up (PROFINET IO), (véase Arranque
preferente)
Feedback interface, 1216
FETCH/WRITE, 1073, 1562
FETCH_RK, 1758
Ficha "Parámetros de puerto", 3367
Ficha "Propiedades OPC", 297
Ficha "Protección de acceso IP", 3370
File Browser, 1607
Filtrado, 3574
Filtro
Catálogo de hardware, 32
Filtro contextual, 32
Fin de la detección de topología, 3160

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Fin del dominio Sync, 3160
Fin del registro de dispositivos accesibles, 3160
Firma, 751
Firmware, 1595
Firmware Card, 1512
Firmware de la CPU, 1595
FM
con una dirección MPI propia, 1261
Formación de direcciones en el caso de las
direcciones comprimidas, 3024, 3103
Formato de archivo
CER, 768
CRL, 768
CRT, 768
DER, 768
P12, 768
PEM, 768
Forward Delay, 603, 2851
Fragmento, 1490, 1496, 1622, 1629
Fragmento manual, 1496, 1629
Frecuencímetro, 3499, 3502
Freeport, 1749
Búfer de recepción, 1731
Criterios de fin, 1728
Criterios de inicio, 1727
Fin del mensaje, 1726
Principio del mensaje, 1726
Transparencia del código, 1731
FREEZE, 3020
FTP, 351, 353, 1073, 1562
Fuente de alimentación del sistema, 3568
Función de contaje en cascada, 3495
Función de reloj, 839, 1062, 1063
Ajustar la hora, 837, 1061, 1541
Contador de horas de funcionamiento, 839
Formato de hora, 837, 1061, 1540
Leer la hora, 837, 1061, 1541
Parámetros del reloj, 838, 1541
Principios básicos, 837, 1061, 1540
Función E-Mail, 629, 2878
Eventos, 629, 2878
Eventos de alarma,
Vigilancia de la red, 628, 629, 2878
Funcionalidad
PROFIBUS DPV0/DPV1, 3056
Funcionamiento
Comunicación directa, 3043
Generación de alarmas en el I-Slave, 3035
Funcionamiento de los frecuencímetros, 3499
Funcionamiento si la configuración teórica difiere de
la real, 3021
Funciones, 713, 2528, 2756, 2972

3719

Índice alfabético

Funciones de aprendizaje, 456
Funciones de diagnóstico, 1755, 1885
Funciones de servidor OPC
Funciones de registro, 1662
para maestro DP clase 2, 1662
Funciones de sistema
Parámetros en el programa del usuario, 1256
Funciones de sistema disponibles, 561, 2185, 2550,
2555, 2560, 2797

Hora local, 1024, 1531
HSC, 1541
HTML5, 1504
HTTP, 387
Cargar/guardar, 2314, 2653, 2867
Servidor, 614, 2860
HTTPS, 500, 841, 1469, 1606
Servidor, 614, 2860
HW RTS siempre activado, 1722

G

I

Get_Features, 1705, 1749
GMRP, 2447
Grabadora de señales, 2722, 2843
Grupo de redundancia, 1688
Grupo VPN, 438
Grupos, 715, 2530, 2757, 2974
Grupos de servicios, 389, 392
Grupos de usuarios, 715, 2530, 2757, 2974
GSDML, (Ver archivos GSD (PROFINET))
Guardar textos de aviso, 1802

ICMP, 395, 566, 2810
Icono
de comparación, 3609
de diagnóstico de hardware, 3608
de diagnóstico de software, 3609
de estado operativo, 3610
Icono Overlay, 3610
Para el estado de comparación, 3662
Para el estado de conexión, 3662
Icono Overlay, 3610
ID de evento, 965
ID de la instalación, 824
ID de red, 510
ID de situación, 824
ID HW, (Véase ID de hardware)
véase ID de hardware, 1597
Identificación del fabricante, 592, 2251, 2600, 2832
Identificador de hardware, 1262, 1264, 1268, 1597,
3513, 3564, 3571, 3595, (Véase ID de hardware)
Identificadores de elementos y bloques, 901
I-Device, 3132
Direcciones de diagnóstico,
Dispositivo proxy,
Exportación como archivo GSD, 3258
Idioma (servidor web y display de la CPU), 1041
Idioma (servidor web), 1467
Idioma de la interfaz para el servidor web, 1041
Idioma para el servidor web, 1041, 1467
Idle Line, 1727
IE/AS-i Link PN IO, 3115
IE/PB Link, 3162
IEC V2.2, 1053
IEC V2.3, 1053
IEEE 802.11n, 2576, 2710
Agregación de tramas, 2578
Channel Bonding, 2578
Guard Interval, 2578
Maximum Ratio Combining, 2577
MIMO, 2577
Spatial Multiplexing, 2577

H
Handshake, 1550
Handshake de software, 1804
Handshake Protocol, 748
Hardware
Configurar y parametrizar, 40
Editar parámetros, 64
Editar propiedades, 64
Hardware interrupt, 1581
Hardware interrupt (S7-1500), 1108
HART, 3490
Hello Time, 603, 2851
Herramienta, (Véase Docking Unit)
Herramientas online, 3601, 3613
Hora, 1024, 1531
Ajustar la hora en la vista online y de
diagnóstico, 3634
Hora del sistema, 637, 2343, 2675, 2886
Precision Time Protocol, 2352
Sincronización, 3690
Sincronización horaria, 640, 2347, 2679, 2889
SNTP (Simple Network Time Protocol), 640, 2347,
2679, 2889
Hora del sistema
Cliente NTP, 642, 2349, 2681, 2892
Cliente PTP, 2352
Cliente SNTP, 640, 2347, 2679, 2890

3720

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

IEEE 802.3, 361
iFeatures
iREF, 2585
IGMP, 2445
IGMP Join, 2237
IGMP Querier, 2445
IIN1.6, 2011
Importar servidor NTP, 434
Imprimir
Imprimir vista de dispositivos, 35
Imprimir vista de redes, 35
Industrial Security, 1504
Información
Cliente OpenVPN, 602, 2850
DSL, 2846
Error de telegrama, 2269, 2270, 2612
Estadísticas de Ethernet, 2268, 2610
Función, 610, 2301, 2620, 2859
Grupos, 611, 2302, 2619, 2858
Hardware, 590, 2831
Inter AP Blocking, 2621
IPsec VPN, 600, 2848
LLDP, 598, 2275, 2839
Log Table, 596, 2836
Mobile, 2841
Registro de autenticación WLAN, 2604
Registro de evento, 593, 2253, 2602, 2833
Security Log, 595, 2835
Seguridad, 608, 610, 2299, 2301, 2617, 2619,
2856, 2858
SHDSL, 2844
SINEMA RC, 601, 2849
SNMP, 598, 2298, 2616, 2839
Software, 590, 2831
Spanning Tree, 604, 2256, 2606, 2852
Tabla ARP, 592, 2252, 2601, 2833
Tabla de vecindad IPv6, 2253, 2600
Tipo de telegrama, 2269, 2611
Versiones, 2599
Versions, 591, 2250, 2831
Información de arranque, 1096
Como en las CPU S7-300 y S7-400, 1096, 1097,
1098, 1102, 1103, 1104, 1106, 1107, 1109, 1111,
1113, 1114, 1115, 1117, 1118, 1121
Optimizado, 1096, 1097, 1098, 1102, 1103, 1104,
1106, 1107, 1109, 1111, 1113, 1114, 1115, 1117,
1118, 1121
Información de arranque del OB, 1096
Información de calidad, 1009, 1010, 3267
Información de conexión, 3663
Información del dispositivo, 3602
Información del programa, 1001

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Información relevante para la instalación
Datos del fabricante, 3685
Datos sobre el módulo, 3685
Información del fabricante, 3613
Información del módulo, 3613
Informaciones de diagnóstico
Evaluar con DPV1, 3061
Informaciones de sistema
Direcciones, 3065
Inicialización, 1884
Inicialización (páginas web definidas por el
usuario), 1473, 1610
Iniciar el cargador de firmware, 3700
Iniciar el diagnóstico de NCM S7, 3695
Iniciar la vista Online y diagnóstico, 3611
Iniciar la vista topológica, 317
Iniciar sesión, 1464
Iniciar sesión para el servidor web, 1604
Inicio de sesión en servidor web, 1604
Inserción y extracción de CPs PC Ethernet, 1651
Insertar componentes
Estación PC, 1650
Insertar submódulos
Estación PC, 1650
Insertar/extraer una tarjeta de red USB, 1651
Instrucción "WWW", 1493, 1626
Instrucciones Modbus, 1751
Instrucciones PtP, 1749
Instrucciones USS, 1753
Inter AP Blocking
Basic, 2783
Configurar, 2783
Direcciones permitidas, 2784
Información, 2621
Intercambio de datos
Esclavo DP, 3005, 3087
Esclavo I - maestro DP, 3008, 3088
Intercambio de datos unidireccional/
bidireccional, 1761, 1778
Interconectar, 85
Interconectar puertos
Vista de tabla, 327, 329
Vista gráfica, 326
Interconexión de puertos, 3148
Interconexión MRP, 2265
Principio de funcionamiento, 2226
Topología, 2226
Interfaces, 1701
Interfaces (PROFINET), 1048
Interfaz
cambiar nombre, 329
Mostrar, 3615, 3687

3721

Índice alfabético

X27 (RS 485), 1717
X27 (RS422), 1714
Interfaz DP, 3010, 3090, 3688
Cambiar, 3013
Direcciones, 3063
Interfaz GBIT (CPU 1518-4 PN/DP), 3157
Interfaz MPI, 3687
Interfaz MPI/DP, 3688
Interfaz PROFINET, 1024, 1048, 1531, 3132, 3616,
3688
Interfaz PROFINET Gigabit, 3157
Interfaz X27 (RS 485), 1717
Interfaz X27 (RS422), 1714
Interfaz X27 (RS422/485), 1811
Interlocutores alternantes (dispositivos IO que
cambian en funcionamiento), 3226
Interpolator OB, 1127
Interrupción de la conexión, 2006
Inversor, 3582
IO access error (S7-1500), 1121
IO-Link, 3333
IP Forwarding, 88
IP-ACL (lista IP Access Control), 3370
iPad, 1504
iPCF
Comunicación PROFINET, 2581
Configurar, 2637, 2638, 2785
Principio de funcionamiento, 2581
Restricción, 2583
iPCF-HT
Configurar, 2788
Principio de funcionamiento, 2581
iPCF-MC
Comunicación PROFINET, 2581
IPP, (Véase Memoria imagen parcial de proceso)
iPRP
Configurar, 2793
Información, 2640
IPsec VPN
NETMAP, 578, 2818
Source NAT, 578, 2818
IPv4
OSPf, 2230
VRRP, 2229
VRRPv3, 2229
IPv6
Cliente FTP, 3600
E-mail, 3600
FETCH/WRITE, 3600
Notación, 2198, 2571, 3599
OSPFv3, 2234
Servidor FTP, 3600

3722

SNMP, 3600
Uso en el CP 1543-1, 3600
VRRPv3, 2229
IQ-Sense, 3584
iREF, 2585
Configurar, 2795
IRT, 3187
Recomendaciones para la instalación, 3165
IRT (Isochronous Realtime), 3182, 3186, 3191
ISAKMP, 460
I-Slave
Activar alarma de proceso, 3066
Modelo de slot de los esclavos DP, 3063
ISO-on-TCP
Características, 123
TSAP, 144

J
jQuery, 1504
Juego de caracteres
en textos de aviso, 1802
Juego de datos de control, 1278, 1638, 3515, 3558,
3591
S7-1500, 1290
Juego de datos de control 196, 3510, 3515, 3569,
3591
Juego de datos de relectura, 3591, (véase juego de
datos de respuesta)
Juego de datos de relectura 197, 3510, 3569, 3591
Juego de datos de respuesta, 3515, 3558

K
KEY-PLUG, 2369, 2372
formatear, 658, 2371, 2693, 2903
iFeatures, 659, 2694, 2904
KeyUsage, 1080

L
LACP, 2433
Layer 2, 684, 2943
MLD (IPv6), 2449
Layer 3, 2372
Layer 3 (IPv6), 2501
Configuración, 2501
Lectura de datos de servicio, 1463
Lectura de recorrido (CPU 31xC), 865, 873
Leer el búfer de diagnóstico, 3627
Leer variable, 1479, 1615

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

Leer variables de PLC
Variables del tipo String y Character, 1480
Variables String o Character en
expresiones, 1481
Line Break, 1727
Link Check, 2265
Link Check Status, 2265
Link Layer Discovery Protocol (LLDP), 1053
Lista de control de acceso IP, 351
LLDP, 351, 353, 598, 2275, 2839, 3160
LLDP (Link Layer Discovery Protocol), 3160
LLDP (ver Link Layer Discovery Protocol), 1053
LLDP conforme a IEEE, 1053
Log Table
Firewall Log, 596, 2836
Security Log, 595, 2835
Longitud del mensaje en el mensaje, 1728
Longitud fija de la trama, 1728
LookAhead OB, 1130

M
Machine Tailoring, (Ver Control de configuración de
sistemas IO)
Ver Control de configuración de sistemas
IO, 3282
maestro, 1812
Maestro DP, 3489
Agregar sistema maestro DP, 3013, 3093
Desconexión del sistema maestro DP, 3013,
3093
Dispositivos y módulos, 3010, 3089
Funcionalidad DPV1, 3056
Interfaz DP, 3010, 3090
Visualización en el esclavo DP, 3011, 3091
Maestro Sync, 3190
Maestro Sync redundante, 3190
maestro Sync secundario, (Véase Maestro Sync
redundante)
Maestro USS
Orden de las llamadas de funciones, 1882
Protocolo USS, 1744, 1880
Protocolo USS: Bloque de datos de red, 1881
Protocolo USS: Campo de datos, 1745
Protocolo USS:Cifrado de datos, 1745
Protocolo USS:Codificación de datos, 1881
Protocolo USS:Estructura de la trama, 1745
Protocolo USS:Estructura de telegrama, 1880
Protocolo USS:Procedimiento de transmisión de
datos, 1745, 1881
Relación de funciones, 1746
Sinopsis de funciones, 1882

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Main, 1572
Main (S7-1500), 1097
Manejo automático de las señales
cualificadoras, 1722
Mapeado IP, 2631
Mapeo del módulo de transferencia, 3180
Marcas, 1002
Marcas de ciclo, 839, 1024, 1064, 1531, 1557
Marcas de sistema, 1024, 1063, 1531, 1556
Máscara de subred, 83, 564, 2196, 2569, 2802,
3121
Matriz
Servidor web, 1487, 1490
MC-Interpolator OB, 1127
MC-LookAhead OB, 1130
MC-PostServo OB, 1126
MC-PreInterpolator-OB, 1127
MC-PreServo OB, 1125
MC-Servo
Assigning parameters, 1124
Parametrizar, 1594
MC-Servo OB, 1123
MC-Transformation-OB, 1128
MD5, 436
Mecanismos de conexión, 1073, 1562
Media Redundancy Protocol (MRP), 3233
Medición de frecuencia (CPU 31xC), 853
Medio de almacenamiento extraíble, 3160
medio de transferencia/dúplex, 3154
Memoria, 1000, 1004
Área de comandos, 3698
Comprimir, 3698
Copiar de RAM a ROM, 3698
Memoria de carga, 806, 810, 1000, 1514
Memoria de sistema, 806
Acceso a través de FETCH/WRITE, 292
Áreas de operandos, 811, 1515
Búfer de diagnóstico, 817, 1519, 3652
Memoria imagen de proceso de las entradas y
salidas, 813, 1517
Pila de bloques, 816
Pila de datos locales, 814
Pila de interrupciones, 816
Memoria de trabajo, 806, 810, 1000, 1515
Memoria imagen de proceso, 1007, 1271, 1273,
1275, 1520
Actualizar, 813, 1518
de las entradas y salidas, 898
Error de acceso a periferia, 813, 1518
Principios básicos, 813, 1517
Memoria imagen parcial de proceso, 1272, 1275,
3077

3723

Índice alfabético

Memoria remanente, 807, 1000
Memory Card, 804, 995, 1000, 1512
Formatear, 3638
Memory Card de actualización de firmware, 995,
1512
Memory Card SIMATIC, 1000
Formatear, 3638
Mensaje
Definir el fin, 1555
Definir principio, 1554
enviar, 1553
Método de redundancia
HRP, 2211
Métodos de autenticación, 441, 443
MIB, 351
Micro Memory Card, 802
MIP OB 1 (memoria imagen de proceso del OB
1), 898
MIPP, (Véase Memoria imagen parcial de proceso)
Mirroring, 2405, 2408
MLD, 2449
Mobile
Información, 2841
MODB_341, 1760
MODB_441, 1760
Modbus
Exception Code, 1740
Fin de la trama, 1740
Señales RS232, 1722
Modbus_Comm_Load, 1705, 1751
Modbus_Master, 1705, 1751
Modbus_Slave, 1705, 1751
Modelo de slot en DPV1, 3063
Modificación de software, 1005
Modificación de una interconexión de puertos
Vista gráfica, 326
Modificar conexiones a través de cuadros de
diálogo, 249
Modificar el interlocutor, 248
Modificar la vía de conexión en la ventana de
inspección, 250
Modificar la vía de una conexión configurada, 249
Modo automático del controlador PROFINET
IO, 1651
Modo avanzado
Reglas de cortafuegos globales, 363
Modo combinado, 454
Modo de aprendizaje, 517
Modo de conexión, 237
Modo de conexión en red, 76
Modo de configuración, 617, 2303, 2642, 2863
Modo de enrutamiento, 410

3724

Modo de proceso, 846
Modo de prueba, 846
Modo dúplex, 1706, 1762
Modo estándar, 580, 2822
Modo isócrono, 3069, 3115, 3197, 3334, 3340
¿Por qué?, 3191
Ajustes en el esclavo DP, 3080
configuración en la subred, 3200
configurar, 3198, 3199
Efecto de Ti, 3194
Efecto de To, 3195
Memorias imagen parciales de proceso, 3077
Mismos tiempos Ti/To para todos los
esclavos, 3081
no seleccionable, 3079
Oversampling, 3540
Proceso, 3193
Propiedades de la CPU, 3077
Propiedades en PROFIBUS, 3079
Reglas, requisitos y condiciones marco, 3074,
3201
Reservas, 3085
Sincronización temporal, 1094
Solapamiento de Ti y To, 3084
Tiempo de ciclo DP y valores Ti/To, 3079
Tiempo de retardo, 3078
Modo mixto ET 200SP con ET 200AL, 3523, 3555
Modo multiplex/síncrono, 3589
Modo PROFIdrive, 1662
Modo RS232, 1709
Modo RS422, 1713
Modo RS485, 1716
Modo semidúplex, 1706, 1762
Modo VLAN, 442
Modulación del ancho de impulso
ET 200MP, 3579
Modulación del ancho de impulso (CPU 31xC), 858
Módulo
borrar, 61
Cambiar nombre, 60
copiar, 56
desplazar, 58
Determinar el estado de diagnóstico, 3624
direccionar, 1261, 1262, 1597
Hora de un módulo, 3634
insertar, 50, 51
Propiedades de comunicación, 3686
Selección múltiple, 53
seleccionar, 48
sustituir, 59

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

Módulo analógico
Restablecimiento de la configuración de
fábrica, 3650
Módulo comodín, 1241
Módulo de bus activo (ET 200M), 3581
Módulo de interfaz, 1257
Módulo de reserva
Valor sustitutivo, 3026, 3105
Módulo de seguridad, 334
Módulo emisor, 1257
Módulo no enchufado, 20
Módulo receptor, 1257
Módulos
Estado de la comunicación, 469
Módulos analógicos de alta velocidad
Modo isócrono, 3540
Módulos centrales
Parámetros en el programa del usuario, 1256
Propiedades de las CPUs, 1255
Selección del catálogo de hardware, 1252
Sinopsis de la configuración, 1240
Módulos de comunicación, 1547
Propiedades, 1548
Módulos de fuente de alimentación
redundantes, 1242
Módulos de fuente de alimentación,
redundantes, 1242
Módulos de seguridad
Selección del catálogo de hardware, 46, 1254
Módulos electrónicos y de pines, 3489
Mostrar avisos, 3347
Mostrar los tipos de memoria de una CPU, 3622,
3623
Mostrar soporte para un módulo, 35
MPI
Asignación de direcciones, 1261
MRP, 3233
MRP (Media Redundancy Protocol), 3231
MSDP, 2237, 2498
Peer, 2499
MSDP Cache, 2289
MSI, 1009
MSI (Shared Input interna del módulo), 1010
MSI/MSO, 3267
MSO, 1009
MSTP, 2427, 2744
Multicast, 253, 300, 412, 2443
Con UDP, 286, 287
Multicast bidireccional, 2237
Multilingüismo, 1041
Multiple Spanning Tree, 2427, 2744
Multipunto, 1812

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

N
NAK, 1734
NAPT, 2580
Configurar, 700, 2464, 2751, 2958
NAT, 2580
1-to-1 NAT, 703, 2962
Configurar, 699, 2461, 2463, 2748, 2958
Enmascaramiento, 577, 2817
NAPT, 577, 2817
NAT-Traversal, 583, 2824
NETMAP, 578, 2818
Source NAT, 578, 2818
NAT/NAPT
Routing, 411
NAT-Traversal, 583, 2824
Navegación general, 13, 16, 23
Negotiation, 681, 2357, 2697, 2931
Nivel de acceso, 1065, 1069
Nivel de protección, 844, 1065, 1069, 1558, 1559
Nodos de red internos
Configurar, 456
Diagnóstico, 470
Nombre convertido (PROFINET), 3127
Nombre de dispositivo, 3119, 3127, 3281
Nombre de dispositivo PROFINET, 3127, 3281,
(Véase Display)
Nombre de dispositivo, puesta en servicio automática
(PROFINET), 3123
Nombre de estación, (Véase Nombre de dispositivo)
Nombre de evento, 1593
Nombre de variable
Servidor web (PLC), 1478, 1614
Nombre del dispositivo
PROFINET, 3174
Nombre del grupo, 386, 390
Notificar errores de sistema, (Véase Diagnóstico del
sistema)
NTP, 2443
Servidor, 646, 2353, 2896
NTP (secure), 429
Número de dispositivo, 3121
PROFINET, 3174
Número de serie, 592, 2251, 2600, 2832
Número máximo de caracteres, 1728
Números de puerto, 141

3725

Índice alfabético

O
OB
Eventos y OB, 1016, 1521
fuente del evento, 1017
Sinopsis, 1016, 1521
OB 1, 906, 1572
OB 10 a OB 17 (S7-300, S7-400), 907
OB 100
OB 101 y OB 102 (S7-300, S7-400), 954
OB 121 (S7-300, S7-400), 960
OB 122 (S7-300, S7-400), 963
OB 20 a OB 23 (S7-300, S7-400), 910
OB 30 a OB 38 (S7-300, S7-400), 912
OB 40 a OB 47 (S7-300, S7-400), 914
OB 61 (S7-300, S7-400), 923
OB 61...64, 3072
OB 62 (S7-300, S7-400), 923
OB 63 (S7-300, S7-400), 923
OB 64 (S7-300, S7-400), 923
OB 80, 1582
OB 80 (S7-300, S7-400), 924
OB 81 (S7-300, S7-400), 927
OB 82, 1584
OB 82 (S7-300, S7-400), 930
OB 83, 1585
OB 83 (S7-300, S7-400), 933
OB 84 (S7-300, S7-400), 937
OB 85, 813
OB 85 (S7-300, S7-400), 939
OB 86 (S7-300, S7-400), 943
OB 87 (S7-300, S7-400), 950
OB 88 (S7-300, S7-400), 951
OB de alarma cíclica
Descripción, 1580
Parametrizar, 1592
OB de alarma cíclica (S7-1500), 1107
OB de alarma de actualización, 1577
OB de alarma de actualización (OB 56) (S7-300,
S7-400), 918
OB de alarma de actualización (S7-1500), 1103
OB de alarma de diagnóstico, 1584
OB de alarma de diagnóstico (OB 82) (S7-300,
S7-400), 930
OB de alarma de diagnóstico (S7-1500), 1114
OB de alarma de estado, 1577
OB de alarma de estado (OB 55) (S7-300,
S7-400), 916
OB de alarma de estado (S7-1500), 1102
OB de alarma de fabricante, 1578
OB de alarma de perfil, 1578

3726

OB de alarma de proceso
Descripción, 1581
Parametrizar, 1593
OB de alarma de proceso (S7-1500), 1108
OB de alarma de retardo, 1578
OB de alarma de retardo (S7-1500), 1105
OB de alarma de sincronismo, 1094, 3072
OB 61 a OB 64 (S7-300, S7-400), 923
parametrizar, 1134
OB de alarma de sincronismo (S7-1500), 1111
OB de alarma específica del fabricante
(S7-1500), 1104
OB de alarma específica del perfil (S7-1500), 1104
OB de alarma horaria
parametrizar, 1131
OB de alarma horaria (S7-1500), 1099
OB de alarmas específicas del fabricante (OB 57)
(S7-300, S7-400), 921
OB de arranque
Descripción, 1572
OB de arranque (S7-1500), 1096
OB de cambio de módulo, 1585
OB de cambio de módulo (S7-1500), 1115
OB de cambio de módulo (S7-300, S7-400), 933
OB de ciclo
Descripción, 1572
OB de ciclo (S7-1500), 1097
OB de error de acceso a la periferia (S7-1500), 1121
OB de error de acceso a la periferia (S7-300,
S7-400), 963
OB de error de comunicación (OB 87) (S7-300,
S7-400), 950
OB de error de ejecución del programa (OB 85)
(S7-300, S7-400), 939
OB de error de fuente de alimentación (OB 81)
(S7-300, S7-400), 927
OB de error de hardware en CPU (OB 84) (S7-300,
S7-400), 937
OB de error de programación (S7-1500), 1118
OB de error de programación (S7-300, S7-400), 960
OB de error de tiempo, 1582
mecanismo de valores umbrales, 1019
OB de error de tiempo (OB 80) (S7-300,
S7-400), 924
OB de error de tiempo (S7-1500), 1112
OB de fallo de rack, 1586
OB de fallo de rack (S7-1500), 1116
OB de fallo del rack (OB 86) (S7-300, S7-400), 943
OB de interrupción del procesamiento (OB 88)
(S7-300, S7-400), 951
OB de tarea no prioritaria (OB 90) (S7-300,
S7-400), 953

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

OB Interpolator, 1589
OB MC-Interpolator, 1589
OB MC-PostServo, 1589
OB MC-PreServo, 1588
OB MC-Servo, 1587
OB PostServo, 1589
OB PreServo, 1588
OB ProDiag, 1122
OB Servo, 1587, 1588, 1589
OBs de arranque OB 100, OB 101 y OB 102 (S7-300,
S7-400), 954
Ocupación estándar, 1813
Ocupación estándar de la línea de recepción, 1713,
1811
Offline, 335
Online, 335
Detección de hardware, 44
OPC UA
Ajustes de seguridad, 1327
Certificados X.509, 1317
Conexión segura, 1322
Espacio de nombres, 1302
Firma y cifrado, 1314
Generador de certificados, 1317
Identificador, 1302
Introducción, 1298
Mecanismos de seguridad, 1312
Modelo de capas, 1322
NodeId, 1301
OpenSSL, 1318
Puntos finales, 1327
Secure Channel (canal seguro), 1322
Variables DB, 1331
Variables PLC, 1331
Opciones de puerto, 3158
Activar autonegotiation, 3157
Velocidad de transferencia / dúplex, 3154
Vigilar, 3154
Open User Communication, 230
Borrar conexión, 121
Capacidad de relectura, 142
Crear conexión, 117
Descripción de la conexión, 124, 127, 129, 131,
133, 134
Establecimiento de la conexión, 109
General, 108
Iniciar la parametrización de la conexión, 116
Instrucciones, 109
Modificar valores de parámetros, 142
Números de puerto, 141
Parametrización de la conexión, 109, 111
Parámetros de conexión, 113

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Protocolos utilizados, 122
TCON_FDL, 137
TCON_IP_RFC, 135
TCON_IP_v4, 128
TCON_IP_V4_SEC, 130
TCON_Param, 124
TCON_QDN, 132
TCON_QDN_SEC, 133
TSAP, 143
Vía Industrial Ethernet, 230
OpenSSL, 1318
Operador de telefonía móvil
Interfaces, 2934
OSPF
Area Range, 2486
Areas, 2484
Áreas, 2230
Estado del router, 2230
Interfaces, 2486
Interfaces OSPFv2, 2279
Link State Advertisment, 2230
OSPFv2 LSDB (información), 2283
OSPFv2 Virtual Neighbors, 2282
Router, 2230
Vecinos OSPFv2, 2280
Vecinos virtuales OSPFv2, 2282
Virtual Links, 2489
OSPF (IPv6)
Area Range, 2518
Areas, 2517
Áreas, 2517
Interfaces OSPFv3, 2290
OSPFv3 AS-Scope LSDB, 2294, 2295
OSPFv3 Interfaces, 2519
OSPFv3 Link-Scope LSDB, 2296
Vecinos OSPFv3, 2291
Vecinos virtuales OSPFv3, 2293
Virtual Links, 2521
OSPFv2
Configuración, 2483
OSPFv3
Configuración, 2516
Otros dispositivos de campo (PROFIBUS y
PROFINET), 3055, 3113, 3170, 3171, 3211
OUC, (Véase Open User Communication)
Oversampling, 3540

P
P_PRINT, 1757
P_PRINT341, 1758
P_RCV, 1757

3727

Índice alfabético

P_RCV_RK, 1758
P_RESET, 1757
P_SEND, 1757
P_SND_RK, 1758
P12, 768
P3964_Config, 1704
Páginas de usuario, (véase Páginas definidas por el
usuario), (véase Páginas web definidas por el
usuario)
Página de usuario como página de inicio, 1476
Páginas web
Intervalo de actualización, 3385
Páginas web definidas por el usuario, 1471, 1475,
1487, 1489, 1490, 1492, 1493, 1504, 1608, 1612,
1621, 1622, 1624, 1625, 1626
Páginas web en el navegador, 1500, 1632
Palabra de datos (DBW), 1515
Palabra de datos locales (LW), 1515
Palabra de entrada (IW), 1515
Palabra de marca (MW), 1515
Palabra de salida (QW), 1515
Palabra doble de datos (DBD), 1515
Palabra doble de datos locales (LD), 1515
Palabra doble de marca (MD), 1515
Palabra doble de salida (QD), 1515
Panel de control de la CPU
Área de visualización, 3622, 3690
Panning, (Véase Desplazar la imagen)
PARADA, 800
Parameter assignment
DI operating mode, 1194
Digital inputs/outputs, 1192
DQ operating mode, 1196
Event/period measurement operating
mode, 1210
Oversampling DI operating mode, 1207
Oversampling DQ, 1208
PWM operating mode, 1211
Timer DI operating mode, 1196
Timer DQ operating mode, 1200
Parametrización
Hardware, 24, 41
Parametrización de la conexión
General, 109
iniciar, 116
Parámetros de conexión, 113
Resumen, 111
Parametrización de la conexión de la instrucción PUT/
GET, 174
Parámetro
para CPU, 1531
Parámetros (CPU), 1024

3728

Parámetros de arranque, 825, 992, 1510
Parámetros de bloque
Principios básicos, 1590
Parámetros de conexión de la instrucción PUT/
GET, 173
Parámetros de dirección
Broadcast, 287
Parámetros de dirección IP, 3121, 3132
Parámetros de interfaz PROFINET
Restablecer, 3699
Parámetros de protocolo, 1806
Parámetros del reloj, 839, 1062, 1063
Parámetros IP, 3616
PEM, 768
Perfil, (Véase perfil de bus)
Perfiles, 1578
Perfiles (S7-1500), 1104
Perfiles PROFIBUS, 103
Distintos perfiles en la misma subred, 103
Repercusiones en la velocidad de
transferencia, 104
Significado de los perfiles, 104
Periferia
acceso directo, 1007, 1520
acceso directo a la ~, 899
Periferia descentralizada, 3002, 3086, 3502, 3555
Configurar, 3002
Números de slots, 3003
Permitir acceso vía comunicación PUT/GET del
interlocutor remoto, 1073, 1562
Permitir sobrescribir el nombre de dispositivo, 3160
Petición de forzado permanente, 995
Pila de bloques, 809, 816
Pila de datos locales, 814
Pila de interrupciones, 816
PIM
Interfaces, 2495
Protocolo, 2495
RP Candidate, 2497
RP Static, 2496
PIM BSRs, 2288
PIM Interfaces, 2286
PIM Neighbors, 2286
Ping, 2373, 2695
PIP (tipo de datos), 1275
Plano de ocupación, 1000, 1001
PLUG, 2372
C-PLUG, 657, 2691, 2901, (C-PLUG)
KEY-PLUG, 659, 2694, 2904, (KEY-PLUG)
Port_Config, 1704, 1749
Posibilidades de comunicación, 2769
Posibles aplicaciones, 1806

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

Posicionamiento (CPU 31xC), 863
PostServo OB, 1126
PPP
Configuración, 683
Overview, 682
PreInterpolator-OB, 1127
PreServo OB, 1125
Preshared Keys, 442
Prioridad, 2389
Prioridad de OB, 1017
Priorización, 2389
Priorización CoS, 568, 2202, 2574, 2805
Private Key, 745
Procedimiento 3964(R), 1733, 1781
Carácter de comprobación de bloque, 1782
Caracteres de control, 1734, 1781
Enviar datos, 1783
Prioridad, 1734, 1782
Recibir datos, 1786
Procedimiento 3964R
Carácter de control de bloque, 1734
Procedimiento handshake, 1718
Procedimiento IPsec, 580, 2822
Procesador de comunicaciones
Software SIMATIC NET PC, 1649
STEP 7 V5 + STEP 7 Professional, 1659
PROFIBUS, 103, 3069
Acoplamiento con PROFINET, 3115
Cambiar interfaz DP, 3013
Comunicación directa, 3044
Crear un sistema maestro DP, 3047
DPV0/DPV1, 3055
ET 200S en modo DPV1, 3029, 3108
Funcionalidad distinta, 3057
Número de conexiones de comunicación, 188
PROFIBUS DP, 3010, 3017, 3090, 3096
PROFIBUS DPV1, 835
PROFIBUS isócrono, (Véase modo isócrono)
PROFIenergy, 3115, 3249, 3250
PROFINET, 85, 518, 1053, 2200, 2579, 2688, 3177,
3182, 3186, 3217, 3241
Acoplamiento con PROFIBUS, 3115
Asignar nombre de dispositivo, 3129
Diagnóstico, 3182
Direcciones IP, 3174
Nombre del dispositivo, 3174
Número de conexiones de comunicación, 188
Número de dispositivo, 3174
Optimizar con IRT, 3165
Optimizar con RT, 3163

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Permitir sustitución de dispositivo sin medio de
almacenamiento extraíble, 3160
Redundancia de medios, 3231
PROFINET IO, 2200, 2579, 3113, 3115, 3119, 3121,
3139, 3145, 3203
Opciones de puerto, 3154
PROFINET IRT, 3191
Programa
Cíclico (S7-300, S7-400), 906
Programa cíclico (OB 1) (S7-300, S7-400), 906
Programa cíclico (S7-1500), 1097
Programa de arranque, 1572
Programa de arranque (S7-1500), 1096
Programa de ejemplo
OB 122, 964
OB 81 (S7-300, S7-400), 930
Programa de usuario, 1156
Programación
Modbus, 1750
PtP, 1746
USS, 1752
Programming error (S7-1500), 1118
Project
Adding a SIMATIC Drive Controller, 1187
Creating, 1186
Display, 1187
Grouping, 1189
Prolongación del impulso, 3530, 3583
Propiedades (CPU, 1024, 1531
Propiedades de comunicación de un módulo, 3686
Propiedades de grupo, 443
Propiedades de interfaces, 3615, 3687
Propiedades de la CPU, 1024, 1531
Propiedades del dominio MRP, 3619
Propiedades del dominio Sync, 3618
Propiedades del grupo VPN, 443
Propiedades OPC", 268, 275, 281
Protección contra escritura, 1558
Protección de acceso, 1076
Protección de acceso IP, 230, 3369, 3372
Lista IP Access Control, 3371
Protección de acceso local, 1076
Protección por contraseña, 844, 1024, 1065, 1069,
1531, 1558, 1559, 1604
Protocolo, 386
Protocolo 3964(R) (CPU 31xC), 887
Protocolo ASCII, 1725
Protocolo ASCII (CPU 31xC), 880
Protocolo de comunicación
definir, 1551
Resumen, 1550
Protocolo Freeport, 1725

3729

Índice alfabético

Protocolo ISO, 518
Protocolo para mainframe RK512, 1790
Enviar datos, 1793
Recoger datos, 1796
Telegrama de orden, 1790, 1791
telegrama de reacción, 1790
Protocolo RK 512 (CPU 31xC), 892
Protocolo USS
Estructura general del bloque de datos de
red:Área de datos de proceso (PZD), 1881
Estructura general del bloque de datos de
red:Área de parámetros (PKW), 1881
Estructura general del bloque de datos:Área de
datos de proceso (PZD), 1746
Estructura general del bloque de datos:Área de
parámetros (PKW), 1746
Protocolos de los módulos de comunicación, 1703
Proxy ARP, 528
Proyecto de maquinaria de serie, 1292, 3271, 3272,
3276, 3278, 3281, 3285, 3286, 3293, 3294
Prueba de coherencia ("Check Consistency"), 516
a nivel de proyecto, 340
local, 340
Public Key, 745
Puerto, 85
102 (protocolo S7 - TCP), 387
123 (NTP), 413, 429
161 (SNMP), 413
20/21 (FTP), 387
443 (HTTPS), 413
4500 (IPsec), 413
500 (IPsec), 413
500 (ISAKMP - UDP), 460
514 (Syslog), 413
80 (HTTP), 387
8448 (diagnóstico de seguridad), 548, 551
cambiar nombre, 329
Configuración, 681, 2359, 2697, 2931
Configuración de puerto, 649, 654, 680, 2356,
2364, 2696, 2699, 2930
Interconexión, 3147
Link Check, 2265
Puerto de comunicación
configurar, 1548
Puerto de redundancia, 1689
Puerto en anillo, 3241
Puerto interlocutor
Información sobre vigilancia, 3148
Puerto interlocutor cambiante, 3224
Puertos interlocutores que cambian durante el
funcionamiento, 3224
Puesta en servicio automática, 3160

3730

Pull or plug of modules (S7-1500), 1115
Pulsador, 647, 2897
Pulsador SET, 647, 2897
Punto a punto, 1812, 2210, 2592
Punto de encuentro, 2236
PUT/GET, 1073, 1562
PWM
ET 200MP, 3579
PZF (error de acceso a periferia), 813

Q
QI (Quality Information), (Véase Información de
calidad)
QoS, 2389

R
R, 103
Rack, 47, 1256
Insertar módulo, 50
Número máximo, 1241, 1242
Reglas de equipamiento del S7-300, 1241
Reglas de equipamiento S7-400, 1242
Rack ampliable, 1258
Rack de ampliación
ER1 (S7-400), 1258
IM 46x, 1258
Reglas, 1259
Rack ET-Connection, 3523
Rack or station failure, 1586
Rack or station failure (S7-1500), 1116
RADIUS, 716, 2533, 2761, 2975
Rango de direcciones, 403
Rango de medición, 3545
Rango de medición escalable, 3545
Rango de valores de la dirección IP, máscara de
subred y dirección de la transición de red, 3364
RCV_PTP, 1758
RDREC, 1267
Rearranque, 826
Rearranque (en caliente), 991, 1508
Rearranque (S7-300, S7-400), 954
Rearranque completo, 2311, 2651, 2866
Rearranque completo (en caliente), 792
Rearranque completo (en caliente) (S7-300,
S7-400), 954
Rearranque completo de la CPU, 1884
Rearranque de la CPU, 1884
Rearranque normal, 793, 826
Rearranque normal manual, 826

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

Rebase del tiempo de respuesta, 1728
Rebase por defecto, 3506, 3531
Rebase por exceso, 3506, 3531
Receive_Config, 1704, 1749
Receive_P2P, 1704, 1749
Receive_Reset, 1704, 1749
Recibir datos, 1749
Driver ASCII, 1770, 1805
Procedimiento 3964(R), 1786
Recipe, 1607
Recoger datos
RK512, 1796
Reconfiguración mediante el programa de
usuario, 1278, 1638, 3510, 3515, 3558, 3569, 3591
Record Protocol, 748
Recurso de conexión, 149, 158
Recursos de conexión, 182, 3691
Asignar, 197, 199
Comunicación HMI, 196
específicos de la estación, 189, 201
específicos del módulo, 189, 202
Indicación en STEP 7, 201
online, 3663, 3664
Routing de juegos de datos (registros), 196
Routing S7, 196
Sinopsis, 192
Visualización en el servidor web, 204
RECV_440, 1759
Redes redundantes, 690, 2949
Reducir el ciclo del sistema, 3082
Reducir el tiempo de reacción del proceso, 3082
Redundancia
Dominio de redundancia, 3233
Redundancia de anillo, 2415
Redundancia de medio
Configurar, 3236
Redundancia de medio (MRP), 3115
Redundancia de medios (MRP), 3231, 3241
Redundancia de sistema, 1145
Redundancia en anillo
HRP, 2384
MRP, 2384
Redundancia OPC UA, 1688
Redundancia Standby, 2213
Referencia, 30, 592, 2251, 2600, 2832, (véase
Referencia)
Referencias, 1701
Registro, 463
CP 343-1 Adv. / 443-1 Adv., 534
SCALANCE S, 500, 502
Registro de auditoría, 472
Registro del sistema, 471

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Registro del sistema en red, 464
Registro local, 464
Registros de filtrado de paquetes, 473
Registros de la CPU, 897
Reglas de cableado (PROFINET), 3158
Reglas de conexión, 542, 555
Reglas de cortafuegos globales, 363
Asignar, 365
Reglas de cortafuegos predefinidas
CP 1543-1, 547, 551
CP 1628, 537
CP 343-1 Adv. / 443-1 Adv., 535
SCALANCE S, 500, 502
Reglas de filtrado de paquetes IP, 395
Reglas de slots
DPV1, 3063
ET 200S, 3020, 3100
Reglas globales de filtrado de paquetes, 365
Reglas para filtrado de paquetes MAC, 400
Reglas para la asignación de direcciones, 1261
Reglas para la configuración de redes MPI
Reglas para la asignación de direcciones
MPI, 108
Reglas para la configuración de redes PROFIBUS
Asignar direcciones de dispositivos, 100, 107
Reglas para slots, 48
Esclavo DP, 3003, 3015, 3094
Estación PC, 1649
ET 200M, 3003
S7-1500, 1244
S7-300, 1241
S7-400, 1242
Servidor OPC, 1650
Reloj del sistema, 3192
Reloj en tiempo real, 3689
Remanencia, 1004, 1517
Memoria de carga, memoria de trabajo, memoria
de sistema, 807
Remanencia de parámetros de dirección IP, 3132
Renovar un certificado de grupo CA, 455
Repetidor de diagnóstico, 3657
Report System Errors, 1466, (Véase Diagnóstico del
sistema)
OB de error creados, 3674
RES_RCVB, 1758
RES_RECV, 1759
Reserva de memoria, 1007
Resistencia PTC, 3542
Respaldo, 810
Restablecer, 2311, 2651, 2866
Configuración de fábrica, 3635, 3636
Parámetros de interfaz PROFINET, 3699

3731

Índice alfabético

Restablecer la configuración de fábrica, 3637
Restablecimiento de la configuración de
fábrica, 1004
Resumen de los identificadores de bits, bytes,
palabras y palabras dobles, 900
Resumen de versiones, 1595
RFC 5280, 745
RI, 1711
RIP
Estadística RIPv2, 2285
RIPng
Configuración, 2522
Estadísticas RIPng, 2296
Interfaces, 2523
RIPv2
Configuración, 2492
Interfaces, 2493
RMON
Estadística, 2453
Historial, 2454
Root Max Age, 603, 2851
Root-Bridge, 2591
Rotulación del módulo, 47
Rotura de hilo, 3505, 3573
Router, 83, 3135
Router estándar, 510
Routing, 2228
ICMP, 566, 2810
Rutas estáticas, 2228
Tabla de enrutamiento, 2278
Tabla de routing IPv4, 599, 2840
Tabla de routing IPv6, 2289, 2615
VRRP, 2228
Routing IO, 3180
Routing IPv4
MSDP Cache, 2289
PIM BSRs, 2288
PIM Interfaces, 2286
PIM Neighbors, 2286
PIM Routes, 2286
PIM RPs, 2287
Tabla de Routing, 599, 2840
Traducciones NAT, 2285
Routing IPv4 a través del bus de fondo (CM/
CP 154x‑1), 3599
Routing IPv6
Interfaces OSPFv3, 2290
OSPFv3 AS-Scope LSDB, 2294, 2295
OSPFv3 Link-Scope LSDB, 2296
Rutas estáticas, 2503
Rutas predeterminadas, 2648
Tabla de routing, 2289, 2296, 2615

3732

Vecinos OSPFv3, 2291
Vecinos virtuales OSPFv3, 2293
Routing S7
Recursos de conexión, 196
RSTP, 689, 2948
RTS, 1711
RTS de HW siempre ON, 1721
RTS de HW siempre ON, ignorar DTR/DSR, 1721
RUN, 798, 800, 993, 1510
RUN de la CPU, 1754, 1884
rutas estáticas
Rutas IPv6, 2503
Rutas predeterminadas
Rutas IPv6, 2648

S
S_MODB, 1759
S_RCV, 1759
S_RTS, 1759
S_SEND, 1759, 1830
S_USSI, 1760
S_USSR, 1760
S_USST, 1759
S_V24, 1759
S_VSET, 1759
S_VSTAT, 1759
S_XON, 1759
S7-1500
Campo de aplicación, 1243
Definición, 1243
Propiedades, 1243
Segmento de potencia, 1244
S7-300
Reglas para slots, 1241
S7-400
Reglas para slots, 1242
S7-PCT, 3333
Salida (Q), 1515
Salida de periferia, 1515
SALRM, 3034
SCALANCE S, 333
Secuencia de fin, 1728
Secuencias de inicio, 1727
Secure communication, 745
Secure Socket Layer, 748
Security Configuration Tool
Vistas de configuración, 335
Segmento de potencia, 1244
Seguridad (servidor web), 1462
Seguridad de la transmisión, 1706
con 3964(R), 1708

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

con Freeport, 1707
con Modbus y USS, 1708
Seguridad de transmisión, 1765
con el driver ASCII, 1767
Con RK512, 1768
Selección múltiple, 48
Componente de hardware, 53
Seleccionar la vía de conexión de forma
específica, 239
select before operate, 2008
Selector de modo, 3690
Sellado de tiempo, 3492
SEND_440, 1759
Send_Config, 1704, 1749
Send_P2P, 1704, 1749
SEND_PTP, 1758
SEND_RK, 1758
Sensor Cu10, 3542
Señal BUSY, 1805
Señales cualificadoras, 1702
Señales cualificadoras RS232
Manejo automático, 1722
Señales cualificadoras RS232C, 1777
Manejo automático, 1778
Señales RS232, 1709
Señales RS422, 1713, 1716
SERVE_RK, 1758
Servicios FETCH/WRITE
Configuración para transporte ISO, 291
Servicios MAC, 390
Servidor DCP, 612, 615, 2303, 2642, 2861
Servidor de correo electrónico, 306
Servidor de redundancia UA, 1686
Servidor DHCP, 515
Servidor OPC
Reglas para slots, 1650
Uso como servidor SMTP, 305
Servidor OPC - Avisos de PLC, 1691
Servidor OPC UA
Adaptar certificado de servidor, 1355
Ajustes de seguridad, 1352
Archivo de exportación XML, 1340
Aumento del rendimiento, 1338
Autenticación, 1357
Derechos de escritura y lectura, 1331
Direccionamiento, 1343, 1415, 1416
Espacio de direcciones, 1303
Generar certificado de servidor, 1348
Intervalo de envío, 1347
Intervalo de muestreo, 1347
Licencias runtime, 1360, 1362, 1416
Nombre de aplicación, 1342, 1414

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Principios básicos, 1324
Puerto TCP, 1345, 1346
Puesta en marcha, 1341, 1413
Rendimiento, 1338
Suscripción, 1345
Servidor OPC UA, 1688
Servidor SSH, 2302
Servidor Syslog, 464
Servidor web, 841, 1041, 1458, 1467, 1471, 1475,
1492, 1500, 1504, 1602, 1604, 1608, 1612, 1624,
1625, (véase Servidor web)
Activar, 1465, 1466, 1605
Administración de usuarios, 1467
administrar acceso, 1465
Certificado, 1469
Clases de visualización de mensajes, 1471
Enumeraciones, 1487, 1621
Estructuras, 1489, 1490
Fragmento, 1490, 1622
HTTPS, 1469, 1606
Matriz, 1487, 1490
Páginas web definidas por el usuario, 1471, 1608
Reglas para nombres de variables PLC, 1478,
1613
Servidores NTP, 429
Servo OB, 1123, 1125, 1126
Set_Features, 1705, 1749
Severidad, 410
SFTP
Cargar/guardar, 622, 2318, 2657, 2871
SHA1, 436
Shared Device, 1010, 3115, 3250, 3267
Controlador IO correspondiente, 3617
Shared I-Device, 3258
Shared Input interna del módulo (MSI), 3267
Shared Output interna del módulo (MSO), 3267
SHDSL
Interfaz, 2939
Sinopsis, 2844, 2938
SiClock, 392
Signal Board, 1601
insertar, 1602
Signal_Get, 1704, 1749
Signal_Set, 1704, 1749
SIM
Interfaces, 2932
SIMATIC ET 200AL, 3523, 3551, 3555
SIMATIC-ACC, 169, 261
Símbolos de estado, 1667
SINAMICS
Digital inputs/outputs, 1218

3733

Índice alfabético

Sincronismo
Combinación de DP con y sin sincronismo, 3075
Crear un programa de usuario, 3081
Ejemplo: registro de varios puntos de
medición, 3073
Sincronización (páginas web definidas por el
usuario), 1473, 1610
Sincronización de la hora, 838, 1062
Sincronización horaria, 429, 1024, 1531, 3358, 3439
CP PROFIBUS, 3435
Sincronizar la hora, 838, 1062
Sinopsis
Access Point, 2621
Canales superpuestos, 2625
clientes, 2627
Overlap APs, 2625
Sinóptico de direcciones, 65, 1270
Sintaxis de los comandos AWP, 1478, 1613
Sintaxis para constantes, 900
sistema
Configuración del sistema,
Configuration, 611, 614, 2859
Información general,
Sistema de memoria de S7-400, 808
Sistema de periferia descentralizada ET 200M, 3580
Sistema IO, 3142, 3272, 3276, 3278, 3282, 3285,
3286, 3293, 3294
Crear, 3145
Sistema IO de múltiples aplicaciones, 3272, 3276,
3278, 3281
Sistema maestro DP
Crear, 3003, 3009, 3017, 3047, 3086, 3089, 3096
Desconectar esclavo DP, 3015, 3095
Desconexión de la subred, 3012, 3092
Desconexión de los nodos, 3012, 3092
Editar propiedades, 3014, 3093
Insertar esclavo DP, 3015, 3094
Resaltar, 3012, 3092
varios, 3006
Sistema monomaestro, 3006, 3088
Sistema PROFINET IO, 3142
Crear, 3138
Resaltar, 3141
Sistemas IO de múltiples aplicaciones, 3271
Sistemas multimaestro, 3006
Slot
Asignación de slots en DPV1, 3063
Datos de usuario con DPV1, 3063
Modelo de slot, 3063
Rack, 47
seleccionar, 48

3734

SMS
enviar, 2908
recibir, 2909
t, 2911
SMTP
Client, 612, 615, 2861
SNAT
Configurar, 701, 2960
SNMP, 351, 569, 613, 616, 633, 2206, 2304, 2340,
2589, 2642, 2672, 2806, 2862, 2883, 3386
Grupos, 633, 2340, 2672, 2883
Sinopsis, 598, 2298, 2616, 2839
SNMP Trap, 633, 2340, 2672, 2882
SNMPv1, 569, 2206, 2589, 2806
SNMPv2c, 569, 2206, 2589, 2806
SNMPv3, 569, 2206, 2589, 2806
Usuario, 635, 2342, 2674, 2884
SNMPv1, 436
SNMPv3, 436
Sobrescritura del nombre de dispositivo
PROFINET, 3281
SOFTNET Security Client
Base de datos, 476
Configurar en el proyecto, 475
Crear un archivo de configuración, 475
Uso del, 474
SOFTNET Security Client, 333
Software SIMATIC NET PC para procesador de
comunicaciones, 1649
Solapamiento de Ti y To
Ajuste, 3084
Principio de funcionamiento, 3082
Reglas, 3085
Requisitos, 3082
Solicitante, 749
Solo servidor HTTPS, 2302
Source NAT
Enmascaramiento, 577, 2817
Source specific-Multicast, 2237
Spanning Tree, 689, 2948
Información, 604, 2256, 2606, 2852
Rapid Spanning Tree, 2210, 2592
Sparse Mode, 2237
Speedy Splitter, 12, 15, 22, 38
SSH
Servidor, 611, 614, 2860
SSL, 748
Startup, 1572
Startup (S7-1500), 1096
Stateful Inspection Firewall, 574, 2814
Stateful Packet Inspection, 361
Station_Info, 1267

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

STOP, 790, 798, 993, 994, 1511
STOP de la CPU, 1754, 1884
STX, 1734
Subciclo, 3540
Submódulo, 3267
Submódulo base, 1010
Submódulo MSI, 1010
Subred, 85
Configuración, 698, 2956
Sinopsis, 696, 2955
Subred IP, 85
Subredes
Configuración (IPv6), 2501
Pasarela predeterminada, 2461
Subredes conectadas (IPv6), 2501
Supresión de frecuencias perturbadoras, 3021, 3574
Sustitución de dispositivos, 59
Sustitución de módulos en marcha, 3581
Sustituir
Módulo, 59
Sustituir dispositivo, 59
Switchport, 3158
SYNC, 3019
SYNC_PI, 835
SYNC_PO, 835
Synchronous cycle (S7-1500), 1111
Syslog
Client, 612, 615, 2861

T
T_DC, 1094
Tabla de asignación File, 3378
Tabla de códigos ASCII, 146
Tabla de conexiones, 235, 247
Tabla de observación
Servidor web, 1464
Tabla de registro
Registro de autenticación WLAN, 2604
Registro de evento, 593, 2253, 2602, 2833
Tabla de variables
Servidor web, 1464
Tableta, 1504
Tamaño de los datos de usuario en el dispositivo
IO, 3368
Tamaño de telegrama en el dispositivo IO, 3368
Tarjeta de memoria, (Véase Memory Card)
Tarjeta de programa, 1512
Tarjeta de transferencia, 1512, (Véase Memory Card)
Tarjeta SD, (véase Memory Card)
Tasa de muestreo (módulos analógicos de alta
velocidad), 3542

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Tasa de salida (módulos analógicos de alta
velocidad), 3542
Task Card
Catálogo de hardware, 30
Herramientas online, 3613
TCI (Tool Calling Interface), 3332
TCON_FDL, 137
TCON_IP_RFC, 135
TCON_IP_v4, 128
TCON_IP_V4_SEC, 130
TCON_Param, 124
TCON_PHONE para conexiones de Telecontrol, 136
TCON_QDN, 132
TCON_QDN_SEC, 133
TCP, 386
Características, 122
Números de puerto, 141
TDP (reloj del sistema), 3070
Telegrama de continuación, 1790
Telegrama de orden, 1790
telegrama de reacción, 1790
Estructura y contenido, 1792
Telegrama de señal de vida, 3356
Telegrama FETCH, 1790
Telegrama FETCH de continuación, 1798
Telegrama PUT, 1790
Telegrama SEND, 1790, 1794
Telegrama SEND de continuación, 1794
Telegrama SEND/PUT, 1790, 1791, 1794
Telegramas Ethernet-Non-IP, 361
Telegramas Keep Alive, 3356
Telnet
Servidor, 611, 614, 2860
Temperatura de referencia, 3531, 3534, 3575, 3576
Temperatura de referencia dinámica, 3576
Temperatura de referencia fija, 3576
Tensión de alimentación, 3531
Termopar, 3534, 3545
Termorresistencia, 3534, 3545, (véase
Termorresistencia)
Test de parpadeo, 3656
Texto SMS (TCON_Phone), 136
Textos de aviso, 1802
Caracteres de control, 1802
Diseño de página, 1802
Tabla de caracteres de control, 1802
Tabla de conversión de caracteres, 1802
TFTP
Cargar/guardar, 619, 2316, 2655, 2869
Ti, 1094
Ti (momento en que se leen los datos de
entrada), 3070, 3082, 3200

3735

Índice alfabético

Tiempo de actualización, 3149
Tiempo de ciclo, 1024, 1036, 1531, 1537
mostrar medido, 3620
mostrar parametrizado, 3615
Tiempo de ciclo de emisión, 1094, 3149, 3177, 3187
Tiempo de ciclo de emisión impar, 3177
Tiempo de ciclo máximo, 1036, 1537
Tiempo de ciclo mínimo, 993, 1036, 1510, 1537
Tiempo de conmutación, 1553
Tiempo de mensaje excedido, 1728
Tiempo de preprocesamiento, 1094
Tiempo de preprocesamiento Ti, 3072
Tiempo de retardo
Modo isócrono, 3078
Tiempo de retardo de caracteres, 1728
Tiempo de retardo de caracteres TRC, 1740, 1818
Tiempo de supervisión de respuesta, 3151
Tiempo de vigilancia del ciclo, 993, 1036, 1510,
1538
Time delay interrupt, 1578
Time delay interrupt (S7-1500), 1105
Time error interrupt, 1582
Time error interrupt (S7-1500), 1112
Time of day (S7-1500), 1099
Tipo de arranque, 1024, 1531
Tipo de contador, 1543
Tipo de datos
PIP, 1275
Tipo de encoder Inversor, 3582
Tipo de tarjeta, (véase Memory Card)
Tipos de enumeraciones, 1485, 1620
Tipos de esclavos DP, 3014, 3094
Titular del certificado, 749
TLS, 748
TM, 3180
To, 1094
To (momento en que se emiten los datos de
salida), 3082, 3200
To (tiempo en que se emiten los datos de
salida), 3070
Tool Calling Interface (TCI), 3332
Topología
Anillo, 3233
Topologías, 1812
Traducciones NAT, 2285
Tráfico de datos bidireccional, 1706
Tráfico de datos unidireccional/bidireccional, 1710
Transfer Card; véase Tarjeta de transferencia, 1512
Transferencia de datos asíncrona, 1706
Transferencia de datos con el maestro Modbus ET
200S, 1829
Transferencia de datos serie, 1705

3736

Transferencia de datos UART, 1547
Transferir datos, 1749
Transformation OB, 1128
Transición de red, 83
Transiciones de estado operativo, 1754, 1884
Transparencia del código, 1731
Transport Layer Security, 748
Trust Mode, 2389
TSAP
Estructura, 144, 169, 261
Tabla de códigos ASCII, 146
TSAP ASCII, 146

U
UDP, 386, 395, 429
Características, 124
Números de puerto, 141
Unidad periférica descentralizada ET 200iSP
Definición, 3488
Unión fría, 3022, 3101, 3491, 3506, 3531, 3534,
3575, 3576
Unión fría interna, 3576
Upload, 3335
Uso de datos móviles, 2844
USS_Drive_Control, 1705, 1753
USS_Port_Scan, 1705, 1753
USS_Read_Param, 1705, 1753
USS_Write_Param, 1705, 1753
Usuarios locales, 711, 2526, 2754, 2971

V
V24_SET, 1758
V24_SET_340, 1757
V24_SET_441, 1759
V24_STAT, 1758
V24_STAT_340, 1757
V24_STAT_441, 1759
Valor de arranque, 1000
Valor límite, 3531
Valor sustitutivo
Módulo de reserva, 3026, 3105
Variable ERPC, 3377
Variable especial (servidor web), 1483, 1617
Variable IEEE, 3489
Variables, 3377
Variables HART
configurar, 3487
Estructura, 3488
Variables PLC, 1478, 1479, 1482, 1614, 1615, 1616

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Índice alfabético

Variables temporales (TEMP)
En el programa cíclico (S7-300, S7-400), 906
Necesario para OB, 963
Velocidades de transferencia de datos, 1702
Ventana de inspección, 64
Editor de hardware y redes, 24
Ficha Diagnóstico, 3602
Ventana de medición (PUERTA), 3502
Ventana de propiedades, (Véase Ventana de
inspección)
Ventana de vigilancia, 3583
Versión de hardware, 592, 2251, 2600, 2832
Versión de módulo
Actualizar, 62
Versión de software, 592, 2251, 2600, 2832
Vía de conexión
Resaltar en la vista de redes, 245
Vigilancia de errores
Alimentación, 2364, 2685
modificación de estado de conexión, 655, 2365,
2686, 2899
Redundancia, 2366
Tarjeta SIM, 2900
Vigilancia de inestabilidad de señal, 3583
Vigilancia de la red, 628, 629, 2878
Vigilancia del puerto interlocutor..., 3148
Vigilar, 3154
Visor de avisos, 3347
Acusar un aviso, 3351
Estructura de los avisos en la vista "Avisos
activos", 3347
Estructura de los avisos en la vista de
fichero, 3348
Exportar fichero, 3349
Manejo del teclado, 3353
Recibir avisos, 3350
Vaciar por completo el fichero de avisos, 3349
Vista "Avisos activos", 3347
Vista de fichero, 3348
Visor de topología, 3385
Vista de dispositivos
Área de módulos no enchufados, 20
Editar parámetros, 64
Editar propiedades, 64
Editor de hardware y redes, 15
Insertar módulo, 49
Insertar Signal Board, 1601
Rack, 47, 1256
Vista de redes
Agregar dispositivo, 42
Comunicación E/S, 3129

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Editor de hardware y redes, 12
Significado, 244
Vista general de dispositivos
Área de direcciones, 1261, 1262, 1597
Vista general de redes
Funciones básicas, 78
Funciones básicas para editar la tabla de la vista
general de redes, 78
Vista Online y diagnóstico, 3601
Vista topológica
Agregar dispositivo, 42
Aplicar dispositivos determinados online, 332
Aplicar interconexiones de puertos determinadas
online,
Comparación offline/online avanzada, 324
Comparar offline/online, 321
Diferencias con respecto a la vista de redes, 315
Editor de hardware y redes, 22
Estado de diagnóstico en la vista de tabla, 320
Estado de diagnóstico en la vista gráfica, 320
Funciones, 314
Interconectar puertos, 324
Topología configurada, 317, 318
Vista topológica general, 22
Visualización de conexiones en la vista de
redes, 235
Visualización online
Color naranja, 3611
VLAN, 567, 2201, 2572, 2803
ID de VLAN, 569, 2203, 2575, 2806
Prioridad, 687, 2399, 2735, 2946
Tag, 687, 2399, 2735, 2946
VID de puerto, 688, 2399, 2735, 2946
VLAN-tag, 567, 2201, 2573, 2804
VLAN-Tagging, 442
Volumen de datos bruto, 3368
Volumen de datos neto, 3368
VRRP
Configuración, 2474
Configuración de direcciones VRRPv3
(IPv4), 708, 2482, 2967
Configuración de direcciones VRRPv3
(IPv6), 2514
Configuración VRRPv3 (IPv4), 706, 2480, 2965
Configuración VRRPv3 (IPv6), 2512
Router, 2473
Router de reserva, 2229
Router maestro, 2229
Router virtual, 2229
Router VRRP, 2229
Router VRRPv3 (IPv4), 705, 2478, 2510, 2964
Sinopsis de direcciones, 2476

3737

Índice alfabético

Sinopsis de direcciones VRRPv3 (IPv4), 708,
2481, 2967
Sinopsis de direcciones VRRPv3 (IPv6), 2514
Vigilancia de interfaces, 2477, 2482, 2515
VRRP Statistics, 2258
VRRPv3
Estadísticas VRRPv3, 606, 2260, 2854
Vigilancia de interfaces, 709, 2968

W
WDS, 2713
Wireless-LAN/PB-Link, 3115
WLAN
Registro de autenticación WLAN, 2604
WRREC, 1267
WWW (instrucción), 1493, 1626

X
X.509, 745
XON/XOFF, 1719

Z
Zoom
Ajuste del nivel de zoom, 12, 15, 22
Comandos de teclado, 39

3738

Edición de dispositivos y redes
Manual de programación y manejo, 11/2019

Programación del PLC
Manual de programación y manejo

11/2019

Principios básicos de la
programación

1

Recomendaciones de
programación

2

Tipos de datos

3

Instrucciones

4

Editor de programación

5

Utilización de las Software
Units

6

Creación y gestión de
bloques

7

Protección de bloques

8

Declaración de la interfaz del
bloque

9

Programación de bloques de
datos

10

Declaración de variables PLC

11

Declarar tipos de datos PLC
(UDT)

12

Creación de programas KOP

13

Creación de programas FUP

14

Crear programas AWL

15

Creación de programas SCL

16

Continua en página siguiente

Siemens AG
Digital Industries
Postfach 48 48
90026 NÜRNBERG
ALEMANIA

Ⓟ 11/2019 Sujeto a cambios sin previo aviso

Copyright © Siemens AG 2019.
Reservados todos los derechos

Continuación

Programación del PLC
Manual de programación y manejo

Crear programas GRAPH

17

Configurar avisos

18

Compilación y carga de
programas de PLC

19

Comparación de programas
de PLC

20

Mostrar información del
programa

21

Mostrar referencias cruzadas

22

Comprobar el programa de
usuario

23

Supervisión de máquinas e
instalaciones con ProDiag

24

Notas jurídicas
Filosofía en la señalización de advertencias y peligros

Este manual contiene las informaciones necesarias para la seguridad personal así como para la prevención de
daños materiales. Las informaciones para su seguridad personal están resaltadas con un triángulo de advertencia;
las informaciones para evitar únicamente daños materiales no llevan dicho triángulo. De acuerdo al grado de peligro
las consignas se representan, de mayor a menor peligro, como sigue.
PELIGRO
Significa que, si no se adoptan las medidas preventivas adecuadas se producirá la muerte, o bien lesiones
corporales graves.
ADVERTENCIA
Significa que, si no se adoptan las medidas preventivas adecuadas puede producirse la muerte o bien lesiones
corporales graves.
PRECAUCIÓN
Significa que si no se adoptan las medidas preventivas adecuadas, pueden producirse lesiones corporales.
ATENCIÓN
Significa que si no se adoptan las medidas preventivas adecuadas, pueden producirse daños materiales.
Si se dan varios niveles de peligro se usa siempre la consigna de seguridad más estricta en cada caso. Si en una
consigna de seguridad con triángulo de advertencia de alarma de posibles daños personales, la misma consigna
puede contener también una advertencia sobre posibles daños materiales.

Personal cualificado

El producto/sistema tratado en esta documentación sólo deberá ser manejado o manipulado por personal
cualificado para la tarea encomendada y observando lo indicado en la documentación correspondiente a la misma,
particularmente las consignas de seguridad y advertencias en ella incluidas. Debido a su formación y experiencia,
el personal cualificado está en condiciones de reconocer riesgos resultantes del manejo o manipulación de dichos
productos/sistemas y de evitar posibles peligros.

Uso previsto de los productos de Siemens
Considere lo siguiente:
ADVERTENCIA
Los productos de Siemens sólo deberán usarse para los casos de aplicación previstos en el catálogo y la
documentación técnica asociada. De usarse productos y componentes de terceros, éstos deberán haber sido
recomendados u homologados por Siemens. El funcionamiento correcto y seguro de los productos exige que su
transporte, almacenamiento, instalación, montaje, manejo y mantenimiento hayan sido realizados de forma
correcta. Es preciso respetar las condiciones ambientales permitidas. También deberán seguirse las indicaciones
y advertencias que figuran en la documentación asociada.

Marcas registradas

Todos los nombres marcados con ® son marcas registradas de Siemens AG. Los restantes nombres y
designaciones contenidos en el presente documento pueden ser marcas registradas cuya utilización por terceros
para sus propios fines puede violar los derechos de sus titulares.

Exención de responsabilidad

Hemos comprobado la concordancia del contenido de esta publicación con el hardware y el software descritos. Sin
embargo, como es imposible excluir desviaciones, no podemos hacernos responsable de la plena concordancia. El
contenido de esta publicación se revisa periódicamente; si es necesario, las posibles correcciones se incluyen en
la siguiente edición.

Siemens AG
Digital Industries
Postfach 48 48
90026 NÜRNBERG
ALEMANIA

Ⓟ 11/2019 Sujeto a cambios sin previo aviso

Copyright © Siemens AG 2019.
Reservados todos los derechos

Índice
1

Principios básicos de la programación .......................................................................................................35
1.1

Sistema operativo y programa de usuario .............................................................................35

1.2
1.2.1
1.2.2
1.2.3
1.2.4
1.2.5
1.2.6
1.2.7
1.2.8
1.2.9
1.2.10
1.2.11
1.2.11.1
1.2.11.2

Bloques del programa de usuario ..........................................................................................36
Programación lineal y estructurada........................................................................................36
Sinopsis de los tipos de bloques............................................................................................38
Bloques de organización (OB) ...............................................................................................39
Funciones (FC) ......................................................................................................................39
Bloques de función (FB).........................................................................................................40
Bloques de datos globales (DB).............................................................................................41
Bloques de datos ARRAY globales (DB) ...............................................................................43
Ejemplo de uso de bloques de datos ARRAY........................................................................43
Bloques de datos instancia ....................................................................................................52
Bloques de datos de CPU......................................................................................................52
Bloques con acceso optimizado.............................................................................................54
Fundamentos del acceso a bloques ......................................................................................54
Ajustar el acceso a un bloque ................................................................................................56

1.3
1.3.1
1.3.2
1.3.3
1.3.3.1
1.3.3.2
1.3.3.3
1.3.3.4
1.3.3.5
1.3.4
1.3.4.1
1.3.4.2
1.3.4.3
1.3.4.4
1.3.4.5

Llamadas de bloque...............................................................................................................59
Principios básicos de las llamadas de bloque........................................................................59
Jerarquía de llamada .............................................................................................................60
Instancias ...............................................................................................................................61
Principios básicos de las instancias.......................................................................................61
Instancias individuales ...........................................................................................................62
Multiinstancias........................................................................................................................64
Instancias de parámetro.........................................................................................................67
Ejemplos de uso de instancias de parámetros ......................................................................71
Transferencia de parámetros en la llamada de un bloque.....................................................80
Reglas para el suministro de parámetros de bloque..............................................................80
Asignar valores a parámetros de funciones...........................................................................82
Asignar valores a parámetros de bloques de función ............................................................85
Transferencia de parámetros como copia o puntero .............................................................86
Reenviar parámetros de bloque.............................................................................................89

1.4
1.4.1
1.4.2
1.4.3
1.4.4
1.4.4.1
1.4.4.2
1.4.4.3
1.4.4.4
1.4.5
1.4.5.1
1.4.5.2
1.4.5.3

Utilizar y direccionar operandos.............................................................................................95
Fundamentos de los operandos.............................................................................................95
Palabras clave........................................................................................................................95
Variables ..............................................................................................................................102
Constantes ...........................................................................................................................103
Principios básicos de las constantes ...................................................................................103
Declaración de nombres simbólicos para constantes..........................................................105
Tipos de datos de las constantes.........................................................................................106
Ejemplos de uso de constantes ...........................................................................................108
Direccionar operandos .........................................................................................................109
Direccionar variables globales .............................................................................................109
Direccionar variables en bloques de datos ..........................................................................112
Direccionar operandos de modo indirecto ...........................................................................121

Programación del PLC
Manual de programación y manejo, 11/2019

5

Índice

2

3

6

1.5
1.5.1

Señalización de estructuras para el intercambio de datos...................................................143
Bytes de relleno cuando se usan tipos de datos estructurados...........................................143

1.6
1.6.1
1.6.2
1.6.3
1.6.3.1
1.6.3.2
1.6.3.3
1.6.3.4
1.6.3.5
1.6.3.6
1.6.3.7
1.6.4
1.6.5
1.6.6

Tratamiento de errores de ejecución del programa .............................................................145
Causas de error ...................................................................................................................145
Sinopsis de los mecanismos para el tratamiento de errores ...............................................149
Mecanismo EN/ENO ............................................................................................................152
Principios básicos del mecanismo EN/ENO ........................................................................152
Mecanismo EN/ENO en KOP ..............................................................................................154
Mecanismo EN/ENO en FUP...............................................................................................159
Mecanismo EN/ENO en AWL ..............................................................................................164
Mecanismo EN/ENO en SCL ...............................................................................................167
Mecanismo EN/ENO en GRAPH .........................................................................................171
Mecanismo EN/ENO en bloques programados en distintos lenguajes................................173
Evaluación de errores con el parámetro de salida RET_VAL ..............................................174
Uso de las instrucciones GET_ERROR y GET_ERR_ID .....................................................178
Ejemplo de tratamiento de errores de ejecución del programa ...........................................180

1.7
1.7.1
1.7.1.1
1.7.1.2
1.7.1.3
1.7.2
1.7.2.1
1.7.2.2
1.7.3
1.7.3.1
1.7.3.2

Control del flujo de programa...............................................................................................184
Palabra de datos en S7-300/S7-400....................................................................................184
Principios básicos de la palabra de estado..........................................................................184
Activar el bit de estado.........................................................................................................186
Consultar el bit de estado en AWL.......................................................................................195
Palabra de datos S7-1500 ...................................................................................................198
Principios básicos de la palabra de estado..........................................................................198
Consulta y activación de los bits de estado en AWL ...........................................................199
Master Control Relay ...........................................................................................................203
El MCR (Master Control Relay)............................................................................................203
Indicaciones importantes sobre el uso de la función MCR ..................................................204

Recomendaciones de programación........................................................................................................207
2.1

Resumen de las nuevas funciones de la CPU S7-1200/1500 y recomendaciones de
programación .......................................................................................................................207

2.2

Direccionamiento simbólico .................................................................................................211

2.3

Direccionar indirectamente elementos de ARRAY ..............................................................213

2.4

Uso del tipo de datos DB_ANY ............................................................................................216

2.5

Uso de tipos de datos PLC (UDT)........................................................................................232

2.6

Uso de instrucciones MOVE en AWL ..................................................................................235

2.7

Uso de temporizadores y contadores CEI ...........................................................................237

Tipos de datos ..........................................................................................................................................241
3.1

Vista general de los tipos de datos válidos ..........................................................................241

3.2
3.2.1
3.2.2
3.2.2.1
3.2.2.2
3.2.2.3
3.2.2.4

Números binarios .................................................................................................................245
BOOL (bit) ............................................................................................................................245
Secuencias de bits ...............................................................................................................246
BYTE....................................................................................................................................246
WORD..................................................................................................................................247
DWORD ...............................................................................................................................248
LWORD................................................................................................................................250

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

3.3
3.3.1
3.3.2
3.3.3
3.3.4
3.3.5
3.3.6
3.3.7
3.3.8

Enteros.................................................................................................................................251
SINT (enteros de 8 bits) .......................................................................................................251
USINT (enteros de 8 bits) ....................................................................................................252
INT (enteros de 16 bits) .......................................................................................................253
UINT (enteros de 16 bits).....................................................................................................254
DINT (enteros de 32 bits).....................................................................................................255
UDINT (enteros de 32 bits) ..................................................................................................256
LINT (enteros de 64 bits) .....................................................................................................257
ULINT (enteros de 64 bits)...................................................................................................259

3.4
3.4.1
3.4.2
3.4.3

Números en coma flotante ...................................................................................................261
REAL....................................................................................................................................261
LREAL..................................................................................................................................262
Números en coma flotante no válidos..................................................................................263

3.5
3.5.1
3.5.2
3.5.3

Temporizadores ...................................................................................................................265
S5TIME (tiempo) ..................................................................................................................265
TIME (tiempo IEC) ...............................................................................................................266
LTIME (temporizador CEI) ...................................................................................................267

3.6
3.6.1
3.6.2
3.6.3
3.6.4
3.6.5
3.6.6

Fecha y hora ........................................................................................................................268
DATE....................................................................................................................................268
TOD (TIME_OF_DAY)..........................................................................................................268
LTOD (LTIME_OF_DAY)......................................................................................................269
DT (DATE_AND_TIME) .......................................................................................................269
LDT (DATE_AND_LTIME) ...................................................................................................271
DTL ......................................................................................................................................271

3.7
3.7.1
3.7.1.1
3.7.1.2
3.7.2
3.7.2.1
3.7.2.2
3.7.2.3
3.7.2.4
3.7.2.5

Cadenas de caracteres ........................................................................................................273
Carácter ...............................................................................................................................273
CHAR ...................................................................................................................................273
WCHAR................................................................................................................................273
Cadenas de caracteres ........................................................................................................274
STRING................................................................................................................................274
Estructura de una variable STRING.....................................................................................277
WSTRING ............................................................................................................................277
Direccionamiento de caracteres individuales de un STRING o WSTRING .........................280
Transferir variable del tipo de datos STRING o WSTRING .................................................282

3.8
3.8.1
3.8.2
3.8.3

Tipos de datos PLC (UDT)...................................................................................................283
Principios básicos de los tipos de datos PLC (UDT)............................................................283
Transferir variable del tipo de datos PLC (UDT) ..................................................................286
Direccionar tipos de datos PLC (UDT).................................................................................287

3.9
3.9.1
3.9.2
3.9.3
3.9.4

Estructura de datos STRUCT (estructuras anónimas).........................................................288
Principios básicos de STRUCT............................................................................................288
Estructura de una variable STRUCT....................................................................................290
Direccionamiento de componentes STRUCT ......................................................................291
Transferir variables del tipo de datos STRUCT ...................................................................292

3.10
3.10.1
3.10.2
3.10.3
3.10.4

ARRAY.................................................................................................................................293
Principios básicos del ARRAY .............................................................................................293
Estructura de una variable ARRAY......................................................................................298
Direccionar componentes de ARRAY ..................................................................................299
Transferir variables del tipo de datos ARRAY / ARRAY[*]...................................................302

Programación del PLC
Manual de programación y manejo, 11/2019

7

Índice

8

3.10.5
3.10.5.1
3.10.5.2

Ejemplos de uso de ARRAYs ..............................................................................................306
Ejemplo de ARRAY multidimensional ..................................................................................306
Ejemplo de cálculo del producto escalar de dos vectores con ARRAY[*]............................307

3.11
3.11.1
3.11.1.1
3.11.1.2
3.11.1.3
3.11.1.4
3.11.1.5
3.11.1.6
3.11.1.7
3.11.1.8
3.11.1.9
3.11.2
3.11.2.1
3.11.2.2
3.11.2.3
3.11.2.4
3.11.2.5
3.11.2.6
3.11.2.7
3.11.3
3.11.4

Puntero.................................................................................................................................310
Referencias ..........................................................................................................................310
Principios básicos de las referencias ...................................................................................310
Declarar referencias.............................................................................................................314
Referenciar...........................................................................................................................316
Desreferenciar......................................................................................................................320
Instrucciones estándar con referencias ...............................................................................322
Intento de asignación de VARIANT a una referencia ..........................................................325
Transferir referencias como parámetros de bloque .............................................................327
Ejemplo: Transferencia de variables de diferentes tipos de datos mediante referencias ....330
Ejemplo: Retornar datos por referencia al bloque invocante ...............................................332
VARIANT..............................................................................................................................335
Principios básicos de VARIANT...........................................................................................335
Comparación de casos de aplicación para punteros ...........................................................337
Instrucciones VARIANT .......................................................................................................339
Posibilidades de uso de instrucciones VARIANT.................................................................340
Inicializar VARIANT..............................................................................................................342
Transferencia y lectura de diferentes tipos de datos con VARIANT ....................................343
Ejemplos de uso del tipo de datos VARIANT.......................................................................344
POINTER .............................................................................................................................353
ANY......................................................................................................................................356

3.12
3.12.1

Tipos de parámetros ............................................................................................................359
Tipos de parámetros ............................................................................................................359

3.13
3.13.1

Tipos de datos de sistema ...................................................................................................360
Tipos de datos de sistema ...................................................................................................360

3.14
3.14.1

Tipos de datos de hardware.................................................................................................363
Tipos de datos de hardware.................................................................................................363

3.15
3.15.1
3.15.2
3.15.2.1
3.15.2.2
3.15.2.3
3.15.2.4
3.15.2.5
3.15.2.6
3.15.2.7
3.15.3
3.15.3.1
3.15.3.2
3.15.3.3
3.15.3.4
3.15.3.5
3.15.3.6

Conversión de los tipos de datos en el S7-1500..................................................................366
Sinopsis de la conversión de tipos de datos ........................................................................366
Conversiones implícitas .......................................................................................................368
Activar o desactivar la verificación CEI ................................................................................368
Números binarios .................................................................................................................369
Enteros.................................................................................................................................378
Números en coma flotante ...................................................................................................393
Tiempos ...............................................................................................................................397
Fecha y hora ........................................................................................................................403
Cadenas de caracteres ........................................................................................................415
Conversiones explícitas .......................................................................................................422
Números binarios .................................................................................................................422
Enteros.................................................................................................................................438
Números en coma flotante ...................................................................................................467
Tiempos ...............................................................................................................................473
Fecha y hora ........................................................................................................................481
Cadenas de caracteres ........................................................................................................497

3.16
3.16.1

Conversión de los tipos de datos en el S7-1200..................................................................506
Sinopsis de la conversión de tipos de datos ........................................................................506

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

4

3.16.2
3.16.2.1
3.16.2.2
3.16.2.3
3.16.2.4
3.16.2.5
3.16.2.6
3.16.2.7
3.16.3
3.16.3.1
3.16.3.2
3.16.3.3
3.16.3.4
3.16.3.5
3.16.3.6

Conversiones implícitas .......................................................................................................508
Activar o desactivar la verificación CEI ................................................................................508
Números binarios .................................................................................................................509
Enteros.................................................................................................................................513
Números en coma flotante ...................................................................................................519
Temporizadores ...................................................................................................................521
Fecha y hora ........................................................................................................................522
Cadenas de caracteres ........................................................................................................525
Conversiones explícitas .......................................................................................................529
Números binarios .................................................................................................................529
Enteros.................................................................................................................................539
Números en coma flotante ...................................................................................................559
Temporizadores ...................................................................................................................565
Fecha y hora ........................................................................................................................567
Cadenas de caracteres ........................................................................................................571

3.17
3.17.1
3.17.2
3.17.2.1
3.17.2.2
3.17.2.3
3.17.2.4
3.17.2.5
3.17.2.6
3.17.2.7
3.17.3
3.17.3.1
3.17.3.2
3.17.3.3
3.17.3.4
3.17.3.5
3.17.3.6
3.17.3.7

Conversión de tipos de datos en el S7-300/S7-400.............................................................576
Sinopsis de las conversiones de tipos de datos ..................................................................576
Conversiones implícitas .......................................................................................................579
Activar o desactivar la verificación CEI ................................................................................579
Números binarios .................................................................................................................579
Enteros.................................................................................................................................583
Números en coma flotante ...................................................................................................584
Temporizadores ...................................................................................................................585
Fecha y hora ........................................................................................................................587
Cadenas de caracteres ........................................................................................................589
Conversiones explícitas .......................................................................................................590
Números binarios .................................................................................................................590
Enteros.................................................................................................................................599
Números en coma flotante ...................................................................................................605
Temporizadores ...................................................................................................................606
Fecha y hora ........................................................................................................................608
Cadenas de caracteres ........................................................................................................611
Otras funciones de conversión.............................................................................................613

Instrucciones ............................................................................................................................................615
4.1
4.1.1
4.1.1.1
4.1.1.2
4.1.2
4.1.2.1
4.1.3
4.1.3.1
4.1.3.2
4.1.3.3
4.1.3.4
4.1.3.5
4.1.4
4.1.4.1
4.1.4.2
4.1.4.3

Instrucciones ........................................................................................................................615
Librerías de ejemplo.............................................................................................................615
Sample Library for Instructions ............................................................................................615
Library of General Functions................................................................................................617
Instrucciones que funcionan asíncronamente......................................................................618
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente ...................................................................................................................618
Instrucciones básicas...........................................................................................................621
KOP......................................................................................................................................621
FUP ......................................................................................................................................993
AWL ...................................................................................................................................1366
SCL ....................................................................................................................................1762
GRAPH ..............................................................................................................................2032
Instrucciones avanzadas....................................................................................................2233
Indicaciones generales sobre las instrucciones avanzadas ..............................................2233
Fecha y hora ......................................................................................................................2234
String + Char ......................................................................................................................2271

Programación del PLC
Manual de programación y manejo, 11/2019

9

Índice

4.1.4.4
4.1.4.5
4.1.4.6
4.1.4.7
4.1.4.8
4.1.4.9
4.1.4.10
4.1.4.11
4.1.4.12
4.1.4.13
4.1.4.14
4.1.4.15
4.1.4.16
4.1.5
4.1.5.1
4.1.5.2
4.1.5.3
4.1.5.4
4.1.5.5
4.1.5.6
4.1.6
4.1.6.1
4.1.6.2
4.1.6.3
4.1.6.4
4.1.6.5
4.1.6.6
4.1.7
4.1.7.1

Memoria imagen de proceso..............................................................................................2365
Periferia descentralizada....................................................................................................2375
PROFIenergy .....................................................................................................................2555
Parametrización del módulo...............................................................................................2612
Alarmas ..............................................................................................................................2625
Avisos.................................................................................................................................2715
Diagnóstico ........................................................................................................................2767
Impulso...............................................................................................................................2845
Recetas y Data Logging.....................................................................................................2849
Funciones de bloques de datos .........................................................................................2915
Direccionamiento ...............................................................................................................2943
File Handling ......................................................................................................................2964
Sistema R/H .......................................................................................................................2976
Tecnología .........................................................................................................................2979
Motion Control....................................................................................................................2979
Contadores rápidos............................................................................................................3603
Contaje y medición (S7-1500)............................................................................................3608
Control PID.........................................................................................................................3626
Time-based IO ...................................................................................................................3908
SINAMICS - TO_BasicPos.................................................................................................3940
Comunicación ....................................................................................................................3942
Comunicación S7 ...............................................................................................................3942
Open User Communication................................................................................................3978
OPC UA .............................................................................................................................4151
Servidor web ......................................................................................................................4354
Procesador de comunicaciones .........................................................................................4364
TeleService ........................................................................................................................4685
Paquetes opcionales..........................................................................................................4693
SIMATIC Ident....................................................................................................................4693

4.2
4.2.1
4.2.1.1

Instrucciones ......................................................................................................................4813
Instrucciones que funcionan asíncronamente....................................................................4813
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente .................................................................................................................4813
Instrucciones básicas.........................................................................................................4817
KOP....................................................................................................................................4817
FUP ....................................................................................................................................5033
AWL ...................................................................................................................................5254
SCL ....................................................................................................................................5550
GRAPH ..............................................................................................................................5701
Instrucciones avanzadas....................................................................................................5835
Fecha y hora ......................................................................................................................5835
String + Char ......................................................................................................................5868
Memoria imagen de proceso..............................................................................................5881
Periferia descentralizada....................................................................................................5888
PROFIenergy .....................................................................................................................5973
Parametrización del módulo...............................................................................................6026
Alarmas ..............................................................................................................................6038
Avisos.................................................................................................................................6065
Diagnóstico ........................................................................................................................6114
Funciones de bloques de datos .........................................................................................6189
Funciones de tabla.............................................................................................................6202
Direccionamiento ...............................................................................................................6225

4.2.2
4.2.2.1
4.2.2.2
4.2.2.3
4.2.2.4
4.2.2.5
4.2.3
4.2.3.1
4.2.3.2
4.2.3.3
4.2.3.4
4.2.3.5
4.2.3.6
4.2.3.7
4.2.3.8
4.2.3.9
4.2.3.10
4.2.3.11
4.2.3.12

10

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

4.2.3.13
4.2.4
4.2.4.1
4.2.4.2
4.2.4.3
4.2.4.4
4.2.5
4.2.5.1
4.2.5.2
4.2.5.3
4.2.5.4
4.2.5.5
4.2.5.6
4.2.5.7
4.2.5.8
4.2.5.9
4.2.5.10
4.2.5.11
5

Otras funciones ..................................................................................................................6234
Tecnología .........................................................................................................................6236
Control PID.........................................................................................................................6236
Motion Control....................................................................................................................6489
Módulos de función ............................................................................................................6552
Funciones 300C .................................................................................................................6792
Comunicación ....................................................................................................................6824
Información común de parámetros y errores .....................................................................6824
Comunicación S7 ...............................................................................................................6829
Open User Communication................................................................................................6887
Servidor web ......................................................................................................................6944
Comunicación adicional .....................................................................................................6946
Procesador de comunicaciones .........................................................................................7002
Funciones 300C .................................................................................................................7586
Comunicación con iSlave/iDevice ......................................................................................7606
PROFINET CBA.................................................................................................................7612
Comunicación MPI .............................................................................................................7617
TeleService ........................................................................................................................7628

Editor de programación ..........................................................................................................................7657
5.1

Sinopsis del editor de programación..................................................................................7657

5.2

Comandos de teclado del editor de programación ............................................................7661

5.3

Ampliar la superficie de la ventana de programación ........................................................7666

5.4

Ajustar los nemónicos ........................................................................................................7668

5.5

Mostrar operandos simbólicos y absolutos ........................................................................7669

5.6

Buscar instrucciones ..........................................................................................................7670

5.7

Edición de textos de proyectos multilingües en bloques....................................................7671

5.8
5.8.1
5.8.2
5.8.3

Utilizar versiones de instrucciones.....................................................................................7673
Principios básicos de las versiones de instrucciones ........................................................7673
Actualizar proyecto e instrucciones....................................................................................7675
Actualizar el programa de la CPU actual ...........................................................................7676

5.9
5.9.1
5.9.2
5.9.3
5.9.4
5.9.5

Utilizar perfiles de instrucciones.........................................................................................7677
Principios básicos de los perfiles de instrucciones ............................................................7677
Crear un perfil de instrucciones .........................................................................................7677
Abrir y editar un perfil de instrucciones ..............................................................................7679
Activar y desactivar un perfil de instrucciones ...................................................................7680
Borrar un perfil de instrucciones ........................................................................................7681

5.10
5.10.1
5.10.2

Utilizar la función automática de autocompletar ................................................................7682
Principios básicos de la función automática de autocompletar..........................................7682
Utilizar la función automática de autocompletar en los lenguajes de programación
gráficos...............................................................................................................................7683
Utilizar la función automática de autocompletar en los lenguajes de programación
textuales.............................................................................................................................7684

5.10.3
5.11
5.11.1
5.11.2

Configuración general de la programación PLC ................................................................7685
Sinopsis de la configuración general .................................................................................7685
Modificar la configuración ..................................................................................................7688

5.12

Corregir errores de sintaxis en el programa.......................................................................7688

Programación del PLC
Manual de programación y manejo, 11/2019

11

Índice

6

7

12

5.12.1
5.12.2

Principios básicos de los errores de sintaxis .....................................................................7688
Buscar errores de sintaxis en el programa ........................................................................7689

5.13
5.13.1
5.13.2

Cambiar el lenguaje de programación ...............................................................................7690
Reglas para cambiar el lenguaje de programación............................................................7690
Cambiar el lenguaje de programación ...............................................................................7690

Utilización de las Software Units ............................................................................................................7693
6.1
6.1.1
6.1.2
6.1.3

Principios básicos de las Software Units ...........................................................................7693
Introducción a las Software Units.......................................................................................7693
Creación de programas de PLC en Software Units ...........................................................7697
Estructuras de programa posibles con Software Units ......................................................7700

6.2
6.2.1
6.2.2
6.2.3
6.2.4
6.2.5
6.2.6
6.2.7
6.2.8

Creación y administración de Software Units ....................................................................7704
Creación de Software Units ...............................................................................................7704
Cambiar el nombre de las Software Units..........................................................................7704
Copiar e insertar Software Units ........................................................................................7705
Borrar Software Units.........................................................................................................7706
Reglas para elementos de programa en Software Units ...................................................7707
Copiar o mover elementos de programa............................................................................7709
Mostrar y modificar las propiedades de una Software Unit................................................7710
Administración de elementos de Software Units en librerías.............................................7711

6.3
6.3.1
6.3.2
6.3.3

Crear relaciones.................................................................................................................7712
Principios básicos de las relaciones ..................................................................................7712
Publicación de elementos del programa ............................................................................7714
Crear relaciones.................................................................................................................7715

6.4
6.4.1
6.4.2
6.4.3
6.4.3.1
6.4.3.2
6.4.3.3
6.4.3.4

Compilación y carga de Software Units .............................................................................7717
Fundamentos sobre la compilación y carga de Software Units .........................................7717
Compilación de Software Units ..........................................................................................7719
Carga de Software Units ....................................................................................................7720
Carga de Software Units en un dispositivo ........................................................................7720
Carga de Software Units de un dispositivo ........................................................................7722
Carga de Software Units en una Memory Card .................................................................7723
Carga de Software Units desde una Memory Card ...........................................................7724

Creación y gestión de bloques ...............................................................................................................7727
7.1
7.1.1
7.1.2
7.1.3
7.1.4
7.1.5
7.1.6
7.1.6.1
7.1.6.2
7.1.7
7.1.8

Crear bloques.....................................................................................................................7727
Carpeta de bloques............................................................................................................7727
Crear bloques de organización ..........................................................................................7728
Crear funciones y bloques de función................................................................................7729
Crear bloques de datos......................................................................................................7730
Utilizar bloques de librerías................................................................................................7731
Copiar o mover bloques .....................................................................................................7733
Principios básicos sobre la copia de bloques ....................................................................7733
Copiar o mover bloques .....................................................................................................7736
Introducir el título del bloque ..............................................................................................7737
Introducir el comentario de bloque.....................................................................................7738

7.2
7.2.1
7.2.2
7.2.3
7.2.4

Definir propiedades de bloques .........................................................................................7739
Principios básicos de las propiedades de bloques ...........................................................7739
Sinopsis de las propiedades de bloques............................................................................7740
Sellos de tiempo de bloques ..............................................................................................7745
Mostrar y editar propiedades de bloques...........................................................................7747

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

8

9

7.3
7.3.1
7.3.2
7.3.3
7.3.4
7.3.5
7.3.6
7.3.7

Gestionar bloques ..............................................................................................................7748
Abrir bloques ......................................................................................................................7748
Guardar bloques ................................................................................................................7750
Cerrar bloques ...................................................................................................................7750
Cambiar el nombre de bloques ..........................................................................................7751
Borrar bloques offline .........................................................................................................7752
Borrar bloques online .........................................................................................................7752
Borrar bloques de datos de CPU .......................................................................................7753

7.4
7.4.1
7.4.2
7.4.3
7.4.4
7.4.5
7.4.6

Utilizar archivos fuente externos ........................................................................................7754
Principios básicos de la utilización de archivos fuente externos........................................7754
Reglas para la programación de archivos fuente externos ...............................................7756
Guardar un bloque como archivo fuente externo...............................................................7757
Integrar archivos fuente externos.......................................................................................7759
Abrir y editar archivos fuente externos...............................................................................7759
Generar bloques a partir de archivos fuente externos .......................................................7760

Protección de bloques ............................................................................................................................7763
8.1

Proteger bloques................................................................................................................7763

8.2

Vincular un proveedor de contraseñas ..............................................................................7766

8.3

Mostrar proveedores de contraseñas disponibles .............................................................7768

8.4

Registrar actividades de los proveedores de contraseñas ................................................7769

8.5

Definir el tipo de asignación de contraseñas .....................................................................7770

8.6

Establecer y quitar la protección contra copia de un bloque..............................................7771

8.7

Establecer y quitar la protección contra escritura de bloques............................................7773

8.8

Configurar la protección de know-how para bloques .........................................................7776

8.9

Abrir bloques con protección de know-how .......................................................................7777

8.10

Imprimir bloques con protección de know-how ..................................................................7778

8.11

Cambiar la contraseña .......................................................................................................7779

8.12

Quitar la protección de know-how para los bloques ..........................................................7780

Declaración de la interfaz del bloque .....................................................................................................7783
9.1

Descripción de la interfaz de bloque ..................................................................................7783

9.2
9.2.1
9.2.2
9.2.3
9.2.4

Reglas de la declaración de la interfaz del bloque.............................................................7785
Reglas generales de la declaración de la interfaz del bloque............................................7785
Tipos de datos válidos en la interfaz de bloque .................................................................7786
Tipos de datos válidos en la interfaz de bloque .................................................................7787
Remanencia de las variables locales.................................................................................7789

9.3

Seleccionar representación tabular o textual de la interfaz del bloque..............................7790

9.4
9.4.1
9.4.2
9.4.3
9.4.4
9.4.5

Declaración de la interfaz de bloque..................................................................................7791
Estructura de la interfaz de bloque ....................................................................................7791
Declarar variables y constantes locales en la interfaz del bloque......................................7793
Declarar una variable local en el editor de programación..................................................7794
Declarar variables del tipo de datos ARRAY .....................................................................7796
Declarar variables del tipo de datos STRUCT ...................................................................7798

Programación del PLC
Manual de programación y manejo, 11/2019

13

Índice

10

14

9.4.6
9.4.7
9.4.8
9.4.9
9.4.10
9.4.11
9.4.12
9.4.13
9.4.13.1
9.4.13.2
9.4.13.3
9.4.13.4
9.4.13.5
9.4.13.6

Declaración de variables del tipo de datos STRING y WSTRING .....................................7799
Declarar variables basadas en un tipo de datos PLC ........................................................7800
Declarar variables superpuestas........................................................................................7801
Declarar multiinstancias .....................................................................................................7802
Declaración de instancias de parámetro............................................................................7803
Ocultar parámetros en la llamada del bloque ....................................................................7804
Declarar parámetros actuales predefinidos .......................................................................7805
Edición de la tabla de la interfaz de bloque .......................................................................7806
Insertar filas en la tabla ......................................................................................................7806
Agregar filas en la tabla .....................................................................................................7806
Borrar variables..................................................................................................................7807
Rellenar celdas consecutivas automáticamente ................................................................7807
Mostrar y ocultar las columnas de la tabla.........................................................................7807
Editar variables con editores externos ...............................................................................7808

9.5
9.5.1
9.5.2
9.5.3
9.5.4
9.5.5
9.5.6
9.5.7
9.5.8
9.5.9
9.5.10
9.5.11
9.5.12
9.5.13

Declaración de la interfaz de bloque en la vista de texto...................................................7809
Estructura de la interfaz de bloque textual.........................................................................7809
Declaración de bloque y valor de retorno ..........................................................................7810
Secciones de declaración ..................................................................................................7811
Declaración de variables e inicialización............................................................................7812
Declaración de STRUCT....................................................................................................7813
Declaración de ARRAY......................................................................................................7816
Declaración de STRING y WSTRING................................................................................7820
Declaración de instancias ..................................................................................................7821
Atributos para variables .....................................................................................................7822
Comentarios.......................................................................................................................7823
Edición de la interfaz de bloque textual .............................................................................7824
Restablecimiento de la interfaz estándar de un bloque de organización...........................7826
Ejemplo de una interfaz de bloque textual .........................................................................7827

9.6
9.6.1
9.6.2
9.6.3

Editar las propiedades de variables y constantes locales..................................................7829
Propiedades de variables y constantes locales .................................................................7829
Cambiar las propiedades de variables y constantes locales .............................................7831
Editar comentarios multilingües en la interfaz del bloque ..................................................7833

9.7

Actualizar la interfaz del bloque ........................................................................................7834

9.8

Ampliar una interfaz de bloque ..........................................................................................7836

Programación de bloques de datos........................................................................................................7839
10.1

Principios básicos de la programación de bloques de datos .............................................7839

10.2

Estructura de la tabla de declaración de bloques de datos ...............................................7841

10.3

Crear bloques de datos......................................................................................................7843

10.4

Actualizar bloques de datos ...............................................................................................7845

10.5

Ampliar bloques de datos...................................................................................................7846

10.6
10.6.1
10.6.2
10.6.3
10.6.4
10.6.5

Programar la estructura de datos de bloques de datos globales.......................................7847
Declarar variables del tipo de datos simple .......................................................................7847
Declarar variables del tipo de datos ARRAY .....................................................................7848
Declarar variables del tipo de datos STRUCT ...................................................................7850
Declaración de variables del tipo de datos STRING..........................................................7851
Declarar variables basadas en un tipo de datos PLC ........................................................7852

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

11

10.7
10.7.1
10.7.2

Definir valores de arranque................................................................................................7853
Principios básicos de los valores de arranque...................................................................7853
Definir valores de arranque................................................................................................7854

10.8
10.8.1
10.8.2
10.8.3

Ajustar remanencia ............................................................................................................7855
Remanencia de variables en bloques de datos .................................................................7855
Ajustar la remanencia en un bloque de datos de instancia................................................7855
Ajustar la remanencia en un bloque de datos global .........................................................7856

10.9
10.9.1
10.9.2
10.9.3
10.9.4

Editar las propiedades de las variables en bloques de datos ............................................7857
Propiedades de variables en bloques de datos .................................................................7857
Modificar propiedades de las variables en bloques de datos de instancia ........................7861
Modificar propiedades de las variables en bloques de datos globales ..............................7862
Editar comentarios multilingües en el bloque de datos......................................................7863

10.10
10.10.1
10.10.2
10.10.3
10.10.4
10.10.5
10.10.6
10.10.7

Editar la tabla de declaración de bloques de datos ...........................................................7865
Insertar filas en la tabla ......................................................................................................7865
Agregar filas en la tabla .....................................................................................................7865
Borrar variables..................................................................................................................7865
Rellenar celdas consecutivas automáticamente ................................................................7866
Navegar hasta las definiciones ..........................................................................................7867
Mostrar y ocultar las columnas de la tabla.........................................................................7867
Editar variables con editores externos ...............................................................................7868

10.11
10.11.1
10.11.2
10.11.3
10.11.4
10.11.5
10.11.6
10.11.7
10.11.8
10.11.9
10.11.9.1
10.11.9.2
10.11.9.3
10.11.9.4

Funciones online y de diagnóstico para bloques de datos ................................................7869
Editar bloques de datos en modo online............................................................................7869
Relación de las funciones online y de diagnóstico en bloques de datos ...........................7871
Observar variables .............................................................................................................7873
Forzar variables .................................................................................................................7873
Cargar valores de arranque como valores actuales ..........................................................7874
Crear una instantánea de los valores actuales ..................................................................7876
Cargar instantáneas como valores actuales ......................................................................7878
Copiar la instantánea en los valores de arranque..............................................................7880
Utilizar valores de ajuste durante la puesta en marcha .....................................................7882
Principios básicos para adaptar los valores de ajuste durante la puesta en marcha ........7882
Marcar datos como valores ajustables...............................................................................7883
Inicializar valores de ajuste en el programa online ............................................................7884
Aplicar valores del programa online como valores de arranque ........................................7885

Declaración de variables PLC ................................................................................................................7889
11.1

Sinopsis de las tablas de variables PLC ............................................................................7889

11.2

Estructura de la tablas de variables PLC ...........................................................................7890

11.3
11.3.1
11.3.2

Reglas para variables PLC ................................................................................................7892
Nombres de variables PLC permitidos...............................................................................7892
Direcciones y tipos de datos admisibles para variables PLC.............................................7893

11.4
11.4.1
11.4.2
11.4.3
11.4.4

Crear y gestionar tablas de variables PLC.........................................................................7896
Crear tablas de variables PLC ...........................................................................................7896
Abrir la tabla de variables PLC...........................................................................................7897
Copiar o mover tablas de variables PLC............................................................................7898
Agrupar tablas de variables PLC .......................................................................................7898

11.5
11.5.1

Declarar variables PLC ......................................................................................................7899
Introducir la declaración de variables PLC.........................................................................7899

Programación del PLC
Manual de programación y manejo, 11/2019

15

Índice

12

16

11.5.1.1
11.5.1.2
11.5.2
11.5.2.1
11.5.2.2
11.5.2.3

Declarar variables en la tabla de variables PLC ................................................................7899
Declarar variables PLC en el editor de programación .......................................................7900
Ajustar la remanencia de variables PLC ............................................................................7902
Comportamiento remanente de variables PLC ..................................................................7902
Ajustar el comportamiento remanente de variables PLC...................................................7902
Ajustar el comportamiento remanente de variables PLC...................................................7903

11.6
11.6.1
11.6.2

Agrupar variables PLC en estructuras para entradas y salidas .........................................7904
Información importante sobre variables PLC estructuradas ..............................................7904
Crear variables PLC estructuradas ....................................................................................7907

11.7
11.7.1
11.7.2
11.7.3

Declarar constantes globales.............................................................................................7908
Reglas para constantes de usuario globales .....................................................................7908
Reglas para constantes de sistema globales.....................................................................7909
Declarar constantes globales.............................................................................................7910

11.8
11.8.1
11.8.1.1
11.8.1.2
11.8.2
11.8.2.1
11.8.2.2
11.8.3
11.8.3.1
11.8.3.2
11.8.4

Editar propiedades .............................................................................................................7911
Editar las propiedades de variables PLC ...........................................................................7911
Propiedades de variables PLC...........................................................................................7911
Editar las propiedades de variables PLC ...........................................................................7912
Editar propiedades de las constantes globales..................................................................7913
Propiedades de las constantes globales............................................................................7913
Editar propiedades de las constantes globales..................................................................7913
Editar propiedades de tablas de variables PLC .................................................................7914
Propiedades de tablas de variables PLC ...........................................................................7914
Editar propiedades de tablas de variables PLC .................................................................7914
Editar comentarios multilingües en la tabla de variables PLC ...........................................7914

11.9
11.9.1

Observar variables PLC .....................................................................................................7915
Observar variables PLC .....................................................................................................7915

11.10
11.10.1
11.10.2
11.10.3
11.10.4
11.10.5
11.10.6
11.10.7
11.10.8
11.10.9
11.10.9.1
11.10.9.2
11.10.9.3
11.10.9.4
11.10.9.5
11.10.9.6
11.10.9.7

Editar tablas de variables PLC...........................................................................................7917
Insertar filas en la tabla de variables PLC..........................................................................7917
Copiar entradas de la tabla de variables PLC....................................................................7917
Borrar entradas de la tabla de variables PLC ....................................................................7918
Ordenar las filas de las tablas de variables PLC ...............................................................7918
Rellenar celdas automáticamente en la tabla de variables PLC........................................7918
Navegar a la vista de dispositivos......................................................................................7919
Navegar hasta las definiciones ..........................................................................................7919
Mostrar y ocultar las columnas de la tabla.........................................................................7920
Exportar e importar variables PLC .....................................................................................7920
Principios básicos para exportar e importar variables PLC ...............................................7920
Formato del archivo de exportación (*.xlsx).......................................................................7921
Formato del archivo de exportación (*.xml) .......................................................................7922
Formato del archivo de exportación (*.sdf) ........................................................................7923
Exportación de variables PLC............................................................................................7923
Importación de variables PLC ............................................................................................7924
Editar variables PLC individuales con editores externos ...................................................7925

Declarar tipos de datos PLC (UDT) .......................................................................................................7927
12.1

Estructura de la tabla de declaración para los tipos de datos PLC....................................7927

12.2

Tipos de datos PLC en el árbol del proyecto ....................................................................7928

12.3

Crear tipos de datos PLC...................................................................................................7929

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

13

12.4

Copiar o mover tipos de datos PLC ...................................................................................7930

12.5

Borrar tipos de datos PLC..................................................................................................7930

12.6

Renumerar tipos de datos PLC..........................................................................................7931

12.7
12.7.1
12.7.2
12.7.3
12.7.4

Programar la estructura de los tipos de datos PLC ...........................................................7932
Declarar variables del tipo de datos simple .......................................................................7932
Declarar variables del tipo de datos ARRAY .....................................................................7932
Declarar variables del tipo de datos STRUCT ..................................................................7934
Declarar variables basadas en otro tipo de datos PLC......................................................7935

12.8
12.8.1
12.8.2
12.8.3

Editar propiedades de variables en tipos de datos PLC ....................................................7936
Propiedades de variables en tipos de datos PLC ..............................................................7936
Modificar propiedades de variables en tipos de datos PLC ...............................................7937
Editar comentarios multilingües en el tipo de datos PLC...................................................7938

12.9
12.9.1
12.9.2
12.9.3
12.9.4
12.9.5

Editar la tabla de declaración para tipos de datos PLC .....................................................7939
Insertar filas en la tabla ......................................................................................................7939
Agregar filas en la tabla .....................................................................................................7939
Borrar variables..................................................................................................................7940
Rellenar celdas consecutivas automáticamente ................................................................7940
Mostrar y ocultar las columnas de la tabla.........................................................................7941

Creación de programas KOP .................................................................................................................7943
13.1
13.1.1
13.1.2

Principios básicos de KOP.................................................................................................7943
Lenguaje de programación KOP........................................................................................7943
Vista general de los elementos KOP .................................................................................7943

13.2
13.2.1
13.2.2

Configuración de KOP .......................................................................................................7946
Sinopsis de la configuración de KOP.................................................................................7946
Modificar la configuración ..................................................................................................7946

13.3
13.3.1
13.3.2
13.3.3
13.3.4
13.3.5
13.3.6
13.3.7
13.3.8
13.3.9

Trabajar con segmentos ....................................................................................................7947
Utilizar segmentos..............................................................................................................7947
Insertar segmentos ............................................................................................................7948
Seleccionar segmentos......................................................................................................7949
Copiar e insertar segmentos ..............................................................................................7950
Borrar segmentos...............................................................................................................7950
Contraer y expandir segmentos .........................................................................................7951
Insertar título del segmento................................................................................................7952
Introducir el comentario del segmento ...............................................................................7953
Navegar en segmentos ......................................................................................................7954

13.4
13.4.1
13.4.2
13.4.3
13.4.4
13.4.5
13.4.5.1
13.4.5.2
13.4.6
13.4.6.1
13.4.6.2
13.4.6.3

Insertar elementos KOP.....................................................................................................7955
Reglas para utilizar elementos KOP ..................................................................................7955
Interconexiones no permitidas en KOP..............................................................................7957
Insertar elementos KOP mediante la Task Card "Instrucciones" .......................................7958
Insertar elementos KOP mediante un cuadro vacío ..........................................................7959
Seleccionar el tipo de datos de un elemento KOP.............................................................7960
Seleccionar un tipo de datos..............................................................................................7960
Definir el tipo de datos de una instrucción .........................................................................7961
Utilizar Favoritos en KOP...................................................................................................7963
Agregar elementos KOP a los favoritos .............................................................................7963
Insertar elementos KOP mediante Favoritos .....................................................................7963
Quitar elementos KOP de los favoritos ..............................................................................7964

Programación del PLC
Manual de programación y manejo, 11/2019

17

Índice

14

13.4.7
13.4.7.1
13.4.7.2
13.4.7.3
13.4.7.4
13.4.8
13.4.8.1
13.4.9
13.4.9.1
13.4.9.2
13.4.9.3
13.4.9.4

Insertar llamadas de bloque en KOP .................................................................................7965
Insertar llamadas de bloque mediante Drag & Drop ..........................................................7965
Actualizar llamadas de bloque en KOP..............................................................................7966
Modificar una llamada de bloque .......................................................................................7968
Cambiar el tipo de instancia...............................................................................................7969
Insertar instrucciones KOP complejas ...............................................................................7970
Utilizar la instrucción "Calcular" .........................................................................................7970
Utilizar comentarios libres ..................................................................................................7971
Principios básicos de la utilización de comentarios libres en KOP ....................................7971
Insertar comentarios libres.................................................................................................7972
Editar comentarios libres....................................................................................................7972
Borrar comentarios libres ...................................................................................................7974

13.5
13.5.1
13.5.2
13.5.3
13.5.4
13.5.5
13.5.6
13.5.7
13.5.8

Editar elementos KOP........................................................................................................7974
Seleccionar elementos KOP ..............................................................................................7974
Copiar elementos KOP ......................................................................................................7975
Cortar elementos KOP .......................................................................................................7976
Insertar elementos KOP desde el portapapeles ................................................................7976
Reemplazar elementos KOP..............................................................................................7977
Insertar entradas y salidas adicionales en los elementos KOP .........................................7978
Quitar entradas y salidas ...................................................................................................7979
Borrar elementos KOP .......................................................................................................7980

13.6
13.6.1
13.6.2
13.6.3

Cablear operandos en instrucciones KOP .........................................................................7981
Cablear operandos.............................................................................................................7981
Cablear parámetros ocultos ...............................................................................................7982
Mostrar u ocultar informaciones de variables ....................................................................7983

13.7
13.7.1
13.7.2
13.7.3
13.7.4
13.7.5

Ramas en KOP ..................................................................................................................7985
Principios básicos de las ramas en KOP ...........................................................................7985
Reglas para ramas en KOP ...............................................................................................7985
Insertar ramas en segmentos KOP....................................................................................7986
Cerrar ramas en segmentos KOP......................................................................................7987
Borrar ramas en segmentos KOP ......................................................................................7987

13.8
13.8.1
13.8.2
13.8.3
13.8.4

Cruces en KOP ..................................................................................................................7988
Principios básicos de los cruces en KOP...........................................................................7988
Insertar cruces ...................................................................................................................7988
Cambiar la posición de cruces ...........................................................................................7989
Borrar cruces......................................................................................................................7989

13.9
13.9.1
13.9.2
13.9.3

Circuitos en KOP................................................................................................................7990
Principios básicos de los circuitos en KOP ........................................................................7990
Insertar un circuito..............................................................................................................7991
Borrar un circuito................................................................................................................7991

13.10
13.10.1
13.10.2
13.10.3
13.10.4
13.10.5

Ejemplos de programación KOP........................................................................................7992
Ejemplo de control de una cinta transportadora ...............................................................7992
Ejemplo de detección del sentido de marcha de una cinta transportadora .......................7994
Ejemplo de detección del nivel de llenado de una zona de almacén ................................7996
Ejemplo de cálculo de una ecuación..................................................................................7999
Ejemplo de control de la temperatura ambiente ................................................................8001

Creación de programas FUP..................................................................................................................8005
14.1

18

Principios básicos de FUP .................................................................................................8005

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

14.1.1
14.1.2

Lenguaje de programación FUP ........................................................................................8005
Vista general de los elementos FUP..................................................................................8005

14.2
14.2.1
14.2.2

Configuración de FUP........................................................................................................8007
Resumen de la configuración de FUP ...............................................................................8007
Modificar la configuración ..................................................................................................8008

14.3
14.3.1
14.3.2
14.3.3
14.3.4
14.3.5
14.3.6
14.3.7
14.3.8
14.3.9

Trabajar con segmentos ....................................................................................................8009
Utilizar segmentos..............................................................................................................8009
Insertar segmentos ............................................................................................................8010
Seleccionar segmentos......................................................................................................8011
Copiar e insertar segmentos ..............................................................................................8011
Borrar segmentos...............................................................................................................8012
Contraer y expandir segmentos .........................................................................................8013
Insertar título del segmento................................................................................................8013
Introducir el comentario del segmento ...............................................................................8015
Navegar en segmentos ......................................................................................................8016

14.4
14.4.1
14.4.2
14.4.3
14.4.4
14.4.4.1
14.4.4.2
14.4.5
14.4.5.1
14.4.5.2
14.4.5.3
14.4.6
14.4.6.1
14.4.6.2
14.4.6.3
14.4.6.4
14.4.7
14.4.7.1
14.4.8
14.4.8.1
14.4.8.2
14.4.8.3
14.4.8.4

Insertar elementos FUP .....................................................................................................8017
Reglas para utilizar elementos FUP...................................................................................8017
Insertar elementos FUP mediante la Task Card "Instrucciones" .......................................8018
Insertar elementos FUP mediante un cuadro vacío...........................................................8019
Seleccionar el tipo de datos de un elemento FUP .............................................................8021
Seleccionar un tipo de datos..............................................................................................8021
Definir el tipo de datos de una instrucción .........................................................................8022
Emplear favoritos en FUP ..................................................................................................8023
Agregar elementos FUP a los Favoritos ............................................................................8023
Insertar elementos FUP mediante Favoritos......................................................................8024
Quitar elementos FUP de los Favoritos .............................................................................8025
Insertar llamadas de bloque en FUP..................................................................................8025
Insertar llamadas de bloque mediante Drag & Drop ..........................................................8025
Actualizar llamadas de bloque en FUP ..............................................................................8027
Modificar una llamada de bloque .......................................................................................8029
Cambiar el tipo de instancia...............................................................................................8029
Insertar instrucciones FUP complejas................................................................................8030
Utilizar la instrucción "Calcular" .........................................................................................8030
Utilizar comentarios libres ..................................................................................................8031
Principios básicos de la utilización de comentarios libres en FUP ...................................8031
Insertar comentarios libres.................................................................................................8032
Editar comentarios libres....................................................................................................8032
Borrar comentarios libres ...................................................................................................8034

14.5
14.5.1
14.5.2
14.5.3
14.5.4
14.5.5
14.5.6
14.5.7
14.5.8

Editar elementos FUP ........................................................................................................8034
Seleccionar elementos FUP...............................................................................................8034
Copiar elementos FUP.......................................................................................................8035
Cortar elementos FUP .......................................................................................................8036
Insertar elementos FUP desde el portapapeles.................................................................8036
Reemplazar elementos FUP ..............................................................................................8037
Insertar entradas y salidas adicionales en los elementos FUP..........................................8038
Quitar entradas y salidas de una instrucción .....................................................................8039
Borrar elementos FUP .......................................................................................................8040

14.6
14.6.1
14.6.2

Cablear operandos en instrucciones FUP .........................................................................8041
Cablear operandos.............................................................................................................8041
Cablear parámetros ocultos ...............................................................................................8042

Programación del PLC
Manual de programación y manejo, 11/2019

19

Índice

15

20

14.6.3

Mostrar u ocultar informaciones de variables ....................................................................8043

14.7
14.7.1
14.7.2
14.7.3
14.7.4

Ramas en FUP...................................................................................................................8045
Principios básicos de las ramas en FUP............................................................................8045
Reglas para ramas en FUP................................................................................................8045
Insertar ramas en segmentos FUP ....................................................................................8046
Borrar ramas en segmentos FUP ......................................................................................8046

14.8
14.8.1
14.8.2
14.8.3

Circuitos lógicos en FUP....................................................................................................8047
Principios básicos de los circuitos lógicos en FUP ............................................................8047
Insertar un circuito lógico ...................................................................................................8048
Borrar un circuito lógico .....................................................................................................8049

14.9
14.9.1
14.9.2
14.9.3
14.9.4
14.9.5

Ejemplos de programación FUP ........................................................................................8050
Ejemplo de control de una cinta transportadora ...............................................................8050
Ejemplo de detección del sentido de marcha de una cinta transportadora .......................8052
Ejemplo de detección del nivel de llenado de una zona de almacén ................................8054
Ejemplo de cálculo de una ecuación..................................................................................8058
Ejemplo de control de la temperatura ambiente ................................................................8060

Crear programas AWL............................................................................................................................8065
15.1
15.1.1
15.1.2
15.1.3
15.1.3.1
15.1.3.2

Bases de AWL ...................................................................................................................8065
Lenguaje de programación AWL........................................................................................8065
Intercambio de datos en AWL............................................................................................8065
Alimentación de parámetros a través de registros.............................................................8067
Alimentación de parámetros a través de registros en la llamada de bloques en AWL ......8067
Activar alimentación de parámetros a través de registros .................................................8069

15.2
15.2.1
15.2.2

Configuración de AWL .......................................................................................................8070
Vista general de configuraciones de AWL .........................................................................8070
Modificar la configuración ..................................................................................................8070

15.3
15.3.1
15.3.2
15.3.3
15.3.4
15.3.5
15.3.6
15.3.7
15.3.8
15.3.9

Trabajar con segmentos ....................................................................................................8071
Utilizar segmentos..............................................................................................................8071
Insertar segmentos ............................................................................................................8071
Seleccionar segmentos......................................................................................................8072
Copiar e insertar segmentos ..............................................................................................8073
Borrar segmentos...............................................................................................................8074
Contraer y expandir segmentos .........................................................................................8074
Insertar título del segmento................................................................................................8075
Introducir el comentario del segmento ...............................................................................8077
Navegar en segmentos ......................................................................................................8078

15.4
15.4.1
15.4.2
15.4.3
15.4.4
15.4.5
15.4.5.1
15.4.5.2
15.4.6
15.4.7
15.4.8
15.4.8.1

Añadir instrucciones AWL ..................................................................................................8079
Reglas sobre AWL .............................................................................................................8079
Instrucciones de la librería global "Long Functions" ..........................................................8080
Introducir manualmente las instrucciones AWL .................................................................8082
Insertar instrucciones AWL empleando la Task Card "Instrucciones" ...............................8083
Seleccionar el tipo de datos de una instrucción AWL ........................................................8085
Seleccionar un tipo de datos..............................................................................................8085
Definir el tipo de datos de una instrucción .........................................................................8085
Insertar operandos .............................................................................................................8086
Mostrar u ocultar informaciones de variables ....................................................................8087
Emplear favoritos en AWL .................................................................................................8088
Insertar elementos AWL en favoritos .................................................................................8088

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

16

15.4.8.2
15.4.8.3
15.4.9
15.4.9.1
15.4.9.2
15.4.9.3
15.4.9.4
15.4.10

Insertar instrucciones AWL empleando favoritos ..............................................................8089
Eliminar instrucciones AWL retirándolas de favoritos ........................................................8090
Insertar llamadas de bloque en AWL .................................................................................8090
Insertar manualmente llamadas de bloque ........................................................................8090
Insertar llamadas de bloque mediante Drag & Drop ..........................................................8092
Actualizar las llamadas de bloque en AWL........................................................................8093
Cambiar el tipo de instancia...............................................................................................8095
Insertar comentarios ..........................................................................................................8097

15.5
15.5.1
15.5.2
15.5.3
15.5.4
15.5.5

Procesar instrucciones AWL ..............................................................................................8098
Seleccionar instrucciones AWL..........................................................................................8098
Copiar instrucciones AWL..................................................................................................8099
Cortar instrucciones AWL ..................................................................................................8100
Insertar instrucciones AWL procedentes del portapapeles................................................8100
Borrar instrucciones AWL ..................................................................................................8101

15.6
15.6.1
15.6.2
15.6.3
15.6.4
15.6.5
15.6.6

Ejemplos de programación AWL........................................................................................8102
Ejemplo de control de una cinta transportadora ................................................................8102
Ejemplo de detección del sentido de marcha de una cinta transportadora .......................8104
Ejemplo de detección del nivel de llenado de una zona de almacén ................................8106
Ejemplo de cálculo de una ecuación..................................................................................8108
Ejemplo de calentamiento de una caldera .......................................................................8110
Ejemplo de una cadena secuencial ...................................................................................8112

Creación de programas SCL ..................................................................................................................8115
16.1
16.1.1
16.1.2
16.1.3
16.1.4
16.1.5
16.1.6
16.1.7
16.1.8
16.1.9

Principios básicos de SCL .................................................................................................8115
Lenguaje de programación SCL ........................................................................................8115
Expresiones .......................................................................................................................8116
Expresiones aritméticas .....................................................................................................8117
Expresiones de comparación.............................................................................................8120
Expresiones lógicas ...........................................................................................................8125
Operadores y su jerarquía .................................................................................................8126
Asignaciones de valor ........................................................................................................8127
Calcular en SCL con números en coma flotante (REAL y LREAL)....................................8131
Calcular en SCL con constantes........................................................................................8135

16.2
16.2.1
16.2.2

Configuración de SCL ........................................................................................................8138
Sinopsis de la configuración de SCL .................................................................................8138
Modificar la configuración ..................................................................................................8140

16.3
16.3.1
16.3.2
16.3.3
16.3.4
16.3.5
16.3.6
16.3.6.1
16.3.6.2
16.3.6.3
16.3.6.4

La ventana de programación de SCL ................................................................................8140
Vista general de la ventana de programación....................................................................8140
Ajuste de la ventana de programación...............................................................................8141
Formatear un código SCL ..................................................................................................8143
Expandir y contraer secciones de código ..........................................................................8144
Navegar hasta las definiciones ..........................................................................................8145
Uso de marcadores............................................................................................................8146
Principios básicos de los marcadores................................................................................8146
Inserción de marcadores....................................................................................................8146
Navegación por marcadores ..............................................................................................8147
Borrado de marcadores .....................................................................................................8148

16.4
16.4.1
16.4.2

Entrada de instrucciones SCL............................................................................................8149
Reglas sobre las instrucciones SCL ..................................................................................8149
Entrada manual de instrucciones SCL...............................................................................8150

Programación del PLC
Manual de programación y manejo, 11/2019

21

Índice

17

16.4.3
16.4.4
16.4.5
16.4.5.1
16.4.5.2
16.4.5.3
16.4.5.4
16.4.5.5
16.4.6
16.4.6.1
16.4.6.2
16.4.6.3
16.4.6.4
16.4.7
16.4.8
16.4.8.1
16.4.8.2
16.4.8.3
16.4.9
16.4.9.1
16.4.9.2
16.4.9.3
16.4.9.4
16.4.10
16.4.11
16.4.12

Inserción de instrucciones SCL desde la Task Card "Instrucciones".................................8151
Encerrar el código de programa con elementos de estructura ..........................................8152
Trabajar con áreas .............................................................................................................8153
Uso de áreas......................................................................................................................8153
Insertar áreas .....................................................................................................................8156
Copiar y pegar áreas..........................................................................................................8157
Navegar por las áreas........................................................................................................8158
Borrar áreas .......................................................................................................................8160
Definir el tipo de datos de una instrucción SCL .................................................................8161
Principios básicos de los tipos de datos de instrucciones SCL .........................................8161
Modificar el tipo de datos de una instrucción SCL .............................................................8162
Tipo de datos de temporizadores y contadores CEI ..........................................................8162
Ejemplo de modificación del tipo de datos de una instrucción SCL...................................8163
Mostrar u ocultar informaciones de variables ....................................................................8163
Utilizar Favoritos en SCL ...................................................................................................8164
Agregar instrucciones SCL a los Favoritos ........................................................................8164
Inserción de instrucciones de SCL mediante Favoritos .....................................................8165
Eliminación de instrucciones SCL de los Favoritos ...........................................................8166
Inserción de llamadas de bloque en SCL ..........................................................................8167
Principios básicos de la llamada de bloque en SCL ..........................................................8167
Inserción manual de llamadas de bloque...........................................................................8172
Insertar llamadas de bloque mediante Drag & Drop ..........................................................8174
Actualización de llamadas de bloque.................................................................................8175
Ampliar y reducir una lista de parámetros..........................................................................8177
Insertar pragmas ................................................................................................................8178
Inserción de comentarios ...................................................................................................8179

16.5
16.5.1
16.5.2
16.5.3

Edición de instrucciones SCL ............................................................................................8181
Selección de instrucciones.................................................................................................8181
Copiar, cortar y pegar instrucciones ..................................................................................8182
Borrado de instrucciones ...................................................................................................8182

16.6
16.6.1
16.6.2
16.6.3

Ejemplos de programación SCL ........................................................................................8183
Ejemplo de control de una cinta transportadora ................................................................8183
Ejemplo de detección del sentido de marcha de una cinta transportadora .......................8185
Ejemplo de detección del nivel de llenado de una zona de almacén ................................8187

Crear programas GRAPH.......................................................................................................................8191
17.1
17.1.1
17.1.2
17.1.2.1
17.1.2.2
17.1.3
17.1.3.1
17.1.3.2
17.1.3.3
17.1.4
17.1.4.1
17.1.4.2
17.1.4.3
17.1.4.4
17.1.4.5

22

Principios básicos de GRAPH............................................................................................8191
Lenguaje de programación GRAPH...................................................................................8191
Cadenas secuenciales .......................................................................................................8193
Principios básicos de las cadenas secuenciales ...............................................................8193
Elementos de una cadena secuencial ...............................................................................8194
Etapas y transiciones .........................................................................................................8198
Principios básicos de las etapas ........................................................................................8198
Elementos de una etapa ....................................................................................................8199
Principios básicos de las transiciones................................................................................8200
Acciones.............................................................................................................................8201
Principios básicos de las acciones.....................................................................................8201
Acciones estándar..............................................................................................................8202
Acciones controladas por evento .......................................................................................8204
Llamadas de bloque...........................................................................................................8207
Temporizadores .................................................................................................................8208

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

17.1.4.6
17.1.5
17.1.6
17.1.7
17.1.8
17.1.8.1
17.1.8.2
17.1.8.3
17.1.8.4
17.1.8.5

Contadores.........................................................................................................................8209
Instrucciones permanentes ................................................................................................8211
Condiciones .......................................................................................................................8211
Avisos de interlock y supervisión .......................................................................................8212
Interfaz de un bloque de función GRAPH ..........................................................................8213
Principios básicos de la interfaz de un bloque de función GRAPH....................................8213
Parámetros de entrada ......................................................................................................8216
Parámetros de salida .........................................................................................................8220
Parámetros estáticos .........................................................................................................8224
Ampliar el comportamiento estándar de GRAPH...............................................................8232

17.2
17.2.1
17.2.2
17.2.3
17.2.3.1
17.2.3.2
17.2.4
17.2.5
17.2.6
17.2.7

Configuración de GRAPH ..................................................................................................8235
Sinopsis de la configuración de GRAPH............................................................................8235
Modificar la configuración ..................................................................................................8238
Versiones de GRAPH ........................................................................................................8239
Vista general de las versiones de GRAPH ........................................................................8239
Definir la versión del bloque de función GRAPH ...............................................................8239
Definir el lenguaje de programación en segmentos...........................................................8240
Definir el juego de parámetros de interfaz .........................................................................8241
Definir el modelo de espacio de memoria para el bloque de datos ...................................8242
Modificar ajustes para parámetros internos .......................................................................8244

17.3
17.3.1
17.3.2
17.3.3
17.3.4
17.3.5
17.3.6

La ventana de programación de GRAPH...........................................................................8245
Vista general de la ventana de programación....................................................................8245
Vista "Instrucciones permanentes anteriores" ...................................................................8247
Vista de cadena .................................................................................................................8248
Vista de etapa individual ....................................................................................................8250
Vista "Instrucciones permanentes posteriores"..................................................................8252
Visor de avisos...................................................................................................................8253

17.4
17.4.1
17.4.2
17.4.3

Utilizar Favoritos en GRAPH..............................................................................................8255
Agregar elementos GRAPH a los Favoritos ......................................................................8255
Insertar elementos GRAPH mediante Favoritos ................................................................8256
Quitar elementos GRAPH de los Favoritos .......................................................................8257

17.5
17.5.1
17.5.2
17.5.3
17.5.4
17.5.5
17.5.6
17.5.7
17.5.7.1
17.5.7.2
17.5.7.3
17.5.7.4
17.5.7.5
17.5.7.6
17.5.7.7
17.5.7.8
17.5.7.9
17.5.8
17.5.8.1

Programar la estructura de una cadena secuencial...........................................................8257
Insertar cadenas secuenciales...........................................................................................8257
Cambiar el nombre de cadenas secuenciales ...................................................................8258
Comentar cadenas secuenciales .......................................................................................8259
Insertar elementos en una cadena secuencial...................................................................8260
Finalizar cadenas secuenciales .........................................................................................8260
Borrar cadenas secuenciales.............................................................................................8261
Utilizar etapas y transiciones .............................................................................................8262
Insertar etapas y transiciones ............................................................................................8262
Establecer y desmarcar una etapa inicial ..........................................................................8264
Renumerar las etapas y transiciones.................................................................................8265
Renombrar las etapas y transiciones.................................................................................8267
Comentar etapas................................................................................................................8268
Copiar y pegar etapas y transiciones.................................................................................8269
Saltar etapas ......................................................................................................................8270
Borrar etapas y transiciones ..............................................................................................8270
Mostrar y editar las traducciones de los nombres de etapas y transiciones......................8271
Utilizar ramas .....................................................................................................................8272
Crear ramas alternativas....................................................................................................8272

Programación del PLC
Manual de programación y manejo, 11/2019

23

Índice

18

24

17.5.8.2
17.5.8.3
17.5.8.4
17.5.9
17.5.9.1
17.5.9.2
17.5.9.3
17.5.9.4

Crear una rama simultánea................................................................................................8273
Cerrar ramas ......................................................................................................................8274
Borrar ramas ......................................................................................................................8275
Utilizar saltos......................................................................................................................8275
Insertar saltos.....................................................................................................................8275
Cambiar destino de salto ...................................................................................................8276
Navegar hasta el destino de salto......................................................................................8277
Borrar saltos.......................................................................................................................8277

17.6
17.6.1
17.6.2
17.6.2.1
17.6.2.2
17.6.3
17.6.4
17.6.5
17.6.6

Programar acciones ...........................................................................................................8278
Insertar acciones................................................................................................................8278
Definir el tipo de datos de una instrucción GRAPH ...........................................................8281
Principios básicos de los tipos de datos de instrucciones GRAPH....................................8281
Modificar el tipo de datos de una instrucción GRAPH .......................................................8282
Modificar acciones .............................................................................................................8283
Copiar, cortar y pegar acciones .........................................................................................8284
Desplazar acciones............................................................................................................8285
Borrar acciones ..................................................................................................................8286

17.7
17.7.1
17.7.2
17.7.2.1
17.7.2.2
17.7.3
17.7.4
17.7.4.1
17.7.4.2
17.7.5

Programar condiciones ......................................................................................................8286
Programar interlocks ..........................................................................................................8286
Programar supervisiones ...................................................................................................8288
Insertar condiciones de supervisión...................................................................................8288
Utilizar la vigilancia del tiempo de etapa ............................................................................8289
Programar transiciones ......................................................................................................8293
Programar instrucciones permanentes ..............................................................................8295
Trabajar con segmentos ....................................................................................................8295
Insertar instrucciones permanentes ...................................................................................8301
Mostrar u ocultar informaciones de variables ....................................................................8303

17.8
17.8.1
17.8.2
17.8.3
17.8.4

Insertar llamadas de bloque en GRAPH ............................................................................8304
Inserción manual de llamadas de bloque...........................................................................8304
Insertar llamadas de bloque mediante Drag & Drop ..........................................................8306
Actualizar llamadas de bloque en GRAPH ........................................................................8308
Modificar una llamada de bloque .......................................................................................8309

17.9
17.9.1
17.9.2

Definir avisos......................................................................................................................8310
Activar y desactivar el visor de avisos ...............................................................................8310
Editar avisos.......................................................................................................................8310

17.10
17.10.1
17.10.2
17.10.3
17.10.4

Adquirir primeros valores ...................................................................................................8312
Sinopsis de la adquisición de primeros valores .................................................................8312
Activar la adquisición de primeros valores.........................................................................8314
Inicializar primeros valores.................................................................................................8315
Ejemplo de orden en la lista...............................................................................................8316

Configurar avisos....................................................................................................................................8319
18.1

Introducción a la configuración de avisos ..........................................................................8319

18.2

Asignación de números de aviso .......................................................................................8319

18.3

Componentes de un aviso .................................................................................................8320

18.4

Bloques de aviso disponibles.............................................................................................8320

18.5

Plantilla y avisos.................................................................................................................8322

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

18.6

Parámetros formales, tipos de datos de avisos y bloques de aviso ..................................8323

18.7

Estructura del editor de avisos...........................................................................................8324

18.8

Trabajar con el editor de avisos .........................................................................................8326

18.9
18.9.1
18.9.2
18.9.3
18.9.4
18.9.5
18.9.6
18.9.7
18.9.8
18.9.9
18.9.10
18.9.11
18.9.12
18.9.13

Crear y editar avisos ..........................................................................................................8326
Crear avisos de programa..................................................................................................8326
Editar avisos de programa en el editor de avisos ..............................................................8327
Editar avisos de programa en el editor de programación ..................................................8328
Borrar avisos de programa.................................................................................................8328
Editar un tipo de aviso........................................................................................................8329
Crear un DB de instancia y editar instancias de aviso.......................................................8329
Crear avisos de diagnóstico de usuario .............................................................................8330
Editar avisos de diagnóstico de usuario.............................................................................8330
Borrar avisos de diagnóstico de usuario ............................................................................8331
Insertar valores asociados en los avisos ...........................................................................8331
Estructura de los valores asociados ..................................................................................8332
Ejemplos de valores asociados..........................................................................................8333
Borrar valores asociados ...................................................................................................8334

18.10
18.10.1
18.10.2
18.10.3
18.10.4
18.10.5
18.10.6
18.10.7
18.10.8
18.10.9
18.10.10
18.10.11

Crear y editar avisos ..........................................................................................................8335
Crear avisos de programa..................................................................................................8335
Editar avisos de programa en el editor de avisos ..............................................................8336
Editar avisos de programa en el editor de programación ..................................................8336
Borrar avisos de programa.................................................................................................8337
Editar un tipo de aviso........................................................................................................8337
Crear un DB de instancia y editar instancias de aviso.......................................................8337
Insertar valores asociados en los avisos ...........................................................................8338
Ajustes al introducir valores asociados ..............................................................................8340
Particularidades con valores asociados.............................................................................8341
Ejemplos de valores asociados..........................................................................................8342
Borrar valores asociados ...................................................................................................8343

18.11
18.11.1
18.11.2
18.11.3
18.11.4
18.11.5
18.11.6

Textos y atributos...............................................................................................................8343
Palabras clave para textos de aviso ..................................................................................8343
Introducir textos..................................................................................................................8344
Principios básicos para bloquear/desbloquear textos y atributos ......................................8345
Mostrar/ocultar bloqueos para avisos nuevos y símbolos de bloqueo...............................8346
Inhibir textos.......................................................................................................................8347
Inhibir atributos...................................................................................................................8348

18.12
18.12.1
18.12.2
18.12.3
18.12.4

Listas de textos para avisos...............................................................................................8349
Principios básicos de las listas de textos para avisos........................................................8349
Editar listas de textos para avisos......................................................................................8349
Integrar en avisos los textos de listas de textos.................................................................8350
Ejemplo de integración en avisos de los textos de las listas de textos..............................8351

18.13
18.13.1
18.13.2
18.13.3
18.13.4
18.13.5
18.13.5.1

Categorías..........................................................................................................................8352
Crear categorías ................................................................................................................8352
Editar categorías ................................................................................................................8353
Borrar categorías ...............................................................................................................8353
Prioridad de la categoría de aviso......................................................................................8354
Exportar e importar categorías...........................................................................................8355
Principios básicos para exportar e importar categorías .....................................................8355

Programación del PLC
Manual de programación y manejo, 11/2019

25

Índice

19

20

18.13.5.2
18.13.5.3

Exportar categorías de aviso .............................................................................................8355
Importar categorías de aviso..............................................................................................8356

18.14
18.14.1
18.14.2
18.14.3

Importar y exportar textos de aviso....................................................................................8357
Principios básicos para exportar e importar textos de aviso..............................................8357
Exportar textos de aviso.....................................................................................................8359
Importar textos de aviso.....................................................................................................8359

Compilación y carga de programas de PLC...........................................................................................8361
19.1

Fundamentos sobre la compilación y carga de programas de PLC ..................................8361

19.2
19.2.1
19.2.2
19.2.3
19.2.4

Compilar bloques ...............................................................................................................8362
Principios básicos de la compilación de bloques ...............................................................8362
Compilar bloques en el árbol del proyecto.........................................................................8365
Compilar bloques en el editor de programación ................................................................8366
Solucionar errores de compilación.....................................................................................8367

19.3
19.3.1
19.3.2
19.3.3
19.3.4
19.3.5
19.3.6
19.3.7
19.3.8
19.3.9
19.3.9.1
19.3.9.2
19.3.9.3
19.3.9.4
19.3.9.5
19.3.9.6

Cargar bloques para S7-1200/1500...................................................................................8368
Introducción a la carga de bloques ....................................................................................8368
Cargar bloques en un dispositivo en estado operativo "RUN"...........................................8372
Cargar bloques en un dispositivo desde el editor de programación ..................................8377
Cargar bloques en un dispositivo desde el árbol del proyecto...........................................8378
Cargar bloques de un dispositivo.......................................................................................8381
Cargar bloques en una Memory Card................................................................................8382
Cargar bloques de una Memory Card................................................................................8384
Desactivar la cadena secuencial antes de cargar un bloque de datos GRAPH ................8384
Cargar ampliaciones de bloque sin reinicializar.................................................................8385
Principios básicos para cargar ampliaciones de bloque sin reinicializar............................8385
Ajustar la reserva de memoria para ampliaciones de bloque ............................................8387
Activar la reserva de memoria ...........................................................................................8388
Desactivar la reserva de memoria .....................................................................................8389
Ampliación de una interfaz de bloque o un bloque de datos .............................................8390
Inicialización de la reserva de memoria .............................................................................8391

19.4
19.4.1
19.4.2
19.4.3
19.4.4
19.4.5
19.4.6
19.4.7
19.4.8

Cargar bloques para S7-300/400.......................................................................................8392
Introducción a la carga de bloques ....................................................................................8392
Cargar bloques en un dispositivo en modo operativo "RUN".............................................8395
Cargar bloques en un dispositivo desde el editor de programas .......................................8400
Cargar bloques en el dispositivo desde el árbol de proyectos...........................................8401
Cargar bloques desde un dispositivo .................................................................................8403
Cargar bloques en una Memory Card................................................................................8404
Cargar bloques de una Memory Card................................................................................8406
Desactivar la cadena secuencial antes de cargar un bloque de datos GRAPH ................8406

19.5
19.5.1
19.5.2

Cargar variables PLC.........................................................................................................8407
Introducción a la carga de variables PLC ..........................................................................8407
Visibilidad de variables PLC online/offline .........................................................................8409

Comparación de programas de PLC ......................................................................................................8411
20.1
20.1.1
20.1.2
20.1.3
20.1.4
20.1.5

26

Principios básicos para comparar programas de PLC.......................................................8411
Introducción a la comparación de programas de PLC .......................................................8411
Comparación de Software Units ........................................................................................8415
Comparación de bloques y tipos de datos PLC .................................................................8416
Comparación de variables PLC .........................................................................................8416
Comparación de programas PLC a partir de las sumas de verificación ............................8417

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

21

20.2
20.2.1
20.2.2
20.2.2.1
20.2.2.2
20.2.2.3
20.2.2.4
20.2.2.5
20.2.2.6
20.2.2.7

Comparar bloques..............................................................................................................8419
Comparar bloques en el editor de comparación ................................................................8419
Realizar una comparación detallada de bloques ...............................................................8420
Iniciar una comparación detallada de bloques KOP/FUP/AWL/SCL .................................8420
Iniciar una comparación detallada de bloques GRAPH .....................................................8423
Iniciar la comparación detallada de bloques de datos .......................................................8426
Representación del resultado de la comparación ..............................................................8428
Navegar en la comparación detallada................................................................................8444
Modificar bloques durante la comparación detallada.........................................................8445
Actualizar resultados de la comparación ...........................................................................8447

20.3

Comparar variables PLC....................................................................................................8448

20.4

Comparar tipos de datos PLC............................................................................................8451

Mostrar información del programa..........................................................................................................8455
21.1

Resumen de la información del programa disponible ........................................................8455

21.2
21.2.1
21.2.2
21.2.3
21.2.4
21.2.5
21.2.6
21.2.7
21.2.8
21.2.9
21.2.10

Visualizar el plano de ocupación........................................................................................8456
Introducción al plano de ocupación....................................................................................8456
Estructura del plano de ocupación.....................................................................................8457
Símbolos del plano de ocupación ......................................................................................8458
Visualizar el plano de ocupación........................................................................................8459
Configurar las opciones de visualización del plano de ocupación .....................................8460
Posibilidades de filtrado en el plano de ocupación ............................................................8461
Definir filtros para el plano de ocupación ...........................................................................8461
Filtrar el plano de ocupación ..............................................................................................8463
Definir áreas de memoria remanentes para marcas..........................................................8463
Activar la indicación de la remanencia de marcas .............................................................8464

21.3
21.3.1
21.3.2
21.3.3
21.3.4
21.3.5
21.3.6
21.3.7

Mostrar la estructura de llamada........................................................................................8465
Introducción a la estructura de llamadas ...........................................................................8465
Símbolos utilizados en la estructura de llamadas ..............................................................8467
Composición de la estructura de llamadas ........................................................................8468
Mostrar la estructura de llamadas......................................................................................8469
Configurar las opciones de visualización de la estructura de llamadas.............................8470
Introducción a la comprobación de coherencia en la estructura de llamada .....................8471
Comprobar la coherencia de bloques en la estructura de llamada....................................8471

21.4
21.4.1
21.4.2
21.4.3
21.4.4
21.4.5
21.4.6
21.4.7

Mostrar la estructura de dependencias..............................................................................8472
Introducción a la estructura de dependencias ...................................................................8472
Estructura de dependencias ..............................................................................................8473
Símbolos utilizados en la estructura de dependencias ......................................................8474
Mostrar la estructura de dependencias..............................................................................8475
Configurar las opciones de visualización de la estructura de dependencias.....................8476
Introducción a la comprobación de coherencia en la estructura de dependencias ...........8477
Comprobar la coherencia de bloques en la estructura de dependencias ..........................8477

21.5
21.5.1
21.5.2
21.5.3
21.5.4

Mostrar la carga de la memoria de la CPU ........................................................................8478
Introducción a la carga de la memoria ...............................................................................8478
Estructura de la ficha "Carga de la memoria" ....................................................................8480
Mostrar la carga de la memoria .........................................................................................8481
Seleccionar la memoria de carga máxima disponible........................................................8482

Programación del PLC
Manual de programación y manejo, 11/2019

27

Índice

22

23

28

Mostrar referencias cruzadas .................................................................................................................8483
22.1

Información general sobre las referencias cruzadas .........................................................8483

22.2

Estructura de la lista de referencias cruzadas ...................................................................8484

22.3

Ajustes de la lista de referencias cruzadas........................................................................8486

22.4

Visualizar la lista de referencias cruzadas .........................................................................8489

22.5

Clasificar la lista de referencias cruzadas..........................................................................8491

22.6
22.6.1
22.6.2
22.6.3
22.6.4
22.6.5
22.6.6
22.6.7
22.6.8
22.6.9
22.6.10

Posibilidades de filtro para referencias cruzadas...............................................................8492
Introducción al filtrado de referencias cruzadas.................................................................8492
Estructura del cuadro de diálogo de filtros.........................................................................8494
Atributos, operadores y valores del cuadro de diálogo de filtros .......................................8496
Crear filtros definidos por el usuario para referencias cruzadas........................................8497
Editar filtros definidos por el usuario ..................................................................................8499
Borrar filtros definidos por el usuario .................................................................................8501
Exportar e importar filtros definidos por el usuario.............................................................8502
Activar filtro como predeterminado ....................................................................................8504
Duplicar filtros ....................................................................................................................8505
Filtrar la lista de referencias cruzadas ...............................................................................8506

22.7

Imprimir una lista de referencias cruzadas ........................................................................8507

22.8

Agregar un nuevo objeto a la lista de referencias cruzadas ..............................................8508

22.9

Mostrar accesos solapados en la lista de referencias cruzadas........................................8509

22.10

Restaurar las referencias cruzadas después de una actualización de proyecto ...............8511

22.11

Mostrar y editar referencias cruzadas en la ventana de inspección ..................................8512

Comprobar el programa de usuario........................................................................................................8515
23.1

Principios básicos del test del programa de usuario..........................................................8515

23.2
23.2.1
23.2.2
23.2.2.1
23.2.2.2
23.2.3
23.2.4
23.2.5
23.2.6
23.2.7
23.2.8
23.2.9
23.2.9.1
23.2.9.2
23.2.9.3
23.2.10
23.2.10.1
23.2.10.2
23.2.10.3
23.2.10.4
23.2.10.5

Test con el estado del programa........................................................................................8516
Introducción al test con el estado del programa ................................................................8516
Ajustar el entorno de llamada ............................................................................................8518
Principios básicos del entorno de llamada.........................................................................8518
Ajuste del entorno de llamada para observar bloques.......................................................8519
Activar/desactivar el test con el estado del programa........................................................8521
Observación de bucles.......................................................................................................8524
Observación de estructuras ...............................................................................................8526
Editar bloques durante el test del programa ......................................................................8527
Forzar variables durante la observación ............................................................................8528
Cambiar formatos de visualización en el estado del programa .........................................8529
Particularidades del test de programas GRAPH................................................................8530
Principios básicos del test de programas GRAPH.............................................................8530
Definir ajustes para el test..................................................................................................8533
Forzar una cadena secuencial durante un test ..................................................................8534
Ejemplos de visualización del estado del programa ..........................................................8539
Visualización del estado de programas KOP.....................................................................8539
Visualización del estado de programas FUP .....................................................................8540
Visualización del estado de programas AWL.....................................................................8541
Visualización del estado de programas SCL .....................................................................8542
Visualización del estado de programas GRAPH................................................................8543

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

23.3
23.3.1
23.3.2
23.3.3
23.3.4
23.3.5
23.3.6
23.3.7
23.3.8
23.3.9
23.3.10
23.3.11
23.3.12
23.3.13
23.3.14
23.3.15
23.3.16

Test con puntos de parada ................................................................................................8547
Introducción al test con puntos de parada .........................................................................8547
Consignas de seguridad para el test con puntos de parada..............................................8549
Consignas de seguridad para el test con puntos de parada..............................................8549
Reglas para el test con puntos de parada .........................................................................8552
Indicación del estado de los puntos de parada..................................................................8553
Ajustar el entorno de llamada para puntos de parada .......................................................8555
Posicionar puntos de parada .............................................................................................8556
Activar puntos de parada ...................................................................................................8558
Desactivar puntos de parada .............................................................................................8560
Navegar hasta los puntos de parada .................................................................................8562
Borrar puntos de parada ....................................................................................................8563
Realizar tests con puntos de parada en modo de etapa o paso individual........................8565
Puntos de parada "Ejecutar hasta la marca" .....................................................................8567
Observar variables al alcanzar el punto de parada............................................................8568
Forzar variables al alcanzar el punto de parada ................................................................8570
Continuar la ejecución del programa .................................................................................8572

23.4
23.4.1
23.4.2
23.4.3
23.4.4
23.4.5
23.4.5.1
23.4.5.2
23.4.5.3
23.4.5.4
23.4.6
23.4.6.1
23.4.6.2
23.4.6.3
23.4.6.4
23.4.6.5
23.4.6.6
23.4.7
23.4.7.1
23.4.7.2
23.4.7.3
23.4.7.4
23.4.8
23.4.8.1
23.4.8.2
23.4.8.3
23.4.8.4
23.4.8.5
23.4.8.6

Test con la tabla de observación .......................................................................................8573
Introducción al test con la tabla de observación ................................................................8573
Estructura de la tabla de observación................................................................................8574
Modo básico/avanzado en la tabla de observación ...........................................................8575
Símbolos y botones utilizados en la tabla de observación.................................................8576
Crear y editar tablas de observación .................................................................................8578
Crear una tabla de observación .........................................................................................8578
Abrir una tabla de observación ..........................................................................................8578
Copiar e insertar una tabla de observación .......................................................................8579
Guardar una tabla de observación.....................................................................................8579
Introducir variables en la tabla de observación..................................................................8580
Información básica para la entrada de variables en la tabla de observación ....................8580
Operandos permitidos para la tabla de observación..........................................................8581
Valores de forzado permitidos para la tabla de observación .............................................8582
Sinopsis de los formatos de visualización..........................................................................8584
Seleccionar un formato de visualización para variables ....................................................8587
Cómo crear y editar líneas de comentario .........................................................................8587
Observar variables en la tabla de observación ..................................................................8589
Introducción a la observación de variables en la tabla de observación .............................8589
Definición del modo de observación y forzado ..................................................................8590
Variables "Observar todos" ................................................................................................8593
"Observar inmediatamente" variables ................................................................................8594
Forzar variables en la tabla de observación ......................................................................8595
Introducción al forzado de variables ..................................................................................8595
Forzar variables a "0" .........................................................................................................8596
Forzar variables a "1" .........................................................................................................8598
"Forzar inmediatamente" variables ....................................................................................8599
"Forzar con disparador" variables ......................................................................................8600
Desbloquear salidas...........................................................................................................8602

23.5
23.5.1
23.5.2
23.5.3
23.5.4

Test con la tabla de forzado permanente...........................................................................8603
Introducción al test con la tabla de forzado permanente ...................................................8603
Medidas de seguridad para el forzado permanente de variables ......................................8605
Estructura de la tabla de forzado permanente ...................................................................8605
Modo básico y modo avanzado en la tabla de forzado permanente..................................8607

Programación del PLC
Manual de programación y manejo, 11/2019

29

Índice

23.5.5
23.5.6
23.5.6.1
23.5.6.2
23.5.6.3
23.5.7
23.5.7.1
23.5.7.2
23.5.7.3
23.5.7.4
23.5.7.5
23.5.7.6
23.5.8
23.5.8.1
23.5.8.2
23.5.8.3
23.5.8.4
23.5.9
23.5.9.1
23.5.9.2
23.5.9.3
23.5.9.4
23.5.9.5
23.5.9.6
23.5.10
23.5.10.1
23.5.10.2
24

30

Símbolos utilizados en la tabla de forzado permanente ....................................................8607
Abrir y procesar tabla de forzado permanente...................................................................8609
Visualización de la tabla de forzado permanente ..............................................................8609
Abrir tabla de forzado permanente.....................................................................................8609
Guardar tabla de forzado permanente ...............................................................................8609
Introducir variables en la tabla de forzado permanente .....................................................8610
Información básica para la entrada de variables en la tabla de forzado permanente........8610
Operandos permitidos para la tabla de forzado permanente.............................................8611
Valores de forzado permanente permitidos para la tabla de forzado permanente ............8612
Sinopsis de los formatos de visualización..........................................................................8614
Seleccionar un formato de visualización para variables ....................................................8616
Cómo crear y editar líneas de comentario .........................................................................8617
Observar variables en la tabla de forzado permanente .....................................................8618
Introducción a la observación de variables en la tabla de forzado permanente ................8618
Establecimiento del modo de observación en la tabla de forzado permanente.................8619
Variables "Observar todos" ................................................................................................8620
"Observar inmediatamente" variables ................................................................................8621
Forzar permanentemente variables en la tabla de forzado permanente ...........................8622
Introducción al forzado permanente de variables ..............................................................8622
Medidas de seguridad para el forzado permanente de variables ......................................8624
Actualizar operandos forzados permanentemente ............................................................8624
Forzar permanentemente variables a "0"...........................................................................8626
Forzar permanentemente variables a "1"...........................................................................8628
Forzar permanentemente variables "Forzar todos permanentemente" .............................8629
Finalizar forzado permanente de variables ........................................................................8631
Finalizar forzado permanente de todas las variables.........................................................8631
Finalizar forzado permanente de variables individuales ....................................................8633

Supervisión de máquinas e instalaciones con ProDiag..........................................................................8635
24.1
24.1.1
24.1.2
24.1.3

Requisitos de sistema para ProDiag..................................................................................8635
Notas relativas a licencias..................................................................................................8635
Ajustar licencias ProDiag ...................................................................................................8635
Requisitos de software y hardware ....................................................................................8636

24.2
24.2.1

Datos técnicos para ProDiag .............................................................................................8637
Datos técnicos para ProDiag .............................................................................................8637

24.3
24.3.1
24.3.2
24.3.3
24.3.3.1
24.3.3.2
24.3.3.3
24.3.3.4
24.3.3.5
24.3.3.6
24.3.3.7
24.3.3.8
24.3.4
24.3.4.1
24.3.4.2
24.3.4.3

Principios básicos de la supervisión con ProDiag..............................................................8637
Introducción a ProDiag.......................................................................................................8637
Ejemplo de creación de una supervisión a partir de una supervisión de operandos .........8640
Tipos de supervisiones ......................................................................................................8643
Vista general de los tipos de supervisiones .......................................................................8643
Supervisión de operandos .................................................................................................8644
Supervisión de enclavamientos .........................................................................................8646
Supervisión de acciones ....................................................................................................8648
Supervisión de reacciones .................................................................................................8650
Supervisión de posiciones .................................................................................................8652
Aviso de texto.....................................................................................................................8654
Mensaje de error ................................................................................................................8655
Ejemplos de los distintos tipos de supervisiones ...............................................................8657
Introducción........................................................................................................................8657
Ejemplo de una supervisión de operandos ........................................................................8658
Ejemplo de una supervisión de enclavamiento..................................................................8660

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

24.3.4.4
24.3.4.5
24.3.4.6
24.3.4.7
24.3.4.8
24.3.5

Ejemplo de una supervisión de acciones...........................................................................8664
Ejemplo de una supervisión de reacciones........................................................................8666
Ejemplo de una supervisión de posición............................................................................8669
Ejemplo de un texto de aviso .............................................................................................8672
Ejemplo de un mensaje de error ........................................................................................8673
Ejemplos de aplicación para la supervisión con ProDiag ..................................................8676

24.4
24.4.1
24.4.2
24.4.3
24.4.4
24.4.4.1
24.4.4.2
24.4.4.3
24.4.4.4
24.4.4.5

Crear bloques de función ProDiag .....................................................................................8676
Sinopsis de los bloques de función ProDiag......................................................................8676
Estructura de un bloque de función ProDiag .....................................................................8677
Guardar la disposición de las columnas en el FB ProDiag ................................................8677
Crear bloques de función ProDiag .....................................................................................8678
Crear FB ProDiag al crear supervisiones globales ............................................................8678
Crear FB ProDiag en la llamada del bloque.......................................................................8679
Crear FB ProDiag en el bloque de instancia de un FB ......................................................8680
Crear FB ProDiag con el cuadro de diálogo "Agregar nuevo bloque". ..............................8681
Crear FB ProDiag en las tablas sinópticas de ProDiag .....................................................8682

24.5
24.5.1
24.5.2

Utilizar un sello de tiempo central ......................................................................................8683
Utilizar un sello de tiempo central ......................................................................................8683
Varios avisos de supervisión de un FB ProDiag en un tiempo de ciclo .............................8685

24.6
24.6.1
24.6.2
24.6.3
24.6.4

Utilizar bloques de datos de instancia ProDiag..................................................................8686
Estructura de un bloque de datos de instancia ProDiag de la versión 1.0.........................8686
Contenido de un bloque de datos de instancia ProDiag de la versión 1.0.........................8687
Estructura de un bloque de datos de instancia ProDiag de la versión 2.0.........................8693
Contenido de un bloque de datos de instancia ProDiag de la versión 2.0.........................8694

24.7
24.7.1
24.7.2
24.7.2.1
24.7.2.2
24.7.2.3
24.7.3
24.7.3.1
24.7.3.2
24.7.4
24.7.4.1
24.7.4.2
24.7.5

Definir las propiedades de un bloque de función ProDiag .................................................8701
Estructura de los ajustes de supervisión en el FB ProDiag ...............................................8701
Crear criterios de habilitación para avisos de supervisión .................................................8702
Sinopsis de los criterios de habilitación .............................................................................8702
Utilizar el criterio de habilitación global ..............................................................................8704
Utilizar el criterio de habilitación de la categoría................................................................8704
Definir una variable de confirmación para categorías individuales ....................................8705
Visión de conjunto de las variables de confirmación .........................................................8705
Utilizar una variable de confirmación .................................................................................8706
Configurar discriminadores ................................................................................................8706
Sinopsis de los discriminadores.........................................................................................8706
Configurar el discriminador ................................................................................................8707
Mostrar el número de supervisiones de un FB ProDiag ....................................................8707

24.8
24.8.1
24.8.2
24.8.2.1
24.8.2.2
24.8.2.3
24.8.2.4
24.8.3
24.8.3.1
24.8.3.2
24.8.3.3
24.8.3.4
24.8.3.5

Definir la configuración de supervisiones de ProDiag........................................................8708
Sinopsis de la configuración de supervisiones de ProDiag ...............................................8708
Definir los ajustes generales de supervisión de ProDiag...................................................8709
Estructura de los ajustes de supervisión ProDiag..............................................................8709
Categorías..........................................................................................................................8710
Subcategorías ....................................................................................................................8713
Tipos de supervisiones ......................................................................................................8716
Definir textos de aviso ProDiag centralizados....................................................................8719
Estructura del editor de textos de aviso .............................................................................8719
Estructura de un aviso de supervisión GRAPH .................................................................8722
Estructura de un aviso de supervisión global (variable).....................................................8723
Estructura de un aviso de supervisión local (parámetros) .................................................8724
Crear textos de aviso .........................................................................................................8727

Programación del PLC
Manual de programación y manejo, 11/2019

31

Índice

24.8.3.6
24.8.4
24.8.5

Exportación de textos de ProDiag y GRAPH .....................................................................8727
Exportar la configuración de supervisiones de ProDiag ....................................................8728
Importar la configuración de supervisiones de ProDiag.....................................................8729

24.9
24.9.1
24.9.2
24.9.3
24.9.4
24.9.5
24.9.5.1
24.9.5.2
24.9.5.3
24.9.6

Crear supervisiones ProDiag .............................................................................................8730
Sinopsis de las supervisiones ............................................................................................8730
Posibilidades de uso de las supervisiones.........................................................................8733
Crear supervisiones globales.............................................................................................8734
Crear supervisiones locales ...............................................................................................8736
Crear un campo de texto específico ..................................................................................8739
Uso de los valores asociados ............................................................................................8739
Crear un campo de texto específico ..................................................................................8741
Mostrar y editar traducciones del campo de texto específico ............................................8742
Borrar supervisión ..............................................................................................................8743

24.10
24.10.1
24.10.2
24.10.3

Copiar bloques de función ProDiag ...................................................................................8744
Instrucciones rápidas para copiar de bloques de función ProDiag ....................................8744
Copiar bloques de función ProDiag ...................................................................................8745
Insertar un bloque de función ProDiag...............................................................................8745

24.11
24.11.1
24.11.2
24.11.3
24.11.4
24.11.5
24.11.6

Asignar bloques de función ProDiag..................................................................................8746
Sinopsis de la asignación a un FB ProDiag .......................................................................8746
Asignar supervisiones globales a un FB ProDiag ..............................................................8747
Asignar supervisiones locales a un FB ProDiag ................................................................8748
Asigna bloque de datos de instancia a un FB ProDiag (supervisiones locales) ................8749
Modificar la asignación existente de un FB ProDiag..........................................................8750
Eliminar la asignación existente de un FB ProDiag ...........................................................8752

24.12
24.12.1
24.12.2
24.12.3
24.12.4

Editar bloques de función ProDiag.....................................................................................8753
Insertar supervisiones nuevas en el FB ProDiag ...............................................................8753
Copiar supervisiones en el FB ProDiag .............................................................................8753
Borrar supervisiones en el FB ProDiag..............................................................................8754
Ordenar supervisiones en el FB ProDiag...........................................................................8755

24.13
24.13.1

Llamar bloques de función ProDiag ...................................................................................8755
Sinopsis de la llamada de los bloques de función ProDiag ...............................................8755

24.14
24.14.1

Cargar bloques ProDiag.....................................................................................................8756
Cargar bloques ProDiag.....................................................................................................8756

24.15
24.15.1
24.15.2
24.15.2.1
24.15.2.2
24.15.2.3
24.15.2.4
24.15.3
24.15.3.1
24.15.3.2
24.15.3.3
24.15.3.4
24.15.3.5

Visualizar supervisiones ProDiag.......................................................................................8757
Sinopsis de las posibilidades de visualización...................................................................8757
Visualizar las supervisiones en el editor de sinopsis ProDiag ...........................................8758
Estructura del editor de sinopsis ProDiag ..........................................................................8758
Ver las supervisiones de todas las variables globales.......................................................8758
Mostrar las supervisiones de todos los bloques de función...............................................8759
Mostrar las supervisiones de todos los bloques de función llamados ...............................8760
Editar el editor de la vista general ProDiag........................................................................8761
Agregar supervisiones de variables en el editor de sinopsis ProDiag ...............................8761
Copiar supervisiones de variables en el editor de sinopsis ProDiag .................................8761
Borrar supervisiones de variables en el editor de sinopsis ProDiag ..................................8762
Clasificar supervisiones de variables en el editor de sinopsis ProDiag .............................8763
Editar definiciones de supervisión en el bloque de función en el editor de sinopsis
ProDiag ..............................................................................................................................8763
Borrar definiciones de supervisión en el bloque de función en el editor de sinopsis
ProDiag ..............................................................................................................................8764

24.15.3.6

32

Programación del PLC
Manual de programación y manejo, 11/2019

Índice

24.15.4
24.15.5

Mostrar las supervisiones de un bloque de función ...........................................................8764
Mostrar las supervisiones de un bloque de función ProDiag .............................................8765

24.16
24.16.1

Mostrar bloques definidos por el usuario supervisados .....................................................8766
Mostrar bloques definidos por el usuario supervisados .....................................................8766

24.17
24.17.1
24.17.2
24.17.3

Exportar e importar supervisiones ProDiag y propiedades de un FB ProDiag ..................8767
Sinopsis de la exportación e importación de supervisiones y propiedades de un FB
ProDiag ..............................................................................................................................8767
Exportar supervisiones y propiedades de un FB ProDiag .................................................8769
Importar supervisiones y propiedades de un FB ProDiag..................................................8771

24.18
24.18.1
24.18.2
24.18.3

Exportar e importar asignaciones de FB ProDiag a DB de instancia.................................8773
Sinopsis de la exportación e importación de asignaciones................................................8773
Exportar asignaciones........................................................................................................8774
Importar asignaciones........................................................................................................8774

24.19
24.19.1
24.19.2

Mostrar referencias cruzadas ProDiag...............................................................................8775
Resumen de referencias cruzadas ....................................................................................8775
Mostrar referencias cruzadas.............................................................................................8776

24.20
24.20.1
24.20.2
24.20.3

Adquisición de primeros valores ........................................................................................8777
Sinopsis de la adquisición de primeros valores .................................................................8777
Activar la adquisición de primeros valores.........................................................................8780
Ejemplo de orden en la lista...............................................................................................8780

Índice alfabético......................................................................................................................................8783

Programación del PLC
Manual de programación y manejo, 11/2019

33

Índice

34

Programación del PLC
Manual de programación y manejo, 11/2019

1

Principios básicos de la programación
1.1

Sistema operativo y programa de usuario
La figura siguiente muestra la interacción entre el sistema operativo y el programa de usuario.

Programa de usuario

FB
Hardware

iDB

FC

OS
OB

FC

FC

Global
DB

Sistema operativo (OS)
El sistema operativo está contenido en toda CPU y sirve para organizar todas las funciones y
procesos de la CPU no relacionados con una tarea de control específica.
Algunas de las tareas del sistema operativo son p. ej.:
● Ejecutar un rearranque (en caliente)
● Actualización de las memorias imagen de proceso de las entradas y salidas
● Llamada del programa de usuario
● Registro de alarmas y llamada de los OBs de alarma
● Detección y tratamiento de errores
● Administración de áreas de memoria
El sistema operativo forma parte de la CPU y ya está contenido en ella en el momento de
suministro.

Programa de usuario
El programa de usuario contiene todas las funciones necesarias para ejecutar la tarea de
automatización específica.

Programación del PLC
Manual de programación y manejo, 11/2019

35

Principios básicos de la programación
1.2 Bloques del programa de usuario
Algunas de las tareas del programa de usuario son:
● Comprobación de los requisitos previos para un rearranque completo (en caliente) con
ayuda de los OB de arranque, p. ej. final de carrera en posición correcta o dispositivo de
seguridad activo
● Tratamiento de datos de proceso, p. ej. combinación lógica de señales binarias, lectura y
evaluación de valores analógicos, definición de señales binarias para la salida, salida de
valores analógicos
● Reacción a alarmas, p. ej. alarma de diagnóstico al rebasar por debajo el valor límite de un
módulo de ampliación analógico
● Tratamiento de fallos o averías durante la ejecución normal del programa
El usuario crea el programa de usuario y lo carga en la CPU.

1.2

Bloques del programa de usuario

1.2.1

Programación lineal y estructurada

Programación lineal
Las tareas de automatización pequeñas pueden solucionarse escribiendo todo el programa de
usuario linealmente en un OB de ciclo. Esto se recomienda solo para programas sencillos.
La figura siguiente muestra esquemáticamente un programa lineal: El OB de ciclo "Main"
contiene el programa de usuario completo.
Programa principal

OB
Main

36

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.2 Bloques del programa de usuario

Programación estructurada
Para simplificar la creación y mantenimiento de tareas complejas de automatización, es
conveniente subdividirlas en tareas parciales más pequeñas que correspondan a las diversas
funciones tecnológicas del proceso de automatización o que puedan utilizarse varias veces.
En el programa de usuario, estas tareas parciales se representan mediante bloques. Cada
bloque es una sección independiente del programa de usuario.
La estructuración del programa ofrece las ventajas siguientes:
● Los programas grandes pueden programarse de forma clara.
● Es posible estandarizar partes de programas y utilizarlas varias veces con diferentes
parámetros.
● La organización del programa se simplifica.
● El programa se puede modificar más fácilmente.
● La comprobación del programa se simplifica, puesto que puede realizarse por secciones.
● La puesta en marcha se simplifica.
La figura siguiente muestra un esquema de un programa estructurado: El OB de ciclo "Main"
llama subprogramas consecutivamente que ejecutan tareas parciales definidas.
Programa principal

OB
Main

Subprograma

Bloque 1

Bloque 2

Profundidad de anidamiento de bloques
La profundidad de anidamiento permitida para bloques depende de la CPU utilizada.
La tabla siguiente muestra los valores orientativos para la profundidad de anidamiento
máxima. Encontrará indicaciones específicas para la CPU utilizada en los datos técnicos de la
documentación de hardware. Para consultar la documentación de hardware en Internet haga
clic en los enlaces de la tabla.

Programación del PLC
Manual de programación y manejo, 11/2019

37

Principios básicos de la programación
1.2 Bloques del programa de usuario

Familia de
CPU

Profundidad de anidamiento (valor orientativo)

Enlace a la documentación de hardware

S7-1500

24 bloques por clase de prioridad

SIMATIC S7-1500 / ET 200MP Manual Collection
(https://support.industry.siemens.com/cs/ww/es/
view/86140384)

S7-1200

16 bloques del OB de ciclo o de arranque, 6 bloques
adicionales dentro de cualquier OB de evento de
alarma

Sistema de automatización SIMATIC S7-1200
(https://support.industry.siemens.com/cs/ww/es/
view/91696622)

S7-400

24 bloques por clase de prioridad, 1 a 2 bloques adi‐ Sistema de automatización SIMATIC S7-400, datos
cionales dentro de un OB de error
de la CPU S7-400 (https://
support.industry.siemens.com/cs/de/en/view/
53385241)

S7-300

16 bloques por clase de prioridad, 4 bloques adicio‐ SIMATIC S7-300 CPU 31xC y CPU 31x: Datos técni‐
nales dentro de un OB de error
cos (https://support.industry.siemens.com/cs/de/de/
view/12996906/es)

ET 200SP

24 bloques

SIMATIC ET 200SP Manual Collection (https://
support.industry.siemens.com/cs/ww/es/view/
84133942)

Profundidad de anidamiento de estructuras
Las estructuras (STRUCT) y los tipos de datos PLC (UDT) pueden anidarse hasta una
profundidad de 8. Esta profundidad de anidamiento es independiente de la CPU utilizada.

1.2.2

Sinopsis de los tipos de bloques

Tipos de bloques
Para realizar las tareas en un sistema de automatización se dispone de distintos tipos de
bloques. La tabla siguiente muestra los tipos de bloques disponibles:
Tipo de bloque

Descripción breve

Bloques de organización (Página 39) (OB)

Los bloques de organización determinan la estructura del programa de
usuario.

Funciones (Página 39) (FC)

Las funciones contienen rutinas de programa para tareas que se repiten con
frecuencia. Carecen de "memoria".

Bloques de función (Página 40) (FB)

Los bloques de función son bloques lógicos que depositan sus valores de
forma permanente en bloques de datos instancia, de modo que siguen dis‐
ponibles tras procesar el bloque.

Bloques de datos instancia (Página 52)

Cuando se llama un bloque de función, se le asignan los bloques de datos
instancia, en los que se almacenan los datos de programa.

Bloques de datos globales (Página 41)

Los bloques de datos globales son áreas de datos para almacenar datos que
pueden ser utilizados por cualquier bloque.

38

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.2 Bloques del programa de usuario

1.2.3

Bloques de organización (OB)

Definición
Los bloques de organización (OBs) constituyen la interfaz entre el sistema operativo y el
programa de usuario. Son llamados por el sistema operativo y controlan p. ej. los siguientes
procesos:
● Comportamiento en arranque del sistema de automatización
● Ejecución cíclica del programa
● Ejecución del programa controlada por alarmas
● Tratamiento de errores
Programando los bloques de organización se define el comportamiento de la CPU. En función
de la CPU utilizada, se dispone de diferentes bloques de organización.
Encontrará más información acerca de los bloques de organización en las descripciones de los
modos de funcionamiento de las CPU en el capítulo "Información adicional sobre
configuraciones" de "Configurar dispositivos y redes".

Información de arranque de bloques de organización
Al arrancar algunos bloques de organización, el sistema operativo ofrece información que
puede evaluarse en el programa de usuario. En las descripciones de los bloques de
organización se indica si se ofrece información y de qué información se trata.

Consulte también
Crear bloques de organización (Página 7728)

1.2.4

Funciones (FC)

Definición
Las funciones (FCs) son bloques lógicos sin memoria. No poseen una memoria de datos que
permita almacenar valores de parámetros de bloque. Por este motivo, al llamar una función es
preciso asignar parámetros actuales a todos los parámetros formales.
Para almacenar los datos de forma permanente, las funciones disponen de bloques de
datos globales.

Programación del PLC
Manual de programación y manejo, 11/2019

39

Principios básicos de la programación
1.2 Bloques del programa de usuario

Campo de aplicación
Una función contiene un programa que se ejecuta cada vez que la función es llamada por otro
bloque lógico. Las funciones se pueden utilizar p. ej. para los siguientes fines:
● Devolver valores de función al bloque invocante, p. ej. en funciones matemáticas
● Ejecutar funciones tecnológicas, p. ej. controles individuales con operaciones lógicas
binarias
Una función también se puede llamar varias veces en diferentes puntos de un programa. Esto
facilita la programación de funciones de uso frecuente.
Nota
Transferencia de parámetros al llamar funciones
Para evitar errores al trabajar con funciones, consulte el capítulo "Transferencia de parámetros
en la llamada de un bloque (Página 80)".

Consulte también
Crear funciones y bloques de función (Página 7729)

1.2.5

Bloques de función (FB)

Definición
Los bloques de función son bloques lógicos que depositan sus parámetros de entrada, salida
y entrada/salida de forma permanente en bloques de datos instancia, de modo que siguen
estando disponibles después de editar el bloque. Por eso también se denominan "bloques con
memoria".
Los bloques de función también pueden funcionar con variables temporales. No obstante, las
variables temporales no se almacenan en el DB instancia, sino que únicamente permanecen
disponibles durante un ciclo.

Campo de aplicación
Los bloques de función contienen subprogramas que se ejecutan cada vez que un bloque de
función es llamado por otro bloque lógico. Un bloque de función también se puede llamar varias
veces en diferentes puntos de un programa. Esto facilita la programación de funciones de uso
frecuente.

Instancias de bloques de función
La llamada de un bloque de función se denomina instancia. Para cada instancia de un bloque
de función se requiere un bloque de datos de instancia en el que se almacenen valores
específicos de la instancia para los parámetros formales declarados en el FB.

40

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.2 Bloques del programa de usuario
El bloque de función puede depositar sus datos específicos de la instancia en un bloque de
datos de instancia propio o en el bloque de datos de instancia del bloque que realiza la llamada.

Tipos de acceso
Los S7-1200 y S7-1500 ofrecen para los bloques de datos de instancia dos posibilidades de
acceso diferentes que se asignan a un bloque de función al llamarlo:
● Bloques de datos con acceso optimizado
Los bloques de datos de acceso optimizado carecen de una estructura de memoria
definida. En la declaración se asigna a los elementos de datos un nombre simbólico, pero
no una dirección fija dentro del bloque.
● Bloques de datos con acceso estándar (compatible con S7-300/400)
Los bloques de datos de acceso estándar tienen una estructura de memoria fija. En la
declaración se asigna a los elementos de datos un nombre simbólico y también una
dirección fija dentro del bloque.
Nota
Para evitar errores al trabajar con bloques de función, consulte el capítulo "Transferencia de
parámetros en la llamada de un bloque (Página 80)".

Consulte también
Crear funciones y bloques de función (Página 7729)
Multiinstancias (Página 64)
Bloques de datos instancia (Página 52)
Fundamentos del acceso a bloques (Página 54)

1.2.6

Bloques de datos globales (DB)

Definición
Los bloques de datos sirven para almacenar datos de programa. Así, los bloques de datos
contienen datos variables con los que trabaja el programa de usuario. Los bloques de datos
globales almacenan datos de usuario utilizables desde todos los demás bloques.
El tamaño máximo de los bloques de datos varía en función de la CPU. La estructura de
bloques de datos globales puede definirse a discreción.
También es posible utilizar tipos de datos PLC (UDT) como plantilla para crear bloques de
datos globales.

Programación del PLC
Manual de programación y manejo, 11/2019

41

Principios básicos de la programación
1.2 Bloques del programa de usuario

Bloques de datos globales en el programa de usuario
Todo bloque de función, toda función o todo bloque de organización puede leer datos de un
bloque de datos global o escribir datos en este. Estos datos se conservan en el bloque de datos
incluso al cerrarlo. Un bloque de datos global y un bloque de datos instancia pueden estar
abiertos simultáneamente.
La figura siguiente muestra diferentes accesos a bloques de datos:

Función

FC 1
DB_
Global

Función

FC 2

DB global con
acceso para todos
los bloques

Bloque de función

FB 3
DB_
Instance
(iDB 3)

DB de
instancia del
FB 3

Tipos de acceso
Las S7-1200 y S7-1500 ofrecen dos posibilidades diferentes de acceso para bloques de datos
globales:
● Bloques de datos con acceso optimizado
Los bloques de datos con acceso optimizado carecen de una estructura definida. En la
declaración se asigna a los elementos de datos un nombre simbólico, pero no una dirección
fija dentro del bloque.
● Bloques de datos con acceso estándar (compatible con S7-300/400)
Los bloques de datos con acceso estándar tienen una estructura fija. En la declaración se
asigna a los elementos de datos un nombre simbólico y también una dirección fija dentro
del bloque.

Consulte también
Crear bloques de datos (Página 7843)
Fundamentos del acceso a bloques (Página 54)

42

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.2 Bloques del programa de usuario

1.2.7

Bloques de datos ARRAY globales (DB)

Bloques de datos ARRAY (S7-1500)
Un tipo especial de bloques de datos globales son los bloques de datos ARRAY. Están
formados por un ARRAY de un tipo de datos cualquiera. Puede ser un ARRAY de un tipo de
datos PLC (UDT), por ejemplo. El DB no contiene otros elementos más que el ARRAY. Gracias
a su estructura plana, los bloques de datos ARRAY facilitan el acceso a los elementos ARRAY
y su transmisión a bloques llamados.
Para los bloques de datos ARRAY, el atributo "Acceso optimizado al bloque" siempre está
activado. No se admiten bloques de datos ARRAY con acceso estándar.
La sección "Transferencia > DB ARRAY" de la Task Card "Instrucciones > Instrucciones
básicas" ofrece opciones avanzadas para direccionar bloques de datos ARRAY. Estas
instrucciones ofrecen la posibilidad de direccionar el nombre del DB de forma indirecta, por
ejemplo:
● ReadFromArrayDB: Leer en un bloque de datos ARRAY
● WriteToArrayDB: Escribir en un bloque de datos ARRAY
● ReadFromArrayDBL: Leer en un bloque de datos ARRAY de la memoria de carga
● WriteToArrayDBL: Escribir en bloque de datos Array de la memoria de carga

Consulte también
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Direccionamiento de los DB ARRAY (Página 115)
Crear bloques de datos (Página 7843)

1.2.8

Ejemplo de uso de bloques de datos ARRAY

Uso de un bloque de datos ARRAY (S7-1500)
Los bloques de datos ARRAY son bloques de datos globales que constan únicamente de un
ARRAY. En la mayoría de los casos es suficiente un bloque de datos con una variable del tipo
de datos ARRAY, pues los accesos pueden programarse de forma intuitiva con una variable
del tipo de datos ARRAY (p. ej. #myArray[#index]) y ofrecen un rendimiento mejor en tiempo
de ejecución que los bloques de datos ARRAY. Sin embargo, en determinadas circunstancias
es necesario procesar ARRAYs de distinta longitud distinta. El bloque de datos ARRAY es
adecuado justamente para estos casos.
El ejemplo siguiente muestra cómo se utiliza un bloque de datos ARRAY.

Programación del PLC
Manual de programación y manejo, 11/2019

43

Principios básicos de la programación
1.2 Bloques del programa de usuario

Ejemplo de programación
Una cinta transporta piezas de material sueltas. Estas piezas pasan por un escáner capaz de
leer la información que lleva cada una de ellas. La información es leída y transferida a un panel.
Como el escáner y el panel tienen diferentes ciclos/velocidades, la información debe
almacenarse en una memoria intermedia.
En el siguiente ejemplo de programación se muestra cómo programar el código del programa
para transmitir la información de material. Para ello se usa un bloque de datos ARRAY.
El ejemplo se ha estructurado de forma tan flexible que en el momento de crear el código del
programa todavía no es necesario saber qué bloque de datos de ARRAY se lee o se escribe
ni qué tamaño tiene. De ese modo se pueden utilizar ARRAYs de diferente longitud. Esa
flexibilidad se consigue utilizando el tipo de datos DB_ANY.
Para mantener esta flexibilidad al indicar el valor que se va a leer o escribir, se utiliza el tipo de
datos VARIANT.
El bloque de datos ARRAY no se transfiere hasta el momento de su ejecución, para luego
acceder a los valores en el bloque de programa. Se determina el tipo de datos de los elementos
del ARRAY y el tipo de datos del valor que se va a leer o escribir.
El número de objetos y el grado de relleno del bloque de datos ARRAY se determinan con
ayuda de instrucciones especiales.

Procedimiento
Cree el tipo de datos PLC "UDT_Queue". Este tipo de datos de PLC se utiliza en ambas
funciones ("FC_Enqueue" y "FC_Dequeue"). Esto es importante, p. ej., para acceder a la
variable #Queue.Used, ya que la función "FC_Enqueue" incrementa la variable en una unidad
y la función "FC_Dequeue" decrementa la variable en una unidad.
1. En el árbol del proyecto, dentro de la carpeta "Tipos de datos PLC", haga doble clic en el
comando "Agregar nuevo tipo de datos".
Para crear un tipo de datos PLC se crea y se abre una tabla de declaración nueva.
2. Declare las siguientes líneas dentro del tipo de datos PLC:
DB > Tipo de datos: DB_ANY
Size > Tipo de datos: DINT
Used > Tipo de datos: DINT
ReadPos > Tipo de datos: DINT
WritePos > Tipo de datos: DINT

Programe la función "FC_Enqueue", que escribe los valores de la información de material en
un bloque de datos ARRAY. No es necesario conocer el bloque de datos ARRAY concreto ni

44

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.2 Bloques del programa de usuario
el tipo de datos del valor en ese momento, ya que las interfaces se programan con los tipos de
datos VARIANT y DB_ANY.
1. Cree una función SCL y llámela "FC_Enqueue".
2. Declare la interfaz del bloque de la manera siguiente:

3. Escriba el siguiente código de programa:

Programación del PLC
Manual de programación y manejo, 11/2019

45

Principios básicos de la programación
1.2 Bloques del programa de usuario

Con esta función se comprueba si queda espacio libre en el bloque de datos. En caso
afirmativo, escriba en el parámetro db del bloque de datos el valor indicado en el parámetro
value Con cada nueva información de material que se escribe, la variable #Queue.Used y
la variable de puntero #Queue.WritePos se incrementan en una unidad. En cuanto el
puntero de escritura llega al final del bloque de datos, vuelve a ponerse a 0. Cuando el
bloque de datos está lleno, se devuelve el código de error #4711.
Programe la función "FC_Dequeue", que leerá la información de material de un bloque de
datos ARRAY y la escribirá en el panel. No es necesario conocer el bloque de datos ARRAY
concreto ni el tipo de datos del valor en ese momento, ya que las interfaces se programan con

46

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.2 Bloques del programa de usuario
los tipos de datos VARIANT y DB_ANY. A continuación se puede visualizar la información de
material p. ej., en un panel:
1. Cree una función SCL y llámela "FC_Dequeue".
2. Declare la interfaz del bloque de la manera siguiente:

3. Escriba el siguiente código de programa:

Programación del PLC
Manual de programación y manejo, 11/2019

47

Principios básicos de la programación
1.2 Bloques del programa de usuario

Con esta función se comprueba si en el bloque de datos hay información de material. En
caso afirmativo, lea el valor al que señala el puntero #Queue.ReadPos y escríbalo en la
variable #Value. Con cada información de material que se lee, la variable #Queue.Used se
decrementa en una unidad y la variable de puntero #Queue.ReadPos se incrementa en una
unidad. En cuanto el puntero de lectura llega al final del bloque de datos, vuelve a ponerse
a 0. Si el bloque de datos está vacío, se devuelve el código de error #4712.
Para guardar los datos de material cree un bloque de datos ARRAY. Como tipo de datos del
bloque de datos ARRAY utilice el tipo de datos PLC "Material_UDT".

48

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.2 Bloques del programa de usuario
Cree primero el tipo de datos PLC "UDT_Material": Este tipo de datos PLC contiene una
estructura para la información de material suministrada por el escáner.
1. En el árbol del proyecto, dentro de la carpeta "Tipos de datos PLC", haga doble clic en el
comando "Agregar nuevo tipo de datos".
Para crear un tipo de datos PLC se crea y se abre una tabla de declaración nueva.
2. Declare las siguientes líneas dentro del tipo de datos PLC:
ArticleNumber > Tipo de datos: DINT
ArticleName > Tipo de datos: STRING
Amount > Tipo de datos: REAL
Unit > Tipo de datos: STRING

Cree el bloque de datos ARRAY "DB_MaterialBuffer". El bloque de datos ARRAY debe
contener registros con información de material del tipo de datos "UDT_Material". La
información de material se escribe en el bloque de datos ARRAY con la función "FC_Enqueue".
1. Haga doble clic en el comando "Agregar nuevo bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
2. Haga clic en el botón "Bloque de datos (DB)".
3. Introduzca el nombre "DB_MaterialBuffer".
4. Seleccione "DB ARRAY" como tipo de bloque de datos.
5. Como tipo de datos ARRAY, seleccione el tipo de datos PLC "UDT_Material".
6. Introduzca "1000" como límite superior de ARRAY.
7. Haga clic en "Aceptar".

Programación del PLC
Manual de programación y manejo, 11/2019

49

Principios básicos de la programación
1.2 Bloques del programa de usuario

Cree el bloque de organización (OB) de arranque "OB_MaterialQueue". En este bloque de
organización, inicialice las variables DB y Size.
1. Haga doble clic en el comando "Agregar nuevo bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
2. Haga clic en el botón "Bloque de organización (OB)".
3. Introduzca el nombre "OB_MaterialQueue".
4. Elija el tipo "Startup".
5. Como lenguaje del bloque de organización, seleccione SCL.
6. Haga clic en "Aceptar".
7. Escriba el siguiente código de programa:

Asignando el bloque de datos se conecta el bloque de datos ARRAY "DB_MaterialBuffer"
con las funciones SCL "FC_Enqueue" y "FC_Dequeue". En el parámetro Size, indique el
tamaño del bloque de datos ARRAY. El valor de arranque del parámetro Used es "0", para
que la primera información de material se escriba en el elemento de ARRAY "0".
1. En la "Tabla de variables estándar", declare las siguientes variables:

2. Llame a la función SCL "FC_Enqueue" dentro del bloque de función donde el escáner lee
la información de material.
3. En la interfaz del bloque, declare la variable "ConnectionToUDT" en la sección "Temp" y
conéctela con el tipo de datos PLC "UDT_Material":

50

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.2 Bloques del programa de usuario
4. Conecte la llamada de función con las siguientes variables y, en la entrada de habilitación
EN, cree el flanco de señal "P: Consultar flanco de señal ascendente de un operando".
Conecte el flanco de señal con las variables globales de la tabla de variables estándar:

5. Llame a la función SCL "FC_Dequeue".
6. Conecte la llamada de función con las siguientes variables y, en la entrada de habilitación
EN, cree el flanco de señal "P: Consultar flanco de señal ascendente de un operando".
Conecte el flanco de señal con las variables globales de la tabla de variables estándar:

Resultado
En cuanto está presente un flanco de señal positivo, se escribe información de material en un
bloque de datos ARRAY mediante la instrucción "WriteToArrayDB" y se transfiere al panel
mediante la instrucción "ReadFromArrayDB".

Consulte también
Bloques de datos ARRAY globales (DB) (Página 43)
Direccionamiento de los DB ARRAY (Página 115)

Programación del PLC
Manual de programación y manejo, 11/2019

51

Principios básicos de la programación
1.2 Bloques del programa de usuario

1.2.9

Bloques de datos instancia

Definición
La llamada de un bloque de función se denomina instancia. Los datos con los que trabaja la
instancia se almacenan en un bloque de datos instancia.
El tamaño máximo de los bloques de datos instancia varía en función de la CPU. Las variables
declaradas en el bloque de función determinan la estructura del bloque de datos instancia.

Tipos de acceso
Los S7-1200 y S7-1500 ofrecen para los bloques de datos de instancia dos posibilidades de
acceso diferentes que se asignan a un bloque de función al llamarlo:
● Bloques de datos con acceso optimizado
Los bloques de datos con acceso optimizado carecen de una estructura definida. En la
declaración se asigna a los elementos de datos un nombre simbólico, pero no una dirección
fija dentro del bloque.
● Bloques de datos con acceso estándar (compatible con S7-300/400)
Los bloques de datos con acceso estándar tienen una estructura fija. En la declaración se
asigna a los elementos de datos un nombre simbólico y también una dirección fija dentro
del bloque.

Consulte también
Crear bloques de datos (Página 7730)
Fundamentos del acceso a bloques (Página 54)
Instancias (Página 61)
Insertar llamadas de bloque en KOP (Página 7965)
Insertar llamadas de bloque en FUP (Página 8025)

1.2.10

Bloques de datos de CPU

Definición
Los bloques de datos de CPU son bloques de datos que la CPU genera en runtime. Para ello,
inserte en el programa de usuario la instrucción "CREATE_DB". Una vez que el bloque de
datos se ha generado en runtime, se puede utilizar para guardar los datos.
Los bloques de datos de CPU se muestran dentro de un dispositivo accesible en la carpeta
"Bloques de programa" con un pequeño símbolo de una CPU. Los valores actuales de las
variables de un bloque de datos de CPU se pueden observar online como los de cualquier otro
tipo de bloque de datos.
Los bloques de datos de CPU no se pueden crear offline en el proyecto.

52

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.2 Bloques del programa de usuario

Cargar bloques de datos de CPU
Una vez que el programa de usuario ha generado el bloque de datos de CPU con la instrucción
"CREATE_DB", en un primer momento el bloque solo estará disponible en modo online en el
dispositivo. En la siguiente carga completa en la que se carguen los bloques del dispositivo al
proyecto también se cargarán en él todos los bloques de datos de CPU. Los bloques de datos
de CPU se marcan con un pequeño símbolo de una CPU. Sin embargo, los bloques de datos
de CPU ya no pueden volver a cargarse en el dispositivo.

Limitaciones de bloques de datos de CPU en el proyecto
Si los bloques de datos de CPU se cargaron en el proyecto offline con un proceso de carga, se
podrán abrir y se podrá visualizar su contenido. No obstante, recuerde que los bloques de
datos de CPU están protegidos contra escritura en el proyecto. Por ello, dentro del proyecto los
bloques de datos de CPU están sometidos a las siguientes limitaciones:
● No es posible editar bloques de datos de CPU ni convertirlos a otro tipo de bloque de datos.
● Los bloques de datos de CPU no pueden dotarse con protección de know-how.
● El lenguaje de programación de los bloques de datos de CPU no puede cambiarse.
● Los bloques de datos de CPU no pueden compilarse ni cargarse en el dispositivo.

Comparar bloques de datos de CPU
Si los bloques de datos de CPU se cargaron en el proyecto offline con un proceso de carga, se
puede realizar una comparación offline/online de los bloques de datos de CPU cargados. En
el editor de comparación se obtiene una vista general de las diferencias. No obstante, los
bloques de datos de CPU que difieren en las versiones online y offline no pueden sincronizarse
cargando la versión offline en el dispositivo.

Borrar bloques de datos de CPU
Los bloques de datos de CPU se pueden borrar tanto del proyecto como de la CPU.

Consulte también
Borrar bloques de datos de CPU (Página 7753)

Programación del PLC
Manual de programación y manejo, 11/2019

53

Principios básicos de la programación
1.2 Bloques del programa de usuario

1.2.11

Bloques con acceso optimizado

1.2.11.1

Fundamentos del acceso a bloques

Introducción
STEP 7 ofrece bloques de datos con distintas posibilidades de acceso:
● Bloques de datos con acceso optimizado (S7-1200/S7-1500)
● Bloques de datos con acceso estándar (S7-300 / S7-400 / S7-1200 / S7-1500)
Ambos tipos de bloques se pueden combinar en un programa.

Bloques de datos con acceso optimizado
Los bloques de datos con acceso optimizado carecen de una estructura definida. En la
declaración se asigna a los elementos de datos un nombre simbólico, pero no una dirección fija
dentro del bloque. Los elementos se disponen automáticamente en el área de memoria
disponible del bloque de manera que no haya huecos en la memoria. De este modo se
aprovecha al máximo la capacidad de memoria.
Las variables de estos bloques de datos se identifican por medio de su nombre simbólico. Para
direccionar las variables debe indicarse su nombre simbólico. Por ejemplo, a la variable "Nivel"
del DB "Datos" se accede del siguiente modo:
"Datos".Nivel
Los bloques con acceso optimizado ofrecen las ventajas siguientes:
● Es posible crear bloques de datos con una estructura cualquiera sin tener en cuenta la
disposición física de los diferentes elementos de datos.
● El acceso a datos optimizados se realiza siempre con la mayor rapidez posible, puesto que
el sistema optimiza y administra el almacenamiento de datos.
● Se excluyen los errores de acceso, p. ej. en caso de direccionamiento indirecto o desde la
HMI.
● Las distintas variables pueden definirse como remanentes de forma selectiva.
● Los bloques optimizados disponen por defecto de una reserva de memoria que permite
ampliar las interfaces de bloques de función o datos durante el funcionamiento. Los bloques
modificados pueden cargarse sin necesidad de pasar la CPU a STOP y sin afectar a los
valores de las variables ya cargadas.
Nota
El atributo "Acceso optimizado al bloque" siempre está activado para los bloques siguientes y
no puede desmarcarse:
● bloques GRAPH
● bloques de datos ARRAY

54

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.2 Bloques del programa de usuario

Bloques de datos con acceso estándar
Los bloques de datos con acceso estándar tienen una estructura fija. En la declaración se
asigna a los elementos de datos un nombre simbólico y también una dirección fija dentro del
bloque. La dirección se muestra en la columna "Offset".
En estos bloques de datos, las variables se pueden direccionar de forma simbólica o absoluta.
"Datos".Nivel
DB1.DBW2

Remanencia con acceso optimizado o estándar
Cuando los datos se definen como remanentes, sus valores se conservan si se produce un
fallo de tensión o alimentación. Una variable remanente no se inicializa tras el rearranque, sino
que conserva el valor que tenía antes del fallo de tensión. Si una variable DB se define como
remanente, queda depositada en el área de memoria remanente del bloque de datos.
Las posibilidades de ajustar la remanencia dependen del tipo de acceso del bloque:
● En los bloques de datos con acceso estándar no se puede definir por separado el
comportamiento de remanencia de las distintas variables. La configuración de remanencia
se aplica a todas las variables del bloque de datos.
● En los bloques de datos con acceso optimizado se puede definir el comportamiento de
remanencia de las distintas variables.
En las variables de tipo de datos estructurado, la configuración de remanencia se aplica
siempre a la totalidad de la estructura. No es posible configurar por separado la remanencia
de diferentes elementos dentro del tipo de datos.

Posibilidades de direccionamiento con acceso optimizado y estándar
Los bloques con acceso optimizado admiten únicamente accesos denominados "con
seguridad de tipo". Dichos accesos direccionan variables utilizando solo el nombre simbólico.
De este modo se descarta la posibilidad de que se produzcan incoherencias en el programa o
errores de acceso, incluso en caso de cambios en el bloque o en su interfaz.
La tabla siguiente muestra las posibilidades de direccionamiento para datos optimizados:

Direccionamiento
Direccionamiento simbólico

Bloque con acceso estándar

Bloque con acceso optimizado

x

x

Direccionamiento indexado de
ARRAYs

x

Accesos Slice

x

x

Solapamiento con AT

x

-

Direccionamiento absoluto

x

-

Direccionamiento indirecto mediante
ANY

x

-

Direccionamiento indirecto mediante
POINTER y VARIANT

x

solo con notación simbólica

Programación del PLC
Manual de programación y manejo, 11/2019

55

Principios básicos de la programación
1.2 Bloques del programa de usuario

Consulte también
Ajustar el acceso a un bloque (Página 56)
Direccionar variables en bloques de datos (Página 112)
Crear bloques (Página 7727)

1.2.11.2

Ajustar el acceso a un bloque

Introducción
El acceso al bloque se ajusta automáticamente al crear un bloque:
● En las CPU de la serie S7-1200/1500, cuando se genera un bloque este tiene acceso
optimizado de forma predeterminada.
● En las CPU de la serie S7-300/S7-400, cuando se genera un bloque este tiene acceso
estándar de forma predeterminada.
Si copia o migra un bloque a una CPU de otra serie, el acceso al bloque no cambia
automáticamente. No obstante, puede ser conveniente modificar manualmente el acceso al
bloque. p. ej. para poder utilizar todas las funciones de la CPU.
Tras cambiar el acceso al bloque, generalmente es necesario volver a compilar y cargar el
programa.
ATENCIÓN
Acceso optimizado en bloques GRAPH
El atributo "Acceso optimizado al bloque" siempre está activado para bloques GRAPH en la
S7-1500 y no puede desmarcarse:

Procedimiento
Para ajustar el acceso al bloque, proceda del siguiente modo:
1. Abra la carpeta "Bloques de programa" en el árbol del proyecto.
2. Haga clic con el botón derecho del ratón en el bloque cuyo acceso desee modificar.
3. Elija el comando "Propiedades" del menú contextual.
Se abre el diálogo de propiedades del bloque.
4. Haga clic en "Atributos" en la navegación local.
5. Active o desactive la opción "Acceso optimizado al bloque".
6. Confirme las entradas con "Aceptar".

Limitaciones y particularidades
Básicamente el acceso al bloque solo puede cambiarse en CPU de las series S7-1200/1500,
ya que solo estas soportan el tipo de acceso "optimizado".

56

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.2 Bloques del programa de usuario
Para ello existen las siguientes limitaciones y particularidades:
● Bloques de datos de instancia
El acceso a los bloques de datos de instancia siempre se rige por el bloque de función
asignado y no puede modificarse manualmente. Si cambia el tipo de acceso de un bloque
de función, será necesario actualizar los bloques de datos de instancia asignados. Al
actualizar se adapta el tipo de acceso del bloque de datos instancia.
● Bloques de sistema y bloques con protección de know-how
En los bloques de sistema y en los bloques con protección de know-how no es posible
modificar manualmente el acceso.
● Bloques de organización
La información estándar de un OB con acceso estándar siempre se encuentra en la interfaz
del bloque en los primeros 20 bytes de la sección "Temp". Por el contrario, la información
de arranque de un OB con acceso optimizado se guarda en la sección "Input". Por ello, en
el caso de los OB al cambiar el acceso al bloque también cambia la interfaz del bloque. Los
detalles se describen en los capítulos siguientes.

Cambiar el acceso al bloque de "estándar" a "optimizado"
Al copiar o migrar un bloque de una CPU de las series S7-300/400 a una CPU S7-1200/1500,
el bloque primero tendrá el tipo de acceso "estándar". Sin embargo, el rendimiento de la
ejecución del programa mejora notablemente utilizando bloques con acceso optimizado. Por
ello puede ser conveniente cambiar el tipo de acceso manualmente.
Al realizar el cambio, los bloques se adaptan del siguiente modo:
● Bloques de función
Todos los parámetros de interfaz obtienen el ajuste de remanencia "no remanente".
● Bloques de datos globales
El ajuste de remanencia que antes estaba ajustado de forma centralizada para todo el
bloque de datos se transfiere a los diferentes parámetros de interfaz. Seguidamente es
posible cambiar manualmente el ajuste de remanencia de los diferentes parámetros.
Pero además rige la regla siguiente: En las variables de tipo de datos estructurado, la
configuración de remanencia se aplica siempre a la totalidad de la estructura. No es posible
configurar por separado la remanencia de diferentes elementos dentro de un tipo de datos
estructurado. Así, en los bloques de datos basados en tipos de datos PLC tampoco se
podrán realizar ajustes de remanencia individuales para las distintas variables.
● Bloques de organización
Todos los parámetros de interfaz que se encuentran en los primeros 20 bytes de la sección
"Temp" se borran. En la sección "Input" se crean nuevas informaciones de arranque
específicas de la CPU. Si con ello aparecen conflictos de nombres con parámetros de
interfaz definidos por el usuario, se cambia el nombre de estos últimos.

Programación del PLC
Manual de programación y manejo, 11/2019

57

Principios básicos de la programación
1.2 Bloques del programa de usuario

PRECAUCIÓN
El cambio del acceso al bloque tiene las siguientes consecuencias:
● Tras cambiar el acceso al bloque a "optimizado" ya no será posible direccionar los
parámetros de interfaz del bloque de forma absoluta.
Ejemplo: #L0.1 ya no está permitido:
● Al cambiar el acceso a bloques de organización a "optimizado" cambia la interfaz del OB.
Debido a este cambio, puede ser necesario adaptar, volver a compilar y cargar el programa.

Cambiar el acceso al bloque de "optimizado" a "estándar"
Para copiar o mover un bloque de una CPU de las series S7-1200/1500 a una CPU de las
series S7-300/400, primero es necesario cambiar el acceso al bloque a "estándar".
Al realizar el cambio, los bloques se adaptan del siguiente modo:
● Bloques de función y bloques de datos globales:
En el bloque de función ya no es posible realizar un ajuste de remanencia. El ajuste se
realiza en el bloque de datos instancia.
Todos los parámetros de interfaz del bloque de datos instancia o del bloque de datos global
obtienen el mismo ajuste de remanencia. El cambio se produce conforme a la siguiente
regla:
– Si todos los parámetros de interfaz eran remanentes en el bloque de partida, tras el
cambio todo el bloque será remanente.
– Si todos los parámetros de interfaz eran no remanentes en el bloque de origen, tras el
cambio todo el bloque será no remanente.
– Si los parámetros de interfaz tenían diferentes ajustes de remanencia en el bloque de
origen, todo el bloque será no remanente tras el cambio.
● Bloques de organización
Se borran todos los parámetros de interfaz que se encuentran en la sección "Input". En la
sección "Temp" se crean nuevas informaciones de arranque específicas de la CPU. Con
ella se ocupan los primeros 20 bytes. Si con ello aparecen conflictos de nombres con
parámetros de interfaz definidos por el usuario, se cambia el nombre de estos últimos.
PRECAUCIÓN
El cambio del acceso al bloque tiene las siguientes consecuencias:
Al cambiar el acceso al bloque a "estándar" los ajustes de remanencia de los parámetros de
interfaz pueden cambiar. Debido a este cambio, puede ser necesario adaptar, volver a
compilar y cargar el programa.

Consulte también
Fundamentos del acceso a bloques (Página 54)
Definir propiedades de bloques (Página 7739)

58

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque

1.3

Llamadas de bloque

1.3.1

Principios básicos de las llamadas de bloque

Función de las llamadas de bloque
Para poder ejecutar los bloques en el programa de usuario, deben llamarse desde otro bloque
distinto.
Si un bloque llama a otro bloque, se ejecutan las instrucciones del bloque llamado. El
procesamiento del bloque llamante no se reanuda hasta que ha finalizado la ejecución del
bloque llamado. La ejecución continúa con la instrucción que sigue a la llamada del bloque.
La figura siguiente muestra cómo se realiza una llamada de bloque en un programa de usuario:
Bloque llamante
(OB, FB o FC)
Ejecución del programa
Bloque llamado
(FB o FC)

Llamada del bloque

Ejecución del
programa

Fin del bloque

Transferencia de parámetros
Al llamar a un bloque, se asignan valores a los parámetros en la interfaz del bloque. Asignando
valores a los parámetros de entrada se determina con qué datos debe procesarse el bloque.
Asignando valores a los parámetros de salida se determina dónde deben almacenarse los
resultados del procesamiento.

Consulte también
Jerarquía de llamada (Página 60)
Principios básicos de las instancias (Página 61)
Transferencia de parámetros en la llamada de un bloque (Página 80)

Programación del PLC
Manual de programación y manejo, 11/2019

59

Principios básicos de la programación
1.3 Llamadas de bloque

1.3.2

Jerarquía de llamada

Definición
Por jerarquía de llamada se entiende el orden y la profundidad de anidamiento de las llamadas
de bloque.
La figura siguiente muestra un ejemplo del orden y la profundidad de anidamiento de las
llamadas de bloque en un ciclo de ejecución:
Programa principal

Subprograma

FB 1 iDB 1
OS

OB
FC 1

Global
DB

FC 2

Profundidad de anidamiento de bloques
La profundidad de anidamiento permitida para bloques depende de la CPU utilizada.
La tabla siguiente muestra los valores orientativos para la profundidad de anidamiento
máxima. Encontrará indicaciones específicas para la CPU utilizada en los datos técnicos de la
documentación de hardware. Para consultar la documentación de hardware en Internet haga
clic en los enlaces de la tabla.

Familia de
CPU

Profundidad de anidamiento (valor orientativo)

Enlace a la documentación de hardware

S7-1500

24 bloques por clase de prioridad

SIMATIC S7-1500 / ET 200MP Manual Collection
(https://support.industry.siemens.com/cs/ww/es/
view/86140384)

S7-1200

16 bloques del OB de ciclo o de arranque, 6 bloques
adicionales dentro de cualquier OB de evento de
alarma

Sistema de automatización SIMATIC S7-1200
(https://support.industry.siemens.com/cs/ww/es/
view/91696622)

60

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque
Familia de
CPU

Profundidad de anidamiento (valor orientativo)

Enlace a la documentación de hardware

S7-400

24 bloques por clase de prioridad, 1 a 2 bloques adi‐ Sistema de automatización SIMATIC S7-400, datos
cionales dentro de un OB de error
de la CPU S7-400 (https://
support.industry.siemens.com/cs/de/en/view/
53385241)

S7-300

16 bloques por clase de prioridad, 4 bloques adicio‐ SIMATIC S7-300 CPU 31xC y CPU 31x: Datos técni‐
nales dentro de un OB de error
cos (https://support.industry.siemens.com/cs/de/de/
view/12996906/es)

ET 200SP

24 bloques

SIMATIC ET 200SP Manual Collection (https://
support.industry.siemens.com/cs/ww/es/view/
84133942)

Profundidad de anidamiento de estructuras
Las estructuras (STRUCT) y los tipos de datos PLC (UDT) pueden anidarse hasta una
profundidad de 8. Esta profundidad de anidamiento es independiente de la CPU utilizada.

Consulte también
Principios básicos de las instancias (Página 61)
Principios básicos de las llamadas de bloque (Página 59)

1.3.3

Instancias

1.3.3.1

Principios básicos de las instancias

Definición
Un bloque de función necesita memoria para sus datos de trabajo una vez se ha llamado.
Estos datos se denominan instancia.
Las instancias tienen las características siguientes:
● Las instancias están asignadas siempre a un FB.
● La estructura de una instancia se deriva de la interfaz del FB correspondiente y solo puede
modificarse allí.
● Las instancias se crean automáticamente cuando se llama a un bloque de función.

Programación del PLC
Manual de programación y manejo, 11/2019

61

Principios básicos de la programación
1.3 Llamadas de bloque

Almacenamiento de instancias
Para almacenar instancias se dispone de las siguientes posibilidades:
● Instancia individual:
El bloque de función llamado almacena sus datos en un bloque de datos de instancia
propio.
Consulte también: Instancias individuales (Página 62)
● Multiinstancia:
El bloque de función llamado no almacena sus datos en un bloque de datos de instancia
propio, sino en la instancia de otro bloque de función.
Consulte también: Multiinstancias (Página 64)
● Instancia de parámetro:
La instancia de un bloque de función se transfiere como parámetro de entrada/salida
(InOut) a otro bloque. Dicho bloque puede acceder a los datos de la instancia transferida o
bien llamar al FB correspondiente.
Consulte también: Instancias de parámetro (Página 67)

Consulte también
Descripción de la interfaz de bloque (Página 7783)
Direccionar datos de instancia (Página 114)
Direccionar variables en bloques de datos (Página 112)
Principios básicos de las llamadas de bloque (Página 59)
Jerarquía de llamada (Página 60)

1.3.3.2

Instancias individuales

Definición
Una instancia de un bloque de función (FB) que está en un DB de instancia propio, se
denomina instancia individual. El DB de instancia contiene pues los datos de trabajo de una
sola llamada de bloque.

Ventajas
El uso de instancias individuales presenta las ventajas siguientes:
● Posibilidad de reutilizar los bloques de función
● Mejor estructuración de programas sencillos

Funcionamiento de instancias individuales
La figura siguiente ilustra cómo el FB "Caller" utiliza otro FB („Valve“). "Valve" se llama como
instancia individual, es decir, guarda sus datos en su propio DB de instancia.

62

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque

La estructura del bloque de datos de instancia se define en la interfaz del FB correspondiente
y solo puede modificarse allí. El DB de instancia contiene los datos siguientes:
● Parámetros del bloque
Los parámetros del bloque de las secciones "Input", "Output" e "InOut" constituyen la
interfaz del bloque para la llamada en el programa.
● Datos locales estáticos
Los datos locales estáticos de la sección "Static" sirven para almacenar los resultados
intermedios de forma permanente, incluso transcurrido el ciclo de programa actual, por
ejemplo para almacenar el estado lógico en una evaluación de flancos.

Creación de instancias individuales
Existen las siguientes posibilidades para crear una instancia individual:
● Cuando se llama a un FB en el programa, aparece el cuadro de diálogo "Opciones de
llamada". Aquí se puede indicar si el FB debe llamarse como instancia individual,
multiinstancia o instancia de parámetro.
● Cuando se crea un bloque de datos, se abre el cuadro de diálogo "Agregar nuevo bloque".
Aquí, en "Tipo", se selecciona el bloque de función para el que se creará un bloque de datos
de instancia.

Llamar a instancias individuales
Cuando se llama a una instancia individual se indica el bloque de datos de instancia asignado.
La figura siguiente ilustra la llamada del bloque "Block" como instancia individual en KOP. El
bloque de datos de instancia "BlockData" figura encima de la llamada.

Programación del PLC
Manual de programación y manejo, 11/2019

63

Principios básicos de la programación
1.3 Llamadas de bloque

Consulte también
Principios básicos de las instancias (Página 61)
Multiinstancias (Página 64)

1.3.3.3

Multiinstancias

Definición
Cuando un bloque de función (FB) llama a otro FB, sus datos de instancia pueden guardarse
también en el DB de instancia del FB que efectúa la llamada. Este tipo de llamada de bloque
se denomina multiinstancia.

Ventajas
El uso de multiinstancias presenta las ventajas siguientes:
● Mejor estructuración de programas sencillos
● Número reducido de DB de instancia
● Programación sencilla de subprogramas locales, por ejemplo para temporizadores locales
o evaluaciones de flancos.

64

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque

Funcionamiento de las multiinstancias
La figura siguiente ilustra cómo un FB utiliza otro FB („Valve“). "Valve" se llama como
multiinstancia, es decir, guarda sus datos en el DB de instancia del FB que efectúa la llamada.
Los datos de la multiinstancia se encuentran en la sección "Static" del bloque que efectúa la
llamada. En las CPU de las series S7-1200/S7-1500, la instancia también puede estar en el DB
de instancia de otro bloque de función.

Creación de multiinstancias
Existen las siguientes posibilidades para crear una multiinstancia:
● Cuando se llama a un FB en el programa, aparece el cuadro de diálogo "Opciones de
llamada". Aquí se puede indicar si el FB debe llamarse como instancia individual,
multiinstancia o instancia de parámetro.
● La multiinstancia se declara directamente en la interfaz del bloque que efectúa la llamada.
● La multiinstancia se declara en la interfaz de otro bloque de función (S7-1200/S7-1500).
Consulte también: Declaración de multiinstancias

Programación del PLC
Manual de programación y manejo, 11/2019

65

Principios básicos de la programación
1.3 Llamadas de bloque

ARRAY de multiinstancias
Las multiinstancias también pueden crearse como ARRAY. Los diferentes elementos del
ARRAY pueden direccionarse utilizando un índice variable, por ejemplo al ejecutar bucles.

Los ARRAY de multiinstancias se declaran directamente en la interfaz de un bloque de función.

Llamar a multiinstancias
Para llamar a una multiinstancia se indica la instancia asignada. Las siguientes figuras ilustran
la llamada del bloque "Block" como multiinstancia en KOP.
En el ejemplo siguiente, la instancia está almacenada localmente en el DB de instancia del
bloque que efectúa la llamada:

En el ejemplo siguiente, la instancia está en el DB de instancia "MyOtherFB" (S7-1200/
S7-1500):

66

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque
En el ejemplo siguiente, la instancia está en un ARRAY de multiinstancias del DB de instancia
"MyOtherFB" (S7-1200/S7-1500):

Consulte también
Principios básicos de las instancias (Página 61)
Instancias individuales (Página 62)
Ejemplos de uso de instancias de parámetros en un ARRAY de multiinstancias (Página 71)

1.3.3.4

Instancias de parámetro

Definición
La instancia de parámetro presenta una modalidad especial de instanciación:
Aquí, la instancia del bloque que debe utilizarse se transfiere en forma de parámetro de
entrada/salida (InOut) al bloque llamante en tiempo de ejecución.

Ventajas
El uso de instancias de parámetro presenta las ventajas siguientes:
● Es posible definir en tiempo de ejecución la instancia que se va a utilizar.
● Es posible procesar diferentes instancias de forma iterativa en bucles de programa.
Nota
ARRAYs de instancias
Para simplificar la ejecución iterativa de instancias en bucles del programa, defina un ARRAY
de instancias, p. ej.,
● ARRAY del tipo de datos "DB_ANY"
● ARRAY de multiinstancias
Los distintos elementos del ARRAY pueden direccionarse a través de un índice variable
durante la ejecución en bucle.
Consulte también: Ejemplos de uso de instancias de parámetros (Página 71)

Programación del PLC
Manual de programación y manejo, 11/2019

67

Principios básicos de la programación
1.3 Llamadas de bloque

Funcionamiento de instancias de parámetro
La figura siguiente ilustra el "Caller", que utiliza otro FB ("Valve"). Una instancia de "Valve" se
transfiere como instancia de parámetro. Defina para ello un parámetro de entrada/salida
("#valveInstance"), por medio del cual se transfiera la instancia concreta en tiempo de
ejecución.

Creación de instancias de parámetro
Las instancias de parámetro se definen cuando se llama un bloque de función: Cuando se
llama un FB se abre un cuadro de diálogo que permite indicar si el FB debe llamarse como
instancia individual, multiinstancia o instancia de parámetro. Otra posibilidad consiste en
introducir a mano instancias de parámetro directamente en la interfaz del bloque.
Consulte también: Declaración de instancias de parámetro (Página 7803)
La figura siguiente muestra la llamada de una instancia de parámetro para el FB "Valve":

68

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque

Transferencia de instancias como parámetro
En cada llamada del FB superior (en el ejemplo "Caller") se transfiere una instancia para el FB
llamado (en el ejemplo "Valve"). Se pueden transferir los siguientes tipos de instancias:
● Instancia individual
Transfiera un DB de instancia existente del FB llamado.
● Multiinstancia
Transfiera una multiinstancia existente del FB llamado.
● Elemento individual de un ARRAY de multiinstancias
Transfiera un elemento de un ARRAY de multiinstancias existente.
● Variable del tipo de datos "DB_Any" (S7-1200 >= V4.2 / S7-1500 >= V2.0)
Transfiera una variable del tipo de datos "DB_Any" y asígnele una instancia adecuada en
tiempo de ejecución.
Recuerde que este tipo de transferencia de parámetros no es posible para instancias de
bloques de datos de la Task Card "Instrucciones".
La figura siguiente ilustra la llamada del FB "Caller". En el parameter "valveInstance" se
transfiere la instancia "#currValve". Esta instancia, que está presente en el parámetro
#currValve en tiempo de ejecución, se utiliza para la llamada de "Valve".

Programación del PLC
Manual de programación y manejo, 11/2019

69

Principios básicos de la programación
1.3 Llamadas de bloque

En las CPU de las series S7-1200/S7-1500 también pueden transferirse como parámetros
instancias que estén en el DB de instancia de otro bloque.
En el ejemplo siguiente, la instancia transferida está en el DB de instancia "MyOtherIDB"
(S7-1200/S7-1500):

En el ejemplo siguiente, la instancia transferida está en un ARRAY de multiinstancias del DB
de instancia "MyOtherIDB" (S7-1200/S7-1500):

70

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque
En el siguiente ejemplo, la instancia transferida se encuentra en un ARRAY del tipo de datos
"DB_ANY" en el bloque de datos global "DB_ValveInstances":

1.3.3.5

Ejemplos de uso de instancias de parámetros

Ejemplos de uso de instancias de parámetros en un ARRAY de multiinstancias
Tarea
El uso de instancias de parámetros permite transferir la instancia de un bloque de función a otro
bloque (FB o FC) para continuar su procesamiento, como p. ej., una consulta de datos o un
análisis de errores, o bien ejecutar el propio bloque de función con la instancia transferida.
El ARRAY de multiinstancias puede utilizarse para agrupar objetos del mismo tipo y procesar
sus instancias indizadas en un bucle de programa. Los elementos de ARRAY indizados
también se pueden transferir a otro bloque como instancia de parámetros.
A título explicativo, en el ejemplo siguiente se ha elegido el objeto "Válvula" (FB_Valve). Sobre
esta base, toda la información necesaria relativa al procesamiento de la válvula está disponible
en un bloque de programa, en este caso "FB_ValveControl".
La figura siguiente muestra qué funciones son necesarias y como es posible utilizarlas:

Programación del PLC
Manual de programación y manejo, 11/2019

71

Principios básicos de la programación
1.3 Llamadas de bloque

FB_ValveControl
ARRAY de válvula
Instancia de válvula[1]
Instancia de válvula[2]
Instancia de válvula[3]

Bloques de válvulas necesarios

Procesamiento básico y
transmisión de parámetros:
Llamada Instancia de válvula[i] (...)
Procesamiento especial condicionado
p. ej., consulta de estado:
Actual := estado (instancia de válvula[i])
Procesamiento especial condicionado
p. ej., detectada necesidad de
mantenimiento:
IF necesidad de mantenimiento
(instancia de válvula[i])
THEN (efectuar mantenimiento)

Llamada en el FB_ValveControl

Instancia de válvula[…]

FB_Valve
(Definición de datos &
funcionalidad básica)

FC_StatusValve
(función especial)

FC_MaintainValve
(función especial)

● Las dos funciones "FC_StatusValve" y "FC_MaintainValve" procesan una instancia de
parámetro del bloque de programa "FB_Valve", transferida en la llamada.
● En el bloque de programa "FB_ValveControl", el ARRAY de multiinstancias se utiliza, por
un lado, para declarar el número de válvulas existentes, y por otro para procesar todas las
válvulas en un bucle de programa mediante diferentes funciones.
Nota
Integridad
Esta solución sirve únicamente de ejemplo para poner de manifiesto cómo abordar las tareas
planteadas. Tenga en cuenta que es necesario adaptar el código del programa a cada tarea
real.

72

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque
Para aplicar este ejemplo se necesitan los bloques de programa siguientes:
Bloque

Descripción

Lenguaje de programación

FB_ValveCon‐
trol

Este bloque de función sirve de bloque de control en
el que se procesan todas las válvulas mediante un
ARRAY de multiinstancias.

SCL

FB_Valve

Este bloque de función contiene la definición de los
datos de las válvulas y el código de programa para el
procesamiento de una válvula.

SCL

FC_StatusValve Esta función Indica el estado de la válvula que se está
procesando actualmente.
FC_Maintain‐
Valve

(Los tres bloques de progra‐
ma son utilizados por el blo‐
que de programa "FB_Val‐
veControl").

Esta función comprueba la necesidad de manteni‐
miento en la válvula. Si es necesario, se ejecuta el
mantenimiento, y cuando se ha terminado se devuel‐
ve el valor de la función TRUE.

Procedimiento: Crear "FB_Valve"
Para crear el bloque de función SCL, proceda del siguiente modo:
1. Haga doble clic en el comando "Agregar nuevo bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
2. Haga clic en el botón "Bloque de función (FB)".
3. Introduzca el nombre "FB_Valve".
4. Seleccione el lenguaje "SCL".
5. Haga clic en "Aceptar".
6. La declaración de la interfaz de bloque se orienta a una válvula que puede abrirse y
cerrarse, y podría ser, p. ej., así:

7. El código de programa para el control de las válvulas podría ser, p. ej., así:

Programación del PLC
Manual de programación y manejo, 11/2019

73

Principios básicos de la programación
1.3 Llamadas de bloque

Procedimiento: Crear "FC_StatusValve"
Para crear la función SCL "FC_StatusValve", proceda del siguiente modo:
1. Haga doble clic en el comando "Agregar nuevo bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
2. Haga clic en el botón "Función (FC)".
3. Introduzca el nombre "FC_StatusValve".
4. Seleccione el lenguaje "SCL".
5. Haga clic en "Aceptar".
6. La declaración de la interfaz de bloque con integración de la instancia de parámetro
"FB_Valve" podría ser, p. ej., así:

7. Escriba, p. ej., el siguiente código de programa:

Procedimiento: Crear "FC_MaintainValve"
Para crear la función SCL "FC_MaintainValve", proceda del siguiente modo:
1. Haga doble clic en el comando "Agregar nuevo bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
2. Haga clic en el botón "Función (FC)".
3. Introduzca el nombre "FC_MaintainValve".
4. Seleccione el lenguaje "SCL".
5. Haga clic en "Aceptar".

74

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque
6. La declaración de la interfaz de bloque con integración de la instancia de parámetro
"FB_Valve" podría ser, p. ej., así:

7. Escriba, p. ej., el siguiente código de programa:

Procedimiento: Crear "FB_ValveControl"
Para crear el bloque de función SCL, proceda del siguiente modo:
1. Haga doble clic en el comando "Agregar nuevo bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
2. Haga clic en el botón "Bloque de función (FB)".
3. Introduzca el nombre "FB_ValveControl".
4. Seleccione el lenguaje "SCL".
5. Haga clic en "Aceptar".
6. Defina la constante de usuario:

En este ejemplo la constante de usuario "vmax" para permitir adaptar con facilidad el
programa a diversos números de válvulas.

Programación del PLC
Manual de programación y manejo, 11/2019

75

Principios básicos de la programación
1.3 Llamadas de bloque
7. La declaración de la interfaz de bloque con integración de la instancia de válvula
"FB_Valve" podría ser, p. ej., así:

8. Escriba, p. ej., el siguiente código de programa:

Procedimiento: Llamada del "FB_ValveControl" en el OB 1.
Para llamar al bloque de función "FB_ValveControl" en el OB 1, proceda del siguiente modo:
1. Abra el bloque "Main (OB1)" haciendo doble clic.
2. Arrastre el bloque de función "FB_ValveControl" mediante Drag & Drop hasta el OB 1.

76

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque

Resultado
Por cada ciclo de programa se procesará una válvula. Se procesará la válvula seleccionada en
cada caso mediante el índice, se consultará su estado y, en caso necesario, se realizará un
mantenimiento.
En este ejemplo se ha procesado una válvula por ciclo. Naturalmente, también es posible
procesar todas las válvulas en un bucle de programa. Aunque el tiempo de ciclo aumenta en
consecuencia. Si se necesita que el ciclo de programa sea corto, no es recomendable trabajar
con un bucle de programa.

Consulte también
Instancias de parámetro (Página 67)
Multiinstancias (Página 64)

Ejemplos de uso de instancias de parámetros en un ARRAY de DB_ANY
Tarea
El ejemplo siguiente muestra cómo se direccionan varias instancias de un bloque de función
mediante un índice variable. Las instancias deben ejecutarse iterativamente en un bucle FOR.

DBAnyStorage
MyFB
myArrayOfInstances: Array [0..4] of DB_Any
No [0] : DB_Any:=MyFBInst0
MyFBInst0
MyFBInst1
MyFBInst2
MyFBInst3
MyFBInst4

No [1] : DB_Any:=MyFBInst1

No [4] : DB_Any:=MyFBInst4

LoopCallDoMyFB

DoMyFB

//Passes the instances of "MyFB"
//to "DoMyFB"
FOR #i := 0 TO 4 DO
"DoMyFB"(currentMyFBInstance :=
"DBAnyStorage".myArrayOfInstances[#index]);

Parameter
Instance

//Calls the passed instance of
//"MyFB" and processes it in the
//program code
#currentMyFBInstance()

END_FOR;

Programación del PLC
Manual de programación y manejo, 11/2019

77

Principios básicos de la programación
1.3 Llamadas de bloque

Creación del programa de ejemplo
1. Cree primero el bloque de función "MyFB".
2. Genere cinco bloques de datos de instancia para "MyFB".

3. Genere el bloque de datos global "DBAnyStorage" y en las propiedades del bloque de datos
ponga la reserva de memoria a "0 bytes".
4. Declare en "DBAnyStorage" un ARRAY del tipo de datos "DB_ANY" con cinco
componentes.

5. Para la inicialización, asigne a los distintos elementos del ARRAY del OB de arranque los
nombres simbólicos de los cinco DB de instancia.

78

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque
6. Cree el bloque de función "LoopCallDoMyFB" y acceda en él a las distintas instancias de
"MyFB" iterativamente con ayuda de un bucle FOR.
Las instancias se transfieren una tras otra a la función "DoMyFB" para su ejecución.
La instancia transferida se determina en tiempo de ejecución. Eso significa que en el
momento de la creación no es posible determinar si la instancia transferida es realmente
adecuada para el parámetro declarado en la interfaz de "DoMyFB" . Para comprobarlo
recomendamos utilizar la instrucción "TypeOfDB" en el FB "LoopCallDoMyFB".

7. En la interfaz de "DoMyFB" está declarado el parámetro de entrada/salida
"currentMyFBInstance". Allí "LoopCallDoMyFB" transfiere a la función "DoMyFB" en tiempo
de ejecución la instancia de "MyFB" que debe ejecutarse. (Transferencia como instancia de
parámetro).

Programación del PLC
Manual de programación y manejo, 11/2019

79

Principios básicos de la programación
1.3 Llamadas de bloque

Resultado
El FB "DoMyFB" ejecuta una tras otra todas las instancias de "MyFB".

Consulte también
Instancias de parámetro (Página 67)

1.3.4

Transferencia de parámetros en la llamada de un bloque

1.3.4.1

Reglas para el suministro de parámetros de bloque

Parámetros de bloque
El bloque que llama envía al bloque llamado los valores con los que debe trabajar. Estos
valores se denominan parámetros de bloque. El bloque llamado recibe con los parámetros de
entrada los valores que debe procesar. El bloque devuelve los resultados a través de los
parámetros de salida.

80

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque
Así, los parámetros de bloque constituyen la interfaz entre el bloque que llama y el bloque
llamado.
Si solo se desea consultar o leer valores, se utilizan parámetros de entrada, y si solo se desea
definir o escribir valores, se utilizan parámetros de salida. Para leer y escribir parámetros de
bloque, es necesario crearlos como parámetros de entrada/salida.
Para el uso de parámetros de bloque en un bloque rigen las reglas siguientes:
● Los parámetros de entrada solo pueden leerse.
● Los parámetros de salida solo pueden escribirse.
● Los parámetros de entrada/salida pueden leerse y escribirse.

Parámetros formales y actuales
Los parámetros de bloque se definen en la interfaz del bloque llamado. Estos parámetros se
denominan parámetros formales. Sirven de comodines para los valores que se transfieren al
bloque al llamarlo. Los valores transferidos en la llamada se denominan parámetros actuales.
Los tipos de datos de los parámetros actuales y formales deben ser idénticos o convertibles
según las reglas de conversión de tipos de datos.
Nota
S7-1200/1500: Transferir entradas o salidas de periferia como parámetros de bloque
Si se suministra una entrada o salida de periferia a un parámetro de entrada, existe el riesgo
de que se produzcan errores de acceso a periferia al llamar el bloque en tiempo de ejecución,
p. ej. un error de lectura en el acceso directo a datos de un módulo de entrada.
El comportamiento del sistema en las CPU de la serie S7-1500 con versión de FW V2.1 o
superior es el siguiente:
El bloque se llama y se procesa con el valor sustitutivo de la señal.
El comportamiento del sistema en las CPU de las series S7-1200 y S7-1500 con versión de FW
V2.1 o inferior es el siguiente:
El bloque no se llama debido al error de acceso a periferia. El programa sigue ejecutándose
tras la llamada del bloque. Si existe un OB 122 o si el tratamiento local de errores está activado,
estos se ejecutan.
Para impedir que una llamada de bloque no se ejecute en caso de un error de acceso a
periferia, copie la entrada o salida de periferia en una variable local (Temp) y transfiérala como
parámetro de bloque al bloque llamado.
Encontrará más información al respecto en la siguiente FAQ:
FAQ 89377245: ¿Por qué no se elaboran los bloques de un S7-1200/S7-1500 si se direcciona
con componentes PROFINET no disponibles? (https://
support.industry.siemens.com/cs/ww/es/view/89377245)

Programación del PLC
Manual de programación y manejo, 11/2019

81

Principios básicos de la programación
1.3 Llamadas de bloque

Consulte también
Variables (Página 102)
Asignar valores a parámetros de bloques de función (Página 85)
Asignar valores a parámetros de funciones (Página 82)
Reglas de la declaración de la interfaz del bloque (Página 7785)
Tipos de datos PLC (UDT) (Página 283)
Bases de AWL (Página 8065)

1.3.4.2

Asignar valores a parámetros de funciones

Parámetros de funciones (FC)
Las funciones no poseen una memoria de datos que permita almacenar valores de parámetros
de bloque. Por este motivo, al llamar una función es preciso que todos los parámetros formales
reciban parámetros actuales.

Parámetros de entrada (Input)
Los parámetros de entrada se leen una única vez antes de cada llamada del bloque. Por ello
rige la norma de que la escritura de un parámetro de entrada dentro del bloque no afecta al
parámetro actual. Solo se escribe el parámetro formal.

Parámetros de salida (Output)
Los parámetros de salida se escriben una única vez después de cada llamada del bloque. Por
ello rige la norma de que los parámetros de salida dentro del bloque no deben leerse. No
obstante, si lee un parámetro de salida, recuerde que solo se lee el valor del parámetro formal.
El valor del parámetro actual no puede leerse dentro del bloque.
Si un parámetro de salida de una función no se escribe en dicha función, se utiliza el valor
predefinido para el tipo de datos indicado. Por ejemplo, el valor predefinido para BOOL es
"false". No obstante, a los parámetros de salida estructurados no se les asigna ningún valor.
Para no continuar procesando el valor predefinido o un valor indefinido de forma accidental,
recuerde lo siguiente al programar el bloque:
● Asegúrese de que en los parámetros de salida se registran valores para cada ruta de
programa posible dentro del bloque. Recuerde, p. ej., que los comandos de salto pueden
saltar sobre secuencias de instrucciones en las que se activan salidas.
● Tenga en cuenta que las instrucciones de activación y desactivación dependen del
resultado lógico. Si el valor de un parámetro de salida se determina con estas instrucciones,
no se forma ningún valor si el resultado lógico (RLO) es 0.
● Si es posible, asigne un valor predeterminado a los parámetros de salida de las funciones.

82

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque

Parámetros de entrada/salida (InOut)
Los parámetros de entrada/salida se leen antes de la llamada del bloque y se escriben
después de ella. Si se lee o escribe el parámetro dentro del bloque, solo se accede a su
parámetro formal.
Los parámetros de entrada/salida con tipo de datos estructurado son una excepción. Los tipos
de datos estructurados son los que se componen de varios elementos de datos, p. ej. ARRAY
o STRUCT. Estos se transfieren al bloque llamado a través de un puntero. Así, siempre se
accede al parámetro actual si se lee o escribe un parámetro de entrada/salida estructurado
dentro de un bloque.
Si no se escribe un parámetro de entrada/salida de una función en dicha función, el valor de
salida o de entrada antiguo se utiliza como valor. No obstante, también en este caso debe
observar las indicaciones anteriores sobre parámetros de salida para no seguir procesando
valores antiguos involuntariamente.

Programación del PLC
Manual de programación y manejo, 11/2019

83

Principios básicos de la programación
1.3 Llamadas de bloque

Datos locales temporales (Temp)
Los datos locales temporales solo están disponibles durante el procesamiento del bloque.
Reciben un tratamiento diferente en función del ajuste de optimización del bloque:
● Acceso estándar
En los bloques lógicos con acceso estándar y para todas las variables con el ajuste de
remanencia "Ajustar en IDB" rige la siguiente regla:
Si se utilizan datos locales temporales, hay que tomar las medidas necesarias para que los
valores se inicialicen antes del uso. De lo contrario, los valores serán aleatorios. Los datos
temporales del tipo de datos STRING o WSTRING son una excepción: Estos tienen
asignada automáticamente la longitud real 0.
● Acceso optimizado
En los bloques lógicos con acceso optimizado se aplican las siguientes reglas:
– Si una variable temporal no se escribe dentro de una función, se utiliza el valor
predefinido para el tipo de datos indicado.
La tabla siguiente muestra algunos ejemplos de valores predefinidos:
Tipo de datos

Valor predefinido

Bool

false

Int

0

REAL

0.0

Char

''

Wchar

WCHAR#' '

DTL

DTL#1970-01-01-00:00:00

Date_And_Time

DT#1990-01-01-00:00:00

Date

D#1990-01-01

– A los elementos de los tipos de datos PLC se les preasigna el valor predeterminado
especificado en la declaración del tipo de datos PLC (UDT).
– Los STRINGs y WSTRINGs tienen asignada la longitud real "0", aunque se utilicen en
un tipo de datos PLC.
– Los elementos del tipo de datos ARRAY tienen asignado el valor "0", aunque se utilicen
en un tipo de datos PLC.

Valor de función (Return)
Por lo general, las funciones calculan un valor de función. Dicho valor puede devolverse al
bloque que realiza la llamada a través del parámetro de salida RET_VAL. Para ello, el
parámetro de salida RET_VAL debe estar declarado en la interfaz de la función. RET_VAL es
siempre el primer parámetro de salida de una función. Para el parámetro RET_VAL se admiten
todos los tipos de datos excepto ARRAY y STRUCT, así como los tipos de parámetros TIMER
y COUNTER.
El lenguaje de programación SCL permite llamar directamente funciones en una expresión. El
resultado de la expresión se obtiene a partir del valor de función calculado. Por este motivo, en
SCL no se admite el tipo de datos ANY para el valor de función.

84

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque

Consulte también
Asignar valores a parámetros de bloques de función (Página 85)
Reglas para el suministro de parámetros de bloque (Página 80)
Llamada de funciones (Página 8168)
Ejemplos de la llamada de funciones en SCL (Página 8171)

1.3.4.3

Asignar valores a parámetros de bloques de función

Asignar valores a parámetros de bloques de función (FB)
En el caso de los bloques de función, los valores de parámetro se guardan en los datos de
instancia.
Si no se han transferido valores a los parámetros de entrada, salida y entrada/salida de un
bloque de función, se utilizan los valores almacenados, si el parámetro ya se ha inicializó una
vez en un ciclo precedente. Si este no es el caso, la CPU pasa a STOP con un error en tiempo
de ejecución.
En algunos casos es imperativo indicar un parámetro actual.
La tabla siguiente muestra a qué parámetros de un bloque de función se deben asignar
parámetros actuales:
Parámetros

Tipo de datos simple

Tipo de datos estructurado

Tipo de parámetro

Entrada (Input)

opcional

opcional

opcional

Salida (Output)

opcional

opcional

no admisible

Entrada/salida (InOut)

opcional

● Llamada de un bloque de datos no
optimizado: no es imperativamente
necesario, pero el valor debe inicializarse
con una única llamada, de lo contrario se
emite un error en tiempo de ejecución.

no admisible

●

Llamada de bloques optimizados: necesario

Consulte también
Reglas para el suministro de parámetros de bloque (Página 80)
Asignar valores a parámetros de funciones (Página 82)
Tipos de parámetros (Página 359)

Programación del PLC
Manual de programación y manejo, 11/2019

85

Principios básicos de la programación
1.3 Llamadas de bloque

1.3.4.4

Transferencia de parámetros como copia o puntero

Introducción
Al llamar un bloque se transfieren datos a los parámetros de la interfaz del bloque. Mediante
los parámetros de entrada (Input) se transfieren los datos con los que debe trabajar el bloque.
Mediante los parámetros de salida (Output) se determina dónde deben almacenarse los
resultados del procesamiento. Los parámetros de entrada/salida (InOut) sirven tanto para
transferir datos al bloque llamado como para devolver resultados.
Internamente, STEP 7 conoce dos métodos distintos para transferir parámetros: en función del
área de transferencia y del tipo de datos del parámetro, los datos se transfieren como puntero
o como copia.

Transferencia como copia (Call by value)
Durante la llamada del bloque, el valor del operando se copia en los parámetros de entrada del
bloque llamado. En los bloques de función, la copia se deposita en el DB de instancia, mientras
que en las funciones se deposita en la pila del bloque. Para la copia se requiere espacio de
memoria adicional.
Esto significa que el bloque llamado trabaja siempre con el valor que tenía el operando
indicado al producirse la llamada del bloque. No puede acceder directamente al operando. Los
accesos de escritura simplemente modifican la copia, pero no el valor real del operando
indicado. Los accesos de lectura únicamente leen la copia que se creó en el instante en que
se llamó el bloque.

FC / FB
"My_int"
IN
-Valor: 31
value: 31

Transferencia como puntero (Call by reference)
Los parámetros se referencian a través de un puntero cuando se llama el bloque.
Esto significa que el bloque llamado accede directamente a la dirección de memoria del
operando especificado como parámetro: los accesos de escritura modifican directamente el
operando indicado. Los accesos de lectura leen el valor del operando justo en el instante del
acceso. Puesto que no se crean copias no se requiere espacio de memoria adicional.

"My_string"
-Valor: 'Test'

86

FC/FB
IN/OUT
Referencia a"My_string"

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque

Nota
Declare los tipos de datos estructurados en el área "InOut"
Siempre que sea posible, para variables estructuradas (p. ej. del tipo de datos ARRAY,
STRUCT, STRING, …) debe utilizarse el área "InOut" en la interfaz del bloque. Puesto que los
parámetros de entrada/salida estructurados (InOut) se transfieren como estándar en forma de
puntero, de este modo no aumenta innecesariamente la memoria de datos necesaria.

Transferencia de parámetros en S7-1200/1500
La siguiente tabla muestra cómo se transfieren parámetros de bloque con tipos de datos
simples o estructurados en S7-1200/1500. Tipos de datos simples son, p. ej., BOOL, INT o
BYTE. Tipos de datos estructurados son, p. ej., ARRAY, STRUCT o STRING.

Tipos de datos simples

Tipos de datos estructurados

Input

Copia

Puntero

Output

Copia

Puntero

InOut

Copia

Puntero

Input

Copia

Copia

Output

Copia

Copia

InOut

Copia

Puntero

FC

FB

Programación del PLC
Manual de programación y manejo, 11/2019

87

Principios básicos de la programación
1.3 Llamadas de bloque

Nota
Transferencia de datos entre áreas de memoria con acceso optimizado y áreas de memoria
con acceso estándar
Si se transfieren estructuras a un bloque en forma de parámetros de entrada/salida (InOut),
dichas estructuras se transfieren de forma estándar como punteros (Call by reference).
Esto no es aplicable si el área de memoria del parámetro actual transferido y el bloque llamado
tienen ajustes de optimización distintos: si, por ejemplo, el parámetro actual tiene la propiedad
"acceso optimizado" y el bloque tiene la propiedad "acceso estándar", el parámetro se
transfiere como copia (Call by value).
Cuando el bloque llamado contiene muchos parámetros estructurados, puede suceder
rápidamente que el área de memoria temporal (pila de datos locales) del bloque se desborde.
Además, es posible que surjan problemas si los parámetros actuales transferidos cambian
debido a procesos asíncronos, p. ej. a causa de accesos HMI u OB de alarma. Si tras el
procesamiento del bloque los valores vuelven a copiarse a los operandos transferidos
originariamente como parámetros actuales, se sobrescriben los cambios realizados de forma
asíncrona en dichos operandos.
Para impedir que esto suceda se debe ajustar el mismo tipo de acceso para el área de memoria
del parámetro actual y para el bloque llamado o bien escribir primero los accesos asíncronos
en un área de memoria aparte y copiar de forma síncrona esta área en el momento adecuado.
Consulte también:
Bloques con acceso optimizado (Página 54)
FAQ 109478253: ¿Por qué los datos del sistema HMI o del servidor web se sobrescriben en
ocasiones en el S7-1500? (https://support.industry.siemens.com/cs/de/en/view/109478253)

Transferencia de parámetros en S7-300/400
La siguiente tabla muestra cómo se transfieren parámetros de bloque con tipos de datos
simples o estructurados en S7-300/400.
Tipos de datos simples

Tipos de datos estructurados

Input

Copia*

Puntero

Output

Copia*

Puntero

InOut

Copia*

Puntero

FC

88

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque
Tipos de datos simples

Tipos de datos estructurados

Input

Copia

Copia

Output

Copia

Copia

InOut

Copia

Puntero

FB
* Excepción: los operandos de las áreas de memoria I, Q, M, P, L y direcciones de DB con
especificación parcial (p. ej. "DW 2") se transfieren como puntero.
Nota
Particularidades en la transferencia como puntero en S7-300/400
Cuando los parámetros se transfieren a través de un puntero no es posible reenviar
parámetros de salida o de entrada y salida del bloque invocante a los parámetros de entrada
del bloque llamado.

1.3.4.5

Reenviar parámetros de bloque

Fundamentos del reenvío de parámetros de bloque
Definición
Existe un modo especial de uso de valores de parámetros denominado "reenvío" de
parámetros de bloque. Consiste en reenviar los valores de los parámetros del bloque que llama
a los parámetros del bloque llamado. El bloque llamado utiliza como parámetros actuales los
valores asignados actualmente a los parámetros de bloque del bloque que llama.
La figura siguiente muestra cómo se reenvían los parámetros de la función FC_10 a la función
FC_12:

Programación del PLC
Manual de programación y manejo, 11/2019

89

Principios básicos de la programación
1.3 Llamadas de bloque

Función (FC)

FC 10
FC 10; declaración de variables

A_Param = Param_1
B_Param = Param_2
C_Param = Param_3

Input: Param_1
Output: Param_2
InOut: Param_3

FC 12; declaración de variables
InOut: C_Param
Output: B_Param
Input: A_Param

FC 12

Reglas para KOP/FUP
En KOP y FUP rigen las siguientes reglas generales:
● Los parámetros de entrada solo pueden reenviarse a parámetros de entrada.
● Los parámetros de salida solo pueden reenviarse a parámetros de salida.
● Los parámetros de entrada/salida pueden enviarse a cualquier tipo de parámetro.
● En los S7-300/400, ambos parámetros de bloque deben ser del mismo tipo de datos.
● En los S7-1200/1500, los parámetros también se pueden convertir según las normas de
conversión implícita.

Reglas para AWL
En AWL rigen las siguientes reglas generales:
● Los parámetros de entrada solo pueden reenviarse a parámetros de entrada.
● Los parámetros de salida solo pueden reenviarse a parámetros de salida.
● Los parámetros de entrada/salida pueden enviarse a cualquier tipo de parámetro.
● Ambos parámetros de bloque deben ser del mismo tipo de datos. Esta regla rige para AWL
en todas las familias de CPU.

Reglas para SCL
Las reglas que rigen para SCL son menos estrictas. Para facilitar la implantación de programas
de versiones anteriores de SCL, se permiten otros métodos de transferencia de parámetros.
Así, es posible, por ejemplo, enviar un parámetro de entrada/salida estructurado a un
parámetro de entrada. No obstante, en ese caso hay que asegurarse de que el parámetro
actual no se encuentre en los datos locales temporales o en un bloque de datos global.

90

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque
En los capítulos siguientes se describen otras reglas en detalle.

Consulte también
Llamada de una función desde otra función (Página 91)
Llamada de una función desde un bloque de función (Página 92)
Llamada de un bloque de función desde una función (Página 93)
Llamada de un bloque de función desde otro bloque de función (Página 94)

Llamada de una función desde otra función
Tipos de datos permitidos al llamar una función desde otra función
El paso de parámetros formales está regido por determinadas reglas. La tabla siguiente
muestra las reglas que rigen para poder pasar parámetros a las diferentes familias de CPU:
FC llama a FC

Tipos de datos

Paráme‐
tro actual

Paráme‐
tro formal

(bloque
que efec‐
túa la lla‐
mada)

(bloque
llamado)

Input

Input

Tipos de da‐
tos estándar

ARRAY,
STRUCT,
STRING,
WSTRING,
DT

S7-300/400

S7-1200

S7-1200

S7-1500

ANY,
POIN‐
TER

S7-1500

VARIANT

Tipos de pará‐
metros

Output

S7-300/400

S7-1200

S7-1200

S7-1500

S7-1500

S7-1200

S7-1500

-

REF_TO

S7-1200 a
partir de V2

S7-1500

(TIMER,
COUNTER,
BLOCK_XX)

S7-1500

S7-1500
Output

DB_Any

S7-1200

-

-

-

-

-

S7-1500

-

-

-

-

-

-

S7-1500

S7-1500
InOut

Input

S7-300/400

S7-1200

S7-1200

S7-1500

S7-1500

S7-1200
S7-1500

S7-1500
InOut

Output

S7-300/400

S7-1200

S7-1200

S7-1500

-

S7-1200
S7-1500

S7-1500
InOut

InOut

S7-300/400

S7-1200

S7-1200

S7-1500

S7-1500

S7-1200
S7-1500

S7-1500

Consulte también
Fundamentos del reenvío de parámetros de bloque (Página 89)

Programación del PLC
Manual de programación y manejo, 11/2019

91

Principios básicos de la programación
1.3 Llamadas de bloque

Llamada de una función desde un bloque de función
Tipos de datos permitidos al llamar una función desde un bloque de función
El paso de parámetros formales está regido por determinadas reglas. La tabla siguiente
muestra las reglas que rigen para poder pasar parámetros a las diferentes familias de CPU:
FB llama a FC

Tipos de datos

Paráme‐
tro actual

Paráme‐
tro formal

(bloque
que efec‐
túa la lla‐
mada)

(bloque
llamado)

Input

Input

Output

InOut

Output

Input

Tipos de da‐
tos estándar

ARRAY,
STRUCT,
STRING,
WSTRING,
DT

ANY,
POIN‐
TER

S7-300/400

S7-300/400

S7-1500

S7-1200

S7-1200

S7-1500

S7-1500

S7-300/400

S7-300/400

S7-1200

S7-1200

S7-1500

S7-1500

S7-300/400

S7-1200

S7-1200

S7-1500

VARIANT

Tipos de pará‐
metros

REF_TO

S7-1200 a
partir de V2

S7-1500

(TIMER,
COUNTER,
BLOCK_XX)
S7-1200

S7-1500

S7-1500
-

DB_Any

S7-1200

S7-1500
-

-

-

-

-

S7-1500

-

-

-

-

-

-

S7-1500
S7-1500

S7-1200
S7-1500

S7-1500
InOut

Output

S7-300/400

S7-1200

S7-1200

S7-1500

-

S7-1200
S7-1500

S7-1500
InOut

InOut

S7-300/400

S7-1200

S7-1200

S7-1500

S7-1500

S7-1200
S7-1500

S7-1500

Consulte también
Fundamentos del reenvío de parámetros de bloque (Página 89)

92

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.3 Llamadas de bloque

Llamada de un bloque de función desde una función
Tipos de datos permitidos al llamar un bloque de función desde una función
El reenvío de parámetros formales está regido por determinadas reglas. La tabla siguiente
muestra las reglas que rigen para poder reenviar parámetros a las diferentes familias de CPU:
FC llama a FB

Tipos de datos

Parámetro
actual

Parámetro
formal

(bloque
que efec‐
túa la lla‐
mada)

(bloque lla‐
mado)

Input

Input

Tipos de datos
estándar

ARRAY,
STRUCT,
STRING,
WSTRING,
DT

S7-300/400

S7-1200

S7-1200

S7-1500

ANY,
POINTER

VARIANT

Tipos de pará‐
metros
(TIMER, COUN‐
TER,
BLOCK_XX)

S7-1500

S7-1200

S7-300/400

S7-1500

S7-1500

S7-1200 a
partir de V2

S7-1200

-

-

-

-

-

-

-

-

S7-1500
Output

Output

S7-300/400

S7-1200

S7-1200

S7-1500

DB_Any

-

S7-1500

S7-1500

S7-1500
InOut

Input

S7-300/400

S7-1200

S7-1200

S7-1500

S7-1500

S7-1200
S7-1500

S7-1500
InOut

Output

S7-300/400

S7-1200

S7-1200

S7-1500

-

S7-1200
S7-1500

S7-1500
InOut

InOut

S7-300/400

S7-1200

S7-1200

S7-1500

S7-1500

S7-1200
S7-1500

S7-1500

Consulte también
Fundamentos del reenvío de parámetros de bloque (Página 89)

Programación del PLC
Manual de programación y manejo, 11/2019

93

Principios básicos de la programación
1.3 Llamadas de bloque

Llamada de un bloque de función desde otro bloque de función
Tipos de datos permitidos al llamar un bloque de función desde otro bloque de función
El reenvío de parámetros formales está regido por determinadas reglas. La tabla siguiente
muestra las reglas que rigen para poder reenviar parámetros a las diferentes familias de CPU:
FB llama a FB

Tipos de datos

Parámetro
actual

Parámetro
formal

(bloque
que efec‐
túa la lla‐
mada)

(bloque lla‐
mado)

Input

Output

InOut

Input

Output

Input

Tipos de datos
estándar

ARRAY,
STRUCT,
STRING,
WSTRING,
DT

S7-300/400

S7-300/400

S7-1200

S7-1200

S7-1500

S7-1500

S7-300/400

S7-300/400

S7-1200

S7-1200

S7-1500

S7-1500

S7-300/400

S7-1200

S7-1200

S7-1500

ANY,
POINTER

VARIANT

Tipos de pará‐
metros

DB_Any

(TIMER, COUN‐
TER,
BLOCK_XX)
S7-1500

-

S7-1200

S7-300/400

S7-1500

S7-1500

S7-1200 a
partir de V2

S7-1200

-

-

-

-

-

-

-

-

S7-1500

S7-1500
S7-1500

S7-1200
S7-1500

S7-1500
InOut

Output

S7-300/400

S7-1200

S7-1200

S7-1500

-

S7-1200
S7-1500

S7-1500
InOut

InOut

S7-300/400

S7-1200

S7-1200

S7-1500

S7-1500

S7-1200
S7-1500

S7-1500

Consulte también
Fundamentos del reenvío de parámetros de bloque (Página 89)

94

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

1.4

Utilizar y direccionar operandos

1.4.1

Fundamentos de los operandos

Introducción
Al programar instrucciones se indican los valores de datos que la instrucción debe procesar.
Estos valores se denominan operandos. P. ej. pueden usarse como operandos los siguientes
elementos:
● Variables PLC
● Constantes
● Variables de bloques de datos instancia
● Variables de bloques de datos globales

Dirección absoluta y nombre simbólico
Los operandos se identifican mediante una dirección absoluta y un nombre simbólico. Los
nombres y direcciones se definen en la tabla de variables PLC o en la declaración de variables
de los bloques.

Bloques de datos de acceso optimizado (S7-1200, S7-1500)
A los elementos de datos de los bloques de datos con acceso optimizado se les asigna en la
declaración un nombre simbólico, pero no una dirección absoluta.

Consulte también
Mostrar operandos simbólicos y absolutos (Página 7669)
Fundamentos del acceso a bloques (Página 54)

1.4.2

Palabras clave
SIMATIC conoce toda una serie de palabras clave que tienen un determinado significado en
el programa. Estas palabras clave no deben usarse como nombres de variables ni de
constantes.

Programación del PLC
Manual de programación y manejo, 11/2019

95

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Tabla de palabras clave
En la tabla siguiente figuran todas las palabras clave.

96

Palabras clave
Nemónicos alemanes

Palabras clave
Nemónicos ingleses

Descripción

&

&

Operación lógica Y de expresio‐
nes lógicas

^

^

Operador para leer o escribir el
valor de una referencia

A

Q

Salida, bit

A1

CC1

Bit indicador

A0

CC0

Bit indicador

AB

QB

Salida, byte

AD

QD

Salida, palabra doble

AND

AND

Operación lógica Y de expresio‐
nes lógicas

ANY

ANY

Tipo de datos, puntero

AR1

AR1

Registro de direcciones 1

AR2

AR2

Registro de direcciones 2

ARRAY

ARRAY

Inicio de la especificación de un
array, seguida de la lista de índi‐
ces entre "[" y "]"

AT

AT

Declaración de variables super‐
puestas

AUTHOR

AUTHOR

Nombre del autor, empresa, de‐
partamento u otro nombre (máx.
8 caracteres, sin espacios)

AW

QW

Salida, palabra

B

B

Byte

BEGIN

BEGIN

Inicio de la sección de instruccio‐
nes de bloques lógicos o sección
de inicialización de bloques de
datos

BIE

BR

Resultado binario

BLOCK_FB

BLOCK_FB

Tipo de parámetro para especifi‐
car un FB

BLOCK_FC

BLOCK_FC

Tipo de parámetro para especifi‐
car una FC

BLOCK_SDB

BLOCK_SDB

Tipo de parámetro para especifi‐
car un SDB

BOOL

BOOL

Tipo de datos

BY

BY

Incremento del bucle FOR

BYTE

BYTE

Tipo de datos

CALL

CALL

Llamada

CASE

CASE

Introducción de la instrucción
CASE

CHAR

CHAR

Tipo de datos simple

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
Palabras clave
Nemónicos alemanes

Palabras clave
Nemónicos ingleses

Descripción

CODE_VERSION1

CODE_VERSION1

Identificación de si un FB es apto
para multiinstancia o no. Si de‐
ben declararse multiinstancias,
el FB no puede tener esta pro‐
piedad.

CONST

CONST

Inicio de la declaración de cons‐
tante

CONTINUE

CONTINUE

Instrucción para salir de un bucle
en SCL

COUNTER

COUNTER

Tipo de parámetro para especifi‐
car un contador

DATA_BLOCK

DATA_BLOCK

Inicio del bloque de datos

DATE

DATE

Tipo de datos

DATE_AND_TIME

DATE_AND_TIME

Tipo de datos

DB

DB

Bloque de datos

DB_ANY

DB_ANY

Tipo de datos

DBB

DBB

Bloque de datos, byte de datos

DBD

DBD

Bloque de datos, palabra doble
de datos

DBLG

DBLG

Longitud del bloque de datos

DBNO

DBNO

Número del bloque de datos

DBW

DBW

Bloque de datos, palabra de da‐
tos

DBX

DBX

Bloque de datos, bit de datos

DI

DI

Bloque de datos de instancia

DIB

DIB

Bloque de datos de instancia,
byte de datos

DID

DID

Bloque de datos de instancia,
palabra doble de datos

DILG

DILG

Longitud de bloque de datos de
instancia

DINO

DINO

Número de bloque de datos de
instancia

DINT

DINT

Tipo de datos

DIW

DIW

Bloque de datos de instancia,
palabra de datos

DIX

DIX

Bloque de datos de instancia, bit
de datos

DO

DO

Inicio de la sección de instruccio‐
nes de FOR y WHILE

DT

DT

Tipo de datos

DTL

DTL

Tipo de datos

DWORD

DWORD

Tipo de datos

E

I

Entrada (mediante memoria ima‐
gen de proceso), bit

Programación del PLC
Manual de programación y manejo, 11/2019

97

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

98

Palabras clave
Nemónicos alemanes

Palabras clave
Nemónicos ingleses

Descripción

EB

IB

Entrada (mediante memoria ima‐
gen de proceso), byte

ED

ID

Entrada (mediante memoria ima‐
gen de proceso), palabra doble

ELSE

ELSE

Rama alternativa en la instruc‐
ción IF y CASE

ELSIF

ELSIF

Condición alternativa de la ins‐
trucción IF

EN

EN

Operando de sistema del meca‐
nismo EN/ENO

ENO

ENO

Operando de sistema del meca‐
nismo EN/ENO

END_CASE

END_CASE

Fin de la instrucción CASE

END_DATA_BLOCK

END_DATA_BLOCK

Fin del bloque de datos

END_FOR

END_FOR

Fin de la instrucción FOR

END_FUNCTION

END_FUNCTION

Fin de la función

END_FUNCTION_BLOCK

END_FUNCTION_BLOCK

Fin del bloque de función

END_IF

END_IF

Fin de la instrucción IF

END_ORGANIZATION_BLOCK

END_ORGANIZATION_BLOCK

Fin del bloque de organización

END_REGION

END_REGION

Fin de un área

END_REPEAT

END_REPEAT

Fin de la instrucción REPEAT

END_STRUCT

END_STRUCT

Fin de la especificación de una
estructura

END_SYSTEM_FUNCTION

END_SYSTEM_FUNCTION

Fin de la función de sistema

END_SYSTEM_FUNC‐
TION_BLOCK

END_SYSTEM_FUNC‐
TION_BLOCK

Fin del bloque de función de sis‐
tema

END_TYPE

END_TYPE

Fin del tipo de datos PLC

END_VAR

END_VAR

Fin de un bloque de declaración

END_WHILE

END_WHILE

Fin de la instrucción WHILE

EW

IW

Entrada (mediante memoria ima‐
gen de proceso), palabra

EXIT

EXIT

Instrucción para salir de un bucle
en SCL

FALSE

FALSE

Constante booleana predefini‐
da: Condición lógica no se cum‐
ple, valor igual a 0

FAMILY

FAMILY

Nombre de la familia de bloques:
p. ej. regulador

FB

FB

Bloque de función

FC

FC

Función

FOR

FOR

Inicio de la instrucción FOR

FUNCTION

FUNCTION

Inicio de la función

FUNCTION_BLOCK

FUNCTION_BLOCK

Inicio del bloque de función

GOTO

GOTO

Inicio de la instrucción GOTO

IF

IF

Inicio de la instrucción IF

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
Palabras clave
Nemónicos alemanes

Palabras clave
Nemónicos ingleses

Descripción

INSTANCE

INSTANCE

Tipo de datos

INT

INT

Tipo de datos

KNOW_HOW_PROTECT

KNOW_HOW_PROTECT

Protección de bloque

L

L

Bit de datos locales

LB

LB

Byte de datos locales

LD

LD

Palabra doble de datos locales

LDT

LDT

Tipo de datos

LINT

LINT

Tipo de datos

LTIME

LTIME

Tipo de datos

LTOD

LTOD

Tipo de datos

LW

LW

Palabra de datos locales

LWORD

LWORD

Tipo de datos

M

M

Bit de marcas

MB

MB

Byte de marcas

MD

MD

Palabra doble de marcas

MOD

MOD

Operador módulo

MW

MW

Palabra de marcas

NAME

NAME

Nombre del bloque

NETWORK

NETWORK

Segmento

NOT

NOT

Inversión lógica

NULL

NULL

Puntero Null

OB

OB

Bloque de organización

OF

OF

Inicio de la especificación del ti‐
po de datos/de la sección de ins‐
trucciones de la instrucción CA‐
SE

OR

OR

Operación lógica O de expresio‐
nes lógicas

ORGANIZATION_BLOCK

ORGANIZATION_BLOCK

Inicio del bloque de organización

OS

OS

Desbordamiento, con memoria

OV

OV

Desbordamiento

PA

PQ

Salida (periferia directa), bit

PAB

PQB

Salida (periferia directa), byte

PAD

PQD

Salida (periferia directa), palabra
doble

PAW

PQW

Salida (periferia directa), palabra

PE

PI

Entrada (periferia directa), bit

PEB

PIB

Entrada (periferia directa), byte

PED

PID

Entrada (periferia directa), pala‐
bra doble

PEW

PIW

Entrada (periferia directa), pala‐
bra

POINTER

POINTER

Tipo de datos

Programación del PLC
Manual de programación y manejo, 11/2019

99

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

100

Palabras clave
Nemónicos alemanes

Palabras clave
Nemónicos ingleses

Descripción

PRAGMA_BEGIN

PRAGMA_BEGIN

Inicio de un pragma

PRAGMA_END

PRAGMA_END

Fin de un pragma

READ_ONLY

READ_ONLY

Protección contra escritura para
bloques de datos

REAL

REAL

Tipo de datos

REF

REF

Instrucción para formar una refe‐
rencia

REF_TO

REF_TO

Introducción para declarar una
referencia

REGION

REGION

Inicio de un área

REPEAT

REPEAT

Inicio de la instrucción REPEAT

RET_VAL

RET_VAL

Valor de retorno

RETURN

RETURN

Instrucción RETURN en SCL

S5T

S5T

Sintaxis para el tipo de datos
S5TIME

S5TIME

S5TIME

Tipo de datos

S7_

S7_

Palabras clave para atributos del
sistema

SDB

SDB

Bloque de datos de sistema

SFB

SFB

Bloque de función de sistema

SFC

SFC

Función de sistema

SINT

SINT

Tipo de datos

STRING

STRING

Tipo de datos

STRUCT

STRUCT

Inicio de la especificación de una
estructura seguido de la lista de
componentes

STW

STW

Palabra de estado

SYSTEM_FUNCTION

SYSTEM_FUNCTION

Función de sistema

SYSTEM_FUNCTION_BLOCK

SYSTEM_FUNCTION_BLOCK

Bloque de función de sistema

T

T

Temporizador (timer)

THEN

THEN

Inicio de la sección de instruccio‐
nes de una instrucción IF

THIS

THIS

Sintaxis para el acceso a un blo‐
que de datos ARRAY

TIME

TIME

Tipo de datos simple para indi‐
caciones horarias

TIME_OF_DAY

TIME_OF_DAY

Tipo de datos

TIMER

TIMER

Tipo de parámetro para especifi‐
car un temporizador

TITLE

TITLE

Título opcional de bloque o de
segmento

TO

TO

Definición del valor final de una
instrucción FOR

TOD

TOD

Tipo de datos

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
Palabras clave
Nemónicos alemanes

Palabras clave
Nemónicos ingleses

Descripción

TRUE

TRUE

Constante booleana predefini‐
da: Condición lógica se cumple,
valor diferente de 0

TYPE

TYPE

Inicio del tipo de datos PLC

UDT

UDT

Tipo de datos PLC o global

UDINT

UDINT

Tipo de datos

UINT

UINT

Tipo de datos

ULINT

ULINT

Tipo de datos

UNLINKED

UNLINKED

Identificación 'no relevante para
la ejecución'

UNTIL

UNTIL

Fin de la sección de instruccio‐
nes de una instrucción REPEAT

USINT

USINT

Tipo de datos

UO

UO

Consulta de (A1=1) Y (A0=1)

VAR

VAR

Inicio de un bloque de declara‐
ción

VAR_IN_OUT

VAR_IN_OUT

Inicio de un bloque de declara‐
ción

VAR_INPUT

VAR_INPUT

Inicio de un bloque de declara‐
ción

VAR_OUTPUT

VAR_OUTPUT

Inicio de un bloque de declara‐
ción

VAR_TEMP

VAR_TEMP

Inicio de un bloque de declara‐
ción

VARIANT

VARIANT

Tipo de datos

VERSION

VERSION

Número de versión del bloque

VOID

VOID

La función no tienen ningún va‐
lor de retorno

WCHAR

WCHAR

Tipo de datos

WSTRING

WSTRING

Tipo de datos

WHILE

WHILE

Inicio de la instrucción WHILE

WORD

WORD

Tipo de datos

XOR

XOR

Operación lógica

Z

C

Contador (counter)

Programación del PLC
Manual de programación y manejo, 11/2019

101

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

1.4.3

Variables

Definición
Una variable es un comodín que ocupa en un programa el lugar de un valor de datos
modificable. El formato del valor de datos está establecido. La utilización de variables aumenta
la flexibilidad del programa. Por ejemplo, a las variables declaradas en la interfaz de un bloque
se pueden asignar valores diferentes en cada llamada del bloque. De esta manera, un bloque
programado se puede reutilizar para distintos fines.
Una variable consta de los siguientes elementos:
● Nombre
● Tipo de datos
● Dirección absoluta
– En los bloques con acceso estándar, las variables PLC y las variables DB tienen una
dirección absoluta.
– En los bloques con acceso optimizado, las variables DB no tienen una dirección
absoluta.
● Valor (opcional)

Declaración de variables
En el programa se pueden definir variables con distintos ámbitos de validez:
● Variables PLC válidas en toda la CPU
● Variables DB de bloques de datos globales que pueden ser utilizadas por todos los bloques
en toda la CPU.
● Variables DB de bloques de datos de instancia que se utilizan prioritariamente en el bloque
en el que están declaradas.
La tabla siguiente muestra la diferencia entre los distintos tipos de variables:

Ámbito de vali‐
dez

Variables PLC

Variables de bloques de da‐
tos de instancia

Variables de bloques de da‐
tos globales

● Válidas en toda la CPU.

● Se utilizan
prioritariamente en el
bloque en el que están
definidas.

● Pueden ser utilizadas por
todos los bloques de la
CPU.

● Pueden ser utilizadas por todos los
bloques de la CPU.
● El nombre es unívoco dentro de la
CPU.

Caracteres per‐
mitidos

● Letras, cifras, caracteres especiales
● No se permiten las comillas.
● No se permiten las palabras clave
reservadas.

102

● El nombre es unívoco
dentro del bloque de
datos de instancia.

● El nombre es unívoco
dentro del bloque de
datos global.

● Letras, cifras, caracteres
especiales

● Letras, cifras, caracteres
especiales

● No se permiten las
palabras clave
reservadas.

● No se permiten las
palabras clave
reservadas.

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Aplicación

Ubicación de la
definición

Variables PLC

Variables de bloques de da‐
tos de instancia

Variables de bloques de da‐
tos globales

● Señales E/S (I, IB, IW, ID, Q, QB, QW,
QD)

● Datos estáticos

● Marcas (M, MB, MW, MD)

● Parámetros de bloque
(parámetros de entrada,
salida y entrada/salida)

Tabla de variables PLC

Interfaz del bloque

● Datos estáticos de un
bloque
Tabla de declaración del blo‐
que de datos global

Nota
Encontrará más información sobre los caracteres admisibles en nombres de variables en el
Siemens Industry Online Support, en los artículos siguientes:
¿Cuándo hay que utilizar identificadores u operandos "entre comillas" en STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/10947785 (https://
support.industry.siemens.com/cs/ww/es/view/109477857)
Encontrará recomendaciones para nombrar variables unívocamente en todo el proyecto en la
guía de estilo del programador:
https://support.industry.siemens.com/cs/ww/de/view/109478084 (https://
support.industry.siemens.com/cs/ww/es/view/81318674)

Consulte también
Palabras clave (Página 95)
Fundamentos de los operandos (Página 95)
Mostrar operandos simbólicos y absolutos (Página 7669)
Nombres de variables PLC permitidos (Página 7892)
Direcciones y tipos de datos admisibles para variables PLC (Página 7893)

1.4.4

Constantes

1.4.4.1

Principios básicos de las constantes

Definición
Las constantes son datos que tienen un valor fijo que no cambia durante el tiempo de ejecución
del programa. Las constantes pueden ser leídas por diferentes elementos del programa
durante su ejecución, pero no se pueden sobrescribir. Para el valor de una constante hay
notaciones definidas según el tipo y formato de datos. Básicamente se distingue entre notación
con tipo y notación sin tipo.

Programación del PLC
Manual de programación y manejo, 11/2019

103

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Constantes sin tipo
En la notación sin tipo únicamente se introduce el valor de la constante, pero no un tipo de
datos. Las constantes sin tipo obtienen su tipo de datos con la combinación aritmética o lógica
en la que se utilizan.
El siguiente ejemplo muestra la notación de constantes sin tipo:
SCL
#My_Int1 := #My_Int2 + 12345

(*El tipo de datos de la constante "12345"
resulta de la suma con My_Int 2. "12345" recibe
el tipo de datos INT.*)

#My_Real1 := #My_Real2 + 12345

(*El tipo de datos de la constante "12345" resulta de la suma con My_Real2. "12345" recibe el tipo de datos REAL.*)

Constantes con tipo
En la notación con tipo, además del valor de la constante se indica explícitamente un tipo de
datos.
El siguiente ejemplo muestra la notación de constantes con tipo:
SCL
#My_Int1 := INT#12345

(*El tipo de datos de la constante es
siempre INT.*)

Nota
Constantes del tipo BOOL en KOP/FUP
En KOP/FUP solo se pueden utilizar constantes de tipo BOOL en entradas de instrucciones en
las CPU de las series S7-1200, a partir de la versión de firmware V4.0, y S7-1500 a partir de
la versión de firmware V1.8.
En las versiones de firmware anteriores, solo está permitido utilizarlas con instrucciones que
sean un bloque de función (FB) a nivel interno del sistema. Estas instrucciones se reconocen
porque al insertarlas en un segmento se abre el cuadro de diálogo "Opciones de llamada". En
ninguna de las instrucciones restantes se pueden utilizar constantes booleanas como
entradas.
En S7-300/400, el uso no está permitido.

Consulte también
Declaración de la interfaz de bloque (Página 7791)
Declarar constantes globales (Página 7908)
Calcular en SCL con constantes (Página 8135)

104

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

1.4.4.2

Declaración de nombres simbólicos para constantes

Constantes simbólicas
Existe la posibilidad de declarar nombres simbólicos para constantes, a fin de poder utilizar en
el programa valores constantes con un nombre. De ese modo se consigue una mejor
legibilidad y un mantenimiento más sencillo del programa en caso de cambio de valores
constantes.
Una constante simbólica está compuesta por los siguientes elementos:
● Nombre
● Tipo de datos
Las constantes simbólicas tienen siempre un tipo de datos y no admiten la notación sin tipo.
● Valor de la constante
Se puede elegir, como valor de constante, cualquier valor situado dentro del rango de
valores del tipo de datos indicado. Encontrará indicaciones sobre los rangos de valores en
el capítulo "Tipos de datos".

Declaración de constantes
Es posible definir constantes con ámbitos de validez distintos:
● Constantes globales válidas en toda la CPU
● Constantes locales válidas únicamente dentro de un bloque
La tabla siguiente muestra la diferencia entre los distintos tipos de constantes:

Ámbito de validez

Constantes globales

Constantes locales

● Válidas en toda la CPU

● Válidas en el bloque en el
que fueron declaradas.

● El nombre es unívoco dentro
de la CPU.

● El nombre es unívoco dentro
del bloque.

Caracteres permitidos

● Los caracteres permitidos en
el nombre de una constante
son letras, números y
caracteres especiales.

● Los caracteres permitidos en
el nombre de una constante
son letras, números y
caracteres especiales.

Ubicación de la definición

Ficha "Constantes" de la tabla
de variables PLC

Interfaz del bloque

Representación

Entre comillas, p. ej.:

Con una almohadilla antepues‐
ta, p. ej.:

"Glob_Const"

#Loc_Const

Es posible que se produzcan conflictos de nombres cuando se ha declarado una constante
local y una global con el mismo nombre simbólico y se utiliza el nombre asignado por duplicado

Programación del PLC
Manual de programación y manejo, 11/2019

105

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
como valor predeterminado de una variable. En este caso se utiliza automáticamente la
constante local.
Nota
Cargar la declaración de constantes (S7-300/400)
Las declaraciones de constantes locales y globales no se cargan en la CPU. Al cargar un
programa de un dispositivo es posible que ya no estén disponibles las declaraciones de
constantes.

Nota
Encontrará más información sobre los caracteres admisibles en nombres de constantes en el
Siemens Industry Online Support, en los artículos siguientes:
¿Cuándo hay que utilizar identificadores u operandos "entre comillas" en STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/10947785 (https://
support.industry.siemens.com/cs/ww/es/view/109477857)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Calcular en SCL con constantes (Página 8135)
Declarar constantes globales (Página 7908)
Declaración de la interfaz de bloque (Página 7791)

1.4.4.3

Tipos de datos de las constantes

Tipos de datos permitidos
Para las constantes se admiten todos los tipos de datos básicos y sus derivados:
● Números binarios
● Secuencias de bits
● Enteros
● Números en coma flotante
● Temporizadores
● Fecha y hora
●

Cadenas de caracteres

Se aplican las reglas generales sobre la conversión explícita e implícita de tipos de datos.

106

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Tipos de datos de constantes sin tipo
Las constantes sin tipo no contienen información explícita sobre el tipo de datos. Obtienen su
tipo de datos con la combinación aritmética o lógica en la que se utilizan.
El siguiente ejemplo muestra el tratamiento de constantes sin tipo:
SCL
#My_Int1 := #My_Int2 + 12345

(*El tipo de datos de la constante "12345"
resulta de la suma con My_Int 2. "12345" recibe
el tipo de datos INT.*)

#My_Real1 := #My_Real2 + 12345

(*El tipo de datos de la constante "12345" resulta de la suma con My_Real2. "12345" recibe el tipo de datos REAL.*)

Nota
STEP 7 utiliza siempre el tipo de datos con la precisión más alta posible
Mientras dentro de una expresión no sea posible definir de forma unívoca el tipo de datos de
una constante, se utilizará siempre el tipo de datos disponible en la CPU actual que tenga la
precisión más alta posible.
Ejemplo:
#My_Real := #My_Int / 3.5
En esta expresión se combina una variable de entero con una constante de coma flotante sin
tipo. En S7-300/400 se calcula la parte derecha de la asignación en formato REAL. En
S7-1200/1500, el cálculo se realiza automáticamente con la precisión más alta posible, es
decir, en este caso en LREAL. Como consecuencia, la asignación a una variable REAL no es
válida o bien genera una advertencia.
Para definir con precisión el tipo de datos de una constante, utilice la notación con tipo:
Ejemplo:
#My_Real := #My_Int / REAL#3.5

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Calcular en SCL con constantes (Página 8135)
Declarar constantes globales (Página 7908)
Declaración de la interfaz de bloque (Página 7791)

Programación del PLC
Manual de programación y manejo, 11/2019

107

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

1.4.4.4

Ejemplos de uso de constantes

Uso en instrucciones, asignaciones y expresiones
Las constantes pueden utilizarse en instrucciones o asignaciones en lugar de variables. En
SCL también es posible utilizar constantes en expresiones. Puesto que las constantes no
pueden escribirse, solo pueden utilizarse como entradas.
El siguiente ejemplo muestra los usos posibles de constantes:
SCL
#My_Int :=

3;

#My_Real1 := #My_Real2 * 3;
#My_Real1 := #My_Real2 * #My_local_const;
#My_Real1 := #My_Real2 * "My_global_const";

Uso como valor predeterminado
Las constantes también pueden utilizarse como valor predeterminado de una variable. Para
hacerlo, introduzca el valor o el nombre simbólico de la constante en la columna "Valor
predeterminado" de la interfaz del bloque. El tipo de datos de la constante debe ser igual al tipo
de datos de la variable o bien debe ser convertible de acuerdo con las reglas de la conversión
implícita de tipos de datos con comprobación IEC.

Uso como longitud máxima de STRING
Las constantes locales o globales del tipo de datos UINT, UDINT, ULINT, SINT, INT, DINT o
LINT también pueden utilizarse como longitud máxima de STRING.
El ejemplo siguiente muestra el uso de constantes como longitud máxima de STRING:
SCL
STRING[#My_local_const1]
STRING["My_global_const1"]

Uso como límite de ARRAY
Las constantes locales o globales del tipo de datos UINT, UDINT, ULINT, SINT, INT, DINT o
LINT también pueden utilizarse como límites de ARRAY.
El ejemplo siguiente muestra el uso de constantes como límites de ARRAY:
SCL
Array[#My_local_const1..#My_local_const2] of REAL
Array["My_global_const1".."My_global_const1"] of REAL

108

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Nota
Constantes como límites de ARRAY o como longitud máxima de STRING
● Las constantes que se utilizan como límites de ARRAY o como longitud máxima de
STRING no se pueden modificar si está activada la reserva de memoria del bloque. Esto
sucede tanto con constantes locales como globales. Para modificar estas constantes
primero debe desactivarse la reserva de memoria.
● Los cambios en constantes globales provocan incoherencias en los bloques que las
utilizan. Las incoherencias se marcan en rojo en el bloque utilizado. Para corregir las
incoherencias es necesario actualizar los bloques.
Consulte también: Actualizar bloques de datos (Página 7845)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Calcular en SCL con constantes (Página 8135)
Principios básicos del ARRAY (Página 293)
Declarar constantes globales (Página 7908)
Declaración de la interfaz de bloque (Página 7791)

1.4.5

Direccionar operandos

1.4.5.1

Direccionar variables globales

Direccionar variables globales
Para direccionar una variable PLC global se puede utilizar la dirección absoluta o el nombre
simbólico.
Nota
Los tipos de datos LWORD, LINT, ULINT, LREAL, LTIME, LTOD y LDT solo pueden ser
direccionados con su nombre simbólico.

Direccionamiento simbólico de variables globales
Para el direccionamiento simbólico debe usarse el nombre de variable procedente de la tabla
de variables PLC. El nombre simbólico de las variables globales se encierra automáticamente
entre comillas.

Programación del PLC
Manual de programación y manejo, 11/2019

109

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
Las variables estructuradas que se basan en un tipo de datos PLC se direccionan con el
nombre simbólico de las variables PLC. También es posible indicar los nombres de los
diferentes componentes separados por un punto.

Direccionamiento absoluto de variables globales
Para el direccionamiento absoluto indique la dirección de la variable obtenida de la tabla de
variables PLC. Para el direccionamiento absoluto se utilizan direcciones numéricas que
empiezan por cero para cada área de operandos. Delante de la dirección absoluta de las
variables globales se antepone automáticamente el identificador de dirección %.

Ejemplos
Ejemplos de aplicaciones del direccionamiento simbólico y absoluto:
Direccionamiento

Significado

%Q1.0

Dirección absoluta: Salida 1.0

%I16.4

Dirección absoluta: Entrada 16.4

%IW4

Dirección absoluta: Palabra de entrada 4

"Motor"

Dirección simbólica "Motor"

"Value"

Dirección simbólica "Value"

"Variable_estructurada"

Dirección simbólica de una variable basada en un tipo de datos PLC

"Variable_estructurada".Componente

Dirección simbólica del componente de una variable
estructurada.

Consulte también
Mostrar operandos simbólicos y absolutos (Página 7669)
Direcciones y tipos de datos admisibles para variables PLC (Página 7893)
Direccionar la periferia (Página 110)

Direccionar la periferia
Descripción
La memoria imagen de proceso de la CPU se actualiza una vez por ciclo. No obstante, en
aplicaciones de tiempo crítico puede ser necesario leer o transferir el estado actual de una
entrada o salida digital con una frecuencia mayor. Para ello se puede acceder directamente a
la periferia mediante un identificador de acceso a periferia en el operando.
Para leer la entrada directamente desde la periferia, utilice el área de memoria de entradas de
periferia (PI) como contraposición a la memoria imagen de proceso de las entradas (I). El área
de memoria de periferia se puede leer en formato de bits, bytes, palabras o palabras dobles.
Para leer la salida directamente desde la periferia, utilice el área de memoria de las salidas de
periferia (PQ) en contraposición a la memoria imagen de proceso de las salidas (Q). El área de

110

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
memoria de salidas de periferia se puede escribir en formato de bits, bytes, palabras o palabras
dobles.
Para leer o escribir una señal directamente desde una entrada de periferia se puede agregar
a un operando la identificación de acceso a la periferia ":P".
Los componentes de variables PLC estructuradas también pueden direccionarse con ":P". Sin
embargo, no es posible acceder a la variable de nivel superior con ":P".
ADVERTENCIA
Escritura directa en la periferia
La escritura directa en la periferia puede provocar estados peligrosos, p. ej. cuando se
direcciona varias veces en un ciclo de programa una salida de periferia en escritura.

Nota
S7-1200/1500: Transferir entradas o salidas de periferia como parámetros de bloque
Si se suministra una entrada o salida de periferia a un parámetro de entrada, existe el riesgo
de que se produzcan errores de acceso a periferia al llamar el bloque en tiempo de ejecución,
p. ej. un error de lectura en el acceso directo a datos de un módulo de entrada.
El comportamiento del sistema en las CPU de la serie S7-1500 con versión de FW V2.1 o
superior es el siguiente:
El bloque se llama y se procesa con el valor sustitutivo de la señal.
El comportamiento del sistema en las CPU de las series S7-1200 y S7-1500 con versión de FW
V2.1 o inferior es el siguiente:
El bloque no se llama debido al error de acceso a periferia. El programa sigue ejecutándose
tras la llamada del bloque. Si existe un OB 122 o si el tratamiento local de errores está activado,
estos se ejecutan.
Para impedir que una llamada de bloque no se ejecute en caso de un error de acceso a
periferia, copie la entrada o salida de periferia en una variable local (Temp) y transfiérala como
parámetro de bloque al bloque llamado.
Encontrará más información al respecto en la siguiente FAQ:
FAQ 89377245: ¿Por qué no se elaboran los bloques de un S7-1200/S7-1500 si se direcciona
con componentes PROFINET no disponibles? (https://
support.industry.siemens.com/cs/ww/es/view/89377245)

Sintaxis

<Operando>:P

Programación del PLC
Manual de programación y manejo, 11/2019

111

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Ejemplo
Ejemplo de aplicaciones de la identificación de acceso a la periferia:
Direccionamiento

Significado

"Motor"

Direcciona la variable "Motor" en la memoria imagen de
proceso.

"Motor":P

Direcciona la variable "Motor" en el área de memoria
de periferia (PI o PQ).

"Variable_estructurada".Componente

Direcciona el componente de una variable PLC estructurada en la memoria imagen de proceso.

"Variable_estructurada".Componente:P

Direcciona el componente de una variable PLC estructurada en el área de memoria de periferia (PI o PQ).

Consulte también
Direccionar variables globales (Página 109)

1.4.5.2

Direccionar variables en bloques de datos

Direccionar variables en bloques de datos globales
Descripción
En los bloques de datos globales, las variables se pueden direccionar de forma simbólica o
absoluta. Para el direccionamiento simbólico, se utiliza el nombre del bloque de datos y el
nombre de la variable, separados por un punto. El nombre del bloque de datos se pone entre
comillas.
Para el direccionamiento absoluto, se utiliza el número del bloque de datos y la dirección
absoluta de la variable en el bloque de datos, separados por un punto. Delante de la dirección
absoluta se antepone automáticamente el identificador de dirección %.
En el S7-1200/1500 es posible acceder a un bloque de datos que se desconoce en el momento
de la programación. Para ello se crea un parámetro de bloque del tipo de datos DB_ANY en la
interfaz del bloque que accede. A este parámetro se transfiere el nombre o el número del
bloque de datos en tiempo de ejecución. Para acceder a variables dentro del bloque de datos
utilice el nombre del parámetro de bloque del tipo de datos DB_ANY y la dirección absoluta de
la variable separada por un punto.

112

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Nota
Direccionar variables de DB de forma absoluta
Las siguientes variables no pueden ser direccionadas de forma absoluta:
● Variables de bloques con acceso optimizado.
● Variables de los tipos de variables LWORD, LINT, ULINT, LREAL, LTIME, LTOD y LDT.
Utilice para esas variables el direccionamiento simbólico, más cómodo.

Bloques de datos ARRAY
Un tipo especial de bloques de datos globales son los bloques de datos ARRAY. Están
formados por un ARRAY de un tipo de datos cualquiera. Puede ser un ARRAY de un tipo de
datos PLC (UDT), por ejemplo.
Los elementos de bloques de datos ARRAY se direccionan mediante la palabra clave "THIS".
A continuación, el índice se indica entre corchetes. El índice puede ser tanto una constante
como una variable. Como variables para el índice, se admiten números enteros de hasta 32
bits de ancho.
El área "Transferencia" de la Task Card "Instrucciones" ofrece opciones avanzadas para
direccionar bloques de datos ARRAY. Estas instrucciones ofrecen, p. ej., la posibilidad de
direccionar también el nombre del DB de forma indirecta.

Sintaxis

"<NombreDB>".NombreVariable
%<NúmeroDB>.DirecciónAbsoluta
#<Nombre_DBAny>.%DirecciónAbsoluta
"<ArrayDBname".THIS[#i].<Component>.<ComponentElement>
SCL:
"<ArrayDBname"."THIS"[#i].<Component>.<ComponentElement>
La tabla siguiente muestra las direcciones absolutas posibles de variables en bloques de datos:
Tipo de datos

Dirección absoluta

Ejemplo

Significado

BOOL

%DBn.DBXx.y

%DB1.DBX1.0

Bit de datos 1.0 en el
DB1

BYTE, CHAR, SINT,
USINT

%DBn.DBBy

%DB1.DBB1

Byte de datos 1 en el
DB1

WORD, INT, UINT

%DBn. DBWy

%DB1.DBW1

Palabra de datos 1 en el
DB1

DWORD, DINT,
UDINT, REAL, TIME

%DBn.DBDy

%DB1.DBD1

Palabra de datos doble
1 en el DB1

Programación del PLC
Manual de programación y manejo, 11/2019

113

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Ejemplo
Ejemplos de direccionamiento de variables en bloques de datos globales:
Direccionamiento

Significado

"Motor".Value

Direccionamiento simbólico de la variable "Value"
en el bloque de datos global "Motor".

%DB1.DBX1.0

Direccionamiento absoluto de la variable "DBX1.0"
en el bloque de datos global "DB1".

#MyDBAny.%DBX30.0

Direccionamiento absoluto de la variable
"DBX30.0" en el bloque de datos global, que en
runtime se transmite en el parámetro "MyDBany".

"MyARRAY_DB".THIS[#MyIndex].MyComponent.MyComponentElement

Direccionamiento de un bloque de datos ARRAY. El
índice de ARRAY se indica a través de la variable
"MyIndex". El elemento ARRAY contiene dos subestructuras más: "MyComponent" y "MyComponentElement".

---------------------V16----------------------

Consulte también
Uso del tipo de datos DB_ANY (Página 216)
Direccionamiento de caracteres individuales de un STRING o WSTRING (Página 280)
Direccionar tipos de datos PLC (UDT) (Página 287)
Direccionamiento de componentes STRUCT (Página 291)
Direccionar componentes de ARRAY (Página 299)
Direccionar áreas de una variable con accesos Slice (Página 116)
Fundamentos del direccionamiento indirecto (Página 121)
Direccionar datos de instancia (Página 114)

Direccionar datos de instancia
Descripción
Es posible direccionar elementos de datos desde la interfaz del bloque actual. Estas variables
se almacenan en el bloque de datos de instancia.
Nota
En los bloques de datos con acceso optimizado, las variables solo se pueden direccionar de
forma simbólica.
Para direccionar una variable desde la interfaz del bloque actual, debe introducirse el carácter
# seguido del nombre simbólico de la variable.

114

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
También es posible acceder a las variables de un bloque multiinstancia. Dentro del bloque
multiinstancia también deben direccionarse los datos con el carácter # seguido del nombre de
la variable. Para acceder a los datos del bloque multiinstancia desde el bloque que efectúa la
llamada se utiliza #<NombreMultiinstancia.NombreVariable>.

Sintaxis
Para direccionar variables en bloques de datos de instancia se utiliza la siguiente sintaxis:
#<nombre de la variable>
#<nombre de la multiinstancia>.<nombre de la variable>

Ejemplos
Ejemplos de direccionamiento de variables en bloques de datos de instancia:
Direccionamiento

Significado

#Value

Direccionamiento de la variable "Value" en el bloque de datos de
instancia.

#On

Direccionamiento de la variable "On" dentro del bloque multiinstancia

#Multi.On

Direccionamiento de la variable "On" del bloque multiinstancia
desde el bloque que llama

Consulte también
Direccionar variables en bloques de datos globales (Página 112)
Instancias (Página 61)
Direccionar componentes de ARRAY (Página 299)
Direccionar áreas de una variable con accesos Slice (Página 116)
Fundamentos del direccionamiento indirecto (Página 121)

Direccionamiento de los DB ARRAY
Direccionamiento de bloques de datos ARRAY
Una forma especial de ARRAY son los bloques de datos ARRAY. Los bloques de datos
ARRAY son bloques de datos globales que constan exactamente de un ARRAY. Los
elementos de bloques de datos ARRAY se direccionan con la siguiente sintaxis:
"<GlobArrayDBname>".THIS[#i].<elementname>
SCL:
"<GlobArrayDBname>"."THIS"[#i].<elementname>

Programación del PLC
Manual de programación y manejo, 11/2019

115

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Ejemplos
Ejemplos de direccionamiento de elementos en un DB ARRAY:
Direccionamiento en SCL

Significado

"My_ARRAY_DB"."THIS"[0]

"My_ARRAY_DB" es un DB ARRAY que contiene
elementos del tipo de datos REAL.
Aquí se direcciona el primer elemento dentro de "My_ARRAY_DB".

"MY_UDT_ARRAY_DB"."THIS"[3].MyREAL

"MY_UDT_ARRAY_DB" es un DB ARRAY que contiene elementos de un tipo de datos PLC
(UDT). El tipo de datos PLC contiene elementos del tipo de datos BYTE.
Aquí se direcciona el cuarto elemento del
ARRAY en "MY_UDT_ARRAY_DB" y, dentro de él,
el elemento "MyREAL".

Instrucciones para el direccionamiento de DB ARRAY
La sección "Transferencia > DB ARRAY" de la Task Card "Instrucciones > Instrucciones
básicas" ofrece opciones avanzadas para direccionar bloques de datos ARRAY. Estas
instrucciones ofrecen la posibilidad de direccionar el nombre del DB de forma indirecta, por
ejemplo:
● ReadFromArrayDB: Leer en un bloque de datos ARRAY
● WriteToArrayDB: Escribir en un bloque de datos ARRAY
● ReadFromArrayDBL: Leer en un bloque de datos ARRAY de la memoria de carga
● WriteToArrayDBL: Escribir en bloque de datos Array de la memoria de carga

Consulte también
Fundamentos del direccionamiento indirecto (Página 121)
Indexación indirecta de componentes de ARRAY (Página 128)
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Bloques de datos ARRAY globales (DB) (Página 43)
ARRAY (Página 293)

Direccionar áreas de una variable con accesos Slice
Descripción
Existe la posibilidad de direccionar áreas concretas dentro de variables declaradas. Se puede
acceder a áreas de 1 bit, 8 bits, 16 bits o 32 bits. La división de un área de memoria (p. ej. BYTE
o WORD) en áreas de memoria más pequeñas (p. ej. BOOL) también se denomina "Slice".

116

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
Con accesos Slice no pueden direccionarse estructuras, constantes ni variables que deben
superponerse con AT.

Sintaxis
Para el direccionamiento se utiliza la sintaxis siguiente:
<Variable>.X<Número de bit>
<Variable>.B<Número de BYTE>
<Variable>.W<Número de WORD>
<Variable>.D<Número de DWORD>
La sintaxis está formada por las partes siguientes:
Parte

Descripción

<Variable>

Variable a la que se accede. La variable debe ser del tipo de datos "Se‐
cuencia de bits" o "Entero".
Con SCL solo pueden programarse accesos Slice a variables del tipo de
datos "Entero" si la verificación CEI está desactivada.

X

Identificación de la anchura de acceso "Bit (1 bit)"

B

Identificación de la anchura de acceso "Byte (8 bits)"

W

Identificación de la anchura de acceso "Palabra (16 bits)"

D

Identificación de la anchura de acceso "DWord (32 bits)"

<Número de BIT>

Número del bit al que se accede dentro de la <Variable>. El número 0
accede al BIT menos significativo.

<Número de BYTE>

Número del byte al que se accede dentro de la <Variable>.
El número 0 accede al BYTE menos significativo.

<Número WORD>

Número de la palabra a la que se accede dentro de la <Variable>.
El número 0 accede a la WORD menos significativa.

<Número DWORD>

Número de la DWord a la que se accede dentro de la <variable>.
El número 0 accede a la DWord menos significativa.

Ejemplos de accesos Slice
Los siguientes ejemplos muestran el direccionamiento de slices por bit, byte, palabra y palabra
doble:
Direccionamiento

Significado

"Engine".Motor.X0

"Motor" es una variable del tipo de datos BYTE, WORD,
DWORD o LWORD en el bloque de datos global "Engine".

"Engine".Motor.X7

X0 direcciona la dirección de bit 0, X7 la dirección de
bit 7 dentro de "Motor".
"Engine".Speed.B0
"Engine".Speed.B1

"Speed" es una variable del tipo de datos WORD, DWORD o
LWORD en el bloque de datos global "Engine".
B0 direcciona la dirección de byte 0, B1 la dirección de
byte 1 dentro de "Speed".

Programación del PLC
Manual de programación y manejo, 11/2019

117

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
Direccionamiento

Significado

"Engine".Fuel.W0

"FUEL" es una variable del tipo de datos DWORD o LWORD en
el bloque de datos global "Engine".

"Engine".Fuel.W1

W0 direcciona la dirección de palabra 0, W1 la dirección
de palabra 1 dentro de "Fuel".
"Engine".Data.D0
"Engine".Data.D1

"Data" es una variable del tipo de datos LWORD en el bloque de datos global "Engine".
D0 direcciona la dirección de palabra doble 0, D1 la dirección de palabra doble 1 dentro de "Data".

Ejemplo de programación
Encontrará un ejemplo detallado en el Siemens Industry Online Support:
https://support.industry.siemens.com/cs/ww/es/view/57374718 (https://
support.industry.siemens.com/cs/ww/es/view/57374718)

Superponer variables con AT
Descripción
Para acceder a determinadas áreas de datos dentro de una variable declarada, se puede
superponer a las variables declaradas otra declaración más. De esta manera existe la
posibilidad de direccionar una variable ya declarada con otro tipo de datos. Por ejemplo, cada
bit de una variable del tipo de datos WORD se puede direccionar con un ARRAY of BOOL.
Otra posibilidad consiste en utilizar las instrucciones "SCATTER" y "GATHER" para
descomponer secuencias de bits en un ARRAY of BOOL o bien para agrupar bits individuales
en una secuencia. Estas instrucciones se encuentran en la Task Card "Instrucciones básicas"
del área "Transferencia".

Reglas
Reglas generales válidas para la superposición de variables:
● En AWL, KOP, FUP y GRAPH es posible la superposición en S7-1200 y S7-1500.
● En SCL, la superposición es posible en todas las familias de CPU.
● La superposición de variables es posible en los siguientes bloques:
– En bloques lógicos con acceso estándar
– En bloques lógicos de acceso optimizado para variables con el ajuste de remanencia
"Ajustar en IDB"
● El ancho de datos de la variable superpuesta debe ser menor o igual al de la variable sobre
la que se superpone.
● Los tipos de datos VARIANT e INSTANCE no pueden superponerse.
● Si la variable superpuesta es del tipo de datos STRING, ARRAY of BYTE, ARRAY of
CHAR, etc., su longitud debería equivaler a un número par de bytes.

118

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
● Los bloques de librerías que están declaradas como parámetros en la interfaz no pueden
superponerse.
● Las variables PLC estructuradas que están declaradas como parámetros en la interfaz no
pueden superponerse.
● Las variables que deben superponerse no pueden direccionarse mediante accesos Slice.

Nota
S7-1200/1500: utilizar AT en FC
En las FC del S7-1200/1500, el ancho de datos de las variables superpuestas deben ser
idénticos a los de las variables sobre las que se superponen. Si eso no es factible en su
programa, compruebe si en lugar de una construcción AT puede utilizar un acceso Slice o las
instrucciones "SCATTER" y "GATHER".
Consulte también: Direccionar áreas de una variable con accesos Slice (Página 116)
Además, rigen las siguientes reglas de combinación:
Variable superpues‐ Variable sobre la que se superpone
ta
FB

Input

Simple

Estructurada *

Simple

x

x **

Estructurada *

x

x

Any/Pointer
Temp

DB_ANY
x

x

x

x

Simple

x

x **

Estructurada

x

x

Any/Pointer
Static, Output

Any/Pointer

x

x

Simple

x

x **

x

Estructurada

x

x

x

Any/Pointer
InOut

Simple

x

Estructurada

x
x

Any/Pointer
FC

Temp

Simple

x

x **

Estructurada

x

x

Any/Pointer
Input, Output,
InOut

Simple

x

x
x

x

(ambas variables
deben tener el mis‐
mo ancho de bit)
Estructurada

x

Any/Pointer
OB

Temp

Simple

x

x **

Estructurada

x

x

Any/Pointer

Programación del PLC
Manual de programación y manejo, 11/2019

x

x

119

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
* Los tipos de datos estructurados son los que se componen de varios elementos de datos, p.
ej. ARRAY o STRUCT.
** Excepción: BOOL, BYTE, SINT, USINT y CHAR no pueden solaparse con variables del tipo
de datos STRUCT, UDT o ARRAY.

Declaración
Para superponer una variable, es necesario declarar una segunda variable directamente a
continuación de la variable sobre la que se desea superponer, e identificarla con la palabra
clave "AT".

Ejemplo
La figura siguiente muestra la declaración de una variable sobre la que se superpone en la
interfaz de un FB:

Al llamar un bloque con la declaración de variables indicada, se suministran valores a la
variable "MyWord". Dentro del bloque existen dos posibilidades de interpretación de estos
datos:
● como WORD
● como ARRAY of BOOL unidimensional

120

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Consulte también
Declarar variables superpuestas (Página 7801)
Ajustar remanencia (Página 7855)

1.4.5.3

Direccionar operandos de modo indirecto

Direccionamiento indirecto
Fundamentos del direccionamiento indirecto
Introducción
El direccionamiento indirecto ofrece la posibilidad de direccionar operandos cuya dirección no
se calcula hasta el momento de la ejecución. El direccionamiento indirecto también permite
procesar varias veces partes del programa utilizando un operando diferente en cada
ejecución. Así se puede utilizar un índice diferente para cada ejecución, p. ej. en bucles de
programa.
Las ventajas resultantes son las siguientes:
● Más flexibilidad dentro del programa.
● El direccionamiento indirecto está disponible en todos los lenguajes de programación de
STEP 7.
● El código del programa resulta más claro y legible.
● Se utilizan los nombres existentes de los bloques de datos y las variables (direccionamiento
simbólico). De este modo se aumenta la legibilidad del código del programa.

ADVERTENCIA
Peligro de errores de acceso
Puesto que en el direccionamiento indirecto los operandos no se calculan hasta el momento
de la ejecución, existe el peligro de que se produzcan errores de acceso y el programa
funcione con valores incorrectos. Además, es posible sobrescribir áreas de memoria
involuntariamente con valores incorrectos. En ese caso, el sistema de automatización puede
reaccionar de forma inesperada.
Por ello, el direccionamiento indirecto debe usarse siempre con precaución.

Programación del PLC
Manual de programación y manejo, 11/2019

121

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Posibilidades generales del direccionamiento indirecto en S7-1200 y S7-1500
Posibilidades de direccionamiento indirecto disponibles en todos los lenguajes de
programación:
● Direccionamiento indirecto mediante punteros
● Indexación indirecta de componentes de ARRAY
● Direccionamiento indirecto de un bloque de datos mediante el tipo de datos DB_ANY.

Posibilidades de direccionamiento indirecto específicas del lenguaje
Además, los diferentes lenguajes de programación ofrecen las siguientes posibilidades de
direccionamiento específicas:
● En AWL pueden direccionarse operandos de forma indirecta a través del registro de
direcciones.
● En SCL se puede leer o escribir un área de memoria variable con las siguientes
instrucciones:
– POKE - escribir dirección de memoria
– POKE_BOOL - escribir bit de memoria
– PEEK - leer dirección de memoria
– PEEK_BOOL - leer bit de memoria
– POKE_BLK - escribir área de memoria

Consulte también
Direccionar variables en bloques de datos globales (Página 112)
POKE: Escribir dirección de memoria (Página 1900)
POKE_BOOL: Escribir bit de memoria (Página 1902)
PEEK: Leer dirección de memoria (Página 1896)
PEEK_BOOL: Leer bit de memoria (Página 1898)
POKE_BLK: Escribir área de memoria (Página 1903)
Direccionamiento indirecto vía puntero (Página 127)
Indexación indirecta de componentes de ARRAY (Página 128)
Direccionamiento indirecto en AWL (Página 134)

Ejemplos de direccionamiento indirecto
1.er ejemplo de programación
En el ejemplo siguiente se accede por medio de un índice a tres variables que están en áreas
de memoria distintas.

122

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
Vista general de las tres variables, cada una asignada a un índice:
Índice

Acceso a variable

Área de memoria

1

Input_WORD_0

IW 0

2

"Processdata".Temperature

DB 1

3

Output_WORD_4

QW 4

En la "Tabla de variables estándar", declare las dos variables siguientes:

Cree un bloque de datos global:
1. Haga doble clic en el comando "Agregar nuevo bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
2. Haga clic en el botón "Bloque de datos (DB)".
3. Introduzca el nombre "DB_Processdata".
4. Como tipo del bloque de datos, seleccione "Global DB".
5. Haga clic en "Aceptar".
6. Declare el elemento de bloque de datos "Temperature":

Programación del PLC
Manual de programación y manejo, 11/2019

123

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
Dentro de una función, declare los accesos indirectos por medio de un índice.
1. Cree una función SCL y llámela "FB_AccessGroupInt".
2. Declare la interfaz del bloque de la manera siguiente:

3. Escriba el siguiente código de programa:

4. Llame la función "FC_AccessGroupInt" en el OB1:

Según sea el número indicado en el parámetro Index (1, 2 o 3), se ejecutará el primero,
segundo o tercer caso de la instrucción "FC_AccessGroupInt".

2.º ejemplo de programación
En el ejemplo siguiente se accede por medio de un índice a tres bloques de datos optimizados
distintos.

124

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
Puesto que todos los bloques de datos deben tener las mismas variables, existe la posibilidad
de trabajar en este caso con un tipo de datos PLC (UDT).
1. Cree un tipo de datos PLC haciendo doble clic en el comando "Agregar nuevo tipo de datos"
de la carpeta "Tipos de datos PLC", dentro del árbol del proyecto.
Para crear un tipo de datos PLC se crea y se abre una tabla de declaración nueva.
2. Cambie el nombre del tipo de datos PLC por "UDT_SiloContents".
3. Declare las siguientes líneas dentro del tipo de datos PLC:
MyBool > Tipo de datos: BOOL
MyInt > Tipo de datos: INT
MyWord > Tipo de datos: WORD

Cree tres bloques de datos globales.
1. Haga doble clic en el comando "Agregar nuevo bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
2. Haga clic en el botón "Bloque de datos (DB)".
3. Introduzca los nombres "DB_SiloWater", "DB_SiloSugar" y "DB_SiloMilk".

Programación del PLC
Manual de programación y manejo, 11/2019

125

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
4. Como tipo de los bloques de datos, seleccione "UDT_SiloContents".
5. Haga clic en "Aceptar".

Cree una función para leer valores de las variables del bloque de datos y escribirlos en un tipo
de datos PLC.
1. Cree una función SCL y llámela "FC_AccessGroupSiloRead".
2. Declare la interfaz del bloque de la manera siguiente:

126

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
3. Escriba el siguiente código de programa:

4. Llame la función "FC_AccessGroupSiloRead" en el OB1:

Según sea el número indicado en el parámetro
Index (1, 2 o 3), se ejecutará el primero, segundo o tercer caso de la instrucción
"FC_AccessGroupSiloRead".

Consulte también
Direccionamiento indirecto en AWL (Página 140)
Direccionamiento indirecto en SCL (Página 137)
Direccionar operandos de modo indirecto (Página 121)

Direccionamiento indirecto vía puntero
Descripción
Para el direccionamiento indirecto se requiere un formato de datos especial, que contiene la
dirección y, en su caso, también el rango y el tipo de datos de un operando. Este formato de
datos se denomina puntero. Están disponibles los siguientes tipos de punteros:
● Referencias (S7-1500)
● VARIANT (S7-1200/1500)

Programación del PLC
Manual de programación y manejo, 11/2019

127

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
● POINTER (S7-1500)
● ANY (S7-1500, válido solo para bloques con acceso estándar)
Encontrará más información sobre tipos de datos de puntero en "Consulte también".
Nota
POINTER en SCL
En SCL, el uso de POINTER está sujeto a limitaciones. Solo existe la posibilidad de reenviarlo
a bloques ya llamados.

Ejemplo
El ejemplo siguiente muestra un direccionamiento indirecto con un puntero intraárea:
Direccionamiento en AWL

Significado

L P#10.0

// Cargar el puntero (P#10.0) en el Acumulador 1

T MD20

// Transferir el puntero al operando MD20

L MW [MD20]

// Cargar MW10 en el Acumulador 1

....

// Cualquier programa

L MD [MD20]

// Cargar MD10 en el Acumulador 1

....

// Cualquier programa

= M [MD20]

// Para RLO=1, activar el bit de marca M10.0

El puntero P#10.0 se transfiere al operando MD20. Si el operando MD20 está programado
entre corchetes, en tiempo de ejecución se reemplazará por la dirección contenida en el
puntero.

Consulte también
Fundamentos del direccionamiento indirecto (Página 121)
Puntero (Página 310)

Indexación indirecta de componentes de ARRAY
Accesos de ARRAY con índice variable
Como índices para direccionar elementos de ARRAY se pueden especificar constantes o
variables del tipo de datos Entero. Se admiten enteros con una longitud de hasta 32 bits.
En caso de direccionamiento indirecto con una variable, el índice no se calcula hasta que no
se ejecuta el programa. Así se puede utilizar un índice diferente para cada ejecución, p. ej. en
bucles de programa.

128

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Sintaxis
Para indexar un ARRAY de forma indirecta se usa la siguiente sintaxis:
"MyDB".MyArray[#i]
// ARRAY unidimensional
"MyDB".MyArray[#i].a // ARRAY of STRUCT unidimensional
"MyDB".MyArray[#i,#j]// ARRAY multidimensional
"MyDB".MyArray[#i].a // ARRAY of STRUCT multidimensional
La sintaxis está formada por las partes siguientes:
Parte

Descripción

MyDB

Nombre del bloque de datos en el que se encuentra el ARRAY

MyArray

Variable del tipo de datos ARRAY

i, j

Variables PLC del tipo de datos Entero que se emplean como punteros

a

Otras variables parciales de la estructura

Nota
Si se llama un bloque y se le transfiere un componente de ARRAY indexado de forma indirecta
("MyDB".MyArray[#i]) como parámetro de entrada/salida (InOut), no es posible modificar el
valor de la variable de índice [i] durante la ejecución del bloque. Es decir, el valor siempre se
vuelve a escribir en el mismo componente de ARRAY del que se ha leído.

Indexar componentes de ARRAY con las instrucciones "FieldRead" y "FieldWrite"
Para la indexación indirecta de componentes ARRAY en KOP y FUP también pueden utilizarse
las siguientes instrucciones:
● FieldWrite - Escribir campo
● FieldRead - Leer campo

Consulte también
Ejemplos de indexación indirecta de ARRAYs (Página 130)
Direccionar indirectamente elementos de ARRAY (Página 213)
Fundamentos del direccionamiento indirecto (Página 121)
Direccionar componentes de ARRAY (Página 299)
ARRAY (Página 293)

Programación del PLC
Manual de programación y manejo, 11/2019

129

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Ejemplos de indexación indirecta de ARRAYs
Ejemplo: Acceso a ARRAY con índice variable en KOP
El ejemplo siguiente muestra la indexación indirecta de un componente de ARRAY (en este
caso, con KOP). "MyArray" es un ARRAY tridimensional.#Tag_1, #Tag_2 y #Tag_3 son
parámetros de entrada del tipo de datos "Integer". En función de sus valores, uno de los
componentes del MyArray se copia en la variable "MyTarget".
ಯ7DJ,Qಯ
0\'%0\$UUD\>0\7DJB
0\7DJB0\7DJB@

029(
(1

(12

,1

287

ಯ7DJ2XWಯ

ಯ0\7DUJHWಯ

Ejemplo: Acceso a ARRAY con índice variable en SCL
El ejemplo siguiente muestra cómo se direccionan varios bloques de datos mediante un índice
variable. En el ejemplo se utilizan cinco ejes de velocidad. Los ejes deben ejecutarse
iterativamente en un bucle FOR con SCL.
1. Primero cree cinco ejes de velocidad. Los cinco ejes deben ser del mismo tipo.
Para cada eje se crea un bloque de datos en el árbol del proyecto:

2. A continuación cree un bloque de datos global y declare un ARRAY del tipo de datos ANY
con cinco componentes.

130

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
3. Para la inicialización, asigne a los distintos elementos del ARRAY del OB de arranque los
nombres simbólicos de los cinco ejes.

4. En SCL se accede iterativamente a los distintos ejes mediante un bucle FOR. Los ejes se
transfieren sucesivamente a la función "MaximumVelocity" para su procesamiento.

Ejemplo: Acceso a ARRAY con índice variable en AWL
Un ejemplo de aplicación de un acceso a un ARRAY con índice variable en AWL se puede
consultar en "Direccionar indirectamente elementos de ARRAY". (Página 213)

Consulte también
Indexación indirecta de componentes de ARRAY (Página 128)
Fundamentos del direccionamiento indirecto (Página 121)
Direccionar componentes de ARRAY (Página 299)
ARRAY (Página 293)

Programación del PLC
Manual de programación y manejo, 11/2019

131

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Direccionamiento indirecto de caracteres individuales de un STRING
Descripción
Como índices para direccionar caracteres individuales de un STRING o WSTRING no solo se
pueden especificar constantes, sino también variables. Las variables deben ser del tipo de
datos "Entero". Si se usan variables, el índice se calcula en tiempo de ejecución. Así se puede
utilizar un índice diferente para cada ejecución, p. ej. en bucles de programa.
Si al llamar el bloque se transfiere un STRING o WSTRING indexado por variable a un
parámetro de entrada/salida (InOut), tenga en cuenta lo siguiente: la variable de índice [i] se
lee una vez al iniciar la llamada del bloque y, durante la ejecución del bloque llamado, no puede
ser modificada por él.
Nota
Supervisión de accesos STRING en tiempo de ejecución
Si en tiempo de ejecución se escribe un STRING o WSTRING que supera la longitud definida,
es posible que se produzcan reacciones inesperadas en el programa. En S7-1200/1500 se
vigila el rebase de la longitud de STRING o WSTRING. Si en el acceso de lectura al STRING
se obtiene el carácter '$00' o '$0000', no se ejecuta ningún acceso de escritura al STRING. Si
la instrucción dispone de la salida de habilitación ENO, ENO adopta el estado lógico FALSE.
La CPU no pasa a STOP.

Sintaxis
Para indexar un STRING o WSTRING de forma indirecta se usa la siguiente sintaxis:
"<Bloque de datos>".<STRING>["i"]
"<Bloque de datos>".<WSTRING>["i"]

Ejemplo
El siguiente ejemplo muestra la indexación indirecta de un STRING a partir del ejemplo de
SCL. "STRING", "WSTRING", "CHAR" y "WCHAR" son variables. "Tag_1" es una variable PLC
del tipo de datos "Integer".

132

Direccionamiento en SCL

Significado

STRING["Tag_1"] := CHAR;

(*Direccionamiento indirecto: Asignación de "CHAR" al carácter especificado
con "Tag_1" del STRING*)

WSTRING["Tag_1"] := WCHAR;

(*Direccionamiento indirecto: Asignación de "WCHAR" al carácter especificado
con "Tag_1" del WSTRING*)

WCHAR := WSTRING["Tag_1"];

(*Direccionamiento indirecto: Asignación del carácter del WSTRING especificado con "Tag_1" a WCHAR*)

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Consulte también
STRING (Página 274)
WSTRING (Página 277)

Direccionamiento indirecto en AWL
Fundamentos de registros de direcciones
Introducción
Para direccionar operandos de forma indirecta existen dos registros de direcciones, el registro
de direcciones 1 (AR1) y el registro de direcciones 2 (AR2). Los registros de direcciones son
equivalentes y tienen una longitud de 32 bits. En los registros de direcciones pueden guardarse
punteros intraárea y punteros interárea. Los datos guardados pueden llamarse en el programa
para determinar la dirección de un operando.
El intercambio de datos entre los registros y las demás áreas de memoria disponibles se
realiza con ayuda de instrucciones de carga y transferencia.
Nota
En el S7-1500 rigen reglas especiales para intercambiar datos a través del registro de bloques
de datos y el registro de direcciones:
● los valores de los registros no se mantienen más allá de los límites del bloque.
● Al cambiar el lenguaje dentro de un bloque, los registros se inicializan.
● Solo es posible remitir a datos de bloques con acceso optimizado cuando estos disponen
del ajuste de remanencia "Ajustar en IDB".
● No es posible remitir a datos locales en bloques con acceso optimizado mediante los
registros de direcciones (interárea).

Consulte también
LAR1: Cargar contenido del acumulador 1 en AR1 (Página 5440)
LAR1 <D>: Cargar palabra doble o puntero de área en AR1 (Página 5441)
LAR1 AR2: Cargar contenido del AR2 en AR1 (Página 5443)
LAR2: Cargar contenido del acumulador 1 en AR2 (Página 5443)
CAR: Intercambiar AR1 y AR2 (Página 5449)
TAR1: Transferir AR1 a acumulador 1 (Página 5449)
TAR1 <D>: Transferir AR1 a palabra doble (Página 5450)
TAR1 AR2: Transferir AR1 a AR2 (Página 5451)
TAR2: Transferir AR2 a acumulador 1 (Página 5452)
+AR1: Sumar acumulador 1 a AR1 (Página 5540)

Programación del PLC
Manual de programación y manejo, 11/2019

133

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
+AR2: Sumar acumulador 1 a AR2 (Página 5541)
Direccionamiento indirecto en AWL (Página 134)
Intercambio de datos en AWL (Página 8065)
Direccionar áreas de una variable con accesos Slice (Página 116)
Carga y transferencia (Página 1655)
Ajustar remanencia (Página 7855)

Direccionamiento indirecto en AWL
En AWL existen las siguientes posibilidades de direccionamiento indirecto:
● Direccionamiento indirecto por memoria
● Direccionamiento intraárea indirecto por registro
● Direccionamiento indirecto interárea por registro

Direccionamiento indirecto por memoria
En el direccionamiento indirecto por memoria se deposita la dirección en una variable. Esta
variable puede ser del tipo de datos WORD o DWORD. La variable puede encontrarse en las
áreas de memoria "Datos" (DB o DI), "Marcas" (M) o "Datos locales temporales" (L). En el
S7-1500, los parámetros del FB también pueden utilizarse para depositar la dirección. Si la
variable se encuentra en un bloque de datos, este debe tener acceso estándar.
Ejemplo de aplicaciones del direccionamiento indirecto por memoria:
Direccionamiento en AWL

Significado

U E [MD 2]

// Ejecuta una operación lógica Y con un bit de entrada
variable. La dirección del bit de entrada se encuentra
en la palabra doble de marcas MD2.

= DIX [DBD 2]

// Asigna el RLO a un bit de datos variable. La dirección del bit de datos se encuentra en la palabra doble
de datos DBD2.

L EB [DID 4]

// Carga un byte de entrada variable en ACU 1. La dirección del byte de entrada se encuentra en la palabra doble de instancia DID4.

AUF DB [LW 2]

// Abre un bloque de datos variable. El número del bloque de datos se encuentra en la palabra de datos locales
LW2.

Direccionamiento intraárea indirecto por registro
El direccionamiento indirecto por registro utiliza uno de los registros de direcciones (AR1 o
AR2) para obtener la dirección del operando.
En el direccionamiento intraárea indirecto por registro solo se indexan la dirección de bit y la
dirección de byte mediante el registro de direcciones (p. ej. P#10.0). El área de memoria para
el que será válida la dirección del registro de direcciones no se indica hasta realizar que no se

134

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
programa la instrucción. De este modo, la dirección del registro de direcciones actuará en el
área de memoria que se especifique en la instrucción.
Las áreas de memoria posibles son "Entradas" (I), "Salidas" (Q), "Periferia" (PI o PQ), "Marcas"
(M), "Datos locales temporales" (L) y "Datos" (DB o DI). Si el operando se encuentra en un
bloque de datos, este debe ser de acceso estándar.
Al introducir el direccionamiento intraárea indirecto por registro, después de indicar el registro
de direcciones se especifica un offset que se añade al contenido del registro de direcciones sin
modificarlo. Dicho offset también tiene el formato de un puntero. Es obligatorio indicar el
puntero, lo cual debe realizarse como constante (p. ej. P#0.0 o P#2.0).
Ejemplo de aplicación del direccionamiento indirecto intraárea por registro:
AWL

Significado

LAR1 P#10.0

// Cargar el puntero (P#10.0) en el registro de direcciones 1

L IW [AR1, P#2.0]

// Aumentar el contenido del registro de direcciones 1
(P#10.0) con el offset P#2.0.
// Cargar el contenido de la palabra de entrada IW12 en el
acumulador 1

L IW [AR1, P#0.0]

// Aumentar el contenido del registro de direcciones 1
(P#10.0) con el offset P#0.0.
// Cargar el contenido de la palabra de entrada IW10 en el
acumulador 1

Direccionamiento indirecto interárea por registro
En el direccionamiento interárea indirecto por registro se indexa la dirección completa del
operando (es decir, tanto las direcciones de bit y byte como el área de memoria) mediante el
registro de direcciones. Las áreas de memoria posibles son "Entradas" (I), "Salidas" (Q),
"Periferia" (PI), "Marcas" (M), "Datos locales temporales" (L) y "Datos" (DB o DI). Si el
operando se encuentra en un bloque de datos, este debe ser de acceso estándar o el operando
debe tener el ajuste de remanencia "Ajustar en IDB".
En la instrucción únicamente se programa el ancho del operando. Los anchos del operando
posibles son bit, byte, palabra y palabra doble.
Ejemplo de aplicación del direccionamiento interárea indirecto por registro:

LAR1 P#M10.0

// Cargar el puntero interárea (P#M10.0) en el registro de direcciones 1

L W [AR1, P#2.0]

// Aumentar el contenido del registro de direcciones 1
(P#M10.0) con el offset P#2.0.
// Cargar el contenido de la palabra de marca MW12 en el acumulador 1

LAR1 P#A10.0

// Cargar el puntero interárea (P#Q10.0) en el registro de direcciones 1

L W [AR1, P#2.0]

// Sumar el contenido del registro de direcciones 1 (P#Q10.0)
con el offset P#2.0
// Cargar el contenido de la palabra de salida QW12.0 en el
acumulador 1

Programación del PLC
Manual de programación y manejo, 11/2019

135

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Nota
Particularidades en S7-1500
En el S7-1500 rigen reglas especiales para intercambiar datos a través del registro de bloques
de datos y el registro de direcciones:
● los valores de los registros no se mantienen más allá de los límites del bloque. Los registros
también se inicializan al cambiar el lenguaje dentro de un bloque.
● Si se accede a un operando del tipo BYTE, WORD o DWORD mediante direccionamiento
indirecto por registro, la dirección deberá comenzar en un límite de byte.
Ejemplos:
LAR1 P#0.0
L MW [AR1, P#0.0] // P#0.0 + P#0.0 = P#0.0 - El direccionamiento está permitido ya que
el puntero P#0.0 señala a un límite de byte.
L MW [AR1, P#2.1] // P#0.0 + P#2.1 = P#2.1 - El direccionamiento no está permitido ya que
el puntero P#2.1 no señala a un límite de byte.

Consulte también
Fundamentos del direccionamiento indirecto (Página 121)
Direccionamiento indirecto de bloques de datos (Página 137)
Direccionar componentes de ARRAY (Página 299)
Fundamentos de registros de direcciones (Página 133)
Intercambio de datos en AWL (Página 8065)

Direccionamiento indirecto
Direccionamiento indirecto mediante punteros
Descripción
Para el direccionamiento indirecto se requiere un formato de datos especial, que contiene la
dirección y, en su caso, también el rango y el tipo de datos de un operando. Este formato de
datos se denomina puntero. Tipos de punteros disponibles:
● POINTER (S7-300/400)
● ANY (S7-300/400)
● VARIANT (S7-1200/1500)

136

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
Encontrará más información sobre tipos de datos de puntero en "Consulte también".
Nota
En SCL, el uso del tipo de datos puntero está sujeto a limitaciones. Solo existe la posibilidad
de reenviarlo a bloques ya llamados.

Ejemplo
El ejemplo siguiente muestra un direccionamiento indirecto con un puntero intraárea:
Direccionamiento en AWL

Significado

L P#10.0

// Cargar el puntero (P#10.0) en el Acumulador 1

T MD20

// Transferir el puntero al operando MD20

L MW [MD20]

// Cargar MW10 en el Acumulador 1

....

// Cualquier programa

L MD [MD20]

// Cargar MD10 en el Acumulador 1

....

// Cualquier programa

= M [MD20]

// Para RLO=1, activar el bit de marca M10.0

El puntero P#10.0 se transfiere al operando MD20. Si el operando MD20 está programado
entre corchetes, en tiempo de ejecución se reemplazará por la dirección contenida en el
puntero.

Consulte también
Fundamentos del direccionamiento indirecto (Página 121)
Puntero (Página 310)

Direccionamiento indirecto en SCL
Direccionamiento indirecto de bloques de datos
Direccionamiento indirecto de bloques de datos en SCL
Para direccionar bloques de datos de forma indirecta, puede utilizarse la función de conversión
WORD_TO_BLOCK_DB. El número de DB se indica como variable o expresión con el tipo de
datos WORD.

Sintaxis
Para direccionar un bloque de datos de forma indirecta se usa la siguiente sintaxis:
WORD_TO_BLOCK_DB(índice).IdentificadorDelOperando(dirección)

Programación del PLC
Manual de programación y manejo, 11/2019

137

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Ejemplos
Ejemplo 1: la variable global "Índice de dirección" del tipo de datos WORD se utiliza como
número del DB.
Direccionamiento en SCL
%M0.0:=WORD_TO_BLOCK_DB("índice de dirección").DX(0,0);
%MW0:=WORD_TO_BLOCK_DB("índice de dirección").DW(4);

Ejemplo 2: la variable global "Índice de dirección" del tipo de datos WORD se utiliza como
número del DB. El elemento de datos dentro del DB también se especifica mediante un índice.
Direccionamiento en SCL
%M0.0:=WORD_TO_BLOCK_DB("índice de dirección").DX(#i,#y);
%MW0:=WORD_TO_BLOCK_DB("Índice de dirección").DW(#y);

Consulte también
Fundamentos del direccionamiento indirecto (Página 121)
Direccionamiento indirecto en AWL (Página 134)
Direccionar componentes de ARRAY (Página 299)

Direccionamiento indirecto de variables
Direccionamiento indirecto de variables en SCL
El direccionamiento indirecto se realiza de modo similar al direccionamiento absoluto. En lugar
de la dirección se especifica un offset entre paréntesis. El offset se compone de una variable
de byte, y si se usan operandos booleanos, de una variable de byte y una variable de bit. Las
variables de byte y bit deben ser del tipo de datos INT.
Los temporizadores y contadores procedentes de la tabla de variables PLC no se pueden
direccionar de forma indirecta de este modo.

Sintaxis
Para indexar una variable global de forma indirecta se usa la siguiente sintaxis:
IdentificadorDelOperando(VariableDeByte)
IdentificadorDelOperando(VariableDeByte.VariableDeBit)
Para indexar una variable DB de forma indirecta se usa la siguiente sintaxis:
MyDB.IdentificadorDelOperando(VariableDeByte)
MyDB.IdentificadorDelOperando(VariableDeByte.VariableDeBit)

138

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Ejemplos
Ejemplo 1: En función del valor de la variable contador i se pone a 0 una de las palabras de
entrada 2 a 8.
Direccionamiento en SCL
#i:=2;
FOR #i := 2 TO 8 DO
%IW(#i) := 0 ;
END_FOR;

Ejemplo 2: En función del valor de la variable contador i se pone a 0 una de las palabras 2 a
8 en DB10.
Direccionamiento en SCL
#i:=2;
FOR #i := 2 TO 8 DO
%DB10.DW(#i) := 0 ;
END_FOR;

Direccionamiento indirecto de componentes de ARRAY
Descripción
Como índices para direccionar los componentes de un ARRAY no solo se pueden especificar
constantes, sino también variables del tipo de datos Entero. Si se usan variables, el índice se
calcula en tiempo de ejecución. Así se puede utilizar un índice diferente para cada ejecución,
p. ej. en bucles de programa.
Nota
La variable de índice [i] se lee una vez al iniciar la llamada al bloque y, durante la ejecución del
bloque llamado, no puede ser modificada por él.
Si se llama un bloque y se le transfiere un componente de ARRAY indexado de forma indirecta
("<Bloque de datos>".<ARRAY>["i"]) como parámetro de entrada/salida (InOut), no es posible
modificar el valor de la variable de índice durante el procesamiento del bloque. Es decir, el valor
siempre se vuelve a escribir en el mismo componente de ARRAY del que se ha leído.

Sintaxis
Para indexar un ARRAY de forma indirecta se usa la siguiente sintaxis:
"<Bloque de datos>".<ARRAY>["i"] // ARRAY unidimensional
"<Bloque de datos>".<ARRAY>["i"].a // ARRAY of STRUCT unidimensional
"<Bloque de datos>".<ARRAY>["i", "j"] // ARRAY multidimensional
"<Bloque de datos>".<ARRAY>["i", "j"].a // ARRAY of STRUCT
multidimensional

Programación del PLC
Manual de programación y manejo, 11/2019

139

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
La sintaxis está formada por las partes siguientes:
Parte

Descripción

Bloque de datos

Nombre del bloque de datos en el que se encuentra el ARRAY

ARRAY

Variable del tipo de datos ARRAY

i, j

Variables PLC del tipo de datos Entero que se emplean como punteros

a

Otras variables parciales de la estructura

Ejemplos
Los ejemplos siguientes muestran la indexación indirecta de un componente de ARRAY (en
este caso, con SCL). MOTOR es un ARRAY_of_INT unidimensional con tres filas. VALUES es
una variable PLC del tipo de datos "Integer".
Direccionamiento en SCL

Significado

MOTOR[2] := VALUES;

(*Direccionamiento directo: asignación
de VALUES a la segunda fila del ARRAY MOTOR*)

MOTOR["Tag_1"] := VALUES;

(*Direccionamiento indirecto: asignación de VALUES a la fila especificada
con "Tag_1" del ARRAY MOTOR*)

#MOTOR["Tag_2"+"Tag_3"] := #Values;

(*Direccionamiento indirecto: asignación de VALUES a la fila especificada
con la expresión "Tag_2"+"Tag_3" del
ARRAY MOTOR*)

Consulte también
Direccionar componentes de ARRAY (Página 299)

Direccionamiento indirecto en AWL
Fundamentos de registros de direcciones
Introducción
Para direccionar operandos de forma indirecta existen dos registros de direcciones, el registro
de direcciones 1 (AR1) y el registro de direcciones 2 (AR2). Los registros de direcciones son
equivalentes y tienen una longitud de 32 bits. En los registros de direcciones pueden guardarse
punteros intraárea y punteros interárea. Los datos guardados pueden llamarse en el programa
para determinar la dirección de un operando.
El intercambio de datos entre los registros y las demás áreas de memoria disponibles se
realiza con ayuda de instrucciones de carga y transferencia.

140

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.4 Utilizar y direccionar operandos

Consulte también
LAR1: Cargar contenido del acumulador 1 en AR1 (Página 5440)
LAR1 <D>: Cargar palabra doble o puntero de área en AR1 (Página 5441)
LAR1 AR2: Cargar contenido del AR2 en AR1 (Página 5443)
LAR2: Cargar contenido del acumulador 1 en AR2 (Página 5443)
CAR: Intercambiar AR1 y AR2 (Página 5449)
TAR1: Transferir AR1 a acumulador 1 (Página 5449)
TAR1 <D>: Transferir AR1 a palabra doble (Página 5450)
TAR1 AR2: Transferir AR1 a AR2 (Página 5451)
TAR2: Transferir AR2 a acumulador 1 (Página 5452)
+AR1: Sumar acumulador 1 a AR1 (Página 5540)
+AR2: Sumar acumulador 1 a AR2 (Página 5541)
Direccionamiento indirecto en AWL (Página 141)
Intercambio de datos en AWL (Página 8065)
Carga y transferencia (Página 1655)

Direccionamiento indirecto en AWL
En AWL existen las siguientes posibilidades de direccionamiento indirecto:
● Direccionamiento indirecto por memoria
● Direccionamiento intraárea indirecto por registro
● Direccionamiento indirecto interárea por registro

Direccionamiento indirecto por memoria
En el direccionamiento indirecto por memoria se deposita la dirección en una variable. Esta
variable puede ser del tipo de datos WORD o DWORD. La variable puede encontrarse en las
áreas de memoria "Datos" (DB o DI), "Marcas" (M) o "Datos locales temporales" (L).
Ejemplo de aplicaciones del direccionamiento indirecto por memoria:
Direccionamiento en AWL

Significado

U E [MD 2]

// Ejecuta una operación lógica Y con un bit de entrada
variable. La dirección del bit de entrada se encuentra
en la palabra doble de marcas MD2.

= DIX [DBD 2]

// Asigna el RLO a un bit de datos variable. La dirección del bit de datos se encuentra en la palabra doble
de datos DBD2.

L EB [DID 4]

// Carga un byte de entrada variable en ACU 1. La dirección del byte de entrada se encuentra en la palabra doble de instancia DID4.

Programación del PLC
Manual de programación y manejo, 11/2019

141

Principios básicos de la programación
1.4 Utilizar y direccionar operandos
Direccionamiento en AWL

Significado

AUF DB [LW 2]

// Abre un bloque de datos variable. El número del bloque de datos se encuentra en la palabra de datos locales
LW2.

Direccionamiento intraárea indirecto por registro
El direccionamiento indirecto por registro utiliza uno de los registros de direcciones (AR1 o
AR2) para obtener la dirección del operando.
En el direccionamiento intraárea indirecto por registro solo se indexan la dirección de bit y la
dirección de byte mediante el registro de direcciones (p. ej. P#10.0). El área de memoria para
el que será válida la dirección del registro de direcciones no se indica hasta realizar que no se
programa la instrucción. De este modo, la dirección del registro de direcciones actuará en el
área de memoria que se especifique en la instrucción.
Las áreas de memoria posibles son "Entradas" (I), "Salidas" (Q), "Periferia" (PI o PQ), "Marcas"
(M), "Datos locales temporales" (L) y "Datos" (DB o DI).
Al introducir el direccionamiento intraárea indirecto por registro, después de indicar el registro
de direcciones se especifica un offset que se añade al contenido del registro de direcciones sin
modificarlo. Dicho offset también tiene el formato de un puntero. Es obligatorio indicar el
puntero, lo cual debe realizarse como constante (p. ej. P#0.0 o P#2.0).
Ejemplo de aplicación del direccionamiento indirecto intraárea por registro:
AWL

Significado

LAR1 P#10.0

// Cargar el puntero (P#10.0) en el registro de direcciones 1

L IW [AR1, P#2.0]

// Aumentar el contenido del registro de direcciones 1
(P#10.0) con el offset P#2.0.
// Cargar el contenido de la palabra de entrada IW12 en el
acumulador 1

L IW [AR1, P#0.0]

// Aumentar el contenido del registro de direcciones 1
(P#10.0) con el offset P#0.0.
// Cargar el contenido de la palabra de entrada IW10 en el
acumulador 1

Direccionamiento indirecto interárea por registro
En el direccionamiento interárea indirecto por registro se indexa la dirección completa del
operando (es decir, tanto las direcciones de bit y byte como el área de memoria) mediante el
registro de direcciones. Las áreas de memoria posibles son "Entradas" (I), "Salidas" (Q),
"Periferia" (PI), "Marcas" (M), "Datos locales temporales" (L) y "Datos" (DB o DI). En la
instrucción únicamente se programa el ancho del operando. Los anchos del operando posibles
son bit, byte, palabra y palabra doble.

142

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.5 Señalización de estructuras para el intercambio de datos
Ejemplo de aplicación del direccionamiento interárea indirecto por registro:

LAR1 P#M10.0

// Cargar el puntero interárea (P#M10.0) en el registro de direcciones 1

L W [AR1, P#2.0]

// Aumentar el contenido del registro de direcciones 1
(P#M10.0) con el offset P#2.0.
// Cargar el contenido de la palabra de marca MW12 en el acumulador 1

LAR1 P#A10.0

// Cargar el puntero interárea (P#Q10.0) en el registro de direcciones 1

L W [AR1, P#2.0]

// Sumar el contenido del registro de direcciones 1 (P#Q10.0)
con el offset P#2.0
// Cargar el contenido de la palabra de salida QW12.0 en el
acumulador 1

Consulte también
Fundamentos del direccionamiento indirecto (Página 121)
Direccionamiento indirecto de bloques de datos (Página 137)
Direccionar componentes de ARRAY (Página 299)
Fundamentos de registros de direcciones (Página 140)
Intercambio de datos en AWL (Página 8065)

1.5

Señalización de estructuras para el intercambio de datos

1.5.1

Bytes de relleno cuando se usan tipos de datos estructurados
Si hay que transferir un tipo de datos estructurado con forma y tamaño predeterminados entre
una CPU SIMATIC y un dispositivo de terceros, la transferencia se produce internamente en
el área de memoria estándar.
En SIMATIC, todos los tipos de datos estructurados se disponen en una dirección inicial par
(divisible entre 2). Por ello, la longitud seleccionada en BYTE de un tipo de datos estructurado
debe ser igualmente divisible entre 2.
Si, debido a BYTE precedentes o a la longitud del tipo de datos estructurado, la dirección inicial
del tipo de datos estructurado se desplazara a una dirección impar o si la dirección final se

Programación del PLC
Manual de programación y manejo, 11/2019

143

Principios básicos de la programación
1.5 Señalización de estructuras para el intercambio de datos
desplazara a una dirección par, se inserta automáticamente un byte de relleno en el punto
correspondiente.
Nota
Mostrar bytes de relleno
Los bytes de relleno no son visibles al almacenar los datos (p. ej. en el DB), sino que solo
afectan a la asignación de direcciones (en el área de de memoria estándar).
De ese modo, si en un bloque de datos, por ejemplo, después de tres BYTE individuales hay
un Array con una longitud de siete BYTE, se inserta automáticamente un byte de relleno tanto
antes del Array como después de él. Los primeros tres BYTE estarán, por ejemplo, en las
direcciones "0.0" a "2.0". El Array posterior estará en las direcciones "4.0" a "10.0". Si después
siguiera un BYTE individual, tendría la dirección "12.0".

Sinopsis sobre la aparición de bytes de relleno de tipos de datos estructurados
Los siguientes componentes de TIA Portal están afectados por bytes de relleno:
Tema

Tipos de datos CPU

Almacenamiento
de datos

Bytes de relle‐
no

Struct, tipos
de datos PLC,
Array

Bloques no optimi‐ ● Serialize
zados, bloques op‐
(Página 814),
timizados
Deserialize
(Página 809),

S7-300,
S7-400,
S7-120
0,
S7-150
0

Ejemplos de instruc‐
ciones

● WRREC
(Página 2401),
RDREC
(Página 2382),

Escenarios de ejemplo
● Estructuras con elementos
estructurados
● Periferia (juegos de datos
específicos de fabricante)
● Estructuras del área de
direcciones de la periferia
● Comunicación con periferia
de otros fabricantes

● TSEND_C
● Uso de hardware con Linux
(Página 3984),
● Drivers de un dispositivo
TRCV_C
(Página 3999), PUT
(Página 3953), GET
(Página 3947)

144

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Ejemplo de problema
Para la transmisión como juego de datos a un dispositivo de terceros se ha creado la siguiente
estructura anidada como tipo de datos PLC "typeHARTrequest". (Véase el cuadro verde.)

Problema: El tipo de datos PLC "typeHARTrequest" tiene oficialmente una longitud de 11
BYTE. Debido a varias longitudes impares en BYTE se insertan bytes de relleno (Padding
Byte) dentro del tipo de datos PLC. (Véanse las marcas rojas.) Incluyendo todos los bytes de
relleno, al intercambiar los datos, el tipo de datos PLC tiene una longitud de 14 BYTE. Por ello,
al producirse el intercambio de datos, las áreas de direcciones afectadas de la CPU SIMATIC
no coincidirán con las del dispositivo de terceros.
Solución: Cambie el Array marcado en azul a cinco BYTE individuales. El nuevo tipo de datos
PLC "typeHARTrequest" tendrá entonces (incluido el byte de relleno final) una longitud de 12
BYTE.

1.6

Tratamiento de errores de ejecución del programa

1.6.1

Causas de error

Introducción
En el TIA Portal existen diferentes causas para distintas calidades de error, ante las que se
puede reaccionar con diferentes mecanismos. Los mecanismos disponibles para reaccionar
ante errores son independientes del lenguaje de programación utilizado. Lo único que
depende del lenguaje de programación es la representación de los distintos mecanismos.

Programación del PLC
Manual de programación y manejo, 11/2019

145

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
Aquello que se considera error varía en función de la situación. Así, por ejemplo, un
desbordamiento en una suma puede ser un error, ya que no se entrega el resultado esperado.
Sin embargo, en algunos casos el desbordamiento en la suma puede ser un comportamiento
aceptable y definido y, por lo tanto, no es un error.
Al crear el código del programa hay que ser, asimismo, consciente de que pueden producirse
determinadas situaciones. Si se programa, por ejemplo, una comunicación, la conexión se
puede interrumpir en cualquier momento. Para estar preparado para esta situación hay que
integrar una reacción a error, ya que la interrupción de la conexión impide al bloque de
programa T_SEND enviar un mensaje. Por ello es importante que la interrupción se notifique,
para poder reconocer que no es posible enviar un mensaje. Dado que la instrucción T_SEND
no puede impedir la interrupción de la conexión, para T_SEND la notificación de error es un
comportamiento correcto. La inobservancia de esta notificación puede considerarse un error
del autor del programa.
En adelante se utilizará siempre el término "error" aunque se trate del comportamiento definido.

Diferentes causas de un error
Las causas de un error pueden diferenciarse del siguiente modo:
Valores de parámetros
inadecuados

Programación inadecua‐
da

Fallo de recursos

Descripción

Errores que se tratan di‐
rectamente en la instruc‐
ción.

Errores de programación
o acceso, que en tiempo
de ejecución hacen que
se cancele la ejecución
de una instrucción.

Errores que son tratados
por el sistema operativo y
para los que se puede
programar una reacción
en el código del progra‐
ma.

Calidad del error

Error tratado

Error síncrono

Error asíncrono

Ejemplo

Rebase en una instruc‐
ción aritmética

Programación inadecua‐
da:

Aparición de un evento
determinado fuera del có‐
digo del programa.

● Consulta de una
entrada de periferia
no existente
● Al acceder a un
ARRAY con índice
variable, el valor del
índice se encuentra
fuera de los límites de
ARRAY válidos

146

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Reacción del pro‐
grama o del siste‐
ma operativo

Valores de parámetros
inadecuados

Programación inadecua‐
da

Fallo de recursos

Las instrucciones combi‐
nadas lógicamente con la
salida de habilitación
ENO no se ejecutan.

Si no se ha programado
1. Si el evento no tiene
ningún OB de error, el sis‐
asignado ningún
tema operativo reacciona‐
bloque de
rá en función de la CPU.
organización (OB),
cuando se produzca
el evento el sistema
operativo ejecutará la
reacción de sistema
preajustada.
2. Si el evento tiene
asignado un bloque
de organización (OB),
se llamará dicho
bloque.

Programación del PLC
Manual de programación y manejo, 11/2019

147

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
Valores de parámetros
inadecuados
Mecanismos para
el tratamiento de
errores en el pro‐
grama

Programación inadecua‐
da

Para ello existen diferen‐ Tratamiento global de
tes posibilidades de trata‐ errores 1):
miento local de errores 2) ● OB de error de
según instrucción:
ejecución del
● Mecanismo EN/ENO
programa
● Los parámetros de
● OB de error de
salida:
programación
–

RET_VAL

–

STATUS

–

ERROR

● OB de error de
acceso a la periferia

Fallo de recursos
Bloques de organización
(OB) de error:
● Error de tiempo (OB
80)
● Alarma de
diagnóstico (OB 82)
● Alarma de presencia
de módulo (OB 83)

● Error de rack (OB 86)
Tratamiento local de erro‐ Posibles reacciones del
res 2) con las instruccio‐
sistema sin OB de error
nes:
asignado:
● GET_ERROR
● El sistema operativo
● GET_ERR_ID

ignora el evento.

● La CPU cambia al
estado operativo
STOP.
● Si es posible se aplica
un tratamiento local
de errores.
Si hay un OB de error
asignado, este se llama
cuando se produce el
evento correspondiente.
Encontrará un ejemplo de
aplicación del diagnósti‐
co en el programa de
usuario en el Con evalua‐
ción de los errores en los
OB de error (https://
support.industry.siemens
.com/cs/document/
98210758?lc=es-WW)
1)

El tratamiento global de errores se realiza con bloques de organización.

2)

El tratamiento local de errores se programa dentro del código del programa.

Nota
Tratamiento asíncrono de errores
En las CPU de la serie S7-1500 los OB de error se llaman de forma asíncrona. Por ello es
posible que los OB de error de acceso a periferia o de programación no se ejecuten
inmediatamente al producirse el error, sino con retardo en función de la prioridad ajustada. Si
se producen más errores antes de que se haya terminado de ejecutar el OB de error de acceso
a la periferia o de programación, no se llamará ningún otro OB de dichos tipos. Para impedir
que se rechacen los OB de error de acceso a periferia o de programación, ajuste una prioridad
suficientemente alta.

148

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Consulte también
Ejemplo de tratamiento de errores de ejecución del programa (Página 180)

1.6.2

Sinopsis de los mecanismos para el tratamiento de errores

Sinopsis
Existen diferentes mecanismos para interceptar posibles errores de parámetros, de
programación o de acceso:
Mecanismo

Tarea

Entrada de habilitación EN o instruc‐ Impedimento de la ejecución de un
ción IF
código del programa
Salida de habilitación ENO o bit BR

Tratamiento de errores
Local

Indicación de un error

Salidas de parámetro RET_VAL,
STATUS y ERROR
Instrucciones GET_ERROR y
GET_ERR_ID

Reacción a un error

Bloques de organización

Global

Tratamiento local de errores en caso de valores de parámetros inadecuados
El tratamiento local de errores no solo permite reaccionar cuando se ha producido un error,
sino que además permite establecer una reacción concreta dentro del código del programa. El
tratamiento local de errores se programa directamente en un bloque de programa (OB, FB o
FC). Solo trata errores que se producen dentro de bloque de programa concreto.
Ventajas del tratamiento local de errores:
● La información de error permite programar en el bloque de programa una reacción al error
ocurrido.
● Las evaluaciones y reacciones a errores programadas no interrumpen el ciclo del programa.
● El tratamiento local de errores no supone una carga innecesaria para el rendimiento del
sistema. Si no se producen errores, no se ejecutan las evaluaciones y reacciones
programadas.

Programación del PLC
Manual de programación y manejo, 11/2019

149

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
Existen las siguientes posibilidades de tratamiento local de errores:
Tipo de tratamiento de errores

Validez

Significado

Mecanismo EN/ENO

S7-300 /
S7-400 /
S7-1200 /
S7-1500

La salida de habilitación ENO permite detectar y tratar errores de‐
terminados en tiempo de ejecución. La ejecución de las siguientes
instrucciones varía en función del estado lógico de la salida de
habilitación. Con el uso del mecanismo EN/ENO se evitan interrup‐
ciones del programa. El estado del bloque se transmite en forma de
variable booleana.

1)

Encontrará más información sobre el mecanismo EN/ENO aquí:
Principios básicos del mecanismo EN/ENO (Página 152)
Parámetros de salida STATUS y
ERROR

S7-300 /
S7-400 /
S7-1200 /
S7-1500

Con los parámetros STATUS y ERROR como valores de retorno de
bloques de función del sistema (SFB) se puede consultar informa‐
ción de error específica de bloque. La información de error se de‐
vuelve en una estructura predeterminada.
Encontrará más información sobre los parámetros de salida en las
descripciones de las diferentes instrucciones que encontrará en el
sistema de información.

Parámetro de salida RET_VAL

S7-300 /
S7-400 /
S7-1200 /
S7-1500

El parámetro de salida RET_VAL, como valor de retorno de funcio‐
nes de sistema (SFC), permite visualizar códigos de error genera‐
les o específicos. Los códigos de error generales hacen referencia
a cualquier instrucción y los códigos de error específicos se refieren
únicamente a una instrucción concreta. Puede devolverse como
máximo una variable del tipo de datos INT o WORD.
Encontrará más información sobre el parámetro de salida
RET_VAL aquí:
Evaluación de errores con el parámetro de salida RET_VAL (Pági‐
na 174)

1)
Si no se produce ningún error de acceso a la memoria debido a los parámetros de una instrucción, la salida de habilitación
ENO correspondiente proporciona el estado lógico "1" y las salidas proporcionan valores válidos, que pueden consultarse.

Tratamiento global y local de errores en caso de programación inadecuada
El tratamiento global y local de errores permite reaccionar de forma inmediata a un error
ocurrido, sin que la CPU cambie al estado operativo STOP. Para el tratamiento de errores de
programación y acceso existen las siguientes posibilidades:
Tipo de tratamiento global de errores Validez

Significado

OB de error de ejecución del progra‐ S7-300 /
ma (OB 85)
S7-400

Si no se utiliza el OB 85, en cuanto se produce un error de ejecución
del programa la CPU cambia del estado operativo RUN a STOP y
escribe una entrada en el búfer de diagnóstico.
Encontrará más información sobre el OB 85 aquí:
AUTOHOTSPOT

Tratamiento de errores interno de la
CPU para errores de programación y
de acceso

150

S7-1200

Sin necesidad de programación adicional, en caso de error la CPU
genera una entrada en el búfer de diagnóstico y permanece en es‐
tado operativo RUN.

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
Tipo de tratamiento global de errores Validez

Significado

OB de error de programación (OB
121)

Si no se utiliza el OB 121, en cuanto se produce un error de progra‐
mación la CPU cambia del estado operativo RUN a STOP y escribe
una entrada en el búfer de diagnóstico.

S7-300/
S7-400 /
S7-1500

Encontrará más información sobre el OB 121 aquí:
S7-300 / S7-400:
AUTOHOTSPOT
S7-1500:
AUTOHOTSPOT
OB de error de acceso a la periferia
(OB 122)

S7-300/
S7-400 /
S7-1500

S7-300 / S7-400:
Si no se utiliza el OB 122, en cuanto se produce un error de acceso
la CPU cambia del estado operativo RUN a STOP.
AUTOHOTSPOT
S7-1500:
En caso de error de acceso a la periferia, la CPU siempre perma‐
nece en estado operativo RUN y escribe una entrada en el búfer de
diagnóstico, incluso si no se utiliza el OB 122.
Encontrará más información sobre el OB 122 aquí:
AUTOHOTSPOT

Encontrará más información sobre la estructura del búfer de diagnóstico aquí: AUTOHOTSPOT

El tratamiento local de errores con las instrucciones "GET_ERROR" y "GET_ERR_ID" se
puede integrar directamente en el código del programa. Además existe la posibilidad de
obtener información detallada sobre el error y evaluarlo con más detalle en el programa en las
inmediaciones del error. El tratamiento local de errores se programa directamente en un
bloque de programa (OB, FB o FC). Solo trata errores que se producen dentro de bloque de
programa concreto.
Tipo de tratamiento local de errores

Validez

Significado

Instrucciones GET_ERROR y
GET_ERR_ID

S7-1200 /
S7-1500

Estas instrucciones permiten obtener una ID de error o información
detallada sobre un error, además de programar una reacción directa
en el código del programa.
Cuando se consulta la información acerca del primer error ocurrido,
se libera el espacio ocupado por el error en la memoria de sistema.
Si posteriormente ocurren más errores, se muestra la información
acerca del siguiente error ocurrido.
Encontrará más información sobre las instrucciones GET_ERROR y
GET_ERR_ID y una sinopsis de la priorización de los errores ocu‐
rridos aquí:
Uso de las instrucciones GET_ERROR y GET_ERR_ID (Página 178)

Si se aplica el tratamiento local de errores y consulta con la instrucción GET_ERROR, las
reacciones preajustadas son las siguientes:
● En caso de error de escritura: el error se ignora y la ejecución del programa prosigue sin
más.
● En caso de error de lectura: en las instrucciones aritméticas la ejecución del programa
continúa con el valor sustitutivo "0".
● En caso de error de ejecución: la ejecución de la instrucción se cancela y el programa se
continúa ejecutando con la siguiente instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

151

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
Ventajas del tratamiento local de errores:
● En la memoria de sistema se almacena información de error, que se puede consultar y
evaluar (p. ej. con las instrucciones GET_ERROR y GET_ERR_ID).
● La información de error permite programar en el bloque de programa una reacción al error
ocurrido.
● Las evaluaciones y reacciones a errores programadas no interrumpen el ciclo del programa.
● El tratamiento local de errores supone una carga menor para el rendimiento del sistema que
el tratamiento global. Si no se producen errores, no se ejecutan las evaluaciones y
reacciones programadas.
● Si se ha programado un tratamiento local de errores para un bloque de programa, no se
realizará un tratamiento global en caso de error.
Nota
Para evitar que la CPU pase al estado operativo STOP al producirse un error, todos los errores
de programación y acceso a la periferia deben ser interceptados mediante un tratamiento
global o local.

Ejemplo
Encontrará un ejemplo exhaustivo del tratamiento local de errores con varias de las
posibilidades citadas anteriormente, aquí: Ejemplo de tratamiento de errores de ejecución del
programa (Página 180)

Consulte también
Mecanismo EN/ENO (Página 152)

1.6.3

Mecanismo EN/ENO

1.6.3.1

Principios básicos del mecanismo EN/ENO

Introducción
La salida de habilitación ENO permite detectar y tratar determinados errores en tiempo de
ejecución. La ejecución de las siguientes instrucciones varía en función del estado lógico de la
salida de habilitación. Utilizando el mecanismo EN/ENO se evitan interrupciones del
programa. El estado del bloque se transfiere en forma de variable booleana.

152

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
El mecanismo EN/ENO puede usarse en dos niveles:
● Para instrucciones individuales (ENO de instrucción)

● En llamadas de bloque de programa (ENO de bloque)

En KOP y FUP el mecanismo EN/ENO ya está disponible en la llamada de las instrucciones
simples y avanzadas en los cuadros de código del programa.
El mecanismo EN/ENO permite influir en la llamada de las siguientes instrucciones y
configurar individualmente el salto desde un bloque de programa con la instrucción "RET:
Retroceder". Para ello también es posible asignar un valor individual (0 o 1) a la salida de
habilitación ENO del bloque de programa. Este comportamiento se aplica generalmente en
bloques de programa KOP y FUP. En bloques de programa SCL también puede procederse
del mismo modo. Pero no es necesario utilizar la instrucción "RET" para influir en la salida de
habilitación ENO del bloque de programa SCL.
En los límites del segmento la salida de habilitación ENO se ajusta una y otra vez al estado
lógico "1". En un bloque de programa KOP eso puede reconocerse p. ej. por el hecho de que
la barra de alimentación izquierda siempre proporciona tensión aunque la salida de
habilitación ENO de la última instrucción del segmento anterior devuelve el estado lógico "0".

Función de la instrucción "RET: Retroceder" (KOP/FUP)
Con RLO = 0 la instrucción no se ejecuta y se procesa el siguiente segmento.
Con RLO = 1 la instrucción se ejecuta y se produce un salto de retroceso al bloque de programa
llamante.
El estado lógico de la ENO del bloque puede determinarse de cuatro formas diferentes:
● RLO: el RLO = 1 se aplica, es decir, que la ENO del bloque adopta el estado TRUE.
● TRUE: la ENO del bloque adopta el estado TRUE.
● FALSE: la ENO del bloque adopta el estado FALSE.
● Operando: el estado lógico del operando indicado determina cómo será la ENO del bloque.

Programación del PLC
Manual de programación y manejo, 11/2019

153

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Errores de programación y de acceso a periferia
No es posible evaluar errores de programación y acceso a la periferia por medio del
mecanismo EN/ENO. Utilice para ello el tratamiento global de errores mediante OB o el
tratamiento local de errores mediante las instrucciones "GET_ERROR" o "GET_ERR_ID" (solo
CPU S7-1200/1500). Si en una instrucción no se ha producido ninguno de los errores, se
puede evaluar la correspondiente salida de habilitación ENO.

Llamadas de bloques de programa en todos los lenguajes de programación (S7-300/400)
En las CPU de las series S7-300/400: si se llaman bloques de programa que no contienen
instrucciones no se ven afectados ni el bit BR ni la salida de habilitación ENO. De este modo
el estado lógico del bit BR permanece constante. No se puede llegar a una conclusión definitiva
sobre éxito de la llamada del bloque de programa.

1.6.3.2

Mecanismo EN/ENO en KOP

Sinopsis del mecanismo EN/ENO en KOP
Para aumentar el rendimiento, en las instrucciones el mecanismo EN/ENO está desactivado
por defecto. Puede volver a activarse en cualquier momento para instrucciones individuales.
Encontrará más información sobre la activación y desactivación del mecanismo EN/ENO
aquí: Activar y desactivar el mecanismo EN/ENO en KOP y FUP (Página 155)
En los bloques de programa KOP/FUP el mecanismo EN/ENO solo funciona con una salida de
habilitación ENO en las instrucciones correspondientes.

Mecanismo EN/ENO en una instrucción
Con la entrada de habilitación EN pueden establecerse condiciones para la ejecución de una
instrucción. La instrucción se ejecuta solo si el estado lógico de la entrada de habilitación EN
es "1".
Con la salida de habilitación ENO pueden consultarse errores en tiempo de ejecución en una
instrucción y reaccionar a ellos:
● La salida de habilitación ENO devuelve el estado lógico "1" cuando no se produce ningún
error durante la ejecución.
● La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
– La entrada de habilitación EN devuelve el estado lógico "0".
– Se ha producido un error durante la ejecución.

154

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Mecanismo EN/ENO en llamadas de bloques de programa
A todas las llamadas de bloques de programa se les asigna una entrada de habilitación EN y
una salida de habilitación ENO. Esto vale para todos los bloques de programa llamantes,
independientemente del lenguaje de programación en el que se haya creado el bloque de
programa llamado. Eso significa que al llamar un bloque de programa AWL o SCL en el que no
haya ningún mecanismo EN/ENO predeterminado y preprogramado, en KOP o FUP la
llamada sí tendrá un mecanismo EN/ENO.
La entrada de habilitación EN se puede utilizar para llamar un bloque de programa en función
de determinadas condiciones. El bloque de programa se ejecuta solo si el estado lógico de la
entrada de habilitación EN es "1".
Con la salida de habilitación ENO puede consultarse el estado de error del bloque de programa:
● La salida de habilitación ENO devuelve el estado lógico "1" en cuanto se ha completado
correctamente la ejecución del bloque.
● Si en caso de error en el bloque de programa llamado la salida de habilitación ENO no se
pone explícitamente al estado lógico "0", conservará el estado lógico "1". La instrucción
"RET: Retroceder" permite ajustar la ENO del bloque al estado lógico "0".
Encontrará más información sobre el uso de la instrucción RET aquí: Influir en la ENO de
un bloque de programa KOP/FUP (Página 156)

Activar y desactivar el mecanismo EN/ENO en KOP y FUP
En KOP y FUP, determinadas instrucciones poseen una salida de habilitación ENO (enable
output) y utilizan por consiguiente el mecanismo EN/ENO. Dicho mecanismo permite consultar
errores en tiempo de ejecución en instrucciones y reaccionar a ellos. Para aumentar el
rendimiento de la CPU, el mecanismo EN/ENO está desactivado por defecto. Por
consiguiente, en un principio no existe la posibilidad de reaccionar a errores en tiempo de
ejecución de la instrucción a través del valor ENO. Sin embargo, el mecanismo EN/ENO se
puede activar en cualquier momento si fuera necesario.
El mecanismo EN/ENO se puede activar individualmente para cada instrucción con el fin de
generar el ENO. Si se activa el mecanismo EN/ENO para una instrucción, el resto de
instrucciones que se arrastren al programa posteriormente se insertarán con el mecanismo EN/
ENO también activado. Si no desea utilizar la evaluación de ENO para una instrucción, el
mecanismo EN/ENO puede volver a desactivarse en cualquier momento. Cualquier otra
instrucción que se arrastre al programa posteriormente se insertará sin el mecanismo EN/ENO.
Si la salida de habilitación ENO está activada, los errores en tiempo de ejecución no provocan
un STOP de la CPU.

Activar el mecanismo EN/ENO
Para activar el mecanismo EN/ENO de una instrucción, proceda del siguiente modo:
1. Haga clic con el botón derecho del ratón en el programa sobre la instrucción para la que
desea activar el mecanismo EN/ENO.
2. Elija el comando "Generar ENO" del menú contextual.
Para esa instrucción se vuelve a generar el valor ENO. Cualquier otra instrucción adicional
se insertará entonces con la salida de habilitación activada.

Programación del PLC
Manual de programación y manejo, 11/2019

155

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Desactivar el mecanismo EN/ENO
Para desactivar el mecanismo EN/ENO de una instrucción, proceda del siguiente modo:
1. Haga clic con el botón derecho del ratón en el programa sobre la instrucción para la que
desea desactivar el mecanismo EN/ENO.
2. Elija el comando "No generar ENO" del menú contextual.
Para esa instrucción ya no se generará más el valor ENO. Cualquier otra instrucción
adicional se insertará entonces sin la salida de habilitación activada.

Consulte también
Principios básicos del mecanismo EN/ENO (Página 152)

Influir en la ENO de un bloque de programa KOP/FUP
Descripción
La instrucción "RET: Retroceder" permite saltar desde un bloque de programa e influir con ello
en el estado lógico de la ENO del bloque.

Procedimiento
Para influir en el estado lógico de la ENO del bloque, proceda del siguiente modo:
1. Active el mecanismo EN/ENO de una instrucción (p. ej. de la suma "ADD").
2. A continuación programe la instrucción "RET: Retroceder" con estado lógico FALSE en la
salida de habilitación ENO con una negación.

Resultado
De ese modo, en caso de error (p. ej. un desbordamiento en el resultado) primero se devuelve
el estado lógico "0" en la salida de habilitación ENO. Con ayuda de la negación, el estado
lógico "0" pasa al estado lógico "1", con lo que se consigue el RLO = 1 para ejecutar la
instrucción "RET", que devuelve el valor FALSE. De ese modo la ENO del bloque de programa
es FALSE y se regresa desde el bloque de programa a la instrucción que sigue a la llamada del
bloque de programa anterior. Este procedimiento puede programarse en todos los segmentos
(p. ej. con varias funciones matemáticas, etc.).
Sin embargo, no hay por qué programar necesariamente un salto desde el bloque de
programa. Dentro de un segmento también puede utilizarse el estado lógico "0" de la salida de

156

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
habilitación ENO de una única instrucción para que la instrucción siguiente no se ejecute. La
ENO del bloque no se ve afectada por ello.
Nota
Efectos sobre la ENO del bloque
Solo es posible influir en el estado lógico de la ENO del bloque saltando desde el bloque de
programa.
Aunque la salida de habilitación ENO de la última instrucción del último segmento de un bloque
de programa tenga el estado lógico "0", la ENO del bloque no se verá afectada.

Ejemplo del mecanismo EN/ENO en KOP
Ejemplo de una instrucción con el mecanismo EN/ENO
El siguiente ejemplo muestra la instrucción "Sumar" con conexión EN/ENO y una bobina RET
(Ret False):
'%B$''

ಯ7DJ(QDEOHಯ

$''
,17
(1

ಯ7DJ9DOXHಯ

,1

ಯ7DJ9DOXHಯ

,1

(12

287

127

)$/6(
5(7

ಯ7DJ5HVXOWಯ

Después del contacto normalmente abierto "TagEnable", la entrada de habilitación EN
contiene el resultado de la operación lógica precedente:
● Si el operando "TagEnable" devuelve el estado lógico "0", no se ejecuta la instrucción
"Sumar". La salida de habilitación ENO adopta el estado lógico "0" y se sale del bloque de
programa llamado. La salida de habilitación ENO del bloque de programa invocante adopta
entonces también el estado lógico "0".
● Si el operando "TagEnable" devuelve el estado lógico "1", la entrada de habilitación EN
tiene el estado lógico "1" y se ejecuta la instrucción "Sumar". La instrucción suma dos
valores del tipo de datos INT. Si el resultado esperado está fuera del rango de valores de
INT (16 bits: de -32768 a +32767), la instrucción devolverá igualmente un resultado, pero
este estará dentro del rango de valores de INT. Eso se debe a que el 16.º bit de INT es el
bit de signo. El desbordamiento no puede observarse en ese resultado. Por eso, para una
suma rige => ENO := NOT(OV). Si durante la ejecución del bloque de programa se produce
un error, la salida de habilitación ENO adopta el estado lógico "0" y se sale del bloque de
programa llamado. La salida de habilitación ENO del bloque de programa invocante adopta
entonces también el estado lógico "0".
● Si el operando "TagEnable" devuelve el estado lógico "1", la entrada de habilitación EN
tiene el estado lógico "1" y se ejecuta la instrucción "Sumar". Si no se producen errores al
ejecutar la instrucción, la salida de habilitación ENO devuelve también el estado lógico "1"
y la salida "TagResult" devuelve el resultado.

Programación del PLC
Manual de programación y manejo, 11/2019

157

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
Encontrará una descripción detallada de la instrucción "RET: Retroceder" aquí: --(RET):
Retroceder (Página 918)

Ejemplo del efecto de la salida de habilitación ENO
El ejemplo siguiente muestra la forma de utilizar instrucciones con la salida de habilitación
ENO activada y desactivada:

Si se ha activado la salida de habilitación ENO, como en la instrucción SUB, todas las
instrucciones posteriores se crearán también con la salida de habilitación ENO activada. En
ese caso, si se produce un error de aritmética al procesar la instrucción SUB, la instrucción
ADD no se ejecutará.
En la segunda rama de la instrucción DIV la salida de habilitación ENO está desactivada. Si
durante el procesamiento se produce un error en tiempo de ejecución, la instrucción MUL se
ejecutará de todas formas.

Ejemplo de una llamada del bloque de programa con el mecanismo EN/ENO
El ejemplo siguiente muestra la llamada del bloque de programa con conexión EN/ENO:
%ORFNQDPHB'%
ಯ7DJ(QDEOHಯ

%ORFNQDPH
(1

(12

ಯ7DJ(QDEOH2XWಯ

El bloque de programa solo se ejecuta si el operando "TagEnable" tiene el estado lógico "1":
● La salida de habilitación ENO devuelve un estado lógico en función de lo que se haya
programado en el bloque de programa.
● Si el operando "TagEnable" devuelve el estado lógico "0", no se ejecuta la llamada del
bloque de programa. Tanto la entrada de habilitación EN como la salida de habilitación
ENO tienen el estado lógico "0".

Consulte también
Principios básicos del mecanismo EN/ENO (Página 152)

158

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

1.6.3.3

Mecanismo EN/ENO en FUP

Sinopsis del mecanismo EN/ENO en FUP
Para aumentar el rendimiento, en las instrucciones el mecanismo EN/ENO está desactivado
por defecto. Puede volver a activarse en cualquier momento para instrucciones individuales.
Encontrará más información sobre la activación y desactivación del mecanismo EN/ENO
aquí: Activar y desactivar el mecanismo EN/ENO en KOP y FUP (Página 160)
En los bloques de programa KOP/FUP el mecanismo EN/ENO solo funciona con una salida de
habilitación ENO en las instrucciones correspondientes.

Mecanismo EN/ENO en una instrucción
Con la entrada de habilitación EN pueden establecerse condiciones para la ejecución de una
instrucción. La instrucción se ejecuta solo si el estado lógico de la entrada de habilitación EN
es "1".
Con la salida de habilitación ENO pueden consultarse errores en tiempo de ejecución en una
instrucción y reaccionar a ellos:
● La salida de habilitación ENO devuelve el estado lógico "1" cuando no se produce ningún
error durante la ejecución.
● La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
– La entrada de habilitación EN devuelve el estado lógico "0".
– Se ha producido un error durante la ejecución.

Mecanismo EN/ENO en llamadas de bloques de programa
A todas las llamadas de bloques de programa se les asigna una entrada de habilitación EN y
una salida de habilitación ENO. Esto vale para todos los bloques de programa llamantes,
independientemente del lenguaje de programación en el que se haya creado el bloque de
programa llamado. Eso significa que al llamar un bloque de programa AWL o SCL en el que no
haya ningún mecanismo EN/ENO predeterminado y preprogramado, en KOP o FUP la
llamada sí tendrá un mecanismo EN/ENO.
La entrada de habilitación EN se puede utilizar para llamar un bloque de programa en función
de determinadas condiciones. El bloque de programa se ejecuta solo si el estado lógico de la
entrada de habilitación EN es "1".
Con la salida de habilitación ENO puede consultarse el estado de error del bloque de programa:
● La salida de habilitación ENO devuelve el estado lógico "1" en cuanto se ha completado
correctamente la ejecución del bloque.
● Si en caso de error en el bloque de programa llamado la salida de habilitación ENO no se
pone explícitamente al estado lógico "0", conservará el estado lógico "1". La instrucción
"RET: Retroceder" permite ajustar la ENO del bloque al estado lógico "0".
Encontrará más información sobre el uso de la instrucción RET aquí: Influir en la ENO de
un bloque de programa KOP/FUP (Página 160)

Programación del PLC
Manual de programación y manejo, 11/2019

159

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Activar y desactivar el mecanismo EN/ENO en KOP y FUP
En KOP y FUP, determinadas instrucciones poseen una salida de habilitación ENO (enable
output) y utilizan por consiguiente el mecanismo EN/ENO. Dicho mecanismo permite consultar
errores en tiempo de ejecución en instrucciones y reaccionar a ellos. Para aumentar el
rendimiento de la CPU, el mecanismo EN/ENO está desactivado por defecto. Por
consiguiente, en un principio no existe la posibilidad de reaccionar a errores en tiempo de
ejecución de la instrucción a través del valor ENO. Sin embargo, el mecanismo EN/ENO se
puede activar en cualquier momento si fuera necesario.
El mecanismo EN/ENO se puede activar individualmente para cada instrucción con el fin de
generar el ENO. Si se activa el mecanismo EN/ENO para una instrucción, el resto de
instrucciones que se arrastren al programa posteriormente se insertarán con el mecanismo EN/
ENO también activado. Si no desea utilizar la evaluación de ENO para una instrucción, el
mecanismo EN/ENO puede volver a desactivarse en cualquier momento. Cualquier otra
instrucción que se arrastre al programa posteriormente se insertará sin el mecanismo EN/ENO.
Si la salida de habilitación ENO está activada, los errores en tiempo de ejecución no provocan
un STOP de la CPU.

Activar el mecanismo EN/ENO
Para activar el mecanismo EN/ENO de una instrucción, proceda del siguiente modo:
1. Haga clic con el botón derecho del ratón en el programa sobre la instrucción para la que
desea activar el mecanismo EN/ENO.
2. Elija el comando "Generar ENO" del menú contextual.
Para esa instrucción se vuelve a generar el valor ENO. Cualquier otra instrucción adicional
se insertará entonces con la salida de habilitación activada.

Desactivar el mecanismo EN/ENO
Para desactivar el mecanismo EN/ENO de una instrucción, proceda del siguiente modo:
1. Haga clic con el botón derecho del ratón en el programa sobre la instrucción para la que
desea desactivar el mecanismo EN/ENO.
2. Elija el comando "No generar ENO" del menú contextual.
Para esa instrucción ya no se generará más el valor ENO. Cualquier otra instrucción
adicional se insertará entonces sin la salida de habilitación activada.

Consulte también
Principios básicos del mecanismo EN/ENO (Página 152)

Influir en la ENO de un bloque de programa KOP/FUP
Descripción
La instrucción "RET: Retroceder" permite saltar desde un bloque de programa e influir con ello
en el estado lógico de la ENO del bloque.

160

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Procedimiento
Para influir en el estado lógico de la ENO del bloque, proceda del siguiente modo:
1. Active el mecanismo EN/ENO de una instrucción (p. ej. de la suma "ADD").
2. A continuación programe la instrucción "RET: Retroceder" con estado lógico FALSE en la
salida de habilitación ENO con una negación.

Resultado
De ese modo, en caso de error (p. ej. un desbordamiento en el resultado) primero se devuelve
el estado lógico "0" en la salida de habilitación ENO. Con ayuda de la negación, el estado
lógico "0" pasa al estado lógico "1", con lo que se consigue el RLO = 1 para ejecutar la
instrucción "RET", que devuelve el valor FALSE. De ese modo la ENO del bloque de programa
es FALSE y se regresa desde el bloque de programa a la instrucción que sigue a la llamada del
bloque de programa anterior. Este procedimiento puede programarse en todos los segmentos
(p. ej. con varias funciones matemáticas, etc.).
Sin embargo, no hay por qué programar necesariamente un salto desde el bloque de
programa. Dentro de un segmento también puede utilizarse el estado lógico "0" de la salida de
habilitación ENO de una única instrucción para que la instrucción siguiente no se ejecute. La
ENO del bloque no se ve afectada por ello.
Nota
Efectos sobre la ENO del bloque
Solo es posible influir en el estado lógico de la ENO del bloque saltando desde el bloque de
programa.
Aunque la salida de habilitación ENO de la última instrucción del último segmento de un bloque
de programa tenga el estado lógico "0", la ENO del bloque no se verá afectada.

Ejemplo del mecanismo EN/ENO en FUP
Ejemplo de una instrucción con el mecanismo EN/ENO
El siguiente ejemplo muestra la instrucción "Sumar" con conexión EN/ENO y una bobina RET
(Ret False):
$''
,17

ಯ7DJ(QDEOHಯ

(1

ಯ7DJ9DOXHಯ

,1

ಯ7DJ9DOXHಯ

,1

Programación del PLC
Manual de programación y manejo, 11/2019

287

(12

ಯ7DJ5HVXOWಯ
)$/6(
5(7

161

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
Después del contacto normalmente abierto "TagEnable", la entrada de habilitación EN
contiene el resultado de la operación lógica precedente:
● Si el operando "TagEnable" devuelve el estado lógico "0", no se ejecuta la instrucción
"Sumar". La salida de habilitación ENO adopta el estado lógico "0" y se sale del bloque de
programa llamado. La salida de habilitación ENO del bloque de programa invocante adopta
entonces también el estado lógico "0".
● Si el operando "TagEnable" devuelve el estado lógico "1", la entrada de habilitación EN
tiene el estado lógico "1" y se ejecuta la instrucción "Sumar". La instrucción suma dos
valores del tipo de datos INT. Si el resultado esperado está fuera del rango de valores de
INT (16 bits: de -32768 a +32767), la instrucción devolverá igualmente un resultado, pero
este estará dentro del rango de valores de INT. Eso se debe a que el 16.º bit de INT es el
bit de signo. El desbordamiento no puede observarse en ese resultado. Por eso, para una
suma rige => ENO := NOT(OV). Si durante la ejecución del bloque de programa se produce
un error, la salida de habilitación ENO adopta el estado lógico "0" y se sale del bloque de
programa llamado. La salida de habilitación ENO del bloque de programa invocante adopta
entonces también el estado lógico "0".
● Si el operando "TagEnable" devuelve el estado lógico "1", la entrada de habilitación EN
tiene el estado lógico "1" y se ejecuta la instrucción "Sumar". Si no se producen errores al
ejecutar la instrucción, la salida de habilitación ENO devuelve también el estado lógico "1"
y la salida "TagResult" devuelve el resultado.
Encontrará una descripción detallada de la instrucción "RET: Retroceder" aquí: RET:
Retroceder (Página 1293)

162

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Ejemplo del efecto de la salida de habilitación ENO
El ejemplo siguiente muestra la forma de utilizar instrucciones con la salida de habilitación
ENO activada y desactivada:

Si se ha activado la salida de habilitación ENO, como en la instrucción SUB, todas las
instrucciones posteriores se crearán también con la salida de habilitación ENO activada. En
ese caso, si se produce un error de aritmética al procesar la instrucción SUB, la instrucción
ADD no se ejecutará.
En el segundo segmento de la instrucción DIV la salida de habilitación ENO está desactivada.
Si durante el procesamiento se produce un error en tiempo de ejecución, la instrucción MUL se
ejecutará de todas formas.

Ejemplo de una llamada del bloque de programa con el mecanismo EN/ENO
El ejemplo siguiente muestra la llamada del bloque de programa con conexión EN/ENO:
%ORFNQDPHB'%
%ORFNQDPH
ಯ7DJ(QDEOHಯ

(1

Programación del PLC
Manual de programación y manejo, 11/2019

(12

ಯ7DJ(QDEOH2XWಯ

163

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
El bloque de programa solo se ejecuta si el operando "TagEnable" tiene el estado lógico "1":
● La salida de habilitación ENO devuelve un estado lógico en función de lo que se haya
programado en el bloque de programa.
● Si el operando "TagEnable" devuelve el estado lógico "0", no se ejecuta la llamada del
bloque de programa. Tanto la entrada de habilitación EN como la salida de habilitación
ENO tienen el estado lógico "0".

Consulte también
Principios básicos del mecanismo EN/ENO (Página 152)

1.6.3.4

Mecanismo EN/ENO en AWL

Sinopsis del mecanismo EN/ENO en AWL
Mecanismo EN/ENO en una instrucción
El mecanismo EN/ENO no está disponible para instrucciones individuales. Se realiza con
secuencias de instrucciones específicas de cada lenguaje y el uso de la palabra de estado (bit
BR).
Encontrará más información sobre la palabra de estado aquí: Palabra de datos S7-1500
(Página 198)
Encontrará más información aquí: Ejemplo de la emulación del mecanismo EN/ENO en AWL
(Página 165)

Mecanismo EN/ENO en llamadas de bloques de programa
Un bloque de programa que se llama desde un bloque de programa AWL no se dota de los
parámetros EN y ENO. Sin embargo, independientemente del lenguaje de programación en el
que se haya creado el bloque de programa, se puede obtener información de error del bloque
de programa AWL llamante a través del bit BR de la palabra de estado.
El estado de error del bloque de programa llamado puede evaluarse mediante una
combinación lógica del bit BR de la palabra de estado con el resultado de la operación (RLO).
El RLO tiene el estado lógico "1" en cuanto empieza el procesamiento del bloque de programa
llamado. Si el RLO no se vuelve a poner explícitamente a "0" una vez ejecutadas las acciones,
conservará el estado lógico "1". Para pasar información de error al bloque de programa
llamante, hay que poner explícitamente el RLO al estado lógico "0". La información de error se
activa con las instrucciones "SAVE: Guardar RLO en bit BR" y "JNB: Saltar si RLO = 0 y
guardar RLO".
En AWL se dispone del bit BR para la evaluación de errores. En los lenguajes de programación
KOP, FUP y SCL el bit BR se utiliza como base para generar la salida de habilitación ENO.

164

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
El valor "0" del bit BR de la palabra de estado indica que se ha producido un error en la llamada
de un bloque de programa AWL (el bloque de programa llamante es un bloque de programa
AWL).
Procesamiento de la instruc‐
ción por la CPU

Bit BR

Valor de retorno

Signo del entero

Erróneo

0

Menor que "0"

Negativo (bit de signo es "1")

Correcto

1

Mayor o igual a "0"

Positivo (bit de signo es "0")

Encontrará más información sobre el bit BR aquí: Evaluación de errores con el parámetro de
salida RET_VAL (Página 174)

Ejemplo de la emulación del mecanismo EN/ENO en AWL
Ejemplo de una secuencia de programa con el mecanismo EN/ENO
El ejemplo siguiente muestra una sección de programa para sumar valores con el mecanismo
EN/ENO:
AWL

Explicación

A "TagEnable"

// Consultar si el estado lógico del operando "TagEnable" es "1" y combinar el resultado lógicamente con Y con el RLO actual.

JNB MyLABEL

// Evaluación de la entrada de habilitación EN
// Si el RLO es "0", saltar a la etiqueta
"MyLABEL" y guardar el RLO actual en el
bit BR. Las acciones siguientes no se ejecutan.
// Si el RLO es "1", ejecutar las acciones siguientes.

L "Tag_Input_1"

// Cargar el primer sumando.

L "Tag_Input_2"

// Cargar el segundo sumando.

+I

// Sumar valores

T "Tag_Result"

// Transferir la suma al operando "Tag_Result".

AN OV

// Consultar si se ha producido un desbordamiento.

SAVE

// Transferir el estado lógico del RLO al
bit BR.

CLR

/// Poner RLO a "0" y finalizar la cadena
lógica.

MyLABEL: U BR

// Etiqueta "MyLABEL"
// Consultar el bit BR.

= "Tag_Output"

// Asignar el estado lógico del RLO al
operando "Tag_Output".

La consulta del operando "TagEnable" devuelve el resultado de la operación lógica precedente
(RLO). La instrucción "JNB: Saltar si RLO = 0 y guardar RLO" guarda el RLO en el bit BR.

Programación del PLC
Manual de programación y manejo, 11/2019

165

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
Además, la instrucción evalúa el RLO y, en función del estado lógico, ejecuta las acciones
siguientes:
● Si el RLO es "0", la ejecución del programa continúa en la etiqueta "MyLABEL" con la
consulta del bit BR. No se realiza la suma. Se asigna el RLO actual al
operando"Tag_Output".
● Si el RLO es "1", se realiza la suma. Consultando el bit de desbordamiento (OV) se
determina si se ha producido un error en la suma. El resultado de la consulta se guarda en
el bit BR. La instrucción "CLR: Poner RLO a 0" pone de nuevo a "0" el RLO y finaliza la
cadena lógica. Finalmente se consulta el bit BR y se asigna al operando "Tag_Output". El
estado lógico del bit BR y del operando "Tag_Output" indica si la suma se ha efectuado sin
errores.

Ejemplo de una llamada del bloque de programa con el mecanismo EN/ENO
El ejemplo siguiente muestra la llamada del bloque de programa con conexión EN/ENO:
AWL

Explicación

A "TagEnable"

// Consultar si el estado lógico del operando "TagEnable" es "1" y combinar el resultado lógicamente con Y con el RLO actual.

JNB MyLABEL

// Evaluación de la entrada de habilitación EN
// Si el RLO es "0", saltar a la etiqueta
"MyLABEL" y guardar el RLO actual en el
bit BR. Las acciones siguientes no se ejecutan.
// Si el RLO es "1", ejecutar las acciones siguientes.

CALL "Block name", "Block name_DB"

// Llamada del bloque de programa.

MyLABEL: U BR

// Etiqueta "MyLABEL"
// Consultar el bit BR y combinar el resultado lógicamente con Y con el RLO.

= "Tag_Output"

// Asignar el estado lógico del RLO al
operando "Tag_Output".

Consulte también
Principios básicos del mecanismo EN/ENO (Página 152)

166

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

1.6.3.5

Mecanismo EN/ENO en SCL

Sinopsis del mecanismo EN/ENO en SCL
En segmentos SCL existe la posibilidad de influenciar el ENO asignando un valor. Para ello
debe escribirse "ENO:=TRUE" o "ENO:=FALSE" o utilizar una variable del tipo de datos BOOL.
Si se activa la propiedad del bloque "Activar ENO automáticamente", el compilador agrega un
código del programa para calcular el ENO, igual que en los lenguajes de programación KOP
y FUP. Este código del programa adicional incrementa el tiempo de ejecución, por lo que la
propiedad "Activar ENO automáticamente" está desactivada en el ajuste predeterminado.
Encontrará más información al respecto aquí: "Activar y desactivar la propiedad "Activar ENO
automáticamente" en SCL"
En segmentos SCL existe la posibilidad de no asignar ningún valor al parámetro EN de una FC.
Una solución a esta circunstancia consiste en llamar la FC de forma condicional, es decir,
colocarla dentro de una instrucción "IF". Esto significa que la llamada del bloque no se ejecuta
y no se influye en ENO. Este comportamiento es distinto al de los lenguajes de programación
KOP y FUP.
Encontrará más información al respecto aquí: "Influenciar el ENO de un bloque SCL"

Utilizar ENO
El uso de ENO es opcional para instrucciones.
Encontrará más información aquí: Utilizar la salida de habilitación ENO en instrucciones SCL
(Página 168)

Consulte también
Activar y desactivar la propiedad "Activar ENO automáticamente" en SCL (Página 167)
Influenciar el ENO dentro de un bloque (Página 169)
Influenciar el ENO de un bloque SCL (Página 169)

Activar y desactivar la propiedad "Activar ENO automáticamente" en SCL
Descripción
Si la propiedad "Activar ENO automáticamente" está puesta a "TRUE", el valor del ENO del
bloque llamado se reenvía al ENO del bloque que efectúa la llamada.

Activar el mecanismo ENO en las propiedades del bloque
La propiedad "Activar ENO automáticamente" se activa en las propiedades del bloque, del
siguiente modo:
1. Abra la carpeta "Bloques de programa" en el árbol del proyecto.
2. Haga clic con el botón derecho del ratón en el bloque SCL cuyas propiedades desea
mostrar.
Programación del PLC
Manual de programación y manejo, 11/2019

167

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
3. Elija el comando "Propiedades" del menú contextual.
Se abre el cuadro de diálogo de propiedades del bloque.
4. Haga clic en el grupo "Atributos" de la navegación local.
5. Active la propiedad "Activar ENO automáticamente".
6. Confirme sus entradas con "Aceptar".
Resultado: La propiedad "Activar ENO automáticamente" solo está activada para el bloque
seleccionado.

Poner la propiedad "Activar ENO automáticamente" a "TRUE" para todos los bloques de programa
nuevos
La propiedad "Activar ENO automáticamente" se activa del siguiente modo en las propiedades
del programa:
1. Elija el comando "Configuración" del menú "Opciones".
Se abre la ventana "Configuración" en el área de trabajo.
2. Seleccione el grupo "Programación PLC" en la navegación local.
3. Elija el grupo SCL (Structured Control Language)
4. Active la propiedad "Activar ENO automáticamente".
Resultado: La propiedad "Activar ENO automáticamente" está activada para todos los bloques
de programa nuevos.

Utilizar la salida de habilitación ENO en instrucciones SCL
Descripción
En cada instrucción SCL, p. ej. en una función matemática, hay que consultar la salida de
habilitación ENO para poder trabajar con ella.

Procedimiento
Para consultar la salida de habilitación ENO, proceda del siguiente modo:
1. Active el mecanismo EN/ENO.
2. Tras la instrucción SCL consulte la salida de habilitación ENO (p. ej. #MyOutputBool :=
ENO;)
Si hay un error, como . ej. un desbordamiento, la salida de habilitación ENO devuelve el
estado lógico "0". A continuación se puede trabajar con ese estado lógico y programar p. ej.
la instrucción "RETURN", una indicación de error o un valor sustitutivo.
3. Ponga el estado lógico de la salida de habilitación ENO de nuevo a "1" (p. ej. ENO := 1;)
antes de ejecutar la siguiente instrucción.
De ese modo es posible volver a poner el estado lógico "0" con el siguiente error. Si no lo
hace, el estado lógico de la salida de habilitación ENO continuará siendo "0".

168

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Nota
Salto a un bloque SCL
Cuando se salta a un bloque SCL el estado lógico de la salida de habilitación ENO se pone
automáticamente a "1".

Influenciar el ENO de un bloque SCL
Descripción
La última asignación en el tiempo de un ENO dentro de un bloque de programa SCL es el ENO
del bloque. Asimismo, existe la posibilidad de salir del bloque de programa y, al mismo tiempo,
asignar al ENO del bloque el valor "TRUE" o "FALSE" utilizando la instrucción "RETURN".

Procedimiento
El estado lógico del ENO del bloque se influencia del siguiente modo:
1. Active el mecanismo ENO.
2. A continuación programe:
IF #n := 0 THEN
RETURN FALSE;
END_IF;

Resultado
Si la variable local "#n" tiene el valor "0", el sistema regresa al bloque que efectúa la llamada.
El ENO del bloque tiene entonces el valor "FALSE".
No obstante, no es obligatorio programar un RETURN. El compilador SCL reenvía el valor del
ENO actual al ENO del bloque. Por este motivo, la última asignación efectuada en el tiempo del
ENO saldrá del ENO del bloque.

Influenciar el ENO dentro de un bloque
El valor del ENO puede influenciarse mediante la asignación "ENO:=TRUE" o "ENO:=FALSE"
o bien mediante una variable del tipo de datos BOOL. Si se activa la propiedad del bloque
"Activar ENO automáticamente" (TRUE), el ENO también se influenciará al llamar un bloque
o una instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

169

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Ejemplo de uso de ENO en SCL
Ejemplo de ajuste del ENO
El ejemplo siguiente muestra un bloque SCL que, antes de la división, comprueba si el divisor
es 0. En este caso, ENO se pone al valor "FALSE" y la división siguiente no se lleva a cabo. Un
bloque que efectúa la llamada puede valorar el ENO del bloque llamado y decidir si el
programa debe proseguir.

IF #Divisor = 0 THEN
ENO:=false;
RETURN;
END_IF;
#Quotient:=Dividend/Divisor;

Ejemplo de la llamada de un bloque de programa con el mecanismo ENO
El siguiente ejemplo muestra la llamada de un bloque de programa (A), que trata el ENO de un
bloque llamado (B).

"BlockName_DB"( ENO => ENO );
IF ENO = false THEN
RETURN;
END_IF;

El bloque de programa (A) es llamado y procesado. En este proceso, el bloque de programa
llamado (B) reproduce el valor de su ENO. El valor del ENO del bloque llamado (B) se copia en
el ENO del bloque que efectúa la llamada (A). A continuación, este ENO se utiliza en una
instrucción "IF".
Si el bloque llamado (B) devuelve el estado lógico "ENO=FALSE", el bloque que efectúa la
llamada (A) no prosigue con el procesamiento y también devuelve el estado lógico
"ENO=FALSE".

Consulte también
Principios básicos del mecanismo EN/ENO (Página 152)

170

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

1.6.3.6

Mecanismo EN/ENO en GRAPH

Sinopsis del mecanismo EN/ENO en GRAPH
Mecanismo EN/ENO en una instrucción
No tiene acceso a la salida de habilitación ENO de las instrucciones, por lo que no puede influir
en el estado de la salida de habilitación ENO en el bloque de función GRAPH. Sin embargo,
en conversiones, funciones matemáticas o instrucciones KOP/FUP, por ejemplo, existe la
posibilidad de visualizar la salida de habilitación ENO en el estado del programa.

Mecanismo EN/ENO en llamadas de bloques de programa
La entrada de habilitación EN se puede utilizar para llamar un bloque de programa en función
de determinadas condiciones. El bloque de programa se ejecuta solo si el estado lógico de la
entrada de habilitación EN es "1".
Con la salida de habilitación ENO puede consultarse el estado de error del bloque de programa:
● La salida de habilitación ENO devuelve el estado lógico "1" en cuanto el bloque de
programa llamado se ejecuta sin errores.
● La salida de habilitación ENO devuelve el estado lógico "0" si se produce un error al ejecutar
el bloque de programa llamado.
● La salida de habilitación ENO no puede activarse o desactivarse de forma explícita.
● La salida de habilitación ENO no se ve afectada por la ENO de las instrucciones.

Activar y desactivar el mecanismo EN/ENO en GRAPH
Descripción
Al realizar un test con el estado del programa se mostrará el estado de la salida de habilitación
ENO. Dicha salida tiene el valor TRUE si la acción se ha realizado correctamente y FALSE en
caso contrario.
La posibilidad de visualizar el estado de la salida de habilitación ENO está disponible en los
siguientes lugares del bloque de programa GRAPH:
● Instrucciones permanentes anteriores
● Vista de cadena > Acciones
● Instrucciones permanentes posteriores

Programación del PLC
Manual de programación y manejo, 11/2019

171

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Activar el mecanismo EN/ENO en las propiedades del bloque
Para activar el mecanismo EN/ENO en las propiedades del bloque, proceda del siguiente
modo:
1. Abra la carpeta "Bloques de programa" en el árbol del proyecto.
2. Haga clic con el botón derecho del ratón en el bloque GRAPH cuyas propiedades desea
mostrar.
3. Elija el comando "Propiedades" del menú contextual.
Se abre el cuadro de diálogo de propiedades del bloque.
4. Haga clic en el grupo "Atributos" de la navegación local.
5. Active la propiedad "Activar ENO automáticamente".
6. Confirme sus entradas con "Aceptar".
Resultado: El mecanismo EN/ENO solo está activado para el bloque GRAPH seleccionado.

Ejemplo del mecanismo EN/ENO en GRAPH
Ejemplo de un estado de programa con la salida de habilitación ENO
El ejemplo siguiente muestra el estado de programa de la salida de habilitación ENO en la vista
de cadena, debajo de las acciones:

Si se produce un error durante el procesamiento, la salida de habilitación ENO devuelve el
estado lógico FALSE.

Ejemplo de una llamada del bloque de programa
El ejemplo siguiente muestra la llamada del bloque de programa GRAPH en un bloque de
programa KOP con conexión EN/ENO:
*5$3+B)%B'%
*5$3+B)%
ಯ7DJ(QDEOHಯ

(1

IDOVH

2))B64

6B12



IDOVH

,1,7B64

6B025(





172

ಯ7DJ(QDEOH2XWಯ

(12



Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
El bloque de programa solo se ejecuta si el operando "TagEnable" tiene el estado lógico "1":
● Si el operando "TagEnable" devuelve el estado lógico "0", no se procesa el bloque de
programa llamado. Tanto la entrada de habilitación EN como la salida de habilitación ENO
tienen el estado lógico "0".
● Si el operando "TagEnable" devuelve el estado lógico "1", la entrada de habilitación EN
tiene el estado lógico "1" y se ejecuta el bloque de programa llamado. La salida de
habilitación ENO devuelve un estado lógico en función de lo que se haya programado en
el bloque de programa.

Consulte también
Principios básicos del mecanismo EN/ENO (Página 152)

1.6.3.7

Mecanismo EN/ENO en bloques programados en distintos lenguajes

Descripción
El mecanismo EN/ENO se puede emplear también en bloques programados en distintos
lenguajes. Cada lenguaje de programación refleja el estado de error de distinto modo:
● SCL tiene una variable ENO que almacena el estado de error y que puede consultarse. El
acceso directo a esta variable solo es posible en SCL.
● KOP/FUP/AWL no tienen ninguna variable especial para ENO. Sin embargo, en AWL se
puede leer el estado de error en el bit BR y en KOP/FUP puede consultarse en la bobina
RET.
Para leer el estado de error de todo el bloque se aplican las reglas siguientes:
● El último segmento del bloque es un segmento KOP/FUP:
Si no utiliza ninguna bobina RET, el estado de error es TRUE de forma estándar.
● El último segmento del bloque es un segmento AWL:
el bit BR determina el estado de error. El bit BR puede ser procesado por el registro BR en
los segmentos AWL.
● El último segmento del bloque es un segmento SCL:
La variable ENO determina el estado de error del bloque.

Efectos sobre la ENO del bloque
En bloques de programa KOP/FUP con varios segmentos, que a su vez pueden comprender
varios lenguajes de programación (p. ej. KOP, FUP, AWL o SCL), el último segmento es el que
decide el estado lógico de la ENO del bloque.
Si el último segmento ejecutado de un bloque de programa de ese tipo es un segmento KOP
o FUP, el estado lógico de la ENO del bloque no se verá forzosamente afectado. Solo se verá
afectado si en una instrucción en la que el mecanismo EN/ENO esté activado la salida de
habilitación ENO devuelve el estado lógico "0" y se salta del bloque de programa con la
instrucción "RET: Retroceder". Si esa instrucción no se ha programado, la ENO del bloque
devuelve el estado lógico "1". La posible presencia del estado lógico "0" de una ENO de

Programación del PLC
Manual de programación y manejo, 11/2019

173

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
instrucción no afecta a la ENO del bloque, ya que al principio de un segmento siempre adopta
el estado lógico "1".
Eso mismo rige para un segmento KOP o FUP que preceda a otro segmento (KOP, FUP o
SCL). El estado lógico de la ENO del bloque solo se ve afectado por la instrucción "RET:
Retroceder". En cualquier otro caso con la transición al siguiente segmento se restablece el
estado lógico "1" de la ENO de bloque.
Si el último segmento de un bloque de programa mixto es un segmento SCL, la ENO del bloque
siempre se verá afectada por ello.

Consulte también
Principios básicos del mecanismo EN/ENO (Página 152)

1.6.4

Evaluación de errores con el parámetro de salida RET_VAL

Principios básicos de la evaluación de errores en bloques de librería (SFB y SFC)
Junto al parámetro de salida RET_VAL hay disponibles otros dos posibles métodos de
evaluación de errores:
● Con el mecanismo EN/ENO (KOP, FUP y SCL)
Encontrará más información sobre el mecanismo EN/ENO aquí: Principios básicos del
mecanismo EN/ENO (Página 152)
● Con el bit BR (bit de resultado binario) de la palabra de estado (AWL)
● Con el parámetro de salida RET_VAL (return value).
La salida de habilitación ENO solo indica que se ha producido un error. Para saber qué error
se ha producido concretamente, utilice el parámetro de salida RET_VAL. Dicho parámetro le
ayudará a determinar si la CPU ha podido o no ejecutar la instrucción correctamente. En caso
de error también se puede saber porqué no ha sido posible ejecutar la instrucción
correctamente.
En el siguiente capítulo se recoge información detallada sobre ambos métodos de evaluación
de errores RET_VAL y el bit BR.

Recomendación sobre el orden de las evaluaciones de errores
Antes de evaluar los parámetros de salida de la instrucción (p. ej. OUT) siempre deberá
procederse del siguiente modo:
1. Evalúe en primer lugar la salida de habilitación ENO (o el bit BR de la palabra de estado en
AWL).
2. Compruebe después el parámetro de salida RET_VAL.
Si la salida de habilitación ENO o el bit BR indican que la instrucción no se ha ejecutado
correctamente o si en el parámetro de salida RET_VAL figura un código de error general, los
parámetros de salida específicos de la instrucción devolverán un valor no válido.

174

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
Si en el parámetro de salida RET_VAL aparece un error general, ello se indica con el valor "0"
en el bit BR de la palabra de estado. El valor de retorno es del tipo de datos entero (INT). La
relación del valor de retorno con respecto al valor "0" indica si se ha producido un error al
procesar la instrucción.

Códigos de error generales y específicos (RET_VAL)
En los códigos de error del parámetro de salida RET_VAL se distingue entre:
● un código de error general que pueden devolver todas las instrucciones
● un código de error específico que puede devolver una instrucción según sus funciones
específicas.
El tipo de datos del parámetro de salida RET_VAL es un entero (INT). Los códigos de error de
la instrucción están formados por valores hexadecimales. Si evalúa un valor de retorno y lo
compara con los códigos de error indicados en esta documentación, visualice el código de
error en formato hexadecimal.
El programa se puede escribir de manera que reaccione a posibles errores en el
procesamiento de la instrucción. De este modo pueden evitarse errores subsiguientes.
Nota
Error en el suministro de los parámetros de entrada
Si durante la ejecución de una instrucción que contenga el parámetro RET_VAL se producen
errores mientras los parámetros de entrada reciben valores, en el parámetro RET_VAL se
devuelve un código de error no válido y los parámetros de salida de la instrucción no deben
evaluarse.
La figura siguiente ilustra la estructura de un código de error de una función de sistema en
formato hexadecimal:
&µGLJRGHHUURUSHM:


 




[
1¼PHURGHHYHQWRRFODVHGHHUURU\HUURULQGLYLGXDO
6L[ ಫಫVHWUDWDGHXQFµGLJRGHHUURUHVSHF¯ILFRGHXQLQVWUXFFLµQ(OFµGLJRGH
HUURUHVSHF¯ILFRVHHQFXHQWUWDHQODGHVFULSFLµQGHODUHVSHFWLYDLQVWUXFFLµQ
6L[! ಫಫVHWUDWDGHXQFµGLJRGHHUURUJHQHUDOGHXQLQVWUXFFLµQ(QHVWHFDVR
[HVHOQ¼PHURGHOSDU£PHWURGHODLQVWUXFFLµQTXHKDFDXVDGRHOHUURU/RV
FµGLJRVGHHUURUJHQHUDOHVSRVLEOHVVHLQGLFDQHQODWDEODVLJXLHQWH
%LWGHVLJQR ,QGLFDTXHVHKDSURGXFLGRXQHUURU

Programación del PLC
Manual de programación y manejo, 11/2019

175

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
Dado que el parámetro de salida RET_VAL es del tipo INT, es fácil saber si se ha producido un
error:
● Si el valor es <0, se trata de un error.
● Si el valor es =0, significa que no se ha producido ningún error.
● Si el valor es mayor que 0, significa que no se ha producido ningún error, pero la instrucción
aún no se ha ejecutado correctamente. Esto se utiliza p. ej. con instrucciones asíncronas
para mostrar que la ejecución de la instrucción ha comenzado, pero aún no se ha
completado. Consulte al respecto los valores de retorno de T_SEND o WRIT_DBL.

Códigos de error generales
El código de error general indica errores que pueden aparecer en todas las instrucciones. Un
código de error general está formado por los siguientes dos números:
● Un número de parámetro comprendido entre 1 y 111, donde 1 muestra el primer parámetro,
2 el segundo parámetro etc. de la instrucción llamada.
● Un número de evento comprendido entre 0 y 127. El número de evento indica un error.
La figura siguiente muestra la estructura de un código de error general:
%LWV




 
1¼PHURGHOSDU£PHWUR


1¼PHURGHOHYHQWR

6LJQR

Nota
Reacción a un código de error general
Si se ha registrado un código de error general en el parámetro de salida RET_VAL, podría
haber pasado lo siguiente:
● La acción correspondiente a la instrucción se ha iniciado o ya se ha ejecutado por completo.
● Se ha producido un error específico de la instrucción al ejecutar la acción. Sin embargo,
debido a un error general que haya tenido lugar posteriormente, ya no ha sido posible
indicar el error específico.
La tabla siguiente explica los códigos de error generales de un valor de retorno. El código de
error se indica en formato hexadecimal. La letra x en cada número de código sirve únicamente
de comodín y representa el número del parámetro de la función de sistema que ha causado el
error:
Código de Explicación
error
(W#16#....)

176

8x01

Identificador de sintaxis no válido en un parámetro VARIANT

8x22

Error de longitud de área al leer un parámetro.

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
Código de Explicación
error
(W#16#....)
8x23

Error de longitud de área al escribir un parámetro.
Este código de error indica que el parámetro x se encuentra íntegra o parcialmente fuera
del área de operandos o que la longitud de un campo de bits de un parámetro VARIANT
no es divisible por 8.

8x24

Error de área al leer un parámetro.

8x25

Error de área al escribir un parámetro.
Este código de error indica que el parámetro x se encuentra en un área no válida para la
función de sistema. La descripción de la función en cuestión indica las áreas que no son
válidas para la función.

8x26

El parámetro contiene un número demasiado elevado de una célula de temporizador.
Este código de error indica que la célula de temporizador indicada en el parámetro x no
existe.

8x27

El parámetro contiene un número demasiado elevado de una célula de contador (error de
número del contador).
Este código de error indica que la célula de contador indicada en el parámetro x no existe.

8x28

Error de alineación al leer un parámetro.

8x29

Error de alineación al escribir un parámetro.
Este código de error indica que la referencia al parámtero x es un operando cuya dirección
de bit es diferente de 0.

8x30

El parámetro se encuentra en el DB global protegido contra escritura.

8x31

El parámetro se encuentra en el DB de instancia protegido contra escritura.
Este código de error indica que el parámetro x se encuentra en un bloque de datos
protegido contra escritura. Si el bloque de datos ha sido abierto por la propia función de
sistema, la función de sistema devolverá siempre el valor W#16#8x30.

8x32

El parámetro contiene un número de DB demasiado elevado (error de número del DB).

8x34

El parámetro contiene un número de FC demasiado elevado (error de número del FC).

8x35

El parámetro contiene un número de FB demasiado elevado (error de número del FB).
Este código de error indica que el parámetro x contiene un número de bloque mayor que
el número de bloque máximo admisible.

8x3A

El parámetro contiene el número de un DB que no está cargado.

8x3C

El parámetro contiene el número de un FC que no está cargado.

8x3E

El parámetro contiene el número de un FB que no está cargado.

8x42

Se ha producido un error de accdeso mientras el sistema intentaba leer un parámetro del
área de periferia de las entradas.

8x43

Se ha producido un error de accdeso mientras el sistema intentaba escribir un parámetro
en el área de periferia de las salidas.

8x44

Error en el enésimo (n > 1) acceso en lectura tras producirse un error.

8x45

Error en el enésimo (n > 1) acceso en escritura tras producirse un error.
Este código de error indica que se deniega el acceso al parámetro deseado.

8x7F

Error interno
Este código de error indica un error interno en el parámetro x.

Programación del PLC
Manual de programación y manejo, 11/2019

177

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Códigos de error específicos
Algunas instrucciones poseen un valor de retorno que pone a disposición un código de error
específico de la instrucción. El código de error específico indica errores que solo pueden
aparecer en instrucciones individuales.
Un código de error específico está formado por los siguientes dos números:
● Una clase de error comprendida entre 0 y 7.
● Un error individual comprendido entre 0 y 15.
%LWV 


 




 
&ODVHGHHUURU


(UURULQGLYLGXDO

6LJQR

Encontrará más información sobre los códigos de error específicos en las descripciones de las
diferentes instrucciones que hay en el sistema de información.

Consulte también
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

1.6.5

Uso de las instrucciones GET_ERROR y GET_ERR_ID

Introducción
El tratamiento local de errores permite consultar si se han producido errores en un bloque de
programa y evaluar la información correspondiente. El tratamiento local de errores se puede
ajustar para bloques de organización (OB), bloques de función (FB) y funciones (FC). Si está
activado el tratamiento local de errores, se ignorará la reacción del sistema.
En la información de error de la instrucción GET_ERR_ID se puede consultar el número de
error. A partir de la información de error de la instrucción GET_ERROR se puede ver, p. ej. en
el caso de un error de acceso, qué parámetro ha causado el error de acceso. Para que las
instrucciones puedan devolver la información necesaria sobre el error, deben programarse en
el programa de usuario para cada uno de los bloques de programa de los cuales deben
evaluarse posibles errores. Si trabaja con las instrucciones, no se llama ningún OB de error y
no se produce ninguna entrada en el búfer de diagnóstico. Con este tipo de tratamiento de
errores se interviene activamente en el desarrollo del programa en el momento en que se
produce el error programando una reacción al error ocurrido. Dado que los errores pueden
ocurrir en cualquier punto del bloque de programa, se recomienda integrar la instrucción al final
de él.
Las instrucciones GET_ERROR y GET_ERR_ID se diferencian en la profundidad de la
información de error proporcionada.
En cuanto se ha integrado una de las dos instrucciones en el código del programa, se activa
la casilla de verificación "Tratamiento local de errores en el bloque" en "Propiedades >

178

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
Atributos" de la ventana de inspección. Este ajuste no se puede modificar en la ventana de
inspección. El tratamiento local de errores se puede desactivar de nuevo borrando las
instrucciones correspondientes insertadas para dicho tratamiento.
Nota
Propiedad del bloque "Tratamiento local de errores en el bloque"
Este ajuste no se aplica a un bloque invocante, ni se transfiere a bloques de programa
llamados. Para los bloques de programa de orden superior e inferior sigue siendo aplicable la
configuración del sistema, si no se ha programado ningún tratamiento local de errores propio
para ellos.

Prioridades en la salida de errores
En el tratamiento local de errores con las instrucciones GET_ERROR o GET_ERR_ID se
muestra la información acerca del primer error ocurrido. Si durante la ejecución de una
instrucción se presentan simultáneamente varios errores, estos se muestran según su
prioridad. La tabla siguiente muestra la prioridad de los distintos tipos de error:
Prioridad

Tipo de error

1

Error en el código del programa

2

Falta la referencia

3

Rango no válido

4

El DB no existe

5

Los operandos no son compatibles

6

El ancho del rango indicado no es suficiente

7

No existen temporizadores ni contadores

8

No hay acceso de escritura a un DB

9

Error de periferia

10

La instrucción no existe

11

El bloque no existe

12

Profundidad de anidamiento no válida

La prioridad más alta es 1 y la más baja es 12.

Información adicional
Encontrará información adicional sobre las instrucciones en el sistema de información, en
Programar PLC > Instrucciones > Instrucciones (S7-1200, S7-1500) > Instrucciones básicas.
Las instrucciones están disponibles en los lenguajes de programación KOP/FUP/AWL/SCL y
GRAPH.

Consulte también
GET_ERROR: Consultar error localmente (Página 1303)
GET_ERR_ID: Consultar ID de error localmente (Página 933)

Programación del PLC
Manual de programación y manejo, 11/2019

179

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
GET_ERR_ID: Consultar ID de error localmente (Página 1307)
GET_ERROR: Consultar error localmente (Página 928)

1.6.6

Ejemplo de tratamiento de errores de ejecución del programa

Introducción
Las opciones de tratamiento de errores pueden programarse tanto individual como
conjuntamente. Para garantizar la detección de todos los tipos de error que pueden aparecer
en el programa, recomendamos combinar las opciones de tratamiento de errores de la forma
descrita en el ejemplo siguiente.
Para un análisis preciso de los errores, además del parámetro de salida RET_VAL también se
pueden utilizar las instrucciones "GET_ERROR" o "GET_ERR_ID". Estas opciones
proporcionan códigos de error, cuya explicación detallada puede consultarse en la descripción
de cada instrucción.
No obstante, también hay tipos de error en los que el parámetro de salida RET_VAL no
devuelve ningún código de error. Si se produce, p. ej., un error de acceso durante la lectura de
un parámetro de entrada, las salidas de la instrucción ya no se escriben, ya que la ejecución
de la instrucción se ha interrumpido. En tal caso recomendamos integrar en el programa
ambas instrucciones "GET_ERROR" o "GET_ERR_ID", ya que en este caso también
proporcionan información fiable.
ADVERTENCIA
Error de acceso durante la lectura de un parámetro de entrada
El parámetro RET_VAL no devuelve ningún código de error válido y en el búfer de diagnóstico
no se registra información detallada del error.
Un primer indicio de un error puede ser el bit BR de la palabra de estado o la salida de
habilitación ENO. Si estos devuelven el estado lógico "0", hay un error en la ejecución de la
instrucción. Con el estado lógico "1" no hay ningún error y no se requieren más análisis. Salvo
que se trate de un error de acceso a la memoria. Entonces el estado lógico "1" también puede
significar un error.

180

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

Procedimiento
El siguiente ejemplo muestra cómo detectar un error de acceso durante la lectura de un
parámetro de entrada.
1. Declare la interfaz del bloque de programa de la manera siguiente:

2. Escriba el siguiente código de programa:

Programación del PLC
Manual de programación y manejo, 11/2019

181

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa

182

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.6 Tratamiento de errores de ejecución del programa
En el segmento 1 se llama la instrucción "MOVE_BLK_VARIANT: Copiar área". En el
parámetro SRC se accede al área de origen "SrcField" con un índice variable. Si durante la
ejecución de la instrucción no se producen errores, la salida de habilitación ENO devuelve el
estado lógico "1" y la ejecución del programa salta al segmento 4 y continúa allí.
Si durante la ejecución de la instrucción, p. ej. debido al índice variable, se produce un error de
acceso, la instrucción "GET_ERR_ID: Consultar ID de error localmente" en el segmento 2
devuelve una ID de error. La comparación de si la ID de error es "DIFERENTE" al valor "0" en
el segmento 2 ofrece el resultado #Test2 = TRUE. La comparación de si la ID de error es
"IGUAL" al valor "0" en el segmento 3 ofrece el resultado #Test3 = TRUE.
En tal caso, el operando #TagRet_Val del parámetro de salida RET_VAL no devuelve ningún
código de error válido.

Excepciones
Sin embargo, existen unas cuantas instrucciones en las que no es posible programar el
tratamiento de errores como en el ejemplo mencionado arriba. Se trata de las instrucciones
siguientes:
● Instrucciones que por regla general no tienen un mecanismo EN/ENO
● Instrucciones en las que se ha desactivado ENO
● S_COMP
● PEEK, PEEK_BOOL, POKE, POKE_BOOL y POKE_BLK
El bit BR y/o la salida de habilitación ENO se ponen a TRUE en estas instrucciones, incluso en
caso de que se produzca un error de acceso.
El ejemplo siguiente muestra cómo se puede programar un tratamiento de errores fiable en el
lenguaje de programación AWL:

AWL

Explicación

SET

// El operando #Tag_ErrorID se inicializa
con "0".

L 0
T #Tag_ErrorID

Programación del PLC
Manual de programación y manejo, 11/2019

183

Principios básicos de la programación
1.7 Control del flujo de programa
AWL

Explicación

CALL S_COMP

// Se llama la instrucción.

src_type := String

// Tipo de datos de los parámetros IN1 y
IN2

relation := EQ

// Tipo de comparación de la instrucción

IN1 := #StringArray.THIS[#index]

// Se accede de forma variable al elemento del ARRAY.

IN2 := 'STRING'

// Ambos valores se comparan entre sí.

OUT := #TagResult

// Si ambos valores son iguales el operando #TagResult obtiene el estado lógico
"1".

A BR

// Se consulta el bit BR.

CALL GET_ERR_ID

// Se llama la instrucción.

RET_VAL := #Tag_ErrorID

// En caso de error de acceso la instrucción emite un código de error.

Aunque el bit BR tenga el estado lógico "1", se detecta el error de acceso. El código de error
se consulta evaluando el operando #Tag_ErrorID de la instrucción "GET_ERR_ID: Consultar
ID de error localmente".

1.7

Control del flujo de programa

1.7.1

Palabra de datos en S7-300/S7-400

1.7.1.1

Principios básicos de la palabra de estado

Descripción
La palabra de estado agrupa bits de estado que son activados por la CPU durante el
procesamiento digital o bien utilizados por la misma para controlar operaciones lógicas
binarias. Los bits de estado se pueden consultar e influenciar de forma concreta.
La tabla siguiente muestra el orden de los bits de estado en la palabra de estado:
Palabra de estado
Número de bit

15-9

8

7

6

5

4

3

2

1

0

Contenido

0

BR

CC1

CC0

OV

OS

OR

STA

RLO

/FC

Los bits de estado /FC, RLO, STA, OR y BR son indicadores binarios que utiliza la CPU en las
instrucciones binarias. Los bits de estado OS, OV, CC0 y CC1 son indicadores digitales que
muestran principalmente resultados de funciones matemáticas.

184

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.7 Control del flujo de programa

/FC (primera consulta)
El estado lógico del bit /FC controla la ejecución de una cadena de operación lógica.
Una cadena de operación lógica comienza con el estado lógico "0" del bit /FC y una instrucción
binaria de consulta (primera consulta). La primera consulta corresponde a la primera
operación lógica con bits o bien consulta binaria en una red. Esta pone el bit /FC a "1". La
cadena de operación lógica finaliza con una asignación binaria de valores (p. ej. con la
instrucción "Activar"), con un salto condicional o un cambio de bloque. Estos ponen el bit /FC
a "0".

RLO (resultado lógico)
El bit de estado RLO es la memoria intermedia en las operaciones lógicas binarias.
La CPU transfiere el resultado de la consulta al RLO en la primera consulta. En todas las
consultas siguientes, el resultado de la consulta se combina lógicamente con el RLO guardado
y el resultado se deposita nuevamente en el RLO.
El RLO se puede activar, desactivar, negar o guardar en el resultado binario (BR) a través de
las instrucciones correspondientes.
Con el RLO se controlan instrucciones de almacenamiento, temporización y contaje y se
ejecutan determinadas instrucciones de salto.

STA (estado)
El bit de estado STA se corresponde con el estado lógico del operando binario consultado.
El estado de una operación lógica, la cual permite el acceso de lectura en la memoria, siempre
es igual al valor del bit direccionado. El estado de una operación lógica, la cual permite el
acceso de lectura a la memoria (p. ej. las instrucciones "Activar" o "Desactivar"), es igual al
valor del bit en el que la instrucción escribe. En caso de no escribir, el estado es igual al valor
del bit direccionado. El bit de estado no tiene ningún significado para las instrucciones de
operación lógica que no acceden a la memoria. Estas instrucciones ponen el bit de estado a
"1". La instrucciones no consultan el bit de estado. Este simplemente se calcula a través de
variables de programa al mostrar el estado online.

OR (bit OR)
El bit de estado OR se requiere cuando se ejecuta una operación lógica Y antes de una
operación lógica O.
El bit OR se activa cuando el RLO de la operación lógica Y es "1". De esta manera se anticipa
el resultado de la operación lógica O. Cualquier otra instrucción binaria desactiva el bit OR.

OS (desbordamiento con memoria)
El bit de estado OS guarda una activación del bit de estado OV.
Cuando la CPU activa el bit de estado OV también activa el bit de estado OS. No obstante,
mientras la siguiente instrucción ejecutada correctamente vuelve a desactivar el bit OV, el bit
de estado OS permanece activado. Esto permite consultar más adelante, dentro del ciclo

Programación del PLC
Manual de programación y manejo, 11/2019

185

Principios básicos de la programación
1.7 Control del flujo de programa
actual de la CPU, un desbordamiento del margen numérico o p. ej. la utilización de números
en coma flotante no válidos.

OV (desbordamiento)
El bit de estado OV muestra un desbordamiento del margen numérico o la utilización de
números en coma flotante no válidos.
El bit de estado OV se puede influenciar por medio de funciones matemáticas, instrucciones
de conversión y comparaciones de números en coma flotante.

CC0 y CC1 (códigos de condición)
Los bits de estado CC0 y CC1 informan sobre el resultado de las siguientes instrucciones:
● Instrucciones de comparación
● Funciones matemáticas
● Operaciones lógicas con palabras
● Instrucciones de desplazamiento y rotación

BR (resultado binario)
El bit de estado BR sirve para ejecutar el mecanismo EN/ENO para cuadros o como condición
en algunas instrucciones de salto (AWL). El bit de estado BR puede influenciarse a través de
instrucciones determinadas (p. ej. SAVE).

1.7.1.2

Activar el bit de estado

Activar el bit de estado en operaciones lógicas con bits
Descripción
Las instrucciones binarias influyen en los bits de estado OR, STA, RLO y /FC.

Activar los bits de estado en KOP
La siguiente tabla muestra la activación de los bits de estado en el lenguaje de programación
KOP:
Instrucción

186

Bit de estado

Nemónicos

Título

OR

STA

RLO

/FC

-| |-

Contacto normalmente abierto

x

x

x

1

-| / |-

Contacto normalmente cerrado

x

x

x

1

-|NOT|-

Invertir RLO

-

1

x

-

-( )-

Asignación

0

x

-

0

-(R)-

Desactivar salida

0

x

-

0

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.7 Control del flujo de programa
Instrucción

Bit de estado

Nemónicos

Título

OR

STA

RLO

/FC

-(S)-

Activar salida

0

x

-

0

SR

Flipflop de activación/desactivación

x

x

x

1

RS

Flipflop de desactivación/activación

x

x

x

1

-|P|-

Consultar flanco de señal ascendente de un ope‐
rando

0

1

x

1

-|N|-

Consultar flanco de señal descendente de un ope‐ 0
rando

1

x

1

P_TRIG

Consultar flanco de señal ascendente del RLO

0

x

x

1

N_TRIG

Consultar flanco de señal descendente del RLO

0

x

x

1

x: la instrucción puede escribir "1" o "0".
1: la instrucción pone el bit de estado a "1".
0: la instrucción pone el bit de estado a "0".
-: el bit de estado no se ve influenciado.

Activar los bits de estado en FUP
La siguiente tabla muestra la activación de los bits de estado en el lenguaje de programación
FUP:
Instrucción

Bit de estado

Nemónicos

Título

OR

STA

RLO

/FC

&

Operación lógica Y

x

x

x

1

<=1

Operación lógica O

x

x

x

1

X

Operación lógica O-exclusiva

x

x

x

1

-|

Insertar entrada binaria

-

1

x

-

-o|

Invertir RLO

-

1

x

-

-( )-

Asignación

0

x

-

0

R

Desactivar salida

0

x

-

0

S

Activar salida

0

x

-

0

SR

Flipflop de activación/desactivación

x

x

x

1

RS

Flipflop de desactivación/activación

x

x

x

1

P

Consultar flanco de señal ascendente de un ope‐
rando

0

1

x

1

N

Consultar flanco de señal descendente de un ope‐ 0
rando

1

x

1

P_TRIG

Consultar flanco de señal ascendente del RLO

0

x

x

1

N_TRIG

Consultar flanco de señal descendente del RLO

0

x

x

1

x: la instrucción puede escribir "1" o "0".
1: la instrucción pone el bit de estado a "1".
0: la instrucción pone el bit de estado a "0".
-: el bit de estado no se ve influenciado.

Programación del PLC
Manual de programación y manejo, 11/2019

187

Principios básicos de la programación
1.7 Control del flujo de programa

Activar los bits de estado en AWL
La siguiente tabla muestra la activación de los bits de estado en el lenguaje de programación
AWL:
Instrucción

Bit de estado

Nemónicos

Título

OR

STA

RLO

/FC

A

Operación lógica Y

0

x

x

1

AN

Operación lógica Y negada

0

x

x

1

O

Operación lógica O

0

x

x

1

ON

Operación lógica O negada

0

x

x

1

X

Operación lógica O-exclusiva

0

x

x

1

XN

Operación lógica O-exclusiva negada

0

x

x

1

O

Operación lógica O de funciones Y

0

1

-

0

A(

Operación lógica Y con abrir paréntesis

0

1

-

0

AN(

Operación lógica Y con abrir paréntesis

0

1

-

0

O(

Operación lógica O con abrir paréntesis

0

1

-

0

ON(

Operación lógica O negada con abrir paréntesis

0

1

-

0

X(

Operación lógica O-exclusiva con abrir paréntesis 0

1

-

0

XN(

Operación lógica O-exclusiva negada con abrir pa‐ 0
réntesis

1

-

0

=

Asignación

0

x

-

0

R

Desactivar salida

0

x

-

0

S

Activar salida

0

x

-

0

NOT

Invertir RLO

-

1

x

-

SET

Poner RLO a 1

0

1

1

0

CLR

Poner RLO a 0

0

0

0

0

SAVE

Guardar RLO en bit BR

-

-

-

-

FN

Consultar flanco de señal descendente del RLO

0

x

x

1

FP

Consultar flanco de señal ascendente del RLO

0

x

x

1

x: la instrucción puede escribir "1" o "0".
1: la instrucción pone el bit de estado a "1".
0: la instrucción pone el bit de estado a "0".
-: el bit de estado no se ve influenciado.

Activar el bit de estado en instrucciones de temporización y contaje
Descripción
Las instrucciones de temporización y contaje influyen en los bits de estado OR, STA, RLO y /
FC.

188

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.7 Control del flujo de programa

Activar los bits de estado en KOP y FUP
La tabla siguiente muestra la activación de los bits de estado en los lenguajes de programación
KOP y FUP:
Instrucción

Bit de estado

Nemónicos

Título

OS

OR

STA

RLO

/FC

S_PULSE

Parametrizar y arrancar temporizador como
impulso

-

x

x

x

1

S_PEXT

Parametrizar y arrancar temporizador como
impulso prolongado

-

x

x

x

1

S_ODT

Parametrizar y arrancar temporizador como
retardo a la conexión

-

x

x

x

1

S_ODTS

Parametrizar y arrancar temporizador como
retardo a la conexión con memoria

-

x

x

x

1

S_OFFDT

Parametrizar y arrancar temporizador como
retardo a la desconexión

-

x

x

x

1

SP

Arrancar temporizador como impulso

-

0

-

-

0

SE

Arrancar temporizador como impulso prolon‐
gado

-

0

-

-

0

SD

Arrancar temporizador como retardo a la co‐
nexión

-

0

-

-

0

SS

Arrancar temporizador como retardo a la co‐
nexión con memoria

-

0

-

-

0

SF

Arrancar temporizador como retardo a la des‐ conexión

0

-

-

0

S_CUD

Parametrizar e incrementar/decrementar con‐ tador

x

x

x

1

S_CU

Parametrizar e incrementar contador

-

x

x

x

1

S_CD

Parametrizar y decrementar contador

-

x

x

x

1

SC

Poner contador al valor inicial

-

0

x

-

0

CU

Contador ascendente

-

0

x

-

0

CD

Contador descendente

-

0

-

-

0

x: la instrucción puede escribir "1" o "0".
1: la instrucción pone el bit de estado a "1".
0: la instrucción pone el bit de estado a "0".
-: el bit de estado no se ve influenciado.

Activar los bits de estado en AWL
La siguiente tabla muestra la activación de los bits de estado en el lenguaje de programación
AWL:
Instrucción
Nemónicos

Bit de estado

Título

OS

OR

STA

RLO

/FC

FR

Habilitar temporizador

-

0

-

-

0

R

Inicializar temporizador

-

0

-

-

0

SP

Arrancar temporizador como impulso

-

0

-

-

0

Programación del PLC
Manual de programación y manejo, 11/2019

189

Principios básicos de la programación
1.7 Control del flujo de programa
Instrucción

Bit de estado

Nemónicos

Título

OS

OR

STA

RLO

/FC

SE

Arrancar temporizador como impulso prolon‐
gado

-

0

-

-

0

SD

Arrancar temporizador como retardo a la co‐
nexión

-

0

-

-

0

SS

Arrancar temporizador como retardo a la co‐
nexión con memoria

-

0

-

-

0

SF

Arrancar temporizador como retardo a la des‐ conexión

0

-

-

0

FR

Habilitar contador

-

0

-

-

0

R

Poner contador a 0

-

0

-

-

0

S

Inicializar contador

-

0

-

-

0

CU

Contador ascendente

-

0

-

-

0

CD

Contador descendente

-

0

-

-

0

x: la instrucción puede escribir "1" o "0".
1: la instrucción pone el bit de estado a "1".
0: la instrucción pone el bit de estado a "0".
-: el bit de estado no se ve influenciado.

Activar los bits de estado en instrucciones con números enteros
Descripción
Las instrucciones con números enteros influyen en los bits de estado CC1, CC0, OV y OS de
la palabra de estado.
Si el resultado es negativo, los bits de estado CC1 y CC0 se ponen a "0". Si el resultado es
positivo, el bit de estado CC1 se pone a "1" y el bit de estado CC0 a "0". El bit de estado CC1
se pone a "0" y el bit de estado CC0 a "1" cuando el resultado es negativo.
Si se produce un desbordamiento del margen numérico, los bits de estado OV y OS se ponen
a "1". Si se produce una división entre cero, los bits de estado CC1, CC0, OV y OS devuelven
el estado lógico "0".
Las siguientes tablas muestran la activación de los bits de estado cuando se utilizan números
enteros:
Rango válido

CC CC0
1

OV OS

0 (cero)

0

0

0

*

16 bits: -32768 <= resultado < 0 (número negativo)

0

1

0

*

1

0

0

*

32 bits: -2147483648 <= resultado < 0 (número negativo)
16 bits: 32767 >= resultado > 0 (número positivo)
32 bits: 2147483647 >= resultado > 0 (número positivo)
* El bit OS no se ve afectado por el resultado de la operación.

190

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.7 Control del flujo de programa

Rango no válido

CC CC OV OS
1
0

Rebase por defecto en suma

0

0

1

1

0

1

1

1

0

1

1

1

1

0

1

1

1

0

1

1

1

1

1

1

16 bits: resultado = - 65536
32 bits: resultado = - 4294967296
Rebase por defecto en multiplicación
16 bits: resultado < -32768 (número negativo)
32 bits: resultado < -2147483648 (número negativo)
Desbordamiento en suma y resta
16 bits: resultado > 32767 (número positivo)
32 bits: resultado > 2147483647 (número positivo)
Desbordamiento en multiplicación y división
16 bits: resultado > 32767 (número positivo)
32 bits: resultado > 2147483647 (número positivo)
Rebase por defecto en suma y resta
16 bits: resultado < -32768 (número negativo)
32 bits: resultado < -2147483648 (número negativo)
División por 0

Activar los bits de estado en instrucciones con números en coma flotante
Descripción
Las instrucciones con números en coma flotante influyen en los bits de estado CC1, CC0, OV
y OS de la palabra de estado.
Si el resultado es negativo, los bits de estado CC1 y CC0 se ponen a "0". Si el resultado es
positivo, el bit de estado CC1 se pone a "1" y el bit de estado CC0 a "0". El bit de estado CC1
se pone a "0" y el bit de estado CC0 a "1" cuando el resultado es negativo.
Si se produce un desbordamiento del margen numérico, los bits de estado OV y OS se ponen
a "1". En caso de número en coma flotante no válido, los bits de estado CC1, CC0, OV y OS
devuelven el estado lógico "0".
Las siguientes tablas muestran la activación de los bits de estado cuando se utilizan números
en coma flotante:
Rango válido

CC CC OV OS
1
0

+0, -0 (cero)

0

0

0

*

-3,402823E+38 < resultado <
-1,175494E-38 (número negativo)

0

1

0

*

+1,175494E-38 < resultado < 3,402824E
+38 (número positivo)

1

0

0

*

* El bit OS no se ve afectado por el resultado de la operación.

Programación del PLC
Manual de programación y manejo, 11/2019

191

Principios básicos de la programación
1.7 Control del flujo de programa

Rango no válido

CC CC OV OS
1
0

Rebase por defecto

0

0

1

1

0

0

1

1

0

1

1

1

1

0

1

1

1

1

1

1

-1,175494E-38 < resultado < 1,401298E-45 (número negativo)
Rebase por defecto
+1,401298E-45 < resultado <
+1,175494E-38 (número positivo)
Desbordamiento
Resultado < -3,402823E+38 (número ne‐
gativo)
Desbordamiento
Resultado > 3,402823E+38 (número posi‐
tivo)
Número en coma flotante no válido u ope‐
ración no admisible (valor de entrada fuera
del rango de valores válido)

Activar el bit de estado en operaciones de comparación
Descripción
Las instrucciones de comparación influyen en los bits de estado CC1, CC0, OV y OS de la
palabra de estado.
Las instrucciones de comparación activan los bits de estado CC1 y CC0 independientemente
de la relación de comparación.
Si se utilizan números en coma flotante no válidos, los bits de estado CC1, CC0, OV y OS se
ponen a "1".
La siguiente tabla muestra la activación de los bits de estado en instrucciones de comparación:
Resultado

CC1

CC0

OV

OS

Igual (ACU2 = ACU1)

0

0

0

*

Mayor (ACU2 > ACU1)

1

0

0

*

Menor (ACU2 < ACU1)

0

1

0

*

Número en coma flotante no válido

1

1

1

1

* El bit OS no se ve afectado por el resultado de la operación.

Activar el bit de estado en instrucciones de control del programa
Descripción
Las instrucciones de control del programa influyen en los bits de estado OS, OR, STA, RLO y /
FC.

192

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.7 Control del flujo de programa

Activar los bits de estado en KOP y FUP
La tabla siguiente muestra la activación de los bits de estado en los lenguajes de programación
KOP y FUP:
Instrucción

Bit de estado

Nemónicos

Título

OS

OR

STA

RLO

/FC

JMP

Saltar si RLO = 1

-

0

1

1

0

JMPN

Saltar si RLO = 0

-

0

1

1

0

RET

Retroceder

0

0

1

1

0

CALL

Llamar bloque

0

0

1

-

0

OPN

Abrir bloque de datos global

-

-

-

-

-

OPNI

Abrir bloque de datos de instancia

-

-

-

-

-

MCR<

Abrir áreas MCR

-

0

1

-

0

MCR>

Cerrar áreas MCR

-

0

1

-

0

MCRA

Activar área MCR

-

-

-

-

-

MCRD

Desactivar área MCR

-

-

-

-

-

x: la instrucción puede escribir "1" o "0".
1: la instrucción pone el bit de estado a "1".
0: la instrucción pone el bit de estado a "0".
-: el bit de estado no se ve influenciado.

Activar los bits de estado en AWL
La siguiente tabla muestra la activación de los bits de estado en el lenguaje de programación
AWL:
Instrucción

Bit de estado

Nemónicos

Título

OS

OR

STA

RLO

/FC

JU

Salto incondicional

-

-

-

-

-

JC

Saltar si RLO = 1

-

0

1

1

0

JCN

Saltar si RLO = 0

-

0

1

1

0

JCB

Saltar si RLO = 1 y guardar RLO

-

0

1

1

0

JNB

Saltar si RLO = 0 y guardar RLO

-

0

1

1

0

JBI

Saltar si BR = 1

-

0

1

-

0

JNBI

Saltar si BR = 1

-

0

1

-

0

JO

Saltar si OV = 1

-

-

-

-

-

JOS

Saltar si OS = 1

0

-

-

-

-

SPZ

Saltar si el resultado es cero

-

-

-

-

-

SPN

Saltar si el resultado no es cero

-

-

-

-

-

SPP

Saltar si el resultado es mayor que cero

-

-

-

-

-

SPM

Saltar si el resultado es menor que cero

-

-

-

-

-

JPZ

Saltar si el resultado es mayor o igual a cero

-

-

-

-

-

SPMZ

Saltar si el resultado es menor o igual a cero

-

-

-

-

-

SPU

Saltar si el resultado no es válido

-

-

-

-

-

JL

Definir lista de saltos

-

-

-

-

-

Programación del PLC
Manual de programación y manejo, 11/2019

193

Principios básicos de la programación
1.7 Control del flujo de programa
Instrucción

Bit de estado

Nemónicos

Título

OS

OR

STA

RLO

/FC

LOOP

Bucle

-

-

-

-

-

OPN

Abrir bloque de datos global

-

-

-

-

-

AUFDI

Abrir bloque de datos de instancia

-

-

-

-

-

CALL

Llamar bloque

0

0

1

-

0

CC

Llamada condicional

0

0

1

1

0

UC

Llamada incondicional

0

0

1

-

0

BE

Fin de bloque

0

0

1

-

0

BEC

Fin de bloque condicional

x

0

1

1

0

BEU

Fin de bloque incondicional

0

0

1

-

0

MCR(

Abrir áreas MCR

-

0

1

-

0

)MCR

Cerrar áreas MCR

-

0

1

-

0

MCRA

Activar área MCR

-

-

-

-

-

MCRD

Desactivar área MCR

-

-

-

-

-

x: la instrucción puede escribir "1" o "0".
1: la instrucción pone el bit de estado a "1".
0: la instrucción pone el bit de estado a "0".
-: el bit de estado no se ve influenciado.

Activar el bit de estado en operaciones lógicas con palabras
Descripción
Las operaciones lógicas con palabras influyen en los bits de estado CC1, CC0 y OV de la
palabra de estado.
Si en el resultado de una operación lógica con palabras todos los bits son "0", el bit de estado
CC1 se pone a "0". Si por lo menos un bit del resultado es "1", el bit de estado CC1 se pone a
"1".
La siguiente tabla muestra la activación de los bits de estado en operaciones lógicas con
palabras:
Resultado

CC1

CC0

OV

Cero

0

0

0

No cero

1

0

0

Activar el bit de estado en instrucciones de desplazamiento y rotación
Descripción
Las instrucciones de desplazamiento y rotación influyen en los bits de estado CC1, CC0 y OV
de la palabra de estado.

194

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.7 Control del flujo de programa
En las operaciones de desplazamiento y rotación, el estado lógico del bit desplazado o rotado
en último lugar se transfiere al bit de estado CC1. Los bits de estado CC0 y OV se resetean.
La siguiente tabla muestra la activación del bit de estado en instrucciones de desplazamiento
y rotación:
Bit desplazado hacia fuera o rotado

CC1

CC0

OV

"0"

0

0

0

"1"

1

0

0

Con número de desplazamiento o rotación 0

*

*

*

* El bit no se ve afectado por el resultado de la operación.

1.7.1.3

Consultar el bit de estado en AWL

Consultar el bit de estado con instrucciones de operaciones lógicas con bits
Descripción
El estado lógico de los bits en la palabra de estado se consulta con las siguientes operaciones
lógicas con bits:
● A: Operación lógica Y
● AN: Operación lógica Y negada
● O: Operación lógica O
● ON: Operación lógica O negada
● X: Operación lógica O-exclusiva
● XN: Operación lógica O-exclusiva negada
La tabla siguiente muestra los operandos que pueden utilizarse para consultar los estados
lógicos de los bits en la palabra de estado:
Operando

Consulta de la palabra de estado

== 0

Consulta de ((CC 0 = 0) Y (CC 1 = 0))

<> 0

Consulta de CC 0 <>CC 1

>0

Consulta de ((CC 0 = 0) Y (CC 1 = 1))

<0

Consulta de ((CC 0 = 1) Y (CC 1 = 0))

>= 0

Consulta de CC 0 = 0

<= 0

Consulta de CC 1 = 0

UO

Consulta de ((CC 1 = 1) Y (CC 0 = 1))

OV

Consulta de OV = 1

OS

Consulta de OS = 1

BR

Consulta de BR = 1

Programación del PLC
Manual de programación y manejo, 11/2019

195

Principios básicos de la programación
1.7 Control del flujo de programa

Consulte también
A: Operación lógica Y (Página 5356)
AN: Operación lógica Y negada (Página 5357)
O: Operación lógica O (Página 5359)
ON: Operación lógica O negada (Página 5360)
X: Operación lógica O-exclusiva (Página 5361)
XN: Operación lógica O-exclusiva negada (Página 5362)
O: Operación lógica O de funciones Y (Página 5364)
A(: Operación lógica Y con abrir paréntesis (Página 5364)
AN(: Operación lógica Y negada con abrir paréntesis (Página 5365)
O(: Operación lógica O con abrir paréntesis (Página 5366)
ON(: Operación lógica O negada con abrir paréntesis (Página 5367)
X(: Operación lógica O-exclusiva con abrir paréntesis (Página 5368)
XN(: Operación lógica O-exclusiva negada con abrir paréntesis (Página 5369)
): Cerrar paréntesis (Página 5370)
=: Asignación (Página 5371)
R: Desactivar (Página 5372)
S: Activar (Página 5373)
NOT: Invertir RLO (Página 5374)
SET: Poner RLO a 1 (Página 5375)
CLR: Poner RLO a 0 (Página 5376)
SAVE: Guardar RLO en bit BR (Página 5377)
FN: Consultar flanco de señal descendente del RLO (Página 5378)
FP: Consultar flanco de señal ascendente del RLO (Página 5380)

Consultar el bit de estado con instrucciones de salto
Descripción
La tabla siguiente muestra la evaluación de los bits de estado utilizando las instrucciones de
salto:

196

RLO

BR

CC1

CC0

OV

OS

Nemónicos de la instrucción ejecutada

1

-

-

-

-

-

JC, JCB

0

-

-

-

-

-

JCN, JNB

-

1

-

-

-

-

JBI

-

0

-

-

-

-

JNBI

-

-

0

0

-

-

JZ, JMZ, JPZ

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.7 Control del flujo de programa
RLO

BR

CC1

CC0

OV

OS

Nemónicos de la instrucción ejecutada

-

-

1

0

-

-

JN, JP, JPZ

-

-

0

1

-

-

JN, JM, JMZ

-

-

1

1

-

-

SPU

-

-

-

-

1

-

JO

-

-

-

-

-

1

JOS

La tabla siguiente muestra la relación entre los bits de estado CC1 y CC0 y las instrucciones
de salto condicionales:
CC1

CC0

Resultado

Nemónicos de la instrucción ejecuta‐
da

0

0

=0

SPZ

1o0

0o1

<> 0

SPN

1

0

>0

SPP

0

1

<0

SPM

0o1

0

>= 0

JPZ

0

0o1

<= 0

SPMZ

1

1

UO (no válido)

SPU

Consulte también
JU: Salto incondicional (Página 5471)
JC: Saltar si RLO = 1 (Página 5472)
JCN: Saltar si RLO = 0 (Página 5474)
JCB: Saltar si RLO = 1 y guardar RLO (Página 5475)
JNB: Saltar si RLO = 0 y guardar RLO (Página 5476)
JBI: Saltar si BR = 1 (Página 5477)
JNBI: Saltar si BR = 0 (Página 5478)
JO: Saltar si OV = 1 (Página 5479)
JOS: Saltar si OS = 1 (Página 5480)
JZ: Saltar si el resultado es cero (Página 5482)
JN: Saltar si el resultado no es cero (Página 5483)
JP: Saltar si el resultado es mayor que cero (Página 5485)
JM: Saltar si el resultado es menor que cero (Página 5487)
JPZ: Saltar si el resultado es mayor o igual a cero (Página 5488)
JMZ: Saltar si el resultado es menor o igual a cero (Página 5490)
JUO: Saltar si el resultado no es válido (Página 5492)
JL: Definir lista de saltos (Página 5493)
LOOP: Bucle (Página 5494)

Programación del PLC
Manual de programación y manejo, 11/2019

197

Principios básicos de la programación
1.7 Control del flujo de programa

1.7.2

Palabra de datos S7-1500

1.7.2.1

Principios básicos de la palabra de estado

Descripción
La palabra de estado agrupa bits de estado que son activados por la CPU durante el
procesamiento digital o bien utilizados por la misma para controlar operaciones lógicas
binarias. Los bits de estado se pueden consultar e influenciar de forma concreta.
La tabla siguiente muestra el orden de los bits de estado en la palabra de estado:
Palabra de estado
Número de bit

15-9

8

7

6

5

4

3

2

1

0

Contenido

0

BR

CC1

CC0

OV

OS

0

0

0

0

Los bits de estado OS, OV, CC0 y CC1 son indicadores digitales que muestran principalmente
resultados de funciones matemáticas.

OS (desbordamiento con memoria)
El bit de estado OS guarda una activación del bit de estado OV.
Cuando la CPU activa el bit de estado OV también activa el bit de estado OS. No obstante,
mientras la siguiente instrucción ejecutada correctamente vuelve a desactivar el bit OV, el bit
de estado OS permanece activado. Esto permite consultar más adelante, dentro del bloque
actual de la CPU, un desbordamiento del margen numérico o p. ej. la utilización de números
en coma flotante no válidos.

OV (desbordamiento)
El bit de estado OV muestra un desbordamiento del margen numérico o la utilización de
números en coma flotante no válidos.
El bit de estado OV se puede influenciar por medio de funciones matemáticas, instrucciones
de conversión y comparaciones de números en coma flotante.

CC0 y CC1 (códigos de condición)
Los bits de estado CC0 y CC1 informan sobre el resultado de las siguientes instrucciones:
● Instrucciones de comparación
● Funciones matemáticas
● Operaciones lógicas con palabras
● Instrucciones de desplazamiento y rotación

198

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.7 Control del flujo de programa

BR (resultado binario)
El bit de estado BR sirve para ejecutar el mecanismo EN/ENO para cuadros o como condición
en algunas instrucciones de salto (AWL). El bit de estado BR puede influenciarse a través de
instrucciones determinadas (p. ej. SAVE).

RLO (resultado lógico)
El bit de estado RLO es la memoria intermedia en las operaciones lógicas binarias y no forma
parte de la palabra de estado.
La CPU transfiere el resultado de la consulta al RLO en la primera consulta. En todas las
consultas siguientes, el resultado de la consulta se combina lógicamente con el RLO guardado
y el resultado se deposita nuevamente en el RLO.
El RLO se puede activar o desactivar a través de las instrucciones correspondientes.
Con el RLO se controlan instrucciones de almacenamiento, temporización y contaje y se
ejecutan determinadas instrucciones de salto.

Nota
Dado que los bits de estado en parte solo se necesitan para el procesamiento interno,
únicamente se muestran cuando están disponibles para la posterior ejecución del programa.

1.7.2.2

Consulta y activación de los bits de estado en AWL

Consultar el bit de estado con instrucciones de operaciones lógicas con bits
Descripción
El estado lógico de los bits en la palabra de estado se consulta con las siguientes operaciones
lógicas con bits:
● A: Operación lógica Y
● AN: Operación lógica Y negada
● O: Operación lógica O
● ON: Operación lógica O negada
● X: Operación lógica O-exclusiva
● XN: Operación lógica O-exclusiva negada
La tabla siguiente muestra los operandos que pueden utilizarse para consultar los estados
lógicos de los bits en la palabra de estado:
Operando

Consulta de la palabra de estado

== 0

Consulta de ((CC 0 = 0) Y (CC 1 = 0))

<> 0

Consulta de CC 0 <>CC 1

Programación del PLC
Manual de programación y manejo, 11/2019

199

Principios básicos de la programación
1.7 Control del flujo de programa
Operando

Consulta de la palabra de estado

>0

Consulta de ((CC 0 = 0) Y (CC 1 = 1))

<0

Consulta de ((CC 0 = 1) Y (CC 1 = 0))

>= 0

Consulta de CC 0 = 0

<= 0

Consulta de CC 1 = 0

UO

Consulta de ((CC 1 = 1) Y (CC 0 = 1))

OV

Consulta de OV = 1

OS

Consulta de OS = 1

BR

Consulta de BR = 1

Consulte también
A: Operación lógica Y (Página 1579)
AN: Operación lógica Y negada (Página 1580)
O: Operación lógica O (Página 1581)
ON: Operación lógica O negada (Página 1583)
X: Operación lógica O-exclusiva (Página 1584)
XN: Operación lógica O-exclusiva negada (Página 1585)
O: Operación lógica O de funciones Y (Página 1586)
A(: Operación lógica Y con abrir paréntesis (Página 1587)
AN(: Operación lógica Y negada con abrir paréntesis (Página 1588)
O(: Operación lógica O con abrir paréntesis (Página 1589)
ON(: Operación lógica O negada con abrir paréntesis (Página 1590)
X(: Operación lógica O-exclusiva con abrir paréntesis (Página 1591)
XN(: Operación lógica O-exclusiva negada con abrir paréntesis (Página 1592)
): Cerrar paréntesis (Página 1593)
=: Asignación (Página 1594)
R: Desactivar (Página 1595)
S: Activar (Página 1596)
NOT: Invertir RLO (Página 1597)
SET: Poner RLO a 1 (Página 1598)
CLR: Poner RLO a 0 (Página 1598)
SAVE: Guardar RLO en bit BR (Página 1599)
FN: Consultar flanco de señal descendente del RLO (Página 1600)
FP: Consultar flanco de señal ascendente del RLO (Página 1601)

200

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.7 Control del flujo de programa

Consultar el bit de estado con instrucciones de salto
Descripción
La tabla siguiente muestra la evaluación de los bits de estado utilizando las instrucciones de
salto:
RLO

BR

CC1

CC0

OV

OS

Nemónicos de la instrucción ejecutada

1

-

-

-

-

-

JC, JCB

0

-

-

-

-

-

JCN, JNB

-

1

-

-

-

-

JBI

-

0

-

-

-

-

JNBI

-

-

0

0

-

-

JZ, JMZ, JPZ

-

-

1

0

-

-

JN, JP, JPZ

-

-

0

1

-

-

JN, JM, JMZ

-

-

1

1

-

-

SPU

-

-

-

-

1

-

JO

-

-

-

-

-

1

JOS

La tabla siguiente muestra la relación entre los bits de estado CC0 y CC1 y las instrucciones
de salto condicionales:
CC1

CC0

Resultado

Nemónicos de la instrucción ejecuta‐
da

0

0

=0

JZ

1o0

0o1

<> 0

JN

1

0

>0

JP

0

1

<0

JM

0o1

0

>= 0

JPZ

0

0o1

<= 0

JMZ

1

1

UO (no válido)

SPU

Consulte también
JU: Salto incondicional (Página 5471)
JC: Saltar si RLO = 1 (Página 5472)
JCN: Saltar si RLO = 0 (Página 5474)
JCB: Saltar si RLO = 1 y guardar RLO (Página 5475)
JNB: Saltar si RLO = 0 y guardar RLO (Página 5476)
JBI: Saltar si BR = 1 (Página 5477)
JNBI: Saltar si BR = 0 (Página 5478)
JO: Saltar si OV = 1 (Página 5479)
JOS: Saltar si OS = 1 (Página 5480)
JZ: Saltar si el resultado es cero (Página 5482)
Programación del PLC
Manual de programación y manejo, 11/2019

201

Principios básicos de la programación
1.7 Control del flujo de programa
JN: Saltar si el resultado no es cero (Página 5483)
JP: Saltar si el resultado es mayor que cero (Página 5485)
JM: Saltar si el resultado es menor que cero (Página 5487)
JPZ: Saltar si el resultado es mayor o igual a cero (Página 5488)
JMZ: Saltar si el resultado es menor o igual a cero (Página 5490)
JUO: Saltar si el resultado no es válido (Página 5492)
JL: Definir lista de saltos (Página 5493)
LOOP: Bucle (Página 5494)
Etiqueta (Página 1688)
JU: Salto incondicional (Página 1689)
JC: Saltar si RLO = 1 (Página 1691)
JCN: Saltar si RLO = 0 (Página 1692)
JCB: Saltar si RLO = 1 y guardar RLO (Página 1693)
JNB: Saltar si RLO = 0 y guardar RLO (Página 1694)
JBI: Saltar si BR = 1 (Página 1695)
JNBI: Saltar si BR = 0 (Página 1696)
JO: Saltar si OV = 1 (Página 1697)
JOS: Saltar si OS = 1 (Página 1699)
JZ: Saltar si el resultado es cero (Página 1700)
JN: Saltar si el resultado no es cero (Página 1702)
JP: Saltar si el resultado es mayor que cero (Página 1703)
JM: Saltar si el resultado es menor que cero (Página 1705)
JPZ: Saltar si el resultado es mayor o igual a cero (Página 1707)
JMZ: Saltar si el resultado es menor o igual a cero (Página 1708)
JUO: Saltar si el resultado no es válido (Página 1710)
JL: Definir lista de saltos (Página 1712)
LOOP: Bucle (Página 1713)

Activar el bit de estado en operaciones lógicas con palabras
Descripción
Las operaciones lógicas con palabras influyen en los bits de estado CC0, CC1 y OV de la
palabra de estado. Los bits de estado se activan únicamente si se utilizan durante el desarrollo
del programa.

202

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.7 Control del flujo de programa
Si en el resultado de una operación lógica con palabras todos los bits son "0", el bit de estado
CC1 se pone a "0". Si por lo menos un bit del resultado es "1", el bit de estado CC1 se pone a
"1".
La siguiente tabla muestra la activación de los bits de estado en operaciones lógicas con
palabras:
Resultado

CC1

CC0

OV

Cero

0

0

0

No cero

1

0

0

Consulte también
AW: Operación lógica Y por palabras (Página 1728)
OW: Operación lógica O por palabras (Página 1730)
XOW: Operación lógica O-exclusiva por palabras (Página 1731)
AD: Operación lógica Y por palabras dobles (Página 1733)
OD: Operación lógica O por palabras dobles (Página 1735)
XOD: Operación lógica O-exclusiva por palabras dobles (Página 1737)

1.7.3

Master Control Relay

1.7.3.1

El MCR (Master Control Relay)

Descripción de la funcionalidad MCR
El Master Control Relay (MCR) activa o desactiva el flujo de señales en una parte del
controlador en los controladores de contactos.
Nota
Observe la información del apartado "Indicaciones importantes sobre el uso de la función MCR
(Página 204)"

ADVERTENCIA
Para evitar el riesgo de daños personales o materiales, no utilice nunca la funcionalidad MCR
para sustituir un Master Control Relay mecánico que esté conectado permanentemente y que
sirva como dispositivo de emergencia o seguridad.

Programación del PLC
Manual de programación y manejo, 11/2019

203

Principios básicos de la programación
1.7 Control del flujo de programa
El MCR afecta a todas las instrucciones que reescriben un valor en la memoria. Si la
dependencia MCR está activada, dichas instrucciones reaccionan independientemente de
que previamente haya una operación lógica binaria o digital.
Para la realización del MCR se dispone de las instrucciones siguientes:
● MCRA: Activar área MCR
● MCR: Abrir áreas MCR
● MCR: Cerrar áreas MCR
● MCRD: Desactivar área MCR
Si el resultado lógico es "1" justo antes de abrir un área MCR, se activa la dependencia MCR
para dicha área. Si el RLO es "0" al abrir el área, el procesamiento en la misma se realiza sin
dependencia MCR.

1.7.3.2

Indicaciones importantes sobre el uso de la función MCR
PRECAUCIÓN
En los bloques en los que se ha activado el Master Control Relay con la instrucción "Activar
área MCR" (MCRA), debe tenerse en cuenta lo siguiente:
● Si el MCR está desactivado, todas las asignaciones escribirán el valor "0" en las secciones
del programa que se encuentran entre las instrucciones "Abrir área MCR" (MCR( ) y
"Cerrar área MCR" ( )MCR).
● El MCR está desactivado cuando el resultado lógico (RLO) es "0" antes de una instrucción
"Abrir área MCR" (MCR( ).

204

Programación del PLC
Manual de programación y manejo, 11/2019

Principios básicos de la programación
1.7 Control del flujo de programa
PELIGRO
STOP de la CPU o comportamiento indefinido del tiempo de ejecución.
Para calcular las direcciones el compilador accede en modo de escritura a los datos locales
que se encuentran después de las variables temporales definidas en VAR_TEMP. Por
consiguiente, las siguientes secuencias de comandos ponen el AS a STOP o provocan un
comportamiento indefinido del tiempo de ejecución (véanse las explicaciones siguientes).
Accesos a parámetros formales
● Accesos a componentes de parámetros FC complejos del tipo STRUCT, tipo de datos
PLC (UDT), ARRAY, STRING
● Accesos a componentes de parámetros FB complejos del tipo STRUCT, tipo de datos PLC
(UDT), ARRAY, STRING del área InOut en un bloque multiinstancia.
● Accesos a parámetros de un FB multiinstancia si su dirección es mayor que 8180.0.
● El acceso a un parámetro del tipo BLOCK_DB dentro del FB multiinstancia abre el DB 0.
Los posteriores accesos a datos ponen la CPU a STOP. Con TIMER, COUNTER,
BLOCK_FC y BLOCK_FB también se utiliza siempre T 0, C 0, FC 0 y FB 0,
respectivamente.
Transferencia de parámetros
Se realiza en las llamadas de bloque en las que se transfieren parámetros.
Solución
Libere los comandos citados de la dependencia MCR:
1. Desactive el Master Control Relay con la instrucción "Desactivar área MCR" (MCRD)
antes de la instrucción o del segmento en cuestión.
2. Active el Master Control Relay con la instrucción "Activar área MCR" (MCRA) después de
la instrucción o del segmento en cuestión.

Programación del PLC
Manual de programación y manejo, 11/2019

205

Principios básicos de la programación
1.7 Control del flujo de programa

206

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.1

2

Resumen de las nuevas funciones de la CPU S7-1200/1500 y
recomendaciones de programación

Mayor rendimiento
Las CPU S7-1500 de las series S7-1200/1500 ofrecen un rendimiento considerablemente
mayor que las CPU de las series S7-300/400. A la hora de realizar la programación con STEP
7 V5.x probablemente estaba acostumbrado a trabajar p. ej. con direccionamiento absoluto
con el fin de conseguir un mayor rendimiento de la CPU y un código del programa más
reducido. Esto ya no es necesario gracias al mayor rendimiento de las CPU de las series
S7-1200/1500. Si desea reusar un código de programa escrito para una CPU S7-300/400 en
una CPU S7-1200/1500-CPU, entonces es probablemente necesario modificar en uno a varios
puntos el código del programa para poder aprovecha plenamente su mayor rendimiento.
En los apartados siguientes le presentamos algunas de la nuevas posibilidades de
programación para las CPU S7-1200/1500.
Aquí encontrará más recomendaciones sobre cómo aumentar el rendimiento: ShopTurnnto
con STEP 7 (TIA Portal) (https://support.industry.siemens.com/cs/ww/es/view/37571372)

Simbología homogénea
La S7-1500 ofrece la posibilidad de utilizar una simbología homogénea en todo el proyecto. La
función de autocompletar ayuda al usuario en función del contexto a la hora de programar con
símbolos dentro de los editores de programación. En la declaración se asigna a los elementos
de datos (p. ej. dentro de un bloque de datos) un nombre simbólico, pero no una dirección fija
dentro del bloque de datos. Esto permite aprovechar al máximo el gran rendimiento de la
S7-1500 cuando se accede a dichos elementos de datos. Las direcciones absolutas de los
operandos ya no tienen que conocerse, con lo que se evitan errores de acceso.
El código del programa se hace más comprensible gracias a los símbolos y se reduce la
necesidad de introducir comentarios. Cuando se corrige la simbología se actualizan
automáticamente todas las ubicaciones.
Nota
Encontrará más información sobre el uso de la simbología homogénea en:
¿Cómo se direcciona simbólicamente?
Direccionamiento simbólico (Página 211)

Programación del PLC
Manual de programación y manejo, 11/2019

207

Recomendaciones de programación
2.1 Resumen de las nuevas funciones de la CPU S7-1200/1500 y recomendaciones de programación

Acceso optimizado al bloque
Con un acceso optimizado al bloque, los elementos de datos declarados se disponen
automáticamente en el área de memoria disponible del bloque de manera que se aproveche
al máximo la capacidad de este último. Los datos se estructuran y depositan de una manera
óptima para la CPU utilizada. Del almacenamiento se encarga el sistema. En la declaración se
asigna a los elementos de datos un nombre simbólico con el que se llama la variable dentro del
bloque. Esto se traduce en un mayor rendimiento de la CPU. Se excluyen los errores de
acceso, p. ej. desde la HMI.

6,(0(16

$FFHVRVDEORTXHVHQODFRPSDUDFLµQ
(VW£QGDU!2SWLPL]DGR

*HVWLµQGHGDWRV

$FFHVRHVW£QGDUDOEORTXH
6FRPSDWLEOH
FRQ6

$FFHVRRSWLPL]DGRDOEORTXH
VROR6

/DVYDULDEOHVVHSXHGHQGLUHFFLRQDUWDQWR
GHIRUPDVLPEµOLFD FRQRSWLPL]DFLµQGH
PHPRULD FRPRDEVROXWD GHILQLGDSRUHO
XVXDULR 

(OVLVWHPDVHHQFDUJDGHJHVWLRQDU\
RSWLPL]DUHODOPDFHQDPLHQWRGHGDWRV'H
HVHPRGRVHDSURYHFKDDOP£[LPROD
FDSDFLGDGGHPHPRULD

5HQGLPLHQWR

(ODFFHVRDXQD&38GHODVVHULHV
6QRVLHPSUHHVHOP£V
U£SLGRSRVLEOH\DTXHHODOPDFHQD
PLHQWRGHGDWRVSXHGHQRVHUHIHFWLYR
GHELGRDOGLUHFFLRQDPLHQWRDEVROXWR

(ODFFHVRVLHPSUHHVHOP£VU£SLGR
SRVLEOH\DTXHHOVLVWHPDRSWLPL]DHO
DOPDFHQDPLHQWRGHGDWRV\QRVH
DVLJQDQGLUHFFLRQHVILMDV

)UHFXHQFLDGHHUURUHV

(OGLUHFFLRQDPLHQWRDEVROXWR SHM
GHVGH+0,RFRQGLUHFFLRQDPLHQWR
LQGLUHFWR SXHGHSURYRFDULQFRKHUHQ
FLDVVLVHFDPELDODGLUHFFLµQILMD

6HH[FOX\HQORVHUURUHVGHDFFHVRS
HMHQFDVRGHGLUHFFLRQDPLHQWR
LQGLUHFWRRGHVGHOD+0,\DTXHVH
DFFHGHVLPEµOLFDPHQWH

5HPDQHQFLD

9£OLGRSDUDWRGDVODVYDULDEOHVGHXQ
EORTXHGHGDWRV

9£OLGRSDUDYDULDEOHVLQGLYLGXDOHV

5HFRPHQGDFLµQ
3DUDFRQVHJXLUHOPHMRUUHQGLPLHQWRSRVLEOHVHUHFRPLHQGDQRPH]FODUORVWLSRVGHDFFHVRDEORTXHVGHQWURGHOSURJUD
PD

Nota
Encontrará más información sobre bloques con acceso optimizado aquí:
Bloques con acceso optimizado (Página 54)

208

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.1 Resumen de las nuevas funciones de la CPU S7-1200/1500 y recomendaciones de programación

Nuevos tipos de datos
Los nuevos tipos de datos LWORD, LINT, ULINT, LTIME, LTOD, LDT y ARRAY (límite de 32
bits) ofrecen una precisión de cálculo considerablemente superior cuando se utilizan funciones
matemáticas. Las posibilidades en cuanto a la conversión implícita y explícita de datos son
mayores que las de las CPUs de las series S7-300/400.
Nota
Encontrará más información sobre los nuevos tipos de datos aquí:
Vista general de los tipos de datos válidos (Página 241)

Tipos de datos PLC
Los tipos de datos PLC (UDT) son estructuras de datos definidas por el usuario que pueden
utilizarse varias veces en el programa. La estructura de un tipo de datos PLC consta de varios
componentes, que pueden pertenecer a diferentes tipos de datos. El tipo de los componentes
se define en la declaración del tipo de datos PLC.
El tipo de datos PLC puede utilizarse como tipo de datos básico para la definición de variables
y como plantilla para crear bloques de datos globales. Si se realizan a posteriori cambios en el
tipo de datos PLC, estos se aplican automáticamente a todas las ubicaciones.
También es posible acceder simbólicamente a diferentes elementos de un ARRAY dentro de
un tipo de datos PLC.
Nota
Encontrará más información sobre los tipos de datos PLC aquí:
¿En qué consiste un tipo de datos PLC y cómo se declara en el programa?
● Tipos de datos PLC (UDT) (Página 283)
Encontrará recomendaciones de programación sobre el tipo de datos PLC aquí:
● Uso de tipos de datos PLC (UDT) (Página 232)
● Uso del tipo de datos DB_ANY (Página 216)

Instrucciones unitarias en todos los lenguajes de programación
Está disponible un juego unitario de instrucciones en todos los lenguajes de programación
(KOP, FUP, AWL, SCL y GRAPH).

Programación del PLC
Manual de programación y manejo, 11/2019

209

Recomendaciones de programación
2.1 Resumen de las nuevas funciones de la CPU S7-1200/1500 y recomendaciones de programación

Accesos Slice
Los accesos Slice permiten direccionar áreas de forma selectiva dentro de variables
declaradas. El acceso simbólico a un solo bit es posible hasta el nivel de variable. El bit en
concreto se llama de forma absoluta.
Nota
Encontrará más información sobre los accesos Slice en:
¿Cómo se direcciona con accesos Slice?
● Direccionar áreas de una variable con accesos Slice (Página 116)
● Fundamentos del acceso a bloques (Página 54)

Direccionamiento indirecto
El direccionamiento indirecto ofrece la posibilidad de direccionar operandos cuya dirección no
se calcula hasta el momento de la ejecución. En todos los lenguajes de programación hay
disponibles posibilidades generales, como el direccionamiento indirecto mediante POINTER,
por ejemplo. En los lenguajes de programación AWL y SCL, además, es posible utilizar
también las instrucciones PEEK y POKE.
Nota
Encontrará más información sobre el direccionamiento indirecto aquí:
Direccionamiento indirecto (Página 121)

Librería "Sample Library for Instructions"
Como ayuda para la programación, utilice "Sample Library for Instructions". Aquí encontrará
ejemplos de programación prácticos y fácilmente comprensibles para SIMATIC S7-1500 y
S7-1200 en el lenguaje de programación KOP. Los ejemplos se pueden agregar fácilmente al
programa para usarlos dentro del mismo.
Nota
Encontrará más información sobre los ejemplos de programación aquí:
Sample Library for Instructions (Página 615)

210

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.2 Direccionamiento simbólico

Otras recomendaciones de programación
Encontrará más información sobre recomendaciones de programación y una guía y un manual
de estilo de programación en el Siemens Industry Online Support en:
● FAQ: Recomendaciones de programación (http://support.automation.siemens.com/WW/
llisapi.dll?aktprim=0&lang=es&referer=%2fWW
%2f&func=cslib.csinfo&siteid=csius&Datakey=47071380&extranet=standard&groupid=40
00002&viewreg=WW&nodeid0=29156492&objaction=csopen)
● Contexto y descripciones del sistema en la Guía y manual de estilo de programación
(https://support.industry.siemens.com/cs/document/81318674/gu%C3%ADa-deprogramaci%C3%B3n-para-s7-12001500?dti=0&lc=es-WW)

2.2

Direccionamiento simbólico

Ventajas del direccionamiento simbólico
El uso homogéneo de símbolos autoexplicativos en todo el proyecto hace que el código del
programa sea más comprensible y fácil de leer.
Las ventajas resultantes son las siguientes:
● Ya no es necesario escribir comentarios amplios.
● El acceso a datos es más rápido.
● No se producen errores al acceder a datos.
● Ya no es necesario trabajar con direcciones absolutas.
● STEP 7 supervisa la asignación del símbolo al área de memoria, es decir, cuando cambia
el nombre o la dirección de una variable se actualizan automáticamente todos los lugares
de uso (ubicaciones).

Programación en STEP 7 V5.x
En STEP 7 V5.x ya existía la posibilidad de escribir el programa de forma clara utilizando
nombres autoexplicativos para operandos y bloques. Para ello se asignaban los operandos
simbólicos a las áreas de memoria y los bloques en la tabla de símbolos. Para que un cambio
en la simbología repercutiera también en el código del programa del editor de programación,
había que determinar mediante la propiedad "Operandos preferentes" si debía ser
determinante el símbolo o el valor absoluto.
El direccionamiento simbólico permitía mejorar la claridad del programa. No obstante, en
algunos casos, p. ej. al programar con tipos de datos definidos por el usuario (UDT), el
direccionamiento simbólico podía afectar al rendimiento.
Para aumentar el rendimiento había que ignorar la simbología en UDT y direccionar de forma
absoluta. Pero para ello era necesario conocer la ubicación de los datos. Los cambios en UDT
no se aplicaban automáticamente. Por medio del direccionamiento absoluto también era
posible acceder a partes de una variable y editarlas. Sin embargo, el inconveniente de un
direccionamiento absoluto exclusivo era que el código del programa se volvía confuso a partir
de cierto volumen y había que introducir comentarios adicionales para orientarse mejor.

Programación del PLC
Manual de programación y manejo, 11/2019

211

Recomendaciones de programación
2.2 Direccionamiento simbólico

Procedimiento en STEP 7 TIA Portal
La CPU S7-1500 ofrece un rendimiento considerablemente mayor que las CPU S7-300/400.
Para poder beneficiarse al máximo este gran rendimiento, recomendamos activar el acceso
optimizado para todos los bloques y utilizar direcciones simbólicas en el código del programa.
Al trabajar con símbolos, el editor de programación asiste al usuario mediante ayudas
contextuales a las entradas, como la función de autocompletar. De ese modo es posible
acceder cómodamente a variables o instrucciones existentes durante la programación.

Ejemplo de programación
El ejemplo siguiente muestra la forma de acceder simbólicamente a diferentes elementos:

Los nombres de variables definidos en la interfaz del bloque pueden utilizarse directamente en
los parámetros de la instrucción TON sin conocer la dirección absoluta de las variables.

Consulte también
Ajustar el acceso a un bloque (Página 56)
Fundamentos del acceso a bloques (Página 54)
Direccionar áreas de una variable con accesos Slice (Página 116)
Direccionar variables globales (Página 109)
Direccionar variables en bloques de datos globales (Página 112)
Utilizar la función automática de autocompletar (Página 7682)

212

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.3 Direccionar indirectamente elementos de ARRAY

2.3

Direccionar indirectamente elementos de ARRAY

Realizar accesos de ARRAY en el TIA Portal con índice variable
Es recomendable utilizar un ARRAY cuando deben procesarse datos conexos del mismo tipo.
Como índices para direccionar los elementos de ARRAY se pueden especificar constantes o
variables del tipo de datos Entero. Se admiten enteros de una longitud de hasta 32 bits.
En caso de direccionamiento indirecto con una variable, el índice no se calcula hasta que no
se ejecuta el programa. Así se puede utilizar un índice diferente para cada ejecución, p. ej. en
bucles de programa. También es posible acceder a un ARRAY dentro de un tipo de datos PLC
(UDT).
Las ventajas resultantes son las siguientes:
● No se requiere direccionamiento con registros de direcciones ni con punteros creados por
el usuario, como p. ej. un puntero ANY.
● Más flexibilidad dentro del programa.
● El índice variable está disponible en todos los lenguajes de programación de STEP 7.
● Se utilizan los nombres existentes de los bloques de datos y las variables ARRAY
(direccionamiento simbólico). De este modo se aumenta la legibilidad del código del
programa.
● No es necesario conocer la dirección básica del ARRAY.
● El código del programa resulta más fácil de crear y el compilador genera un código de
programa optimizado.

Procedimiento en STEP 7 V5.x
Para direccionar elementos de ARRAY de forma indirecta, en STEP 7 V5.x había que utilizar
registros de direcciones mediante POINTER propios. Al hacerlo, debía tenerse en cuenta lo
siguiente:
● El nombre del ARRAY no se utilizaba. Esto reducía la legibilidad del código del programa
y obligaba a introducir comentarios.
● La dirección básica del ARRAY tenía que conocerse para el direccionamiento.
El lenguaje de programación SCL ya soportaba el direccionamiento indirecto con un índice
variable.

Ejemplo de programación en STEP 7 V5.x
Para el siguiente ejemplo en AWL se requiere el bloque de datos "Data_classic". Para llamar
a un elemento del ARRAY "Quantities" deben utilizarse los comandos siguientes:
AWL

Explicación

OPN "Data_classic"

// Se llama el bloque de datos "Data_classic".

L #index

// El valor de la variable local #index se carga en el
acumulador 1.

Programación del PLC
Manual de programación y manejo, 11/2019

213

Recomendaciones de programación
2.3 Direccionar indirectamente elementos de ARRAY
AWL

Explicación

SLD 3

// Desplazar los bits 0 a 31 del acumulador 1 tres posiciones a la izquierda.
// Rellenar las posiciones liberadas con ceros.

LAR1

// Cargar el contenido del acumulador 1 en el registro
de direcciones 1.

L DBW [AR1, P#10.0]

// Cargar en el acumulador 1 el elemento de ARRAY direccionado mediante #index.
// P#10.0 = dirección básica del campo

Ejemplo de programación en STEP 7 TIA Portal
El ejemplo siguiente presenta el direccionamiento indirecto de un elemento de ARRAY en AWL
con el TIA Portal.
Cree para ello un bloque de datos global:
1. Haga doble clic en el comando "Agregar nuevo bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
2. Haga clic en el botón "Bloque de datos (DB)".
3. Introduzca el nombre "DB_Quantities".
4. Seleccione "DB ARRAY" como tipo de bloque de datos.
5. Seleccione "DINT" como tipo de datos.
6. Introduzca "10" como límite superior de ARRAY.
7. Haga clic en "Aceptar".

214

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.3 Direccionar indirectamente elementos de ARRAY

1. Cree un bloque de función y llámelo "FB_Quantities".
2. Declare la interfaz del bloque de la manera siguiente:

3. Escriba el siguiente código de programa:

Para direccionar un elemento de ARRAY se requiere únicamente una línea del programa
en el TIA Portal. El valor del elemento de ARRAY #index se carga en el acumulador 1
directamente desde el bloque de datos.
4. Llame el bloque de función "FB_Quantities" en el OB1 y asigne un índice entre 0 y 10:

Para obtener el mejor rendimiento posible deben observarse las indicaciones siguientes:
● Las variables que se utilizan como índice de ARRAY deben declararse como entero menor
o igual a 32 bits.
● Los resultados intermedios y los índices de ARRAY deben crearse en el área temporal de
datos locales.

Programación del PLC
Manual de programación y manejo, 11/2019

215

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY

Consulte también
Direccionamiento indirecto de componentes de ARRAY (Página 139)
Principios básicos del ARRAY (Página 293)
ARRAY (Página 293)
Direccionamiento indirecto en AWL (Página 140)
Direccionamiento indirecto en SCL (Página 137)

2.4

Uso del tipo de datos DB_ANY

Uso del tipo de datos DB_ANY (S7-1200/1500)
El tipo de datos DB_ANY sirve para identificar un bloque de datos cualquiera. En las CPU de
las series S7-1200/1500 es posible acceder a un bloque de datos que todavía no existe en el
momento de la programación. Para ello se crea un parámetro de bloque del tipo de datos
DB_ANY en la interfaz del bloque que accede. A dicho parámetro se transfiere en tiempo de
ejecución el nombre del bloque de datos o una variable del tipo de datos DB_ANY asignada
previamente al nombre del bloque de datos. Las instrucciones siguientes permiten procesar el
contenido de un bloque de datos mediante el uso de símbolos:
● VARIANT_TO_DB_ANY: Convertir VARIANT en DB_ANY
● DB_ANY_TO_VARIANT: Convertir DB_ANY en VARIANT
Encontrará más información sobre las instrucciones en "Instrucciones básicas > AWL/SCL >
Conversión > VARIANT".
La ventaja de este procedimiento es que: es posible crear el código del programa antes de
saber el bloque de datos que se procesará.
Para este ejemplo se requieren los siguientes objetos:

216

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY

Ejemplo de programación
El siguiente ejemplo muestra cómo utilizar el tipo de datos DB_ANY:
Una punzonadora puede perforar diferentes figuras geométricas. Las peticiones de
punzonado se transfieren a la máquina y, para cada petición individual, hay datos de petición
específicos. Los datos de la petición difieren tanto en el tipo como en los valores.

Programación del PLC
Manual de programación y manejo, 11/2019

217

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY

Procedimiento para crear los tipos de datos PLC
En la primera petición debe punzonarse un orificio redondo en una chapa. Para que la
punzonadora pueda ejecutar esta petición se requieren las coordenadas del punto medio y el
radio del orificio. Estos datos de petición pueden transferirse a la punzonadora agrupados en
un tipo de datos PLC (UDT).
8'7B+ROH

<

5DGLXV





0 



;








Cree el tipo de datos PLC "UDT_Hole" para transferir los datos de la petición:
1. En el árbol del proyecto, dentro de la carpeta "Tipos de datos PLC", haga doble clic en el
comando "Agregar nuevo tipo de datos".
Para crear un tipo de datos PLC se crea y se abre una tabla de declaración nueva.
2. Declare las siguientes líneas en el tipo de datos PLC:
X-coordinate > REAL
Y-coordinate > REAL
Diameter > REAL

En la segunda petición debe punzonarse un rectángulo en una chapa. Para esta petición se
requieren dos coordenadas, una de las cuales marca el punto superior izquierdo y la otra el
punto inferior derecho del rectángulo. Estos datos de petición pueden transferirse a la
punzonadora agrupados en el tipo de datos PLC "UDT_RectangleWindowStatic".

218

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY
8'7B5HFWDQJOH:LQGRZ6WDWLF

<
% 







$ 


;












Cree el tipo de datos PLC "UDT_RectangleWindowStatic":
1. En el árbol del proyecto, dentro de la carpeta "Tipos de datos PLC", haga doble clic en el
comando "Agregar nuevo tipo de datos".
Para crear un tipo de datos PLC se crea y se abre una tabla de declaración nueva.
2. Declare las siguientes líneas en el tipo de datos PLC:
X1-coordinate > REAL
Y1-coordinate > REAL
X2-coordinate > REAL
Y2-coordinate > REAL

Con los datos de petición de "UDT_RectangleWindowStatic" solo es posible punzonar
rectángulos cuyos bordes sean paralelos a los ejes x e y.
Si desea punzonar un rectángulo con una alineación cualquiera, es decir, que no sea paralelo
a los ejes x e y, necesitará un tipo de datos PLC adicional. En él puede indicar, por ejemplo, la
altura y anchura, así como la alineación del rectángulo respecto del eje de la x por medio de
un ángulo.

Programación del PLC
Manual de programación y manejo, 11/2019

219

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY
8'7B5HFWDQJOH:LQGRZ)OH[LEOH

<




GW K

+H

L JK

W

:L


0 
༾




;














Cree el tipo de datos PLC "UDT_RectangleWindowFlexible":
1. En el árbol del proyecto, dentro de la carpeta "Tipos de datos PLC", haga doble clic en el
comando "Agregar nuevo tipo de datos".
Para crear un tipo de datos PLC se crea y se abre una tabla de declaración nueva.
2. Declare las siguientes líneas en el tipo de datos PLC:
X-coordinate > REAL
Y-coordinate > REAL
Height > REAL
Width > REAL
Angle > REAL

Las coordenadas x e y indican el centro del rectángulo.

220

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY

Procedimiento para crear los bloques de datos
En el apartado siguiente se explica la forma de transferir a la punzonadora las figuras
geométricas sencillas cuyos datos de petición se han registrado en los tipos de datos PLC. La
peticiones de punzonado se descomponen en golpes individuales dentro del código del
programa, los cuales son ejecutados en orden por la punzonadora. La punzonadora tiene una
mesa en cruz sobre la que está fijada una chapa. Una mesa en cruz puede moverse a lo largo
del eje de la x o de la y, como en un sistema de coordenadas. La mesa en cruz se mueve
utilizando dos motores. La herramienta tiene diferentes insertos para poder punzonar formas
distintas en la chapa, como círculos y rectángulos de diferente tamaño. Además, la
herramienta puede girarse en un máximo de 90° para que no solo puedan punzonarse
rectángulos de una alineación.
Los tipos de datos PLC se utilizan ahora para crear varios bloque de datos de instancia. A
continuación, el bloque de datos de instancia contiene los valores concretos para un orificio,
por ejemplo.
Cree el bloque de datos de instancia "DB_OrderHole":
1. Vaya a la carpeta "Bloques de programa" y haga doble clic en el comando "Agregar nuevo
bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
1. Haga clic en el botón "Bloque de datos (DB)".
2. Introduzca el nombre "DB_OrderHole".
3. Seleccione "UDT_Hole" como tipo de bloque de datos.
4. Haga clic en "Aceptar".
Introduzca los valores de arranque correspondientes:

Ahora, para fabricar una pieza de chapa concreta, p. ej. la pared lateral de un armario de
distribución, se cargan las figuras geométricas necesarias en la punzonadora. Para ello se
crea otro bloque de datos que incluye una lista de bloques de datos.
Cree el bloque de datos "DB_OrderList":
1. Haga doble clic en el comando "Agregar nuevo bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
2. Haga clic en el botón "Bloque de datos (DB)".
3. Introduzca el nombre "DB_OrderList".
4. Seleccione "DB global" como tipo de bloque de datos.
5. Haga clic en "Aceptar".
Programación del PLC
Manual de programación y manejo, 11/2019

221

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY

Cree la lista de peticiones siguiente dentro del bloque de datos:

Procedimiento para crear el código del programa
Para cada tipo de orden (petición) se crea una función propia. En ellas, las órdenes de
punzonado se descomponen en golpes individuales y se agrupan en un ARRAY.
1. Cree el tipo de datos PLC "UDT_Punch".
2. Haga doble clic en el comando "Agregar nuevo tipo de datos" en "Tipos de datos PLC".
Se crea un tipo de datos PLC nuevo con el nombre "Tipo_de_datos_de_usuario_x".
3. Cambie el nombre del tipo de datos PLC por "UDT_Punch".
4. Declare las siguientes líneas en el tipo de datos PLC:
Tool > DINT
x > REAL
y > REAL
w > REAL

5. Cree el bloque de datos ARRAY "DB_PunchList".

222

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY
Para preparar la orden de punzonado para un orificio, cree una función SCL y llámela
"FC_PrepareHole".
1. Declare la interfaz del bloque de la manera siguiente:

2. Escriba el siguiente código:

Programación del PLC
Manual de programación y manejo, 11/2019

223

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY
Para preparar la orden de punzonado para una ventana se requiere una función que
componga la orden de punzonado a partir de cuatro series de golpes. Cree una función SCL
y llámela "FC_PrepareWindowStatic".
1. Declare la interfaz del bloque de la manera siguiente:

2. Escriba el siguiente código:

224

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY

Programación del PLC
Manual de programación y manejo, 11/2019

225

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY
Para preparar la orden de punzonado para una ventana se requiere una función que
componga la orden de punzonado a partir de cuatro series de golpes. Cree una función SCL
y llámela "FC_PrepareWindowFlexible".
1. Declare la interfaz del bloque de la manera siguiente:

2. Escriba el siguiente código:

Ahora, la punzonadora debe empezar a procesar las peticiones. Si ya lo está haciendo, debe
tomar la próxima petición de la lista y prepararla.
1. Cree un bloque de función SCL.
2. Haga doble clic en el comando "Agregar nuevo bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".

226

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY
3. Haga clic en el botón "Bloque de función (FB)".
4. Introduzca el nombre "FB_PrepareNextOrder".
5. Declare la interfaz del bloque de la manera siguiente:

6. Declare la variable global "AllOrdersDone":
7. Escriba el siguiente código:

La próxima petición de la lista se prepara, lo que significa que la petición de punzonado actual
se descompone en golpes individuales. Para ello, la punzonadora debe saber qué petición de
punzonado hay.
1. Cree una función SCL.
2. Haga doble clic en el comando "Agregar nuevo bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
3. Haga clic en el botón "Función (FC)".
4. Introduzca el nombre "FC_PrepareOrder".

Programación del PLC
Manual de programación y manejo, 11/2019

227

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY
5. Declare la interfaz del bloque de la manera siguiente:

6. Escriba el siguiente código:

En el bloque de función SCL "FB_PrepareNextOrder" llame a la función SCL
"FC_PrepareOrder".

Llame a continuación a la "FB_PrepareNextOrder" en el OB1:

228

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY

Además de la posibilidad de cargar las órdenes con ayuda del bloque de datos "DB_OrderList"
en una secuencia fija en la punzonadora, como se describe más arriba, la lista de órdenes
también podría generarse dinámicamente. O también podría existir, por ejemplo, una
selección de distintas listas de órdenes. Después de haber procesado una lista de órdenes
cabría la posibilidad de cargar una nueva lista de órdenes en la punzonadora. Para este modo
de funcionamiento se requiere el siguiente código adicional.
Cree un bloque de datos de instancia del bloque de función "FB_PrepareNextOrder".
1. Vaya a la carpeta "Bloques de programa" y haga doble clic en el comando "Agregar nuevo
bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
2. Haga clic en el botón "Bloque de datos (DB)".
3. Introduzca el nombre "DB_FB_PrepareNextOrder".
4. Seleccione "FB_PrepareNextOrder" como tipo de bloque de datos.
5. Haga clic en "Aceptar".

Programación del PLC
Manual de programación y manejo, 11/2019

229

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY
Para cambiar la lista de órdenes, cree otra función SCL:
1. Cree la función SCL "FC_SwapOrderList".
2. Declare la interfaz del bloque de la manera siguiente:

3. Declare la variable global "NewModelNr":
4. Escriba el siguiente código:

Cree el bloque de datos "DB_OrderRepository":
1. Vaya a la carpeta "Bloques de programa" y haga doble clic en el comando "Agregar nuevo
bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
2. Haga clic en el botón "Bloque de datos (DB)".
3. Introduzca el nombre "DB_OrderRepository".
4. Seleccione "DB global" como tipo de bloque de datos.
5. Haga clic en "Aceptar".

230

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.4 Uso del tipo de datos DB_ANY

Llame a continuación a la "FC_SwapOrderList" en el OB1:

Resultado
Este ejemplo muestra cómo utilizar la instrucción "DB_ANY_TO_VARIANT: Convertir DB_ANY
en VARIANT" para determinar el tipo de datos PLC de un bloque de datos y cómo seleccionar
y ejecutar una función adecuada sobre esta base.

Consulte también
Direccionar variables en bloques de datos globales (Página 112)

Programación del PLC
Manual de programación y manejo, 11/2019

231

Recomendaciones de programación
2.5 Uso de tipos de datos PLC (UDT)

2.5

Uso de tipos de datos PLC (UDT)

Uso de un tipo de datos PLC
Los tipos de datos PLC (UDT) son estructuras de datos definidas por el usuario que pueden
utilizarse varias veces en el programa. La estructura puede estar formada por varios
elementos de diferentes tipos de datos. Los tipos de datos de los diferentes elementos se
definen al declarar un tipo de datos PLC.
Los tipos de datos PLC suelen utilizarse cuando se requiere un juego de datos conexo con
diferentes tipos de datos y debe procesarse desde diferentes puntos del programa. Pueden
ser, p. ej.:
● juegos de datos para seguimiento de material
● juegos de parámetros para un ajuste del motor
● recetas
El uso de tipos de datos PLC conlleva las ventajas siguientes:
● Los elementos de un tipo de datos PLC también pueden direccionarse indirectamente, es
decir, la dirección es variable y no se calcula hasta el momento de la ejecución.
● Las variables que se basan en un tipo de datos PLC heredan todas las propiedades del
mismo. De este modo, cuando se cambia el tipo de datos PLC se adaptan automáticamente
todas las variables que se basan en dicho tipo de datos PLC.
● Gracias al uso homogéneo de símbolos resulta más fácil leer el programa, pues los
nombres de los diferentes elementos de un tipo de datos PLC se muestran en el programa.
● Se aprovecha al máximo el elevado rendimiento de una CPU S7-1500.
● Al llamar el bloque es posible transferir el tipo de datos PLC como estructura completa.
● La interfaz de llamada es más simple gracias al menor número de parámetros que deben
recibir valores.

Procedimiento en STEP 7 V5.x
En STEP 7 V5.x ya existía la posibilidad de crear un juego de datos como variable estructurada
utilizando el tipo de datos STRUCT o un tipo de datos PLC (UDT). Sin embargo, el uso del
direccionamiento simbólico perjudicaba el rendimiento.
La declaración en los bloques de datos solía realizarse como estructura anónima. En ese caso,
los bloques propiamente dichos se programaban de modo que se transferían como
parámetros actuales los valores de la estructura y los valores calculados se copiaban de nuevo
en la estructura. Eso permitía transferir también el número del bloque de datos y direccionarlo
de forma absoluta en el bloque. El número de parámetros que debían rellenarse solía ser muy
grande. Los datos actuales se depositaban en los bloques de datos y los valores calculados se
transferían a otros bloques. No obstante, a la hora de transferir las variables del bloque de
datos ya no estaban disponibles los símbolos.

232

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.5 Uso de tipos de datos PLC (UDT)

Ejemplo de programación en STEP 7 TIA Portal
A un tipo de datos PLC es posible asignarle tanto un parámetro formal como un parámetro
actual. Con ello ya no hace falta declarar parámetros individuales. Si un bloque tiene un
parámetro de entrada basado en un tipo de datos PLC, es necesario transferir como parámetro
actual una variable que sea del mismo tipo de datos PLC.
El ejemplo siguiente muestra la llamada y parametrización de un bloque de función (FB) con
dos parámetros formales:
1. Cree un tipo de datos PLC haciendo doble clic en el comando "Agregar nuevo tipo de datos"
de la carpeta "Tipos de datos PLC", dentro del árbol del proyecto.
Para crear un tipo de datos PLC se crea y se abre una tabla de declaración nueva.
2. Cambie el nombre del tipo de datos PLC por "UDT_Material".
3. Declare las siguientes líneas dentro del tipo de datos PLC:
ArticleNumber > Tipo de datos: DINT
ArticleName > Tipo de datos: STRING
Amount > Tipo de datos: REAL
Unit > Tipo de datos: STRING

Utilice el tipo de datos PLC dentro de un bloque de datos global. El tipo de datos PLC puede
indicarse directamente como tipo de datos del bloque de datos o bien como tipo de datos de
una variable dentro del bloque de datos.
Cree para ello un bloque de datos global:
1. Haga doble clic en el comando "Agregar nuevo bloque".
Se abre el cuadro de diálogo "Agregar nuevo bloque".
2. Haga clic en el botón "Bloque de datos (DB)".
3. Introduzca el nombre "DB_MaterialBuffer".
4. Seleccione "DB ARRAY" como tipo de bloque de datos.
5. Como tipo de datos ARRAY, seleccione el tipo de datos PLC "UDT_Material".

Programación del PLC
Manual de programación y manejo, 11/2019

233

Recomendaciones de programación
2.5 Uso de tipos de datos PLC (UDT)
6. Introduzca "1000" como límite superior del ARRAY.
7. Haga clic en "Aceptar".

En la llamada del bloque de función, interconecte los parámetros formales con variables del
bloque de datos global "DB_MaterialBuffer".
1. Cree un bloque de función SCL y llámelo "FB_Material".
2. Declare la interfaz del bloque de la manera siguiente:

234

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.6 Uso de instrucciones MOVE en AWL
3. Escriba el siguiente código de programa:

4. Llame el bloque de función "FB_Material" en el OB1 e interconecte los parámetros formales
con variables del bloque de datos global "DB_MaterialBuffer":

Los datos de material se desplazan dentro del bloque de datos global "DB_MaterialBuffer".

Consulte también
Información importante sobre variables PLC estructuradas (Página 7904)
Crear variables PLC estructuradas (Página 7907)
Reglas para el suministro de parámetros de bloque (Página 80)
Principios básicos de los tipos de datos PLC (UDT) (Página 283)
Tipos de datos PLC (UDT) (Página 283)

2.6

Uso de instrucciones MOVE en AWL

Usos posibles
Ahora, en una CPU S7-1500 también es posible programar instrucciones MOVE en AWL.

Programación del PLC
Manual de programación y manejo, 11/2019

235

Recomendaciones de programación
2.6 Uso de instrucciones MOVE en AWL
Las ventajas resultantes son las siguientes:
● Es posible crear una estructura de programa más sencilla.
● El rendimiento de la CPU aumenta.

Programación en STEP 7 V5.x
En STEP 7 V5.x, para implementar las funciones de MOVE se utilizaban las funciones de
sistema "BLKMOV: Copiar área" y "UBLKMOV: Copiar área sin interrupciones".

Procedimiento en STEP 7 TIA Portal
En STEP 7 TIA Portal están disponibles las siguientes instrucciones MOVE nuevas:
● MOVE: Copiar valor
● MOVE_BLK: Copiar área
● MOVE_BLK_VARIANT: Copiar área
● UMOVE_BLK: Copiar área sin interrupciones

Ejemplo de programación
El siguiente ejemplo muestra el uso de la instrucción "MOVE_BLK: Copiar área". Para ello se
copia un área de un ARRAY en otra:

236

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.7 Uso de temporizadores y contadores CEI

La instrucción MOVE_BLK permite copiar 10 elementos del "Array_1" del bloque de datos
"Data_DB" en el "Array_2" del mismo bloque de datos.

Consulte también
MOVE: Copiar valor (Página 1421)
MOVE_BLK: Copiar área (Página 1434)
MOVE_BLK_VARIANT: Copiar área (Página 1436)
UMOVE_BLK: Copiar área sin interrupciones (Página 1441)

2.7

Uso de temporizadores y contadores CEI

Ventajas de los temporizadores y contadores CEI
Gracias al uso homogéneo de temporizadores y contadores CEI, el código del programa se
vuelve más efectivo.
Las ventajas resultantes son las siguientes:
● Los bloques pueden llamarse repetidas veces cada vez con nuevos bloques de datos de
instancia.
● Los contadores CEI disponen de un amplio rango de contaje.
● Los temporizadores CEI presentan un mayor rendimiento y una mayor precisión de tiempo
que los temporizadores S5.

Programación en STEP 7 V5.x
Los temporizadores y contadores S5 de STEP 7 V5.x se direccionaban de forma absoluta
utilizando un número. Debido a la dependencia del número no era posible utilizar varias veces
bloques de programa con temporizadores y contadores S5.
El rango de valores de un temporizador estaba limitado a 9990s como máximo y el de un
contador a un valor límite máximo de 999.

Programación del PLC
Manual de programación y manejo, 11/2019

237

Recomendaciones de programación
2.7 Uso de temporizadores y contadores CEI

Procedimiento en STEP 7 TIA Portal
Los temporizadores y contadores CEI deben declararse en el bloque de programa en el que se
llamarán y utilizarán. El temporizador CEI es una estructura del tipo de datos IEC_TIMER,
IEC_LTIMER, o p. ej. TON_TIME y TON_LTIME, que también puede declararse como variable
local en un bloque. El contador IEC es una estructura del tipo de datos IEC_SCOUNTER,
IEC_USCOUNTER, etc.

Ejemplos de programas en el TIA Portal
El ejemplo siguiente muestra la forma de declarar un temporizador CEI y un contador CEI
como variable local:

Los datos del temporizador CEI TON y del contador CEI CTU se depositan en la interfaz del
bloque como variable local (multiinstancia).

238

Programación del PLC
Manual de programación y manejo, 11/2019

Recomendaciones de programación
2.7 Uso de temporizadores y contadores CEI
También es posible crear temporizadores CEI y contadores CEI como multiinstancias en
estructuras y utilizarlas después en el código del programa.
1. Para ello se crea un bloque de datos global con un ARRAY of TON. El tipo de datos TON
no aparece en la lista desplegable pero puede introducirse manualmente:

2. Cree un bloque de función y arrastre la instrucción "TON: Retardo al conectar" a un
segmento. Llame la instancia del temporizador CEI TON de la manera siguiente:

Llamada de un temporizador como multiinstancia
Si desea utilizar el parámetro IN para iniciar un temporizador como multiinstancia, no debe
inicializarlo previamente en el código del programa. En este caso, el temporizador que se llama
a continuación ya no detecta un flanco de señal ascendente en el parámetro IN y no se inicia:
1. Defina el tiempo "Time_1" como multiinstancia del tipo de datos "TP_TIME" en la sección
"Static" de la interfaz del bloque.
2. Escriba el siguiente código de programa:
AWL

Explicación

A "Tag_Output"

// Si la salida "Tag_Output" obtiene el
estado lógico 1, entonces

Programación del PLC
Manual de programación y manejo, 11/2019

239

Recomendaciones de programación
2.7 Uso de temporizadores y contadores CEI
AWL

Explicación

= #Time_1.IN

// el parámetro IN de la multiinstancia
Temporizador #Tiempo_1 se inicializa con
un flanco de señal ascendente.

CALL #Time_1

// Si ahora se llama la multiinstancia
Temporizador y se vuelve a consultar el
parámetro IN, el temporizador no se inicia, pues no hay un nuevo flanco de señal
ascendente.

time_type := Time
IN := "Tag_Output"
PT := T#30s
Q := "Tag_4"
ET := "Tag_ElapsedTime"

// Indique TIME como tipo de datos de la
instrucción.

Por este motivo hay que programar la inicialización de la multiinstancia Temporizador dentro
de la llamada.
AWL

Explicación

CALL #Time_1

// El temporizador se llama y se inicia.

time_type := Time
IN := "Tag_Output"
PT := T#30s

// Indique TIME como tipo de datos de la
instrucción.

Q := "Tag_4"
ET := "Tag_ElapsedTime"

Consulte también
Llamada de temporizadores CEI (Página 1764)
Llamada de contadores CEI (Página 1803)
Temporizadores (Página 265)

240

Programación del PLC
Manual de programación y manejo, 11/2019

3

Tipos de datos
3.1

Vista general de los tipos de datos válidos

Validez de los grupos de tipos de datos
Los tipos de datos determinan las propiedades de los datos, p. ej. el formato de presentación
del contenido y las áreas de memoria admisibles.
En el programa de usuario existe la posibilidad de emplear tipos de datos predefinidos que,
adicionalmente, también pueden agruparse en tipos de datos autodefinidos. Para ello existen
las categorías de tipos de datos siguientes:
● Tipos de datos elementales (números binarios, enteros, números en coma flotante,
temporizadores, DATE, TOD, LTOD, CHAR, WCHAR)
● Tipos de datos compuestos (DT, LDT, DTL, STRING, WSTRING, ARRAY, STRUCT)
● Tipos de datos definidos por el usuario (tipo de datos PLC (UDT))
● Puntero
● Tipos de parámetros
● Tipos de datos de sistema
● Tipos de datos de hardware
Las tablas siguientes muestran la disponibilidad de los tipos de datos en las distintas CPU S7:
Tabla 3-1

Números binarios

Números binarios

S7-300/400

S7-1200

S7-1500

BOOL (Página 245)

X

X

X

X

X

X

Secuencias de bits
BYTE (Página 246)
WORD (Página 247)

X

X

X

DWORD (Página 248)

X

X

X

LWORD (Página 250)

-

-

X

Enteros

S7-300/400

S7-1200

S7-1500

SINT (Página 251)

-

X

X

Tabla 3-2

Enteros

INT (Página 253)

X

X

X

DINT (Página 255)

X

X

X

USINT (Página 252)

-

X

X

UINT (Página 254)

-

X

X

UDINT (Página 256)

-

X

X

Programación del PLC
Manual de programación y manejo, 11/2019

241

Tipos de datos
3.1 Vista general de los tipos de datos válidos
Enteros

S7-300/400

S7-1200

S7-1500

LINT (Página 257)

-

-

X

ULINT (Página 259)

-

-

X

Números en coma flotante

S7-300/400

S7-1200

S7-1500

REAL (Página 261)

X

X

X

LREAL (Página 262)

-

X

X

Temporizadores

S7-300/400

S7-1200

S7-1500

S5TIME (Página 265)

X

-

X

Tabla 3-3

Tabla 3-4

Temporizadores

TIME (Página 266)

X

X

X

LTIME (Página 267)

-

-

X

Fecha y hora

S7-300/400

S7-1200

S7-1500

DATE (Página 268)

X

X

X

TOD (TIME_OF_DAY) (Página 268)

X

X

X

LTOD (LTIME_OF_DAY) (Página 269)

-

-

X

DT (DATE_AND_TIME) (Página 269)

X

-

X

Tabla 3-5

Fecha y hora

LDT (Página 271)

-

-

X

DTL (Página 271)

-

X

X

Cadenas de caracteres

S7-300/400

S7-1200

S7-1500

CHAR (Página 273)

X

X

X

WCHAR (Página 273)

-

X

X

Tabla 3-6

Cadenas de caracteres

STRING (Página 274)

X

X

X

WSTRING (Página 277)

-

X

X

Tipos de datos PLC (UDT)

S7-300/400

S7-1200

S7-1500

Tipo de datos PLC (Página 283) (UDT)

X

X

X

Tabla 3-7

242

Números en coma flotante

Tipos de datos PLC (UDT)

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.1 Vista general de los tipos de datos válidos
Tabla 3-8

Estructuras anónimas

Estructuras anónimas

S7-300/400

S7-1200

S7-1500

STRUCT (Página 288)

X

X

X

ARRAY

S7-300/400

S7-1200

S7-1500

ARRAY [….] of <tipo de datos> (Pági‐
na 293)

X

X

X

S7-300/400

S7-1200

S7-1500

Tabla 3-9

Tabla 3-10

ARRAY

Puntero

Puntero
Referencias (Página 310)

-

-

X

VARIANT (Página 335)

-

X

X

POINTER (Página 353)

X

-

X

ANY (Página 356)

X

-

X

S7-300/400

S7-1200

S7-1500

Tabla 3-11

Tipos de parámetros

Tipos de parámetros
TIMER (Página 359)

X

-

X

COUNTER (Página 359)

X

-

X

BLOCK_FC (Página 359)

X

-

X

BLOCK_FB (Página 359)

X

-

X

BLOCK_DB (Página 359)

X

-

-

BLOCK_SDB (Página 359)

X

-

-

VOID (Página 359)

X

X

X

PARAMETER (Página 359)

-

X

X

Tabla 3-12

Tipos de datos de sistema

Tipos de datos de sistema

S7-300/400

S7-1200

S7-1500

IEC_TIMER (Página 360)

X

X

X

1)

IEC_LTIMER (Página 360)

-

-

X

IEC_SCOUNTER (Página 360)

-

X

X

IEC_USCOUNTER (Página 360)

-

X

X

IEC_COUNTER (Página 360)

X2)

X

X

IEC_UCOUNTER (Página 360)

-

X

X

IEC_DCOUNTER (Página 360)

-

X

X

IEC_UDCOUNTER (Página 360)

-

X

X

IEC_LCOUNTER (Página 360)

-

-

X

Programación del PLC
Manual de programación y manejo, 11/2019

243

Tipos de datos
3.1 Vista general de los tipos de datos válidos
Tipos de datos de sistema

S7-300/400

S7-1200

S7-1500

IEC_ULCOUNTER (Página 360)

-

-

X

ERROR_STRUCT (Página 360)

-

X

X

NREF (Página 360)

-

X

X

CREF (Página 360)

-

X

X

VREF (Página 360)

-

X

X

SSL_HEADER (Página 360)

X

-

-

CONDITIONS (Página 360)

-

X

-

TADDR_Param (Página 360)

-

X

X

TCON_Param (Página 360)

-

X

X

HSC_Period (Página 360)

-

X

-

AssocValues (Página 360)

-

X

X

1)

En las CPUs S7-300/400, el tipo de datos se representa por medio de TP, TON y TOF.

2)

En las CPUs S7-300/400, el tipo de datos se representa por medio de CTU, CTD y CTUD.

Tabla 3-13

Tipos de datos de hardware

Tipos de datos de hardware

244

S7-300/400

S7-1200

S7-1500

REMOTE (Página 363)

-

X

X

HW_ANY (Página 363)

-

X

X

HW_DEVICE (Página 363)

-

X

X

HW_DPMASTER (Página 363)

-

-

X

HW_DPSLAVE (Página 363)

-

X

X

HW_IO (Página 363)

-

X

X

HW_IOSYSTEM (Página 363)

-

X

X

HW_SUBMODULE (Página 363)

-

X

X

HW_MODULE (Página 363)

-

-

X

HW_INTERFACE (Página 363)

-

X

X

HW_IEPORT (Página 363)

-

X

X

HW_HSC (Página 363)

-

X

X

HW_PWM (Página 363)

-

X

X

HW_PTO (Página 363)

-

X

X

EVENT_ANY (Página 363)

-

X

X

EVENT_ATT (Página 363)

-

X

X

EVENT_HWINT (Página 363)

-

X

X

OB_ANY (Página 363)

-

X

X

OB_DELAY (Página 363)

-

X

X

OB_TOD (Página 363)

-

X

X

OB_CYCLIC (Página 363)

-

X

X

OB_ATT (Página 363)

-

X

X

OB_PCYCLE (Página 363)

-

X

X

OB_HWINT (Página 363)

-

X

X

OB_DIAG (Página 363)

-

X

X

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.2 Números binarios
Tipos de datos de hardware

S7-300/400

S7-1200

S7-1500

OB_TIMEERROR (Página 363)

-

X

X

OB_STARTUP (Página 363)

-

X

X

PORT (Página 363)

-

X

X

RTM (Página 363)

-

X

X

PIP (Página 363)

-

-

X

CONN_ANY (Página 363)

-

X

X

CONN_PRG (Página 363)

-

X

X

CONN_OUC (Página 363)

-

X

X

CONN_R_ID (Página 363)

-

-

X

DB_ANY (Página 363)

-

X

X

DB_WWW (Página 363)

-

X

X

DB_DYN (Página 363)

-

X

X

Nota
En función de la versión de la CPU, los tipos de datos efectivamente válidos pueden diferir
ligeramente respecto a los de la tabla.

3.2

Números binarios

3.2.1

BOOL (bit)

Descripción
Un operando del tipo de datos BOOL representa un valor de bit y contiene uno de los siguientes
valores:
● TRUE
● FALSE

Programación del PLC
Manual de programación y manejo, 11/2019

245

Tipos de datos
3.2 Números binarios
La tabla siguiente muestra las propiedades del tipo de datos BOOL:
Longitud
(bits)

Formato

Rango de valores

Ejemplos de entrada de va‐
lores

1

Booleano

FALSE o TRUE

TRUE

BOOL#0 o BOOL#1

BOOL#1

BOOL#FALSE o
BOOL#TRUE

BOOL#TRUE

0ó1

1

Enteros sin signo (sistema
decimal)
Números binarios

2#0 ó 2#1

2#0

Números octales

8#0 u 8#1

8#1

Números hexadecimales

16#0 ó 16#1

16#1

Nota
Válido para las CPU de la serie S7-1500
Con un bloque con la propiedad "Acceso optimizado al bloque", el bit tiene 1 byte de longitud.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.2.2

Secuencias de bits

3.2.2.1

BYTE

Descripción
Un operando del tipo de datos BYTE es una secuencia de 8 bits.

246

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.2 Números binarios
La tabla siguiente muestra las propiedades del tipo de datos BYTE:
Longitud
(bits)

Formato

8

Enteros1) (sistema de‐
cimal)

Rango de valores

Enteros con signo: de
-128 a +127
Enteros sin signo: de 0
a 255

Números binarios

Ejemplos de entrada de valores
Constantes

Direcciones abso‐
lutas y simbólicas

● 15

● EB2

● BYTE#15

● MB10

● BYTE#10#15

● DB1.DBB4

● B#15

● Variable_Name

de 2#0 a 2#1111_1111 ● 2#0000_1111
● BYTE#2#0000
_1111
● B#2#0000_111
1

Números octales

de 8#0 a 8#377

● 8#17
● BYTE#8#17
● B#8#17

Números hexadecima‐ de 16#0 a 16#FF
les

● 16#0F
● BYTE#16#0F
● B#16#0F

1)

El rango de valores depende de la interpretación o conversión correspondiente.

Nota
El tipo de datos BYTE no puede someterse a una comprobación de mayor o menor. En la parte
decimal solo puede alimentarse con los mismos datos que pueden procesar los tipos de datos
SINT y USINT.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.2.2.2

WORD

Descripción
Un operando del tipo de datos WORD es una secuencia de 16 bits.

Programación del PLC
Manual de programación y manejo, 11/2019

247

Tipos de datos
3.2 Números binarios
La tabla siguiente muestra las propiedades del tipo de datos WORD:
Longitud
(bits)

Formato

16

Enteros (sistema deci‐
mal)

Rango de valores

Enteros con signo: de -32_768
a +32_767
Enteros sin signo: de 0 a
65_535

Números binarios

de 2#0 a
2#1111_1111_1111_1111

Ejemplos de entrada de valores
Constantes

Direcciones absolutas y
simbólicas

● 61_680

● MW10

● WORD#61_680

● DB1.DBW2

● WORD#10#61_680

● Variable_Name

● W#61_680
● 2#1111_0000_1111_
0000
● WORD#2#1111_000
0_1111_0000
● W#2#1111_0000_11
11_0000

Números octales

de 8#0 a 8#177_777

● 8#170_360
● WORD#8#170_360
● W#8#170_360

Números hexadecima‐
les

de 16#0 a 16#FFFF

● 16#F0F0
● WORD#16#F0F0
● W#16#F0F0

BCD

de C#0 a C#999

C#55

Secuencia decimal

B#(0, 0) a B#(255, 255)

B#(127, 200)

Nota
El tipo de datos WORD no puede someterse a una comprobación de mayor o menor. En la
parte decimal solo puede alimentarse con los mismos datos que pueden procesar los tipos de
datos INT y UINT.
El formato "BCD" no es posible en SCL.
El formato "Secuencia decimal" no es posible en SCL ni GRAPH.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.2.2.3

DWORD

Descripción
Un operando del tipo de datos DWORD es una secuencia de 32 bits.

248

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.2 Números binarios
La tabla siguiente muestra las propiedades del tipo de datos DWORD:
Longitud
(bits)

Formato

32

Enteros (sistema de‐
cimal)

Rango de valores

Enteros con signo :
-2_147_483_647 a
+2_147_483_647
Enteros sin signo: de 0 a
4_294_967_295

Números binarios

Ejemplos de entrada de valores
Constantes

Direcciones absolutas y
simbólicas

● +15_793_935

● MD10

● DWORD#+15_793_935

● DB1.DBD8

● DWORD#10#
+15_793_935

● Variable_Name

● DW#+15_793_935

de 2#0 a
● 2#0000_0000_1111_000
2#1111_1111_1111_1111_1
0_1111_1111_0000_111
111_1111_1111_1111
1
● DWORD#2#0000_0000_
1111_0000_1111_1111_
0000_1111
● DW#2#0000_0000_1111
_0000_1111_1111_0000
_1111

Números octales

8#0 a 8#37_777_777_777

● 8#74_177_417
● DWORD#8#74_177_417
● DW#8#74_177_417

Números hexadeci‐
males

de 16#0000_0000 a
16#FFFF_FFFF

● 16#00F0_FF0F
● DWORD#16#00F0_FF0
F
● DW#16#00F0_FF0F

Secuencia decimal

B#(0, 0, 0, 0) a B#(255, 255,
255, 255)

B#(127, 200, 127, 200)

Nota
El tipo de datos DWORD no puede someterse a una comprobación de mayor o menor. En la
parte decimal solo puede alimentarse con los mismos datos que pueden procesar los tipos de
datos DINT y UDINT.
El formato "Secuencia decimal" no es posible en SCL ni GRAPH.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

Programación del PLC
Manual de programación y manejo, 11/2019

249

Tipos de datos
3.2 Números binarios

3.2.2.4

LWORD

Descripción
Un operando del tipo de datos LWORD es una secuencia de 64 bits.
La tabla siguiente muestra las propiedades del tipo de datos LWORD:
Longi‐
tud
(bits)

Formato

Rango de valores

Ejemplos de entrada de valores

64

Enteros (sistema
decimal)

Enteros con signo: de
-9_223_372_036_854_775_808 a
+9_223_372_036_854_775_807

● +26_123_590_360_715

Números binarios

● LWORD#+26_123_590_360_715
● LWORD#10#+26_123_590_360_715

Enteros sin signo: de 0 a
18_446_744_073_709_551_615

● LW#+26_123_590_360_715

de 2#0 a
2#1111_1111_1111_1111_1111_1111_1111_
1111_1111_1111_1111_1111_1111_1111_11
11_1111

● 2#0000_0000_0000_0000_0000_1011_1
110_0001_0010_1111_0101_0010_1101
_1110_1000_1011
● LWORD#2#0000_0000_0000_0000_000
0_1011_1110_0001_0010_1111_0101_0
010_1101_1110_1000_1011
● LW#2#0000_0000_0000_0000_0000_10
11_1110_0001_0010_1111_0101_0010_
1101_1110_1000_1011

Números octales

de 8#0 a
8#1_777_777_777_777_777_777_777

● 8#13_724_557_213
● LWORD#8#13_724_557_213
● LW#8#13_724_557_213

Números hexade‐
cimales

de 16#0000_0000 a
16#FFFF_FFFF_FFFF_FFFF

● 16#0000_0000_5F52_DE8B
● LWORD#16#0000_0000_5F52_DE8B
● LW#16#0000_0000_5F52_DE8B

Secuencia decimal B#(0, 0, 0, 0, 0, 0, 0, 0) a B#(255, 255, 255, 255,
255, 255, 255, 255)

B#(127, 200, 127, 200, 127, 200, 127, 200)

Nota
El tipo de datos LWORD no puede someterse a una comprobación de mayor o menor. En la
parte decimal solo puede alimentarse con los mismos datos que pueden procesar los tipos de
datos LINT y ULINT.
El formato "Secuencia decimal" no es posible en SCL ni GRAPH.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Sinopsis de la conversión de tipos de datos (Página 366)
Principios básicos de las constantes (Página 103)

250

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.3 Enteros
Conversiones implícitas (Página 368)
Conversiones explícitas (Página 422)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.3

Enteros

3.3.1

SINT (enteros de 8 bits)

Descripción
Un operando del tipo de datos SINT (Short INT) tiene una longitud de 8 bits y consta de dos
componentes: Un signo y un valor numérico en complemento a dos. Los estados lógicos de los
bits 0 a 6 representan el valor del número. El estado lógico del bit 7 representa el signo. El signo
puede adoptar el estado lógico "0" para positivo o "1" para negativo.
Un operando del tipo de datos SINT ocupa un BYTE en la memoria.
La tabla siguiente muestra las propiedades del tipo de datos SINT:
Longitud
(bits)

Formato

Rango de valores

Ejemplos de entrada de valores

8

Enteros con signo (siste‐
ma decimal)

de -128 a +127

● +44
● SINT#+44
● SINT#10#+44
Si se utiliza la tipificación
SINT#, el rango de valores va
hasta SINT#255 como máximo.
Este valor se interpreta como
entero con -1.

Números binarios (solo
positivos)

de 2#0 a 2#0111_1111

● 2#0010_1100
● SINT#2#0010_1100
● SINT#2#10

Números octales (sólo po‐ 8#0 hasta 8#177
sitivos)

● 8#54

Números hexadecimales
(sólo positivos)

● 16#2C

16#0 hasta 16#7F

● SINT#8#54
● SINT#16#2C
Si se utiliza la tipificación
SINT#, el rango de valores va
hasta SINT#16#FF como máxi‐
mo. Este valor se interpreta co‐
mo entero con -1.

Programación del PLC
Manual de programación y manejo, 11/2019

251

Tipos de datos
3.3 Enteros

Ejemplo
La figura siguiente muestra el entero +44 como número binario:
%LW




6LJQR
'HFLPDOHV




















 

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.3.2

USINT (enteros de 8 bits)

Descripción
Un operando del tipo de datos USINT (Unsigned Short INT) tiene una longitud de 8 bits y
contiene valores numéricos sin signo.
Un operando del tipo de datos USINT ocupa un BYTE en la memoria.
La tabla siguiente muestra las propiedades del tipo de datos USINT:
Longitud
(bits)

Formato

Rango de valores

8

Enteros sin signo (sistema de 0 a 255
decimal)

Ejemplos de entrada de valores
● 78
● USINT#78
● USINT#10#78

Números binarios

de 2#0 a 2#1111_1111

● 2#0100_1110
● USINT#2#0100_1110
● USINT#2#10

Números octales

de 8#0 a 8#377

● 8#116
● USINT#8#116

Números hexadecimales

de 16#0 a 16#FF

● 16#4E
● USINT#16#4E

252

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.3 Enteros

Ejemplo
La figura siguiente muestra el entero 78 como número binario:
%LW




'HFLPDOHV




















 

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.3.3

INT (enteros de 16 bits)

Descripción
Un operando del tipo de datos INT tiene una longitud de 16 bits y consta de dos componentes:
Un signo y un valor numérico en complemento a dos. Los estados lógicos de los bits 0 a 14
representan el valor del número. El estado lógico del bit 15 representa el signo. El signo puede
adoptar el estado lógico "0" para positivo o "1" para negativo.
Un operando del tipo de datos INT ocupa dos BYTE en la memoria.
La tabla siguiente muestra las propiedades del tipo de datos INT:
Longitud
(bits)

Formato

Rango de valores

Ejemplos de entrada de valo‐
res

16

Enteros con signo (sistema
decimal)

de -32_768 a +32_767

● +3_785
● INT#+3_785
● INT#10#+3_785

Números binarios (solo posi‐ de 2#0 a
● 2#0000_1110_1100_100
tivos)
2#0111_1111_1111_1111
1
● INT#2#0000_1110_1100_
1001
● INT#2#10
Números octales (sólo posi‐
tivos)

de 8#0 a 8#7_7777

Números hexadecimales
(sólo positivos)

16#0 hasta 16#7FFF

Programación del PLC
Manual de programación y manejo, 11/2019

● 8#7311
● INT#8#7311
● 16#0EC9
● INT#16#0EC9

253

Tipos de datos
3.3 Enteros

Ejemplo
La figura siguiente muestra el entero +3785 como número binario:
%LW




 


6LJQR
'HFLPDOHV













 


Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.3.4

UINT (enteros de 16 bits)

Descripción
Un operando del tipo de datos UINT (Unsigned INT) tiene una longitud de 16 bits y contiene
valores numéricos sin signo.
Un operando del tipo de datos UINT ocupa dos BYTE en la memoria.
La tabla siguiente muestra las propiedades del tipo de datos UINT:
Longitud
(bits)

Formato

Rango de valores

Ejemplos de entrada de valores

16

Enteros sin signo
(sistema decimal)

de 0 a 65_535

● 65_295

Números binarios

de 2#0 a
2#1111_1111_1111_1111

● UINT#65_295
● UINT#10#65_295
● 2#1111_1111_0000_1111
● UINT#2#1111_1111_0000_
1111
● UINT#2#10

Números octales

de 8#0 a 8#17_7777

● 8#17_7417
● UINT#8#17_7417

Números hexadeci‐
males

254

de 16#0 a 16#FFFF

● 16#FF0F
● UINT#16#FF0F

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.3 Enteros

Ejemplo
La figura siguiente muestra el entero 65295 como número binario:
%LW



 


'HFLPDOHV














 

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.3.5

DINT (enteros de 32 bits)

Descripción
Un operando del tipo de datos DINT (Double INT) tiene una longitud de 32 bits y consta de dos
componentes: Un signo y un valor numérico en complemento a dos. Los estados lógicos de los
bits 0 a 30 representan el valor del número. El estado lógico del bit 31 representa el signo. El
signo puede adoptar el estado lógico "0" para positivo o "1" para negativo.
Un operando del tipo de datos DINT ocupa cuatro BYTE en la memoria.
La tabla siguiente muestra las propiedades del tipo de datos DINT:
Longitud (bits) Formato

Rango de valores

Ejemplos de entrada de valores

32

de -2_147_483_648 a
+2_147_483_647

● +125_790

Enteros con signo (siste‐
ma decimal)

● DINT#+125_790
● DINT#10#+125_790
● L#275

Números binarios (solo po‐ de 2#0 a
sitivos)
2#0111_1111_1111_1111_1111_111
1_1111_1111

● 2#0000_0000_0000_0001_1110_
1011_0101_1110
● DINT#2#0000_0000_0000_0001_
1110_1011_0101_1110
● DINT#2#10

Números octales (sólo po‐
sitivos)

8#0 a 8#177_7777_7777

● 8#36_5536

Números hexadecimales

de 16#0 a 16#7FFF_FFFF

● 16#0001_EB5E

● DINT#8#36_5536
● DINT#16#0001_EB5E

Programación del PLC
Manual de programación y manejo, 11/2019

255

Tipos de datos
3.3 Enteros

Ejemplo
La figura siguiente muestra el entero +125790 como número binario:
%LW



 









 

 





 















6LJQR


'HFLPDOHV

 

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.3.6

UDINT (enteros de 32 bits)

Descripción
Un operando del tipo de datos UDINT (Unsigned Double INT) tiene una longitud de 32 bits y
contiene valores numéricos sin signo.
Un operando del tipo de datos UDINT ocupa cuatro BYTE en la memoria.
La tabla siguiente muestra las propiedades del tipo de datos UDINT:
Longitud (bits) Formato

Rango de valores

Ejemplos de entrada de valores

32

Enteros sin signo (sistema
decimal)

de 0 a 4_294_967_295

● 4_042_322_160

Números binarios

de 2#0 a
2#1111_1111_1111_1111_111
1_1111_1111_1111

● UDINT#4_042_322_160
● UDINT#10#4_042_322_160
● 2#1111_0000_1111_0000_1111_000
0_1111_0000
● UDINT#2#1111_0000_1111_0000_11
11_0000_1111_0000
● UDINT#2#10

Números octales

8#0 a 8#377_7777_7777

● 8#360_7417_0360
● UDINT#8#360_7417_0360

Números hexadecimales

de 16#0 a 16#FFFF_FFFF

● 16#F0F0_F0F0
● UDINT#16#F0F0_F0F0

256

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.3 Enteros

Ejemplo
La figura siguiente muestra el entero 4042322160 como número binario:
%LW



 









 



 



 

















'HFLPDOHV



Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.3.7

LINT (enteros de 64 bits)

Descripción
Un operando del tipo de datos LINT (Long INT) tiene una longitud de 64 bits y consta de dos
componentes: Un signo y un valor numérico en complemento a dos. Los estados lógicos de los
bits 0 a 62 representan el valor del número. El estado lógico del bit 63 representa el signo. El
signo puede adoptar el estado lógico "0" para positivo o "1" para negativo.
Un operando del tipo de datos LINT ocupa ocho BYTE en la memoria.

Programación del PLC
Manual de programación y manejo, 11/2019

257

Tipos de datos
3.3 Enteros
La tabla siguiente muestra las propiedades del tipo de datos LINT:
Lon‐
gitud
(bits)

Formato

Rango de valores

Ejemplos de entrada de valores

64

Enteros con signo
(sistema decimal)

de -9_223_372_036_854_775_808 a
+9_223_372_036_854_775_807

● +154_325_790_816_159
● LINT#+154_325_790_816_159
● LINT#10#+154_325_790_816_159

Números binarios
(solo positivos)

de 2#0 a
● 2#0000_0000_0000_0000_1000_1100_0101_1
2#0111_1111_1111_1111_1111_1111_1
011_1100_0101_1111_0000_1111_0111_1001
111_1111_1111_1111_1111_1111_1111
_1111
_1111_1111_1111
● LINT#2#0000_0000_0000_0000_1000_1100_0
101_1011_1100_0101_1111_0000_1111_0111
_1001_1111

Números octales
(sólo positivos)

de 8#0 a
8#7_7777_7777_7777_7777_7777

● LINT#2#10
● 8#4305_5705_7417_3637
● LINT#8#4305_5705_7417_3637

Números hexadeci‐ de 16#0 a 16#7FFF_FFFF_FFFF_FFFF
males (sólo positi‐
vos)

● 16#0000_8C5B_C5F0_F79F
● LINT#16#0000_8C5B_C5F0_F79F

Ejemplo
La figura siguiente muestra el entero +154325790816159 como número binario:
%LW



 









 



 



 









 








%LW



 









 



 



 



 



 







6LJQR
9DORUHVGHFLPDOHV






 

258

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.3 Enteros

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Sinopsis de la conversión de tipos de datos (Página 366)
Principios básicos de las constantes (Página 103)
Conversiones implícitas (Página 368)
Conversiones explícitas (Página 422)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.3.8

ULINT (enteros de 64 bits)

Descripción
Un operando del tipo de datos ULINT (Unsigned Long INT) tiene una longitud de 64 bits y
contiene valores numéricos sin signo.
Un operando del tipo de datos ULINT ocupa ocho BYTE en la memoria.
La tabla siguiente muestra las propiedades del tipo de datos ULINT:
Longi‐
tud
(bits)

Formato

Rango de valores

Ejemplos de entrada de valores

64

Enteros sin signo
(sistema decimal)

de 0 a
18_446_744_073_709_551_615

● 154_325_790_816_159

Números binarios

de 2#0 a
2#1111_1111_1111_1111_1111_111
1_1111_1111_1111_1111_1111_111
1_1111_1111_1111_1111

● ULINT#154_325_790_816_159
● ULINT#10#154_325_790_816_159
● 2#0000_0000_0000_0000_1000_1100_0101_101
1_1100_0101_1111_0000_1111_0111_1001_111
1
● ULINT#2#0000_0000_0000_0000_1000_1100_01
01_1011_1100_0101_1111_0000_1111_0111_10
01_1111
● ULINT#2#10

Números octales
Números hexade‐
cimales

de 8#0 a
8#17_7777_7777_7777_7777_7777

● 8#4305_5705_7417_3637

de 16#0 a
16#FFFF_FFFF_FFFF_FFFF

● 16#0000_8C5B_C5F0_F79F

Programación del PLC
Manual de programación y manejo, 11/2019

● ULINT#8#4305_5705_7417_3637
● ULINT#16#0000_8C5B_C5F0_F79F

259

Tipos de datos
3.3 Enteros

Ejemplo
La figura siguiente muestra el entero 154325790816159 como número binario:
%LW



 









 



 



 









 








%LW



 



'H]LPDOZHUWH







 



 



 



 



 












 

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Sinopsis de la conversión de tipos de datos (Página 366)
Principios básicos de las constantes (Página 103)
Conversiones implícitas (Página 368)
Conversiones explícitas (Página 422)
Conversión de los tipos de datos en el S7-1200 (Página 506)

260

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.4 Números en coma flotante

3.4

Números en coma flotante

3.4.1

REAL

Descripción
Los operandos del tipo de datos REAL tienen una longitud de 32 bits y se utilizan para
representar números en coma flotante. Un operando del tipo de datos REAL consta de los tres
componentes siguientes:
● Signo: el estado lógico del bit 31 determina el signo. El bit 31 puede adoptar los valores "0"
(positivo) o "1" (negativo).
● Exponentes de 8 bits en base 2: El exponente se incrementa en una constante (base,
+127), de modo que presenta un rango de valores de entre 0 y 255.
● Mantisa de 23 bits: se representa solo la fracción de la mantisa. En los números en coma
flotante normalizados, la parte entera de la mantisa siempre es 1, y no se guarda.
El tipo de datos REAL se procesa con una precisión de 6 posiciones tras la coma.
La figura siguiente muestra la estructura del tipo de datos REAL:
%LW

9
6LJQR
ELWV

 

 

 

 

 

H

 

 



P

([SRQHQWHH

0DQWLVDP

ELWV

ELWV

Nota
En el caso de los números en coma flotante solo se guardan las precisiones definidas en la
norma IEEE754. Las posiciones decimales indicadas adicionalmente se redondean según
IEEE754.
En cálculos aritméticos anidados con frecuencia puede reducirse el número de posiciones
decimales.
Si se indican más posiciones decimales de las que el tipo de datos puede guardar, el número
se redondea al valor correspondiente a la precisión posible en este rango de valores.
La tabla siguiente muestra las propiedades del tipo de datos REAL:
Longitud
(bits)

Formato

Rango de valores

Ejemplos de entrada de
valores

32

Números en coma
flotante según
IEEE754

de -3.402823e+38 a -1.175495e-38

1.0e-5; REAL#1.0e-5

Números en coma
flotante

Programación del PLC
Manual de programación y manejo, 11/2019

±0,0
de +1.175495e-38 a +3.402823e+38

1.0; REAL#1.0

261

Tipos de datos
3.4 Números en coma flotante

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Calcular en SCL con números en coma flotante (REAL y LREAL) (Página 8131)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.4.2

LREAL

Descripción
Los operandos del tipo de datos LREAL tienen una longitud de 64 bits y se utilizan para
representar valores en coma flotante. Un operando del tipo de datos LREAL consta de los tres
componentes siguientes:
● Signo: el estado lógico del bit 63 determina el signo. El bit 63 puede adoptar los valores "0"
(positivo) o "1" (negativo).
● Exponentes de 11 bits en base 2: El exponente se incrementa en una constante (base,
+1023), de modo que presenta un rango de valores de entre 0 y 2047.
● Mantisa de 52 bits: se representa solo la fracción de la mantisa. En los números en coma
flotante normalizados, la parte entera de la mantisa siempre es 1, y no se guarda.
El tipo de datos LREAL se procesa con una precisión de 15 posiciones tras la coma.
La figura siguiente muestra la estructura del tipo de datos LREAL:
%LW
 
6
6LJQR6
ELW

 

 

 

 

 

H

 



 

P
([SRQHQWHH

0DQWLVDP

ELWV

ELWV

La tabla siguiente muestra las propiedades del tipo de datos LREAL:

262

Longitud
(bits)

Formato

Rango de valores

Ejemplos de entrada de
valores

64

Números en coma
flotante según
IEEE754

de -1.7976931348623157e+308 a
-2.2250738585072014e-308

1.0e-5; LREAL#1.0e-5

Números en coma
flotante

de +2.2250738585072014e-308 a
+1.7976931348623157e+308

±0,0

1.0; LREAL#1.0

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.4 Números en coma flotante

Nota
En el caso de los números en coma flotante solo se guardan las precisiones definidas en la
norma IEEE754. Las posiciones decimales indicadas adicionalmente se redondean según
IEEE754.
En cálculos aritméticos anidados con frecuencia puede reducirse el número de posiciones
decimales.
Si se indican más posiciones decimales que el tipo de datos puede guardar, el número se
redondea al valor correspondiente a la precisión posible en este rango de valores.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Calcular en SCL con números en coma flotante (REAL y LREAL) (Página 8131)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.4.3

Números en coma flotante no válidos

Descripción
En los tipos de datos REAL y LREAL se diferencian cuatro rangos numéricos:
● Números normalizados que pueden guardarse con total precisión
● Números desnormalizados que no pueden guardarse con total precisión
● Números infinitos: +Inf/-Inf (Infinity)
● Números no válidos: NaN (Not a Number)
Nota
Los números en coma flotante se depositan como en la norma IEEE754. Los resultados de las
conversiones o las funciones aritméticas con un número en coma flotante desnormalizado,
infinito o NaN (Not a Number) dependen de la CPU.
Si no se trabaja con números en coma flotante normalizados en las funciones matemáticas, el
resultado contenderá diferencias importantes, en función de la serie de CPU que se utilice.
Exceptuando las versiones de CPU antiguas de las series S7-300 y S7-400, una CPU no
puede realizar cálculos con números en coma flotante desnormalizados; el patrón de bits de
un número desnormalizado se interpreta como un cero. Si el resultado de un cálculo se incluye
en este rango, se continúa con cero y los bits de estado OV y OS se activan (rebase por defecto
del rango numérico).

Programación del PLC
Manual de programación y manejo, 11/2019

263

Tipos de datos
3.4 Números en coma flotante
Aunque los valores de los números en coma flotante no válidos solo pueden representarse con
una exactitud limitada en las funciones matemáticas, los números con un exponente de -39 (p.
ej., 2.4408e-039) pueden observarse en el TIA Portal y no por ello representan
necesariamente un resultado erróneo. En consecuencia, puede ocurrir que los valores de los
números en coma flotante estén fuera de los valores numéricos válidos.
Nota
Para las CPU de las series S7-1200 V1, V2 y V3 rige lo siguiente:
La operación de comparación "Igual" utiliza el patrón de bits del número en coma flotante no
válido. Si se comparan dos "números NaN" con el mismo patrón de bits, la salida de la
operación de comparación "Igual" arroja el resultado TRUE.
Nota
Para las CPU de la serie S7-1200 V4 y S7-1500 vale:
Si se comparan dos números no válidos (NaN), el resultado es siempre FALSE,
independientemente del patrón de bits del número no válido o de la relación (>, >, ...).
Nota
Comparación de números en coma flotante desnormalizados
Con la operación de comparación "Igual" con dos números en coma flotante desnormalizados,
en las CPU de la serie S7-300/400 y la serie S7-1200/1500, la salida se pone al estado lógico
"0" y "1", respectivamente.
Si las variables de entrada de una función matemática representan un número en coma
flotante no válido, también se emite un número en coma flotante no válido como resultado.
Posibilidades de evaluar posibles errores derivados de números en coma flotante no válidos:
● En KOP/FUP y SCL puede consultarse FALSE en la salida de habilitación ENO
● En AWL puede evaluarse el bit de estado OV

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Calcular en SCL con números en coma flotante (REAL y LREAL) (Página 8131)
Conversión de los tipos de datos en el S7-1200 (Página 506)

264

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.5 Temporizadores

3.5

Temporizadores

3.5.1

S5TIME (tiempo)

Formato
El tipo de datos S5TIME guarda el tiempo en formato BCD. El tiempo es el producto de un valor
de tiempo en el rango de 0 a 999 y una base de tiempo. La base de tiempo especifica el
intervalo en el que un temporizador reduce el valor temporal en una unidad, hasta llegar a "0".
La base de tiempo permite controlar la resolución de los valores temporales.
La tabla siguiente muestra el rango de valores para el tipo de datos S5TIME:
Longitud
(bits)

Formato

Rango de valores

16

Temporizadores
S5T#0MS a
de S7 en intervalos S5T#2H_46M_30S_0MS
de 10 ms (valor es‐
tándar)

Ejemplos de entrada de valores
S5T#10s, S5TIME#10s

La tabla siguiente muestra la codificación de la base de tiempo para S5TIME:
Base de tiempo

Código binario para la base de tiempo

10 ms

00

100 ms

01

1s

10

10 s

11

Si el tipo de datos S5TIME se utiliza con temporizadores, deben observarse los valores límite
del rango y la resolución de los valores de tiempo. La tabla siguiente indica el rango
correspondiente a cada una de las resoluciones:
Resolución

Rango

0,01 s

de 10 ms a 9 s 990 ms

0,1 s

de 100 ms a 1 m 39 s 900 ms

1s

de 1 s a 16 m 39 s

10 s

de 10 s a 2 h 46 m 30 s

No se aceptan valores por encima de 2h46m30s.

Programación del PLC
Manual de programación y manejo, 11/2019

265

Tipos de datos
3.5 Temporizadores

Ejemplo
La figura siguiente muestra el contenido del operando de tiempo para un valor de tiempo de
127 y una base de tiempo de 1 s:
%LW

[

 
[
















%DVHGHWLHPSR
VHJXQGR




















9DORUGHWLHPSRFRGLILFDGRHQ%&'
GHD

,UUHOHYDQWH(VWRVELWVVHLJQRUDQFXDQGRVHLQLFLDHOWHPSRUL]DGRU

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.5.2

TIME (tiempo IEC)

Descripción
El contenido de un operando del tipo TIME se interpreta como milisegundos. La representación
contiene especificaciones de días (d), horas (h), minutos (m), segundos (s) y milisegundos
(ms).
La tabla siguiente muestra las propiedades del tipo de datos TIME:
Longitud
(bits)

Formato

Rango de valores

Ejemplos de entrada de valores

32

Tiempo con sig‐
no

de
T#-24d_20h_31m_23s_648ms
a T#
+24d_20h_31m_23s_647ms

T#10d_20h_30m_20s_630ms, TI‐
ME#10d_20h_30m_20s_630ms

No es necesario indicar todas las unidades de tiempo. Por ejemplo, T#5h10s es válido. Si se
indica solo una unidad, el valor absoluto de días, horas y minutos no podrá exceder los límites
superiores ni inferiores. Si se indica más de una unidad de tiempo, el valor correspondiente no
podrá exceder 24 días, 23 horas, 59 minutos, 59 segundos o 999 milisegundos.

266

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.5 Temporizadores

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.5.3

LTIME (temporizador CEI)

Descripción
El contenido de un operando del tipo LTIME se interpreta como nanosegundos. La
representación contiene especificaciones de días (d), horas (h), minutos (m), segundos (s),
milisegundos (ms), microsegundos (us) y nanosegundos (ns).
La tabla siguiente muestra las propiedades del tipo de datos LTIME:
Longi‐
tud
(bits)

Formato

Rango de valores

Ejemplos de entrada de valores

64

Tiempo con signo

de
LT#-106751d_23h_47m_16s_854
ms_775us_808ns a LT#
+106751d_23h_47m_16s_854ms
_775us_807ns

LT#11350d_20h_25m_14s_830
ms_652us_315ns, LTI‐
ME#11350d_20h_25m_14s_830
ms_652us_315ns

No es necesario indicar todas las unidades de tiempo. Por ejemplo, LT#5h10s es válido. Si se
indica solo una unidad, el valor absoluto de días, horas y minutos no podrá exceder los límites
superiores ni inferiores. Si se indica más de una unidad de tiempo, el valor correspondiente no
podrá exceder 106751 días, 23 horas, 59 minutos, 59 segundos, 999 milisegundos, 999
microsegundos o 999 nanosegundos.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Sinopsis de la conversión de tipos de datos (Página 366)
Principios básicos de las constantes (Página 103)
Conversiones implícitas (Página 368)
Conversiones explícitas (Página 422)
Conversión de los tipos de datos en el S7-1200 (Página 506)

Programación del PLC
Manual de programación y manejo, 11/2019

267

Tipos de datos
3.6 Fecha y hora

3.6

Fecha y hora

3.6.1

DATE

Formato
El tipo de datos DATE guarda una fecha como número entero sin signo. La representación
contiene el año, el mes y el día.
El contenido de un operando del tipo de datos DATE corresponde al número de días desde
01/01/1990, expresado en formato hexadecimal (16#0000).
La tabla siguiente muestra las propiedades del tipo de datos DATE:
Longitud
(bytes)

Formato

Rango de valores

Ejemplos de entrada de valores

2

Fecha IEC

De D#1990-01-01 a
D#2169-06-06

D#2009-12-31, DATE#2009-12-31

(año-mes-día)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.6.2

TOD (TIME_OF_DAY)

Formato
El tipo de datos TOD (TIME_OF_DAY) ocupa una palabra doble y guarda el número de
milisegundos desde el inicio del día (0:00 h) como número entero sin signo.
La tabla siguiente muestra las propiedades del tipo de datos TOD:
Longitud
(bytes)

Formato

Rango de valores

Ejemplos de entrada de valo‐
res

4

Hora (horas:minutos:segun‐
dos.milisegundos)

TOD#00:00:00.000 a
TOD#23:59:59.999

TOD#10:20:30.400, TI‐
ME_OF_DAY#10:20:30.400

Es obligatorio especificar las horas, minutos y segundos. Los milisegundos se pueden
especificar opcionalmente.

268

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.6 Fecha y hora

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.6.3

LTOD (LTIME_OF_DAY)

Formato
El tipo de datos LTOD (LTIME_OF_DAY) ocupa dos palabras dobles y guarda el número de
nanosegundos desde el comienzo del día (0:00 h) como número entero sin signo.
La tabla siguiente muestra las propiedades del tipo de datos LTOD:
Longitud
(bytes)

Formato

Rango de valores

Ejemplos de entrada de valo‐
res

8

Hora (horas:minutos:segun‐
dos.milisegundos)

de
LTOD#00:00:00.0000000
00 a
LTOD#23:59:59.9999999
99

LTOD#10:20:30.400_365_21
5, LTI‐
ME_OF_DAY#10:20:30.400_
365_215

Es obligatorio especificar las horas, minutos y segundos. Los milisegundos se pueden
especificar opcionalmente.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Sinopsis de la conversión de tipos de datos (Página 366)
Principios básicos de las constantes (Página 103)
Conversiones implícitas (Página 368)
Conversiones explícitas (Página 422)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.6.4

DT (DATE_AND_TIME)

Formato
El tipo de datos DT (DATE_AND_TIME) guarda información de fecha y hora en formato BCD.

Programación del PLC
Manual de programación y manejo, 11/2019

269

Tipos de datos
3.6 Fecha y hora
La tabla siguiente muestra las propiedades del tipo de datos DT:
Longitud
(bytes)

Formato

Rango de valores

8

Fecha y hora

Mín.:
DT#2008-10-25-08:12:34.567,
DT#1990-01-01-00:0 DATE_AND_TI‐
0:00.000
ME#2008-10-25-08:12:34.567

(año-mes-día-hora:minuto:se‐
gundo:milisegundo 3))

Ejemplo de entrada de valores

Máx.:
DT#2089-12-31-23:5
9:59.999

La tabla siguiente muestra la estructura del tipo de datos DT:
Byte

Contenido

Rango de valores

0

Año

de 0 a 99
(años 1990 a 2089)
BCD#90 = 1990
...
BCD#0 = 2000
...
BCD#89 = 2089

1

Mes

BCD#1 a BCD#12

2

Día

BCD#1 a BCD# 31

3

Hora

BCD#0 a BCD#23

4

Minuto

BCD#0 a BCD#59

5

Segundo

BCD#0 a BCD#59

6

Los dos valores más significativos de MSEC

BCD#0 a BCD#999

7 (4MSB) 1)

El valor menos significativo de MSEC

BCD#0 a BCD#9

7 (4LSB) 2)

Día de la semana

BCD#1 a BCD#7
BCD#1 = domingo
...
BCD#7 = sábado

1)

MSB: Most Significant Bit

2)

LSB: Least Significant Bit

3)

Número en coma fija

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

270

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.6 Fecha y hora

3.6.5

LDT (DATE_AND_LTIME)

Formato
El tipo de datos LDT (DATE_AND_LTIME) guarda información de fecha y hora en
nanosegundos desde el 01.01.1970 0:0.
La tabla siguiente muestra las propiedades del tipo de datos LDT:
Longitud Formato
(bytes)
8

Rango de valores

Ejemplo de entrada de valores

Fecha y hora
Mín.:
LDT#2008-10-25-08:12:34.567
(año-mes-día-hora:minu‐ LDT#1970-01-01-00:00:00.0
to:segundo.nanosegundo) 00000000
Máx.:
LDT#2262-04-11-23:47:16.8
54775807

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Sinopsis de la conversión de tipos de datos (Página 366)
Principios básicos de las constantes (Página 103)
Conversiones implícitas (Página 368)
Conversiones explícitas (Página 422)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.6.6

DTL

Descripción
Un operando del tipo de datos DTL tiene una longitud de 12 bytes y guarda datos de fecha y
hora en una estructura predefinida.
La tabla siguiente muestra las propiedades del tipo de datos DTL:
Longitud
(bytes)

Formato

Rango de valores

Ejemplo de entrada de va‐
lores

12

Fecha y hora

Mín.:
DTL#1970-01-01-00:00:00.0

DTL#2008-12-16-20:30:20
.250

(año-mes-día-hora:mi‐
nuto:segundo.nanose‐
gundo)

Programación del PLC
Manual de programación y manejo, 11/2019

Máx.:
DTL#2262-04-11-23:47:16.8547
75807

271

Tipos de datos
3.6 Fecha y hora
La estructura del tipo de datos DTL consta de varios componentes, cada uno de los cuales
puede tener un tipo de datos y un rango de valores distinto. El tipo de datos de un valor indicado
debe coincidir con el tipo de datos del componente en cuestión.
Nota
Valor de observación no válido de la variable DTL en formato hexadecimal
Si el valor de observación de la variable DTL se representa en formato hexadecinal, puede
deberse a que uno de los valores (YEAR, MONTH, DAY, etc.) no es válido. Eso ocurre, por
ejemplo, si en la variable HOUR se ha indicado un valor > 24.
La tabla siguiente muestra los componentes de la estructura del tipo de datos DTL y sus
propiedades:
Byte

Componente

Tipo de datos

Rango de valores

0

Año

UINT

de 1970 a 2262

2

Mes

USINT

de 1 a 12

3

Día

USINT

1 hasta 31

4

Día de la semana USINT

1

de 1 (domingo) a 7 (sábado)
El día de la semana no se tiene en cuenta al
introducir los valores.

5

Hora

USINT

0 hasta 23

6
7

Minuto

USINT

0 hasta 59

Segundo

USINT

0 hasta 59

8

Nanosegundo

UDINT

de 0 a 999999999

9
10
11

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

272

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.7 Cadenas de caracteres

3.7

Cadenas de caracteres

3.7.1

Carácter

3.7.1.1

CHAR

Descripción
Una variable del tipo de datos CHAR (Character) tiene una longitud de 8 bits y ocupa un BYTE
en la memoria.
El tipo de datos CHAR almacena un solo carácter depositado en codificación ASCII.
Encontrará información sobre la codificación de caracteres especiales en "Consulte también >
STRING".
La tabla siguiente muestra el rango de valores del tipo de datos CHAR:
Longitud
(bits)

Formato

Rango de valores

Ejemplo de entradas de valores

8

Caracteres ASCII

Juego de caracteres
ASCII

'A', CHAR#'A'

Consulte también
Vista general de los tipos de datos válidos (Página 241)
STRING (Página 274)

3.7.1.2

WCHAR

Descripción
Una variable del tipo de datos WCHAR (wide characters) tiene una longitud de 16 bits y ocupa
dos BYTE en la memoria.
El tipo de datos WCHAR almacena un carácter individual de un juego de caracteres ampliado
con codificación UFT-16. No obstante, solo se cubre una parte de todo el rango Unicode. Los
caracteres no representables se hacen representables con ayuda de un carácter de escape.
La tabla siguiente muestra el rango de valores del tipo de datos WCHAR:
Longitud (bits)

Formato

Rango de valores

Ejemplo de entrada de
valores

16

Unicode

$0000 - $D7FF

WCHAR#'a'

Programación del PLC
Manual de programación y manejo, 11/2019

273

Tipos de datos
3.7 Cadenas de caracteres

Consulte también
Vista general de los tipos de datos válidos (Página 241)

3.7.2

Cadenas de caracteres

3.7.2.1

STRING

Descripción
Un operando del tipo de datos STRING guarda varios caracteres en una cadena que puede
estar formada por un máximo de 254 caracteres. En las cadenas de caracteres se admiten
todos los caracteres de la página de códigos ajustada en el sistema de creación. Los
caracteres se introducen entre comillas sencillas.
Una cadena de caracteres puede contener también caracteres especiales. Para especificar
caracteres de control, caracteres de dólar y comillas simples se utiliza el carácter de escape $.
Nota
Distintas páginas de códigos
Tenga en cuenta que los caracteres especiales se codifican mediante la página de códigos
ajustada en ese momento en Windows. Eso significa que una cadena que contenga caracteres
especiales se representará de forma diferente en otro sistema operativo que tenga otra página
de códigos.
La dependencia entre la página de códigos y el sistema de creación dificulta el uso
internacional del programa de usuario. Solo los caracteres de la codificación ASCII de 7 bits
son válidos internacionalmente.
La tabla siguiente muestra las propiedades de una variable STRING:
Longitud (bytes) Formato

Rango de valores

Ejemplo de entrada de valores

n+2

0 a 254 caracteres

● 'Nombre'

1)

Cadena de caracteres
ASCII, incluidos los ca‐
racteres especiales

● STRING#'NAME'
● STRING#'Na... (La longitud
actual de la cadena es mayor
que el espacio disponible en la
pantalla.)
● STRING#'' (la cadena está
vacía.)

Un operando del tipo de datos STRING ocupa en la memoria dos bytes más que la longitud máxima
especificada.

1)

274

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.7 Cadenas de caracteres
La tabla siguiente muestra ejemplos de notación de caracteres especiales:
Carácter

Hex

Significado

Ejemplo

$L o $l

0A

Avance de línea

'$LText', '$0AText'

$N

0A y 0D

Salto de línea

'$NText', '$0A$0DText'

El salto de línea ocupa 2 caracteres
en la cadena y en la vista del editor
se convierte a $R$L.
$P o $p

0C

Salto de página

'$PText', '$0CText'

$R o $r

0D

Retorno de carro (CR)

'$RText','$0DText'

$T o $t

09

Tabulación

'$TText', '$09Text'

$$

24

Carácter de dólar

'100$$', '100$24'

$'

27

Comilla simple

'$'Text$'','$27Text$27'

Si al símbolo de escape $ le sigue una letra de la tabla, el carácter indicado en la tabla se
introduce en la cadena. Si al símbolo de escape $ le sigue una letra que no figura en la tabla,
en la cadena se introduce esa letra. Si al símbolo de escape $ le siguen dos cifras sedecimales
(hexadecimales) o solo una cifra, la codificación en cuestión se introducirá en la cadena.

Uso en la tabla de observación
En una CPU de las series S7-300/400 se aplica lo siguiente: si se observa una variable del tipo
de datos STRING, solo se representarán los primeros 30 caracteres. Si la longitud real es
superior a 30 caracteres, en lugar del apóstrofo de cierre (') se muestra una elipse o un
apóstrofo (...). Los valores de STRING con más de 30 caracteres no pueden utilizarse para
control.

Longitud máxima de una cadena de caracteres
En la declaración de un operando, la longitud máxima de la cadena de caracteres puede
indicarse entre corchetes a continuación de la palabra clave STRING (p. ej. STRING[4]). Para
declarar la longitud máxima pueden utilizarse también constantes locales o globales (p. ej.,
STRING[#loc_const] o STRING["glob_const"]). Si no se indica la longitud máxima, se utilizará
para el correspondiente operando la longitud estándar de 254 caracteres.
Encontrará más información sobre el uso de constantes locales o globales para declarar la
longitud máxima aquí:
● Declarar la interfaz del bloque: Declaración de variables del tipo de datos STRING y
WSTRING (Página 7799)
● Programar bloques de datos: Declaración de variables del tipo de datos STRING
(Página 7851)
● Ejemplos de uso de constantes (Página 108)
Si la longitud efectiva de una cadena de caracteres especificada es menor que la longitud
máxima declarada, los caracteres se escriben justificados a la izquierda en la cadena y las
posiciones sobrantes quedan sin definir. Al procesar los valores y en todas las vistas se

Programación del PLC
Manual de programación y manejo, 11/2019

275

Tipos de datos
3.7 Cadenas de caracteres
consideran únicamente las posiciones de carácter ocupadas que determinan la longitud real
de la cadena.
Nota
Para las CPU S7-300/400 se debe tener en cuenta lo siguiente: Si se ha definido una variable
temporal del tipo de datos STRING, en el BYTE "longitud máx. de la cadena de caracteres"
debe escribirse la longitud definida antes de utilizar la variable en el programa de usuario.

Transferir STRING para el suministro de parámetros
El tipo de datos STRING se puede transferir como parámetro. Encontrará más información
sobre el suministro de parámetros con STRING aquí:
● Transferir variable del tipo de datos STRING o WSTRING (Página 282)
● Para S7-1200/1500: Tipos de datos válidos en la interfaz de bloque (Página 7787)
● Para S7-300/400: Tipos de datos válidos en la interfaz de bloque (Página 7786)

Ejemplo
El ejemplo siguiente muestra el orden de los bytes si se indica el tipo de datos STRING[4] con
el valor de salida 'AB':
%\WH







%\WH



/RQJLWXGP£[GH
ODFDGHQD







%\WH



/RQJLWXGUHDOGHOD
FDGHQD ಯ$%ಯ 







9DORU$6&,,
GH$

%\WH









%\WH









%\WH











9DORU$6&,,
GH%

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Conversión de los tipos de datos en el S7-1200 (Página 506)

276

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.7 Cadenas de caracteres

3.7.2.2

Estructura de una variable STRING

Introducción
Una variable del tipo de datos STRING (cadena de caracteres) tiene una longitud máxima de
256 caracteres con 254 bytes de datos netos. Comienza en un límite de palabra (en un byte
con dirección par) de un bloque no optimizado. En un bloque optimizado puede comenzar en
cualquier límite de byte.
Al crear la variable se determina su longitud máxima. Al inicializarla o bien al editar la cadena
de caracteres se registra la longitud actual (la longitud de la cadena de caracteres utilizada
realmente = número de caracteres válidos). En el primer byte de la cadena de caracteres figura
la longitud máxima. En el segundo byte figura la longitud actual. A continuación siguen los
caracteres codificados conforme a la página de códigos ajustada en Windows.
Estructura de una variable STRING:
7LSRGHGDWRV 5DQJR
%\WHQ

/RQJLWXGP£[LPD

86,17

'HD

N

%\WHQ

/RQJLWXGDFWXDO

86,17

'HD

PP N

%\WHQ

HUFDU£FWHU

&+$5

%\WHQ

|FDU£FWHU

&+$5

%\WH



&+$5

%\WHQP

P|FDU£FWHU

&+$5

%\WH



&+$5

%\WHQN



&+$5

/RQJLWXG
DFWXDO
P

/RQJLWXG
P£[LPD N

 Q SDU

3.7.2.3

WSTRING

Descripción
Un operando del tipo de datos WSTRING (Wide Character String) guarda varios caracteres
Unicode del tipo de datos WCHAR en una cadena de caracteres. Si no se indica longitud, la
cadena tiene un valor predeterminado de 254 caracteres. En las cadenas de caracteres se
admiten todos los caracteres soportados por el sistema operativo. Esto permite utilizar también
caracteres chinos dentro de una cadena. Windows solo soporta una (pero suficiente) parte de
los caracteres definidos en Unicode .
Nota
Codificación
STEP 7 prohibe todas las codificaciones de $D000 a $FFFF.
En la declaración de un operando del tipo de datos WSTRING es posible definir su longitud
utilizando corchetes (p. ej. WSTRING[10]). Si no se indica ninguna longitud, el WSTRING se

Programación del PLC
Manual de programación y manejo, 11/2019

277

Tipos de datos
3.7 Cadenas de caracteres
ajustará a 254 caracteres. La longitud máxima que puede declararse es de 16382 caracteres
(WSTRING[16382]).
Los caracteres se indican entre comillas simples y siempre con el indicador WSTRING#.
La tabla siguiente muestra las propiedades de una variable WSTRING:
Longitud (WORD)

Formato

Rango de valores

Ejemplo de entrada de
valores

n + 2 1)

Cadena de caracteres
Unicode;

Valor predeterminado:
0 a 254 caracteres

n indica la longitud de la
cadena de caracteres.

Valor máx. posible: 0 a
16382

● WSTRING#'Hola
mundo'
● WSTRING#'Hola
mun... (La longitud
actual de la cadena
es mayor que el
espacio disponible
en la pantalla.)
● WSTRING#'' (la
cadena está vacía).

Un operando del tipo de datos WSTRING ocupa en la memoria dos WORD más que la longitud
máxima especificada.

1)

Una cadena de caracteres puede contener también caracteres especiales. Para especificar
caracteres de control, caracteres de dólar y comillas simples se utiliza el carácter de escape $.
La tabla siguiente muestra ejemplos de notación de caracteres especiales:
Carácter

Hex

Significado

Ejemplo

$L o $l

000A

Avance de línea

'$LText', '$000AText'

$N

000A y 000D

Salto de línea

'$NText', '$000A
$000DText'

El salto de línea ocupa 2 caracteres
en la cadena y en la vista del editor
se convierte a $R$L.
$P o $p

000C

Salto de página

'$PText', '$000CText'

$R o $r

000D

Retorno de carro (CR)

'$RText','$000DText'

$T o $t

0009

Tabulación

'$TText', '$0009Text'

$$

0024

Carácter de dólar

'100$$', '100$0024'

$'

0027

Comilla simple

'$'Text$'','$0027Text
$0027'

Si al símbolo de escape $ le sigue una letra de la tabla, el carácter indicado en la tabla se
introduce en la cadena. Si al símbolo de escape $ le sigue una letra que no figura en la tabla,

278

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.7 Cadenas de caracteres
en la cadena se introduce esa letra. Si al símbolo de escape $ le siguen cuatro cifras
hexadecimales, la codificación en cuestión se introduce en la cadena.
Nota
Conversión de variables WSTRING
No es posible la conversión implícita del tipo de datos WSTRING. En general, es posible la
conversión explícita del tipo de datos WSTRING a STRING. Sin embargo, en todas las páginas
de códigos de Windows solo funcionan por defecto las conversiones de los caracteres
incluidos en el rango de código 0 - 127. En todos los caracteres que queden por encima de este
rango, el carácter Codepage y el byte inferior del carácter Unicode deben estar exactamente
en el mismo lugar para que la conversión funcione correctamente.

Uso en la tabla de observación
Si se observa una variable del tipo de datos WSTRING, solo se representarán los primeros 254
caracteres. Si la longitud real es superior a 254 caracteres, en lugar del apóstrofo de cierre (')
se muestra una elipse o un apóstrofo (...). Los valores de WSTRING con más de 254
caracteres no pueden utilizarse para control.

Longitud máxima de una cadena de caracteres
En la declaración de un operando, la longitud máxima de la cadena de caracteres puede
indicarse entre corchetes a continuación de la palabra clave WSTRING (p. ej. WSTRING[4]).
Para declarar la longitud máxima pueden utilizarse también constantes locales o globales (p.
ej., WSTRING[#loc_const] o WSTRING["glob_const"]). Si no se indica la longitud máxima, se
utilizará para el correspondiente operando la longitud estándar de 254 caracteres.
Encontrará más información sobre el uso de constantes locales o globales para declarar la
longitud máxima aquí:
● Declarar la interfaz del bloque: Declaración de variables del tipo de datos STRING y
WSTRING (Página 7799)
● Programar bloques de datos: Declaración de variables del tipo de datos STRING
(Página 7851)
● Ejemplos de uso de constantes (Página 108)
Si la longitud efectiva de una cadena de caracteres especificada es menor que la longitud
máxima declarada, los caracteres se escriben justificados a la izquierda en la cadena y las
posiciones sobrantes quedan sin definir. Al procesar los valores se consideran únicamente las
posiciones de carácter ocupadas.

Transferir WSTRING para el suministro de parámetros
En los bloques con el tipo de acceso "optimizado" los operandos del tipo de datos WSTRING
pueden transmitirse como parámetros hasta la longitud máxima.
En los bloques de función (FB) con el tipo de acceso "estándar", los operandos del tipo de
datos WSTRING pueden declararse como parámetros en todas las secciones de la interfaz del
bloque, excepto en la sección "InOut". En una función (FC) con el tipo de acceso "estándar"
solo pueden transmitirse como parámetros operandos del tipo de datos WSTRING.

Programación del PLC
Manual de programación y manejo, 11/2019

279

Tipos de datos
3.7 Cadenas de caracteres
Otras excepciones a esta norma son el valor de función de una FC en el apartado "Return" de
la interfaz del bloque y las expresiones en el lenguaje de programación SCL. En estos casos,
la variable WSTRING no puede tener más de 1022 caracteres.
Las longitudes declaradas de los parámetros formales y actuales pueden ser distintas.
Encontrará más información sobre el suministro de parámetros con WSTRING aquí:
● Transferir variable del tipo de datos STRING o WSTRING (Página 282)
● Tipos de datos válidos en la interfaz de bloque (Página 7787)

Ejemplo
El ejemplo siguiente muestra el orden de los bytes si se indica el tipo de datos WSTRING[4]
con el valor de salida 'AB':
%\WH







%\WH









%\WH



/RQJLWXGP£[GHOVWULQJ







%\WH









%\WH







/RQJLWXGUHDOGHOVWULQJ $% 



%\WH









%\WH







9DORUXQLFRGHGH$



Vista general de los tipos de datos válidos (Página 241)
Constantes (Página 103)

Direccionamiento de caracteres individuales de un STRING o WSTRING

Direccionamiento de caracteres individuales de un STRING o WSTRING
Se accede a caracteres individuales de una variable STRING o WSTRING con la
sintaxis StringName[i] . El índice de contaje "i" empieza por "1". Así pues, con el
StringName[1] se accede al primer carácter del string.
No es posible acceder a caracteres individuales de una constante STRING o WSTRING.

Ejemplos
Ejemplos de direccionamiento de variables de (W)STRINGs:

280

Direccionamiento

Explicación

"myDB".mySTRING[3]

Direcciona el tercer carácter del STRING en el bloque de
datos.

#myWSTRING[3]

Direcciona el tercer carácter del WSTRING.





9DORUXQLFRGHGH%

Consulte también

3.7.2.4



Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.7 Cadenas de caracteres

Tratamiento de errores en accesos a (W)STRING
Los errores de acceso se producen cuando se accede en tiempo de ejecución a un carácter
que está fuera de la longitud del STRING. Si en el acceso de lectura a la cadena de caracteres
se obtiene el carácter '$00' o '$0000', no se ejecuta ningún acceso de escritura a la cadena de
caracteres. Si la instrucción dispone de la salida de habilitación ENO, ENO adopta el estado
lógico FALSE. La CPU no pasa a STOP.
La única excepción es cuando el carácter se escribe directamente después de la longitud real
de la cadena de caracteres.
El ejemplo siguiente muestra el STRING 'Hello' con la longitud real 5. El carácter n.º 27 del
STRING está fuera de la longitud real, por lo que no puede escribirse. El STRING permanece
invariable, el resultado de la asignación es 'hello'.
SCL
MyDB.mystring := 'hello';
MyDB.mystring[27] := CHAR_TO_BYTE('!');

El ejemplo siguiente muestra el caso de excepción mencionado: El carácter se escribe en el 6.º
carácter, justo detrás del STRING. El resultado de la asignación es 'hello!'.
SCL
MyDB.mystring := 'hello';
MyDB.mystring[6] := CHAR_TO_BYTE('!');

Siempre que sea posible, utilice las instrucciones de la paleta "Instrucciones avanzadas >
String + Char" para manejar los STRING.

CONCAT(IN1 := 'hello', IN2 := '!');

Programación del PLC
Manual de programación y manejo, 11/2019

281

Tipos de datos
3.7 Cadenas de caracteres

3.7.2.5

Transferir variable del tipo de datos STRING o WSTRING

Descripción
Existe la posibilidad de transferir variables del tipo de datos STRING o WSTRING como
parámetros. La tabla siguiente muestra las reglas que rigen para transferir (W)STRING en las
diferentes familias de CPU:
Familia de
CPU

Tipo de da‐ Reglas para la transferencia durante la llamada del bloque
tos

S7-300/400

STRING

S7-1200/150
0

STRING

Las longitudes declaradas de los parámetros formales y actuales deben ser idénticas.

Las longitudes declaradas de los parámetros formales y actuales pueden ser distintas. Si en
WSTRING tiempo de ejecución la longitud declarada del parámetro de destino no es suficiente para incor‐
porar el (W)STRING, el (W)STRING queda cortado y la salida de habilitación ENO se pone a
FALSE.
En el editor de programación, un cuadrado gris en el parámetro indica que posiblemente
(W)STRING esté cortado en tiempo de ejecución.
Excepción:
Cuando se llaman bloques en AWL, las longitudes declaradas de los parámetros formales y
actuales deben ser siempre idénticas.

La figura siguiente muestra una llamada de bloque en la que las longitudes de los parámetros
formales y actuales declarados son distintas. Debido a la diferencia en las longitudes
declaradas, tanto "Input_String_20" como "Output_String_10" podrían quedar cortados en
tiempo de ejecución.

Consulte también
Reglas para el suministro de parámetros de bloque (Página 80)

282

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.8 Tipos de datos PLC (UDT)

3.8

Tipos de datos PLC (UDT)

3.8.1

Principios básicos de los tipos de datos PLC (UDT)

Descripción
Un tipo de datos PLC (UDT) es un tipo de datos compuesto personalizado que puede
emplearse para la declaración de una variable. Representa una estructura de datos de varios
componentes de diferentes tipos de datos. Los componentes también pueden derivarse como
estructura de otro tipo de datos PLC, de un ARRAY o directamente mediante la palabra clave
STRUCT. La profundidad de anidamiento está limitada a 8 niveles.
Es posible modificar centralmente un tipo de datos PLC (UDT) y emplearlo varias veces en el
código del programa. Todas las ubicaciones (lugares de uso) se actualizan automáticamente.
Ventajas de los tipos de datos PLC:
● Intercambio de datos sencillo entre varios bloques a través de interfaces de bloque
● Agrupación de datos según el control del proceso
● Transferencia de parámetros como una unidad de datos

Uso de un tipo de datos PLC
Existe la posibilidad de asignar tipos de datos PLC como tipo para crear bloques de datos.
Tomando como base este tipo puede generarse un gran número de bloques de datos con la
misma estructura de datos. Estos bloques de datos pueden adaptarse a la tarea
correspondiente introduciendo los valores actuales necesarios en cada caso.
Por ejemplo, puede crearse un tipo de datos PLC para una receta de mezcla de pinturas. Este
tipo de datos puede asignarse después a varios bloques de datos, cada uno de los cuales
contendrá las cantidades requeridas en su caso.
La figura siguiente muestra este caso de aplicación:

DQ

W LOO

'%$=8/B&(/(67(

3O

7LSRGHGDWRV3/&

D
SD

UD

'%$=8/

8'75HFHWD

Programación del PLC
Manual de programación y manejo, 11/2019

3O D

QW L

OO D

SD

UD

'%/,/$

283

Tipos de datos
3.8 Tipos de datos PLC (UDT)
Los tipos de datos PLC pueden utilizarse para los siguientes fines:
● Pueden utilizarse como tipos de datos de variables en la declaración de variables de
bloques lógicos o en bloques de datos.
● Pueden utilizarse como plantilla para crear bloques de datos globales con la misma
estructura de datos.
● Pueden utilizarse en S7-1200 y S7-1500 como plantilla para crear variables PLC
estructuradas.

Profundidad de anidamiento y número de tipos de datos PLC posible
Es posible definir como máximo 64k de objetos de FC, FB, DB y tipos de datos PLC (pero para
las CPU el número total se limita correspondientemente).
Para cada descripción de estructura (p. ej. un DB o un tipo de datos PLC (UDT)) es posible
definir como máximo 16k de componentes por cada nivel de jerarquía. Estos componentes
también pueden ser de un ARRAY o del tipo de datos STRUCT. En este caso, si un
componente estructurado se deriva de un tipo de datos PLC declarado explícitamente, no
existe limitación alguna. Por tanto, por cada nivel de jerarquía se soportan 16k de
componentes del tipo de datos PLC (UDT)/SDT. Sin embargo, de los 16k de componentes,
como máximo 252 pueden ser "estructuras anónimas".
Los tipos de datos PLC pueden anidarse hasta una profundidad de 8 niveles de jerarquía. Esta
profundidad de anidamiento es independiente de la CPU utilizada.

Desventajas de las estructuras anónimas
Los componentes de variables estructuradas pueden direccionarse de forma idéntica. No
depende de si la declaración se ha realizado mediante un tipo de datos PLC o mediante una
estructura anónima.
El uso de estructuras anónimas tiene las desventajas siguientes:
● Reutilizabilidad de la misma estructura mediante copia. Ello dificulta la modificación de la
estructura.
● Las estructuras anónimas no son compatibles con tipos de datos PLC (UDT) de la misma
estructura.
● Rendimiento, puesto que en tiempo de ejecución se comprueba si los tipos de los
componentes de la estructura son idénticos.
● Al utilizar estructuras anónimas, el límite superior se alcanza con mayor facilidad, puesto
que es necesario evaluar todos los componentes individualmente.

284

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.8 Tipos de datos PLC (UDT)

Ejemplo
El siguiente ejemplo muestra la definición del tipo de datos PLC "MyUDT":

Tipos de datos PLC generados por el sistema
Al crear instancias, algunas instrucciones crean tipos de datos PLC propios que se guardan en
la carpeta de proyecto "Tipos de datos PLC". Estos tipos de datos PLC generados por el
sistema no deben utilizarse en una librería, ya que esto provocaría un comportamiento no
deseado del sistema. El sistema genera estos tipos de datos PLC cuando los requiere, por lo
que no es necesario guardarlos en una librería.

Generar fuentes externas a partir de bloques
Al generar fuentes externas a partir de bloques, los cambios de valores predeterminados de
tipos de datos PLC realizados directamente en la interfaz del bloque no se exportan a las
fuentes. Por ese motivo, al volver a importar las fuentes esos valores ya no están disponibles.
En su lugar se vuelven a aplicar los valores predeterminados. Para impedir esta pérdida de
datos en los valores predeterminados modificados, los cambios deben realizarse directamente
en el tipo de datos PLC y no en la interfaz del bloque. De ese modo los cambios sí se exportan
al generar fuentes externas.

Información adicional sobre los tipos de datos PLC (UDT)
Nota
Declaración de los tipos de datos PLC (UDTs):
Estructura de la tabla de declaración para los tipos de datos PLC (Página 7927)
Recomendaciones de programación de los tipos de datos PLC:
Uso de tipos de datos PLC (UDT) (Página 232)
Uso del tipo de datos DB_ANY (Página 216)
Comparación de tipos de datos PLC (UDT) en el programa:
Comparar tipos de datos PLC (Página 8451)

Programación del PLC
Manual de programación y manejo, 11/2019

285

Tipos de datos
3.8 Tipos de datos PLC (UDT)
Nota
Encontrará más información sobre los tipos de datos PLC en el Siemens Industry Online
Support, en los artículos siguientes:
¿Cómo se inicializan en el S7-1500 estructuras en áreas de memoria optimizadas con STEP
7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/78678760 (https://
support.industry.siemens.com/cs/ww/es/view/78678760)
¿Cómo se crea un tipo de datos PLC (UDT) en un controlador S7-1500?
https://support.industry.siemens.com/cs/ww/es/view/67599090 (https://
support.industry.siemens.com/cs/ww/es/view/67599090)
¿Cómo se lleva a cabo la aplicación selectiva de tipos de datos PLC propios (UDT) en STEP
7 (TIA Portal)?
https://support.industry.siemens.com/cs/es/es/view/67582844 (https://
support.industry.siemens.com/cs/de/en/view/67582844)
¿Por qué para el S7-1500 deben transferirse estructuras completas al llamar un bloque, en
lugar de muchos componentes individuales?
https://support.industry.siemens.com/cs/ww/es/view/67585079 (https://
support.industry.siemens.com/cs/ww/es/view/67585079)

Consulte también
Direccionar tipos de datos PLC (UDT) (Página 287)
Declarar variables basadas en un tipo de datos PLC (Página 7800)
Declarar variables basadas en un tipo de datos PLC (Página 7852)
Comparación de variables PLC (Página 8416)
Crear variables PLC estructuradas (Página 7907)
Direcciones y tipos de datos admisibles para variables PLC (Página 7893)
CMP ==: Igual (Página 725)
Transferir variable del tipo de datos PLC (UDT) (Página 286)

3.8.2

Transferir variable del tipo de datos PLC (UDT)

Descripción
Las variables declaradas como tipo de datos PLC (UDT) también pueden transferirse como
parámetros actuales. Si el parámetro formal está declarado en la declaración de variables
como tipo de datos PLC (UDT), es necesario transferir como parámetro actual una variable que
sea del mismo tipo de datos PLC (UDT).

286

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.8 Tipos de datos PLC (UDT)
El elemento de una variable declarada mediante un tipo de datos PLC (UDT) también puede
transferirse como parámetro actual al llamar un bloque, siempre y cuando el tipo de datos del
elemento de la variable coincida con el tipo de datos del parámetro formal.
Las estructuras y los tipos de datos PLC personalizados pueden asignarse entre sí si tienen
estructuras idénticas. Esto implica que los tipos de datos y el orden de todos los componentes
de la estructura deben ser idénticos. En estructuras anidadas también deben coincidir los tipos
de datos y el orden de las estructuras subordinadas y sus componentes.
También es posible asignar entre sí dos tipos de datos PLC diferentes si los tipos de datos y
el orden de todos los componentes de la estructura, incluidos los de las estructuras
subordinadas, son idénticos. Los nombres de los tipos de datos PLC no tienen que coincidir.
Las estructuras o los tipos de datos PLC definidos por usuario no pueden asignarse a tipos de
datos de sistema.

Consulte también
Reglas para el suministro de parámetros de bloque (Página 80)

3.8.3

Direccionar tipos de datos PLC (UDT)

Direccionamiento de elementos de un tipo de datos PLC
Para acceder a los elementos de un tipo de datos PLC se utiliza la sintaxis siguiente:
<NombreDeTipoDeDatosPLC>.<NombreDelElemento>

Ejemplos
Ejemplos de direccionamiento de variables de tipo estructurado:
Direccionamiento

Explicación

Values.Temperature

Direccionamiento del elemento "Temperature" en la variable "Values", basada en un tipo de datos PLC.

Consulte también
Direccionar variables en bloques de datos globales (Página 112)

Programación del PLC
Manual de programación y manejo, 11/2019

287

Tipos de datos
3.9 Estructura de datos STRUCT (estructuras anónimas)

3.9

Estructura de datos STRUCT (estructuras anónimas)

3.9.1

Principios básicos de STRUCT

Descripción
El tipo de datos STRUCT representa una estructura de datos compuesta por un número fijo de
componentes de diferentes tipos de datos. Los componentes de los tipos de datos STRUCT o
ARRAY también pueden anidarse en una estructura. Con ayuda de estructuras es posible
agrupar datos en función del control del proceso y transmitir parámetros como una unidad de
datos.
Las declaraciones de estructuras que se utilizan directamente en la variable se denominan
estructuras anónimas. Una estructura anónima puede tener el aspecto siguiente:

Todas las explicaciones siguientes se refieren a esta configuración de estructuras.

Profundidad de anidamiento y número de estructuras posible
Una estructura anidada contiene como mínimo una estructura más como componente. Se
pueden definir 65535 FC, FB, DB y tipos de datos PLC respectivamente. Para cada CPU rige
un límite superior especial en cuanto a tipos de bloque y a la suma de todos los bloques.
Para cada descripción de estructura (p. ej. un DB o un tipo de datos PLC (UDT)) es posible
definir como máximo 16k de componentes por cada nivel de jerarquía. Estos componentes
también pueden ser de un ARRAY o del tipo de datos STRUCT. En este caso, si un
componente estructurado se deriva de un tipo de datos PLC declarado explícitamente, no
existe limitación alguna. Por cada nivel de jerarquía se soportan 16k de componentes del tipo
de datos PLC (UDT)/SDT. Sin embargo, dentro de un bloque, como máximo 252 pueden ser
"estructuras anónimas".
Las estructuras (STRUCT) pueden anidarse hasta una profundidad de 8 niveles de jerarquía.
Esta profundidad de anidamiento es independiente de la CPU utilizada.

288

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.9 Estructura de datos STRUCT (estructuras anónimas)

Transferir STRUCT para el suministro de parámetros
El tipo de datos STRUCT se puede transferir como parámetro. Encontrará más información
sobre el suministro de parámetros con STRUCT aquí:
Transferir variables del tipo de datos STRUCT (Página 292)

Desventajas de las estructuras anónimas
Los componentes de la variable estructurada pueden estar direccionados de forma idéntica.
No depende de si la declaración se ha realizado mediante un tipo de datos PLC o mediante una
estructura anónima.
El uso de estructuras anónimas tiene las desventajas siguientes:
● Mayor esfuerzo de mantenimiento: Si una estructura anónima se ha copiado varias veces,
al modificarla también debe modificarse varias veces.
● Las estructuras anónimas no son compatibles con tipos de datos PLC (UDT) de la misma
estructura.
● Rendimiento, puesto que se comprueba si los componentes de la estructura son del mismo
tipo.
● Mayor necesidad de espacio: Cada estructura anónima es un objeto propio cuya
descripción se carga en el sistema de automatización.

Ejemplo
Si se declara la variable del tipo de datos STRUCT en un tipo de datos PLC (UDT), se dispone
de más posibilidades de uso (ver figura izquierda). Sin embargo, la variable también puede
declararse directamente con el tipo de datos STRUCT (consulte la figura derecha).
Declaración de la variable estructurada "Motor" con o sin tipo de datos PLC (UDT):
Variable estructurada con tipo de datos PLC (UDT) Variable estructurada sin tipo de datos PLC (UDT)

Programación del PLC
Manual de programación y manejo, 11/2019

289

Tipos de datos
3.9 Estructura de datos STRUCT (estructuras anónimas)

Procesamiento de estructuras complejas
Una serie de instrucciones (p. ej. "Serialize: Serializar", "Deserialize: Deserializar", "CMP"
(comparador) y "MOVE: Copiar valor") pueden procesar variables muy grandes y con
estructuras complejas. Para ello, la CPU analiza la estructura de variable y ejecuta la
instrucción adecuada para cada subestructura incluida en la estructura global y para todos los
componentes elementales incluidos.
Si la estructura es muy compleja, es posible que el análisis provoque un aumento inesperado
del tiempo de ejecución de la instrucción en cuestión. Además de la complejidad de las
variables estructuradas que se indica en la operación, también influye en el tiempo de
ejecución el número total de las estructuras anónimas declaradas en el programa. Un número
muy elevado de diferentes definiciones de estructuras anónimas puede incrementar todavía
más el tiempo de ejecución.
Solución:
● Evite las estructuras anónimas. Utilice en su lugar tipos de datos PLC.
● Evite la declaración repetida de estructuras de datos similares. Intente agruparlas en una
declaración de estructura.
● Evite declarar muchas variables individuales en estructuras y bloques de datos si tienen el
mismo tipo de datos. Utilice en ese caso el tipo de datos ARRAY, siempre que fuera posible.

Consulte también
Vista general de los tipos de datos válidos (Página 241)

3.9.2

Estructura de una variable STRUCT

Introducción
En un bloque no optimizado, una variable STRUCT comienza siempre en un límite de palabra,
es decir, en un byte con dirección par. Seguidamente se encuentran los diferentes
componentes en el orden de su declaración en la memoria. Las variables STRUCT ocupan la
memoria hasta el siguiente límite de palabra.
Los componentes de tipo de datos BOOL comienzan en el bit menos significativo del siguiente
byte. Los componentes de los tipos de datos BYTE y CHAR comienzan en el siguiente BYTE.
Los componentes de otros tipos de datos comienzan en un límite de palabra. En bloques
optimizados las estructuras se depositan de tal forma que todos los componentes están
alineados en función de su ancho. El orden dentro de la memoria no se corresponde con la
representación en el editor.
Una estructura anidada es una estructura como componente de otra estructura. La
profundidad de anidamiento máxima posible es de 8 estructuras. En la sección "InOut" la
profundidad de anidamiento máxima posible es de 9 estructuras. La profundidad de
anidamiento se calcula incluyendo el elemento superior de la estructura (ejemplo:
"Ana.Berta.Carla" equivale a una profundidad de anidamiento de 3).

290

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.9 Estructura de datos STRUCT (estructuras anónimas)
Se puede acceder individualmente a todos los componentes. Los distintos nombres de los
componentes van separados por un punto.
Estructura de una variable STRUCT con tipos de datos simples y compuestos en el área de
memoria no optimizada:
● Declaración de la variable STRUCT "Motor"

● Requisitos de memoria de la variable STRUCT "Motor"

%\WHQ















 













9DOYHV FRPSRQHQWHVGHELW\ELWVGHUHOOHQR

%\WHQ

%\WH

6SHHGB0LQ FRPSRQHQWHGHE\WH

%\WHQ

%\WH

6SHHGB0D[ FRPSRQHQWHGHE\WH

%\WHQ
%\WHQ
%\WHQ

E\WHGHUHOOHQR
7HPSHUDWXUH FRPSRQHQWHGHSDODEUD

3DODEUD

%\WHQ

   

%\WHQ

%\WH



3.9.3











$[HV FRPSRQHQWHVGHELW\ELWVGHUHOOHQR
2LO FRPSRQHQWHGHE\WH

Q SDU

Direccionamiento de componentes STRUCT

Direccionamiento de componentes en estructuras
A los distintos componentes de una estructura se accede con la sintaxis siguiente:
"DBname".name1.name2.name3

Programación del PLC
Manual de programación y manejo, 11/2019

291

Tipos de datos
3.9 Estructura de datos STRUCT (estructuras anónimas)

Ejemplo
El siguiente ejemplo muestra el direccionamiento de variables de tipo de datos estructurado:
Direccionamiento

Explicación

"Global_DB".Motor.Valves[2] Direccionamiento de la 3.ª válvula del elemento "Valves"
en la estructura Motor del bloque de datos global "Global_DB".

3.9.4

Transferir variables del tipo de datos STRUCT

Descripción
Si el componente tiene el mismo tipo de datos que el parámetro formal, los distintos
componentes de una variable STRUCT también se podrán transferir como parámetros
actuales.
También es posible transferir estructuras completas como parámetros. Si un bloque tiene un
parámetro de entrada del tipo de datos STRUCT, es preciso transferir un STRUCT con idéntica
estructura como parámetro actual. Esto implica que los nombres y los tipos de datos de todos
los componentes de estructura deben ser idénticos.
Las estructuras y los tipos de datos PLC personalizados pueden asignarse entre sí si tienen
estructuras idénticas. Esto implica que los tipos de datos y el orden de todos los componentes
de la estructura deben ser idénticos. En estructuras anidadas también deben coincidir los tipos
de datos y el orden de las estructuras subordinadas y sus componentes.
También es posible asignar entre sí dos tipos de datos PLC diferentes si los tipos de datos y
el orden de todos los componentes de la estructura, incluidos los de las estructuras
subordinadas, son idénticos. Los nombres de los tipos de datos PLC no tienen que coincidir.
Las estructuras o los tipos de datos PLC definidos por usuario no pueden asignarse a tipos de
datos de sistema.
Nota
Se recomienda programar estructuras como tipos de datos PLC (UDT). Los tipos de datos PLC
(UDT) facilitan la programación, puesto que pueden utilizarse varias veces y modificarse de
forma centralizada.

Consulte también
Reglas para el suministro de parámetros de bloque (Página 80)

292

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.10 ARRAY

3.10

ARRAY

3.10.1

Principios básicos del ARRAY

Descripción
Una variable del tipo de datos ARRAY representa una estructura de datos compuesta por un
número fijo de componentes del mismo tipo de datos. Para los componentes se permiten todos
los tipos de datos salvo ARRAY.
Al crear una variable ARRAY, los límites de indexación se definen entre corchetes, y el tipo de
datos se define después de la palabra clave "of". Los límites del ARRAY no solo pueden
definirse de forma fija con números enteros o constantes globales o locales o como parámetros
formales de un bloque, sino también de forma variable mediante ARRAY[*]. El límite inferior
debe ser menor o igual que el límite superior. Un ARRAY puede contener hasta seis
dimensiones, cuyos límites se especifican separados entre sí por comas.
La estructura de una variable unidimensional del tipo de datos ARRAY tiene, por ejemplo, el
siguiente aspecto:

ಯ6WDWLRQರ $55$<>@RI,17



6WDWLRQ>@



6WDWLRQ>@



6WDWLRQ>@

Los límites máximos del ARRAY dependen de los siguientes factores:
● Tipo de datos del componente ARRAY
● Reserva de memoria (solo en bloques de acceso optimizado)
Encontrará más información al respecto en: Principios básicos para cargar ampliaciones de
bloque sin reinicializar (Página 8385).
● Tamaño máximo del bloque de datos
● Capacidad de memoria máxima de la CPU (encontrará información adicional en el manual
de producto correspondiente)
La tabla siguiente muestra las propiedades del tipo de datos ARRAY:
Propiedad de blo‐
que

Formato

Límites de ARRAY

Tipo de datos

Estándar

ARRAY[valor límite infe‐
rior... valor límite superior]
of <tipo de datos>

[-32 768..32 767] of <tipo
de datos>

Todos los tipos de datos
salvo ARRAY

[-2 147 483 648..2 147
483 647] of <tipo de da‐
tos>

Multiinstancias

Optimizado

Programación del PLC
Manual de programación y manejo, 11/2019

293

Tipos de datos
3.10 ARRAY
Dependiendo de si ha declarado la ARRAY, hay diferentes formas de definir los límites de una
ARRAY:
Límites de ARRAY

Bloque de datos global / tabla de
variables

Interfaz del bloque

Uso de enteros como límites de
ARRAY fijos

x

x

Uso de constantes globales co‐
mo límites de ARRAY fijos

x

x

Uso de constantes locales como
límites de ARRAY fijos

-

x

Uso de límites de ARRAY varia‐
bles ARRAY[*]

-

x

ARRAY de multiinstancias

-

x

Encontrará más información sobre la sección de la interfaz del bloque en la que se puede
definir una ARRAY o una ARRAY[*] aquí: Tipos de datos válidos en la interfaz de bloque
(Página 7787)
Nota
Válido para las CPU de la serie S7-1500
Con un bloque con la propiedad "Acceso optimizado al bloque", un elemento del tipo de datos
BOOL requiere 1 byte de memoria. Esto también es válido si se utiliza un ARRAY of <tipo de
datos>. Así, p. ej., un ARRAY[0..1] of BOOL requiere 2 bytes en un bloque de programa
optimizado.

Uso de enteros como límites de ARRAY fijos
Se pueden utilizar enteros como límites de ARRAY fijos:
● Ejemplo de una ARRAY unidimensional

● Ejemplo de una ARRAY bidimensional

294

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.10 ARRAY

Uso de constantes como límites de ARRAY fijos
Las constantes locales o globales pueden utilizarse como límites de ARRAY fijos:
● Límites de ARRAY fijos para un ARRAY unidimensional compuesto por dos constantes de
usuario globales

● Límites de ARRAY fijos para un ARRAY unidimensional compuesto por dos constantes de
usuario locales

● Límites de ARRAY fijos para un ARRAY bidimensional compuesto por constantes de
usuario globales y locales

Encontrará más información sobre la generación y el uso de constantes como límites de
ARRAY aquí:
● Declarar variables y constantes locales en la interfaz del bloque (Página 7793)
● Ejemplos de uso de constantes (Página 108)

Programación del PLC
Manual de programación y manejo, 11/2019

295

Tipos de datos
3.10 ARRAY

Uso de enteros y constantes globales y locales como límites de ARRAY fijos
También es posible combinar entre sí las tres posibilidades anteriores y utilizar como límites de
ARRAY también enteros y constantes globales y locales mezcladas dentro de un ARRAY:

Uso de límites de ARRAY variables ARRAY[*] (solo en bloques de acceso optimizado)
Con ayuda de ARRAY[*] se pueden programar bloques que puedan procesar un ARRAY de
longitud variable. Para ello se declaran límites de ARRAY variables en los parámetros de una
función o de un bloque de función. ARRAY[*] está disponible en todos los lenguajes de
programación.
Con las instrucciones "LOWER_BOUND" y "UPPER_BOUND" existe la posibilidad de leer los
límites inferior y superior de un ARRAY en tiempo de ejecución con límites variables,
respectivamente.
Nota
Disponibilidad de ARRAY[*]
ARRAY[*] está disponible en las CPU de la serie S7-1200 a partir de la versión de firmware >=
4.2 y en las CPU de la serie S7-1500 a partir de la versión de firmware >= 2.0 en bloques
optimizados. En las funciones (FC) es posible utilizar ARRAY[*] en todas las secciones de
declaración. En los bloques de función (FB) solo es posible declarar ARRAY[*] como
parámetro de entrada/salida en la sección "InOut".

296

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.10 ARRAY
● Límites de ARRAY variables para un ARRAY unidimensional:

● Límites de ARRAY variables para un ARRAY tridimensional:

Encontrará más información sobre el uso de ARRAY[*] aquí:
● Transferir variables del tipo de datos ARRAY / ARRAY[*] (Página 302)
● Declarar variables del tipo de datos ARRAY (Página 7796) en la interfaz del bloque

Uso de multiinstancias (solo en bloques de acceso optimizado)
Las multiinstancias también pueden crearse como ARRAY, p. ej. para poder direccionar
multiinstancias individuales con un índice variable al ejecutar bucles de programa:

Encontrará más información sobre la generación y el uso de multiinstancias aquí:
● Multiinstancias (Página 64)
● Declarar multiinstancias (Página 7802)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Direccionar indirectamente elementos de ARRAY (Página 213)

Programación del PLC
Manual de programación y manejo, 11/2019

297

Tipos de datos
3.10 ARRAY

3.10.2

Estructura de una variable ARRAY

Introducción
En bloques no optimizados, una variable ARRAY comienza siempre en un límite de palabra,
es decir, en un byte con dirección par. Las variables ARRAY ocupan la memoria hasta el
siguiente límite de palabra.
En bloques optimizados el ARRAY requiere tanto espacio como el elemento más ancho de su
estructura. Eso significa, p. ej., que un ARRAY of BYTE se encuentra en un límite de byte y un
ARRAY of LREAL en un límite de 8 bytes.
Estructura de una variable ARRAY en el campo unidimensional:
1¼PHURGHELW
%\WHQ

































%\WHQ

HWF

%\WHQ

%\WH

%\WHQ

%\WH

%\WHQ

%\WH

%\WHQ

HWF

%\WHQ
%\WHQ
%\WHQ
%\WHQ
%\WHQ
%\WHQ

     

3DODEUD

3DODEUD

8QFDPSRGH
FRPSRQHQWHVGHDQFKR
GHELW
8QFDPSRGHFRPSRQHQWHV
GHDQFKRGHE\WH

8QFDPSRGHFRPSRQHQWHV
GH
DQFKRGHSDODEUD
/RVFDPSRVGHFRPSRQHQWHVGHDQFKR
GHSDODEUDGREOH\SDODEUDODUJDWLHQHQ
XQDHVWUXFWXUDDQ£ORJD

HWF

 Q SDU

Los componentes del tipo de datos BOOL comienzan en el bit menos significativo. Los
componentes con los tipos de datos BYTE y CHAR comienzan en el byte derecho. Los
diferentes componentes se relacionan en orden.
Estructura de una variable ARRAY en el campo multidimensional:

298

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.10 ARRAY

(MHPSORGHDVLJQDFLµQGHE\WHGHODYDULDEOH
)HOGYDUGHOWLSRGHGDWRV
$55$<>@RI%<7(
%\WHQ

)HOGYDU>@

%\WHQ

)HOGYDU>@

%\WHQ

)HOGYDU>@

%\WHQ

)HOGYDU>@

%\WHQ

)HOGYDU>@

%\WHQ

)HOGYDU>@

%\WHQ

)HOGYDU>@

%\WHQ

)HOGYDU>@

%\WHQ

)HOGYDU>@

%\WHQ

)HOGYDU>@

%\WHQ

)HOGYDU>@

%\WHQ

)HOGYDU>@

lGLPHQVLRQ

lGLPHQVLRQ

lGLPHQVLRQ

lGLPHQVLRQ

En campos multidimensionales, los componentes se depositan por líneas (por dimensiones),
comenzando por la primera dimensión. Cada nueva dimensión comienza con componentes de
bit o de byte siempre en el byte siguiente. En componentes de otros tipos de datos, en bloques
no optimizados siempre empieza en la palabra siguiente (en el siguiente byte par).
En bloques optimizados cada dimensión requiere el mismo espacio que la primera dimensión.

3.10.3

Direccionar componentes de ARRAY

Introducción
Los componentes de ARRAY se direccionan con índice fijo o variable. Los componentes de
una variable ARRAY pueden tratarse como variables del mismo tipo de datos.
El índice del componente se indica entre corchetes. Por cada dimensión ARRAY el índice
contiene un valor entero (índice fijo) o una variable (índice variable).

Programación del PLC
Manual de programación y manejo, 11/2019

299

Tipos de datos
3.10 ARRAY

Direccionamiento de componentes de ARRAY con índice fijo
El direccionamiento de un componente de ARRAY con índice fijo se desarrolla del siguiente
modo:

Direccionamiento de componentes ARRAY con índice variable
Un componente de ARRAY también puede direccionarse con una variable, cuyo valor solo se
calcula en tiempo de ejecución. La variable puede ser una variable global o local con
direccionamiento absoluto o simbólico del tipo de datos entero. El direccionamiento también es
posible con ARRAYs multidimensionales y en el direccionamiento de campos parciales.
(<ArrayName>[i,j,k...])
En un componente de ARRAY direccionado mediante índice variable y creado como
parámetro actual en un parámetro de entrada/salida, un cambio de la variable en el bloque
llamado no tiene ningún efecto. El valor se vuelve a escribir en el componente de ARRAY
transferido en la llamada del que se ha leído.
El direccionamiento de un componente de ARRAY con una variable de indexación se
desarrolla del siguiente modo:

300

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.10 ARRAY
Encontrará más información sobre el direccionamiento indirecto de componentes de ARRAY
aquí:
● Indexación indirecta de componentes de ARRAY (Página 128)
● Recomendaciones de programación:Direccionar indirectamente elementos de ARRAY
(Página 213)

Tratamiento de errores en accesos de ARRAY
Los errores de acceso se producen cuando se accede en tiempo de ejecución a un elemento
que está fuera de los límites de ARRAY declarados. Las diferentes familias de CPU reaccionan
de diferente manera a los rebases de los límites de ARRAY:
● S7-300/400
– La CPU cambia al estado operativo "STOP".
– Para evitar esto, se puede programar el OB de error de ejecución del programa (OB 85).
– En SCL también existe la posibilidad de activar el atributo "Comprobar límites de
ARRAY" en las propiedades del bloque. Esto hace que, en caso de errores de acceso
a ARRAY, la salida de habilitación ENO se ponga a FALSE.
● S7-1200
– La CPU genera una entrada en el búfer de diagnóstico y permanece en estado operativo
"RUN".
● S7-1500
– La CPU cambia al estado operativo "STOP".
– Para evitar esto, se puede programar el OB de error de programación (OB 121).
– Además, existe la posibilidad de programar el tratamiento local de errores con las
instrucciones "GET_ERROR: Consultar error localmente" o "GET_ERROR_ID:
Consultar ID de error localmente".
Nota
Vigilancia de errores de acceso a ARRAY mediante ENO
La salida de habilitación ENO no adopta el estado lógico FALSE cuando se superan los límites
de ARRAY al ejecutar una instrucción. Son excepción los bloques SCL en las CPU de las
series S7-300/400, para las que está activada la propiedad de bloque "Comprobar límites de
ARRAY".

Programación del PLC
Manual de programación y manejo, 11/2019

301

Tipos de datos
3.10 ARRAY

3.10.4

Transferir variables del tipo de datos ARRAY / ARRAY[*]

Transferir variables del tipo de datos ARRAY
Si el elemento es del mismo tipo de datos que el parámetro formal, los distintos elementos de
un ARRAY también se podrán transferir como parámetros actuales.
Existe la posibilidad de transferir variables del tipo de datos ARRAY como parámetros. Si un
bloque tiene un parámetro de entrada del tipo de datos ARRAY, es preciso transferir un
ARRAY con idéntica estructura como parámetro actual. Eso significa que el tipo de datos, el
número de dimensiones y el número de componentes del campo deben ser idénticos.
Los ARRAYs pueden asignarse entre sí si tienen estructuras idénticas. Eso significa que el tipo
de datos, el número de dimensiones y el número de componentes del campo deben ser
idénticos. Los nombres de los ARRAYs no tienen que coincidir.

Transferir variables del tipo de datos ARRAY[*]
ARRAY[*] permite declarar ARRAYs con límites variables en los parámetros de una función o
un bloque de función. Al crear el bloque se pueden definir los límites del ARRAY que se
transferirá después en tiempo de ejecución tras la llamada en tiempo de ejecución.
La figura siguiente muestra dos llamadas de un bloque con un parámetro de entrada del tipo
de datos ARRAY[*]. En cada llamada se transfieren ARRAYs de diferente longitud.

302

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.10 ARRAY

Reglas vigentes para la transferencia de ARRAYs con límites flexibles
Cree para el ejemplo la función "BlockWithArrayStarIn_FC" para poder llamarla
posteriormente:

Programación del PLC
Manual de programación y manejo, 11/2019

303

Tipos de datos
3.10 ARRAY
Se admite la asignación de ARRAY[*] a ARRAY[*] si coinciden el número de dimensiones y el
tipo de datos. Sin embargo, en este caso no es posible transferir los diferentes componentes
del ARRAY:
1. Declare el bloque de función "BlockCaller_FB" y llame la función
"BlockWithArrayStarIn_FC":

Se admite la asignación de un ARRAY con límites conocidos a un ARRAY[*] si coinciden el
número de dimensiones y el tipo de datos. En este caso también es posible asignar
componentes individuales del ARRAY:
1. Declare el bloque de función "BlockCallerFixLimits_FB" y llame la función
"BlockWithArrayStarIn_FC" dos veces:

304

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.10 ARRAY
Se admite la asignación de ARRAY[*] a VARIANT. En este caso también es posible asignar
componentes individuales del ARRAY.
1. Cree la función "BlockWithVariantIn_FC" para poder llamarla:

2. Declare la función "BlockWithArrayStarInVariant_FC" y llame la función
"BlockWithVariantIn_FC":

No se admite la asignación de ARRAY[*] a ARRAYs con límites fijos.
Nota
Los parámetros de bloque del tipo ARRAY[*] deben recibir necesariamente un parámetro
actual.

Consulte también
Reglas para el suministro de parámetros de bloque (Página 80)

Programación del PLC
Manual de programación y manejo, 11/2019

305

Tipos de datos
3.10 ARRAY

3.10.5

Ejemplos de uso de ARRAYs

3.10.5.1

Ejemplo de ARRAY multidimensional

Descripción
Las variables del tipo de datos ARRAY pueden contener hasta 6 dimensiones. Son aplicables
las mismas condiciones que para los ARRAYs unidimensionales. Los rangos de las
dimensiones se escriben en la declaración entre corchetes, separadas entre sí por una coma.
En ARRAYs multidimensionales, los componentes se depositan comenzando por la primera
dimensión.
La tabla siguiente muestra la declaración de una variable bidimensional del tipo de datos
ARRAY:
Nombre

Tipo de datos

Betr_Temp

ARRAY[1..2, 1..3] of INT 1,1,4(0)

Valor

Comentario
Variable bidimensional
del tipo de datos
ARRAY con 6 compo‐
nentes. A los dos prime‐
ros componentes se les
asigna el valor "1". A los
cuatro componentes
restantes se les asigna
el valor "0".

La figura siguiente muestra la estructura de las variables del tipo de datos ARRAY declaradas:
6WDWLRQ>@
6WDWLRQ>@
6WDWLRQ>@
6WDWLRQ $55$<>@RI,17
6WDWLRQ>@
6WDWLRQ>@
6WDWLRQ>@

Acceso a los componentes
Para acceder a los valores de los distintos componentes se utiliza un índice. Para el índice
puede utilizarse una constante o una variable. El índice del primer componente es p. ej. [1,1]
y el índice del cuarto componente, [2,1]. En el programa es necesario indicar, p. ej.,
"Station[2,1]" para acceder al valor del cuarto componente.

306

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.10 ARRAY

3.10.5.2

Ejemplo de cálculo del producto escalar de dos vectores con ARRAY[*]

Descripción
El producto escalar es una operación matemática que asigna un número (escalar) a dos
vectores.
El producto escalar de dos vectores da como resultado una magnitud escalar y se define por:

Aquí ∝ es el ángulo entre los vectores D y E .
Ejemplo de cálculo de un producto escalar:

En este caso, el resultado es el número 22.
En el ejemplo de programación siguiente verá cómo, por medio del ARRAY[*], se puede
calcular el producto escalar de dos vectores con límites de ARRAY flexibles. La función
"ScalarProduct_FC" sirve de plantilla para calcular cada uno de los productos escalares.
Para el ejemplo de programación se necesitan los objetos siguientes:
● Dos bloques de datos y un tipo de datos PLC (UDT) para administrar los datos de los
vectores.
● La función que contiene el código para calcular un producto escalar.
● Las instrucciones "LOWER_BOUND" y "UPPER_BOUND" para leer los límites del ARRAY.
● Bloque de organización para calcular los productos escalares.

Procedimiento
En este ejemplo se utilizan vectores, es decir, ARRAYs de 1 dimensión. Otros cálculos como,
p. ej., las multiplicaciones de matrices, también pueden funcionar con ARRAYs
multidimensionales.

Programación del PLC
Manual de programación y manejo, 11/2019

307

Tipos de datos
3.10 ARRAY
Para calcular los productos escalares, haga lo siguiente:
1. Cree el tipo de datos PLC (UDT) "VectorArrays_UDT":

Los datos de los ARRAY "VectorD5Coordinates" y "VectorE13Coordinates" le permitirán
calcular los productos escalares a continuación.
2. Cree el bloque de datos "VectorArrays1_DB" basándose en el tipo datos PLC
"VectorArrays_UDT":

3. Cree el segundo bloque de datos "VectorArrays2_DB". Este contiene, además de los
vectores del tipo de datos PLC "VectorArrays_UDT", dos vectores más:

Ahora ya ha creado los datos necesarios para calcular los productos escalares.

308

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.10 ARRAY
4. Para crear el método de cálculo de un producto escalar, cree la función "ScalarProduct_FC"
como plantilla:
Interfaz de bloque:

Código de programa:

En las líneas 1-4 se consultan los límites de ARRAY superiores e inferiores de los vectores
1 y 2. Así se sabe cuántas coordenadas tienen los dos ARRAY de los vectores. Dado que
el producto escalar solo se puede formar cuando el número de coordenadas de los dos
vectores que se quieren multiplicar entre sí coincide, se necesitan las líneas de la 6 a la 9.
Si los dos límites superiores o inferiores de los ARRAY son diferentes, la función
"ScalarProduct_FC" devuelve el valor de función "-1" y se abandona el bloque de programa
(RETURN).
Si los dos límites superiores o inferiores de los ARRAY son iguales, se inicializa la variable
#Sum con el valor "0" (línea 10) y se efectúa el cálculo de los productos escalares (líneas
11-13).
5. Cree el bloque de organización "Main_OB" con la clase de evento "Program cycle". La
función "ScalarProduct_FC" creada en el paso 4 sirve ahora en el "Main_OB" de plantilla
para calcular los productos escalares:

Programación del PLC
Manual de programación y manejo, 11/2019

309

Tipos de datos
3.11 Puntero
Interfaz de bloque:

Código de programa:

Resultado
Los resultados de los distintos cálculos de los productos escalares se escriben en las variables
#Result1 -5.

3.11

Puntero

3.11.1

Referencias

3.11.1.1

Principios básicos de las referencias

Descripción
Una referencia es una variable que no contiene ningún valor por sí misma, sino que señala a
la ubicación de otra variable.

310

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero
Las referencias permiten transferir variables más allá de los límites de bloques y, con ello,
manipular directamente los valores de las variables sin tener que crear una copia de las
mismas.
Al declarar la referencia debe indicarse el tipo de datos que debe tener la variable referenciada.
Las referencias tienen seguridad de tipo. Esto es especialmente importante para sistemas de
controlador en los que tienen que evitarse errores de tiempo de ejecución. La restricción
aplicada en CEI, según la cual no deben formarse referencias a elementos de datos
temporales, incrementa todavía más la seguridad. De este modo es posible evitar situaciones
de error en el comportamiento en tiempo de ejecución.
Queda garantizado que las referencias señalan a una ubicación válida del tipo de datos
correcto o bien están ocupadas con el valor NULL.

Utilizar referencias en el programa
Para utilizar referencias es imprescindible disponer de una CPU de la serie S7-1500 con la
versión de firmware V2.5 o superior.
El siguiente gráfico proporciona una vista general de las posibilidades de uso de referencias.

Programación del PLC
Manual de programación y manejo, 11/2019

311

Tipos de datos
3.11 Puntero

,QVWUXFFLµQ

$SOLFDFLµQ

Declarar referencias

#myRefInt : REF_TO INT;

REF_TO <data type>

0£VLQIRUPDFLµQ
Declarar referencias

#myRefType : REF_TO myType;

Declaración de la referencia en la
interfaz del bloque

#myRefArray : REF_TO Array[0..100] of myType;

Referenciar

#myRefInt := REF (#myInt);

REF (<tag>)

#myRefType := REF ("myDB".myType);

Crear una referencia a una variable
concreta

#myRefArray := REF (#myArray);
//myInt and myArray defined in Static

Desreferenciar
<Reference>^

#myInt := #myRefInt^;

Acceso al valor de la
variable referenciada

Referenciar

Desreferenciar

#myInt := #myRefType^.elementOfInt;
#myInt := #myRefArray^[#index].elementOfInt;

Instrucciones estándar
con referencias
Asignación

Comparación

#myRefInt := #yourRefInt;
#myVARIANT := #myReference;
//myVARIANT defined in Temp

Instrucciones estándar
con referencias

IF #myRefInt = NULL THEN...;
IF #myRefInt <> NULL THEN...;

Intento de asignación
<Reference> ?= <VARIANT>
Intento de asignación de una
variable del tipo de datos VARIANT
a una variable de referencia

Asignación en la llamada del
bloque
Transferencia de referencias al llamar
a funciones o bloques de función

312

#myReference ?= #myVariant;

Intento de asignación

"Callee"(MyRefIn1:= REF("MyDataBlock".MyInt),
MyRefIn2:= NULL,
MyRefOut=> #MyRefWord);
//MyRefWord defined in Temp

Transferir referencias
como parámetros del
bloque

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Diferencias entre referencias y VARIANT
Una variable del tipo de datos VARIANT es como un puntero que puede señalar a otras
variables de cualquier tipo de datos. Por ese motivo, en el momento de crear el programa aún
no está definido el tipo de datos al que señalará la variable VARIANT. El tipo de datos se
determina en tiempo de ejecución. Una variable VARIANT puede adoptar incluso varios tipos
de datos en ciclos de programa distintos. Así, por ejemplo, el tipo de datos VARIANT es
adecuado para crear programas genéricos y para el direccionamiento indirecto. Sin embargo,
para seguir procesando una variable VARIANT en el código del programa, primero debe
determinarse el tipo de datos actual utilizando instrucciones especiales. Asimismo, no es
posible leer ni escribir directamente variables VARIANT, sino que para ello se necesitan
también instrucciones especiales, p. ej. VariantGet y VariantPut.
Si se utilizan referencias, el tipo de datos se define ya al crear el programa. Puesto que no es
necesario determinar el tipo de datos en tiempo de ejecución, el programa rinde más y es más
claro. Con el desreferenciado es posible acceder directamente a la variable referenciada en
modo de escritura o lectura, sin integrar instrucciones adicionales en el programa.
Sin embargo, al contrario que con VARIANT, las referencias solo pueden señalar a datos que
se encuentren en un área de memoria optimizada.

Ejemplos
El siguiente ejemplo muestra diferentes posibilidades de aplicación de referencias.
La interfaz de bloque contiene la variable "myRefInt", declarada como referencia:

La siguiente figura muestra cómo utilizar esta variable en SCL:

Programación del PLC
Manual de programación y manejo, 11/2019

313

Tipos de datos
3.11 Puntero

3.11.1.2

Declarar referencias
Declarar referencias
REF_TO <data type>
Declaración de la referencia en la
interfaz del bloque

#myRefInt : REF_TO INT;
#myRefType : REF_TO myType;
#myRefArray : REF_TO Array[0..100] of myType;

Descripción
Las referencias pueden declararse en la interfaz de funciones y bloques de función. Las áreas
de declaración siguientes son admisibles para ello:
● FC: Input, Output, Temp, Return
● FB: Temp
● OB: Temp
Para declarar referencias se utiliza la palabra clave "REF_TO" y se indica el tipo de datos que
debe tener la variable referenciada. En cambio, no se indica la variable concreta a la que
señala la referencia:

314

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Las referencias pueden señalar a los elementos siguientes:
● Secuencias de bits
– Las referencias a BOOL no son posibles.
● Enteros
● Números en coma flotante
● Cadenas de caracteres
– En las cadenas de caracteres no es posible hacer declaraciones de longitud.
● Temporizadores IEC
– Son posibles las referencias a IEC_TIMER e IEC_LTIMER.
– No son posibles las referencias a tipos de datos derivados, p. ej. TON.
● Contadores IEC
– Son posibles las referencias a IEC_COUNTER / IEC_UCOUNTER, IEC_SCOUNTER /
IEC_USCOUNTER, IEC_DCOUNTER / IEC_UDCOUNTER.
– No son posibles las referencias a tipos de datos derivados, p. ej. CTU.
● Tipos de datos PLC (UDT)
● Tipos de datos de sistema (SDT)
● ARRAYs de los tipos de datos citados
– Las referencias a ARRAY[*] no son posibles.
– En la versión actual del TIA Portal no es posible declarar un ARRAY de referencias. No
se admitiría, por tanto, la siguiente declaración:
ARRAY of REF_TO<tipo de datos>

Programación del PLC
Manual de programación y manejo, 11/2019

315

Tipos de datos
3.11 Puntero
Un bloque de datos completo solo puede señalarse si ha sido derivado originalmente de un tipo
de datos PLC (UDT) o de un tipo de datos de sistema (SDT).

Inicialización
Cuando se crea una variable de referencia, el sistema la inicializa con el valor NULL. Esto
significa que, si bien la referencia propiamente dicha existe, todavía no señala a una ubicación
válida. Si se accede realmente a una referencia CERO en tiempo de ejecución, se emite un
error de programación. El usuario no puede realizar una inicialización en la interfaz del bloque.
Para inicializar una referencia utilice la instrucción "REF ()".
Consulte también: Referenciar (Página 316)

Remanencia
Las referencias no pueden ser remanentes. Sin embargo, pueden señalar a datos remanentes.
Nota
Número máximo de parámetros de referencia por bloque
La cantidad máxima permitida de parámetros del tipo de datos "REF_TO" en un bloque
depende de diferentes factores, entre otros del tipo de bloque y el número de otros parámetros
declarados con un tipo de datos estructurado (ARRAYs, tipos de datos PLC, etc.), así como del
número de instancias declaradas.
En caso de exceder el número máximo aparecerá un mensaje durante el proceso de
compilación. En este caso se pueden agrupar varios parámetros en un tipo de datos PLC
(UDT) o en un bloque de datos global (DB) y transferir el tipo o el bloque en forma de parámetro
de bloque.

Consulte también
Principios básicos de las referencias (Página 310)
Tipos de datos válidos en la interfaz de bloque (Página 7787)

3.11.1.3

316

Referenciar
Referenciar

#myRefInt := REF (#myInt);

REF (<tag>)

#myRefType := REF ("myDB".myType);

Crear una referencia a una variable
concreta

#myRefArray := REF (#myArray);
//myInt and myArray defined in Static

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Descripción
Con la palabra clave "REF()" se especifica la variable a la que debe señalar una referencia
previamente declarada. Como parámetro se indica la variable que debe referenciarse. El tipo
de datos de la variable debe coincidir exactamente con el tipo de datos de la referencia
declarada. Una referencia con el tipo de datos "REF_TO Int" sólo puede señalar por tanto a una
variable del tipo de datos "Int". No se produce una conversión de tipos de datos.

Nota
Transferir "REF()" como parámetro actual en la llamada del bloque
"REF()" también puede transferirse como parámetro actual a un bloque llamado en cuya
interfaz se hayan declarado referencias.
Consulte también: Transferir referencias como parámetros de bloque (Página 327)

Reglas
Para el referenciado se aplican las reglas siguientes:
● Los datos que señalan a una referencia deben estar en un área de memoria optimizada.
● La referencia solo debe señalar a los datos de un DB global o a variables estáticas.
● La referencia solo debe señalar a los datos siguientes:
– datos temporales (TEMP)
– variables globales procedentes de la tabla de variables PLC
– parámetros de bloque
– constantes
– variables protegidas contra escritura
● Para referencias a arrays (matrices) rige:
– Los límites de arrays (matrices) y dimensiones de la referencia y de la variable
referenciada deben ser idénticos.
– Las referencias a los arrays con límites dinámicos (Array[*]) no pueden crearse.
– Las referencias a los DB ARRAY que se basan en un tipo de datos PLC deben crearse
del siguiente modo:
REF("my_ArrayDB_UDT"."THIS")
REF("my_ArrayDB_UDT"."THIS"[i])

Programación del PLC
Manual de programación y manejo, 11/2019

317

Tipos de datos
3.11 Puntero

Ejemplos
El siguiente ejemplo muestra la interfaz de un bloque. La interfaz contiene algunos parámetros
que se declararon con el tipo de datos "REF_TO". Al declarar la referencia se define
únicamente el tipo de datos de la variable referenciada, pero no se indica a qué variable debe
señalar la referencia.

En el código del programa se indica a qué variables concretas deben señalar los parámetros
de referencia declarados.
Ejemplos en SCL:

Ejemplos en KOP:

318

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Ejemplos en AWL:

Programación del PLC
Manual de programación y manejo, 11/2019

319

Tipos de datos
3.11 Puntero

Consulte también
Principios básicos de las referencias (Página 310)
Declarar referencias (Página 314)

3.11.1.4

Desreferenciar
Desreferenciar
<Reference>^
Acceso al valor de la
variable referenciada

#myInt := #myRefInt^;
#myInt := #myRefType^.elementOfInt;
#myInt := #myRefArray^[#index].elementOfInt;

Descripción
Para acceder a una variable referenciada en lectura o escritura utilice el carácter "^". Este tipo
de acceso se denomina también "Desreferenciado".

320

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Nota
Antes de poder acceder al valor de una referencia es preciso indicar con la instrucción "REF()"
a qué variable debe señalar la referencia.

Ejemplos
El siguiente ejemplo muestra la interfaz de un bloque. La interfaz contiene el parámetro
"myRefInt" declarado previamente como referencia, así como algunos parámetros estáticos ya
inicializados con un valor:

La siguiente figura muestra cómo indicar en SCL primero con la instrucción "REF()" que la
referencia "myRefInt" señala a "#a" y que, a continuación, se calcula con "#a":

Consulte también
Principios básicos de las referencias (Página 310)

Programación del PLC
Manual de programación y manejo, 11/2019

321

Tipos de datos
3.11 Puntero

3.11.1.5

Instrucciones estándar con referencias
Instrucciones estándar
con referencias
Asignación

Comparación

#myRefInt := #yourRefInt;
#myVARIANT := #myReference;
//myVARIANT defined in Temp
IF #myRefInt = NULL THEN...;
IF #myRefInt <> NULL THEN...;

Las referencias pueden utilizarse como parámetros de entrada o salida de instrucciones de
asignación o comparación.
Los valores desreferenciados pueden interconectarse como parámetros en todas las
instrucciones, siempre que tengan el tipo de datos correcto.

Asignación
Las referencias pueden asignarse entre sí como variables normales. Al hacerlo se asigna la
dirección de la variable referenciada, no su valor. Por tanto, las referencias solo pueden
asignarse entre sí si señalan al mismo tipo de datos. No se produce una conversión implícita
del tipo de datos.
Las referencias a los tipos de datos PLC también deben ser del mismo tipo de datos. No es
suficiente que ambos tipos de datos PLC tengan la misma estructura.
También es posible asignar una referencia a un VARIANT. En este caso, el VARIANT debe
estar declarado como variable temporal (Temp).

Comparación
Las referencias pueden utilizarse en instrucciones de comparación. De ese modo, una
comparación con NULL permite determinar si ya se ha asignado una variable a una referencia.
Esto es aconsejable cuando el flujo del programa no permite asegurar con certeza que una
referencia se ha inicializado.
No son posibles más comparaciones.

322

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Ejemplos
El siguiente ejemplo muestra el uso de referencias en asignaciones y operaciones de
comparación en SCL:

El siguiente ejemplo muestra el uso en KOP:

Programación del PLC
Manual de programación y manejo, 11/2019

323

Tipos de datos
3.11 Puntero

324

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Consulte también
Principios básicos de las referencias (Página 310)

3.11.1.6

Intento de asignación de VARIANT a una referencia
Intento de asignación
<Reference> ?= <VARIANT>
Intento de asignación de una
variable del tipo de datos VARIANT
a una variable de referencia

#myReference ?= #myVariant;

Descripción
El intento de asignación con "?=" puede utilizarse para asignar una variable del tipo de datos
VARIANT a una referencia.
Si la variable direccionada por VARIANT en tiempo de ejecución es del tipo de datos correcto
y está en un área de memoria optimizada, tras ejecutar la asignación habrá una referencia
válida en la variable de destino, en caso contrario habrá NULL.
Tras el intento de asignación es posible comprobar si el intento ha funcionado y, en función del
resultado, continuar con el procesamiento del programa. En KOP y FUP puede emplearse
para ello la salida de habilitación "ENO". "ENO" tiene el estado lógico"1" si el intento de
asignación ha funcionado. Solo entonces se ejecutan las instrucciones siguientes en el
segmento.
En AWL y SCL pueden emplearse las instrucciones "IS_NULL" o "NOT_NULL" para
comprobar el resultado del intento de asignación. Más abajo encontrará ejemplos al respecto.

Reglas
Para el intento de asignación se aplican las siguientes reglas:
● El VARIANT asignado no puede señalar a una variable temporal.
● El VARIANT asignado debe señalar a una variable dentro del área de memoria optimizada.
● Si desea asignar a una referencia una variable del tipo de datos VARIANT que señale a un
ARRAY, VARIANT deberá señalar a un ARRAY cuyos límites coincidan exactamente con
los de la referencia declarada. Un VARIANT que señala a un ARRAY [0..9] no concuerda
con una variable REF_TO ARRAY[1..10].
● En SCL no se pueden utilizar intentos de asignación en asignaciones múltiples (a := b := c;).

Programación del PLC
Manual de programación y manejo, 11/2019

325

Tipos de datos
3.11 Puntero

Ejemplo
El ejemplo siguiente muestra cómo puede leerse o escribirse directa y simbólicamente el valor
de una variable VARIANT utilizando referencias. Así no es necesario copiar el valor con las
instrucciones "VariantGet" y "VariantPut".

La variable VARIANT "variantTelegramData" puede transferir tanto datos del tipo "Telegram1"
como del tipo "Telegram2".
Con un intento de asignación se comprueba si los datos son del tipo "Telegram1". En caso
afirmativo, a los parámetros "Info1" y "Info2" se les pueden asignar los valores "T" y "W".
Ejemplo en SCL:

Ejemplo en KOP:

326

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Consulte también
Principios básicos de las referencias (Página 310)

3.11.1.7

Transferir referencias como parámetros de bloque

Descripción
Las referencias también pueden transferirse como parámetros de bloque al llamar funciones
o como bloques de función.
Si se llama a un bloque en cuya interfaz se ha declarado una referencia como parámetro
formal, es posible transferir como parámetro actual una referencia en forma de "REF()" o
"#MyRef".

Reglas
Para la transferencia de referencias como parámetros de bloque se aplican las siguientes
reglas:
● "REF()" sólo puede transferirse como parámetro actual para un parámetro de entrada
(Input) de una función.
● "REF()" no puede transferirse como parámetro actual a un parámetro de bloque del tipo de
datos "VARIANT".
● El tipo de datos de la variable transferida debe coincidir exactamente con el tipo de datos
de la referencia declarada. No se produce una conversión de tipos de datos.

Programación del PLC
Manual de programación y manejo, 11/2019

327

Tipos de datos
3.11 Puntero

Ejemplo 1
El siguiente ejemplo muestra la interfaz de la función "Callee". La interfaz contiene algunos
parámetros que se declararon como referencia:

La figura siguiente muestra la llamada de este bloque en SCL y el suministro de parámetros de
las referencias declaradas:

328

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Ejemplo 2
El ejemplo siguiente muestra otras posibilidades de transferencia de referencias en la llamada
del bloque:

En el ejemplo existen dos posibilidades de transferencia:
● Transferencia del FB a la FC llamada:
El parámetro de entrada "refStationData" está declarado en "FC StationData".
El "FB LineData" transfiere REF("ReceiveData1") como parámetro actual (fila 2 del
código de programa del "FB LineData") cuando se llama. "ReceiveData1" es un bloque de
datos que se basa en el tipo de datos PLC "typeStationData".
● Retorno de la FC al FB llamante:
En la interfaz de ambos bloques se declaran referencias con el mismo tipo de datos (en el
ejemplo: "refPoductionData").
Cuando se llama el bloque se asignan ambas referencias entre sí (fila 3 del código del
programa del "FB LineData").
La inicialización de la referencia se realiza en la "FC StationData" llamada (fila 2) y se
escribe mediante el parámetro de salida directamente en los datos temporales del FB
invocante.
El ejemplo muestra una sección del ejemplo de programación "Retornar datos por referencia
al bloque invocante". El código de programa detallado se encuentra en "Consulte también".

Consulte también
Principios básicos de las referencias (Página 310)
Desreferenciar (Página 320)
Ejemplo: Retornar datos por referencia al bloque invocante (Página 332)

Programación del PLC
Manual de programación y manejo, 11/2019

329

Tipos de datos
3.11 Puntero

3.11.1.8

Ejemplo: Transferencia de variables de diferentes tipos de datos mediante referencias

Tarea
En el siguiente ejemplo de aplicación, una instalación de producción solicita datos. Según el
tipo de datos solicitados se transfieren distintos datos a la instalación.
Las estructuras de datos se mapean en dos tipos de datos PLC diferentes. El tipo de datos PLC
"typeTelegram1" contiene información general del tipo datos "CHAR"; el tipo de datos PLC
"typeTelegram2" contiene el Part-ID del tipo de datos "STRING". De cada uno de los tipos de
datos PLC se genera un bloque de datos:

330

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Ejemplos de programa
La figura siguiente muestra cómo realizar la tarea con o sin referencias en SCL:

Puesto que ambos bloques deben procesar formatos de telegramas diferentes de forma
flexible, disponen de un parámetro de entrada/salida (InOut) del tipo de datos "VARIANT" al
que se transfieren los telegramas como variables estructuradas. Como el tipo de datos de un
parámetro VARIANT se desconoce mientras se va creando el programa, no es posible acceder
directamente al parámetro. Por tanto, en ambos ejemplos se determina primero la instrucción
"TypeOf" cuyo tipo de datos es el actual en el momento de la llamada.
En el bloque izquierdo, mediante la instrucción "VariantGet" se copia la variable pendiente en
tiempo de ejecución en una variable temporal del tipo de datos correspondiente, y en ella se
escriben los valores adecuados. A continuación, mediante la instrucción "VariantPut" vuelve a
copiarse la estructura en el parámetro "telegram". La copia repercute negativamente sobre el
tiempo de ejecución del programa y ocupa espacio de memoria.
En el bloque derecho se usan referencias para solucionar la tarea: La interfaz contiene un
parámetro de referencia para cada una de las estructuras de datos posibles. Dependiendo de
cuál sea la variable actualmente pendiente, la referencia adecuada se inicializa con el

Programación del PLC
Manual de programación y manejo, 11/2019

331

Tipos de datos
3.11 Puntero
"AssignmentAttempt" y apunta directamente a la ubicación de la variable en el bloque de datos.
A continuación se escriben los valores directamente en el bloque de datos.
Con esta solución, el código de programa será más claro y más fácil de mantener. Como no es
necesario copiar las variables estructuradas, no se ven afectados ni el tiempo de ejecución del
programa ni la memoria necesaria.

3.11.1.9

Ejemplo: Retornar datos por referencia al bloque invocante

Tarea
En el siguiente ejemplo de aplicación se configura una instalación de producción que está
compuesta de varias estaciones. Las estaciones son controladas por dos CPU que envían los
datos a una CPU maestra. Esta debe valorar para qué estación hay datos nuevos y ejecutar
tareas de control de nivel superior, p. ej. sumar los números de unidades producidas.
La siguiente figura muestra la estructura de la instalación de producción:

332

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Bloques del programa de ejemplo
El programa en la CPU maestra tiene la siguiente estructura:
● Tipo de datos PLC "typeStationData"
Los datos de una estación se reproducen en el tipo de datos PLC "typeStationData". El tipo
de datos PLC tiene dos tipos de datos PLC subordinados:
– "typeGeneralInfo"
El tipo de datos contiene el número de estación.
– "typeProductionData"
El tipo de datos contiene el número de unidades de la estación.
● DB "ReceiveData"
Para la comunicación entre las CPU hay por cada CPU un bloque de datos "ReceiveData"
del tipo "typeStationData" en el que se escriben los datos de comunicación.
● "FB LineData"
El FB ejecuta una valoración global de la línea de producción. Esto incluye, p. ej., la suma
de todos los contadores de unidades de cada estación. Además, llama la "FC StationData",
que se encarga, entre otros, de volver a copiar los datos de recepción del DB "ReceiveData"
en el DB global "Station".
● "FC StationData"
La FC comprueba de qué estación hay nuevos datos de recepción y los copia en el
elemento ARRAY correspondiente del DB global "Estación". Seguidamente, el elemento
ARRAY se devuelve como referencia al "FB LineData" invocante para su procesamiento
posterior.
● DB global "Station"
En este DB están los datos de las cinco estaciones. Están almacenados en un ARRAY del
tipo "typeStationData" de cinco componentes.

Programa de ejemplo
La figura siguiente muestra cómo realizar la tarea en SCL:

Programación del PLC
Manual de programación y manejo, 11/2019

333

Tipos de datos
3.11 Puntero

El "FB LineData" llama la "FC StationData" y transfiere la referencia al bloque de datos de
recepción en la llamada mediante REF("ReceiveData").
Mediante desreferenciación al bloque de datos de recepción transferido, la FC lee el número
de estación y lo escribe en la variable temporal "stationNo".
Seguidamente, los datos de producción del bloque de datos de recepción se copian en el
elemento ARRAY correspondiente del DB global "Station".
Este elemento ARRAY se devuelve al "FB LineData" invocante como referencia mediante la
salida "refProductionData".
Seguidamente, este puede acceder directamente al elemento ARRAY transferido mediante
desreferenciación y, de este modo, actualizar el contador de unidades para toda la línea de
producción.

Consulte también
Transferir referencias como parámetros de bloque (Página 327)

334

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

3.11.2

VARIANT

3.11.2.1

Principios básicos de VARIANT

Descripción
Un parámetro del tipo de datos VARIANT es un puntero o una referencia. Puede señalar a
variables de distintos tipos de datos. El puntero VARIANT no puede señalar a instancias ni, por
tanto, a multiinstancias o a un ARRAY of multiinstancias. El puntero VARIANT puede ser un
objeto de un tipo de datos simple, como p. ej., INT o REAL. También puede ser un STRING,
DTL, ARRAY of STRUCT, UDT o un ARRAY of UDT. El puntero VARIANT puede reconocer
estructuras y apuntar a componentes individuales de estas. Los operandos del tipo de datos
VARIANT no ocupan espacio en el bloque de datos de instancia o en la memoria de trabajo.
Pero dentro del área de memoria de la CPU sí que se ocupa lugar.
Una variable del tipo VARIANT no es un objeto, sino una referencia a otro objeto. Los distintos
elementos del tipo VARIANT solo pueden declararse en parámetros formales de la interfaz de
bloque de una función, en las secciones VAR_IN, VAR_IN_OUT y VAR_TEMP. Por este
motivo no es posible declararlos en un bloque de datos o una sección Static de la interfaz de
un bloque de función, por ejemplo, pues no se conoce su tamaño. El tamaño de los objetos
referenciados puede cambiar.
Con el tipo de datos VARIANT es posible crear, sobre todo, funciones (FC) o bloques de
función (FB) normalizados genéricos para distintos tipos de datos. Para ello existen varias
instrucciones en todos los lenguajes de programación. Al crear el programa se puede
especificar qué tipos de datos debe poder procesar el bloque. El tipo de datos VARIANTE sirve
de ayuda al permitir la conexión de cualesquiera variables, a cuyo tipo de datos luego se puede
reaccionar en el bloque. En la llamada de bloque se pueden interconectar los parámetros del
bloque con variables de un tipo de datos cualquiera. Al llamar el bloque, además del puntero
hacia la variable también se transfiere información del tipo de la variable. De este modo es
posible procesar el código del bloque conforme al tipo y la variable transferida durante la
ejecución.
Si, p. ej., un parámetro de bloque de una función tiene el tipo de datos VARIANT, se le puede
transferir en un punto del programa una variable del tipo de datos Entero, y en otro punto una
variable del tipo de datos PLC. En este caso, las instrucciones VARIANT permiten que la
función reaccione sin errores.
Nota
Un bloque de datos completo solo se puede señalar si ha sido derivado originalmente de un
tipo de datos definido por el usuario (UDT).
Nota
Direccionar la periferia
La lectura o escritura directa de una señal de entrada o salida de periferia solo es posible en
una CPU del módulo S7-1500. (<Operando>:P)

Programación del PLC
Manual de programación y manejo, 11/2019

335

Tipos de datos
3.11 Puntero
La tabla siguiente muestra las propiedades del puntero VARIANT:
Longitud
(bytes)

Repre‐
Formato
sentación

Ejemplo de entrada de valores

0

Simbólico Operando

"TagResult"

Absoluto

1)

NombreBloqueDatos.NombreOpe‐
rando.Componente

"Datos_TIA_Portal".VariableStruct.Pri‐
merComponente

Operando

%MW10

NúmeroBloqueDatos.Operando Tipo
Longitud

P#DB10.DBX10.0 INT 12 1)

Puntero NULL

NULL

Si se utiliza el prefijo P#, solo es posible señalar a las áreas de memoria con tipo de acceso "estándar".

Codificación de los tipos de datos
Si se utiliza el direccionamiento absoluto con P# se admiten los tipos de datos siguientes:
● BOOL
● BYTE
● CHAR
● WORD
● INT
● DWORD
● DINT
● REAL
● TIME
● S5TIME
● DATE
● TOD
● DT

Ejemplo
El siguiente ejemplo muestra el funcionamiento de VARIANT tomando como base la
instrucción AWL "MOVE: Copiar valor":

336

AWL

Explicación

CALL MOVE

// Se llama la instrucción.

value_type := VARIANT

// Tipo de datos de los parámetros IN y
OUT

IN := "Datos_TIA_Portal".VariableStruct.PrimerComponente

// Se copia el contenido del operando
"PrimerComponente" del DB "Datos_TIA_Portal".

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero
AWL

Explicación

OUT := "MotorDB".StructResult.TagResult

// Y se transfiere al operando "TagResult" del DB "MotorDB".

Consulte también
Fundamentos del direccionamiento indirecto (Página 121)
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Fundamentos del acceso a bloques (Página 54)
Principios básicos de las llamadas de bloque (Página 59)
Instrucciones VARIANT (Página 339)
Direccionar la periferia (Página 110)
Conversión de los tipos de datos en el S7-1200 (Página 506)

3.11.2.2

Comparación de casos de aplicación para punteros

Casos de aplicación para punteros en una CPU de las series S7-1200/1500 en comparación con
S7-300/400
La tabla siguiente ofrece una visión general de los diferentes casos de aplicación para
punteros en una CPU de las series S7-300/400 (puntero ANY), y su solución con una CPU de
las series S7-1200/1500.
En la mayoría de los casos de aplicación, con una CPU de las series S7-1200/1500 ya no es
necesario utilizar un puntero. En su lugar, el lenguaje de programación dispone de
instrumentos mucho más sencillos.
Tan solo tiene sentido utilizar el tipo de datos VARIANT en caso de direccionamiento indirecto,
cuando los tipos de datos no se determinan hasta la ejecución del programa.
¿Para qué se utilizaba el puntero ANY?

Recomendaciones en el TIA Portal (S7-1200/
S7-1500)

Copia de cualquier tipo de datos de origen y de
destino en el programa mediante la instrucción
"BLKMOV: Copiar área".

Definición de variables dentro de un tipo de datos
PLC. Mediante la instrucción "Serialize" y "Dese‐
rialize" es posible copiar las variables.

Inicialización de una estructura ARRAY.

Mediante la instrucción "FILL_BLK: Rellenar área"
se inicializa o se rellena una estructura ARRAY.

Copia de elementos de ARRAY

Mediante la instrucción "MOVE_BLK: Copiar área"
se copia el contenido de varios elementos de una
estructura ARRAY en otra estructura ARRAY.

Programación del PLC
Manual de programación y manejo, 11/2019

337

Tipos de datos
3.11 Puntero
¿Para qué se utilizaba el puntero ANY?

Recomendaciones en el TIA Portal (S7-1200/
S7-1500)

Optimización de la memoria y el rendimiento me‐
diante datos estructurados

Utilice la sección InOut de la interfaz de bloque
para optimizar la memoria y el rendimiento.
Encontrará más información en la "Guía de pro‐
gramación para S7-1200/1500", en el siguiente
enlace Guía de programación para S7-1200/1500
(http://support.automation.siemens.com/WW/
llisapi.dll?aktprim=4&lang=es&referer=%2fWW
%2f&func=cslib.csinfo&siteid=csius&groupid=400
0002&extranet=standard&viewreg=WW&nodeid4
=20229695&objaction=csopen)

Acceso a bits/bytes concretos de una WORD

Utilice el "acceso Slice".
Encontrará más información aquí: Ejemplo de ac‐
ceso Slice (http://
support.automation.siemens.com/WW/llisapi.dll?
aktprim=0&lang=es&referer=%2fWW
%2f&func=cslib.csinfo&siteid=csius&groupid=400
0002&extranet=standard&viewreg=WW&nodeid0
=29156492&objaction=csopen)

Determinación de la longitud de estructuras o blo‐ Utilice un ARRAY y lea su longitud mediante la
ques de datos
instrucción "CountofElements: Consultar número
de elementos de ARRAY". Esta instrucción única‐
mente funciona con el tipo de datos VARIANT.
Direccionamiento indirecto

338

Para el direccionamiento indirecto de tipos de da‐
tos que no se conocen hasta el momento de la
ejecución se puede utilizar el puntero VARIANT.
Para el acceso indirecto a un bloque de datos se
puede utilizar el tipo de datos DB_ANY.

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

3.11.2.3

Instrucciones VARIANT

Instrucciones VARIANT
En el TIA Portal están disponibles las siguientes instrucciones para trabajar con VARIANT:
Instrucciones básicas
Categoría

Instrucción

Comparación

EQ_Type

Comparar si el tipo de datos es IGUAL al tipo de datos de una variable

NE_Type

Comparar si el tipo de datos es DIFERENTE al tipo de datos de una
variable

EQ_ElemType

Comparar si el tipo de datos de un elemento de ARRAY es IGUAL al tipo
de datos de una variable

NE_ElemType

Comprar si el tipo de datos de un elemento de ARRAY es DIFERENTE
del tipo de datos de una variable

IS_NULL

Consultar si es un puntero IGUAL A CERO

NOT_NULL

Consultar si es un puntero DIFERENTE DE CERO

IS_ARRAY

Consultar si es un ARRAY

TypeOf

Consultar tipo de datos de una variable VARIANT

TypeOfElements

Consultar tipo de datos de un elemento de una variable VARIANT

MOVE_BLK_VA‐
RIANT

Copiar área

VariantGet

Leer valor de una variable VARIANT

VariantPut

Escribir valor en una variable VARIANT

CountOfElements

Consultar número de elementos de ARRAY

Transferencia

Conversión

Descripción

VA‐
Convertir VARIANT en DB_ANY
RIANT_TO_DB_A
NY
DB_ANY_TO_VA‐ Convertir DB_ANY en VARIANT
RIANT

Nota
Diferencias entre MOVE, MOVE_BLK y MOVE_BLK_VARIANT
● Para copiar estructuras completas se puede utilizar la instrucción MOVE.
● Para copiar partes de ARRAYs con un tipo de datos conocido se puede utilizar la
instrucción MOVE_BLK.
● La instrucción MOVE_BLK_VARIANT solo es necesaria cuando se quieren copiar partes
de ARRAYs cuyo tipo de datos no se conoce hasta el momento de la ejecución.
Encontrará más información sobre las distintas instrucciones en el sistema de información en
"Instrucciones básicas > Lenguaje de programación correspondiente".
En "Instrucciones avanzadas" encontrará otras instrucciones que también operan con el tipo
de datos VARIANT.

Programación del PLC
Manual de programación y manejo, 11/2019

339

Tipos de datos
3.11 Puntero

Consulte también
Principios básicos de VARIANT (Página 335)
Direccionamiento indirecto con el tipo de datos VARIANT (http://
support.automation.siemens.com/WW/llisapi.dll?aktprim=0&lang=es&referer=%2fWW
%2f&func=cslib.csinfo&siteid=csius&groupid=4000002&extranet=standard&viewreg=WW&n
odeid0=29156492&objaction=csopen)

3.11.2.4

Posibilidades de uso de instrucciones VARIANT

Introducción
En el siguiente capítulo descubrirá las aplicaciones posibles de las instrucciones VARIANT.

Evaluación de los tipos de datos de las variables a las que apunta un VARIANT
La tabla siguiente muestra las instrucciones que están disponibles para evaluar los tipos de
datos de variables a las que apunta un VARIANT:
Función

Instrucción

Descripción

Determinar el tipo
de datos

TypeOf(): Consultar tipo de datos de una va‐
riable VARIANT

Esta instrucción compara el tipo de datos al que apunta
una variable VARIANT con el tipo de datos de otra
variable cualquiera. También es posible realizar la
comparación con un tipo de datos PLC.

(Esta instrucción tan solo está disponible en
SCL y en combinación con una instrucción IF o
CASE.)
TypeOfElements(): Consultar tipo de datos de
un elemento de ARRAY de una variable VA‐
RIANT
(Esta instrucción tan solo está disponible en
SCL y en combinación con una instrucción IF o
CASE.)
EQ_Type: Comparar si el tipo de datos es
IGUAL al tipo de datos de una variable
NE_Type: Comparar si el tipo de datos es DI‐
FERENTE del tipo de datos de una variable

Esta instrucción compara el tipo de datos al que apunta
una variable VARIANT con el tipo de datos de otra
variable cualquiera. También es posible realizar la
comparación con un tipo de datos PLC. Si el tipo de
datos de la variable VARIANT es un ARRAY, se com‐
para el tipo de datos de los elementos de ARRAY.
Esta instrucción compara el tipo de datos al que apunta
una variable VARIANT con el tipo de datos de otra
variable cualquiera. También es posible realizar la
comparación con un tipo de datos PLC.

Esta instrucción compara el tipo de datos al que apunta
una variable VARIANT con el tipo de datos de otra
variable cualquiera. También es posible realizar la
NE_ElemType: Comparar si el tipo de datos de comparación con un tipo de datos PLC. Si el tipo de
datos de la variable VARIANT es un ARRAY, se com‐
un elemento de ARRAY es DIFERENTE del
para el tipo de datos de los elementos de ARRAY.
tipo de datos de una variable
EQ_ElemType: Comparar si el tipo de datos
de un elemento de ARRAY es IGUAL al tipo de
datos de una variable

Evaluación de ele‐ IS_ARRAY: Consultar si es un ARRAY
mentos de ARRAY
CountOfElements: Consultar número de ele‐
mentos de ARRAY

Esta instrucción comprueba si el tipo de datos al que
apunta una variable VARIANT es un ARRAY.
Esta instrucción lee cuántos elementos de ARRAY tie‐
ne la variable a la que apunta la variable VARIANT.

Encontrará más información sobre las distintas instrucciones en el sistema de información en
"Instrucciones básicas > Lenguaje de programación correspondiente".

340

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Lectura de datos a los que apunta un VARIANT
Para poder utilizar los datos es necesario copiarlos en una variable como paso intermedio, ya
que no es posible procesarlos directamente.
Instrucción

Descripción

Ejemplo
VARIANT
apunta a

VariantGet: Leer valor de una va‐ Esta instrucción copia el valor de UDT_1
riable VARIANT
una única variable en otra varia‐ REAL
ble. Los tipos de datos de las dos
DINT
variables deben coincidir.

Resultado
Tipo de datos
de destino
UDT_1
REAL
DWORD

Se ejecuta la ins‐
trucción.
No se ejecuta la
instrucción.

Asignación de datos a una variable VARIANT
Esta instrucción no puede utilizarse para inicializar variables VARIANT. Por lo tanto, las
variables VARIANT ya deben estar inicializadas cuando devuelven datos a la variable. No se
debe utilizar una variable VARIANT temporal no inicializada.
Instrucción

Descripción

Ejemplo
Tipo de datos
de origen

VariantPut: Escribir valor en una
variable VARIANT

Esta instrucción copia el valor de UDT_1
una única variable en otra varia‐ REAL
ble. Los tipos de datos de las dos
DINT
variables deben coincidir.

Resultado
VARIANT
apunta a:
UDT_1
REAL
DWORD

Se ejecuta la ins‐
trucción.
No se ejecuta la
instrucción porque
los tipos de datos
son diferentes.

Procesamiento de estructuras ARRAY dinámicas
Evaluación de ele‐ TypeOfElements(): Consultar tipo de datos de
mentos de ARRAY un elemento de ARRAY de una variable VA‐
RIANT
(Esta instrucción tan solo está disponible en
SCL y en combinación con una instrucción IF
o CASE.)

Esta instrucción compara el tipo de datos al que apunta
una variable VARIANT con el tipo de datos de otra va‐
riable cualquiera. También es posible realizar la com‐
paración con un tipo de datos PLC. Si el tipo de datos
de la variable VARIANT es un ARRAY, se compara el
tipo de datos de los elementos de ARRAY.

IS_ARRAY: Consultar si es un ARRAY

Esta instrucción comprueba si el tipo de datos al que
apunta una variable VARIANT es un ARRAY.

CountOfElements: Consultar número de ele‐
mentos de ARRAY

Esta instrucción lee cuántos elementos de ARRAY tie‐
ne la variable a la que apunta la variable VARIANT.

MOVE_BLK_VARIANT: Copiar área

Esta instrucción copia ARRAYs dinámicos y con segu‐
ridad de tipos (comprobación de tipo integrada). Los
valores límite del ARRAY de origen y de destino pue‐
den elegirse libremente. Los tipos de datos de los ele‐
mentos de ARRAY deben coincidir.

Programación del PLC
Manual de programación y manejo, 11/2019

341

Tipos de datos
3.11 Puntero

Nota
Diferencias entre MOVE, MOVE_BLK y MOVE_BLK_VARIANT
● Para copiar estructuras completas se puede utilizar la instrucción MOVE.
● Para copiar partes de ARRAYs con un tipo de datos conocido se puede utilizar la
instrucción MOVE_BLK.
● La instrucción MOVE_BLK_VARIANT solo es necesaria cuando se quieren copiar partes
de ARRAYs cuyo tipo de datos no se conoce hasta el momento de la ejecución.
Encontrará más información sobre el uso de la instrucción MOVE_BLK_VARIANT en el
ejemplo de programación "Transferencia de datos".

Consulte también
Principios básicos de VARIANT (Página 335)
Ejemplo de movimiento de datos (Página 344)

3.11.2.5

Inicializar VARIANT

Descripción
Inicialice el tipo de datos VARIANT asignando una variable concreta al parámetro de bloque
VARIANT al llamar al bloque. De este modo se crea una referencia a la dirección de la variable
transferida. Para ello, cree un parámetro de bloque del tipo de datos VARIANT en la interfaz
de bloque. En el siguiente ejemplo son los dos parámetros de bloque SourceArray y
DestinationArray de la sección InOut.

342

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero
El ejemplo muestra una sección del ejemplo de programación "Ejemplo de movimiento de
datos". El código de programa detallado se encuentra en "Consulte también".
Nota
No es posible la transferencia directa de una variable a una variable VARIANT p. ej.,
myVARIANT := #Variable.

Consulte también
Ejemplo de movimiento de datos (Página 344)

3.11.2.6

Transferencia y lectura de diferentes tipos de datos con VARIANT
Los ejemplos muestran una sección del ejemplo de programación "Ejemplo de movimiento de
datos". El código de programa detallado se encuentra en "Consulte también".
Nota
VARIANT como parámetro formal
Si el VARIANT está declarado como parámetro formal, no pueden transferirse datos
protegidos contra escritura como parámetros actuales.

Transferencia de distintos tipos de datos
El siguiente ejemplo ilustra cómo, al llamar varias veces una función normalizada genérica, el
parámetro de bloque VARIANT puede inicializarse con diferentes variables:
La función "FC_PartialArrayCopy" se llama dos veces. En la llamada de la izquierda, el
parámetro VARIANT SourceArray se interconecta con un ARRAY de "my_struct". En la
llamada de la derecha, el parámetro VARIANT SourceArray se interconecta con un ARRAY of
REAL.

Lectura y comprobación de tipos de datos
Para leer el tipo de datos de una variable o elemento y compararlo con los tipos de datos de
otras variables o elementos, se dispone de distintas instrucciones de comparación.

Programación del PLC
Manual de programación y manejo, 11/2019

343

Tipos de datos
3.11 Puntero
La figura siguiente muestra el uso de varias instrucciones de comparación para comprobar si
los elementos de los ARRAYs tienen el mismo tipo de datos:

La instrucción MOVE_BLK_VARIANT solo se ejecuta si los tipos de datos de los elementos de
ARRAY son iguales.

Consulte también
Ejemplo de movimiento de datos (Página 344)

3.11.2.7

Ejemplos de uso del tipo de datos VARIANT

Ejemplo de movimiento de datos
Ejemplo de programación
En el siguiente ejemplo de programación se transfieren para su posterior procesamiento
valores de datos que, p. ej., se han recopilado durante un turno de producción. Los datos se
recogen en un ARRAY, y mediante la instrucción "MOVE_BLK_VARIANT: Copiar área" es
posible copiar de forma dinámica y con seguridad de tipos el ARRAY completo o solo
determinados elementos. Los límites de los ARRAY de origen y destino, respectivamente,
pueden elegirse libremente y no es necesario que coincidan. Sin embargo, los valores de datos
que van a copiarse sí deben tener el mismo tipo de datos. Esta instrucción está disponible en
todos los lenguajes de programación.
Con el tipo de datos VARIANT también es posible utilizar el código de programa creado para
transferir datos a otros turnos de producción, indicando otras áreas de origen y destino en la
llamada de bloque.

344

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Procedimiento
1. Cree una función con el lenguaje de programación SCL y póngale el nombre
"FC_PartialArrayCopy".
2. Declare la interfaz del bloque de la manera siguiente:

3. Cree el código de programa SCL de la manera siguiente:
A continuación figura el código de programa como plantilla maestra.

4. Cree el tipo de datos PLC "UDT_MyStruct":

Programación del PLC
Manual de programación y manejo, 11/2019

345

Tipos de datos
3.11 Puntero
5. Cree el bloque de datos global "DB_WithArrays":

346

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero
6. Llame a la función "FC_PartialArrayCopy" en un bloque de organización p. ej., OB1, e
inicialice los parámetros con el bloque de datos "DB_WithArrays". Introduzca las
constantes mencionadas:

7. En lugar de los dos primeros ARRAYs, que tienen el tipo de datos UDT_MyStruct, también
puede utilizar el tercero y el cuarto ARRAY, que tienen el tipo de datos REAL:

Resultado
Nada más llamar al bloque "FC_PartialArrayCopy" en el ciclo del programa, dos valores de
datos del primer ARRAY del bloque de datos global "DB_WithArrays" se copian al segundo
ARRAY del bloque de datos, empezando por el cuarto elemento. Los valores de datos
copiados se insertan en el segundo ARRAY a partir del cuarto elemento.

Programación del PLC
Manual de programación y manejo, 11/2019

347

Tipos de datos
3.11 Puntero
Código de programa SCL para copiar:
SCL
IF IS_ARRAY(#SourceArray) AND TypeOfElements(#SourceArray) =
TypeOfElements(#DestinationArray) THEN
#Error := MOVE_BLK_VARIANT(COUNT := #Count, SRC := #SourceArray, SRC_INDEX := #SourceIndex,
DEST => #DestinationArray, DEST_INDEX := #DestinationIndex);
END_IF;
#FC_PartialArrayCopy := #Error;

Consulte también
Principios básicos de VARIANT (Página 335)

Ejemplo de programación de una cola de espera (FIFO)
Ejemplo de programación
En el siguiente ejemplo se programa un búfer en anillo que se compone de un ARRAY y se
escribe y se lee según el principio FIFO. El código de programa contiene un puntero VARIANT
de lectura y otro de escritura. Mediante las instrucciones VARIANT es posible programar el
código de programa de manera robusta y garantizar una copia o borrado seguro.
Con el tipo de datos VARIANT es posible influir en partes del programa durante la ejecución.
El puntero VARIANT es un puntero con seguridad de tipos, es decir, se realiza una
comprobación de tipo durante la ejecución. En el caso de bloques que se han creado con la
propiedad de bloque "Optimizado", las funciones parciales que antes se programaban con un
puntero ANY ahora pueden resolverse con un puntero VARIANT. El tipo de datos VARIANT se
utiliza para transferir estructuras a bloques de función del sistema.

348

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

Procedimiento
1. Cree un bloque de función SCL y llámelo "FIFOQueue".
2. Declare la interfaz del bloque de la manera siguiente:
Declaración

Parámetro

Tipo de datos

Comentario

Input

request

BOOL

La instrucción se ejecuta
cuando en el parámetro
"request" se registra un
flanco de señal ascenden‐
te.

mode

BOOL

0 = se devuelve la primera
entrada del búfer en anillo.
1 = se escribe una entrada
en la última posición del
búfer en anillo.

initialValue

VARIANT

Valor con el que se inicia‐
liza el ARRAY del búfer en
anillo.

Output

error

INT

Información de error

InOut

item

VARIANT

La entrada que se devuel‐
ve del búfer en anillo o que
se escribe en él.

buffer

VARIANT

Un ARRAY que se utiliza
como búfer en anillo.

edgeupm

BOOL

Marca de flancos en la que
se almacena el RLO de la
consulta anterior.

firstItemIndex

INT

Índice de la entrada más
antigua del búfer en anillo

nextEmptyItemIn‐
dex

INT

Índice del siguiente ele‐
mento libre en el búfer en
anillo

edgeup

BOOL

Resultado de la evalua‐
ción de flancos

internalError

INT

Información de error

newFirstItemIndex

INT

Índice variable

newNextEmptyIte‐
mIndex

INT

Índice variable

bufferSize

UDINT

Número de elementos
ARRAY en el búfer en ani‐
llo

Static

Temp

3. En el bloque de función "FIFOQueue", cree el siguiente código de programa:

(* Esta sección del código del programa solo se ejecuta una vez tras un
flanco de señal ascendente. Si el estado del resultado lógico no cambia, la
ejecución del programa del FB "FIFOQueue" finaliza. *)
#edgeup := #request & NOT #edgeupm;

Programación del PLC
Manual de programación y manejo, 11/2019

349

Tipos de datos
3.11 Puntero

#edgeupm := #request;
IF NOT (#edgeup) THEN
RETURN;
END_IF;

// ------Validación de si todas las entradas de parámetro son válidas.---(* Esta sección del código del programa comprueba si el búfer en anillo es
un ARRAY. En caso afirmativo, se lee el número de elementos del ARRAY. Si no
se trata de un ARRAY, la ejecución del programa se interrumpe en este punto
y se devuelve el código de error "-10". *)
IF NOT (IS_ARRAY(#buffer)) THEN
#error := -10;
RETURN;
ELSE
#bufferSize := CountofElements(#buffer);
END_IF;
(* Esta sección del código del programa comprueba si el tipo de datos de los
elementos ARRAY coincide con el tipo de datos de la entrada (variable
#item). Si los tipos de datos no coinciden, la ejecución del programa se
interrumpe en este punto y se devuelve el código de error "-11". *)
IF NOT (TypeOf(#item) = TypeOfElements(#buffer)) THEN
#error := -11;
RETURN;
END_IF;
(* Esta sección del código del programa comprueba si el valor inicial del
búfer en anillo coincide con la entrada (variable #item). Si los tipos de
datos no coinciden, la ejecución del programa se interrumpe en este punto y
se devuelve el código de error "-12". *)
IF NOT (TypeOf(#item) = TypeOf(#initialValue)) THEN
#error := -12;
RETURN;
END_IF;
(* Esta sección del código del programa comprueba si los índices variables
se encuentran dentro de los límites ARRAY. Si no es así, la ejecución del
programa se interrumpe en este punto y por cada índice se devuelven los
códigos de error "-20" o "-21". *)
IF (#nextEmptyItemIndex >= #bufferSize) THEN
#error := -20;
RETURN;
END_IF;
IF (#firstItemIndex >= #bufferSize) THEN
#error := -21;
RETURN;

350

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

END_IF;

//-----------Ejecución del código del programa en función del parámetro
Mode------------// La ejecución de las instrucciones depende del estado lógico del
parámetro Mode.
IF #mode = 0 THEN
// Si el parámetro Mode presenta el estado lógico "0", se devuelve la
primera entrada del búfer en anillo transferido.
(* Esta sección del código del programa comprueba si el búfer en anillo está
vacío. En caso afirmativo, la ejecución del programa se interrumpe en este
punto y se devuelve el código de error "-40". *)
IF (#firstItemIndex = -1) THEN
#error := -40;
RETURN;
END_IF;
// Esta sección del código del programa devuelve la primera entrada del
búfer en anillo.
#internalError := MOVE_BLK_VARIANT(SRC := #buffer,
COUNT := 1,
SRC_INDEX := #firstItemIndex,
DEST_INDEX := 0,
DEST => #item);
IF (#internalError = 0) THEN
(* Esta sección del código del programa comprueba si el búfer en anillo
contiene elementos de ARRAY. En caso afirmativo, se desplaza la primera
entrada y el índice se incrementa en 1. *)
#internalError := MOVE_BLK_VARIANT(SRC := #initialValue,
COUNT := 1,
SRC_INDEX := 0,
DEST_INDEX := #firstItemIndex,
DEST => #buffer);
// Esta sección del código del programa calcula el nuevo índice de la
primera entrada.
#newFirstItemIndex := #firstItemIndex +1;
#newFirstItemIndex := #newFirstItemIndex MOD
UDINT_TO_INT(#bufferSize);
// Esta sección del código del programa comprueba si el búfer en anillo está
vacío.
IF (#nextEmptyItemIndex = #newFirstItemIndex) THEN
// Si el búfer en anillo está vacío, el índice se pone a 0.

Programación del PLC
Manual de programación y manejo, 11/2019

351

Tipos de datos
3.11 Puntero

#firstItemIndex := -1;
#nextEmptyItemIndex := 0;
ELSE
// El índice de la primera entrada se modifica.
#firstItemIndex := #newFirstItemIndex;
END_IF;
END_IF;
ELSE

// Si el parámetro Mode presenta el estado lógico "1", la entrada se escribe
en el búfer en anillo transferido.
(* Esta sección del código del programa comprueba si el búfer en anillo está
lleno. En caso afirmativo, la ejecución del programa se interrumpe en este
punto y se devuelve el código de error "-50". *)
IF (#nextEmptyItemIndex = #firstItemIndex) THEN
#error := -50;
RETURN;
END_IF;
// Esta sección del código del programa escribe la entrada en el búfer en
anillo.
#internalError := MOVE_BLK_VARIANT(SRC := #item,
COUNT := 1,
SRC_INDEX := 0,
DEST_INDEX := #nextEmptyItemIndex,
DEST => #buffer);
IF (#internalError = 0) THEN
// Esta sección del código del programa incrementa el índice en 1 y calcula
el nuevo índice de entrada vacío.
#newNextEmptyItemIndex := #nextEmptyItemIndex +1;
#newNextEmptyItemIndex := #newNextEmptyItemIndex MOD #bufferSize;
#nextEmptyItemIndex := #newNextEmptyItemIndex;
(* Esta sección del código del programa comprueba qué índice tiene la
variable "#firstItemIndex". Si el número = -1, el búfer en anillo se ha
inicializado y la entrada se escribe en el búfer en anillo. Por ello hay que
asignar "0" a la variable. *)
IF (#firstItemIndex = -1) THEN
#firstItemIndex := 0;
END_IF;
END_IF;
END_IF;

352

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero

//-------------------------Tratamiento local de
errores---------------------------(* Esta sección del código del programa comprueba si se ha producido un
error local. En caso afirmativo, el programa se interrumpe en este punto y
se devuelve el código de error "-100". *)
IF (#internalError > 0) THEN
#error := -100;
RETURN;
END_IF;
// Si no se ha producido ningún error durante la ejecución del programa, se
devuelve el código de error "0".
#error := 0;

Resultado
Llame al bloque de función SCL en el lugar del programa donde deba ejecutarse la cola de
espera FIFO.

3.11.3

POINTER

Descripción
Un parámetro del tipo POINTER es un puntero que puede señalar a una variable específica.
Ocupa 6 bytes (48 bits) en la memoria y puede contener la siguiente información acerca de una
variable:
● Número del bloque de datos, o bien 0 en caso de que los datos no estén almacenados en
un bloque de datos
● Área de memoria en la CPU
● Dirección de la variable
La figura siguiente muestra la estructura del tipo de parámetro POINTER:
)RUPDWRGHSXQWHUR
%LW

%LW


 

%\WH


%\WH

1¼PHURGH'% R

%\WH

UHDGHPHPRULD

%\WH

E

E

E

E

E

E

E

E











E

E

E

%\WH

E

E

E

E

E

[

[

[

%\WH

E GLUHFFLµQGHE\WHGHOD
YDULDEOH

Programación del PLC
Manual de programación y manejo, 11/2019

[ GLUHFFLµQGHELW
GHODYDULDEOH

353

Tipos de datos
3.11 Puntero

Tipos de punteros
El tipo de parámetro POINTER permite declarar los cuatro tipos siguientes de punteros, en
función de la información que deban contener:
● Puntero intraárea:
Un puntero intraárea contiene información sobre la dirección de una variable.
● Puntero interárea:
Un puntero interárea contiene información sobre el área de memoria y la dirección de un
operando.
● Puntero DB:
Un puntero DB permite apuntar a una variable de un bloque de datos. Un puntero DB
contiene, además del área de memoria y la dirección de una variable, el número de un
bloque de datos.
● Puntero cero:
Con un puntero cero se muestra la falta de un valor. La falta de un valor puede significar por
un lado que no existe ningún valor o que el valor todavía no se conoce. El valor cero
equivale a la ausencia de valor, pero al mismo tiempo es un valor.
La tabla siguiente muestra los formatos para la declaración de los diferentes tipos de punteros:
Representación de
P#Byte

Formato

Ejemplo de entrada
de valores

Descripción

Simbólico

P#Byte.Bit

"MyTag"

Puntero intraárea

P#ByteAreaOperando.Bit

"MyVariable"

Puntero interárea

P#BloqueDatos.Operan‐
doDatos

"MyDB"."MyTag"

Puntero DB

P#Valor cero

-

Puntero cero

P#Byte.Bit

P#20.0

Puntero intraárea

P#ByteAreaOperando.Bit

P#M20.0

Puntero interárea

P#BloqueDatos.Operan‐
doDatos

P#DB10.DBX20.0

Puntero DB

P#Valor cero

P#0.0, NULL

Puntero cero

Absoluto

Nota
SCL: Acceso a bloques de datos mediante punteros DB absolutos
Cuando se direcciona un bloque de datos de la carpeta "Bloques de sistema" en SCL mediante
un puntero DB absoluto (p. ej. P#DB1.dbx0.0) y es el único acceso al DB, en unos pocos casos
se borra el bloque de datos en la próxima compilación. El compilador no detecta el puntero DB
como acceso y supone que el DB no se utiliza en el programa. En lugar del puntero es mejor
utilizar un acceso de lectura al DB (p. ej. "MyDB.MyFirstMember"). Este tipo de acceso se
ejecuta correctamente en todas las situaciones.

El prefijo P#
Al asignar un parámetro formal del tipo de datos POINTER en la llamada de bloque, introduzca
el valor actual sin el prefijo P#. En tal caso, el texto introducido se convierte automáticamente
al formato POINTER.

354

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero
Si se utiliza el prefijo P#, solo es posible señalar a las áreas de memoria con tipo de acceso
"Estándar". Encontrará más información y una comparación directa de ambas posibilidades de
acceso aquí:
● Fundamentos del acceso a bloques (Página 54)
● Resumen de las nuevas funciones de la CPU S7-1200/1500 y recomendaciones de
programación (Página 207)
Para utilizar el prefijo P# en el lenguaje de programación AWL hay que tener en cuenta lo
siguiente:
Tipo de bloque

Tipo de acceso "optimizado"

Tipo de acceso "estándar"

Función (FC)

En el código del programa no se
puede utilizar una variable con el
prefijo P#.

En el código del programa se pueden utilizar
las siguientes variables con el prefijo P#:
● Variables estructuradas que se hayan
declarado en la sección InOut de la
interfaz de bloque
Con el prefijo P# no se pueden utilizar varia‐
bles con tipos de datos simples.

Bloque de función
(FB)

En el código del programa no se
puede utilizar una variable con el
prefijo P#.

En el código del programa se pueden utilizar
las siguientes variables con el prefijo P#:
● Variables que se hayan declarado en las
secciones Static, Input y Output de la
interfaz de bloque
● Variables con el tipo de datos PLC (UDT)
que se hayan declarado en la sección
InOut de la interfaz de bloque

Encontrará más información sobre los tipos de datos estructurados y simples aquí:
Transferencia de parámetros como copia o puntero (Página 86)

Áreas de memoria
La tabla siguiente muestra los códigos hexadecimales de las áreas de memoria del tipo de
parámetro POINTER:
Código hexadecimal

Área de memoria

Descripción

B#16#801)

P

Periferia en una CPU
S7-300/400

16#1

P

Entradas de periferia en una
CPU S7-1500

16#2

P

Salidas de periferia en una CPU
S7-1500

B#16#81

I

Área de memoria de las entradas

B#16#82

Q

Área de memoria de las salidas

B#16#83

M

Área de memoria de las marcas

B#16#84

DBX

Bloque de datos

B#16#85

DIX

Bloque de datos de instancia

B#16#86

L

Datos locales

Programación del PLC
Manual de programación y manejo, 11/2019

355

Tipos de datos
3.11 Puntero
Código hexadecimal

Área de memoria

Descripción

B#16#87

V

Datos locales anteriores

1)

Estos tipos de datos solo pueden utilizarse para el puntero POINTER en una CPU S7-300/400.

Consulte también
Fundamentos del direccionamiento indirecto (Página 121)
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)

3.11.4

ANY

Descripción
Un parámetro del tipo ANY es un puntero que señala el inicio de un área de datos y especifica
su longitud. Un puntero ANY ocupa 10 bytes en la memoria y puede contener la siguiente
información:
● Tipo de datos:
Tipo de datos de los elementos del área de datos.
● Factor de repetición:
Número de elementos del área de datos
● Número de DB:
Bloque de datos en el que están declarados los elementos del área de datos.
● Área de memoria:
Área de memoria de la CPU en la que están depositados los elementos del área de datos.
● Dirección inicial de los datos en formato "Byte.Bit":
Inicio del área de datos al que apunta el puntero ANY.
● Puntero cero:
Con un puntero cero se muestra la falta de un valor. La falta de un valor puede significar por
un lado que no existe ningún valor o que el valor todavía no se conoce. El valor cero
equivale a la ausencia de valor, pero al mismo tiempo es un valor.
Nota
Puntero ANY a un STRING
Cuando se forma un puntero ANY de un segmento KOP/FUP/AWL o SCL mediante asignación
de un string, se crea un puntero ANY del tipo de datos BYTE y el factor de repetición maxstring.
Cuando se forma un puntero ANY de un segmento KOP/FUP/AWL o SCL mediante asignación
de un string, se crea un puntero ANY a un STRING.
Un puntero de este tipo puede crearse, por ejemplo, por transferencia desde un bloque SCL a
un segmento KOP, o por solapamiento con una construcción AT y ajuste manual del tipo de
datos a STRING.

356

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.11 Puntero
Nota
Posibilidades de acceso
El puntero ANY solo debe apuntar a las áreas de memoria con tipo de acceso "Estándar",
incluso en una CPU de la serie S7-1500. Encontrará más información y una comparación
directa de ambas posibilidades de acceso aquí:
● Fundamentos del acceso a bloques (Página 54)
● Resumen de las nuevas funciones de la CPU S7-1200/1500 y recomendaciones de
programación (Página 207)
En los lenguajes SCL y AWL se puede transferir cualquier tipo de memoria en una llamada de
bloque si se ha programado un puntero ANY en un parámetro del bloque.
Sin embargo, el puntero ANY no puede guardar información sobre la estructura. El puntero
ANY no guarda, p. ej. que apunta a una variable de tipo PLC. El puntero ANY lo considera
ARRAY of BYTE.
Se pueden transferir parámetros del tipo de datos ANY a bloques de función de sistema (SFB)
o funciones de sistema (SFC).
La figura siguiente muestra la estructura del puntero ANY:
%LW

%LW



 

%\WH

KSDUD6

%\WH

%\WH

7LSRGHGDWRV

%\WH

)DFWRUGHUHSHWLFLµQ

%\WH

%\WH

1¼PHURGH'% R

%\WH
%\WH



UHDGHPHPRULD
E

E

E

E

E

E

E

E











E

E

E

%\WH

E

E

E

E

E

[

[

[

%\WH

E GLUHFFLµQGHE\WHGHOD
YDULDEOH

[ GLUHFFLµQGHELW
GHODYDULDEOH

Un puntero ANY no puede reconocer estructuras. Solo puede asignarse a variables locales.
La tabla siguiente muestra los formatos para la declaración de un puntero ANY:
Representación

Formato

Ejemplo de entrada de
valores

Descripción

Simbólico

P#BloqueDatos.Área‐
Memoria DirecciónDa‐
tos Tipo Número

"MyDB".VariableS‐
truct.FirstComponent

Área de 10 palabras en
el DB global 11 a partir
de DBB20.0

P#ÁreaMemoria Direc‐ "MyMarkerTag"
ciónDatos Tipo Número
P#Valor cero

Programación del PLC
Manual de programación y manejo, 11/2019

Área de 4 bytes a partir
de MB20.0

"MyTag"

Entrada I1.0

-

Valor cero

357

Tipos de datos
3.11 Puntero
Representación

Formato

Ejemplo de entrada de
valores

Descripción

Absoluto

P#BloqueDatos.Área‐
Memoria DirecciónDa‐
tos Tipo Número

P#DB11.DBX20.0 INT
10

Área de 10 palabras en
el DB global 11 a partir
de DBB20.0

P#ÁreaMemoria Direc‐ P#M20.0 BYTE 10
ciónDatos Tipo Número
P#I1.0 BOOL 8

P#Valor cero
1)

Área de 10 bytes a par‐
tir de MB20.0
Área de 8 bits a partir de
la entrada I1.0 (la longi‐
tud indicada del área
debe ser múltiplo de 8).

P#P0.0 VOID 0, NULL 1) Valor cero

En los lenguajes KOP y FUP, solo se puede introducir NULL como valor válido en el valor cero.

Codificación de los tipos de datos
La tabla siguiente muestra la codificación de los tipos de datos para el puntero ANY:
Código hexadecimal

Tipo de datos

Descripción

B#16#00

NIL

Puntero Cero

B#16#011)

BOOL

Bits

B#16#02

BYTE

Bytes, 8 bits

B#16#03

CHAR

Caracteres de 8 bits

B#16#04

WORD

Palabras de 16 bits

B#16#05

INT

Enteros de 16 bits

B#16#06

DWORD

Palabras de 32 bits

B#16#07

DINT

Enteros de 32 bits

B#16#08

REAL

Números en coma flotante de 32
bits

B#16#0B

TIME

Tiempo

B#16#0C

S5TIME

Tiempo

B#16#09

DATE

Fecha

B#16#0A

TOD

Fecha y hora

B#16#0E

DT

Fecha y hora

B#16#13

STRING

Cadena de caracteres

B#16#171)

BLOCK_FB

Bloque de función

1)

BLOCK_FC

Función

B#16#191)

B#16#18

BLOCK_DB

Bloque de datos

B#16#1A1)

BLOCK_SDB

Bloque de datos de sistema

B#16#1C

1)

B#16#1D1)
1)

358

COUNTER

Contador

TIMER

Temporizador

Estos tipos de datos solo pueden utilizarse para el puntero ANY en una CPU S7-300/400.

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.12 Tipos de parámetros

Codificación de las áreas de memoria
La tabla siguiente muestra la codificación de las áreas de memoria para el puntero ANY:
Código hexadecimal
B#16#80

1)

B#16#81

Área

Descripción

P

Periferia

I

Área de memoria de las entradas

B#16#82

Q

Área de memoria de las salidas

B#16#83

M

Área de memoria de las marcas

DBX

Bloque de datos

B#16#84

DIX

Bloque de datos de instancia

B#16#86

B#16#85

L

Datos locales

B#16#87

V

Datos locales anteriores

1)

1)

Estas áreas de memoria solo pueden utilizarse para el puntero ANY en una CPU S7-300/400.

Consulte también
Fundamentos del direccionamiento indirecto (Página 121)
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de las constantes (Página 103)
Transferencia de parámetros como copia o puntero (Página 86)

3.12

Tipos de parámetros

3.12.1

Tipos de parámetros

Descripción
Los tipos de parámetros son tipos de datos para parámetros formales, que se transfieren a
bloques llamados. Un tipo de parámetros puede ser también un tipo de datos PLC.
La tabla siguiente muestra los tipos de parámetros disponibles y su significado:
Tipo de parámetro Longitud (bits)

Descripción

TIMER

16

Permite indicar un temporizador que se utiliza en el bloque ló‐
gico llamado. Cuando se transfiere un parámetro formal del tipo
TIMER, el parámetro actual correspondiente debe ser siempre
un temporizador.

COUNTER

16

Ejemplo: T1
Permite indicar un contador que se utiliza en el bloque lógico
llamado. Cuando se transfiere un parámetro formal del tipo
COUNTER, el parámetro actual correspondiente debe ser
siempre un contador.
Ejemplo: Z10

Programación del PLC
Manual de programación y manejo, 11/2019

359

Tipos de datos
3.13 Tipos de datos de sistema
Tipo de parámetro Longitud (bits)

Descripción

BLOCK_FC

16

BLOCK_FB

16

Permite indicar un bloque que se utiliza como entrada en el
bloque lógico llamado.

BLOCK_DB

16

BLOCK_SDB

16

Al declarar un parámetro se determina el tipo de bloque (p. ej.
FB, FC, DB) que se debe utilizar.
Cuando se transfiere un parámetro formal del tipo BLOCK, el
parámetro actual debe ser una dirección de bloque.
Ejemplo: DB3

Nota
Tipo de parámetro "Block_DB" para transferir un DB de instancia
En KOP y FUP no es posible indicar el DB de instancia de un bloque de función mediante una
entrada del tipo "Block_DB". En su lugar, utilice una instancia de parámetro.
Consulte también: Instancias de parámetro (Página 67)

Consulte también
Vista general de los tipos de datos válidos (Página 241)

3.13

Tipos de datos de sistema

3.13.1

Tipos de datos de sistema

Descripción
El sistema proporciona los tipos de datos de sistema (SDT), que tienen una estructura
predefinida. La estructura de un tipo de datos de sistema comprende un número fijo de
componentes, que pueden tener distintos tipos de datos. No es posible modificar la estructura
de un tipo de datos de sistema.
Los tipos de datos de sistema solo pueden asignarse entre sí si son del mismo tipo y si su
nombre coincide. Esto sirve también para tipos de datos PLC generados por el sistema, p. ej.
IEC_Timer, etc.

360

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.13 Tipos de datos de sistema
Los tipos de datos de sistema sólo pueden utilizarse para determinadas aplicaciones. La tabla
siguiente muestra los tipos de datos de sistema disponibles y su significado:
Tipo de datos de siste‐ Longitud
ma
(bytes)

Descripción

IEC_TIMER

Estructura de un sincronizador en la que están declarados
los parámetros PT, ET, IN y Q. Los valores de tiempo son del
tipo de datos TIME.

16

Este tipo de datos se utiliza p. ej. en las instrucciones "TP",
"TOF", "TON", "TONR", "RT" y "PT" .
IEC_LTIMER

32

Estructura de un sincronizador en la que están declarados
los parámetros PT, ET, IN y Q. Los valores de tiempo son del
tipo de datos LTIME.
Este tipo de datos se utiliza p. ej. en las instrucciones "TP",
"TOF", "TON", "TONR", "RT" y "PT" .

IEC_SCOUNTER

3

Estructura de un contador cuyos valores de contaje son del
tipo de datos SINT.
Este tipo de datos se utiliza p. ej. en las instrucciones "CTU",
"CTD" y "CTUD".

IEC_USCOUNTER

3

Estructura de un contador cuyos valores de contaje son del
tipo de datos USINT.
Este tipo de datos se utiliza p. ej. en las instrucciones "CTU",
"CTD" y "CTUD".

IEC_COUNTER

6

Estructura de un contador cuyos valores de contaje son del
tipo de datos INT.
Este tipo de datos se utiliza p. ej. en las instrucciones "CTU",
"CTD" y "CTUD".

IEC_UCOUNTER

6

Estructura de un contador cuyos valores de contaje son del
tipo de datos UINT.
Este tipo de datos se utiliza p. ej. en las instrucciones "CTU",
"CTD" y "CTUD".

IEC_DCOUNTER

12

Estructura de un contador cuyos valores de contaje son del
tipo de datos DINT.
Este tipo de datos se utiliza p. ej. en las instrucciones "CTU",
"CTD" y "CTUD".

IEC_UDCOUNTER

12

Estructura de un contador cuyos valores de contaje son del
tipo de datos UDINT.
Este tipo de datos se utiliza p. ej. en las instrucciones "CTU",
"CTD" y "CTUD".

IEC_LCOUNTER

24

Estructura de un contador cuyos valores de contaje son del
tipo de datos LINT.
Este tipo de datos se utiliza p. ej. en las instrucciones "CTU",
"CTD" y "CTUD".

IEC_ULCOUNTER

24

Estructura de un contador cuyos valores de contaje son del
tipo de datos ULINT.
Este tipo de datos se utiliza p. ej. en las instrucciones "CTU",
"CTD" y "CTUD".

Programación del PLC
Manual de programación y manejo, 11/2019

361

Tipos de datos
3.13 Tipos de datos de sistema
Tipo de datos de siste‐ Longitud
ma
(bytes)

Descripción

ERROR_STRUCT

Estructura de una información de error referente a un error de
programación o de acceso a la periferia.

28

Este tipo de datos se utiliza p. ej. en la instrucción
"GET_ERROR".
CREF

8

Componente del tipo de datos ERROR_STRUCT en el que
se guarda la información de dirección de un bloque.

NREF

8

Componente del tipo de datos ERROR_STRUCT en el que
se guarda la información de dirección de un operando.

VREF

12

Sirve para archivar un puntero VARIANT.
Este tipo de datos se utiliza, p. ej., en las instrucciones de
S7-1200/S7-1500 Motion Control.

SSL_HEADER

4

Indica la estructura de datos en la que se guarda la informa‐
ción referente a los registros al leer listas de estado del sis‐
tema. Este tipo de datos se utiliza p. ej. en la instrucción
"RDSYSST".

CONDITIONS

52

Estructura de datos definida, que establece las condiciones
para el inicio y final de una recepción de datos.
Este tipo de datos se utiliza p. ej. en la instrucción
"RCV_CFG".

TADDR_Param

8

Indica la estructura de un bloque de datos en el que se de‐
positan las descripciones de conexiones para Open User
Communication vía UDP.
Este tipo de datos se utiliza p. ej. en las instrucciones "TU‐
SEND" y "TURSV".

TCON_Param

64

Indica la estructura de un bloque de datos en el que se de‐
positan las descripciones de conexiones para Open User
Communication vía Industrial Ethernet (PROFINET).
Este tipo de datos se utiliza p. ej. en las instrucciones
"TSEND" y "TRSV".

HSC_Period

12

Especifica la estructura de un bloque de datos para la medi‐
ción de período con el contador rápido avanzado.
Este tipo de datos se utiliza p. ej. en la instrucción
"CTRL_HSC_EXT".

AssocValues

16

Estructura de datos definida. Define los valores asociados
que se envían junto con un aviso.
Este tipo de datos se utiliza p. ej. en la instrucción
"Gen_UsrMsg".

Consulte también
Vista general de los tipos de datos válidos (Página 241)

362

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.14 Tipos de datos de hardware

3.14

Tipos de datos de hardware

3.14.1

Tipos de datos de hardware

Descripción
La CPU provee los tipos de datos de hardware. El número de tipos de datos de hardware
disponibles depende de la CPU utilizada.
En función de los módulos parametrizados en la configuración de hardware, se crean
constantes de un determinado tipo de datos de hardware. Si se inserta una instrucción para
controlar o activar un módulo parametrizado en el programa de usuario, las constantes
disponibles podrán utilizarse para asignar valores a los parámetros.
La tabla siguiente muestra los tipos de datos de hardware disponibles y su significado:
Tipo de datos

Tipos de datos base

Descripción

REMOTE

ANY

Permite especificar la dirección de una CPU remota.
Este tipo de datos se utiliza p. ej. en las instrucciones
"PUT" y "GET".

HW_ANY

UINT

Identificación de un componente de hardware cual‐
quiera, p. ej. un módulo

HW_DEVICE

HW_ANY

Identificación de un esclavo DP o un dispositivo PRO‐
FINET IO

HW_DPMASTER

HW_INTERFACE

Identificación de un maestro DP

HW_DPSLAVE

HW_DEVICE

Identificación de un esclavo DP

HW_IO

HW_ANY

Número de identificación de la CPU o la interfaz
El número se asigna automáticamente y se guarda en
las propiedades de la CPU o de la interfaz en la con‐
figuración de hardware.

HW_IOSYSTEM

HW_ANY

Identificación de un sistema PN/IO o de un sistema
maestro DP

HW_SUBMODULE

HW_IO

Identificación de un componente central de hardware

HW_MODULE

HW_IO

Identificación de un módulo

HW_INTERFACE

HW_SUBMODULE

Identificación de un componente de interfaz

HW_IEPORT

HW_SUBMODULE

Identificación de un puerto (PN/IO)

HW_HSC

HW_SUBMODULE

Identificación de un contador rápido
Este tipo de datos se utiliza p. ej. en las instrucciones
"CTRL_HSC" y "CTRL_HSC_EXT".

HW_PWM

HW_SUBMODULE

Identificación de una modulación de ancho de impul‐
sos
Este tipo de datos se utiliza p. ej. en la instrucción
"CTRL_PWM".

HW_PTO

HW_SUBMODULE

EVENT_ANY

AOM_IDENT

Identificación de un encóder incremental de posición
Este tipo de datos se utiliza para Motion Control

Programación del PLC
Manual de programación y manejo, 11/2019

Sirve para indicar un evento cualquiera.

363

Tipos de datos
3.14 Tipos de datos de hardware
Tipo de datos

Tipos de datos base

Descripción

EVENT_ATT

EVENT_ANY

Permite especificar un evento que puede asignarse
dinámicamente a un OB
Este tipo de datos se utiliza p. ej. en las instrucciones
"ATTACH" y "DETACH".

EVENT_HWINT

EVENT_ATT

Permite especificar un evento de alarma de proceso

OB_ANY

INT

Permite especificar un bloque de organización cual‐
quiera.

OB_DELAY

OB_ANY

Permite especificar un bloque de organización al que
se llama al producirse una alarma de retardo.
Este tipo de datos se utiliza p. ej. en las instrucciones
"SRT_DINT" y "CAN_DINT".

OB_TOD

OB_ANY

Indica el número de un bloque de organización de
alarma horaria.
Este tipo de datos se utiliza p. ej. en las instrucciones
"SET_TINT", "CAN_TINT", "ACT_TINT" y
"QRY_TINT".

OB_CYCLIC

OB_ANY

Permite especificar un bloque de organización al que
se llama al producirse una alarma cíclica.

OB_ATT

OB_ANY

Permite especificar un bloque de organización que
puede asignarse dinámicamente a un evento.
Este tipo de datos se utiliza p. ej. en las instrucciones
"ATTACH" y "DETACH".

OB_PCYCLE

OB_ANY

Permite especificar un bloque de organización que
puede asignarse a un evento de la clase de evento
"Programa cíclico".

OB_HWINT

OB_ATT

Permite especificar un bloque de organización al que
se llama al producirse una alarma de proceso.

OB_DIAG

OB_ANY

Permite especificar un bloque de organización al que
se llama al producirse una alarma de diagnóstico.

OB_TIMEERROR

OB_ANY

Permite especificar un bloque de organización al que
se llama al producirse un error de tiempo.

OB_STARTUP

OB_ANY

Permite especificar un bloque de organización al que
se llama al producirse un evento de arranque.

PORT

HW_SUBMODULE

Permite especificar un puerto de comunicación.
Este tipo de datos se utiliza para la comunicación
punto a punto.

RTM

UINT

Permite especificar el número de un contador de ho‐
ras de funcionamiento.
Este tipo de datos se utiliza p. ej. en la instrucción
"RTM".

364

PIP

UINT

Permite crear e interconectar un OB "Synchronous
Cycle". Este tipo de datos se utiliza en las SFC 26, 27,
126 y 127.

CONN_ANY

WORD

Sirve para indicar una conexión cualquiera.

CONN_PRG

CONN_ANY

Permite especificar una conexión para la comunica‐
ción abierta vía UDP.

CONN_OUC

CONN_ANY

Sirve para indicar una conexión para la comunicación
abierta vía Industrial Ethernet (PROFINET).

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.14 Tipos de datos de hardware
Tipo de datos

Tipos de datos base

Descripción

CONN_R_ID

DWORD

Tipo de datos para el parámetro R_ID en los bloques
de comunicación S7.

DB_ANY

UINT

Identificación (nombre o número) de un DB
El tipo de datos "DB_ANY" tiene la longitud 0 en la
sección "Temp".

DB_WWW

DB_ANY

Número del DB que describe la aplicación web (p. ej.
la instrucción "WWW")
El tipo de datos "DB_WWW" tiene la longitud 0 en la
sección "Temp".

DB_DYN

DB_ANY

Número del DB generado mediante el programa de
usuario

C_ALARM

C_ALARM

CPU S7-400: 1 canal, con acuse, hasta 10 valores
asociados
Este tipo de datos se utiliza para el bloque de aviso
ALARM.

C_ALARM_S

DWORD

CPU S7-300/400: 1 canal, con y sin acuse, hasta 1
valor asociado
Este tipo de datos se utiliza para los bloques de aviso
ALARM_S, ALARM_SQ, ALARM_DQ y ALARM_D.

C_ALARM_8

C_ALARM

CPU S7-400: 8 canales, con acuse, sin valores aso‐
ciados
Este tipo de datos se utiliza para el bloque de aviso
ALARM_8.

C_ALARM_8P

C_ALARM

CPU S7-400: 8 canales, con acuse, hasta 10 valores
asociados por canal
Este tipo de datos se utiliza para el bloque de aviso
ALARM_8P.

C_AR_SEND

C_ALARM

CPU S7-400: sirve para enviar un fichero
Este tipo de datos se utiliza para el bloque de aviso
AR_SEND.

C_NOTIFY

C_ALARM

CPU S7-400: 1 canal, sin acuse, hasta 10 valores
asociados
Este tipo de datos se utiliza para el bloque de aviso
NOTIFY.

C_NOTIFY_8P

C_ALARM

CPU S7-400: 8 canales, sin acuse, hasta 10 valores
asociados
Este tipo de datos se utiliza para el bloque de aviso
NOTIFY_8P.

C_ALARM_SD

DWORD

Sirve para leer el número de aviso. Este tipo de datos
solo puede utilizarse con la CPU S7-410H.

Consulte también
Vista general de los tipos de datos válidos (Página 241)

Programación del PLC
Manual de programación y manejo, 11/2019

365

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

3.15

Conversión de los tipos de datos en el S7-1500

3.15.1

Sinopsis de la conversión de tipos de datos

Introducción
Para combinar lógicamente varios operandos en una instrucción, es necesario verificar la
compatibilidad de los tipos de datos. Esto también es aplicable a las asignaciones, o a la
asignación de valores a los parámetros de bloque. Si los tipos de datos de los operandos son
diferentes, será preciso realizar una conversión.
La conversión puede realizarse de dos maneras, a saber:
● Conversión implícita
Los lenguajes de programación KOP, FUP, SCL y GRAPH soportan la conversión implícita.
La conversión implícita no es posible en el lenguaje de programación AWL.
● Conversión explícita
Se utiliza una instrucción de conversión explícita antes de ejecutar la instrucción
propiamente dicha.
Nota
Conversión de secuencias de bits en SCL
Todas las secuencias de bit (BYTE, WORD, DWORD y LWORD) incluidas en expresiones
reciben el mismo tratamiento que los enteros sin signo (USINT, UINT, UDINT y ULINT). Por
ello, p. ej. la conversión implícita de DWORD a REAL se lleva a cabo del mismo modo que una
conversión de UDINT a REAL.
Nota
Conversión de REF()
No es posible la conversión del tipo de datos REF(). La variable transferida debe coincidir
exactamente con el tipo de datos de destino.

366

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita
La conversión implícita se realiza automáticamente si los tipos de datos de los operandos son
compatibles. La compatibilidad puede verificarse según criterios más o menos estrictos:
● Con verificación IEC (ajuste predeterminado)
Si está activada la verificación IEC, se aplican las siguientes reglas:
– La conversión implícita de BOOL a otros tipos de datos no es posible.
– Solo los tipos de datos REAL, BYTE, WORD, DWORD, DINT, INT, SINT, UDINT, UINT,
USINT, TIME, LDT, DTL, DT, TOD, WCHAR y CHAR se pueden convertir de forma
implícita.
– La longitud de bits del tipo de datos de origen no puede rebasar la longitud de bits del
tipo de datos de destino. El operando del tipo de datos WORD no puede indicarse, por
ejemplo, en un parámetro si en él se espera el tipo de datos BYTE.
● Sin verificación IEC
Si no está activada la verificación IEC, se aplican las siguientes reglas:
– La conversión implícita de BOOL a otros tipos de datos no es posible.
– Solo los tipos de datos REAL, LREAL, BYTE, WORD, DWORD, LWORD, SINT, INT,
DINT, LINT, USINT, UINT, UDINT, ULINT, TIME, LTIME, S5TIME, LDT, DTL, TOD,
LTOD, DATE, STRING, WSTRING, WCHAR y CHAR se pueden convertir de forma
implícita.
– La longitud de bits del tipo de datos de origen no puede rebasar la longitud de bits del
tipo de datos de destino. El operando del tipo de datos DWORD no puede indicarse, por
ejemplo, en un parámetro si en él se espera el tipo de datos WORD.
– En los parámetros de entrada/salida (InOut) la longitud de bits de un operando indicado
debe coincidir con la longitud de bits programada para el parámetro correspondiente.
Nota
Conversión implícita sin verificación IEC
El editor de programación identifica con un rectángulo gris los operandos que deben
convertirse de forma implícita. Un rectángulo gris oscuro indica que es posible realizar
una conversión implícita sin pérdidas de precisión, p. ej. si el tipo de datos INT se
convierte a DINT. Un rectángulo gris claro indica que es posible realizar una conversión
implícita, aunque pueden producirse fallos en tiempo de ejecución. Si, por ejemplo, el
tipo de datos LINT se convierte a DINT y se produce un desbordamiento, la salida de
habilitación ENO se pone a "0".
Encontrará más información sobre el ajuste de la verificación IEC y la conversión implícita en
el apartado "Consulte también".

Conversión explícita
Si los operandos no son compatibles, por lo que no se puede realizar una conversión implícita,
es posible utilizar una instrucción de conversión explícita. Para ello se pueden utilizar las
instrucciones de conversión de la Task Card "Instrucciones" o bien se puede insertar la
conversión en el programa manualmente. Encontrará la notación de las funciones de
conversión explícita en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

367

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Un posible desbordamiento se indica en la salida de habilitación ENO. Un desbordamiento
tiene lugar cuando, p. ej., el valor del tipo de datos de origen es mayor que el valor del tipo de
datos de destino.
Nota
Mover patrones de bits
Si la conversión explícita consiste en mover un patrón de bits, la salida de habilitación ENO no
se activa.
Encontrará más información sobre la conversión explícita en "Consulte también".
La figura siguiente muestra un ejemplo en el que debe realizarse una conversión explícita de
tipos de datos:
%ORFNB'DWD
&219(57
',17WR,17

,1B',17

(1

(12

,1

287

%ORFN
(1
287B,17 287B,17

(12

,1B,17 287B%22/

El bloque de función "Block" espera en el parámetro de entrada "IN_INT" una variable del tipo
de datos INT. Por ello, el valor de la variable "IN_DINT" se debe convertir primero de DINT a
INT. Si el valor de la variable "IN_DINT" se encuentra dentro del rango de valores permitido del
tipo de datos INT, se realiza una conversión. De lo contrario se notifica un desbordamiento. No
obstante, también en caso de desbordamiento se realiza una conversión, pero los valores se
cortan y la salida de habilitación ENO se pone a "0".

Consulte también
Conversiones implícitas (Página 368)
Conversiones explícitas (Página 422)

3.15.2

Conversiones implícitas

3.15.2.1

Activar o desactivar la verificación CEI
Se comprueba si los tipos de datos de los operandos utilizados son compatibles. La
compatibilidad puede verificarse según criterios más o menos estrictos. Si está activada la
"Verificación CEI para bloques lógicos", se aplican criterios más estrictos.
La verificación CEI se puede configurar de forma centralizada para todos los bloques nuevos
del proyecto, o bien para un bloque en particular.

368

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Configurar la verificación CEI para bloques nuevos
Para configurar la verificación CEI para todos los bloques nuevos del proyecto, proceda del
siguiente modo:
1. Elija el comando "Configuración" del menú "Opciones".
Se abre la ventana "Configuración" en el área de trabajo.
2. Seleccione el grupo "Programación PLC > General" en la navegación local.
3. En el grupo "Ajuste predeterminado para bloques nuevos", active o desactive la casilla de
verificación "Verificación CEI para bloques lógicos".
La verificación CEI se activa o desactiva para todos los bloques nuevos del programa.

Configurar la verificación CEI para un bloque en particular
Para configurar la verificación CEI para un bloque en particular, proceda del siguiente modo:
1. Abra el bloque.
2. Abra la ficha "Propiedades" de la ventana de inspección.
3. Seleccione el grupo "Atributos" en la navegación local.
4. Active o desactive la casilla de verificación "Verificación CEI".
La verificación CEI se activa o desactiva para este bloque. El ajuste se guarda junto con el
proyecto.

3.15.2.2

Números binarios

Conversión implícita de BOOL
Posibilidades de conversión implícita
La conversión implícita del tipo de datos BOOL no es posible.

Consulte también
BOOL (bit) (Página 245)
Sinopsis de la conversión de tipos de datos (Página 366)
Activar o desactivar la verificación CEI (Página 368)
Conversión explícita de BOOL (Página 422)

Programación del PLC
Manual de programación y manejo, 11/2019

369

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Secuencias de bits
Conversión implícita de BYTE
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
BYTE:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

BYTE

BOOL

-

-

Ninguna conversión implícita

WORD

X

X

DWORD

X

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

LWORD

X

X

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

UDINT

-

X

LINT

-

X

ULINT

-

X

REAL

-

-

LREAL

-

-

TIME

-

-

LTIME

-

-

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

Ninguna conversión implícita

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

370

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
BYTE (Página 246)
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
Conversión explícita de BYTE (Página 424)

Programación del PLC
Manual de programación y manejo, 11/2019

371

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de WORD
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
WORD:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

WORD

BOOL

-

-

Ninguna conversión implícita

BYTE

-

X

El byte menos significativo se transfiere al tipo de datos de des‐
tino, y el byte más significativo se ignora.

DWORD

X

X

LWORD

X

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

SINT

-

X

El byte menos significativo se transfiere al tipo de datos de des‐
tino, y el byte más significativo se ignora.
El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

UDINT

-

X

LINT

-

X

ULINT

-

X

REAL

-

-

LREAL

-

-

TIME

-

-

LTIME

-

-

S5TIME

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.
Ninguna conversión implícita

Ninguna conversión implícita

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.
Ninguna conversión implícita

TOD

-

-

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

372

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
WORD (Página 247)
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
Conversión explícita de WORD (Página 427)

Programación del PLC
Manual de programación y manejo, 11/2019

373

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de DWORD
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
DWORD:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

DWORD

BOOL

-

-

Ninguna conversión implícita

BYTE

-

X

WORD

-

X

Los bytes derechos se transfieren al tipo de datos de destino, y
los bytes izquierdos se ignoran.

LWORD

X

X

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

UDINT

-

X

LINT

-

X

ULINT

-

X

REAL

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino.

El valor se convierte al formato del tipo de datos de destino. (El
valor "-1" se convierte en el valor "-1.0", por ejemplo.)

LREAL

-

-

Ninguna conversión implícita

TIME

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.
Ninguna conversión implícita

LTIME

-

-

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.
Ninguna conversión implícita

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

374

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
DWORD (Página 248)
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
Conversión explícita de DWORD (Página 430)

Programación del PLC
Manual de programación y manejo, 11/2019

375

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de LWORD
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
LWORD:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

LWORD

BOOL

-

-

Ninguna conversión implícita

BYTE

-

X

WORD

-

X

Los bytes derechos se transfieren al tipo de datos de destino, y
los bytes izquierdos se ignoran.

DWORD

-

X

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

UDINT

-

X

LINT

-

X

ULINT

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

REAL

-

-

Ninguna conversión implícita

LREAL

-

X

El valor se convierte al formato del tipo de datos de destino. (El
valor "-1" se convierte en el valor "-1.0", por ejemplo.)

TIME

-

-

Ninguna conversión implícita

LTIME

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

S5TIME

-

-

Ninguna conversión implícita

LDT

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

DTL

-

-

Ninguna conversión implícita

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.
Ninguna conversión implícita

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

376

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
LWORD (Página 250)
Conversión explícita de LWORD (Página 434)

Programación del PLC
Manual de programación y manejo, 11/2019

377

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

3.15.2.3

Enteros

Conversión implícita de SINT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos SINT:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

SINT

BOOL

-

-

Ninguna conversión implícita

BYTE

-

X

WORD

-

X

DWORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino. El resto de los
bits se rellenan con "0".

LWORD

-

X

USINT

-

X

INT

X

X

UINT

-

X

DINT

X

X

UDINT

-

X

LINT

X

X

ULINT

-

X

REAL

X

X

LREAL

X

X

El valor se convierte al formato del tipo de datos de destino. (El
valor "-1" se convierte en el valor "-1.0", por ejemplo.)

TIME

-

-

Ninguna conversión implícita

LTIME

-

-

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Transferencia de valores de p. ej. SINT
#-1 -> INT #-1, no se rellena con "0".)

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)

378

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
SINT (enteros de 8 bits) (Página 251)
Conversión explícita de SINT (Página 438)

Conversión implícita de USINT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
USINT:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

USINT

BOOL

-

-

Ninguna conversión implícita
El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino. El resto de los
bits se rellenan con "0".

BYTE

-

X

WORD

-

X

DWORD

-

X

LWORD

-

X

SINT

-

X

INT

X

X

UINT

X

X

DINT

X

X

UDINT

X

X

LINT

X

X

ULINT

X

X

REAL

X

X

LREAL

X

X

El valor se convierte al formato del tipo de datos de destino. (El
valor "-1" se convierte en el valor "-1.0", por ejemplo.)

TIME

-

-

Ninguna conversión implícita

LTIME

-

-

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Conversión de valores de p. ej. USINT
#10 -> DINT #10, o USINT #128 -> SINT #-128)

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

Programación del PLC
Manual de programación y manejo, 11/2019

379

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
USINT (enteros de 8 bits) (Página 252)
Conversión explícita de USINT (Página 442)

380

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de INT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos INT:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

INT

BOOL

-

-

Ninguna conversión implícita

BYTE

-

X

WORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

DWORD

-

X

LWORD

-

X

SINT

-

X

USINT

-

X

UINT

-

X

DINT

X

X

UDINT

-

X

LINT

X

X

ULINT

-

X

REAL

X

X

LREAL

X

X

El valor se convierte al formato del tipo de datos de destino. (El
valor "-1" se convierte en el valor "-1.0", por ejemplo.)
Ninguna conversión implícita

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Conversión de valores de p. ej. INT #-1
-> SINT #-1, o INT #-32 767 -> UINT #32 769)

TIME

-

-

LTIME

-

-

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

TOD

-

-

Ninguna conversión implícita

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)

Programación del PLC
Manual de programación y manejo, 11/2019

381

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
INT (enteros de 16 bits) (Página 253)
Conversión explícita de INT (Página 445)

Conversión implícita de UINT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos UINT:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

UINT

BOOL

-

-

Ninguna conversión implícita
El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

BYTE

-

X

WORD

-

X

DWORD

-

X

LWORD

-

X

SINT

-

X

USINT

-

X

INT

-

X

DINT

X

X

UDINT

X

X

LINT

X

X

ULINT

X

X

REAL

X

X

LREAL

X

X

El valor se convierte al formato del tipo de datos de destino. (El
valor "-1" se convierte en el valor "-1.0", por ejemplo.)

TIME

-

-

Ninguna conversión implícita

LTIME

-

-

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

TOD

-

-

Ninguna conversión implícita

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Conversión de valores de p. ej. UINT
#100 -> DINT #100, o UINT #60 000 -> INT #-5536)

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

382

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
UINT (enteros de 16 bits) (Página 254)
Conversión explícita de UINT (Página 449)

Programación del PLC
Manual de programación y manejo, 11/2019

383

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de DINT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos DINT:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

DINT

BOOL

-

-

Ninguna conversión implícita

BYTE

-

X

WORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

DWORD

-

X

LWORD

-

X

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

UDINT

-

X

LINT

X

X

ULINT

-

X

REAL

-

X

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Conversión de valores de p. ej. DINT
#-1 -> REAL #-1.0, pero se da una pérdida de precisión en aque‐
llos números cuyo valor absoluto es mayor que 8 388 608)

LREAL

X

X

El valor se convierte al formato del tipo de datos de destino. (El
valor "-1" se convierte en el valor "-1.0", por ejemplo.)

TIME

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

LTIME

-

-

Ninguna conversión implícita

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.
Ninguna conversión implícita

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Conversión de valores de p. ej. DINT
#-1 -> SINT #-1, o DINT #-1 -> USINT #255)

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

384

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
DINT (enteros de 32 bits) (Página 255)
Conversión explícita de DINT (Página 452)

Programación del PLC
Manual de programación y manejo, 11/2019

385

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de UDINT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
UDINT:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

UDINT

BOOL

-

-

Ninguna conversión implícita

BYTE

-

X

WORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

DWORD

-

X

LWORD

-

X

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

LINT

X

X

ULINT

X

X

REAL

-

X

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Conversión de valores de p. ej. DINT
#-1 -> REAL #-1.0, pero se da una pérdida de precisión en aque‐
llos números cuyo valor absoluto es mayor que 8 388 608)

LREAL

X

X

El valor se convierte al formato del tipo de datos de destino. (El
valor "-1" se convierte en el valor "-1.0", por ejemplo.)

TIME

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

LTIME

-

-

Ninguna conversión implícita

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.
Ninguna conversión implícita

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Conversión de valores de p. ej. DINT
#-1 -> SINT #-1, o DINT #-1 -> USINT #255)

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

386

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
UDINT (enteros de 32 bits) (Página 256)
Conversión explícita de UDINT (Página 456)

Programación del PLC
Manual de programación y manejo, 11/2019

387

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de LINT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos LINT:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

LINT

BOOL

-

-

Ninguna conversión implícita

BYTE

-

X

WORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

DWORD

-

X

LWORD

-

X

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

UDINT

-

X

ULINT

-

X

REAL

-

X

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Conversión de valores de p. ej. LINT
#-1 -> REAL #-1.0, pero se da una pérdida de precisión en aque‐
llos números cuyo valor absoluto es mayor que 8 388 608)

LREAL

-

X

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Conversión de valores de p. ej. LINT
#-1 -> REAL #-1.0, pero se da una pérdida de precisión en aque‐
llos números cuyo valor absoluto es mayor que 9 007 199 254
740 992)

388

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Conversión de valores de p. ej. LINT
#-1 -> SINT #-1, o LINT #-1 -> USINT #255)

TIME

-

-

Ninguna conversión implícita

LTIME

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino. (Tiempo en
nanosegundos)

S5TIME

-

-

Ninguna conversión implícita

LDT

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino. (Nanosegun‐
dos desde el 1.1.1970)

DTL

-

-

Ninguna conversión implícita

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.
Ninguna conversión implícita

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

x: Conversión posible
-: Conversión no posible

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
LINT (enteros de 64 bits) (Página 257)
Conversión explícita de LINT (Página 460)

Programación del PLC
Manual de programación y manejo, 11/2019

389

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de ULINT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
ULINT:

390

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

ULINT

BOOL

-

-

Ninguna conversión implícita
El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

BYTE

-

X

WORD

-

X

DWORD

-

X

LWORD

-

X

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

UDINT

-

X

LINT

-

X

REAL

-

X

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Conversión de valores de p. ej. LINT
#-1 -> REAL #-1.0, pero se da una pérdida de precisión en aque‐
llos números cuyo valor absoluto es mayor que 8 388 608)

LREAL

-

X

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Conversión de valores de p. ej. LINT
#-1 -> REAL #-1.0, pero se da una pérdida de precisión en aque‐
llos números cuyo valor absoluto es mayor que 9 007 199 254
740 992)

TIME

-

-

Ninguna conversión implícita

LTIME

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino. (Tiempo en
nanosegundos)

S5TIME

-

-

Ninguna conversión implícita

LDT

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino. (Nanosegun‐
dos desde el 1.1.1970)
Ninguna conversión implícita

El patrón de bits del valor de origen se convierte y se transfiere al
tipo de datos de destino. (Conversión de valores de p. ej. ULINT
#-1 -> SINT #-1, o ULINT #-1 -> USINT #255)

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

STRING

-

-

Ninguna conversión implícita

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

Programación del PLC
Manual de programación y manejo, 11/2019

391

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
ULINT (enteros de 64 bits) (Página 259)
Conversión explícita de ULINT (Página 464)

392

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

3.15.2.4

Números en coma flotante

Conversión implícita de REAL
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
REAL:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

REAL

BOOL

-

-

Ninguna conversión implícita

BYTE

-

-

WORD

-

-

DWORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino.

LWORD

-

-

Ninguna conversión implícita

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

UDINT

-

X

El patrón de bits del valor de origen se redondea, se convierte y
se transfiere al tipo de datos de destino. (Redondeo y conversión
de valores de p. ej.
REAL #2.5 -> INT #2,
o números negativos REAL #-2.5 -> INT #-2 -> USINT #254.
En caso de desbordamiento se determina el resto REAL #305.5
-> INT #306 -> USINT #50)

LINT

-

X

ULINT

-

X

LREAL

X

X

El valor se transfiere al tipo de datos de destino.
Ninguna conversión implícita

TIME

-

-

LTIME

-

-

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

Programación del PLC
Manual de programación y manejo, 11/2019

393

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
REAL (Página 261)
Conversión explícita de REAL (Página 467)

394

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de LREAL
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
LREAL:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

LREAL

BOOL

-

-

Ninguna conversión implícita

BYTE

-

-

WORD

-

-

DWORD

-

-

LWORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino.

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

UDINT

-

X

El patrón de bits del valor de origen se redondea, se convierte y
se transfiere al tipo de datos de destino. (Redondeo y conversión
de valores de p. ej.
LREAL #2.5 -> INT #2,
o números negativos LREAL #-2.5 -> INT #-2 -> USINT #254.
En caso de desbordamiento se determina el resto LREAL #305.5
-> INT #306 -> USINT #50)

LINT

-

X

ULINT

-

X

REAL

-

X

El valor se transfiere al tipo de datos de destino.

TIME

-

-

Ninguna conversión implícita

LTIME

-

-

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)

Programación del PLC
Manual de programación y manejo, 11/2019

395

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
LREAL (Página 262)
Conversión explícita de LREAL (Página 470)

396

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

3.15.2.5

Tiempos

Conversión implícita de S5TIME
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
S5TIME:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

S5TIME

BOOL

-

-

Ninguna conversión implícita

BYTE

-

-

WORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión muestra el
tiempo en milisegundos.

DWORD

-

-

Ninguna conversión implícita

LWORD

-

-

SINT

-

-

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

-

UDINT

-

-

LINT

-

-

ULINT

-

-

REAL

-

-

LREAL

-

-

TIME

-

-

LTIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

Programación del PLC
Manual de programación y manejo, 11/2019

397

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
S5TIME (tiempo) (Página 265)
Conversión explícita de S5TIME (Página 473)

398

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de TIME
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos TIME:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

TIME

BOOL

-

-

Ninguna conversión implícita

BYTE

-

-

WORD

-

-

DWORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión muestra el
tiempo en milisegundos.

LWORD

-

-

Ninguna conversión implícita

SINT

-

-

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

X

UDINT

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión muestra el
tiempo en milisegundos.

LINT

-

-

Ninguna conversión implícita

ULINT

-

-

REAL

-

-

LREAL

-

-

S5TIME

-

-

LTIME

X

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión muestra el
tiempo en nanosegundos. (1 ms = 1 000 000 ns)

LDT

-

-

Ninguna conversión implícita

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

X

Si el valor de origen está entre 0 y 84599.999 s, el patrón de bits
del valor de origen se transfiere sin cambios al tipo de datos de
destino. (Representación en nanosegundos). De lo contrario, el
valor de destino no se modifica. El resultado de la conversión
muestra el tiempo transcurrido desde medianoche.

LTOD

-

-

Ninguna conversión implícita

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

Programación del PLC
Manual de programación y manejo, 11/2019

399

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
TIME (tiempo IEC) (Página 266)
Conversión explícita de TIME (Página 475)

400

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de LTIME
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
LTIME:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

LTIME

BOOL

-

-

Ninguna conversión implícita

BYTE

-

-

WORD

-

-

DWORD

-

-

LWORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión muestra el
tiempo en nanosegundos.
Ninguna conversión implícita

SINT

-

-

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

-

UDINT

-

-

LINT

-

X

ULINT

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión muestra el
tiempo en nanosegundos.

REAL

-

-

Ninguna conversión implícita

LREAL

-

-

S5TIME

-

-

TIME

-

X

Si el valor de origen está fuera del rango de valores del tipo de
datos de destino, el valor de destino no se cambia. (De
0.123456789 s se obtiene 0.123 s)

LDT

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión muestra el
tiempo en nanosegundos desde el 1.1.1970.

DTL

-

-

Ninguna conversión implícita

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión muestra el
tiempo en nanosegundos desde el 1.1.1970.
Ninguna conversión implícita

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

Programación del PLC
Manual de programación y manejo, 11/2019

401

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
LTIME (temporizador CEI) (Página 267)
Conversión explícita de LTIME (Página 478)

402

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

3.15.2.6

Fecha y hora

Conversión implícita de DT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos DT:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

DT

BOOL

-

-

Ninguna conversión implícita

BYTE

-

-

WORD

-

-

DWORD

-

-

LWORD

-

-

SINT

-

-

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

-

UDINT

-

-

LINT

-

-

ULINT

-

-

REAL

-

-

LREAL

-

-

TIME

-

-

LTIME

-

-

S5TIME

-

-

LDT

X

X

DTL

X

X

El valor de origen se transfiere sin cambios, conservando su va‐
lor, al tipo de datos de destino. (El valor 24.12.2012 14:30 sigue
siendo 24.12.2012 14:30)
Ninguna conversión implícita

DATE

-

-

TOD

-

-

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

Programación del PLC
Manual de programación y manejo, 11/2019

403

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
DT (DATE_AND_TIME) (Página 269)
Conversión explícita de DT (Página 481)

404

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de LDT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos LDT:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

LDT

BOOL

-

-

Ninguna conversión implícita

BYTE

-

-

WORD

-

-

DWORD

-

-

LWORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino. (Nanosegun‐
dos desde el 1.1.1970)
Ninguna conversión implícita

SINT

-

-

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

-

UDINT

-

-

LINT

-

X

ULINT

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino. (Nanosegun‐
dos desde el 1.1.1970)

REAL

-

-

Ninguna conversión implícita

LREAL

-

-

TIME

-

-

LTIME

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino. (Nanosegun‐
dos desde el 1.1.1970)

S5TIME

-

-

Ninguna conversión implícita

DT

-

X

El patrón de bits del valor de origen se convierte al tipo de datos
de destino con una pérdida de precisión. (De 24.12.2012
12:34:56.123456789 se obtiene 24.12.2012 12:34:56.123)

DTL

X

X

El valor de origen se transfiere sin cambios, conservando su va‐
lor, al tipo de datos de destino. (El valor 24.12.2012 14:30 sigue
siendo 24.12.2012 14:30)

DATE

-

-

Ninguna conversión implícita

TOD

-

-

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

Programación del PLC
Manual de programación y manejo, 11/2019

405

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
Conversión explícita de LDT (Página 484)
LDT (DATE_AND_LTIME) (Página 271)

406

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de DTL
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos DTL:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

DTL

BOOL

-

-

Ninguna conversión implícita

BYTE

-

-

WORD

-

-

DWORD

-

-

LWORD

-

-

SINT

-

-

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

-

UDINT

-

-

LINT

-

-

ULINT

-

-

REAL

-

-

LREAL

-

-

TIME

-

-

LTIME

-

-

S5TIME

-

-

LDT

X

X

El valor de origen se transfiere sin cambios, conservando su va‐
lor, al tipo de datos de destino. (El valor 24.12.2012 14:30 sigue
siendo 24.12.2012 14:30)

DT

-

X

El patrón de bits del valor de origen se convierte al tipo de datos
de destino con una pérdida de precisión. (De 24.12.2012
12:34:56.123456789 se obtiene 24.12.2012 12:34:56.123)

DATE

-

-

Ninguna conversión implícita

TOD

-

-

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

Programación del PLC
Manual de programación y manejo, 11/2019

407

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
DTL (Página 271)
Conversión explícita de DTL (Página 487)

408

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de DATE
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
DATE:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

DATE

BOOL

-

-

Ninguna conversión implícita

BYTE

-

-

WORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión corres‐
ponde al número de días desde el 01.01.1990.
Ninguna conversión implícita

DWORD

-

-

LWORD

-

-

SINT

-

-

USINT

-

-

INT

-

X

UINT

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión corres‐
ponde al número de días desde el 01.01.1990.

DINT

-

-

Ninguna conversión implícita

UDINT

-

-

LINT

-

-

ULINT

-

-

REAL

-

-

LREAL

-

-

TIME

-

-

LTIME

-

-

S5TIME

-

-

LDT

-

-

DT

-

-

DTL

-

-

TOD

-

-

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
Programación del PLC
Manual de programación y manejo, 11/2019

409

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
DATE (Página 268)
Conversión explícita de DATE (Página 490)

410

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de TOD
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos TOD:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

TOD

BOOL

-

-

Ninguna conversión implícita

BYTE

-

-

WORD

-

-

DWORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión equivale
al número de milisegundos desde el inicio del día (0:00 horas).

LWORD

-

-

Ninguna conversión implícita

SINT

-

-

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

X

UDINT

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión equivale
al número de milisegundos desde el inicio del día (0:00 horas).

LINT

-

-

Ninguna conversión implícita

ULINT

-

-

REAL

-

-

LREAL

-

-

TIME

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión equivale
al número de milisegundos desde el inicio del día (0:00 horas).
Ninguna conversión implícita

LTIME

-

-

S5TIME

-

-

LDT

-

-

DT

-

-

DTL

-

-

DATE

-

-

LTOD

X

X

El valor de origen se transfiere sin cambios, conservando su va‐
lor, al tipo de datos de destino. (De 12:34:56.123 se obtiene
12:34:56.123000000)

STRING

-

-

Ninguna conversión implícita

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

Programación del PLC
Manual de programación y manejo, 11/2019

411

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
TOD (TIME_OF_DAY) (Página 268)
Conversión explícita de TOD (Página 492)

412

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de LTOD
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
LTOD:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

LTOD

BOOL

-

-

Ninguna conversión implícita

BYTE

-

-

WORD

-

-

DWORD

-

-

LWORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión equivale
al número de nanosegundos desde el inicio del día (0:00 horas).
Ninguna conversión implícita

SINT

-

-

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

-

UDINT

-

-

LINT

-

X

ULINT

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión equivale
al número de nanosegundos desde el inicio del día (0:00 horas).

REAL

-

-

Ninguna conversión implícita

LREAL

-

-

TIME

-

-

LTIME

-

X

El patrón de bits del valor de origen se transfiere sin cambios al
tipo de datos de destino. El resultado de la conversión equivale
al número de nanosegundos desde el inicio del día (0:00 horas).

S5TIME

-

-

Ninguna conversión implícita

LDT

-

-

DT

-

-

DTL

-

-

DATE

-

-

TOD

-

X

El valor de origen se transfiere sin cambios, conservando su va‐
lor redondeado, al tipo de datos de destino. (De
12:34:56.123456789 se obtiene 12:34:56.123)

STRING

-

-

Ninguna conversión implícita

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

Programación del PLC
Manual de programación y manejo, 11/2019

413

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
Conversión explícita de LTOD (Página 494)
LTOD (LTIME_OF_DAY) (Página 269)

414

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

3.15.2.7

Cadenas de caracteres

Conversión implícita de CHAR
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
CHAR:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

CHAR

BOOL

-

-

Ninguna conversión implícita
El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino. El resto de los
bits se rellenan con "0" desde la izquierda.

BYTE

-

X

WORD

-

X

DWORD

-

X

LWORD

-

X

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

UDINT

-

X

LINT

-

X

ULINT

-

X

REAL

-

-

LREAL

-

-

TIME

-

-

LTIME

-

-

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

-

WCHAR

-

-

Ninguna conversión implícita

STRING

X

X

El STRING se acorta hasta la longitud 1 y contiene el carácter.

WSTRING

-

-

Ninguna conversión implícita

x: Conversión posible
-: Conversión no posible

Programación del PLC
Manual de programación y manejo, 11/2019

415

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
CHAR (Página 273)
Conversión explícita de CHAR (Página 497)

416

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de WCHAR
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
WCHAR:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

WCHAR

BOOL

-

-

Ninguna conversión implícita

BYTE

-

X

WORD

-

X

DWORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y
alineado a la derecha al tipo de datos de destino. El resto de los
bits se rellenan con "0" desde la izquierda.

LWORD

-

X

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

UDINT

-

X

LINT

-

X

ULINT

-

X

REAL

-

-

LREAL

-

-

TIME

-

-

LTIME

-

-

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

-

CHAR

-

-

STRING

-

-

WSTRING

X

X

Ninguna conversión implícita

El WSTRING se acorta hasta la longitud 1 y contiene el carácter.

x: Conversión posible
-: Conversión no posible

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)

Programación del PLC
Manual de programación y manejo, 11/2019

417

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
WCHAR (Página 273)
Conversión explícita de WCHAR (Página 499)

Conversión implícita de STRING
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
STRING:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

STRING

BOOL

-

-

Ninguna conversión implícita

BYTE

-

-

WORD

-

-

DWORD

-

-

LWORD

-

-

SINT

-

-

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

-

UDINT

-

-

LINT

-

-

ULINT

-

-

REAL

-

-

LREAL

-

-

TIME

-

-

LTIME

-

-

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

-

CHAR

-

X

Se devuelve el primer carácter del STRING si el STRING con‐
tiene uno o más caracteres. De lo contrario, el carácter se mues‐
tra con la codificación $00.

WCHAR

-

-

Ninguna conversión implícita

WSTRING

-

-

x: Conversión posible
-: Conversión no posible

418

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)
STRING (Página 274)
Conversión explícita de STRING (Página 501)

Programación del PLC
Manual de programación y manejo, 11/2019

419

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión implícita de WSTRING
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades para la conversión implícita del tipo de datos
WSTRING:
Origen

Destino

Con verifica‐
ción IEC

Sin verifica‐
ción IEC

Explicación

WSTRIN
G

BOOL

-

-

Ninguna conversión implícita

BYTE

-

-

WORD

-

-

DWORD

-

-

LWORD

-

-

SINT

-

-

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

-

UDINT

-

-

LINT

-

-

ULINT

-

-

REAL

-

-

LREAL

-

-

TIME

-

-

LTIME

-

-

S5TIME

-

-

LDT

-

-

DTL

-

-

DT

-

-

DATE

-

-

TOD

-

-

LTOD

-

-

CHAR

-

-

WCHAR

-

X

Se devuelve el primer carácter del WSTRING si el WSTRING
contiene uno o varios caracteres. De lo contrario, el carácter se
muestra con la codificación $0000.

STRING

-

-

Ninguna conversión implícita

x: Conversión posible
-: Conversión no posible

Consulte también
Activar o desactivar la verificación CEI (Página 368)
Sinopsis de la conversión de tipos de datos (Página 366)

420

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
WSTRING (Página 277)
Conversión explícita de WSTRING (Página 504)

Programación del PLC
Manual de programación y manejo, 11/2019

421

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

3.15.3

Conversiones explícitas

3.15.3.1

Números binarios

Conversión explícita de BOOL
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos BOOL y
las correspondientes instrucciones:
Origen

Destino

Conversión

Explicación

BOOL

BYTE

X

WORD

X

DWORD

X

LWORD

X

En el tipo de datos de destino sola‐ BOOL_TO_BYTE
mente se activa el LSB (Least Sig‐ BOOL_TO_WORD
nificant Bit). La salida de habilita‐
BOOL_TO_DWORD
ción ENO es siempre "1".
BOOL_TO_LWORD

SINT

X

BOOL_TO_SINT

USINT

X

BOOL_TO_USINT

INT

X

BOOL_TO_INT

UINT

X

BOOL_TO_UINT

DINT

X

BOOL_TO_DINT

UDINT

X

BOOL_TO_UDINT

LINT

X

BOOL_TO_LINT

ULINT

X

BOOL_TO_ULINT

REAL

-

Ninguna conversión explícita

Nemónicos de la instrucción

-

LREAL

-

-

TIME

-

-

LTIME

-

-

S5TIME

-

-

LDT

-

-

DT

-

-

DTL

-

-

TOD

-

-

LTOD

-

-

DATE

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
- : Conversión no posible

422

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Sinopsis de la conversión de tipos de datos (Página 366)
Conversión implícita de BOOL (Página 369)
BOOL (bit) (Página 245)

Programación del PLC
Manual de programación y manejo, 11/2019

423

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Secuencias de bits
Conversión explícita de BYTE
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos BYTE y
las correspondientes instrucciones:

424

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

BYTE

BOOL

X

Pueden darse las siguientes posibi‐ BYTE_TO_BOOL
lidades:

1)

Nemónicos de la instrucción

● Cuando el valor de origen es
"0", el tipo de datos de destino
también es "0" y la salida de
habilitación ENO es "1".
● Si en el valor de origen
solamente es "1" el LSB (Least
Significant Bit), el tipo de datos
de destino también es "1" y la
salida de habilitación ENO es
"1".
● Si en el valor de origen hay bits
distintos al LSB, el tipo de datos
de destino se ajustará según el
LSB y la salida de habilitación
ENO será "0".
El patrón de bits del valor de origen BYTE_TO_WORD
se transfiere sin cambios y alineado BYTE_TO_DWORD
a la derecha al tipo de datos de des‐
BYTE_TO_LWORD
tino.
BYTE_TO_SINT

WORD1)

X

DWORD1)

X

LWORD1)

X

SINT

X

USINT

X

BYTE_TO_USINT

INT

X

BYTE_TO_INT

UINT

X

BYTE_TO_UINT

DINT

X

BYTE_TO_DINT

UDINT

X

BYTE_TO_UDINT

LINT

X

BYTE_TO_LINT

ULINT

X

REAL

-

LREAL

-

TIME

X

LTIME

X

El patrón de bits del valor de origen BYTE_TO_TIME
se transfiere sin cambios y alineado BYTE_TO_LTIME
a la derecha al tipo de datos de des‐
tino.

S5TIME

-

Ninguna conversión explícita

LDT

X

El patrón de bits del valor de origen BYTE_TO_LDT
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino.
Ninguna conversión explícita

BYTE_TO_ULINT
Ninguna conversión explícita

-

-

DT

-

DTL

-

TOD

X

LTOD

X

DATE

X

El patrón de bits del valor de origen BYTE_TO_TOD
se transfiere sin cambios y alineado BYTE_TO_LTOD
a la derecha al tipo de datos de des‐
BYTE_TO_DATE
tino.

STRING

-

Ninguna conversión explícita

Programación del PLC
Manual de programación y manejo, 11/2019

-

-

425

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

WSTRING

-

CHAR

X

WCHAR

X

Explicación

Nemónicos de la instrucción
-

El patrón de bits del valor de origen BYTE_TO_CHAR
se transfiere sin cambios y alineado BYTE_TO_WCHAR
a la derecha al tipo de datos de des‐
tino.

x: conversión posible
- : conversión no posible
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) se interpretan como número entero sin signo con la misma
longitud de bits. El tipo de datos BYTE se interpreta en este caso como USINT; WORD, como UINT; DWORD, como UDINT
y LWORD, como ULINT.

1)

Consulte también
Sinopsis de la conversión de tipos de datos (Página 366)
Conversión implícita de BYTE (Página 370)
BYTE (Página 246)

426

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de WORD
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos WORD
y las correspondientes instrucciones:

Programación del PLC
Manual de programación y manejo, 11/2019

427

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen
WORD

1)

Destino

Conversión

Explicación

Nemónicos de la instrucción

BOOL

X

Pueden darse las siguientes posibilidades:

WORD_TO_BOOL

● Cuando el valor de origen es "0", el tipo
de datos de destino también es "0" y la
salida de habilitación ENO es "1".
● Si en el valor de origen solamente es "1"
el LSB (Least Significant Bit), el tipo de
datos de destino también es "1" y la
salida de habilitación ENO es "1".
● Si en el valor de origen hay bits distintos
al LSB, el tipo de datos de destino se
ajustará según el LSB y la salida de
habilitación ENO será "0".
BYTE1)
1)

X

LWORD1)

X

El patrón de bits del valor de origen se trans‐ WORD_TO_BYTE
fiere sin cambios y alineado a la derecha al WORD_TO_DWORD
tipo de datos de destino.
WORD_TO_LWORD

SINT

X

ENO = TRUE

DWORD

X

WORD_TO_SINT

#sint1 := WORD_TO_SINT(16#FFFF); // -1 a
#sint1 := WORD_TO_SINT(16#FF80); //
-128
#sint1 := WORD_TO_SINT(16#0); // 0 a
#sint1 := WORD_TO_SINT(16#007F); // 127
ENO = FALSE
#sint1 := WORD_TO_SINT(16#FF7F); //
-129 a
#sint1 := WORD_TO_SINT(16#8000); //
-32768
#sint1 := WORD_TO_SINT(16#0080); // 128
a
#sint1 := WORD_TO_SINT(16#7FFF); //
32767

428

USINT

X

INT

X

El patrón de bits del valor de origen se trans‐ WORD_TO_USINT
fiere sin cambios y alineado a la derecha al WORD_TO_INT
tipo de datos de destino.
WORD_TO_UINT

UINT

X

DINT

X

WORD_TO_DINT

UDINT

X

WORD_TO_UDINT

LINT

X

WORD_TO_LINT

ULINT

X

WORD_TO_ULINT

REAL

-

LREAL

-

TIME

X

LTIME

X

S5TIME

X

LDT

X

DT

-

DTL

-

Ninguna conversión explícita

-

El patrón de bits del valor de origen se trans‐ WORD_TO_TIME
fiere sin cambios y alineado a la derecha al WORD_TO_LTIME
tipo de datos de destino.
WORD_TO_S5TIME
WORD_TO_LDT
Ninguna conversión explícita

-

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

TOD

X

LTOD

X

DATE

X

El patrón de bits del valor de origen se trans‐ WORD_TO_TOD
fiere sin cambios y alineado a la derecha al WORD_TO_LTOD
tipo de datos de destino.
WORD_TO_DATE

Nemónicos de la instrucción

STRING

-

Ninguna conversión explícita

WSTRING

-

CHAR

X

WCHAR

X

WORD_
BCD16

INT

X

BCD16

INT

X

-

El patrón de bits del valor de origen se trans‐ WORD_TO_CHAR
fiere sin cambios y alineado a la derecha al WORD_TO_WCHAR
tipo de datos de destino.
El valor que debe convertirse tiene el tipo de WORD_BCD16_TO_INT
datos WORD y se aplica como valor codifi‐
cado en BCD entre -999 y +999. Tras la con‐ BCD16_TO_INT
versión, el resultado es un número entero
(representación binaria) del tipo INT. Se pro‐
duce una conversión auténtica. Si el patrón
de bits incluye una tétrada no válida, no se
dispara ningún error síncrono, sino que so‐
lamente se activa el bit de estado OV.

x: conversión posible
- : conversión no posible
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) se interpretan como número entero sin signo con la misma
longitud de bits. El tipo de datos BYTE se interpreta en este caso como USINT; WORD, como UINT; DWORD, como UDINT
y LWORD, como ULINT.

1)

Consulte también
Conversión implícita de WORD (Página 372)
Sinopsis de la conversión de tipos de datos (Página 366)
WORD (Página 247)

Programación del PLC
Manual de programación y manejo, 11/2019

429

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de DWORD
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos DWORD
y las correspondientes instrucciones:

430

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la
instrucción

DWORD1)

BOOL

X

Pueden darse las siguientes posibilidades:

DWORD_TO_BOO
L

● Cuando el valor de origen es "0", el tipo de
datos de destino también es "0" y la salida de
habilitación ENO es "1".
● Si en el valor de origen solamente es "1" el LSB
(Least Significant Bit), el tipo de datos de
destino también es "1" y la salida de habilitación
ENO es "1".
● Si en el valor de origen hay bits distintos al LSB,
el tipo de datos de destino se ajustará según el
LSB y la salida de habilitación ENO será "0".
BYTE1)

X

WORD1)

X

LWORD1)

X

SINT

X

El patrón de bits del valor de origen se transfiere sin DWORD_TO_BYT
cambios y alineado a la derecha al tipo de datos de E
destino.
DWORD_TO_WO
RD
DWORD_TO_LW
ORD
ENO = TRUE
#sint1 := DWORD_TO_SINT(16#FFFF_FFFF); //
-1 a
#sint1 := DWORD_TO_SINT(16#FFFF_FF80); //
-128
#sint1 := DWORD_TO_SINT(16#0); // 0 a
#sint1 := DWORD_TO_SINT(16#0000_007F); //
127

DWORD_TO_SIN
T

ENO = FALSE
#sint1 := DWORD_TO_SINT(16#FFFF_FF7F); //
-129
#sint1 := DWORD_TO_SINT(16#8000_0000); //
-2147483648
#sint1 := DWORD_TO_SINT(16#0000_0080); //
128 a
#sint1 := DWORD_TO_SINT(16#7FFF_FFFF); //
2147483647
USINT

X

El patrón de bits del valor de origen se transfiere sin
cambios y alineado a la derecha al tipo de datos de
destino.

DWORD_TO_USI
NT

INT

X

ENO = TRUE

DWORD_TO_INT

#int1 := DWORD_TO_INT(16#FFFF_FFFF); // -1 a
#int1 := DWORD_TO_INT(16#FFFF_8000); //
-32768
#int1 := DWORD_TO_INT(16#0); // 0 a
#int1 := DWORD_TO_INT(16#0000_7FFF); //
32767
ENO = FALSE

Programación del PLC
Manual de programación y manejo, 11/2019

431

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la
instrucción

#int1 := DWORD_TO_INT(16#FFFF_7FFF); //
-32769
#int1 := DWORD_TO_INT(16#8000_0000); //
-2147483648
#int1 := DWORD_TO_INT(16#8000); // 32768 a
#int1 := DWORD_TO_INT(16#7FFF_FFFF); //
2147483647

432

UINT

X

DINT

X

UDINT

X

LINT

X

DWORD_TO_LINT

ULINT

X

DWORD_TO_ULI
NT

REAL

X

DWORD_TO_REA
L

LREAL

-

Ninguna conversión explícita

TIME

X

LTIME

X

El patrón de bits del valor de origen se transfiere sin DWORD_TO_TI‐
cambios y alineado a la derecha al tipo de datos de ME
destino.
DWORD_TO_LTI‐
ME

S5TIME

-

Ninguna conversión explícita

-

LDT

X

El patrón de bits del valor de origen se transfiere sin
cambios y alineado a la derecha al tipo de datos de
destino.

DWORD_TO_LDT

DT

-

Ninguna conversión explícita

-

DTL

-

TOD

X

LTOD

X

DATE

X

STRING

-

WSTRING

-

CHAR

X

WCHAR

X

El patrón de bits del valor de origen se transfiere sin
cambios y alineado a la derecha al tipo de datos de
destino. Si no se producen errores durante la con‐
versión, el estado lógico de ENO = 1; si se produce
un error durante la ejecución, el estado lógico de
ENO = 0.

DWORD_TO_UIN
T
DWORD_TO_DIN
T
DWORD_TO_UDI
NT

-

El patrón de bits del valor de origen se transfiere sin DWORD_TO_TOD
cambios y alineado a la derecha al tipo de datos de DWORD_TO_LTO
destino.
D
DWORD_TO_DA‐
TE
Ninguna conversión explícita

-

El patrón de bits del valor de origen se transfiere sin DWORD_TO_CHA
cambios y alineado a la derecha al tipo de datos de R
destino.
DWORD_TO_WC
HAR

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la
instrucción

DWORD_BCD3
2

DINT

X

BCD32

DINT

X

El valor que debe convertirse tiene el tipo de datos DWORD_BCD32_
DWORD y se aplica como valor codificado en BCD TO_DINT
entre -9999999 y +9999999. Tras la conversión, el BCD32_TO_DINT
resultado es un número entero (representación bi‐
naria) del tipo DINT. Se produce una conversión
auténtica. Si el patrón de bits incluye una tétrada no
válida, no se dispara ningún error síncrono, sino
que solamente se activa el bit de estado OV.

x: conversión posible
- : conversión no posible
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) se interpretan como número entero sin signo con la misma
longitud de bits. El tipo de datos BYTE se interpreta en este caso como USINT; WORD, como UINT; DWORD, como UDINT
y LWORD, como ULINT.
1)

Consulte también
Conversión implícita de DWORD (Página 374)
Sinopsis de la conversión de tipos de datos (Página 366)
DWORD (Página 248)

Programación del PLC
Manual de programación y manejo, 11/2019

433

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de LWORD
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos LWORD
y las correspondientes instrucciones:

434

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conver‐
sión

Explicación

Nemónicos de la ins‐
trucción

LWORD1)

BOOL

X

Pueden darse las siguientes posibilidades:

LWORD_TO_BOOL

● Cuando el valor de origen es "0", el tipo de datos de
destino también es "0" y la salida de habilitación ENO es
"1".
● Si en el valor de origen solamente es "1" el LSB (Least
Significant Bit), el tipo de datos de destino también es "1"
y la salida de habilitación ENO es "1".
● Si en el valor de origen hay bits distintos al LSB, el tipo de
datos de destino se ajusta según el LSB y la salida de
habilitación ENO es "0".
BYTE1)

X

WORD1)

X

DWORD1)

X

SINT

X

El patrón de bits del valor de origen se transfiere sin cambios
y alineado a la derecha al tipo de datos de destino.

LWORD_TO_BYTE
LWORD_TO_WORD
LWORD_TO_DWOR
D

ENO = TRUE

LWORD_TO_SINT

#sint1 :=
LWORD_TO_SINT(16#FFFF_FFFF_FFFF_FFFF); // -1 a
#sint1 :=
LWORD_TO_SINT(16#FFFF_FFFF_FFFF_FF80); // -128
#sint1 := LWORD_TO_SINT(16#0); // 0 a
#sint1 := LWORD_TO_SINT(16#0000_0000_0000_007F); //
127
ENO = FALSE
#sint1 :=
LWORD_TO_SINT(16#FFFF_FFFF_FFFF_FF7F); // -129
#sint1 := LWORD_TO_SINT(16#8000_0000_0000_0000); //
-9223372036854775808
#sint1 := LWORD_TO_SINT(16#0000_0000_0000_0080); //
128
#sint1 :=
LWORD_TO_SINT(16#7FFF_FFFF_FFFF_FFFF); //
9223372036854775807
USINT

X

El patrón de bits del valor de origen se transfiere sin cambios
y alineado a la derecha al tipo de datos de destino.

LWORD_TO_USINT

INT

X

ENO = TRUE

LWORD_TO_INT

#int1 := LWORD_TO_INT(16#FFFF_FFFF_FFFF_FFFF); //
-1 a
#int1 := LWORD_TO_INT(16#FFFF_FFFF_FFFF_8000); //
-32768
#int1 := LWORD_TO_INT(16#0); // 0 a
#int1 := LWORD_TO_INT(16#0000_0000_0000_7FFF); //
32767
ENO = FALSE
#int1 := LWORD_TO_INT(16#FFFF_FFFF_FFFF_7FFF); //
-32769
#int1 := LWORD_TO_INT(16#8000_0000_0000_0000); //

Programación del PLC
Manual de programación y manejo, 11/2019

435

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conver‐
sión

Explicación

Nemónicos de la ins‐
trucción

-2147483648
#int1 := LWORD_TO_INT(16#0000_0000_0000_8000); //
32768 a
#int1 := LWORD_TO_INT(16#7FFF_FFFF_FFFF_FFFF); //
2147483647
UINT

X

El patrón de bits del valor de origen se transfiere sin cambios
y alineado a la derecha al tipo de datos de destino.

LWORD_TO_UINT

DINT

X

ENO = TRUE

LWORD_TO_DINT

#dint1 :=
LWORD_TO_DINT(16#FFFF_FFFF_FFFF_FFFF); // -1 a
#dint1 :=
LWORD_TO_DINT(16#FFFF_FFFF_8000_0000); //
-2147483648
#dint1 := LWORD_TO_DINT(16#0); // 0 a
#dint1 :=
LWORD_TO_DINT(16#0000_0000_7FFF_FFFF); //
2147483647
ENO = FALSE
#dint1 :=
LWORD_TO_DINT(16#FFFF_FFFF_7FFF_FFFF); //
-2147483649 a
#dint1 := LWORD_TO_DINT(16#8000_0000_0000_0000); //
-9223372036854775808
#dint1 := LWORD_TO_DINT(16#0000_0000_8000_0000); //
2147483648 a
#dint1 :=
LWORD_TO_DINT(16#7FFF_FFFF_FFFF_FFFF); //
9223372036854775807

436

UDINT

X

LINT

X

ULINT

X

REAL

-

Ninguna conversión explícita

-

LREAL

X

LWORD_TO_LREAL

TIME

X

LTIME

X

El patrón de bits del valor de origen se transfiere sin cambios
y alineado a la derecha al tipo de datos de destino. Si no se
producen errores durante la conversión, el estado lógico de
ENO = 1; si se produce un error durante la ejecución, el
estado lógico de ENO = 0.

S5TIME

-

Ninguna conversión explícita

-

LDT

X

El patrón de bits del valor de origen se transfiere sin cambios
y alineado a la derecha al tipo de datos de destino.

LWORD_TO_LDT

DT

-

Ninguna conversión explícita

-

DTL

-

TOD

X

LTOD

X

DATE

X

STRING

-

WSTRING

-

El patrón de bits del valor de origen se transfiere sin cambios
y alineado a la derecha al tipo de datos de destino.

LWORD_TO_UDINT
LWORD_TO_LINT
LWORD_TO_ULINT

LWORD_TO_TIME
LWORD_TO_LTIME

El patrón de bits del valor de origen se transfiere sin cambios
y alineado a la derecha al tipo de datos de destino.

LWORD_TO_TOD
LWORD_TO_LTOD
LWORD_TO_DATE

Ninguna conversión explícita

-

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conver‐
sión

Explicación

Nemónicos de la ins‐
trucción

CHAR

X

LWORD_TO_CHAR

WCHAR

X

El patrón de bits del valor de origen se transfiere sin cambios
y alineado a la derecha al tipo de datos de destino.

LWORD_TO_WCHAR

x: conversión posible
- : conversión no posible
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) se interpretan como número entero sin signo con la misma
longitud de bits. El tipo de datos BYTE se interpreta en este caso como USINT; WORD, como UINT; DWORD, como UDINT
y LWORD, como ULINT.

1)

Consulte también
Conversión implícita de LWORD (Página 376)
Sinopsis de la conversión de tipos de datos (Página 366)
LWORD (Página 250)

Programación del PLC
Manual de programación y manejo, 11/2019

437

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

3.15.3.2

Enteros

Conversión explícita de SINT
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos SINT y las
correspondientes instrucciones:

438

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

SINT

BOOL

X

Pueden darse las siguientes posibi‐ SINT_TO_BOOL
lidades:
● Cuando el valor de origen es
"0", el tipo de datos de destino
también es "0" y la salida de
habilitación ENO es "1".
● Si en el valor de origen
solamente es "1" el LSB (Least
Significant Bit), el tipo de datos
de destino también es "1" y la
salida de habilitación ENO es
"1".
● Si en el valor de origen hay bits
distintos al LSB, el tipo de datos
de destino se ajusta según el
LSB y la salida de habilitación
ENO es "0".

BYTE1)

X

WORD1)

X

DWORD

1)

X

LWORD

1)

X

USINT

X

INT

X

UINT

X

DINT

X

UDINT

X

El patrón de bits del valor de origen
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino. Si se convierte un valor nega‐
tivo a un tipo de datos sin signo, la
salida de habilitación ENO se pone
a "0".

SINT_TO_BYTE
SINT_TO_WORD
SINT_TO_DWORD
SINT_TO_LWORD

El patrón de bits del valor de origen
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF). Cuando se con‐
vierte un valor negativo en un tipo
de datos de destino sin signo, la sa‐
lida de habilitación ENO se pone a
"0".

SINT_TO_USINT

El valor se convierte al formato del
tipo de datos de destino. El valor
"-1", p. ej., con la instrucción "Con‐
vertir valor" (CONVERT) se trans‐
forma en el valor "-1.0".

SINT_TO_REAL, NORM_X

SINT_TO_INT
SINT_TO_UINT
SINT_TO_DINT
SINT_TO_UDINT

LINT

X

ULINT

X

REAL

X

LREAL

X

TIME

X

El valor se transfiere al tipo de da‐
tos de destino y se interpreta como
milisegundos.

SINT_TO_TIME

LTIME

X

El valor se transfiere al tipo de da‐
tos de destino y se interpreta como
nanosegundos.

SINT_TO_LTIME

S5TIME

-

Ninguna conversión explícita

-

LDT

X

El resultado se suministra en nano‐ SINT_TO_LDT
segundos desde 1970-1-1-0:0:0.0.

DT

-

Ninguna conversión explícita

DTL

-

Programación del PLC
Manual de programación y manejo, 11/2019

SINT_TO_LINT
SINT_TO_ULINT
SINT_TO_LREAL, NORM_X

-

439

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

TOD

X

El patrón de bits del valor de origen SINT_TO_TOD
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF). Cuando se con‐
vierte un valor negativo en un tipo
de datos de destino sin signo, la sa‐
lida de habilitación ENO se pone a
"0". (Interpretación en milisegun‐
dos desde 0:0)

Nemónicos de la instrucción

LTOD

X

El patrón de bits del valor de origen SINT_TO_LTOD
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF). Cuando se con‐
vierte un valor negativo en un tipo
de datos de destino sin signo, la sa‐
lida de habilitación ENO se pone a
"0". (Interpretación en nanosegun‐
dos desde 0:0)

DATE

X

El patrón de bits del valor de origen SINT_TO_DATE
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF). Cuando se con‐
vierte un valor negativo en un tipo
de datos de destino sin signo, la sa‐
lida de habilitación ENO se pone a
"0". (Interpretación en días desde
1990-1-1)

STRING

X

El valor se convierte en una cadena
de caracteres.

WSTRING

X

SINT_TO_WSTRING
● KOP / FUP / AWL:
los primeros caracteres de la
cadena se rellenan con
espacios. El número de
espacios varía en función de la
longitud del valor numérico.
Los valores numéricos positivos
se emiten sin signo.

SINT_TO_STRING, S_CONV,
VAL_STRG

● SCL:
no se insertan espacios.
La cadena de caracteres se
representa con un signo al
principio.
Si se rebasa la longitud de la cade‐
na de caracteres, la salida de habi‐
litación ENO se pone a "0".
CHAR1)
WCHAR

440

X
1)

X

El patrón de bits del valor de origen SINT_TO_CHAR
se transfiere al tipo de datos de des‐ SINT_TO_WCHAR
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

(16#FFFFFFFF). Cuando se con‐
vierte un valor negativo en un tipo
de datos de destino sin signo, la sa‐
lida de habilitación ENO se pone a
"0".
x: Conversión posible
- : Conversión no posible
1)
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado incluido el signo, y a continuación se copian los bits. La interpretación se decide en función del tipo
de origen.

Consulte también
Conversión implícita de SINT (Página 378)
Sinopsis de la conversión de tipos de datos (Página 366)
SINT (enteros de 8 bits) (Página 251)

Programación del PLC
Manual de programación y manejo, 11/2019

441

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de USINT
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos USINT y
las correspondientes instrucciones:

442

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

USINT

BOOL

X

Pueden darse las siguientes posibi‐ USINT_TO_BOOL
lidades:
● Cuando el valor de origen es
"0", el tipo de datos de destino
también es "0" y la salida de
habilitación ENO es "1".
● Si en el valor de origen
solamente es "1" el LSB (Least
Significant Bit), el tipo de datos
de destino también es "1" y la
salida de habilitación ENO es
"1".
● Si en el valor de origen hay bits
distintos al LSB, el tipo de datos
de destino se ajusta según el
LSB y la salida de habilitación
ENO es "0".

BYTE1)

X

WORD1)

X

DWORD1)

X

LWORD

X

1)

El patrón de bits del valor de origen USINT_TO_BYTE
se transfiere sin cambios y alineado USINT_TO_WORD
a la derecha al tipo de datos de des‐
USINT_TO_DWORD
tino.
USINT_TO_LWORD

SINT

X

El patrón de bits del valor de origen USINT_TO_SINT
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino. Si al convertir se cambia el sig‐
no, la salida de habilitación ENO se
pone a "0".

INT

X

UINT

X

El patrón de bits del valor de origen USINT_TO_INT
se transfiere al tipo de datos de des‐ USINT_TO_UINT
tino sin convertir.
USINT_TO_DINT

DINT

X

UDINT

X

USINT_TO_UDINT

LINT

X

USINT_TO_LINT

ULINT

X

USINT_TO_ULINT

REAL

X

LREAL

X

TIME

LTIME

El valor se convierte al formato del
tipo de datos de destino. El valor
"1", p. ej., con la instrucción "Con‐
vertir valor" (CONVERT) se trans‐
forma en el valor "1.0".

USINT_TO_REAL, NORM_X

X

El valor se transfiere al tipo de da‐
tos de destino y se interpreta como
milisegundos.

USINT_TO_TIME

X

El valor se transfiere al tipo de da‐
tos de destino y se interpreta como
nanosegundos.

USINT_TO_LTIME

-

USINT_TO_LREAL, NORM_X

S5TIME

-

Ninguna conversión explícita

LDT

X

El resultado se suministra en nano‐ USINT_TO_LDT
segundos desde 1970-1-1-0:0:0.0.

Programación del PLC
Manual de programación y manejo, 11/2019

443

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

DT

-

Ninguna conversión explícita

-

DTL

-

TOD

X

El patrón de bits del valor de origen USINT_TO_TOD
se transfiere al tipo de datos de des‐
tino sin convertir. (Interpretación en
milisegundos desde 0:0)

LTOD

X

El patrón de bits del valor de origen USINT_TO_LTOD
se transfiere al tipo de datos de des‐
tino sin convertir. (Interpretación en
nanosegundos desde 0:0)

DATE

X

El patrón de bits del valor de origen USINT_TO_DATE
se transfiere al tipo de datos de des‐
tino sin convertir. (Interpretación en
días desde 1990-1-1)

STRING

X

WSTRING

X

El valor se convierte en una cadena
de caracteres. Si se rebasa la lon‐
gitud de la cadena de caracteres, la
salida de habilitación ENO se pone
a "0".

CHAR1)

X

WCHAR1)

X

-

USINT_TO_STRING, S_CONV,
VAL_STRG
USINT_TO_WSTRING

El patrón de bits del valor de origen USINT_TO_CHAR
se transfiere al tipo de datos de des‐ USINT_TO_WCHAR
tino sin convertir.

x: Conversión posible
- : Conversión no posible
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado (el signo inexistente se sustituye por ceros), y a continuación se copian los bits. La interpretación se
decide en función del tipo de origen.
1)

Consulte también
Conversión implícita de USINT (Página 379)
Sinopsis de la conversión de tipos de datos (Página 366)
USINT (enteros de 8 bits) (Página 252)

444

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de INT
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos INT y las
correspondientes instrucciones:

Programación del PLC
Manual de programación y manejo, 11/2019

445

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

INT

BOOL

X

Pueden darse las siguientes posibili‐
dades:

INT_TO_BOOL

● Cuando el valor de origen es "0",
el tipo de datos de destino también
es "0" y la salida de habilitación
ENO es "1".
● Si en el valor de origen solamente
es "1" el LSB (Least Significant
Bit), el tipo de datos de destino
también es "1" y la salida de
habilitación ENO es "1".
● Si en el valor de origen hay bits
distintos al LSB, el tipo de datos de
destino se ajusta según el LSB y la
salida de habilitación ENO es "0".

446

BYTE1)

X

WORD1)

X

DWORD1)

X

LWORD

X

1)

El patrón de bits del valor de origen se
transfiere sin cambios y alineado a la
derecha al tipo de datos de destino. Si
se convierte un valor negativo a un ti‐
po de datos sin signo, la salida de ha‐
bilitación ENO se pone a "0".
El patrón de bits del valor de origen se
transfiere al tipo de datos de destino
sin convertir. (Del valor "-1" (16#FF)
se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte un
valor negativo a un tipo de datos sin
signo, la salida de habilitación ENO se
pone a "0".

INT_TO_BYTE
INT_TO_WORD
INT_TO_DWORD
INT_TO_LWORD
INT_TO_SINT

SINT

X

USINT

X

UINT

X

DINT

X

UDINT

X

LINT

X

ULINT

X

REAL

X

LREAL

X

TIME

X

El valor se transfiere al tipo de datos
de destino y se interpreta como mili‐
segundos.

LTIME

X

El valor se transfiere al tipo de datos INT_TO_LTIME
de destino y se interpreta como nano‐
segundos.

S5TIME

-

Ninguna conversión explícita

LDT

X

El resultado se suministra en nanose‐ INT_TO_LDT
gundos desde 1970-1-1-0:0:0.0.

DT

-

Ninguna conversión explícita

DTL

-

TOD

X

INT_TO_USINT
INT_TO_UINT
INT_TO_DINT
INT_TO_UDINT
INT_TO_LINT
INT_TO_ULINT

El valor se convierte al formato del tipo INT_TO_REAL, NORM_X
de datos de destino. El valor "-1", p.
INT_TO_LREAL, NORM_X
ej., con la instrucción "Convertir valor"
(CONVERT) se transforma en el valor
"-1.0".
INT_TO_TIME

-

-

El patrón de bits del valor de origen se
transfiere al tipo de datos de destino
sin convertir. (Del valor "-1" (16#FF)
se obtiene el valor "-1"

INT_TO_TOD

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

(16#FFFFFFFF)). Si se convierte un
valor negativo a un tipo de datos sin
signo, la salida de habilitación ENO se
pone a "0". (Interpretación en milise‐
gundos desde 0:0; verificación de lí‐
mite de 24 h)
LTOD

X

El patrón de bits del valor de origen se INT_TO_LTOD
transfiere al tipo de datos de destino
sin convertir. (Del valor "-1" (16#FF)
se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte un
valor negativo a un tipo de datos sin
signo, la salida de habilitación ENO se
pone a "0". (Interpretación en nanose‐
gundos desde 0:0; verificación de lí‐
mite de 24 h)

DATE

X

El patrón de bits del valor de origen se
transfiere al tipo de datos de destino
sin convertir. (Del valor "-1" (16#FF)
se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte un
valor negativo a un tipo de datos sin
signo, la salida de habilitación ENO se
pone a "0". (Interpretación en días
desde 1990-1-1; verificación de valor
negativo)

INT_TO_DATE

STRING

X

El valor se convierte en una cadena
de caracteres.

INT_TO_STRING, S_CONV,
VAL_STRG

WSTRING

X

● KOP / FUP / AWL:
los primeros caracteres de la
cadena se rellenan con espacios.
El número de espacios varía en
función de la longitud del valor
numérico.
Los valores numéricos positivos
se emiten sin signo.

INT_TO_WSTRING

● SCL:
no se insertan espacios.
La cadena de caracteres se
representa con un signo al
principio.
Si se rebasa la longitud de la cadena
de caracteres, la salida de habilitación
ENO se pone a "0".
CHAR1)

X

WCHAR1)

X

Programación del PLC
Manual de programación y manejo, 11/2019

El patrón de bits del valor de origen se
transfiere al tipo de datos de destino
sin convertir. (Del valor "-1" (16#FF)
se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte un
valor negativo a un tipo de datos sin
signo, la salida de habilitación ENO se
pone a "0".

INT_TO_CHAR
INT_TO_WCHAR

447

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

BCD16

X

El valor que debe convertirse tiene el INT_TO_BCD16
tipo INT y se aplica como número en‐ INT_TO_BCD16_WORD
tero con un valor entre -999 y +999.
Tras la conversión, el resultado es un
número codificado en BCD del tipo
WORD. Se produce una conversión
auténtica. Si el valor está fuera del
rango de destino, no se dispara nin‐
gún error síncrono, sino que solamen‐
te se activa el bit de estado OV.

BCD16_WOR X
D

Nemónicos de la instrucción

x: Conversión posible
- : Conversión no posible
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado incluido el signo, y a continuación se copian los bits. La interpretación se decide en función del tipo
de origen.
1)

Consulte también
Conversión implícita de INT (Página 381)
Sinopsis de la conversión de tipos de datos (Página 366)
INT (enteros de 16 bits) (Página 253)

448

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de UINT
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos UINT y
las correspondientes instrucciones:

Programación del PLC
Manual de programación y manejo, 11/2019

449

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

UINT

BOOL

X

Pueden darse las siguientes posibi‐ UINT_TO_BOOL
lidades:
● Cuando el valor de origen es
"0", el tipo de datos de destino
también es "0" y la salida de
habilitación ENO es "1".
● Si en el valor de origen
solamente es "1" el LSB (Least
Significant Bit), el tipo de datos
de destino también es "1" y la
salida de habilitación ENO es
"1".
● Si en el valor de origen hay bits
distintos al LSB, el tipo de datos
de destino se ajustará según el
LSB y la salida de habilitación
ENO será "0".

BYTE1)

X

WORD1)

X

DWORD
LWORD
SINT

450

1)

X

1)

X
X

El patrón de bits del valor de origen
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino. Si en este proceso se pierden
bits, la salida de habilitación ENO
se pone a "0".

UINT_TO_BYTE
UINT_TO_WORD
UINT_TO_DWORD
UINT_TO_LWORD
UINT_TO_SINT

USINT

X

INT

X

El patrón de bits del valor de origen UINT_TO_INT
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino. Si al convertir se cambia el bit
de signo, la salida de habilitación
ENO se pone a "0".

UINT_TO_USINT

DINT

X

UDINT

X

LINT

X

ULINT

X

El patrón de bits del valor de origen UINT_TO_DINT
se transfiere sin cambios y alineado UINT_TO_UDINT
a la derecha al tipo de datos de des‐
UINT_TO_LINT
tino.
UINT_TO_ULINT

REAL

X

LREAL

X

TIME

LTIME

El valor se convierte al formato del
tipo de datos de destino. El valor
"1", p. ej., con la instrucción "Con‐
vertir valor" (CONVERT) se trans‐
forma en el valor "1.0".

UINT_TO_REAL, NORM_X

X

El valor se transfiere al tipo de da‐
tos de destino y se interpreta como
milisegundos.

UINT_TO_TIME

X

El valor se transfiere al tipo de da‐
tos de destino y se interpreta como
nanosegundos.

UINT_TO_LTIME

-

UINT_TO_LREAL, NORM_X

S5TIME

-

Ninguna conversión explícita

LDT

X

El resultado se suministra en nano‐ UINT_TO_LDT
segundos desde 1970-1-1-0:0:0.0.

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

DT

-

Ninguna conversión explícita

-

DTL

-

TOD

X

El patrón de bits del valor de origen UINT_TO_TOD
se transfiere al tipo de datos de des‐
tino sin convertir. (Interpretación en
milisegundos desde 0:0; verifica‐
ción de límite de 24 h)

LTOD

X

El patrón de bits del valor de origen UINT_TO_LTOD
se transfiere al tipo de datos de des‐
tino sin convertir. (Interpretación en
nanosegundos desde 0:0; verifica‐
ción de límite de 24 h)

DATE

X

El patrón de bits del valor de origen UINT_TO_DATE, T_CONV
se transfiere al tipo de datos de des‐
tino sin convertir. (Interpretación en
días desde 1990-1-1; verificación
de valor negativo)

STRING

X

WSTRING

X

El valor se convierte en una cadena
de caracteres. Si se rebasa la lon‐
gitud de la cadena de caracteres, la
salida de habilitación ENO se pone
a "0".

CHAR1)

X

WCHAR

1)

X

-

UINT_TO_STRING, S_CONV,
VAL_STRG
UINT_TO_WSTRING

El patrón de bits del valor de origen UINT_TO_CHAR
se transfiere sin cambios al tipo de UINT_TO_WCHAR
datos de destino. Si se produce un
desbordamiento, la salida de habili‐
tación ENO se pone a "0".

x: conversión posible
- : conversión no posible
1)
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado (el signo inexistente se sustituye por ceros), y a continuación se copian los bits. La interpretación se
decide en función del tipo de origen.

Consulte también
Conversión implícita de UINT (Página 382)
Sinopsis de la conversión de tipos de datos (Página 366)
UINT (enteros de 16 bits) (Página 254)

Programación del PLC
Manual de programación y manejo, 11/2019

451

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de DINT
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos DINT y
las correspondientes instrucciones:

452

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

DINT

BOOL

X

Pueden darse las siguientes posibi‐ DINT_TO_BOOL
lidades:
● Cuando el valor de origen es
"0", el tipo de datos de destino
también es "0" y la salida de
habilitación ENO es "1".
● Si en el valor de origen
solamente es "1" el LSB (Least
Significant Bit), el tipo de datos
de destino también es "1" y la
salida de habilitación ENO es
"1".
● Si en el valor de origen hay bits
distintos al LSB, el tipo de datos
de destino se ajustará según el
LSB y la salida de habilitación
ENO será "0".

BYTE1)

X

WORD1)

X

DWORD
LWORD

1)

X

1)

X

El patrón de bits del valor de origen
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino. Si se convierte un valor nega‐
tivo a un tipo de datos sin signo, la
salida de habilitación ENO se pone
a "0".

DINT_TO_BYTE

El patrón de bits del valor de origen
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte
un valor negativo a un tipo de datos
sin signo, la salida de habilitación
ENO se pone a "0".

DINT_TO_SINT

El valor se convierte al formato del
tipo de datos de destino. El valor
"-1", p. ej., con la instrucción "Con‐
vertir valor" (CONVERT) se trans‐
forma en el valor "-1.0".

DINT_TO_REAL, NORM_X

DINT_TO_WORD
DINT_TO_DWORD
DINT_TO_LWORD

SINT

X

USINT

X

INT

X

UINT

X

UDINT

X

LINT

X

ULINT

X

REAL

X

LREAL

X

TIME

X

El valor se transfiere al tipo de datos DINT_TO_TIME, T_CONV
de destino y se interpreta como mi‐
lisegundos.

LTIME

X

El valor se transfiere al tipo de datos DINT_TO_LTIME, T_CONV
de destino y se interpreta como na‐
nosegundos.

S5TIME

-

Ninguna conversión explícita

LDT

X

El resultado se suministra en nano‐ DINT_TO_LDT
segundos desde 1970-1-1-0:0:0.0.

DT

-

Ninguna conversión explícita

DTL

-

Programación del PLC
Manual de programación y manejo, 11/2019

DINT_TO_USINT
DINT_TO_INT
DINT_TO_UINT
DINT_TO_UDINT
DINT_TO_LINT
DINT_TO_ULINT
DINT_TO_LREAL, NORM_X

-

-

453

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

TOD

X

El patrón de bits del valor de origen DINT_TO_TOD
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte
un valor negativo a un tipo de datos
sin signo, la salida de habilitación
ENO se pone a "0". (Interpretación
en milisegundos desde 0:0)

Nemónicos de la instrucción

LTOD

X

El patrón de bits del valor de origen DINT_TO_LTOD
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte
un valor negativo a un tipo de datos
sin signo, la salida de habilitación
ENO se pone a "0". (Interpretación
en nanosegundos desde 0:0)

DATE

X

El patrón de bits del valor de origen DINT_TO_DATE
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte
un valor negativo a un tipo de datos
sin signo, la salida de habilitación
ENO se pone a "0". (Interpretación
en días desde 1990-1-1)

STRING

X

El valor se convierte en una cadena
de caracteres.

DINT_TO_STRING, S_CONV,
VAL_STRG

WSTRING

X

● KOP / FUP / AWL:
los primeros caracteres de la
cadena se rellenan con
espacios. El número de
espacios varía en función de la
longitud del valor numérico.
Los valores numéricos positivos
se emiten sin signo.

DINT_TO_WSTRING

● SCL:
no se insertan espacios.
La cadena de caracteres se
representa con un signo al
principio.
Si se rebasa la longitud de la cade‐
na de caracteres, la salida de habi‐
litación ENO se pone a "0".
CHAR1)
WCHAR

454

X
1)

X

El patrón de bits del valor de origen DINT_TO_CHAR
se transfiere al tipo de datos de des‐ DINT_TO_WCHAR
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte
un valor negativo a un tipo de datos

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

sin signo, la salida de habilitación
ENO se pone a "0".
BCD32

X

BCD32_DWO
RD

X

El valor que debe convertirse tiene DINT_TO_BCD32
el tipo DINT y se aplica como nú‐
DINT_TO_BCD32_DWORD
mero entero con un valor entre –
999999 y +9999999. Tras la con‐
versión, el resultado es un número
codificado en BCD del tipo
DWORD. Si se produce un desbor‐
damiento, la salida de habilitación
se pone a "0". Se produce una con‐
versión auténtica. Si el valor está
fuera del rango de destino, no se
dispara ningún error síncrono, sino
que solamente se activa el bit de
estado OV.

x: Conversión posible
- : Conversión no posible
1)
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado incluido el signo, y a continuación se copian los bits. La interpretación se decide en función del tipo
de origen.

Consulte también
Conversión implícita de DINT (Página 384)
Sinopsis de la conversión de tipos de datos (Página 366)
DINT (enteros de 32 bits) (Página 255)

Programación del PLC
Manual de programación y manejo, 11/2019

455

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de UDINT
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos UDINT y
las correspondientes instrucciones:

456

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

UDINT

BOOL

X

Pueden darse las siguientes posibi‐ UDINT_TO_BOOL
lidades:
● Cuando el valor de origen es
"0", el tipo de datos de destino
también es "0" y la salida de
habilitación ENO es "1".
● Si en el valor de origen
solamente es "1" el LSB (Least
Significant Bit), el tipo de datos
de destino también es "1" y la
salida de habilitación ENO es
"1".
● Si en el valor de origen hay bits
distintos al LSB, el tipo de datos
de destino se ajustará según el
LSB y la salida de habilitación
ENO será "0".

BYTE1)

X

WORD1)

X

DWORD
LWORD
SINT

1)

X

1)

X
X

El patrón de bits del valor de origen
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino. Si en este proceso se pierden
bits, la salida de habilitación ENO
se pone a "0".

UDINT_TO_BYTE
UDINT_TO_WORD
UDINT_TO_DWORD
UDINT_TO_LWORD
UDINT_TO_SINT

USINT

X

UDINT_TO_USINT

INT

X

UDINT_TO_INT

UINT

X

UDINT_TO_UINT

DINT

X

El patrón de bits del valor de origen UDINT_TO_DINT
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino. Si al convertir se cambia el bit
de signo, la salida de habilitación
ENO se pone a "0".

LINT

X

ULINT

X

El patrón de bits del valor de origen UDINT_TO_LINT
se transfiere sin cambios y alineado UDINT_TO_ULINT
a la derecha al tipo de datos de des‐
tino.

REAL

X

LREAL

X

TIME

El valor se convierte al formato del
tipo de datos de destino. El valor
"1", p. ej., con la instrucción "Con‐
vertir valor" (CONVERT) se trans‐
forma en el valor "1.0".

UDINT_TO_REAL, NORM_X

X

El valor se transfiere al tipo de da‐
tos de destino y se interpreta como
milisegundos.

UDINT_TO_TIME

LTIME

X

El valor se transfiere al tipo de da‐
tos de destino y se interpreta como
nanosegundos.

UDINT_TO_LTIME

S5TIME

-

Ninguna conversión explícita

-

Programación del PLC
Manual de programación y manejo, 11/2019

UDINT_TO_LREAL, NORM_X

457

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

LDT

X

El resultado se suministra en nano‐ UDINT_TO_LDT
segundos desde 1970-1-1-0:0:0.0.

Nemónicos de la instrucción

Ninguna conversión explícita

DT

-

DTL

-

TOD

X

El patrón de bits del valor de origen UDINT_TO_TOD, T_CONV
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte
un valor negativo a un tipo de datos
sin signo, la salida de habilitación
ENO se pone a "0". (Interpretación
en milisegundos desde 0:0; verifi‐
cación de límite de 24 h)

LTOD

X

El patrón de bits del valor de origen UDNT_TO_LTOD, T_CONV
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte
un valor negativo a un tipo de datos
sin signo, la salida de habilitación
ENO se pone a "0". (Interpretación
en nanosegundos desde 0:0; verifi‐
cación de límite de 24 h)

DATE

X

El patrón de bits del valor de origen UDINT_TO_DATE
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte
un valor negativo a un tipo de datos
sin signo, la salida de habilitación
ENO se pone a "0". (Interpretación
en días desde 1990-1-1; verifica‐
ción de valor negativo)

STRING

X

WSTRING

X

El valor se convierte en una cadena
de caracteres. Si se rebasa la lon‐
gitud de la cadena de caracteres, la
salida de habilitación ENO se pone
a "0".

CHAR1)

X

WCHAR1)

X

-

UDINT_TO_STRING, S_CONV,
VAL_STRG
UDINT_TO_WSTRING

El patrón de bits del valor de origen UDINT_TO_CHAR
se transfiere sin cambios al tipo de UDINT_TO_WCHAR
datos de destino. Si se produce un
desbordamiento, la salida de habili‐
tación ENO se pone a "0".

x: Conversión posible
- : Conversión no posible
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado (el signo inexistente se sustituye por ceros), y a continuación se copian los bits. La interpretación se
decide en función del tipo de origen.
1)

458

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Conversión implícita de UDINT (Página 386)
Sinopsis de la conversión de tipos de datos (Página 366)
UDINT (enteros de 32 bits) (Página 256)

Programación del PLC
Manual de programación y manejo, 11/2019

459

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de LINT
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos LINT y las
correspondientes instrucciones:

460

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

LINT

BOOL

X

Pueden darse las siguientes posibi‐ LINT_TO_BOOL
lidades:
● Cuando el valor de origen es
"0", el tipo de datos de destino
también es "0" y la salida de
habilitación ENO es "1".
● Si en el valor de origen
solamente es "1" el LSB (Least
Significant Bit), el tipo de datos
de destino también es "1" y la
salida de habilitación ENO es
"1".
● Si en el valor de origen hay bits
distintos al LSB, el tipo de datos
de destino se ajustará según el
LSB y la salida de habilitación
ENO será "0".

BYTE1)

X

WORD1)

X

DWORD
LWORD
SINT

1)

X

1)

X
X

El patrón de bits del valor de origen
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino. Si se convierte un valor nega‐
tivo a un tipo de datos sin signo, la
salida de habilitación ENO se pone
a "0".

LINT_TO_BYTE
LINT_TO_WORD
LINT_TO_DWORD
LINT_TO_LWORD
LINT_TO_SINT

USINT

X

INT

X

LINT_TO_USINT
LINT_TO_INT

UINT

X

LINT_TO_UINT

DINT

X

LINT_TO_DINT

UDINT

X

LINT_TO_UDINT

ULINT

X

REAL

X

LREAL

X

TIME

LINT_TO_ULINT
El valor se convierte al formato del
tipo de datos de destino. El valor
"-1", p. ej., con la instrucción "Con‐
vertir valor" (CONVERT) se trans‐
forma en el valor "-1.0".

LINT_TO_REAL, NORM_X

X

El valor se transfiere al tipo de da‐
tos de destino y se interpreta como
milisegundos.

LINT_TO_TIME, T_CONV

LTIME

X

El valor se transfiere al tipo de da‐
tos de destino y se interpreta como
nanosegundos.

LINT_TO_LTIME, T_CONV

S5TIME

-

Ninguna conversión explícita

-

LDT

X

El resultado se suministra en nano‐ LINT_TO_LDT
segundos desde 1970-1-1-0:0:0.0.
Ninguna conversión explícita

DT

-

DTL

-

TOD

X

Programación del PLC
Manual de programación y manejo, 11/2019

LINT_TO_LREAL, NORM_X

-

El patrón de bits del valor de origen LINT_TO_TOD
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"

461

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte
un valor negativo a un tipo de datos
sin signo, la salida de habilitación
ENO se pone a "0". (Interpretación
en milisegundos desde 0:0)
LTOD

X

El patrón de bits del valor de origen LINT_TO_LTOD
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte
un valor negativo a un tipo de datos
sin signo, la salida de habilitación
ENO se pone a "0". (Interpretación
en nanosegundos desde 0:0)

DATE

X

El patrón de bits del valor de origen LINT_TO_DATE
se transfiere al tipo de datos de des‐
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte
un valor negativo a un tipo de datos
sin signo, la salida de habilitación
ENO se pone a "0". (Interpretación
en días desde 1990-1-1)

STRING

X

El valor se convierte en una cadena
de caracteres.

WSTRING

X

LINT_TO_WSTRING
● KOP / FUP / AWL:
los primeros caracteres de la
cadena se rellenan con
espacios. El número de
espacios varía en función de la
longitud del valor numérico.
Los valores numéricos positivos
se emiten sin signo.

LINT_TO_STRING, S_CONV,
VAL_STRG

● SCL:
no se insertan espacios.
La cadena de caracteres se
representa con un signo al
principio.
Si se rebasa la longitud de la cade‐
na de caracteres, la salida de habi‐
litación ENO se pone a "0".
CHAR1)
WCHAR

462

X
1)

X

El patrón de bits del valor de origen LINT_TO_CHAR
se transfiere al tipo de datos de des‐ LINT_TO_WCHAR
tino sin convertir. (Del valor "-1"
(16#FF) se obtiene el valor "-1"
(16#FFFFFFFF)). Si se convierte
un valor negativo a un tipo de datos
sin signo, la salida de habilitación
ENO se pone a "0".

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

x: Conversión posible
- : Conversión no posible
1)
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado incluido el signo, y a continuación se copian los bits. La interpretación se decide en función del tipo
de origen.

Consulte también
Conversión implícita de LINT (Página 388)
Sinopsis de la conversión de tipos de datos (Página 366)
LINT (enteros de 64 bits) (Página 257)

Programación del PLC
Manual de programación y manejo, 11/2019

463

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de ULINT
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos ULINT y
las correspondientes instrucciones:

464

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

ULINT

BOOL

X

Pueden darse las siguientes posibi‐ ULINT_TO_BOOL
lidades:
● Cuando el valor de origen es
"0", el tipo de datos de destino
también es "0" y la salida de
habilitación ENO es "1".
● Si en el valor de origen
solamente es "1" el LSB (Least
Significant Bit), el tipo de datos
de destino también es "1" y la
salida de habilitación ENO es
"1".
● Si en el valor de origen hay bits
distintos al LSB, el tipo de datos
de destino se ajustará según el
LSB y la salida de habilitación
ENO será "0".

BYTE1)

X

WORD1)

X

DWORD1)

X

LWORD

X

SINT

1)

El patrón de bits del valor de origen ULINT_TO_BYTE
se transfiere sin cambios y alineado ULINT_TO_WORD
a la derecha al tipo de datos de des‐
ULINT_TO_DWORD
tino.
ULINT_TO_LWORD

X

ULINT_TO_SINT

USINT

X

ULINT_TO_USINT

INT

X

ULINT_TO_INT

UINT

X

ULINT_TO_UINT

DINT

X

El patrón de bits del valor de origen ULINT_TO_DINT
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino. Si al convertir se sobrescribe
el bit de signo, la salida de habilita‐
ción ENO se pone a "0".

UDINT

X

LINT

X

El patrón de bits del valor de origen ULINT_TO_UDINT
se transfiere sin cambios y alineado ULINT_TO_LINT
a la derecha al tipo de datos de des‐
tino.

REAL

X

LREAL

X

TIME

El valor se convierte al formato del
tipo de datos de destino. El valor
"1", p. ej., con la instrucción "Con‐
vertir valor" (CONVERT) se trans‐
forma en el valor "1.0".

ULINT_TO_REAL, NORM_X

X

El valor se transfiere al tipo de da‐
tos de destino y se interpreta como
milisegundos.

ULINT_TO_TIME

LTIME

X

El valor se transfiere al tipo de da‐
tos de destino y se interpreta como
nanosegundos.

ULINT_TO_LTIME

S5TIME

-

Ninguna conversión explícita

-

Programación del PLC
Manual de programación y manejo, 11/2019

ULINT_TO_LREAL, NORM_X

465

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

LDT

X

El resultado se suministra en nano‐ ULINT_TO_LDT
segundos desde 1970-1-1-0:0:0.0.

Nemónicos de la instrucción

Ninguna conversión explícita

DT

-

DTL

-

TOD

X

El patrón de bits del valor de origen ULINT_TO_TOD, T_CONV
se transfiere al tipo de datos de des‐
tino sin convertir. (Interpretación en
milisegundos desde 0:0)

LTOD

X

El patrón de bits del valor de origen ULINT_TO_LTOD, T_CONV
se transfiere al tipo de datos de des‐
tino sin convertir. (Interpretación en
nanosegundos desde 0:0)

DATE

X

El patrón de bits del valor de origen ULINT_TO_DATE
se transfiere al tipo de datos de des‐
tino sin convertir. (Interpretación en
días desde 1990-1-1)

STRING

X

WSTRING

X

El valor se convierte en una cadena
de caracteres. Si se rebasa la lon‐
gitud de la cadena de caracteres, la
salida de habilitación ENO se pone
a "0".

CHAR1)

X

WCHAR

1)

X

-

ULINT_TO_STRING, S_CONV,
VAL_STRG
ULINT_TO_WSTRING

El patrón de bits del valor de origen ULINT_TO_CHAR
se transfiere al tipo de datos de des‐ ULINT_TO_WCHAR
tino sin convertir.

x: Conversión posible
- : Conversión no posible
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado (el signo inexistente se sustituye por ceros), y a continuación se copian los bits. La interpretación se
decide en función del tipo de origen.
1)

Consulte también
Conversión implícita de ULINT (Página 390)
Sinopsis de la conversión de tipos de datos (Página 366)
ULINT (enteros de 64 bits) (Página 259)

466

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

3.15.3.3

Números en coma flotante

Conversión explícita de REAL
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos REAL y
las correspondientes instrucciones:

Programación del PLC
Manual de programación y manejo, 11/2019

467

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

REAL

BOOL

-

Ninguna conversión explícita

-

BYTE

-

-

WORD

-

-

DWORD

X

El patrón de bits del valor de origen REAL_TO_DWORD
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino.

LWORD

-

Ninguna conversión explícita

-

SINT

X

REAL_TO_SINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X

USINT

X

INT

X

UINT

X

El valor se convierte al tipo de datos
de destino. El resultado de la con‐
versión depende de la instrucción
utilizada. Si durante la conversión
se rebasa el rango permitido de va‐
lores del tipo de datos de destino o
el valor a convertir es un número en
coma flotante no válido, la salida de
habilitación ENO se pone a "0".

DINT

X

REAL_TO_DINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X

UDINT

X

REAL_TO_UDINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X

LINT

X

REAL_TO_LINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X

ULINT

X

REAL_TO_ULINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X

LREAL

X

El valor se convierte al tipo de datos
de destino. El resultado de la con‐
versión depende de la instrucción
utilizada, p. ej., TRUNC(2.5) = 2.0;
CEIL(2.5) = 3.0

TIME

-

Ninguna conversión explícita

LTIME

-

-

S5TIME

-

-

LDT

-

-

DT

-

-

DTL

-

-

TOD

-

-

LTOD

-

-

DATE

-

-

STRING

X

WSTRING

X

CHAR

-

468

REAL_TO_USINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X
REAL_TO_INT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X
REAL_TO_UINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X

REAL_TO_LREAL, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X

-

El valor se convierte en una cadena
de caracteres. Si se rebasa la lon‐
gitud de la cadena de caracteres o
el valor a convertir es un número en
coma flotante no válido, la salida de
habilitación ENO se pone a "0". La
longitud mín. de la cadena de ca‐
racteres es de 14 caracteres.

REAL_TO_STRING, S_CONV,
VAL_STRG

Ninguna conversión explícita

-

REAL_TO_WSTRING

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

WCHAR

-

Explicación

Nemónicos de la instrucción

x: Conversión posible
- : Conversión no posible

Consulte también
Conversión implícita de REAL (Página 393)
Sinopsis de la conversión de tipos de datos (Página 366)
REAL (Página 261)

Programación del PLC
Manual de programación y manejo, 11/2019

469

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de LREAL
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos LREAL
y las correspondientes instrucciones:

470

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

LREAL

BOOL

-

Ninguna conversión explícita

-

BYTE

-

-

WORD

-

-

DWORD

-

-

LWORD

X

El patrón de bits del valor de origen LREAL_TO_LWORD
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino.

SINT

X

USINT

X

INT

X

UINT

X

El valor se convierte al tipo de datos
de destino. El resultado de la con‐
versión depende de la instrucción
utilizada. Si durante la conversión
se rebasa el rango permitido de va‐
lores del tipo de datos de destino o
el valor a convertir es un número en
coma flotante no válido, la salida de
habilitación ENO se pone a "0".

DINT

X

LREAL_TO_DINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X

UDINT

X

LREAL_TO_UDINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X

LINT

X

LREAL_TO_LINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X

ULINT

X

LREAL_TO_ULINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X

REAL

X

El valor se convierte al tipo de datos LREAL_TO_LREAL, ROUND, CEIL,
de destino. Si al convertir se rebasa FLOOR, TRUNC, NORM_X, SCALE_X
el rango de valores permitido o el
valor que se desea convertir es un
número en coma flotante no válido,
la salida de habilitación ENO se po‐
ne a "0". Se tolera la pérdida de
precisión.

TIME

-

Ninguna conversión explícita

LTIME

-

-

S5TIME

-

-

LDT

-

-

DT

-

-

DTL

-

-

TOD

-

-

LTOD

-

-

DATE

-

STRING

X

WSTRING

X

Programación del PLC
Manual de programación y manejo, 11/2019

LREAL_TO_SINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X
LREAL_TO_USINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X
LREAL_TO_INT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X
LREAL_TO_UINT, ROUND, CEIL,
FLOOR, TRUNC, NORM_X, SCALE_X

-

El valor se convierte en una cadena
de caracteres. Si se rebasa la lon‐
gitud de la cadena de caracteres o
el valor a convertir es un número en
coma flotante no válido, la salida de
habilitación ENO se pone a "0". La

LREAL_TO_STRING, S_CONV,
VAL_STRG
LREAL_TO_WSTRING

471

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

longitud mín. de la cadena de ca‐
racteres es de 21 caracteres.
CHAR

-

WCHAR

-

Ninguna conversión explícita

-

x: Conversión posible
- : Conversión no posible

Consulte también
Conversión implícita de LREAL (Página 395)
Sinopsis de la conversión de tipos de datos (Página 366)
LREAL (Página 262)

472

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

3.15.3.4

Tiempos

Conversión explícita de S5TIME
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos S5TIME
y las correspondientes instrucciones:
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

S5TIME

BOOL

-

Ninguna conversión explícita

-

BYTE

-

WORD1)

X

El patrón de bits del valor de origen S5TIME_TO_WORD
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino.

-

DWORD

-

Ninguna conversión explícita

LWORD

-

-

SINT

-

-

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

-

UDINT

-

-

LINT

-

-

ULINT

-

-

REAL

-

-

LREAL

-

TIME

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de s5t#10ms se
obtiene T#10ms)

S5TIME_TO_TIME

LTIME

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de s5t#10ms se
obtiene LTIME#10ms)

S5TIME_TO_LTIME

Ninguna conversión explícita

-

-

LDT

-

DT

-

-

DTL

-

-

TOD

-

-

LTOD

-

-

DATE

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

Programación del PLC
Manual de programación y manejo, 11/2019

-

473

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

x: Conversión posible
- : Conversión no posible
1)
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado, y a continuación se copian los bits. La interpretación se decide en función del tipo de origen.

Consulte también
Conversión implícita de S5TIME (Página 397)
Sinopsis de la conversión de tipos de datos (Página 366)
S5TIME (tiempo) (Página 265)

474

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de TIME
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos TIME y
las correspondientes instrucciones:

Programación del PLC
Manual de programación y manejo, 11/2019

475

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

TIME

BOOL

-

Ninguna conversión explícita

-

BYTE

X

WORD1)

X

El patrón de bits del valor de origen TIME_TO_BYTE
se transfiere sin cambios y alineado TIME_TO_WORD
a la derecha al tipo de datos de des‐
TIME_TO_DWORD
tino.
TIME_TO_LWORD

1)

DWORD1)

X

LWORD

X

1)

SINT

476

X

El patrón de bits del valor de origen
se transfiere sin cambios y alineado
a la derecha, interpretado como mi‐
lisegundos, al tipo de datos de des‐
tino.

TIME_TO_SINT

USINT

X

INT

X

TIME_TO_USINT

UINT

X

DINT

X

El patrón de bits del valor de origen TIME_TO_DINT, T_CONV
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino. El resultado de la conversión
muestra el tiempo en milisegundos.

UDINT

X

LINT

X

ULINT

X

El patrón de bits del valor de origen TIME_TO_UDINT
se transfiere sin cambios y alineado TIME_TO_LINT
a la derecha, interpretado como mi‐
lisegundos, al tipo de datos de des‐ TIME_TO_ULINT
tino. El cambio de signo da lugar a
que la salida de habilitación ENO
sea "0".

REAL

-

Ninguna conversión explícita

LREAL

-

S5TIME

X

TIME_TO_TIME
Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de T#10ms se ob‐
tiene s5t#10ms)

LTIME

X

TIME_TO_LTIME
Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de T#10ms se ob‐
tiene LTIME#10ms)

LDT

-

Ninguna conversión explícita

DT

-

-

DTL

-

-

TOD

X

El patrón de bits del valor de origen TIME_TO_TOD
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino. Si el valor de origen está fuera
del rango de valores de TOD, el tipo
de datos de destino no se cambia.

LTOD

-

Ninguna conversión explícita

DATE

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

TIME_TO_INT
TIME_TO_UINT

-

-

-

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

x: Conversión posible
- : Conversión no posible
1)
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado, y a continuación se copian los bits. La interpretación se decide en función del tipo de origen.

Consulte también
Conversión implícita de TIME (Página 399)
Sinopsis de la conversión de tipos de datos (Página 366)
TIME (tiempo IEC) (Página 266)

Programación del PLC
Manual de programación y manejo, 11/2019

477

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de LTIME
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos LTIME y
las correspondientes instrucciones:

478

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

LTIME

BOOL

-

Ninguna conversión explícita

-

X

El patrón de bits del valor de origen LTIME_TO_BYTE
se transfiere sin cambios y alineado LTIME_TO_WORD
a la derecha al tipo de datos de des‐
LTIME_TO_DWORD
tino.
LTIME_TO_LWORD

BYTE

1)

WORD1)

X

DWORD1)

X

LWORD

X

1)

SINT

X

USINT

X

INT

X

UINT

X

DINT

X

UDINT

X

El patrón de bits del valor de origen
se transfiere sin cambios y alineado
a la derecha, interpretado como na‐
nosegundos, al tipo de datos de
destino. El cambio de signo da lu‐
gar a que la salida de habilitación
ENO sea "0".

LTIME_TO_SINT
LTIME_TO_USINT
LTIME_TO_INT
LTIME_TO_UINT
LTIME_TO_DINT
LTIME_TO_UDINT

LINT

X

LTIME_TO_LINT, T_CONV

ULINT

X

LTIME_TO_ULINT

REAL

-

LREAL

-

Ninguna conversión explícita

-

S5TIME

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de LTIME#10ms
se obtiene s5t#10ms)

LTIME_TO_S5TIME

TIME

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de LTIMET#10ms
se obtiene T#10ms)

LTIME_TO_TIME

LDT

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de LTIMET#10ms
se obtiene
LDT#1970-1-1-0:0:0.010000000)

LTIME_TO_LDT

DT

-

Ninguna conversión explícita

-

DTL

-

-

TOD

-

-

LTOD

X

El patrón de bits del valor de origen LTIME_TO_LTOD
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino. Si el valor de origen está fuera
del rango de valores de LTOD, el
tipo de datos de destino no se cam‐
bia.

DATE

-

Ninguna conversión explícita

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

Programación del PLC
Manual de programación y manejo, 11/2019

479

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

x: Conversión posible
- : Conversión no posible
1)
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado, y a continuación se copian los bits. La interpretación se decide en función del tipo de origen.

Consulte también
Conversión implícita de LTIME (Página 401)
Sinopsis de la conversión de tipos de datos (Página 366)
LTIME (temporizador CEI) (Página 267)

480

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

3.15.3.5

Fecha y hora

Conversión explícita de DT
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos DT y las
correspondientes instrucciones:

Programación del PLC
Manual de programación y manejo, 11/2019

481

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

DT

BOOL

-

Ninguna conversión explícita

-

BYTE

-

-

WORD

-

-

DWORD

-

-

LWORD

-

-

SINT

-

-

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

-

UDINT

-

-

LINT

-

-

ULINT

-

-

REAL

-

-

LREAL

-

-

S5TIME

-

-

TIME

-

-

LTIME

-

-

LDT

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de
DT#1990-1-2-0:0:1.0 se obtiene
LDT#1990-1-2-0:0:1.0)

DT_TO_LDT

DTL

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de
DT#1990-1-2-0:0:1.0 se obtiene
DTL#1990-1-2-0:0:1.0)

DT_TO_DTL

TOD

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de
DT#1990-1-2-0:0:1.0 se obtiene
TOD#1990-1-2-0:0:1.0)

DT_TO_TOD

LTOD

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de
DT#1990-1-2-0:0:1.0 se obtiene
LTOD#1990-1-2-0:0:1.0)

DT_TO_LTOD

DATE

X

El patrón de bits del valor de origen DT_TO_DATE
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino.

STRING

-

Ninguna conversión explícita

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

482

-

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

x: conversión posible
- : conversión no posible

Consulte también
Conversión implícita de DT (Página 403)
Sinopsis de la conversión de tipos de datos (Página 366)
DT (DATE_AND_TIME) (Página 269)

Programación del PLC
Manual de programación y manejo, 11/2019

483

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de LDT
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos LDT y las
correspondientes instrucciones:

484

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

LDT

BOOL

-

Ninguna conversión explícita

-

X

El patrón de bits del valor de origen LDT_TO_BYTE
se transfiere sin cambios y alineado LDT_TO_WORD
a la derecha al tipo de datos de des‐
LDT_TO_DWORD
tino.
LDT_TO_LWORD

BYTE

1)

WORD1)

X

DWORD1)

X

LWORD

X

1)

SINT

X

LDT_TO_SINT

USINT

X

LDT_TO_USINT

INT

X

LDT_TO_INT

UINT

X

LDT_TO_UINT

DINT

X

LDT_TO_DINT

UDINT

X

LDT_TO_UDINT

LINT

X

LDT_TO_LINT

ULINT

X

LDT_TO_ULINT

REAL

-

LREAL

-

-

S5TIME

-

-

TIME

-

LTIME

X

El patrón de bits del valor de origen LDT_TO_LTIME
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino.

DT

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de
LDT#1990-1-2-0:0:1.0 se obtiene
DT#1990-1-2-0:0:1.0)

LDT_TO_DT

DTL

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de
LDT#1990-1-2-0:0:1.0 se obtiene
DTL#1990-1-2-0:0:1.0)

LDT_TO_DTL

TOD

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de
LDT#1990-1-2-0:0:1.0 se obtiene
TOD#1990-1-2-0:0:1.0)

LDT_TO_TOD

LTOD

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de
LDT#1990-1-2-0:0:1.0 se obtiene
LTOD#1990-1-2-0:0:1.0)

LDT_TO_LTOD

DATE

X

El patrón de bits del valor de origen LDT_TO_DATE
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino.

STRING

-

Ninguna conversión explícita

WSTRING

-

Programación del PLC
Manual de programación y manejo, 11/2019

Ninguna conversión explícita

-

-

-

485

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

CHAR

-

Explicación

Nemónicos de la instrucción
-

WCHAR

-

-

x: Conversión posible
- : Conversión no posible
1)
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado, y a continuación se copian los bits. La interpretación se decide en función del tipo de origen.

Consulte también
Conversión implícita de LDT (Página 405)
Sinopsis de la conversión de tipos de datos (Página 366)
LDT (DATE_AND_LTIME) (Página 271)

486

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de DTL
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos DTL y las
correspondientes instrucciones:

Programación del PLC
Manual de programación y manejo, 11/2019

487

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

DTL

BOOL

-

Ninguna conversión explícita

-

BYTE

-

-

WORD

-

-

DWORD

-

-

LWORD

-

-

SINT

-

-

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

-

UDINT

-

-

LINT

-

-

ULINT

-

-

REAL

-

-

LREAL

-

-

S5TIME

-

-

TIME

-

-

LTIME

-

-

LDT

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de
DTL#1990-1-2-0:0:1.0 se obtiene
LDT#1990-1-2-0:0:1.0)

DTL_TO_LDT

DT

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de
DTL#1990-1-2-0:0:1.0 se obtiene
DT#1990-1-2-0:0:1.0)

DTL_TO_DT

TOD

X
X

Durante la conversión se extrae la
hora del día del formato DTL y se
escribe en el tipo de datos de des‐
tino.

DTL_TO_TOD, T_CONV

LTOD
DATE

X

Durante la conversión se extrae la DTL_TO_DATE, T_CONV
fecha del formato DTL y se escribe
en el tipo de datos de destino. Si se
produce un desbordamiento, la sa‐
lida de habilitación ENO se pone a
"0".

STRING

-

Ninguna conversión explícita

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

DTL_TO_LTOD

-

x: Conversión posible
- : Conversión no posible

488

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Conversión implícita de DTL (Página 407)
Sinopsis de la conversión de tipos de datos (Página 366)
DTL (Página 271)

Programación del PLC
Manual de programación y manejo, 11/2019

489

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de DATE
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos DATE y
las correspondientes instrucciones:
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

DATE

BOOL

-

Ninguna conversión explícita

-

BYTE 1)

X

WORD 1)

X

El patrón de bits del valor de origen DATE_TO_BYTE
se transfiere sin cambios y justifica‐ DATE_TO_WORD
do a la derecha al tipo de datos de
DATE_TO_DWORD
destino.
DATE_TO_LWORD

DWORD 1)

X

LWORD

X

1)

SINT

X

USINT

X

Como resultado se muestra el nú‐
mero de días desde el 1.1.1990.

DATE_TO_SINT

INT

X

DATE_TO_INT

UINT

X

DATE_TO_UINT

DINT

X

DATE_TO_DINT

UDINT

X

DATE_TO_UDINT

LINT

X

DATE_TO_LINT

ULINT

X

REAL

-

DATE_TO_USINT

DATE_TO_ULINT
Ninguna conversión explícita

-

LREAL

-

-

S5TIME

-

-

TIME

-

-

LTIME

-

DT

X

-

LDT

X

DTL 2)

X

TOD

-

LTOD

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

La conversión ajusta la fecha en el
tipo de destino.

DATE_TO_DT
DATE_TO_LDT
DATE_TO_DTL

Ninguna conversión explícita

-

x: Conversión posible
- : Conversión no posible
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado, y a continuación se copian los bits. La interpretación se decide en función del tipo de origen.

1)

El tipo de datos DTL se inicializa del siguiente modo: 1970-1-1-0:0:0. Una conversión de DATE_TO_DTL ajusta solo la parte
correspondiente del DTL. El resto del DTL permanece tal y como se inicializó. De ahí resultan las siguientes diferencias entre
las instrucciones "T_COMBINE" y "T_CONV":

2)

● T_COMBINE(D#2015-24-12, LTOD#12:13:14) devuelve DTL#2015-24-12-12:13:14
● myDTL := T_CONV(D#2015-24-12); myDTL := T_CONV(LTOD#12:13:14) da como resultado en myDTL =
DTL#1970-1-1-12:13:14

490

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Conversión implícita de DATE (Página 409)
Sinopsis de la conversión de tipos de datos (Página 366)
DATE (Página 268)

Programación del PLC
Manual de programación y manejo, 11/2019

491

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de TOD
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos TOD y las
correspondientes instrucciones:
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

TOD

BOOL

-

Ninguna conversión explícita

-

BYTE1)

X

El patrón de bits del valor de origen TOD_TO_BYTE
se transfiere sin cambios y alineado TOD_TO_WORD
a la derecha al tipo de datos de des‐
TOD_TO_DWORD
tino.
TOD_TO_LWORD

WORD1)

X

DWORD1)

X

LWORD1)

X

SINT

X

USINT

X

INT

X

UINT

X

TOD_TO_UINT

DINT

X

TOD_TO_DINT

UDINT

X

El resultado de la conversión equi‐ TOD_TO_UDINT, T_CONV
vale al número de milisegundos
desde el inicio del día (0:00 horas).

LINT

X

ULINT

X

El patrón de bits del valor de origen TOD_TO_LINT
se transfiere sin cambios y alineado TOD_TO_ULINT
a la derecha al tipo de datos de des‐
tino.

REAL

-

Ninguna conversión explícita

LREAL

-

S5TIME

-

TIME

X

Como resultado se muestra el nú‐
mero de milisegundos desde me‐
dianoche.

TOD_TO_SINT
TOD_TO_USINT
TOD_TO_INT

-

Como resultado se muestra el tiem‐ TOD_TO_TIME
po transcurrido desde medianoche.

LTIME

-

Ninguna conversión explícita

-

DT

X

TOD_TO_DT

LDT

X

La conversión ajusta la hora en el
tipo de datos de destino.

DTL

X

DATE

-

Ninguna conversión explícita

-

LTOD

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de TOD#1:0:0.0
se obtiene LTOD#1:0:0.0)

TOD_TO_LTOD

STRING

-

Ninguna conversión explícita

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

TOD_TO_LDT
TOD_TO_DTL

x: Conversión posible
- : Conversión no posible
1)
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado, y a continuación se copian los bits. La interpretación se decide en función del tipo de origen.

492

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Conversión implícita de TOD (Página 411)
Sinopsis de la conversión de tipos de datos (Página 366)
TOD (TIME_OF_DAY) (Página 268)

Programación del PLC
Manual de programación y manejo, 11/2019

493

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de LTOD
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos LTOD y
las correspondientes instrucciones:

494

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

LTOD

BOOL

-

Ninguna conversión explícita

-

X

El patrón de bits del valor de origen LTOD_TO_BYTE
se transfiere sin cambios y alineado LTOD_TO_WORD
a la derecha al tipo de datos de des‐
LTOD_TO_DWORD
tino.
LTOD_TO_LWORD

BYTE

1)

WORD1)

X

DWORD1)

X

LWORD

X

1)

SINT

X

Como resultado se muestra el nú‐ LTOD_TO_SINT
mero de nanosegundos desde me‐ LTOD_TO_USINT
dianoche.
LTOD_TO_INT

USINT

X

INT

X

UINT

X

LTOD_TO_UINT

DINT

X

LTOD_TO_DINT

UDINT

X

LTOD_TO_UDINT

LINT

X

LTOD_TO_LINT

ULINT

X

LTOD_TO_ULINT, T_CONV

REAL

-

LREAL

-

Ninguna conversión explícita

-

-

S5TIME

-

-

TIME

-

LTIME

X

El patrón de bits del valor de origen LTOD_TO_LTIME
se transfiere sin cambios y alineado
a la derecha al tipo de datos de des‐
tino.

DT

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de LTOD#1:0:0.0
se obtiene DT#1:0:0.0)

LTOD_TO_DT

LDT

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de LTOD#1:0:0.0
se obtiene LDT#1:0:0.0)

LTOD_TO_LDT

DTL

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de LTOD#1:0:0.0
se obtiene DTL#1:0:0.0)

LTOD_TO_DTL

DATE

-

Ninguna conversión explícita

-

TOD

X

Aquí se produce una conversión
del valor de origen al tipo de datos
de destino (p. ej., de LTOD#1:0:0.0
se obtiene TOD#1:0:0.0)

LTOD_TO_TOD

STRING

-

Ninguna conversión explícita

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

-

-

x: Conversión posible
- : Conversión no posible
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y los tipos de datos CHAR y WCHAR se amplían en primer lugar
hasta el ancho deseado, y a continuación se copian los bits. La interpretación se decide en función del tipo de origen.
1)

Programación del PLC
Manual de programación y manejo, 11/2019

495

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Conversión implícita de LTOD (Página 413)
Sinopsis de la conversión de tipos de datos (Página 366)
LTOD (LTIME_OF_DAY) (Página 269)

496

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

3.15.3.6

Cadenas de caracteres

Conversión explícita de CHAR
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos CHAR y
las correspondientes instrucciones:
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

CHAR

BOOL

-

Ninguna conversión explícita

-

BYTE

X

WORD1)

X

El patrón de bits del valor de origen CHAR_TO_BYTE
se transfiere sin cambios y alineado CHAR_TO_WORD
a la derecha al tipo de datos de des‐
CHAR_TO_DWORD
tino.
CHAR_TO_LWORD

1)

DWORD1)

X

LWORD

X

1)

SINT

X

CHAR_TO_SINT

USINT

X

CHAR_TO_USINT

INT

X

CHAR_TO_INT

UINT

X

CHAR_TO_UINT

DINT

X

CHAR_TO_DINT

UDINT

X

CHAR_TO_UDINT

LINT

X

CHAR_TO_LINT

ULINT

X

CHAR_TO_ULINT

REAL

-

LREAL

-

-

S5TIME

-

-

TIME

-

-

LTIME

-

-

DT

-

-

LDT

-

-

DTL

-

-

TOD

-

-

LTOD

-

-

DATE

-

STRING

X

CHAR_TO_STRING, S_CONV
El valor se convierte en el primer
carácter de la cadena de caracte‐
res (STRING). Si la longitud de la
cadena de caracteres no está defi‐
nida, se ajustará la longitud "1" tras
la conversión. Si la longitud de la
cadena de caracteres está definida,
esta no cambia tras la conversión.

WSTRING

-

Ninguna conversión explícita

WCHAR

X

Programación del PLC
Manual de programación y manejo, 11/2019

Ninguna conversión explícita

-

-

CHAR_TO_WCHAR

497

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

x: Conversión posible
- : Conversión no posible
1)
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y el tipo de datos WCHAR se amplían en primer lugar hasta el
ancho deseado, y a continuación se copian los bits. La interpretación se decide en función del tipo de origen.

Consulte también
Conversión implícita de CHAR (Página 415)
Sinopsis de la conversión de tipos de datos (Página 366)
CHAR (Página 273)

498

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de WCHAR
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos WCHAR
y las correspondientes instrucciones:
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

WCHAR

BOOL

-

Ninguna conversión explícita

-

BYTE1)

X

El patrón de bits del valor de origen WCHAR_TO_BYTE
se transfiere sin cambios y alineado WCHAR_TO_WORD
a la derecha al tipo de datos de des‐
WCHAR_TO_DWORD
tino.
WCHAR_TO_LWORD

WORD1)

X

DWORD1)

X

LWORD1)

X

SINT

X

WCHAR_TO_SINT

USINT

X

WCHAR_TO_USINT

INT

X

WCHAR_TO_INT

UINT

X

WCHAR_TO_UINT

DINT

X

WCHAR_TO_DINT

UDINT

X

WCHAR_TO_UDINT

LINT

X

WCHAR_TO_LINT

ULINT

X

REAL

-

LREAL

-

-

S5TIME

-

-

TIME

-

-

LTIME

-

-

DT

-

-

LDT

-

-

DTL

-

-

TOD

-

-

LTOD

-

-

DATE

-

-

STRING

-

WSTRING

X

CHAR

X

WCHAR_TO_ULINT
Ninguna conversión explícita

-

WCHAR_TO_WSTRING
El valor se convierte en el primer
carácter de la cadena de caracte‐
res (WSTRING). Si la longitud de la
cadena de caracteres no está defi‐
nida, se ajustará la longitud "1" tras
la conversión. Si la longitud de la
cadena de caracteres está definida,
esta no cambia tras la conversión.
WCHAR_TO_CHAR

x: Conversión posible
- : Conversión no posible
Las secuencias de bits (BYTE, WORD, DWORD, LWORD) y el tipo de datos CHAR se amplían en primer lugar hasta el
ancho deseado, y a continuación se copian los bits. La interpretación se decide en función del tipo de origen.

1)

Programación del PLC
Manual de programación y manejo, 11/2019

499

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Consulte también
Sinopsis de la conversión de tipos de datos (Página 366)
WCHAR (Página 273)
Conversión implícita de WCHAR (Página 417)

500

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de STRING
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos STRING
y las correspondientes instrucciones:

Programación del PLC
Manual de programación y manejo, 11/2019

501

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

STRING

BOOL

-

Ninguna conversión explícita

-

BYTE

-

-

WORD

-

-

DWORD

-

-

LWORD

-

SINT

X

USINT

X

INT

X

UINT

X

DINT

X

UDINT

X

LINT

X

ULINT

X

REAL

X

LREAL

X

S5TIME

-

TIME

-

-

LTIME

-

-

DT

-

-

LDT

-

-

DTL

-

-

TOD

-

-

LTOD

-

-

DATE

-

-

CHAR

X

El primer carácter de la cadena de STRING_TO_CHAR, S_CONV
caracteres (STRING) se transfiere
al tipo de datos de destino. Si la ca‐
dena de caracteres está vacía, se
escribirá el valor "0" en el tipo de
datos de destino.

WCHAR

-

Ninguna conversión explícita

WSTRING

X

502

La conversión comienza por el pri‐
mer carácter de la cadena de ca‐
racteres (STRING) y termina en el
fin de la cadena o bien en el primer
carácter no permitido. Los caracte‐
res siguientes están permitidos en
la conversión:
● Cifra
● Signo
● Punto
El primer carácter de la cadena de
caracteres puede ser un signo (+, -)
o una cifra. Se ignoran los espacios
iniciales. El punto actúa como se‐
parador en la conversión de núme‐
ros en coma flotante. La notación
exponencial "e" o "E" no está per‐
mitida. A la izquierda del punto de‐
cimal se permite usar comas para
separar los millares, ya que se ig‐
nora. Si la estructura de la cadena
de caracteres no es válida para la
conversión o se produce un desbor‐
damiento, la salida de habilitación
ENO se pone a "0".
Ninguna conversión explícita

STRING_TO_SINT, S_CONV,
STRG_VAL
STRING_TO_USINT, S_CONV,
STRG_VAL
STRING_TO_INT, S_CONV,
STRG_VAL
STRING_TO_UINT, S_CONV,
STRG_VAL
STRING_TO_DINT, S_CONV,
STRG_VAL
STRING_TO_UDINT, S_CONV,
STRG_VAL
STRING_TO_LINT, S_CONV,
STRG_VAL
STRING_TO_ULINT, S_CONV,
STRG_VAL
STRING_TO_REAL, S_CONV,
STRG_VAL
STRING_TO_LREAL, S_CONV,
STRG_VAL

-

STRING_TO_WSTRING

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

x: Conversión posible
- : Conversión no posible

Consulte también
Conversión implícita de STRING (Página 418)
Sinopsis de la conversión de tipos de datos (Página 366)
STRING (Página 274)

Programación del PLC
Manual de programación y manejo, 11/2019

503

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Conversión explícita de WSTRING
Posibilidades de conversión explícita
La tabla siguiente muestra las posibilidades de conversión explícita del tipo de datos
WSTRING y las correspondientes instrucciones:

504

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.15 Conversión de los tipos de datos en el S7-1500

Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

WSTRIN
G

BOOL

-

Ninguna conversión explícita

-

BYTE

-

-

WORD

-

-

DWORD

-

-

LWORD

-

SINT

X

USINT

X

INT

X

UINT

X

DINT

X

UDINT

X

LINT

X

ULINT

X

REAL

X

LREAL

X

S5TIME

-

TIME

-

-

LTIME

-

-

DT

-

-

LDT

-

-

DTL

-

-

TOD

-

-

LTOD

-

-

DATE

-

-

La conversión comienza por el pri‐
mer carácter de la cadena de ca‐
racteres (WSTRING) y termina en
el fin de la cadena o bien en el pri‐
mer carácter no permitido. Los ca‐
racteres siguientes están permiti‐
dos en la conversión:
● Cifra
● Signo
● Punto
El primer carácter de la cadena de
caracteres puede ser un signo (+, -)
o una cifra. Se ignoran los espacios
iniciales. El punto actúa como se‐
parador en la conversión de núme‐
ros en coma flotante. La notación
exponencial "e" o "E" no está per‐
mitida. A la izquierda del punto de‐
cimal se permite usar comas para
separar los millares, ya que se ig‐
nora. Si la estructura de la cadena
de caracteres no es válida para la
conversión o se produce un desbor‐
damiento, la salida de habilitación
ENO se pone a "0".
Ninguna conversión explícita

WSTRING_TO_SINT, S_CONV,
STRG_VAL
WSTRING_TO_USINT, S_CONV,
STRG_VAL
WSTRING_TO_INT, S_CONV,
STRG_VAL
WSTRING_TO_UINT, S_CONV,
STRG_VAL
WSTRING_TO_DINT, S_CONV,
STRG_VAL
WSTRING_TO_UDINT, S_CONV,
STRG_VAL
WSTRING_TO_LINT, S_CONV,
STRG_VAL
WSTRING_TO_ULINT, S_CONV,
STRG_VAL
WSTRING_TO_REAL, S_CONV,
STRG_VAL
WSTRING_TO_LREAL, S_CONV,
STRG_VAL

-

CHAR

-

WCHAR

X

El primer carácter de la cadena de WSTRING_TO_WCHAR
caracteres (WSTRING) se transfie‐
re al tipo de datos de destino. Si la
cadena de caracteres está vacía,
se escribirá el valor "0" en el tipo de
datos de destino.

STRING

X

WSTRING_TO_STRING

Programación del PLC
Manual de programación y manejo, 11/2019

-

505

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200
Origen

Destino

Conversión

Explicación

Nemónicos de la instrucción

x: Conversión posible
- : Conversión no posible

Consulte también
Sinopsis de la conversión de tipos de datos (Página 366)
WSTRING (Página 277)
Conversión implícita de WSTRING (Página 420)

3.16

Conversión de los tipos de datos en el S7-1200

3.16.1

Sinopsis de la conversión de tipos de datos

Introducción
Para combinar lógicamente varios operandos en una instrucción, es necesario verificar la
compatibilidad de los tipos de datos. Esto también es aplicable a las asignaciones, o a la
asignación de valores a los parámetros de bloque. Si los tipos de datos de los operandos son
diferentes, será preciso realizar una conversión.
La conversión puede realizarse de dos maneras, a saber:
● Conversión implícita
La conversión se realiza automáticamente al ejecutar la instrucción.
● Conversión explícita
Se utiliza una instrucción de conversión explícita antes de ejecutar la instrucción
propiamente dicha.
Nota
Las posibilidades descritas para convertir tipos de datos siempre toman como base la versión
más reciente de la CPU (V. 4). Es posible que algunas conversiones marcadas como posibles
no estén disponibles en las versiones 1 - 3 de la CPU.
Nota
Conversión de secuencias de bits en SCL
Todas las secuencias de bit (BYTE, WORD, DWORD y LWORD) incluidas en expresiones
reciben el mismo tratamiento que los enteros correspondientes sin signo (USINT, UINT y
UDINT). Por ello, p. ej., la conversión implícita de DWORD a REAL se lleva a cabo del mismo
modo que una conversión de UDINT a REAL.

506

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

Conversión implícita
La conversión implícita se realiza automáticamente si los tipos de datos de los operandos son
compatibles. La compatibilidad puede verificarse según criterios más o menos estrictos:
● Con verificación CEI (ajuste predeterminado)
Si está activada la verificación CEI, se aplican las siguientes reglas:
– La conversión implícita de BOOL a otros tipos de datos no es posible.
– Solo los tipos de datos REAL, BYTE, WORD, DINT, INT, SINT, UDINT, UINT, USINT,
TIME, DT, STRING, CHAR y WCHAR se pueden convertir de forma implícita.
– La longitud de bits del tipo de datos de origen no debe superar la longitud de bits del tipo
de datos de destino. El operando del tipo de datos WORD no puede indicarse, por
ejemplo, en un parámetro si en él se espera el tipo de datos BYTE.
● Sin verificación CEI
Si no está activada la verificación CEI, se aplican las siguientes reglas:
– La conversión implícita de BOOL a otros tipos de datos no es posible.
– Solo los tipos de datos REAL, LREAL, BYTE, WORD, DWORD, SINT, INT, DINT,
USINT, UINT, UDINT, TIME, DTL, TOD, DATE, STRING, CHAR y WCHAR se pueden
convertir de forma implícita.
– La longitud de bits del tipo de datos de origen no debe superar la longitud de bits del tipo
de datos de destino. El operando del tipo de datos DWORD no puede indicarse, por
ejemplo, en un parámetro si en él se espera el tipo de datos WORD.
– En los parámetros de entrada/salida (InOut) la longitud de bits de un operando indicado
debe coincidir con la longitud de bits programada para el parámetro correspondiente.
Nota
Conversión implícita sin verificación CEI
El editor de programación identifica los operandos que deben convertirse de forma implícita
con un rectángulo gris. Un rectángulo gris oscuro indica que es posible realizar una conversión
implícita sin pérdidas de precisión, p. ej., si el tipo de datos SINT se convierte a INT. Un
rectángulo gris claro indica que es posible realizar una conversión implícita, aunque pueden
producirse fallos en tiempo de ejecución. Si, por ejemplo, el tipo de datos DINT se convierte a
INT y se produce un desbordamiento, la salida de habilitación ENO se pone a "0".
Encontrará más información sobre el ajuste de la verificación CEI y la conversión implícita en
el apartado "Consulte también".

Conversión explícita
Si los operandos no son compatibles, por lo que no se puede realizar una conversión implícita,
es posible utilizar una instrucción de conversión explícita. Encontrará las instrucciones de
conversión en la Task Card "Instrucciones".

Programación del PLC
Manual de programación y manejo, 11/2019

507

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200
Un posible desbordamiento se indica en la salida de habilitación ENO. El desbordamiento se
produce cuando, p. ej., el valor del tipo de datos de origen es mayor que el del tipo de datos de
destino.
Nota
Mover patrones de bits
Si la conversión explícita consiste en mover un patrón de bits, la salida de habilitación ENO no
se activa.
Encontrará más información sobre la conversión explícita en "Consulte también".
La figura siguiente muestra un ejemplo en el que debe realizarse una conversión explícita de
tipos de datos:
%ORFNB'DWD
&219(57
',17WR,17

,1B',17

(1

(12

,1

287

%ORFN
(1
287B,17 287B,17

(12

,1B,17 287B%22/

El bloque de función "Bloque" espera en el parámetro de entrada "IN_INT" una variable del tipo
de datos INT. Por este motivo, el valor de la variable "IN_DINT" debe convertirse primero de
DINT a INT. Si el valor de la variable "IN_DINT" se encuentra dentro del rango de valores válido
del tipo de datos INT, se produce la conversión. En caso contrario, se notifica un
desbordamiento. No obstante, en caso de desbordamiento también tiene lugar una
conversión, pero los valores se cortan y la salida de habilitación ENO se pone a "0".

Consulte también
Activar o desactivar la verificación CEI (Página 508)
Conversiones implícitas (Página 508)
Conversiones explícitas (Página 529)

3.16.2

Conversiones implícitas

3.16.2.1

Activar o desactivar la verificación CEI
Se comprueba si los tipos de datos de los operandos utilizados son compatibles. La
compatibilidad puede verificarse según criterios más o menos estrictos. Si está activada la
"Verificación CEI para bloques lógicos", se aplican criterios más estrictos.
La verificación CEI se puede configurar de forma centralizada para todos los bloques nuevos
del proyecto, o bien para un bloque en particular.

508

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

Configurar la verificación CEI para bloques nuevos
Para configurar la verificación CEI para todos los bloques nuevos del proyecto, proceda del
siguiente modo:
1. Elija el comando "Configuración" del menú "Opciones".
Se abre la ventana "Configuración" en el área de trabajo.
2. Seleccione el grupo "Programación PLC > General" en la navegación local.
3. En el grupo "Ajuste predeterminado para bloques nuevos", active o desactive la casilla de
verificación "Verificación CEI para bloques lógicos".
La verificación CEI se activa o desactiva para todos los bloques nuevos del programa.

Configurar la verificación CEI para un bloque en particular
Para configurar la verificación CEI para un bloque en particular, proceda del siguiente modo:
1. Abra el bloque.
2. Abra la ficha "Propiedades" de la ventana de inspección.
3. Seleccione el grupo "Atributos" en la navegación local.
4. Active o desactive la casilla de verificación "Verificación CEI".
La verificación CEI se activa o desactiva para este bloque. El ajuste se guarda junto con el
proyecto.

3.16.2.2

Números binarios

Conversión implícita de BOOL
Posibilidades de conversión implícita
No es posible la conversión implícita del tipo de datos BOOL.

Consulte también
BOOL (bit) (Página 245)

Programación del PLC
Manual de programación y manejo, 11/2019

509

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

Secuencias de bits
Conversión implícita de BYTE
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades de conversión implícita del tipo de datos BYTE:
Origen

BYTE

Destino

Con

Sin

Verificación
CEI

Verificación
CEI

BOOL

-

-

Sin conversión implícita

WORD

x

x

DWORD

x

x

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

SINT

-

x

USINT

-

x

INT

-

x

UINT

-

x

DINT

-

x

UDINT

-

x

REAL

-

-

LREAL

-

-

TIME

-

-

DTL

-

-

TOD

-

-

DATE

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

x

WCHAR

-

x

Explicación

Sin conversión implícita

El patrón de bits del valor de origen se transfiere sin cambios al tipo
de datos de destino.

x: conversión posible
-: conversión no posible

Consulte también
BYTE (Página 246)
Activar o desactivar la verificación CEI (Página 508)
Sinopsis de la conversión de tipos de datos (Página 506)
Conversión explícita de BYTE (Página 530)

510

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

Conversión implícita de WORD
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades de conversión implícita del tipo de datos WORD:
Origen

WORD

Destino

Con

Sin

Verificación
CEI

Verificación
CEI

BOOL

-

-

Sin conversión implícita

BYTE

-

X

El byte menos significativo se transfiere al tipo de datos de destino,
y el byte más significativo se ignora.

DWORD

X

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

SINT

-

X

El byte menos significativo se transfiere al tipo de datos de destino,
y el byte más significativo se ignora.

USINT

-

X

INT

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

UINT

-

X

DINT

-

X

UDINT

-

X

REAL

-

-

LREAL

-

-

TIME

-

-

DTL

-

-

TOD

-

-

DATE

-

X

El patrón de bits del valor de origen se transfiere sin cambios al tipo
de datos de destino.

STRING

-

-

Sin conversión implícita

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

Explicación

Sin conversión implícita

El patrón de bits del valor de origen se transfiere sin cambios al tipo
de datos de destino.

x: Conversión posible
-: Conversión no posible

Consulte también
WORD (Página 247)
Activar o desactivar la verificación CEI (Página 508)
Sinopsis de la conversión de tipos de datos (Página 506)
Conversión explícita de WORD (Página 532)

Programación del PLC
Manual de programación y manejo, 11/2019

511

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

Conversión implícita de DWORD
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades de conversión implícita del tipo de datos DWORD:
Origen

DWORD

Destino

Con

Sin

Verificación
CEI

Verificación
CEI

Explicación

BOOL

-

-

Sin conversión implícita

BYTE

-

X

WORD

-

X

Los bytes derechos se transfieren al tipo de datos de destino, y los
bytes izquierdos se ignoran.

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

UDINT

-

X

REAL

-

X

El valor se convierte al formato del tipo de datos de destino. (El valor
"-1" se convierte en el valor "-1.0", por ejemplo.)

LREAL

-

-

Sin conversión implícita

TIME

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

DTL

-

-

Sin conversión implícita

TOD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

DATE

-

-

Sin conversión implícita

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

Consulte también
DWORD (Página 248)
Activar o desactivar la verificación CEI (Página 508)
Sinopsis de la conversión de tipos de datos (Página 506)
Conversión explícita de DWORD (Página 535)

512

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

3.16.2.3

Enteros

Conversión implícita de SINT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades de conversión implícita del tipo de datos SINT:
Origen

SINT

Destino

Con

Sin

Explicación

Verificación
CEI

Verificación
CEI

BOOL

-

-

Sin conversión implícita

BYTE

-

X

WORD

-

X

DWORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino. El resto de los bits
se rellenan con "0".

USINT

-

X

INT

X

X

El patrón de bits del valor de origen se convierte y se transfiere al tipo
de datos de destino. (Transferencia de valores de p. ej. SINT #-1 ->
INT #-1, no se rellena con "0".)

UINT

-

X

DINT

X

X

UDINT

-

X

REAL

X

X

LREAL

X

X

El valor se convierte al formato del tipo de datos de destino. (El valor
"-1" se convierte en el valor "-1.0", por ejemplo.)

TIME

-

-

Sin conversión implícita

DTL

-

-

TOD

-

-

DATE

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

Consulte también
SINT (enteros de 8 bits) (Página 251)
Activar o desactivar la verificación CEI (Página 508)
Sinopsis de la conversión de tipos de datos (Página 506)
Conversión explícita de SINT (Página 539)

Programación del PLC
Manual de programación y manejo, 11/2019

513

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

Conversión implícita de USINT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades de conversión implícita del tipo de datos USINT:
Origen

USINT

Destino

BOOL

Con

Sin

Verificación
CEI

Verificación
CEI

-

-

Sin conversión implícita
El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino. El resto de los bits
se rellenan con "0".

BYTE

-

X

WORD

-

X

DWORD

-

X

SINT

-

X

INT

X

X

UINT

X

X

DINT

X

X

UDINT

X

X

REAL

X

X

Explicación

El patrón de bits del valor de origen se convierte y se transfiere al tipo
de datos de destino. (Conversión de valores de p. ej. USINT #10 ->
DINT #10, o USINT #128 -> SINT #-128)

LREAL

X

X

El valor se convierte al formato del tipo de datos de destino. (El valor
"1" se convierte en el valor "1.0", por ejemplo.)

TIME

-

-

Sin conversión implícita

DTL

-

-

TOD

-

-

DATE

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

Consulte también
USINT (enteros de 8 bits) (Página 252)
Activar o desactivar la verificación CEI (Página 508)
Sinopsis de la conversión de tipos de datos (Página 506)
Conversión explícita de USINT (Página 542)

514

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

Conversión implícita de INT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades de conversión implícita del tipo de datos INT:
Origen

INT

Destino

Con

Sin

Verificación
CEI

Verificación
CEI

-

-

Sin conversión implícita

BYTE

-

X

WORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

DWORD

-

X

SINT

-

X

BOOL

USINT

-

X

UINT

-

X

DINT

X

X

UDINT

-

X

REAL

X

X

Explicación

El patrón de bits del valor de origen se convierte y se transfiere al tipo
de datos de destino. (Conversión de valores de p. ej. INT #-1 -> SINT
#-1, o INT #-32 767 -> UINT #32 769)

LREAL

X

X

El valor se convierte al formato del tipo de datos de destino. (El valor
"-1" se convierte en el valor "-1.0", por ejemplo.)

TIME

-

-

Sin conversión implícita

DTL

-

-

TOD

-

-

DATE

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

STRING

-

-

Sin conversión implícita

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

Consulte también
INT (enteros de 16 bits) (Página 253)
Activar o desactivar la verificación CEI (Página 508)
Sinopsis de la conversión de tipos de datos (Página 506)
Conversión explícita de INT (Página 545)

Programación del PLC
Manual de programación y manejo, 11/2019

515

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

Conversión implícita de UINT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades de conversión implícita del tipo de datos UINT:
Origen

UINT

Destino

Con

Sin

Verificación
CEI

Verificación
CEI

BOOL

-

-

Sin conversión implícita

BYTE

-

X

WORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

DWORD

-

X

SINT

-

X

USINT

-

X

INT

-

X

DINT

X

X

UDINT

X

X

REAL

X

X

Explicación

El patrón de bits del valor de origen se convierte y se transfiere al tipo
de datos de destino. (Conversión de valores de p. ej. UINT #100 ->
DINT #100, o UINT #60 000 -> INT #-5536)

LREAL

X

X

El valor se convierte al formato del tipo de datos de destino. (El valor
"1" se convierte en el valor "1.0", por ejemplo.)

TIME

-

-

Sin conversión implícita

DTL

-

-

TOD

-

-

DATE

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

STRING

-

-

Sin conversión implícita

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

Consulte también
UINT (enteros de 16 bits) (Página 254)
Activar o desactivar la verificación CEI (Página 508)
Sinopsis de la conversión de tipos de datos (Página 506)
Conversión explícita de UINT (Página 549)

516

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

Conversión implícita de DINT
Posibilidades de conversión implícita
La tabla siguiente muestra posibilidades de conversión implícita del tipo de datos DINT:
Origen

DINT

Destino

Con

Sin

Verificación
CEI

Verificación
CEI

-

-

Sin conversión implícita

BYTE

-

X

WORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

DWORD

-

X

SINT

-

X

BOOL

Explicación

El patrón de bits del valor de origen se convierte y se transfiere al tipo
de datos de destino. (Conversión de valores de p. ej. DINT #-1 ->
SINT #-1, o DINT #-1 -> USINT #255)

USINT

-

X

INT

-

X

UINT

-

X

UDINT

-

X

REAL

-

X

El patrón de bits del valor de origen se convierte y se transfiere al tipo
de datos de destino. (Conversión de valores de p. ej. DINT #-1 ->
REAL #-1.0, pero se da una pérdida de precisión en aquellos nú‐
meros cuyo valor absoluto es mayor que 8 388 608)

LREAL

X

X

El valor se convierte al formato del tipo de datos de destino. (El valor
"-1" se convierte en el valor "-1.0", por ejemplo.)

TIME

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

DTL

-

-

Sin conversión implícita

TOD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

DATE

-

-

Sin conversión implícita

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

Consulte también
DINT (enteros de 32 bits) (Página 255)
Activar o desactivar la verificación CEI (Página 508)
Sinopsis de la conversión de tipos de datos (Página 506)
Conversión explícita de DINT (Página 552)

Programación del PLC
Manual de programación y manejo, 11/2019

517

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

Conversión implícita de UDINT
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades de conversión implícita del tipo de datos UDINT:
Origen

UDINT

Destino

Con

Sin

Verificación
CEI

Verificación
CEI

Explicación

BOOL

-

-

Sin conversión implícita

BYTE

-

X

WORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

DWORD

-

X

SINT

-

X

El patrón de bits del valor de origen se convierte y se transfiere al tipo
de datos de destino. (Conversión de valores de p. ej. DINT #-1 ->
SINT #-1, o DINT #-1 -> USINT #255)

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

REAL

-

X

El patrón de bits del valor de origen se convierte y se transfiere al tipo
de datos de destino. (Conversión de valores de p. ej. DINT #-1 ->
REAL #-1.0, pero se da una pérdida de precisión en aquellos nú‐
meros cuyo valor absoluto es mayor que 8 388 608)

LREAL

X

X

El valor se convierte al formato del tipo de datos de destino. (El valor
"1" se convierte en el valor "1.0", por ejemplo.)

TIME

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

DTL

-

-

Sin conversión implícita

TOD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

DATE

-

-

Sin conversión implícita

STRING

-

-

WSTRING

-

-

CHAR

-

X

WCHAR

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.

x: Conversión posible
-: Conversión no posible

Consulte también
UDINT (enteros de 32 bits) (Página 256)
Activar o desactivar la verificación CEI (Página 508)
Sinopsis de la conversión de tipos de datos (Página 506)
Conversión explícita de UDINT (Página 556)

518

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

3.16.2.4

Números en coma flotante

Conversión implícita de REAL
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades de conversión implícita del tipo de datos REAL:
Origen

REAL

Destino

Con

Sin

Explicación

Verificación
CEI

Verificación
CEI

BOOL

-

-

BYTE

-

-

WORD

-

-

DWORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios y jus‐
tificado a la derecha al tipo de datos de destino.
El patrón de bits del valor de origen se redondea, se convierte y se
transfiere al tipo de datos de destino. (Redondeo y conversión de
valores de p. ej. REAL #2.5 -> INT #2, o números negativos REAL
#-2.5 -> INT #-2 -> USINT #254. En caso de desbordamiento se
determina el resto REAL #305.5 -> INT #306 -> USINT #50)

Sin conversión implícita

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

UDINT

-

X

LREAL

X

X

El valor se transfiere al tipo de datos de destino.

TIME

-

-

Sin conversión implícita

DTL

-

-

TOD

-

-

DATE

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

Consulte también
REAL (Página 261)
Activar o desactivar la verificación CEI (Página 508)
Sinopsis de la conversión de tipos de datos (Página 506)
Conversión explícita de REAL (Página 559)

Programación del PLC
Manual de programación y manejo, 11/2019

519

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

Conversión implícita de LREAL
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades de conversión implícita del tipo de datos LREAL:
Origen

LREAL

Destino

Con

Sin

Verificación
CEI

Verificación
CEI

BOOL

-

-

BYTE

-

-

WORD

-

-

DWORD

-

-

SINT

-

X

USINT

-

X

INT

-

X

UINT

-

X

DINT

-

X

UDINT

-

X

REAL

-

-

TIME

-

-

DTL

-

-

TOD

-

-

DATE

-

-

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

Explicación

Sin conversión implícita

El patrón de bits del valor de origen se redondea, se convierte y se
transfiere al tipo de datos de destino. (Redondeo y conversión de
valores de p. ej. REAL #2.5 -> INT #2, o números negativos REAL
#-2.5 -> INT #-2 -> USINT #254. En caso de desbordamiento se
determina el resto REAL #305.5 -> INT #306 -> USINT #50)

Sin conversión implícita

x: Conversión posible
-: Conversión no posible

Consulte también
Conversión explícita de LREAL (Página 562)

520

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

3.16.2.5

Temporizadores

Conversión implícita de TIME
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades de conversión implícita del tipo de datos TIME:
Origen

TIME

Destino

Con

Sin

Explicación

Verificación
CEI

Verificación
CEI

BOOL

-

-

BYTE

-

-

WORD

-

-

DWORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios al tipo
de datos de destino. El resultado de la conversión muestra el tiempo
en milisegundos.

SINT

-

-

Sin conversión implícita

Sin conversión implícita

USINT

-

-

INT

-

-

UINT

-

-

DINT

-

X

UDINT

-

X

El patrón de bits del valor de origen se transfiere sin cambios al tipo
de datos de destino. El resultado de la conversión muestra el tiempo
en milisegundos.

REAL

-

-

Sin conversión implícita

LREAL

-

-

DTL

-

-

TOD

-

X

Si el valor de origen es inferior a 24 horas (86 400 00 ms), el patrón
de bits del valor de origen se transfiere sin cambios al tipo de datos
de destino. En cualquier otro caso, el valor de destino no se modifica.
El resultado de la conversión muestra el tiempo transcurrido desde
medianoche.

DATE

-

-

Sin conversión implícita

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

Consulte también
TIME (tiempo IEC) (Página 266)
Activar o desactivar la verificación CEI (Página 508)

Programación del PLC
Manual de programación y manejo, 11/2019

521

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200
Sinopsis de la conversión de tipos de datos (Página 506)
Conversión explícita de TIME (Página 565)

3.16.2.6

Fecha y hora

Conversión implícita de DATE
Posibilidades de conversión implícita
La tabla siguiente muestra las posibilidades de conversión implícita del tipo de datos DATE:
Origen

DATE

Destino

Con

Sin

Verificación
CEI

Verificación
CEI

BOOL

-

-

Explicación

Sin conversión implícita

BYTE

-

-

WORD

-

X

El patrón de bits del valor de origen se transfiere sin cambios al tipo
de datos de destino. El resultado de la conversión equivale al nú‐
mero de días desde el 01/01/1990.

DWORD

-

-

Sin conversión implícita

SINT

-

-

USINT

-

-

INT

-

X

UINT

-

X

El patrón de bits del valor de origen se transfiere sin cambios al tipo
de datos de destino. El resultado de la conversión equivale al nú‐
mero de días desde el 01/01/1990.

DINT

-

-

Sin conversión implícita

UDINT

-

-

REAL

-

-

LREAL

-

-

TIME

-

-

DTL

-

X

El patrón de bits del valor de origen se transfiere sin cambios al tipo
de datos de destino. El resultado de la conversión equivale al nú‐
mero de días desde el 01/01/1990.

TOD

-

-

Sin conversión implícita

STRING

-

-

WSTRING

-

-

CHAR

-

-

WCHAR

-

-

x: Conversión posible
-: Conversión no posible

522

Programación del PLC
Manual de programación y manejo, 11/2019

Tipos de datos
3.16 Conversión de los tipos de datos en el S7-1200

Consulte también
DATE (Página 268)
Activar o desactivar la verificación CEI (Página 508)
Sinopsis de la conversión de tipos de datos (Página 506)
Conversión explícita de DATE (Página 567)

Conversión implícita de TOD
Posibilidades de conversión implícita
L