√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Ejemplos de programaci√≥n AWL (P√°gina 8102)

T STW: Transferir acumulador 1 a palabra de estado
Descripci√≥n
La instrucci√≥n "Transferir acumulador 1 a palabra de estado" transfiere los bits 0 a 8 del
acumulador 1 a la palabra de estado.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1665

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra los bits del acumulador 1 con los que se sobrescriben los bits de
estado despu√©s de ejecutar la instrucci√≥n:
Acumulador 1
N√∫mero de bit

8

7

6

5

4

3

2

1

0

Bits de estado

BR

CC 1

CC 0

OV

OS

0

0

RLO

0

Esta instrucci√≥n se ejecuta independientemente del estado l√≥gico del bit de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_STW"

// Cargar el valor del operando "Tag_STW" en el acumulador 1.

T STW

// Transferir los bits 0 a 8 del acumulador 1 a la palabra de estado.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

CAR: Intercambiar AR1 y AR2
Descripci√≥n
La instrucci√≥n "Intercambiar AR1 y AR2" intercambia los contenidos de los registros de
direcciones 1 (AR1) y 2 (AR2).
La CPU ejecuta la instrucci√≥n independientemente del resultado l√≥gico y los bits de estado. La
instrucci√≥n no influye ni en el resultado l√≥gico ni en los bits de estado.
Los contenidos de los acumuladores no cambian debido a la instrucci√≥n.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:

1666

AWL

Explicaci√≥n

LAR1 P#10.0

// Cargar el contenido del puntero intra√°rea P#10.0 en
el registro de direcciones 1.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

LAR2 P#20.0

// Cargar el contenido del puntero intra√°rea P#20.0 en
el registro de direcciones 2.

CAR

// Intercambiar el contenido de los registros de direcciones.

L MD [AR1,P#2.0]

// Cargar MD22 en el acumulador 1.

T MD [AR2,P#2.0]

// Transferir MD12 al acumulador 2.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

TAR1: Transferir AR1 a acumulador 1
Descripci√≥n
La instrucci√≥n "Transferir AR1 a acumulador 1" transfiere el contenido del registro de
direcciones 1 (AR1) al acumulador 1. El contenido del acumulador 1 se desplaza al
acumulador 2.
La CPU ejecuta la instrucci√≥n independientemente del resultado l√≥gico y los bits de estado. La
instrucci√≥n no influye ni en el resultado l√≥gico ni en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

LAR1 P#15.0

// Cargar el contenido del puntero intra√°rea P#15.0 en
el registro de direcciones 1.

TAR1

// Transferir el contenido del registro de direcciones
1 (P#15.0) al acumulador 1.

T "Tag_Pointer"

// Transferir el contenido del acumulador 1 al operando "Tag_Pointer".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1667

Instrucciones
4.1 Instrucciones
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

TAR1 <D>: Transferir AR1 a palabra doble
Descripci√≥n
La instrucci√≥n "Transferir AR1 a palabra doble" transfiere el contenido del registro de
direcciones 1 (AR1) a una palabra doble. La palabra doble debe estar direccionada en una de
las √°reas de memoria siguientes:
‚óè Marcas (M)
‚óè Datos locales temporales (L)
‚óè Bloques de datos (DB, DI)
La CPU ejecuta la instrucci√≥n independientemente del resultado l√≥gico y los bits de estado. La
instrucci√≥n no influye ni en el resultado l√≥gico ni en los bits de estado.
Los contenidos de los acumuladores no cambian debido a la instrucci√≥n.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Transferir AR1 a palabra doble":
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<D>

Output

DWORD

D, M, L

Operando al que se transfie‚Äê
re el contenido del registro de
direcciones 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

TAR1 %DBD20

// Transferir el contenido del registro de direcciones
1 a la doble palabra de datos DBD20.

TAR1 %DID30

// Transferir el contenido del registro de direcciones
1 a la doble palabra de instancia DID30.

TAR1 %LD18

// Transferir el contenido del registro de direcciones
1 a la doble palabra de datos locales LD18.

TAR1 %MD24

// Transferir el contenido del registro de direcciones
1 a la doble palabra de marcas MD24.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)

1668

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

TAR1 AR2: Transferir AR1 a AR2
Descripci√≥n
La instrucci√≥n "Transferir AR1 a AR2" copia el contenido del registro de direcciones 1 (AR1) en
el registro de direcciones 2 (AR2).
La CPU ejecuta la instrucci√≥n independientemente del resultado l√≥gico y los bits de estado. La
instrucci√≥n no influye ni en el resultado l√≥gico ni en los bits de estado.
Los contenidos de los acumuladores no cambian debido a la instrucci√≥n.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

LAR1 P#10.4

// Cargar el contenido del puntero intra√°rea P#10.4 en
el registro de direcciones 1.

TAR1 AR2

// Transferir el contenido del registro de direcciones
1 al registro de direcciones 2.

A I [AR2,P#3.2]

// Consultar si el estado l√≥gico del bit I13.6 es "1"
y combinar el resultado l√≥gicamente con Y con el RLO
actual.

= "Tag1"

// Poner el operando "Tag_1" a "1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1669

Instrucciones
4.1 Instrucciones

TAR2: Transferir AR2 a acumulador 1
Descripci√≥n
La instrucci√≥n "Transferir AR2 a acumulador 1" transfiere el contenido del registro de
direcciones 2 (AR2) al acumulador 1. El contenido del acumulador 1 se desplaza al
acumulador 2.
La CPU ejecuta la instrucci√≥n independientemente del resultado l√≥gico y los bits de estado. La
instrucci√≥n no influye ni en el resultado l√≥gico ni en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

LAR2 P#20.0

// Cargar el contenido del puntero intra√°rea P#20.0 al
registro de direcciones 2.

TAR2

// Transferir el contenido del registro de direcciones
2 (P#20.0) al acumulador 1.

T "Tag_Pointer"

// Transferir el contenido del acumulador 1 al operando "Tag_Pointer".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

TAR2 <D>: Transferir AR2 a palabra doble
Descripci√≥n
La instrucci√≥n "Transferir AR2 a palabra doble" transfiere el contenido del registro de
direcciones 2 (AR2) a una palabra doble. La palabra doble debe estar direccionada en una de
las √°reas de memoria siguientes:
‚óè Marcas (M)
‚óè Datos locales temporales (L)
‚óè Bloques de datos (DB, DI)
La CPU ejecuta la instrucci√≥n independientemente del resultado l√≥gico y los bits de estado. La
instrucci√≥n no influye ni en el resultado l√≥gico ni en los bits de estado.

1670

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los contenidos de los acumuladores no cambian debido a la instrucci√≥n.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Transferir AR2 a palabra doble":
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<D>

Output

DWORD

D, M, L

Operando al que se transfie‚Äê
re el contenido del registro de
direcciones 2.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

TAR2 %DBD20

// Transferir el contenido del registro de direcciones
2 a la doble palabra de datos DBD20.

TAR2 %DID30

// Transferir el contenido del registro de direcciones
2 a la doble palabra de instancia DID30.

TAR2 %LD18

// Transferir el contenido del registro de direcciones
2 a la doble palabra de datos locales LD18.

TAR2 %MD24

// Transferir el contenido del registro de direcciones
2 a la doble palabra de marcas MD24.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

Conversi√≥n
BTI: Convertir BCD en entero (16 bits)
Descripci√≥n
La instrucci√≥n "Convertir BCD en entero (16 bits)" convierte el valor que est√° en la palabra
derecha del acumulador 1 en un entero (de 16 bits). La instrucci√≥n interpreta el valor que debe
convertirse como n√∫mero decimal codificado en binario de tres d√≠gitos (BCD).
Los bits 1 a 11 del acumulador 1 indican el valor que se convertir√°. Se admiten valores dentro
del rango "-999" a "+999".
Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1671

Instrucciones
4.1 Instrucciones
El signo del valor del resultado se lee del bit 15 del acumulador 1. Si el estado l√≥gico del bit es
"0", el signo es positivo. Si el estado l√≥gico del bit es "1", el signo es negativo. Los bits 12 a 14
no se utilizan en la conversi√≥n.
Si el c√≥digo BCD contiene un error BCD, la CPU activa los bits OV y OS de la palabra de estado.
El resultado de la conversi√≥n se guarda en la palabra derecha del acumulador 1. El contenido
de la palabra izquierda del acumulador 1 no se ve influido por la instrucci√≥n.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar BCD en el acumulador 1.

BTI

// Convertir BCD en entero de 16 bits.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La figura siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
‡≤Ø‡≤Ø

‡≤Ø‡≤Ø



‡≤Ø7DJB,QSXW‡≤Ø



%7,
‡≤Ø7DJB2XWSXW‡≤Ø

‡≤Ø‡≤Ø



‡≤Ø‡≤Ø







‡≤Ø‡≤Ø%&'



‡≤Ø‡≤ØHQWHUR

&RQYHUWLU%&'HQHQWHUR ELWV






Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

ITB: Convertir entero en BCD (16 bits)
Descripci√≥n
La instrucci√≥n "Convertir entero en BCD (16 bits)" convierte el valor que se encuentra en la
palabra derecha del acumulador 1 en un n√∫mero decimal en c√≥digo binario de tres d√≠gitos
(BCD). La instrucci√≥n interpreta el valor que debe convertirse como un entero de 16 bits.

1672

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los bits 0 a 11 del acumulador 1 indican el valor que se convertir√°. Se admiten valores dentro
del rango "-999" a "+999". Si el valor que debe convertirse est√° fuera de este rango, los bits OV
y OS se ponen al estado l√≥gico "1". En este caso no se lleva a cabo la conversi√≥n.
El signo del valor del resultado se lee de los bits 12 a 15 del acumulador 1. Si el estado l√≥gico
de los bits es "0", el signo es positivo. Si el estado l√≥gico de los cuatro bits es "1", el signo es
negativo.
El resultado de la conversi√≥n se guarda en la palabra derecha del acumulador 1. El contenido
de la palabra izquierda del acumulador 1 no se ve influido por la instrucci√≥n.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar entero (16 bits) en el acumulador 1.

ITB

// Convertir entero en BCD.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La figura siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:



‡≤Ø7DJB,QSXW‡≤Ø



,7%
‡≤Ø7DJB2XWSXW‡≤Ø











‡≤Ø‡≤ØHQWHUR



‡≤Ø‡≤Ø%&'

&RQYHUWLUHQWHURHQ%&' ELWV




‡≤Ø‡≤Ø

‡≤Ø‡≤Ø


‡≤Ø‡≤Ø

‡≤Ø‡≤Ø

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1673

Instrucciones
4.1 Instrucciones

BTD: Convertir BCD en entero doble (32 bits)
Descripci√≥n
La instrucci√≥n "Convertir BCD en entero doble (32 bits)" convierte el valor que est√° en el
acumulador 1 en un entero doble (de 32 bits). La instrucci√≥n interpreta el valor que debe
convertirse como n√∫mero decimal codificado en binario de siete d√≠gitos (BCD).
Los bits 0 a 27 del acumulador 1 indican el valor que se convertir√°. Se admiten valores dentro
del rango "-9999999" a "+9999999".
El signo del valor del resultado se lee del bit 31 del acumulador 1. Si el estado l√≥gico del bit es
"0", el signo es positivo. Si el estado l√≥gico del bit es "1", el signo es negativo. Los bits 28 a 30
no se utilizan en la conversi√≥n.
El resultado de la instrucci√≥n se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.
Si el c√≥digo BCD contiene un error BCD, la CPU activa los bits OV y OS de la palabra de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar BCD en el acumulador 1.

BTD

// Convertir BCD en un entero de 32 bits.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La figura siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
‡≤Ø‡≤Ø

‡≤Ø‡≤Ø

‡≤Ø‡≤Ø

‡≤Ø‡≤Ø

‡≤Ø‡≤Ø

‡≤Ø‡≤Ø


        ‡≤Ø‡≤Ø

%7'
‡≤Ø7DJB2XWSXW‡≤Ø

‡≤Ø‡≤Ø

 


‡≤Ø7DJB,QSXW‡≤Ø

‡≤Ø‡≤Ø

&RQYHUWLU%&'HQHQWHUR ELWV
        ‡≤Ø‡≤Ø

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

1674

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

ITD: Convertir entero (16 bits) en entero doble (32 bits)
Descripci√≥n
La instrucci√≥n "Convertir entero (16 bits) en entero doble (32 bits)" convierte el valor que se
encuentra en la palabra derecha del acumulador 1 en un entero doble (de 32 bits). La
instrucci√≥n interpreta el valor que debe convertirse como un entero de 16 bits.
Los bits 0 a 15 se aplican sin cambios en la conversi√≥n. Los bits 16 a 31 del valor del resultado
se rellenan con el estado l√≥gico del bit 15.
El valor del resultado se guarda en el acumulador 1. El contenido del acumulador 2 no cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar entero (16 bits) en el acumulador 1.

ITD

// Convertir entero de 16 bits en entero doble de 32
bits.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el contenido del acumulador 1 antes y despu√©s de ejecutar la
instrucci√≥n:
Estado

Acumulador 1
31 . . .

....

....

. . . 16

15 . . .

....

....

...0

Antes de la
ejecuci√≥n

XXXX

XXXX

XXXX

XXXX

1111

1111

1111

0110

Despu√©s de
la ejecuci√≥n

1111

1111

1111

1111

1111

1111

1111

0110

X : el estado l√≥gico de los bits no es relevante para la conversi√≥n

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1675

Instrucciones
4.1 Instrucciones

DTB: Convertir entero doble (32 bits) en BCD
Descripci√≥n
La instrucci√≥n "Convertir entero doble (32 bits) en BCD" convierte el valor que est√° en el
acumulador 1 en un n√∫mero decimal en c√≥digo binario de siete d√≠gitos (BCD). La instrucci√≥n
interpreta el valor que debe convertirse como un entero de 32 bits.
Los bits 0 a 27 del acumulador 1 indican el valor que se convertir√°. Se admiten valores dentro
del rango "-9999999" a "+9999999". Si el valor que debe convertirse est√° fuera de este rango,
los bits OV y OS se ponen al estado l√≥gico "1". En este caso no se lleva a cabo la conversi√≥n.
El signo del valor del resultado se lee de los bits 28 a 31 del acumulador 1. Si el estado l√≥gico
de los bits es "0", el signo es positivo. Si el estado l√≥gico de los cuatro bits es "1", el signo es
negativo.
El resultado de la instrucci√≥n se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar entero de 32 bits en el acumulador 1.

DTB

// Convertir entero de 32 bits en BCD

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La figura siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
 


‡≤Ø7DJB,QSXW‡≤Ø

       

'7%
‡≤Ø7DJB2XWSXW‡≤Ø



‡≤Ø‡≤ØHQWHUR

&RQYHUWLUHQWHURHQ%&' ELWV

       
‡≤Ø‡≤Ø

‡≤Ø‡≤Ø

‡≤Ø‡≤Ø

‡≤Ø‡≤Ø

‡≤Ø‡≤Ø

‡≤Ø‡≤Ø

‡≤Ø‡≤Ø
‡≤Ø‡≤Ø
‡≤Ø‡≤Ø%&'

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)

1676

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

DTR: Convertir entero doble (32 bits) en n√∫mero en coma flotante
Descripci√≥n
La instrucci√≥n "Convertir entero doble (32 bits) en n√∫mero en coma flotante" convierte el valor
que est√° en el acumulador 1 en un n√∫mero en coma flotante. La instrucci√≥n interpreta el valor
que debe convertirse como un entero de 32 bits.
Puesto que un entero de 32 bits es m√°s exacto que un n√∫mero en coma flotante, el resultado
de la conversi√≥n se redondea al siguiente n√∫mero representable.
El resultado de la instrucci√≥n se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar entero de 32 bits en el acumulador 1.

DTR

// Convertir entero de 32 bits en n√∫mero en coma flotante.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La figura siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
‡≤Ø7DJB,QSXW‡≤Ø
'75

       
&RQYHUWLUHQWHURGREOH ELWV HQQ¬ºPHURHQFRPDIORWDQWH


7DJB2XWSXW

‡≤Ø‡≤ØHQWHUR




       
([SRQHQWHELWV

0DQWLVDELWV

ELW
6LJQRGHODPDQWLVD

‡≤Ø‡≤Ø,((()3

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1677

Instrucciones
4.1 Instrucciones
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

INVI: Generar complemento a uno de un entero (16 bits)
Descripci√≥n
La instrucci√≥n "Generar complemento a uno de un entero (16 bits)" niega bit por bit el valor que
se encuentra en la palabra derecha del acumulador 1.
Al ejecutarse, la instrucci√≥n invierte el estado l√≥gico de cada uno de los bits de la palabra
derecha del acumulador 1. Los unos son sustituidos por ceros y viceversa.
El resultado se guarda en la palabra derecha del acumulador 1. El contenido de la palabra
izquierda del acumulador 1 no se ve influido por la instrucci√≥n.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar el valor en el acumulador 1.

INVI

// Generar un complemento a 1

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor
15 . . .

....

....

...0

Tag_Input

0110

0011

1010

1110

Tag_Output

1001

1100

0101

0001

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

1678

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

INVD: Generar complemento a uno de un entero doble (32 bits)
Descripci√≥n
La instrucci√≥n "Generar complemento a uno de un entero doble (32 bits)" niega bit por bit el
valor que se encuentra en el acumulador 1.
Al ejecutarse, la instrucci√≥n invierte el estado l√≥gico de cada uno de los bits del acumulador 1.
Los unos son sustituidos por ceros y viceversa.
El resultado de la instrucci√≥n se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar el valor en el acumulador 1.

INVD

// Generar un complemento a 1

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor
31 . . .

....

....

. . . 16

15 . . .

....

....

...0

Tag_Input

0110

1111

1000

1100

0110

0011

1010

1110

Tag_Output

1001

0000

0111

0011

1001

1100

0101

0001

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

NEGI: Negar entero (16 bits)
Descripci√≥n
La instrucci√≥n "Negar entero (16 bits)" invierte el signo del valor que est√° en la palabra derecha
del acumulador 1 por una formaci√≥n de complemento a dos. La instrucci√≥n interpreta el valor
del acumulador 1 como un entero de 16 bits.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1679

Instrucciones
4.1 Instrucciones
La ejecuci√≥n de la instrucci√≥n es equivalente a una multiplicaci√≥n por "-1". El resultado de la
instrucci√≥n se guarda en la palabra derecha del acumulador 1. El contenido de la palabra
izquierda del acumulador 1 no se ve influido por la instrucci√≥n.
La instrucci√≥n "Negar entero (16 bits)" influye en los bits de estado CC 0, CC 1, OV y OS. La
tabla siguiente muestra c√≥mo la instrucci√≥n influye en los bits de estado en funci√≥n del
resultado:
Resultado:

CC 1

CC 0

OV

OS

de +1 a +32 767

1

0

0

-

0

0

0

0

-

de -1 a -32 767

0

1

0

-

(-) 32 768

0

1

1

1

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar el valor en el acumulador 1.

NEGI

// Negar entero de 16 bits

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor
15 . . .

....

....

...0

Tag_Input

0101

1101

0011

1000

Tag_Output

1010

0010

1100

1000

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

1680

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

NEGD: Negar entero doble (32 bits)
Descripci√≥n
La instrucci√≥n "Negar entero doble (32 bits)" invierte el signo del valor que se encuentra en el
acumulador 1 por una formaci√≥n de complemento a dos. La instrucci√≥n interpreta el valor del
acumulador 1 como un entero de 32 bits.
La ejecuci√≥n de la instrucci√≥n es equivalente a una multiplicaci√≥n por "-1". El resultado de la
instrucci√≥n se guarda en el acumulador 1. El contenido del acumulador 2 no cambia.
La instrucci√≥n "Negar entero doble (32 bits)" influye en los bits de estado CC 0, CC 1, OV y OS.
La tabla siguiente muestra c√≥mo la instrucci√≥n influye en los bits de estado en funci√≥n del
resultado:
Resultado

CC 1

CC 0

OV

OS

de +1 a +2147483647

1

0

0

-

0

0

0

0

-

de -1 a -2147483647

0

1

0

-

(-) 2147483648

0

1

1

1

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar el valor en el acumulador 1.

NEGD

// Negar entero doble de 32 bits.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Estado

Valor
31 . . .

....

....

. . . 16

15 . . .

....

....

...0

Tag_Input

0101

1111

0110

0100

0101

1101

0011

1000

Tag_Output

1010

0000

1001

1011

1010

0010

1100

1000

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1681

Instrucciones
4.1 Instrucciones

NEGR: Negar n√∫mero en coma flotante
Descripci√≥n
La instrucci√≥n "Negar n√∫mero en coma flotante" invierte el signo de la mantisa y es equivalente
a una multiplicaci√≥n por "-1".
La instrucci√≥n interpreta el valor del acumulador 1 como un n√∫mero en coma flotante. El bit 31
del n√∫mero en coma flotante contiene el signo de la mantisa.
El resultado de la instrucci√≥n se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.
La instrucci√≥n no influye en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar el n√∫mero en coma flotante en el acumulador
1.

NEGR

// Negar n√∫mero en coma flotante.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Input

1.5E+02

Tag_Output

-1.5E+02

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

CAW: Invertir orden de los bytes en la palabra derecha del acumulador 1
Descripci√≥n
La instrucci√≥n "Invertir orden de los bytes en la palabra derecha del acumulador 1" invierte el
orden de los dos bytes derechos en la palabra derecha del acumulador 1.

1682

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el contenido del acumulador 1 antes y despu√©s de ejecutar la
instrucci√≥n:
Estado

Bytes del acumulador 1

Antes de la ejecuci√≥n

Valor A

Valor B

Valor C

Valor D

Despu√©s de la ejecuci√≥n

Valor A

Valor B

Valor D

Valor C

El resultado de la instrucci√≥n se guarda en la palabra derecha del acumulador 1. Los bytes de
la palabra izquierda del acumulador 1 no se ven influidos por la instrucci√≥n y no cambian.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar el valor en el acumulador.

CAW

// Invertir orden de los bytes en la palabra derecha
del acumulador 1.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Input

0000

1111

0000

1111

Tag_Output

0000

1111

1111

0000

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

CAD: Invertir orden de los bytes en todo el acumulador 1
Descripci√≥n
La instrucci√≥n "Invertir orden de los bytes en todo el acumulador 1" invierte el orden de los
bytes en el acumulador 1.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1683

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el contenido del acumulador 1 antes y despu√©s de ejecutar la
instrucci√≥n:
Estado

Bytes del acumulador 1

Antes de la ejecuci√≥n

Valor A

Valor B

Valor C

Valor D

Despu√©s de la ejecuci√≥n

Valor D

Valor C

Valor B

Valor A

El resultado de la instrucci√≥n se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar el valor del operando en el acumulador 1.

CAD

// Invertir orden de los bytes del acumulador 1.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Input

1111

0000

0000

1111

0000

0000

1111

1111

Tag_Output

1111

1111

0000

0000

0000

1111

1111

0000

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

RND: Redondear n√∫mero
Descripci√≥n
La instrucci√≥n "Redondear n√∫mero" convierte el valor que se encuentra en el acumulador 1 en
un entero doble (de 32 bits). La instrucci√≥n interpreta el valor que debe convertirse como un
n√∫mero en coma flotante y lo redondea al siguiente entero.
Si el n√∫mero en coma flotante se encuentra exactamente entre un n√∫mero par y uno impar, se
selecciona el n√∫mero par como resultado.
El resultado de la instrucci√≥n se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.

1684

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La conversi√≥n no se ejecuta y los bits de estado OV y OS se activan si se cumple una de las
condiciones siguientes:
‚óè El valor que se encuentra en el acumulador 1 no es un n√∫mero en coma flotante v√°lido.
‚óè El resultado est√° fuera del rango permitido para un entero del tipo de datos DINT.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar el n√∫mero en coma flotante en el acumulador
1.

RND

// Redondear un n√∫mero en coma flotante a un entero.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valores

Tag_Input

101.5

-101.5

Tag_Output

102

-102

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

TRUNC: Truncar a entero
Descripci√≥n
La instrucci√≥n "Truncar a entero" convierte el valor que se encuentra en el acumulador 1 en un
entero doble (de 32 bits). La instrucci√≥n interpreta el valor que debe convertirse como n√∫mero
en coma flotante y devuelve como resultado su parte entera.
El resultado de la instrucci√≥n se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.
La conversi√≥n no se ejecuta y los bits de estado OV y OS se activan si se cumple una de las
condiciones siguientes:
‚óè El valor que se encuentra en el acumulador 1 no es un n√∫mero en coma flotante v√°lido.
‚óè El resultado est√° fuera del rango permitido para un entero del tipo de datos DINT.
Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1685

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar el n√∫mero en coma flotante en el acumulador
1.

TRUNC

// Convertir el n√∫mero en coma flotante en un entero
del tipo de datos DINT.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valores

Tag_Input

101.5

-101.5

Tag_Output

101

-101

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

RND+: Redondear un n√∫mero en coma flotante al siguiente entero superior
Descripci√≥n
La instrucci√≥n "Redondear un n√∫mero en coma flotante al siguiente entero superior" convierte
el valor que se encuentra en el acumulador 1 en un entero doble (de 32 bits). La instrucci√≥n
interpreta el valor que debe convertirse como n√∫mero en coma flotante y lo redondea al
siguiente entero superior. El resultado de la instrucci√≥n es un n√∫mero del tipo de datos DINT,
mayor o igual al n√∫mero en coma flotante que se ha convertido.
El resultado de la instrucci√≥n se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.
La conversi√≥n no se ejecuta y los bits de estado OV y OS se activan si se cumple una de las
condiciones siguientes:
‚óè El valor que se encuentra en el acumulador 1 no es un n√∫mero en coma flotante v√°lido.
‚óè El resultado est√° fuera del rango permitido para un entero del tipo de datos DINT.

1686

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar el n√∫mero en coma flotante en el acumulador
1.

RND+

// Redondear el n√∫mero en coma flotante al siguiente
entero superior.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valores

Tag_Input

100.5

-100.5

Tag_Output

101

-100

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

RND-: Redondear un n√∫mero en coma flotante al siguiente entero inferior
Descripci√≥n
La instrucci√≥n "Redondear un n√∫mero en coma flotante al siguiente entero inferior" convierte
el valor que se encuentra en el acumulador 1 en un entero doble (de 32 bits). La instrucci√≥n
interpreta el valor que debe convertirse como n√∫mero en coma flotante y lo redondea al
siguiente entero inferior. El resultado de la instrucci√≥n es un n√∫mero del tipo de datos DINT,
menor o igual al n√∫mero en coma flotante que se ha convertido.
El resultado de la instrucci√≥n se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.
La conversi√≥n no se ejecuta y los bits de estado OV y OS se activan si se cumple una de las
condiciones siguientes:
‚óè El valor que se encuentra en el acumulador 1 no es un n√∫mero en coma flotante v√°lido.
‚óè El resultado est√° fuera del rango permitido para un entero del tipo de datos DINT.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1687

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input"

// Cargar el n√∫mero en coma flotante en el acumulador
1.

RND-

// Redondear el n√∫mero en coma flotante al siguiente
entero inferior.

T "Tag_Output"

// Transferir el resultado al operando "Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valores

Tag_Input

100.5

-100.5

Tag_Output

100

-101

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

Control del programa
Operaciones de salto
Etiqueta
Descripci√≥n
Una etiqueta sirve para identificar el punto del programa en el que debe continuar la ejecuci√≥n
tras un salto. El nombre de la etiqueta puede comprender un m√°ximo de 128 letras, cifras o
caracteres de subrayado.
La etiqueta y la instrucci√≥n en la que se indica la etiqueta como destino del salto deben
encontrarse en el mismo bloque. El nombre de una etiqueta debe ser √∫nico en el bloque. A toda
etiqueta se puede acceder desde distintas posiciones. Se pueden declarar como m√°ximo 256
etiquetas.
Es posible saltar hacia delante y hacia atr√°s.

1688

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para la etiqueta deben observarse las siguientes reglas gramaticales:
‚óè Letras (a - z, A - Z)
‚óè Una combinaci√≥n de letras y n√∫meros. Es importante observar el orden, es decir, primero
las letras y despu√©s los n√∫meros (a - z, A - Z, 0 - 9).
‚óè No pueden utilizarse caracteres especiales o una combinaci√≥n de letras y n√∫meros en
orden inverso, es decir, primero los n√∫meros y despu√©s las letras (0 - 9, a - z, A - Z).

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input_1"

// Cargar el primer valor de comparaci√≥n.

L "Tag_Input_2"

// Cargar el segundo valor de comparaci√≥n.

>I

// Consultar si el valor del operando "Tag_Input_1" es
mayor que el valor del operando "Tag_Input_2".

JC MyLABEL

// Si el resultado de la consulta es "1", saltar a la
etiqueta "MyLABEL" y continuar all√≠ el procesamiento
del programa
// Si el resultado de la consulta es "0", procesar la
instrucci√≥n siguiente.

L "Tag_Input_3"

// Cargar el contenido del operando "Tag_Input_3" en
el acumulador 1.

T "Tag_Output"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output".

MyLABEL: A "Tag_Input_4"

// Continuar la ejecuci√≥n del programa en este punto
en caso de haberse ejecutado un salto.
// Consultar si el operando "Tag_Input_4" est√° a "1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

JU: Salto incondicional
Descripci√≥n
La instrucci√≥n "Salto incondicional" interrumpe la ejecuci√≥n lineal del programa y continuarla
en el punto marcado por la etiqueta indicada. Esta instrucci√≥n se ejecuta siempre,
independientemente de las condiciones.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1689

Instrucciones
4.1 Instrucciones
La instrucci√≥n "Salto incondicional" no influye en los bits de estado.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Salto incondicional":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input_1"

// Cargar el primer valor de comparaci√≥n.

L "Tag_Input_2"

// Cargar el segundo valor de comparaci√≥n.

>I

// Consultar si el valor del operando "Tag_Input_1" es
mayor que el valor del operando "Tag_Input_2".

JC MyLABEL_1

// Si el resultado de la consulta es "1", saltar a la
etiqueta "MyLABEL_1" y continuar all√≠ el procesamiento del programa
// Si el resultado de la consulta es "0", continuar
con la ejecuci√≥n lineal del programa.

L "Tag_Input_3"

// Cargar el contenido del operando "Tag_Input_3" en
el acumulador 1.

T "Tag_Output_1"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output_1".

JU MyLABEL_2

// Saltar a la etiqueta "MyLABEL_2" y continuar all√≠
con la ejecuci√≥n del programa.

MyLABEL_1:

// Etiqueta

L "Tag_Input_4"

// Cargar el contenido del operando "Tag_Input_4" en
el acumulador 1.

T "Tag_Output_2"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output_2".

MyLABEL_2: A "Tag_Input_5"

// Etiqueta "MyLABEL_2"
// Consultar si el operando "Tag_Input_5" est√° a "1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Ejemplos de programaci√≥n AWL (P√°gina 8102)

1690

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

JC: Saltar si RLO = 1
Descripci√≥n
La instrucci√≥n "Saltar si RLO = 1" interrumpe la ejecuci√≥n lineal del programa en funci√≥n del
resultado l√≥gico y continuarla en el punto marcado por la etiqueta indicada.
El salto a la etiqueta indicada se ejecuta solo si el RLO actual es "1". Si el RLO actual antes de
la instrucci√≥n es "0", el salto no se ejecuta y la ejecuci√≥n del programa contin√∫a con la
instrucci√≥n siguiente.
La instrucci√≥n "Saltar si RLO = 1" pone el RLO a "1" tanto si la condici√≥n se cumple como si no.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si RLO = 1":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input_1"

// Cargar el primer valor de comparaci√≥n.

L "Tag_Input_2"

// Cargar el segundo valor de comparaci√≥n.

>I

// Consultar si el valor del operando "Tag_Input_1" es
mayor que el valor del operando "Tag_Input_2".

JC MyLABEL

// Si el RLO ="1", saltar a la etiqueta "MyLABEL" y
continuar all√≠ la ejecuci√≥n del programa.
// Si el RLO ="0", procesar la instrucci√≥n siguiente.

L "Tag_Input_3"

// Cargar el contenido del operando "Tag_Input_3" en
el acumulador 1.

T "Tag_Output_1"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output_1".

MyLABEL: L "Tag_Input_4"

// Continuar la ejecuci√≥n del programa en este punto
en caso de haberse ejecutado un salto.
// Cargar el contenido del operando "Tag_Input_4" en
el acumulador 1.

T "Tag_Output_2"

// Transferir el contenido del acumulador 1 al operando "Tag_Output_2".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1691

Instrucciones
4.1 Instrucciones
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Ejemplos de programaci√≥n AWL (P√°gina 8102)

JCN: Saltar si RLO = 0
Descripci√≥n
La instrucci√≥n "Saltar si RLO = 0" interrumpe la ejecuci√≥n lineal del programa en funci√≥n del
resultado l√≥gico (RLO) y continuarla en el punto marcado por la etiqueta indicada.
El salto a la etiqueta indicada se ejecuta solo si el RLO actual es "0". Si el RLO actual antes de
la instrucci√≥n es "1", el salto no se ejecuta y la ejecuci√≥n del programa contin√∫a con la
instrucci√≥n siguiente.
La instrucci√≥n "Saltar si RLO = 0" pone el RLO a "1" tanto si la condici√≥n se cumple como si no.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si RLO = 0":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

A "Tag_Input_1"

// Consultar si el operando "Tag_Input_1" es "1" y
combinar el resultado l√≥gicamente con Y.

A "Tag_Input_2"

// Consultar si el operando "Tag_Input_2" es "1" y
combinar el resultado l√≥gicamente con Y.

JCN MyLABEL

// Si el RLO = "0", saltar a la etiqueta "MyLABEL" y
continuar all√≠ la ejecuci√≥n del programa.
// Si el RLO ="1", procesar la instrucci√≥n siguiente.

L "Tag_Input_3"

// Cargar el contenido del operando "Tag_Input_3" en
el acumulador 1.

T "Tag_Output"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output".

MyLABEL: A "Tag_Input_4"

// Continuar la ejecuci√≥n del programa en este punto
en caso de haberse ejecutado un salto.
// Consultar si el operando "Tag_Input_4" es "1" y
combinar el resultado l√≥gicamente con Y con el RLO.

1692

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Ejemplos de programaci√≥n AWL (P√°gina 8102)

JCB: Saltar si RLO = 1 y guardar RLO
Descripci√≥n
La instrucci√≥n "Saltar si RLO = 1 y guardar RLO" interrumpe la ejecuci√≥n lineal del programa
en funci√≥n del resultado l√≥gico (RLO) y continuarla en el punto marcado por la etiqueta
indicada. Paralelamente, el estado l√≥gico del RLO actual se copia en el resultado binario (BR).
El salto a la etiqueta indicada se ejecuta solo si el RLO actual es "1". En este caso, la
instrucci√≥n pone el resultado binario a "1".
Si el RLO actual antes de la instrucci√≥n es "0", el salto no se ejecuta y la ejecuci√≥n del programa
contin√∫a con la instrucci√≥n siguiente. En tal caso, la instrucci√≥n asigna el estado l√≥gico "0" al
resultado binario.
La instrucci√≥n "Saltar si RLO = 1 y guardar RLO" pone el RLO a "1" tanto si la condici√≥n se
cumple como si no.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si RLO = 1 y guardar RLO":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Input_1"

// Cargar el primer valor de comparaci√≥n.

L "Tag_Input_2"

// Cargar el segundo valor de comparaci√≥n.

>I

// Consultar si el valor del operando "Tag_Input_1" es
mayor que el valor del operando "Tag_Input_2".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1693

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

JCB MyLABEL

// Copiar RLO actual en BR.
// Si el RLO ="1", saltar a la etiqueta "MyLABEL" y
continuar all√≠ la ejecuci√≥n del programa.
// Si el RLO es "0", procesar la instrucci√≥n siguiente.

L "Tag_Input_3"

// Cargar el contenido del operando "Tag_Input_3" en
el acumulador 1.

T "Tag_Output_1"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output_1".

MyLABEL: L "Tag_Input_4"

// Continuar la ejecuci√≥n del programa en este punto
en caso de haberse ejecutado un salto.
// Cargar el contenido del operando "Tag_Input_4" en
el acumulador 1.

T "Tag_Output_2"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output_2".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

JNB: Saltar si RLO = 0 y guardar RLO
Descripci√≥n
La instrucci√≥n "Saltar si RLO = 0 y guardar RLO" interrumpe la ejecuci√≥n lineal del programa
en funci√≥n del resultado l√≥gico (RLO) y continuarla en el punto marcado por la etiqueta
indicada. Paralelamente, el estado del resultado l√≥gico actual se copia en el resultado binario
(BR).
El salto a la etiqueta indicada se ejecuta solo si el RLO actual es "0". En tal caso, la instrucci√≥n
pone el resultado binario a "0".
Si el RLO actual antes de la instrucci√≥n es "1", el salto no se ejecuta y la ejecuci√≥n del programa
contin√∫a con la instrucci√≥n siguiente. En tal caso, la instrucci√≥n asigna el estado l√≥gico "1" al
resultado binario.
La instrucci√≥n "Saltar si RLO = 0 y guardar RLO" pone el RLO a "1" tanto si la condici√≥n se
cumple como si no.

1694

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si RLO = 0 y guardar RLO":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

A "Tag_Input_1"

// Consultar si el operando "Tag_Input_1" es "1" y
combinar el resultado l√≥gicamente con Y.

A "Tag_Input_2"

// Consultar si el operando "Tag_Input_2" es "1" y
combinar el resultado l√≥gicamente con Y.

JNB MyLABEL

// Copiar RLO actual en BR.
// Si el RLO = "0", saltar a la etiqueta "MyLABEL" y
continuar all√≠ la ejecuci√≥n del programa.
// Si el RLO ="1", procesar la instrucci√≥n siguiente.

L "Tag_Input_3"

// Cargar el contenido del operando "Tag_Input_3" en
el acumulador 1.

T "Tag_Output"

// Transferir el contenido del acumulador 1 al operando "Tag_Output".

MyLABEL: A "Tag_Input_4"

// Continuar la ejecuci√≥n del programa en este punto
en caso de haberse ejecutado un salto.
// Consultar si el operando "Tag_Input_4" es "1" y
combinar el resultado l√≥gicamente con Y con el RLO.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

JBI: Saltar si BR = 1
Descripci√≥n
La instrucci√≥n "Saltar si BR = 1" interrumpe la ejecuci√≥n lineal del programa en funci√≥n del
resultado binario y continuarla en el punto marcado por la etiqueta indicada.
El salto a la etiqueta se ejecuta solo si el bit de estado BR es "1". Si el bit de estado BR es "0",
el salto no se ejecuta y la ejecuci√≥n del programa contin√∫a con la instrucci√≥n siguiente.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1695

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si BR = 1":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

SET

// Poner el RLO a "1" al principio del bloque.

SAVE

// Transferir el estado l√≥gico del RLO al bit BR.

....

// Cualquier programa

AN OV

// Consultar el bit OV al final del bloque.

SAVE

// En caso de desbordamiento, poner el bit BR a "0".
// Poner BR a "1" si no se produce desbordamiento.

JBI END

// Si BR = "1", saltar a la etiqueta END.
// Si BR = "0", procesar la instrucci√≥n siguiente.

R "Tag_Output_1"

// Poner el operando "Tag_Output_1" a "0".

END: S "Tag_Output_2"

// Poner el operando "Tag_Output_2" a "1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

JNBI: Saltar si BR = 0
Descripci√≥n
La instrucci√≥n "Saltar si BR = 0" interrumpe la ejecuci√≥n lineal del programa en funci√≥n del
resultado binario (BR) y la contin√∫a en el punto marcado por la etiqueta indicada.
El salto a la etiqueta se ejecuta solo si el bit de estado BR es "0". Si el bit de estado BR antes
de la instrucci√≥n es "1", el salto no se ejecuta y la ejecuci√≥n del programa contin√∫a con la
instrucci√≥n siguiente.

1696

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si BR = 0":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

SET

// Poner el RLO a "1" al principio del bloque.

SAVE

// Transferir el estado l√≥gico del RLO al bit BR.

....

// Cualquier programa

AN OV

// Consultar el bit OV al final del bloque.

SAVE

// En caso de desbordamiento, poner el bit BR a "0".
// Poner BR a "1" si no se produce desbordamiento.

JNBI END

// Si BR = "0", saltar a la etiqueta END.
// Si BR = "1", procesar la instrucci√≥n siguiente.

S "Tag_Output"

// Poner el operando "Tag_Output" a "1".

END: BE

// Finalizar bloque

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

JO: Saltar si OV = 1
Descripci√≥n
La instrucci√≥n "Saltar si OV = 1" interrumpe la ejecuci√≥n lineal del programa en funci√≥n del bit
de estado OV y la contin√∫a en el punto marcado por la etiqueta indicada.
El salto a la etiqueta se ejecuta solo si el bit de estado OV es "1". El bit de estado OV se activa
si, p. ej., el resultado de un c√°lculo est√° fuera del rango permitido o si al comparar n√∫meros en
coma flotante hay un valor no v√°lido.
Si el bit de estado OV es "0", el salto no se ejecuta y la ejecuci√≥n del programa contin√∫a con
la instrucci√≥n siguiente.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1697

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si OV = 1":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar valor

L "Tag_Value_2"

// Cargar valor

*I

// Multiplicar valores

JO OVER

// Si el estado l√≥gico del bit de estado OV es "1",
saltar a la etiqueta "OVER" y continuar all√≠ la ejecuci√≥n del programa.
// Si el estado l√≥gico del bit de estado OV es "0",
procesar la instrucci√≥n siguiente.

T "Tag_Result"

// Transferir el resultado de la multiplicaci√≥n al
operando "Tag_Result".

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar all√≠ con la
ejecuci√≥n del programa.

OVER: SET

// Continuar la ejecuci√≥n del programa en este punto
si se cumple la condici√≥n (OV = "1").
// Poner el RLO al estado l√≥gico "1".

R "Tag_Output"

// Poner el operando "Tag_Output" a "0".

NEXT: A "MyTag_1"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_1" es "1" y combinar el resultado l√≥gicamente con Y.

A "MyTag_2"

// Consultar si el operando "MyTag_2" es "1" y combinar el resultado l√≥gicamente con Y.

S "Tag_Output_2"

// Si el RLO = 1, poner el operando "Tag_Output_2" a
"1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

1698

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

JOS: Saltar si OS = 1
Descripci√≥n
La instrucci√≥n "Saltar si OS = 1" interrumpe la ejecuci√≥n lineal del programa en funci√≥n del bit
de estado OS y la contin√∫a en el punto marcado por la etiqueta indicada.
El salto a la etiqueta se ejecuta solo si el bit de estado OS es "1". El bit de estado OS se activa
siempre que un desbordamiento del rango num√©rico pone el bit de estado OV a "1". Al contrario
que el bit de estado OV, el bit OS se mantiene activado aunque posteriormente haya un
resultado que est√© dentro del rango num√©rico permitido.
Si el bit de estado OS es "0", el salto no se ejecuta y la ejecuci√≥n del programa contin√∫a con
la instrucci√≥n siguiente.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si OS = 1":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar valor

L "Tag_Value_2"

// Cargar valor

*I

// Multiplicar valores cargados.
// Guardar el producto en el acumulador 1.

L "Tag_Value_3"

// Cargar valor

+I

// Sumar el valor cargado al producto.
// Guardar el producto en el acumulador 1.

L "Tag_Value_4"

// Cargar valor

-I

// Restar el valor cargado de la suma calculada.
// Guardar el producto en el acumulador 1.

JOS OVER

// En caso de desbordamiento en una de las tres instrucciones precedentes, el bit de estado OS se pone a
"1".
// Si el estado l√≥gico del bit de estado OS es "1" la
ejecuci√≥n del programa contin√∫a en la posici√≥n de la
etiqueta "OVER".
// Si el estado l√≥gico del bit de estado OS es "0",
procesar la instrucci√≥n siguiente.

T "Tag_Result"

// Transferir el resultado de todo el c√°lculo al operando "Tag_Result".

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar all√≠ con la
ejecuci√≥n del programa.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1699

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

OVER: SET

// Continuar la ejecuci√≥n del programa en este punto
si se cumple la condici√≥n (OV = "1").
// Poner el RLO al estado l√≥gico "1".

R "Tag_Output"

// Poner el operando "Tag_Output" a "0".

NEXT: A "MyTag_1"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_1" es "1" y combinar el resultado l√≥gicamente con Y.

A "MyTag_2"

// Consultar si el operando "MyTag_2" es "1" y combinar el resultado l√≥gicamente con Y.

S "Tag_Output_2"

// Si el RLO = 1, poner el operando "Tag_Output_2" a
"1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

JZ: Saltar si el resultado es cero
Descripci√≥n
La instrucci√≥n "Saltar si el resultado es cero" interrumpe la ejecuci√≥n lineal del programa en
funci√≥n de los bits de estado CC 0 y CC 1 y continuarla en el punto marcado por la etiqueta
indicada.
El salto a la etiqueta indicada se ejecuta solo si el estado l√≥gico de los bits de estado CC 0 y
CC 1 es "0". Esto sucede cuando se cumple una de las condiciones siguientes:
‚óè Despu√©s de ejecutar una instrucci√≥n aritm√©tica sin desbordamiento, el acumulador 1 tiene
el valor "0".
‚óè Al ejecutar la instrucci√≥n "Sumar enteros (16 bits)" (+I) o "Sumar enteros dobles (32 bits)"
(+D) se produce un desbordamiento en el rango negativo.
‚óè Al ejecutar una instrucci√≥n aritm√©tica (aritm√©tica de punto flotante) con desbordamiento se
produce un rebasamiento inferior gradual del rango permitido.
‚óè El contenido del acumulador 2 es igual al contenido del acumulador 1 despu√©s de ejecutar
una instrucci√≥n de comparaci√≥n.
‚óè El contenido del acumulador 1 es cero despu√©s de ejecutar una operaci√≥n l√≥gica con
palabras.
‚óè Tras ejecutar una instrucci√≥n de desplazamiento, el valor del √∫ltimo bit desplazado es "0".

1700

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En los restantes casos, el salto no se ejecuta y la ejecuci√≥n del programa contin√∫a con la
instrucci√≥n siguiente.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si el resultado es cero":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value"

// Cargar el valor del operando "Tag_Value".

SRW 1

// Desplazar el contenido de la palabra derecha del
acumulador 1 una posici√≥n a la derecha.

JZ ZERO

// Si el estado l√≥gico del √∫ltimo bit desplazado hacia
fuera es "0", saltar a la etiqueta "OVER" y continuar
all√≠ el procesamiento del programa
// Si el estado l√≥gico del √∫ltimo bit desplazado hacia
fuera es "1", procesar la instrucci√≥n siguiente.

L "MyTag_1"

// Cargar el valor del operando "MyTag_1" en el acumulador 1.

INC 1

// Sumar el valor "1" al byte derecho del acumulador 1.

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar all√≠ con la
ejecuci√≥n del programa.

ZERO: L "MyTag_2"

// Etiqueta "ZERO"
// Cargar el valor del operando "MyTag_2" en el acumulador 1.

INC 1

// Sumar el valor "1" al byte derecho del acumulador 1.

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado l√≥gicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado l√≥gicamente con Y.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1701

Instrucciones
4.1 Instrucciones
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

JN: Saltar si el resultado no es cero
Descripci√≥n
La instrucci√≥n "Saltar si el resultado no es cero" interrumpe la ejecuci√≥n lineal del programa en
funci√≥n de los bits de estado CC 0 y CC 1 y la contin√∫a en el punto marcado por la etiqueta
indicada.
El salto a la etiqueta indicada se ejecuta solo si el estado l√≥gico de los bits de estado CC 0 y
CC 1 es distinto. Esto sucede cuando se cumple una de las condiciones siguientes:
‚óè Despu√©s de ejecutar una instrucci√≥n aritm√©tica sin desbordamiento, el valor del
acumulador 1 es distinto de cero.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con enteros (+I, -I, *I, +D, -D, *D) se produce un
desbordamiento en el rango negativo.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con enteros (+I, -I, *I, /I, +D, -D, *D, /D, NEGI, NEGD)
se produce un desbordamiento en el rango positivo.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con n√∫meros en coma flotante se produce un
desbordamiento en el rango positivo o negativo.
‚óè El contenido del acumulador 2 es distinto al contenido del acumulador 1 despu√©s de
ejecutar una instrucci√≥n de comparaci√≥n.
‚óè El contenido del acumulador 1 no es cero despu√©s de ejecutar una operaci√≥n l√≥gica con
palabras.
‚óè Tras ejecutar una instrucci√≥n de desplazamiento, el valor del √∫ltimo bit desplazado es "1".
En los restantes casos, el salto no se ejecuta y la ejecuci√≥n del programa contin√∫a con la
instrucci√≥n siguiente.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si el resultado no es cero":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:

1702

AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Valu_1".

L "Tag_Value_2"

// Cargar el valor del operando "Tag_Value_2".

XOW

// Combinar l√≥gicamente con O-exclusiva

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

JN NOZERO

// Cuando el valor del acumulador 1 no es cero, se
salta a la etiqueta "NOZERO" donde se contin√∫a ejecutando el programa.
// Cuando el valor en el acumulador 1 es igual a cero
se ejecuta la siguiente instrucci√≥n.

AN "MyTag_1"

// Consultar si el operando "MyTag_1" es "0" y combinar el resultado l√≥gicamente con Y.

S "Tag_Output_1"

// Si el RLO = "1", poner el operando "Tag_Output_1" a
"1"

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar all√≠ con la
ejecuci√≥n del programa.

NOZERO: AN "MyTag_2"

// Etiqueta "NOZERO"
// Consultar si el operando "MyTag_2" es "0" y combinar el resultado l√≥gicamente con Y.

S "Tag_Output_2"

// Si el RLO es "1", poner el operando "Tag_Output_2"
a "1".

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado l√≥gicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado l√≥gicamente con Y.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

JP: Saltar si el resultado es mayor que cero
Descripci√≥n
La instrucci√≥n "Saltar si el resultado es mayor que cero" interrumpe la ejecuci√≥n lineal del
programa en funci√≥n de los bits de estado CC 0 y CC 1 y la contin√∫a en el punto marcado por
la etiqueta indicada.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1703

Instrucciones
4.1 Instrucciones
El salto a la etiqueta indicada se ejecuta solo si el estado l√≥gico del bit de estado CC 0 es "0"
y el del bit de estado CC 1 es "1". Esto sucede cuando se cumple una de las condiciones
siguientes:
‚óè Despu√©s de ejecutar una instrucci√≥n aritm√©tica sin desbordamiento, el valor del
acumulador 1 es mayor que cero.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con enteros (+I, -I, +D, -D) se produce un
desbordamiento en el rango negativo.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con enteros (*I, /I, *D, /D) se produce un
desbordamiento en el rango positivo.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con n√∫meros en coma flotante se produce un
desbordamiento en el rango positivo.
‚óè Tras ejecutar una instrucci√≥n de comparaci√≥n, el contenido del acumulador 2 es mayor que
el contenido del acumulador 1.
‚óè Tras ejecutar una operaci√≥n l√≥gica con palabras, el contenido del acumulador 1 no es cero.
‚óè Tras ejecutar una instrucci√≥n de desplazamiento, el valor del √∫ltimo bit desplazado es "1".
En los restantes casos, el salto no se ejecuta y la ejecuci√≥n del programa contin√∫a con la
instrucci√≥n siguiente.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si el resultado es mayor que
cero":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1".

L "Tag_Value_2"

// Cargar el valor del operando "Tag_Value_2".

-I

// Restar el valor del operando "Tag_Value_2" del valor del operando "Tag_Value_1".

JP POSITIVE

// Si el valor del resultado en el acumulador 1 es positivo, saltar a la etiqueta "POSITIVE" y continuar
all√≠ el procesamiento del programa
// Si el valor del resultado en el acumulador 1 es negativo, procesar la instrucci√≥n siguiente.

1704

AN "MyTag_1"

// Consultar si el operando "MyTag_1" es "0" y combinar el resultado l√≥gicamente con Y.

S "Tag_Output_1"

// Si el RLO = "1", poner el operando "Tag_Output_1" a
"1"

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar all√≠ con la
ejecuci√≥n del programa.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

POSITIVE: AN "MyTag_2"

// Etiqueta "POSITIVE"
// Consultar si el operando "MyTag_2" es "0" y combinar el resultado l√≥gicamente con Y.

S "Tag_Output_2"

// Si el RLO = "1", poner el operando "Tag_Output_2" a
"1"

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado l√≥gicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado l√≥gicamente con Y.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

JM: Saltar si el resultado es menor que cero
Descripci√≥n
La instrucci√≥n "Saltar si el resultado es menor que cero" interrumpe la ejecuci√≥n lineal del
programa en funci√≥n de los bits de estado CC 0 y CC 1 y la contin√∫a en el punto marcado por
la etiqueta indicada.
El salto a la etiqueta indicada se ejecuta solo si el estado l√≥gico del bit de estado CC 0 es "1"
y el del bit de estado CC 1 es "0". Esto sucede cuando se cumple una de las condiciones
siguientes:
‚óè Despu√©s de ejecutar una instrucci√≥n aritm√©tica sin desbordamiento, el valor del
acumulador 1 es menor que cero.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con enteros (*I, *D) se produce un desbordamiento en
el rango negativo.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con enteros (+I, -I, +D, -D, NEGI, NEGD) se produce
un desbordamiento en el rango positivo.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con n√∫meros en coma flotante se produce un
desbordamiento en el rango negativo.
‚óè Tras ejecutar una instrucci√≥n de comparaci√≥n, el contenido del acumulador 2 es menor que
el contenido del acumulador 1.
En los restantes casos, el salto no se ejecuta y la ejecuci√≥n del programa contin√∫a con la
instrucci√≥n siguiente.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1705

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si el resultado es menor que
cero":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1".

L "Tag_Value_2"

// Cargar el valor del operando "Tag_Value_2".

-I

// Restar el valor del operando "Tag_Value_2" del valor del operando "Tag_Value_1".

JM NEGATIVE

// Si el valor del resultado en el acumulador 1 es negativo, saltar a la etiqueta "NEGATIVE" y continuar
all√≠ el procesamiento del programa
// Si el valor del resultado en el acumulador 1 es positivo, procesar la instrucci√≥n siguiente.

AN "MyTag_1"

// Consultar si el operando "MyTag_1" es "0" y combinar el resultado l√≥gicamente con Y.

S "Tag_Output_1"

// Si el RLO = "1", poner el operando "Tag_Output_1" a
"1"

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar all√≠ con la
ejecuci√≥n del programa.

NEGATIVE: AN "MyTag_2"

// Etiqueta "NEGATIVE"
// Consultar si el operando "MyTag_2" es "0" y combinar el resultado l√≥gicamente con Y.

S "Tag_Output_2"

// Si el RLO = "1", poner el operando "Tag_Output_2" a
"1"

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado l√≥gicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado l√≥gicamente con Y.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

1706

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

JPZ: Saltar si el resultado es mayor o igual a cero
Descripci√≥n
La instrucci√≥n "Saltar si el resultado es mayor o igual a cero" interrumpe la ejecuci√≥n lineal del
programa en funci√≥n del bit de estado CC 0 y la contin√∫a en el punto marcado por la etiqueta
indicada.
El salto a la etiqueta indicada se ejecuta solo si el estado l√≥gico del bit de estado CC 0 es "0".
Esto sucede cuando se cumple una de las condiciones siguientes:
‚óè Despu√©s de ejecutar una instrucci√≥n aritm√©tica sin desbordamiento, el valor del
acumulador 1 es mayor o igual que cero.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con enteros (+I, -I, +D, -D) se produce un
desbordamiento en el rango negativo.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con enteros (*I, /I, *D, /D) se produce un
desbordamiento en el rango positivo.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con n√∫meros en coma flotante se produce un
desbordamiento en el rango positivo.
‚óè Al ejecutar una instrucci√≥n aritm√©tica (aritm√©tica de punto flotante) con desbordamiento se
produce un rebasamiento inferior gradual del rango permitido.
‚óè Tras ejecutar una instrucci√≥n de comparaci√≥n, el contenido del acumulador 2 es mayor o
igual al contenido del acumulador 1.
‚óè Se ha ejecutado una instrucci√≥n de operaci√≥n l√≥gica por palabras.
‚óè Se ha ejecutado una instrucci√≥n de desplazamiento.
En los restantes casos, el salto no se ejecuta y la ejecuci√≥n del programa contin√∫a con la
instrucci√≥n siguiente.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si el resultado es mayor o
igual a cero":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1".

L "Tag_Value_2"

// Cargar el valor del operando "Tag_Value_2".

-I

// Restar el valor del operando "Tag_Value_2" del valor del operando "Tag_Value_1".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1707

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

JPZ REGULAR

// Si el valor del resultado en el acumulador 1 es positivo, saltar a la etiqueta "REGULAR" y continuar
all√≠ el procesamiento del programa
// Si el valor del resultado en el acumulador 1 es negativo, procesar la instrucci√≥n siguiente.

AN "MyTag_1"

// Consultar si el operando "MyTag_1" es "0" y combinar el resultado l√≥gicamente con Y.

S "Tag_Output_1"

// Si el RLO = "1", poner el operando "Tag_Output_1" a
"1"

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar all√≠ con la
ejecuci√≥n del programa.

REGULAR: AN "MyTag_2"

// Etiqueta "REGULAR"
// Consultar si el operando "MyTag_2" es "0" y combinar el resultado l√≥gicamente con Y.

S "Tag_Output_2"

// Si el RLO ="1", poner el operando "Tag_Output_2" a
"1"

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado l√≥gicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado l√≥gicamente con Y.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

JMZ: Saltar si el resultado es menor o igual a cero
Descripci√≥n
La instrucci√≥n "Saltar si el resultado es menor o igual a cero" interrumpe la ejecuci√≥n lineal del
programa en funci√≥n del bit de estado CC 1 y la contin√∫a en el punto marcado por la etiqueta
indicada.
El salto a la etiqueta indicada se ejecuta solo si el estado l√≥gico del bit de estado CC 1 es "0".
Esto sucede cuando se cumple una de las condiciones siguientes:
‚óè Despu√©s de ejecutar una instrucci√≥n aritm√©tica sin desbordamiento, el valor del
acumulador 1 es menor o igual que cero.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con enteros (+I, *I, +D, *D) se produce un
desbordamiento en el rango negativo.

1708

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
‚óè Al ejecutar una instrucci√≥n aritm√©tica con enteros (+I, -I, +D, -D, NEGI, NEGD) se produce
un desbordamiento en el rango positivo.
‚óè Al ejecutar una instrucci√≥n aritm√©tica con n√∫meros en coma flotante se produce un
desbordamiento en el rango negativo.
‚óè Al ejecutar una instrucci√≥n aritm√©tica (aritm√©tica de punto flotante) con desbordamiento se
produce un rebasamiento inferior gradual del rango permitido.
‚óè Tras ejecutar una instrucci√≥n de comparaci√≥n, el contenido del acumulador 2 es menor o
igual al contenido del acumulador 1.
‚óè Tras ejecutar una operaci√≥n l√≥gica con palabras, el valor del acumulador 1 es cero.
‚óè Tras ejecutar una instrucci√≥n de desplazamiento, el valor del √∫ltimo bit desplazado es cero.
En los restantes casos, el salto no se ejecuta y la ejecuci√≥n del programa contin√∫a con la
instrucci√≥n siguiente.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si el resultado es menor o
igual a cero":
Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1".

L "Tag_Value_2"

// Cargar el valor del operando "Tag_Value_2".

-I

// Restar el valor del operando "Tag_Value_2" del valor del operando "Tag_Value_1".

JMZ MyLABEL

// Si el valor del resultado en el acumulador 1 es negativo, saltar a la etiqueta "MyLABEL" y continuar
all√≠ el procesamiento del programa
// Si el valor del resultado en el acumulador 1 es positivo, procesar la instrucci√≥n siguiente.

AN "MyTag_1"

// Consultar si el operando "MyTag_1" es "0" y combinar el resultado l√≥gicamente con Y.

S "Tag_Output_1"

// Si el RLO = "1", poner el operando "Tag_Output_1" a
"1"

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar all√≠ con la
ejecuci√≥n del programa.

MyLABEL: AN "MyTag_2"

// Etiqueta "MyLABEL"
// Consultar si el operando "MyTag_2" es "0" y combinar el resultado l√≥gicamente con Y.

S "Tag_Output_2"

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

// Si RLO="1", poner el operando "Tag_Output_2" a "1"

1709

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado l√≥gicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado l√≥gicamente con Y.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

JUO: Saltar si el resultado no es v√°lido
Descripci√≥n
La instrucci√≥n "Saltar si el resultado no es v√°lido" interrumpe la ejecuci√≥n lineal del programa
en funci√≥n de los bits de estado CC 0 y CC 1 y la contin√∫a en el punto marcado por la etiqueta
indicada.
El salto a la etiqueta indicada se ejecuta solo si el estado l√≥gico de los bits de estado CC 0 y
CC 1 es "1". Esto sucede cuando se cumple una de las condiciones siguientes:
‚óè En una instrucci√≥n matem√°tica (/I, /D, MOD) se divide entre cero.
‚óè En la ejecuci√≥n de una instrucci√≥n matem√°tica con n√∫meros en coma flotante se produce
un desbordamiento y el resultado es un n√∫mero en coma flotante no v√°lido.
‚óè En la ejecuci√≥n de una instrucci√≥n de comparaci√≥n con n√∫meros en coma flotante se ha
empleado un n√∫mero en coma flotante no v√°lido o ha dado como resultado.
En los restantes casos, el salto no se ejecuta y la ejecuci√≥n del programa contin√∫a con la
instrucci√≥n siguiente.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Saltar si el resultado no es v√°lido":

1710

Par√°metro

Descripci√≥n

<Etiqueta>

Nombre simb√≥lico del destino del salto

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1".

L "Tag_Value_2"

// Cargar el valor del operando "Tag_Value_2".

/I

// Dividir el valor del operando "Tag_Value_1" por el
valor del operando "Tag_Value_2".

JUO ERROR

// En una divisi√≥n por cero, saltar a la etiqueta
"ERROR" y continuar all√≠ el procesamiento del programa
// En otro caso, procesar la instrucci√≥n siguiente.

T "Tag_Result"

// Transferir el contenido del acumulador 1 al operando "Tag_Result".

A "MyTag_1"

// Consultar si el operando "MyTag_1" es "1" y combinar el resultado l√≥gicamente con Y.

R "MyTag_1"

// Si el RLO = "1", poner el operando "MyTag_1" a "0".

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar all√≠ con la
ejecuci√≥n del programa.

ERROR: AN "MyTag_1"

// Etiqueta "ERROR"
// Consultar si el operando "MyTag_1" es "0" y combinar el resultado l√≥gicamente con Y.

S "MyTag_1"

// Si el RLO = "1", poner el operando "MyTag_1" a "1"

NEXT: A "MyTag_3"

// Etiqueta "NEXT"
// Consultar si el operando "MyTag_3" es "1" y combinar el resultado l√≥gicamente con Y.

A "MyTag_4"

// Consultar si el operando "MyTag_4" es "1" y combinar el resultado l√≥gicamente con Y.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1711

Instrucciones
4.1 Instrucciones

JL: Definir lista de saltos
Descripci√≥n
La instrucci√≥n "Definir lista de saltos" permite programar una lista compuesta por varias
entradas de la instrucci√≥n "Salto incondicional" (JU). La lista empieza inmediatamente
despu√©s de la instrucci√≥n "Definir lista de saltos" y puede contener un m√°ximo de 255
entradas. La numeraci√≥n de las funciones de salto de la lista empieza por cero. La lista de
saltos debe programarse sin huecos. El final de la lista de saltos se marca con una etiqueta que
se indica en la instrucci√≥n "Definir lista de saltos".
La funci√≥n de salto de la lista que se ejecutar√° depende del valor del byte derecho del
acumulador 1. Si, p. ej., en el acumulador 1 hay el valor "0", se ejecutar√° la primera funci√≥n de
salto. Si el valor del acumulador 1 es "1", se ejecutar√° la segunda funci√≥n de salto. Si el valor
del acumulador "1" es mayor que el n√∫mero de entradas de la lista, la instrucci√≥n "Definir lista
de saltos" remite al final de la lista.
La instrucci√≥n "Distribuidor de saltos" se ejecuta independientemente de las condiciones y no
influye en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value"

// Cargar el n√∫mero de salto en el acumulador 1.

JL END

// Principio de la lista de saltos

JU MyLABEL_1

// Si el valor del acumulador 1 es "0", ejecutar y
saltar a la etiqueta "MyLABEL_1".

JU MyLABEL_2

// Si el valor del acumulador 1 es "1", ejecutar y
saltar a la etiqueta "MyLABEL_2".

JU MyLABEL_3

// Ejecutar con un valor "2" en el acumulador 1 y saltar a la etiqueta "MyLABEL_3".

END: L "MyTag_1"

// Fin de la lista de saltos
// Cargar el contenido del operando "MyTag_1" en el
acumulador 1.

1712

L "MyTag_2"

// Cargar el contenido del operando "MyTag_2" en el
acumulador 1.

+I

// Sumar valores

T "Tag_Output_2"

// Cargar el contenido del acumulador 1 en el operando
"Tag_Output_2".

MyLABEL_1: ...

// Etiqueta "MyLABEL_1"

....

// Cualquier programa

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar all√≠ con la
ejecuci√≥n del programa.

MyLABEL_2: ...

// Etiqueta "MyLABEL_2"

....

// Cualquier programa

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar all√≠ con la
ejecuci√≥n del programa.

MyLABEL_3: ...

// Etiqueta "MyLABEL_3"

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

....

// Cualquier programa

JU NEXT

// Saltar a la etiqueta "NEXT" y continuar all√≠ con la
ejecuci√≥n del programa.

NEXT: ...

// Etiqueta "NEXT"

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Ejemplos de programaci√≥n AWL (P√°gina 8102)

LOOP: Bucle
Descripci√≥n
La instrucci√≥n "Bucle" permite programar bucles.
La instrucci√≥n interpreta la palabra derecha del acumulador 1 como un entero de 16 bits sin
signo en el rango de 0 a 65535. Al ejecutarse, la instrucci√≥n reduce primero en uno el contenido
del acumulador 1. Si el valor del acumulador 1 no es cero despu√©s de decrementar, se ejecuta
el salto hasta la etiqueta indicada. Si el valor es cero, el salto no se ejecuta y la ejecuci√≥n del
programa contin√∫a con la instrucci√≥n siguiente. Por consiguiente, el valor del acumulador 1
determina el n√∫mero de bucles que se ejecutar√°n. Dicho n√∫mero debe guardarse en un
contador de bucles.
El operando <N√∫mero> contiene el n√∫mero de bucles ejecutados. El operando <Contador de
bucles> contiene el n√∫mero de bucles pendientes de ser ejecutados. Al final del bucle, el
contenido del contador de bucles se carga en el acumulador 1 y es decrementado en uno por
la instrucci√≥n. El salto hasta la etiqueta al principio del bucle se ejecuta si el valor del
acumulador no es cero despu√©s de decrementar.
La instrucci√≥n "Bucle" no influye en los bits de estado.
ADVERTENCIA
Asignaci√≥n inicial del contador de bucles
Si al contador de bucles no se le ha asignado ning√∫n valor inicial o se le ha asignado el valor
inicial "0", se va reduciendo hacia el negativo, lo que resulta en un bucle sin fin que puede
provocar el estado operativo STOP de la CPU.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1713

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value"

// Cargar el n√∫mero de ejecuciones de bucle pendientes
en la palabra derecha del acumulador 1.

START: T "Tag_Counter"

// Principio de la lista de saltos
// Transferir el contenido del acumulador 1 al contador de bucles.

L "MyTag_1"

// Cargar el valor del operando "MyTag_1".

L "MyTag_2"

// Cargar el valor del operando "MyTag_2".

*D

// Multiplicar valores

T "MyTag_1"

// Transferir el resultado de la multiplicaci√≥n al
operando "MyTag_1".

L "Tag_Counter"

// Cargar el contenido del contador de bucles en el
acumulador 1.

LOOP START

// Decrementar en uno el valor del acumulador 1.
// Si el valor es distinto de cero, saltar al principio del bucle.
// Si el valor es cero, procesar la instrucci√≥n siguiente.

L "MyTag_2"

// Cargar el valor del operando "MyTag_2".

L 100

// Cargar el valor 100.

>I

// Comparar si el valor del operando "MyTag_2" es mayor que 200.

= "MyTag_3"

// Escribir el resultado de la comparaci√≥n en el operando "MyTag_3".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

1714

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Bloques de datos
OPN: Abrir bloque de datos en el registro DB
Descripci√≥n
La instrucci√≥n "Abrir bloque de datos en el registro DB" permite abrir un bloque de datos global
(DB). El n√∫mero del bloque de datos se transmite al registro del DB. Los siguientes comandos
de DB acceden a los bloques correspondientes en funci√≥n de los contenidos del registro.
La instrucci√≥n "Abrir bloque de datos en el registro DB" se ejecuta independientemente de las
condiciones y no influye en el resultado l√≥gico ni en los contenidos de los acumuladores.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Abrir bloque de datos en el registro
DB":
Operando

Declaraci√≥n

Tipo del bloque de
datos

Descripci√≥n

<Bloque de
datos>

-

DB

Bloque de datos que se abrir√°.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

OPN "GlobalDataBlock"

// Abrir bloque de datos y transferir n√∫mero
del bloque al registro DB.

L %DBW0

// Cargar palabra de datos DBW0 del bloque de
datos global abierto en acumulador 1.

T "MyTag"

// Transferir el contenido del acumulador 1 al
operando "MyTag_1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Bases de AWL (P√°gina 8065)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1715

Instrucciones
4.1 Instrucciones

OPNDI: Abrir bloque de datos en el registro DI
Descripci√≥n
La instrucci√≥n "Abrir bloque de datos en el registro DI" permite abrir un bloque de datos
cualquiera. El n√∫mero del bloque de datos se transmite al registro del DI. Los siguientes
comandos del DI acceden a los bloques correspondientes en funci√≥n de los contenidos del
registro.
Para el direccionamiento simb√≥lico de un par√°metro formal local de la interfaz de bloque,
acceda siempre al bloque de datos cuyo n√∫mero haya indicado al efectuar la llamada de
bloque.
La instrucci√≥n "Abrir bloque de datos en el registro DI" se ejecuta independientemente de las
condiciones y no influye en el resultado l√≥gico ni en los contenidos de los acumuladores.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Abrir bloque de datos en el registro
DI":
Operando

Declaraci√≥n

Tipo del bloque de
datos

Descripci√≥n

<Bloque de
datos>

-

DI

Bloque de datos que se abrir√°.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

OPNDI "DataBlock"

// Abrir bloque de datos y transferir n√∫mero
del bloque de datos al registro DI.

L %DIW0

// Cargar palabra de datos DIW0 del bloque de
datos abierto en acumulador 1.

T "MyTag"

// Transferir el contenido del acumulador 1 al
operando "MyTag".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Bases de AWL (P√°gina 8065)

1716

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CDB: Intercambiar registros de bloques de datos
Descripci√≥n
La instrucci√≥n "Intercambiar registros de bloques de datos" cambia los contenidos de los
registros de los bloques de datos. La instrucci√≥n se ejecuta independientemente de las
condiciones y no influye en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

OPN "GlobalDataBlock"

// Abrir bloque de datos global y transferir
n√∫mero del bloque de datos al registro DB.

OPNDI "DataBlock"

// Abrir bloque de datos y transferir n√∫mero
del bloque de datos al registro DI.

CDB

// Intercambiar registros de bloques de datos
// El registro DB remite a "DataBlock" y el
registro DI remite a "GlobalDataBlock".

L %DIW0

// Cargar DW0 de "GlobalDataBlock" en el acumulador 1.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

L DBLG: Cargar longitud de un bloque de datos global en acumulador 1
Descripci√≥n
La instrucci√≥n "Cargar longitud del bloque de datos global en acumulador 1" carga en el
acumulador 1 la longitud de un bloque de datos global abierto mediante el registro del bloque
de datos. El contenido anterior del acumulador 1 se desplaza al acumulador 2.
Si antes de ejecutar la instrucci√≥n no se ha abierto ning√∫n bloque de datos global mediante el
registro del bloque de datos, se carga el valor "0" en el acumulador 1. La longitud del bloque
de datos es equivalente al n√∫mero de bytes de datos.
La instrucci√≥n no modifica los bits de estado.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1717

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

OPN "GlobalDataBlock"

// Abrir bloque de datos global y transferir
n√∫mero del bloque de datos al registro DB.

L DBLG

// Cargar la longitud de un bloque de datos
abierto en el acumulador 1.

L "MyTag_1"

// Cargar el valor de comparaci√≥n

<D

// Comparar si la longitud del bloque de datos
es menor que el valor del operando "MyTag_1".

= "MyTag_2"

// Escribir el resultado de la consulta en el
operando "MyTag_2".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

L DBNO: Cargar n√∫mero de un bloque de datos global en acumulador 1
Descripci√≥n
La instrucci√≥n "Cargar n√∫mero del bloque de datos global en acumulador 1" carga en el
acumulador 1 el n√∫mero de un bloque de datos global abierto mediante el registro del bloque
de datos. El contenido anterior del acumulador 1 se desplaza al acumulador 2.
Si antes de ejecutar la instrucci√≥n no se ha abierto ning√∫n bloque de datos global mediante el
registro del bloque de datos, se carga el valor "0" en el acumulador 1.
La instrucci√≥n no modifica los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:

1718

AWL

Explicaci√≥n

OPN "GlobalDataBlock"

// Abrir bloque de datos global y transferir
n√∫mero del bloque de datos al registro DB.

L DBNO

// Cargar n√∫mero de un bloque de datos abierto
en acumulador 1.

L "MyTag_1"

// Cargar el valor de comparaci√≥n

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

==I

// Comparar si el n√∫mero del bloque de datos
es igual al valor del operando "MyTag_1".

= "MyTag_2"

// Escribir el resultado de la consulta en el
operando "MyTag_2".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

L DILG: Cargar longitud de un bloque de datos de instancia en acumulador 1
Descripci√≥n
La instrucci√≥n "Cargar longitud del bloque de datos de instancia en acumulador 1" carga en el
acumulador 1 la longitud de un bloque de datos de instancia abierto mediante el registro del
bloque de datos. El contenido anterior del acumulador 1 se desplaza al acumulador 2.
Si antes de ejecutar la instrucci√≥n no se ha abierto ning√∫n bloque de datos de instancia
mediante el registro del bloque de datos, se carga el valor "0" en el acumulador 1. La longitud
del bloque de datos es equivalente al n√∫mero de bytes de datos.
La instrucci√≥n no modifica los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

OPNDI "InstanceDataBlock"

// Abrir bloque de datos y transferir n√∫mero
del bloque de datos al registro DI.

L DILG

// Cargar la longitud de un bloque de datos
abierto en el acumulador 1.

L "MyTag_1"

// Cargar el valor de comparaci√≥n

<I

// Comparar si la longitud del bloque de datos
es menor que el valor del operando "MyTag_1".

= "MyTag_2"

// Escribir el resultado de la consulta en el
operando "MyTag_2".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1719

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

L DINO: Cargar n√∫mero de un bloque de datos de instancia en acumulador 1
Descripci√≥n
La instrucci√≥n "Cargar n√∫mero del bloque de datos de instancia en acumulador 1" carga en el
acumulador 1 el n√∫mero de un bloque de datos de instancia abierto mediante el registro del
bloque de datos. El contenido anterior del acumulador 1 se desplaza al acumulador 2.
Si antes de ejecutar la instrucci√≥n no se ha abierto ning√∫n bloque de datos de instancia
mediante el registro del bloque de datos, se carga el valor "0" en el acumulador 1.
La instrucci√≥n no modifica los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

OPNDI "InstanceDataBlock"

// Abrir bloque de datos y transferir n√∫mero
del bloque de datos al registro DI.

L DINO

// Cargar n√∫mero de un bloque de datos abierto
en acumulador 1.

L "MyTag_1"

// Cargar el valor de comparaci√≥n

==I

// Comparar si el n√∫mero del bloque de datos
es igual al valor del operando "MyTag_1".

= "MyTag_2"

// Asignar el resultado de la consulta al operando "MyTag_2".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

1720

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Bloques l√≥gicos
BE: Fin de bloque
Descripci√≥n
La instrucci√≥n "Fin de bloque" finaliza el procesamiento del bloque actual y pasa al punto del
programa en el que se llama el bloque. El procesamiento del programa contin√∫a con la
instrucci√≥n que se encuentra justo despu√©s de la llamada del bloque.
La instrucci√≥n "Fin de bloque" se ejecuta siempre, independientemente de las condiciones. Si
el procesamiento de la instrucci√≥n se salta debido a una instrucci√≥n de salto, la ejecuci√≥n
actual del programa no finaliza, sino que contin√∫a en el destino del salto dentro del bloque.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

SIN

// Calcular el seno
// Guardar el resultado en el acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

*R

// Multiplicar los valores de los acumuladores 1 y 2.
// Guardar el producto en el acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en el
acumulador 1.

*R

// Multiplicar los valores de los acumuladores 1 y 2.
// Guardar el producto en el acumulador 1.

T "Tag_Result"

// Transferir el contenido del acumulador 1 al operando "Tag_Result".

BE

// Finalizar bloque

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1721

Instrucciones
4.1 Instrucciones
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

BEC: Fin de bloque condicional
Descripci√≥n
La instrucci√≥n "Fin de bloque condicional" finaliza el procesamiento del bloque actual en
funci√≥n del resultado l√≥gico (RLO) y pasa al punto del programa en el que se llama el bloque.
Si el RLO es "1", se ejecuta la instrucci√≥n. El bloque actual se finaliza y la ejecuci√≥n del
programa contin√∫a en el bloque que efect√∫a la llamada. El procesamiento del programa
contin√∫a con la instrucci√≥n que se encuentra justo despu√©s de la llamada del bloque.
Si el RLO es "0" al procesar la instrucci√≥n, esta no se ejecuta. En este caso, la CPU pone el
RLO a "1" y procesa la instrucci√≥n siguiente.
Si el procesamiento de la instrucci√≥n se salta debido a una instrucci√≥n de salto, la ejecuci√≥n
actual del programa no finaliza, sino que contin√∫a en el destino del salto dentro del bloque.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

>I

// Comparar si el valor del acumulador 2 es mayor que
el valor del acumulador 1.

A "Tag_Input"

// Consultar si el operando "Tag_Input" es "1" y combinar el resultado l√≥gicamente con Y con el RLO.

BEC

// Si la condici√≥n se cumple (RLO = "1"), finalizar el
bloque.
// Si la condici√≥n no se cumple (RLO = "0"), procesar
la instrucci√≥n siguiente.

T "Tag_Result"

// Transferir el contenido del acumulador 1 al operando "Tag_Result".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)

1722

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

BEU: Fin de bloque incondicional
Descripci√≥n
La instrucci√≥n "Fin de bloque incondicional" finaliza el procesamiento del bloque actual y pasa
al punto del programa en el que se llama el bloque. El procesamiento del programa contin√∫a
con la instrucci√≥n que se encuentra justo despu√©s de la llamada del bloque.
La instrucci√≥n "Fin de bloque incondicional" se ejecuta siempre, independientemente de las
condiciones, y se puede programar varias veces dentro de un bloque. Si el procesamiento de
la instrucci√≥n se salta debido a una instrucci√≥n de salto, la ejecuci√≥n actual del programa no
finaliza, sino que contin√∫a en el destino del salto dentro del bloque.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

>I

// Comparar si el valor del acumulador 2 es mayor que
el valor del acumulador 1.

A "Tag_Input"

// Consultar si el operando "Tag_Input" es "1" y combinar el resultado l√≥gicamente con Y con el RLO.

JC NEXT

// Si la condici√≥n se cumple (RLO = "1"), continuar el
procesamiento del programa a partir de la etiqueta
"NEXT".
// Si la condici√≥n no se cumple (RLO = "0"), procesar
la instrucci√≥n siguiente.

BEU

// Finalizar bloque

NEXT: T "Tag_Result"

// Etiqueta "NEXT"
// Transferir el contenido del acumulador 1 al operando "Tag_Result".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1723

Instrucciones
4.1 Instrucciones
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Ejemplos de programaci√≥n AWL (P√°gina 8102)

CALL: Llamar bloque
Descripci√≥n
La instrucci√≥n "Llamar bloque" llama los siguientes tipos de bloque en el programa:
‚óè Funciones
‚óè Bloques de funci√≥n
La instrucci√≥n "Llamar bloque" se ejecuta siempre, independientemente de las condiciones.
Tras ejecutar la instrucci√≥n, el procesamiento del programa contin√∫a en el bloque llamado.
Existe la posibilidad de suministrar datos a un bloque llamado. Los datos se transfieren
mediante los par√°metros del bloque. Los par√°metros del bloque llamado se listan en el bloque
que efect√∫a la llamada despu√©s de la instrucci√≥n de llamada. Es posible asignarles los
par√°metros actuales necesarios. Al ejecutar la instrucci√≥n "Llamar bloque", los datos se
transfieren al bloque llamado. Con la transmisi√≥n de los datos se modifican los contenidos
tanto de la palabra de estado como del registro de direcciones y del de los bloques de datos.
Los par√°metros de un bloque de funci√≥n que no reciben valores nuevos conservan su valor
actual. Al llamar funciones deben suministrarse valores a todos los par√°metros. Si un bloque
llamado no tiene par√°metros, no se muestra la lista de par√°metros.
Si el bloque llamado requiere un bloque de datos de instancia, √©ste debe indicarse en la
llamada, separado por una coma. El bloque de datos indicado debe haberse creado antes de
la llamada.
Una vez procesado el bloque llamado, la CPU vuelve al bloque que efect√∫a la llamada y
contin√∫a con el procesamiento de dicho bloque despu√©s de la instrucci√≥n de llamada.
Nota
La instrucci√≥n "Llamar bloque" solo puede utilizarse si est√° activada la propiedad del bloque
"Alimentaci√≥n de par√°metros a trav√©s de registros".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

CALL "MyFunction"

// Llamar la funci√≥n "MyFunction"

Input_1 := "Tag_Input_1",

// Asignar par√°metros actuales

Input_2 := "Tag_Input_2"
Output_1 := "Tag_Output_1"
Output_2 := "Tag_Output_1"

1724

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

CALL "MyFunctionBlock", "MyFB_DB"
Value_1 := "Tag_Value_1"

// Llamar el bloque de funci√≥n "MyFunctionBlock"

Value_2 := "Tag_Value_2"

// Asignar par√°metros actuales

Output := "Tag_Output"
CALL "LIMIT"
MN := "Tag_LowLimit"

// Llamar la instrucci√≥n "Ajustar valor l√≠mite"

IN := "Tag_InputValue"

// Asignar par√°metros actuales

MX := "Tag_HighLimit"
OUT := "Tag_Output"
CALL "CTU", "CTU_DB"
CU := "Tag_StartCTU"

// Llamar el contador "Contador ascendente"
// Asignar par√°metros actuales

R := "Tag_ResetCounter"
PV := "Tag_PresetValue"
Q := "Tag_CounterStatus"
CV := "Tag_CounterValue"

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Bases de AWL (P√°gina 8065)

CC: Llamada condicional
Descripci√≥n
La instrucci√≥n "Llamada condicional" llama en funci√≥n del resultado l√≥gico (RLO) funciones
(FC) y bloques de funci√≥n (FB) que no tienen par√°metros ni bloques de datos de instancia.
La instrucci√≥n solo se ejecuta si el resultado l√≥gico (RLO) actual antes de procesar la
instrucci√≥n es "1". Tras ejecutar la instrucci√≥n, el procesamiento del programa contin√∫a en el
bloque llamado. Una vez procesado el bloque llamado, la CPU vuelve al bloque que efect√∫a la
llamada y contin√∫a con el procesamiento de dicho bloque despu√©s de la instrucci√≥n de llamada.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1725

Instrucciones
4.1 Instrucciones
Al cambiar el bloque, el bit de estado OS se pone a "0". Los bits de estado CC 0, CC 1 y OV
se ven influidos en funci√≥n del bloque invocante.
Nota
La instrucci√≥n "Llamada condicional" solo puede utilizarse cuando est√° activada la propiedad
del bloque "Alimentaci√≥n de par√°metros a trav√©s de registros". Sin embargo, de este modo se
reduce el rendimiento.
La instrucci√≥n "Llamada condicional" no modifica el contenido de los acumuladores ni los
registros de direcciones.
Si el RLO actual es "0", la instrucci√≥n y, por consiguiente, la llamada de bloque no se ejecutan
y el RLO se pone a "1".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

A "Tag_Input_1"

// Consultar si el operando "Tag_Input_1" es
"1" y combinar el resultado l√≥gicamente con Y
con el RLO actual.

CC "MyFunction"

// Si la condici√≥n se cumple (RLO = "1"), llamar la funci√≥n "MyFunction".
// Si la condici√≥n no se cumple (RLO = "0"),
procesar la instrucci√≥n siguiente.

A "Tag_Input_2"

// Consultar si el operando "Tag_Input_2" es
"1" y combinar el resultado l√≥gicamente con Y
con el RLO actual.

CC "MyFunctionBlock"

// Si la condici√≥n se cumple (RLO = "1"), llamar el bloque de funci√≥n "MyFunctionBlock".
// Si la condici√≥n no se cumple (RLO = "0"),
procesar la instrucci√≥n siguiente.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Sinopsis de las propiedades de bloques (P√°gina 7740)
Alimentaci√≥n de par√°metros a trav√©s de registros en la llamada de bloques en AWL
(P√°gina 8067)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

1726

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

UC: Llamada incondicional
Descripci√≥n
La instrucci√≥n "Llamada incondicional" llama funciones (FC) y bloques de funci√≥n (FB) que no
tienen par√°metros ni bloques de datos de instancia.
Esta instrucci√≥n se ejecuta independientemente de las condiciones. Tras ejecutar la
instrucci√≥n, el procesamiento del programa contin√∫a en el bloque llamado. Una vez procesado
el bloque llamado, la CPU vuelve al bloque que efect√∫a la llamada y contin√∫a con el
procesamiento de dicho bloque despu√©s de la instrucci√≥n de llamada.
Al cambiar el bloque, el bit de estado OS se pone a "0". Los bits de estado CC 0, CC 1 y OV
se ven influidos en funci√≥n del bloque invocante.
Nota
La instrucci√≥n "Llamada incondicional" solo puede utilizarse cuando est√° activada la propiedad
del bloque "Alimentaci√≥n de par√°metros a trav√©s de registros". Sin embargo, de este modo se
reduce el rendimiento.
La instrucci√≥n "Llamada incondicional" no modifica el contenido de los acumuladores ni los
registros de direcciones.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

A "Tag_Input_1"

// Consultar si el operando "Tag_Input_1" es
"1" y combinar el resultado l√≥gicamente con Y
con el RLO actual.

UC "MyFunction"

// Llamar la funci√≥n "MyFunction".

A "Tag_Input_2"

// Consultar si el operando "Tag_Input_2" es
"1" y combinar el resultado l√≥gicamente con Y
con el RLO actual.

UC "MyFunctionBlock"

// Llamar el bloque de funci√≥n "MyFunctionBlock".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Sinopsis de las propiedades de bloques (P√°gina 7740)
Alimentaci√≥n de par√°metros a trav√©s de registros en la llamada de bloques en AWL
(P√°gina 8067)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1727

Instrucciones
4.1 Instrucciones
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

Operaciones l√≥gicas con palabras
AW: Operaci√≥n l√≥gica Y por palabras
Descripci√≥n
La instrucci√≥n "Operaci√≥n l√≥gica Y por palabras" combina l√≥gicamente con Y por bits el valor
de la palabra derecha del acumulador 1 con el valor de la palabra derecha del acumulador 2
o una constante concreta. El resultado se guarda en la palabra derecha del acumulador 1. El
contenido de la palabra izquierda del acumulador 1 no cambia.
La instrucci√≥n combina el bit 0 del acumulador 1 con el bit 0 del acumulador 2 o una constante
y guarda el resultado en el bit 0 del acumulador 1. Los bits 1 a 15 se combinan del mismo modo.
El estado l√≥gico del bit de resultado es "1" si el estado l√≥gico de los dos bits que deben
combinarse l√≥gicamente tambi√©n es "1". Si el estado l√≥gico de uno de los bits que deben
combinarse l√≥gicamente es "0", se desactivar√° el bit de resultado correspondiente.
La tabla siguiente muestra c√≥mo se forma el resultado en una operaci√≥n l√≥gica Y por palabras:
Acumulador 2 /
constante

0

0

1

1

Acumulador 1

0

1

0

1

Resultado

0

0

0

1

La instrucci√≥n se ejecuta independientemente de las condiciones y no influye en el resultado
l√≥gico.
La instrucci√≥n influye en los bits de estado CC 0, CC 1 y OV.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Operaci√≥n l√≥gica Y por palabras":
Par√°metro

Tipo de datos Descripci√≥n

<Constante>

WORD

Valor que se combina l√≥gicamente con Y con el valor que se encuentra
en la palabra derecha del acumulador 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:

1728

AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en la palabra derecha
del acumulador 1.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

AW W#16#F6B5

// Combinar l√≥gicamente con Y el valor de la palabra
derecha del acumulador 1 con la constante (W#16#F6B5).
// El resultado se guarda en la palabra derecha del
acumulador 1.

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

L "Tag_Value_2"

// Cargar el valor del operando en la palabra derecha
del acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en la
palabra derecha del acumulador 1.

AW

// Combinar l√≥gicamente con Y el valor de la palabra
derecha del acumulador 2 ("Tag_Value_2") con el valor
de la palabra derecha del acumulador 1 ("Tag_Value_3").
// El resultado se guarda en la palabra derecha del
acumulador 1.

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando
Tag_Value_1

Valor
0101

1001

0011

1011

Constante (W#16#F6B5) 1111

0110

1011

0101

Tag_Result_1

0000

0011

0001

0101

Tag_Value_2

0110

1100

0010

1010

Tag_Value_3

1101

1010

1001

0011

Tag_Result_2

0100

1000

0000

0010

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Activar el bit de estado en operaciones l√≥gicas con palabras (P√°gina 202)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Ejemplos de programaci√≥n AWL (P√°gina 8102)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1729

Instrucciones
4.1 Instrucciones

OW: Operaci√≥n l√≥gica O por palabras
Descripci√≥n
La instrucci√≥n "Operaci√≥n l√≥gica O por palabras" combina l√≥gicamente con O por bits el valor
de la palabra derecha del acumulador 1 con el valor de la palabra derecha del acumulador 2
o una constante concreta. El resultado se guarda en la palabra derecha del acumulador 1. El
contenido de la palabra izquierda del acumulador 1 no cambia.
La instrucci√≥n combina el bit 0 del acumulador 1 con el bit 0 del acumulador 2 o una constante
y guarda el resultado en el bit 0 del acumulador 1. Los bits 1 a 15 se combinan del mismo modo.
El estado l√≥gico del bit de resultado es "1" si el estado l√≥gico de como m√≠nimo uno de los dos
bits que deben combinarse l√≥gicamente tambi√©n es "1". Si el estado l√≥gico de los dos bits que
deben combinarse l√≥gicamente es "0", el bit de resultado correspondiente se pondr√° a "0".
La tabla siguiente muestra c√≥mo se forma el resultado en una operaci√≥n l√≥gica O por palabras:
Acumulador 2 /
constante

0

0

1

1

Acumulador 1

0

1

0

1

Resultado

0

1

1

1

La instrucci√≥n se ejecuta independientemente de las condiciones y no influye en el resultado
l√≥gico.
La instrucci√≥n influye en los bits de estado CC 0, CC 1 y OV.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Operaci√≥n l√≥gica O por palabras":
Par√°metro

Tipo de datos Descripci√≥n

<Constante>

WORD

Valor que se combina l√≥gicamente con O con el valor que se encuentra
en la palabra derecha del acumulador 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en la palabra derecha
del acumulador 1.

OW W#16#F6B5

// Combinar l√≥gicamente con O el valor de la palabra
derecha del acumulador 1 con la constante (W#16#F6B5).
// El resultado se guarda en la palabra derecha del
acumulador 1.

1730

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

L "Tag_Value_2"

// Cargar el valor del operando en la palabra derecha
del acumulador 1.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en la
palabra derecha del acumulador 1.

OW

// Combinar l√≥gicamente con O el valor de la palabra
derecha del acumulador 2 ("Tag_Value_2") con el valor
de la palabra derecha del acumulador 1 ("Tag_Value_3").
// El resultado se guarda en la palabra derecha del
acumulador 1.

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando
Tag_Value_1

Valor
0101

1001

0011

1011

Constante (W#16#F6B5) 1111

0110

1011

0101

Tag_Result_1

1111

1111

1011

1111

Tag_Value_2

0110

1100

0010

1010

Tag_Value_3

1101

1010

1001

0011

Tag_Result_2

1111

1110

1011

1011

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Activar el bit de estado en operaciones l√≥gicas con palabras (P√°gina 202)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Ejemplos de programaci√≥n AWL (P√°gina 8102)

XOW: Operaci√≥n l√≥gica O-exclusiva por palabras
Descripci√≥n
La instrucci√≥n "Operaci√≥n l√≥gica O-exclusiva por palabras" combina l√≥gicamente con Oexclusiva por bits el valor de la palabra derecha del acumulador 1 con el valor de la palabra
derecha del acumulador 2 o una constante concreta. El resultado se guarda en la palabra
derecha del acumulador 1. El contenido de la palabra izquierda del acumulador 1 no cambia.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1731

Instrucciones
4.1 Instrucciones
La instrucci√≥n combina el bit 0 del acumulador 1 con el bit 0 del acumulador 2 o una constante
y guarda el resultado en el bit 0 del acumulador 1. Los bits 1 a 15 se combinan del mismo modo.
El estado l√≥gico del bit de resultado es "1" si el estado l√≥gico de los dos bits que deben
combinarse l√≥gicamente es diferente. Si el estado l√≥gico de los dos bits que deben combinarse
l√≥gicamente es el mismo, el bit de resultado correspondiente se pondr√° a "0".
La tabla siguiente muestra c√≥mo se forma el resultado en una operaci√≥n l√≥gica O-exclusiva por
palabras:
Acumulador 2 /
constante

0

0

1

1

Acumulador 1

0

1

0

1

Resultado

0

1

1

0

La instrucci√≥n se ejecuta independientemente de las condiciones y no influye en el resultado
l√≥gico.
La instrucci√≥n influye en los bits de estado CC 0, CC 1 y OV.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Operaci√≥n l√≥gica O-exclusiva por
palabras":
Par√°metro

Tipo de datos Descripci√≥n

<Constante>

WORD

Valor que se combina l√≥gicamente con O-exclusiva con el valor que se
encuentra en la palabra derecha del acumulador 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en la palabra derecha
del acumulador 1.

XOW W#16#F6B5

// Combinar l√≥gicamente con O-exclusiva el valor de la
palabra derecha del acumulador 1 con la constante
(W#16#F6B5).
// El resultado se guarda en la palabra derecha del
acumulador 1.

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

L "Tag_Value_2"

// Cargar el valor del operando en la palabra derecha
del acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en la
palabra derecha del acumulador 1.

1732

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

XOW

// Combinar l√≥gicamente con O-exclusiva el valor de la
palabra derecha del acumulador 2 ("Tag_Value_2") con
el valor de la palabra derecha del acumulador 1
("Tag_Value_3").
// El resultado se guarda en la palabra derecha del
acumulador 1.

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando
Tag_Value_1

Valor
0101

1001

0011

1011

Constante (W#16#F6B5) 1111

0110

1011

0101

Tag_Result_1

1010

1111

1000

1110

Tag_Value_2

0110

1100

0010

1010

Tag_Value_3

1101

1010

1001

0011

Tag_Result_2

1011

0110

1011

1001

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Activar el bit de estado en operaciones l√≥gicas con palabras (P√°gina 202)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

AD: Operaci√≥n l√≥gica Y por palabras dobles
Descripci√≥n
La instrucci√≥n "Operaci√≥n l√≥gica Y por palabras dobles" combina l√≥gicamente con Y por bits el
contenido del acumulador 1 con el contenido del acumulador 2 o el valor de una constante
concreta. El resultado se guarda en el acumulador 1.
La instrucci√≥n combina el bit 0 del acumulador 1 con el bit 0 del acumulador 2 o una constante
y guarda el resultado en el bit 0 del acumulador 1. Los bits 1 a 31 se combinan del mismo modo.
El estado l√≥gico del bit de resultado es "1" si el estado l√≥gico de los dos bits que deben
combinarse l√≥gicamente tambi√©n es "1". Si el estado l√≥gico de uno de los bits que deben
combinarse l√≥gicamente es "0", se desactivar√° el bit de resultado correspondiente.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1733

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra c√≥mo se forma el resultado en una operaci√≥n l√≥gica Y por palabras:
Acumulador 2 /
constante

0

0

1

1

Acumulador 1

0

1

0

1

Resultado

0

0

0

1

La instrucci√≥n se ejecuta independientemente de las condiciones y no influye en el resultado
l√≥gico.
La instrucci√≥n influye en los bits de estado CC 0, CC 1 y OV.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Operaci√≥n l√≥gica Y por palabras
dobles":
Par√°metro

Tipo de datos Descripci√≥n

<Constante>

DWORD

Valor que se combina l√≥gicamente con Y con el valor que est√° en el
acumulador 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

AD DW#16#39C657AC

// Combinar l√≥gicamente con Y el valor del acumulador
1 con la constante (DW#16#39C657AC).
// Guardar el resultado en el acumulador 1.

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

L "Tag_Value_2"

// Cargar el valor del operando en el acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en el
acumulador 1.

AD

// Combinar l√≥gicamente con Y el valor del acumulador
2 ("Tag_Value_2") con el valor del acumulador 1
("Tag_Value_3").
// Guardar el resultado en el acumulador 1.

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

1734

Valor

Tag_Value_1 0101

1111

0110

0100

1001

1101

0011

1011

Constante
(DW#16#39
C657AC)

1001

1100

0110

0101

0111

1010

1100

0011

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Operando
Tag_Re‚Äê
sult_1

Valor
0001

1001

0100

0100

0001

0101

0010

1000

Tag_Value_2 0110

0101

0100

0011

0101

1101

0010

1011

Tag_Value_3 0011

1001

1100

0110

0101

0111

1010

1100

Tag_Re‚Äê
sult_2

0001

0100

0010

0101

0101

0010

1010

0010

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Activar el bit de estado en operaciones l√≥gicas con palabras (P√°gina 202)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

OD: Operaci√≥n l√≥gica O por palabras dobles
Descripci√≥n
La instrucci√≥n "Operaci√≥n l√≥gica O por palabras dobles" combina l√≥gicamente con O por bits
el contenido del acumulador 1 con el contenido del acumulador 2 o el valor de una constante
concreta. El resultado se guarda en el acumulador 1.
La instrucci√≥n combina el bit 0 del acumulador 1 con el bit 0 del acumulador 2 o una constante
y guarda el resultado en el bit 0 del acumulador 1. Los bits 1 a 31 se combinan del mismo modo.
El estado l√≥gico del bit de resultado es "1" si el estado l√≥gico de como m√≠nimo uno de los dos
bits que deben combinarse l√≥gicamente tambi√©n es "1". Si el estado l√≥gico de los dos bits que
deben combinarse l√≥gicamente es "0", el bit de resultado correspondiente se pondr√° a "0".
La tabla siguiente muestra c√≥mo se forma el resultado en una operaci√≥n l√≥gica O por palabras:
Acumulador 2 /
constante

0

0

1

1

Acumulador 1

0

1

0

1

Resultado

0

1

1

1

La instrucci√≥n se ejecuta independientemente de las condiciones y no influye en el resultado
l√≥gico.
La instrucci√≥n influye en los bits de estado CC 0, CC 1 y OV.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1735

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Operaci√≥n l√≥gica O por palabras
dobles":
Par√°metro

Tipo de datos Descripci√≥n

<Constante>

DWORD

Valor que se combina l√≥gicamente con O con el valor que est√° en el
acumulador 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

OD DW#16#39C657AC

// Combinar l√≥gicamente con O el valor del acumulador
1 con la constante (DW#16#39C657AC).
// Guardar el resultado en el acumulador 1.

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

L "Tag_Value_2"

// Cargar el valor del operando en el acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en el
acumulador 1.

OD

// Combinar l√≥gicamente con O el valor del acumulador
2 ("Tag_Value_2") con el valor del acumulador 1
("Tag_Value_3").
// Guardar el resultado en el acumulador 1

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

1736

Valor

Tag_Value_1 0101

1111

0110

0100

1001

1101

0011

1011

Constante
(DW#16#39
C657AC)

0011

1001

1100

0110

0101

0111

1010

1100

Tag_Re‚Äê
sult_1

0111

1111

1110

0110

1101

1111

1011

1111

Tag_Value_2 0110

0101

0100

0011

0101

1101

0010

1011

Tag_Value_3 0011

1001

1100

0110

0101

0111

1010

1100

Tag_Re‚Äê
sult_2

1101

1100

0111

0101

1111

1110

1111

0111

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Activar el bit de estado en operaciones l√≥gicas con palabras (P√°gina 202)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

XOD: Operaci√≥n l√≥gica O-exclusiva por palabras dobles
Descripci√≥n
La instrucci√≥n "Operaci√≥n l√≥gica O-exclusiva por palabras dobles" combina l√≥gicamente con
O-exclusiva por bits el contenido del acumulador 1 con el contenido del acumulador 2 o el valor
de una constante concreta. El resultado se guarda en el acumulador 1.
La instrucci√≥n combina el bit 0 del acumulador 1 con el bit 0 del acumulador 2 o una constante
y guarda el resultado en el bit 0 del acumulador 1. Los bits 1 a 31 se combinan del mismo modo.
El estado l√≥gico del bit de resultado es "1" si el estado l√≥gico de los dos bits que deben
combinarse l√≥gicamente es diferente. Si el estado l√≥gico de los dos bits que deben combinarse
l√≥gicamente es el mismo, el bit de resultado correspondiente se pondr√° a "0".
La tabla siguiente muestra c√≥mo se forma el resultado en una operaci√≥n l√≥gica O-exclusiva por
palabras:
Acumulador 2 /
constante

0

0

1

1

Acumulador 1

0

1

0

1

Resultado

0

1

1

0

La instrucci√≥n se ejecuta independientemente de las condiciones y no influye en el resultado
l√≥gico.
La instrucci√≥n influye en los bits de estado CC 0, CC 1 y OV.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Operaci√≥n l√≥gica O-exclusiva por
palabras dobles":
Par√°metro

Tipo de datos Descripci√≥n

<Constante>

DWORD

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Valor que se combina l√≥gicamente con O-exclusiva con el valor que
est√° en el acumulador 1.

1737

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

XOD DW#16#39C657AC

// Combinar l√≥gicamente con O-exclusiva el valor del
acumulador 1 con la constante (DW#16#39C657AC).
// Guardar el resultado en el acumulador 1.

T "Tag_Result_1"

// Transferir el resultado al operando "Tag_Result_1".

L "Tag_Value_2"

// Cargar el valor del operando en el acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en el
acumulador 1.

XOD

// Combinar l√≥gicamente con O-exclusiva el valor del
acumulador 2 ("Tag_Value_2") con el valor del acumulador 1 ("Tag_Value_3").
// Guardar el resultado en el acumulador 1.

T "Tag_Result_2"

// Transferir el resultado al operando "Tag_Result_2".

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

1001

1101

0011

1011

Constante
(DW#16#39
C657AC)

0011

1001

1100

0110

0101

0111

1010

1100

Tag_Re‚Äê
sult_1

0110

0110

1010

0010

1100

1010

1001

0111

Tag_Value_2 0110

0101

0100

0011

0101

1101

0010

1011

Tag_Value_3 0011

1001

1100

0110

0101

0111

1010

1100

Tag_Re‚Äê
sult_2

1100

1000

0101

0000

1010

1000

0111

0101

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Activar el bit de estado en operaciones l√≥gicas con palabras (P√°gina 202)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

1738

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Desplazamiento y rotaci√≥n
Desplazar
SSI: Desplazar con signo por palabras
Descripci√≥n
La instrucci√≥n "Desplazar con signo por palabras" desplaza bit por bit la palabra derecha (bits
de 0 a 15) del acumulador 1 hacia la derecha. Las posiciones que quedan libres al desplazar
se rellenan con el estado l√≥gico del bit 15 (bit con signo en n√∫meros INT). Los bits 16 a 31 del
acumulador 1 no cambian. Esta instrucci√≥n se ejecuta independientemente del RLO. El bit de
estado A1 se ajusta al estado l√≥gico del √∫ltimo bit desplazado.
Para indicar el n√∫mero de posiciones de bit que se desplazar√°n existen las posibilidades
siguientes:
‚óè Indicaci√≥n de un entero positivo como par√°metro de la instrucci√≥n. (<N√∫mero>)
‚óè Indicaci√≥n mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
‚óè SSI <N√∫mero>: El operando <N√∫mero> indica el n√∫mero de desplazamiento. Se permiten
valores entre 0 y 15. Los bits de estado A0 y OV se ponen a "0" si <N√∫mero> es mayor que
cero.
‚óè SSI: El valor del acumulador 2 indica el n√∫mero de desplazamiento. Se permiten valores
entre 0 y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2
es mayor que cero.
Si el n√∫mero de desplazamiento indicado es mayor que 15, todos los bits de la palabra
derecha del acumulador 1 se rellenar√°n con el estado l√≥gico del bit 15.
Aunque el n√∫mero de desplazamiento indicado sea cero, la instrucci√≥n se ejecuta. El bit de
estado CC 1 se pone a "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Formato

Descripci√≥n

<N√∫mero>

Enteros posi‚Äê N√∫mero de posiciones de bit que se desplazar√°n.
tivos:
SINT, INT,
UINT, USINT

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1739

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

SSI 6

// Desplazar los bits 0 a 15 del acumulador 1 seis posiciones a la derecha.
// Rellenar las posiciones liberadas con el estado del
bit 15.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 3

// Cargar el n√∫mero de desplazamiento en el acumulador
1.

L "Tag_Value_2"

// Desplazar el n√∫mero de desplazamiento al byte derecho del acumulador 2.
// Cargar el valor del operando en el acumulador 1.

SSI

// Desplazar los bits 0 a 15 del acumulador 1 tres posiciones a la derecha.
// Rellenar las posiciones liberadas con el estado del
bit 15.

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

1001

1101

0011

1011

Tag_Re‚Äê
sult_1

0101

1111

0110

0100

1111

1110

0111

0100

Tag_Value_2 0101

1111

0110

0100

0101

1101

0010

1011

Tag_Re‚Äê
sult_2

1111

0110

0100

0000

1011

1010

0101

0101

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Bases de AWL (P√°gina 8065)

1740

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

SSD: Desplazar con signo por palabras dobles
Descripci√≥n
La instrucci√≥n "Desplazar con signo por palabras dobles" desplaza bit por bit todo el contenido
del acumulador 1 hacia la derecha. Las posiciones que quedan libres al desplazar se rellenan
con el estado l√≥gico del bit 31 (bit con signo en n√∫meros DINT). Esta instrucci√≥n se ejecuta
independientemente del RLO. El bit de estado A1 se ajusta al estado l√≥gico del √∫ltimo bit
desplazado.
Para indicar el n√∫mero de posiciones de bit que se desplazar√°n existen las posibilidades
siguientes:
‚óè Indicaci√≥n de un entero positivo como par√°metro de la instrucci√≥n. (<N√∫mero>)
‚óè Indicaci√≥n mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
‚óè SSD <N√∫mero>: El operando <N√∫mero> indica el n√∫mero de desplazamiento. Se permiten
valores entre 0 y 31. Los bits de estado A0 y OV se ponen a "0" si <N√∫mero> es mayor que
cero.
‚óè SSD: El valor del acumulador 2 indica el n√∫mero de desplazamiento. Se permiten valores
entre 0 y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2
es mayor que cero.
Con valores mayores que 31, todos los bits del acumulador 1 se rellenan con el estado
l√≥gico del bit 31.
Aunque el n√∫mero de desplazamiento indicado sea cero, la instrucci√≥n se ejecuta. El bit de
estado CC 1 se pone a "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Desplazar con signo por palabras
dobles":
Par√°metro

Formato

Descripci√≥n

<N√∫mero>

Enteros posi‚Äê N√∫mero de posiciones de bit que se desplazar√°n.
tivos:
SINT, INT,
UINT,
USINT,

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1741

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

SSD 7

// Desplazar los bits 0 a 31 del acumulador 1 siete
posiciones a la derecha.
// Rellenar las posiciones liberadas con el estado del
bit 31.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 4

// Cargar el n√∫mero de desplazamiento en el acumulador
1.

L "Tag_Value_2"

// Desplazar el n√∫mero de desplazamiento al byte derecho del acumulador 2.
// Cargar el valor del operando en el acumulador 1.

SSD

// Desplazar los bits 0 a 31 del acumulador 1 cuatro
posiciones a la derecha.
// Rellenar las posiciones liberadas con el estado del
bit 31.

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 1000

1111

0110

0100

0101

1101

0011

1011

Tag_Re‚Äê
sult_1

1111

1111

0001

1110

1100

1000

1011

1010

Tag_Value_2 0010

1000

1010

0010

1001

1011

1100

1101

Tag_Re‚Äê
sult_2

0010

1000

1010

0010

1001

1011

1100

0000

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Bases de AWL (P√°gina 8065)

SLW: Desplazar a la izquierda por palabras
Descripci√≥n
La instrucci√≥n "Desplazar a la izquierda por palabras" desplaza bit por bit la palabra derecha
(bits 0 a 15) del acumulador 1 hacia la izquierda. Las posiciones que quedan libres al desplazar
se rellenan con ceros. Los bits 16 a 31 del acumulador 1 no cambian. Esta instrucci√≥n se
ejecuta independientemente del RLO. El bit de estado A1 se ajusta al estado l√≥gico del √∫ltimo
bit desplazado.

1742

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para indicar el n√∫mero de posiciones de bit que se desplazar√°n existen las posibilidades
siguientes:
‚óè Indicaci√≥n de un entero positivo como par√°metro de la instrucci√≥n. (<N√∫mero>)
‚óè Indicaci√≥n mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
‚óè SLW <N√∫mero>: El operando <N√∫mero> indica el n√∫mero de desplazamiento. Se permiten
valores entre 0 y 15. Los bits de estado A0 y OV se ponen a "0" si <N√∫mero> es mayor que
cero.
‚óè SLW: El valor del acumulador 2 indica el n√∫mero de desplazamiento. Se permiten valores
entre 0 y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2
es mayor que cero.
Si el n√∫mero de desplazamiento indicado es mayor que 15, todos los bits de la palabra
derecha del acumulador 1 se rellenar√°n con ceros.
Aunque el n√∫mero de desplazamiento indicado sea cero, la instrucci√≥n se ejecuta. El bit de
estado CC 1 se pone a "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Desplazar a la izquierda por
palabras":
Par√°metro

Formato

Descripci√≥n

<N√∫mero>

Enteros posi‚Äê N√∫mero de posiciones de bit que se desplazar√°n.
tivos: SINT,
INT, UINT,
USINT

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

SLW 5

// Desplazar los bits 0 a 15 del acumulador 1 cinco
posiciones a la izquierda.
// Rellenar las posiciones liberadas con ceros.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 4

// Cargar el n√∫mero de desplazamiento en el acumulador
1.

L "Tag_Value_2"

// Desplazar el n√∫mero de desplazamiento al byte derecho del acumulador 2.
// Cargar el valor del operando en el acumulador 1.

SLW

// Desplazar los bits 0 a 15 del acumulador 1 cuatro
posiciones a la izquierda.
// Rellenar las posiciones liberadas con ceros.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1743

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‚Äê
sult_1

0101

1111

0110

0100

1010

0111

0110

0000

Tag_Value_2 0101

1111

0110

0100

0101

1101

0010

1011

Tag_Re‚Äê
sult_2

1111

0110

0100

1101

0010

1011

0000

0101

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Bases de AWL (P√°gina 8065)

SRW: Desplazar a la derecha por palabras
Descripci√≥n
La instrucci√≥n "Desplazar a la derecha por palabras" desplaza bit por bit la palabra derecha
(bits 0 a 15) del acumulador 1 hacia la derecha. Las posiciones que quedan libres al desplazar
se rellenan con ceros. Los bits 16 a 31 del acumulador 1 no cambian. Esta instrucci√≥n se
ejecuta independientemente del RLO. El bit de estado A1 se ajusta al estado l√≥gico del √∫ltimo
bit desplazado.
Para indicar el n√∫mero de posiciones de bit que se desplazar√°n existen las posibilidades
siguientes:
‚óè Indicaci√≥n de un entero positivo como par√°metro de la instrucci√≥n. (<N√∫mero>)
‚óè Indicaci√≥n mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
‚óè SRW <N√∫mero>: El operando <N√∫mero> indica el n√∫mero de desplazamiento. Se permiten
valores entre 0 y 15. Los bits de estado A0 y OV se ponen a "0" si <N√∫mero> es mayor que
cero.
‚óè SRW: El valor del acumulador 2 indica el n√∫mero de desplazamiento. Se permiten valores
entre 0 y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2
es mayor que cero.
Si el n√∫mero de desplazamiento indicado es mayor que 15, todos los bits de la palabra
derecha del acumulador 1 se rellenar√°n con ceros.

1744

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Aunque el n√∫mero de desplazamiento indicado sea cero, la instrucci√≥n se ejecuta. El bit de
estado CC 1 se pone a "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Desplazar a la derecha por
palabras":
Par√°metro

Formato

Descripci√≥n

<N√∫mero>

Enteros posi‚Äê N√∫mero de posiciones de bit que se desplazar√°n.
tivos: SINT,
INT, UINT,
USINT

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

SRW 6

// Desplazar los bits 0 a 15 del acumulador 1 seis posiciones a la derecha.
// Rellenar las posiciones liberadas con ceros.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 4

// Cargar el n√∫mero de desplazamiento en el acumulador
1.

L "Tag_Value_2"

// Desplazar el n√∫mero de desplazamiento al byte derecho del acumulador 2.
// Cargar el valor del operando en el acumulador 1.

SRW

// Desplazar los bits 0 a 15 del acumulador 1 cuatro
posiciones a la derecha.
// Rellenar las posiciones liberadas con ceros.

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‚Äê
sult_1

0101

1111

0110

0100

0000

0001

0111

0100

Tag_Value_2 0101

1111

0110

0100

0101

1101

0010

1011

Tag_Re‚Äê
sult_2

1111

0110

0100

0000

0101

1101

0010

0101

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1745

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Bases de AWL (P√°gina 8065)

SLD: Desplazar a la izquierda por palabras dobles
Descripci√≥n
La instrucci√≥n "Desplazar a la izquierda por palabras dobles" desplaza bit por bit todo el
contenido del acumulador 1 hacia la izquierda. Las posiciones que quedan libres al desplazar
se rellenan con ceros. Esta instrucci√≥n se ejecuta independientemente del RLO. El bit de
estado A1 se ajusta al estado l√≥gico del √∫ltimo bit desplazado.
Para indicar el n√∫mero de posiciones de bit que se desplazar√°n existen las posibilidades
siguientes:
‚óè Indicaci√≥n de un entero positivo como par√°metro de la instrucci√≥n. (<N√∫mero>)
‚óè Indicaci√≥n mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
‚óè SLD <N√∫mero>: El operando <N√∫mero> indica el n√∫mero de desplazamiento. Se permiten
valores entre 0 y 31. Los bits de estado A0 y OV se ponen a "0" si <N√∫mero> es mayor que
cero.
‚óè SLD: El valor del acumulador 2 indica el n√∫mero de desplazamiento. Se permiten valores
entre 0 y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2
es mayor que cero.
Con valores mayores que 31, todos los bits del acumulador 1 se rellenan con ceros.
Aunque el n√∫mero de desplazamiento indicado sea cero, la instrucci√≥n se ejecuta. El bit de
estado CC 1 se pone a "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Desplazar a la izquierda por
palabras dobles":

1746

Par√°metro

Formato

Descripci√≥n

<N√∫mero>

Enteros posi‚Äê N√∫mero de posiciones de bit que se desplazar√°n.
tivos: SINT,
INT, UINT,
USINT

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

SLD 5

// Desplazar los bits 0 a 31 del acumulador 1 cinco
posiciones a la izquierda.
// Rellenar las posiciones liberadas con ceros.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 4

// Cargar el n√∫mero de desplazamiento en el acumulador
1.

L "Tag_Value_2"

// Desplazar el n√∫mero de desplazamiento al byte derecho del acumulador 2.
// Cargar el valor del operando en el acumulador 1.

SLD

// Desplazar los bits 0 a 31 del acumulador 1 cuatro
posiciones a la izquierda.
// Rellenar las posiciones liberadas con ceros.

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‚Äê
sult_1

1110

1100

1000

1011

1010

0111

0110

0000

Tag_Value_2 1010

1000

1010

0010

1001

1011

1100

1101

Tag_Re‚Äê
sult_2

1010

0010

1001

1011

1100

1101

0000

1000

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Bases de AWL (P√°gina 8065)

SRD: Desplazar a la derecha por palabras dobles
Descripci√≥n
La instrucci√≥n "Desplazar a la derecha por palabras dobles" desplaza bit por bit todo el
contenido del acumulador 1 hacia la derecha. Las posiciones que quedan libres al desplazar
se rellenan con ceros. Esta instrucci√≥n se ejecuta independientemente del RLO. El bit de
estado A1 se ajusta al estado l√≥gico del √∫ltimo bit desplazado.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1747

Instrucciones
4.1 Instrucciones
Para indicar el n√∫mero de posiciones de bit que se desplazar√°n existen las posibilidades
siguientes:
‚óè Indicaci√≥n de un entero positivo como par√°metro de la instrucci√≥n. (<N√∫mero>)
‚óè Indicaci√≥n mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
‚óè SRD <N√∫mero>: El operando <N√∫mero> indica el n√∫mero de desplazamiento. Se permiten
valores entre 0 y 31. Los bits de estado A0 y OV se ponen a "0" si <N√∫mero> es mayor que
cero.
‚óè SRD: El valor del acumulador 2 indica el n√∫mero de desplazamiento. Se permiten valores
entre 0 y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2
es mayor que cero.
Con valores mayores que 31, todos los bits del acumulador 1 se rellenan con ceros.
Aunque el n√∫mero de desplazamiento indicado sea cero, la instrucci√≥n se ejecuta. El bit de
estado CC 1 se pone a "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Desplazar a la derecha por
palabras dobles":
Par√°metro

Formato

Descripci√≥n

<N√∫mero>

Enteros posi‚Äê N√∫mero de posiciones de bit que se desplazar√°n.
tivos: SINT,
INT, UINT,
USINT

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

SRD 7

// Desplazar los bits 0 a 31 del acumulador 1 siete
posiciones a la derecha.
// Rellenar las posiciones liberadas con ceros.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 4

// Cargar el n√∫mero de desplazamiento en el acumulador
1.

L "Tag_Value_2"

// Desplazar el n√∫mero de desplazamiento al byte derecho del acumulador 2.
// Cargar el valor del operando en el acumulador 1.

SRD

// Desplazar los bits 0 a 31 del acumulador 1 cuatro
posiciones a la derecha.
// Rellenar las posiciones liberadas con ceros.

1748

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicaci√≥n

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‚Äê
sult_1

0000

0000

1011

1110

1100

1000

1011

1010

Tag_Value_2 1010

1000

1010

0010

1001

1011

1100

1101

Tag_Re‚Äê
sult_2

1010

1000

1010

0010

1001

1011

1100

0000

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Bases de AWL (P√°gina 8065)

Rotar
RLD: Rotar a la izquierda por palabras dobles
Descripci√≥n
La instrucci√≥n "Rotar a la izquierda por palabras dobles" rota bit por bit todo el contenido del
acumulador 1 hacia la izquierda. Durante la ejecuci√≥n, la instrucci√≥n desplaza por bits los bits
de 0 a 31 del acumulador 1 hacia la izquierda y rellena las posiciones que han quedado libres
al desplazar con las posiciones de bit desplazadas. Esta instrucci√≥n se ejecuta
independientemente del RLO. El bit de estado A1 se ajusta al estado l√≥gico del √∫ltimo bit
desplazado.
Para indicar el n√∫mero de posiciones de bit que se rotar√°n existen las posibilidades siguientes:
‚óè Indicaci√≥n de un entero positivo como par√°metro de la instrucci√≥n. (<N√∫mero>)
‚óè Indicaci√≥n mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1749

Instrucciones
4.1 Instrucciones
Se pueden utilizar los siguientes formatos:
‚óè RLD <N√∫mero>: El operando <N√∫mero> indica el n√∫mero de rotaci√≥n. Se permiten valores
entre 0 y 32. Los bits de estado A0 y OV se ponen a "0" si <N√∫mero> es mayor que cero.
‚óè RLD: El valor del acumulador 2 indica el n√∫mero de rotaci√≥n. Se permiten valores entre 0
y 255. Los bits de estado A0 y OV se ponen a "0" si el contenido del acumulador 2 es mayor
que cero.
Si el valor es mayor que 32, el n√∫mero de rotaci√≥n se calcula con una divisi√≥n m√≥dulo entre
32. Si, p. ej., el n√∫mero de rotaci√≥n es 34, los bits del acumulador 1 se rotar√°n 2 posiciones
de bit.
Si el n√∫mero de rotaci√≥n indicado es 32, el contenido del acumulador 1 no cambia.
Aunque el n√∫mero de rotaci√≥n indicado sea cero, la instrucci√≥n se ejecuta. El bit de estado CC
1 se pone a "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Rotar a la izquierda por palabras
dobles":
Par√°metro

Formato

Descripci√≥n

<N√∫mero>

Enteros posi‚Äê N√∫mero de posiciones de bit que se rotar√°n.
tivos: SINT,
INT, UINT,
USINT

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

RLD 4

// Rotar los bits 0 a 31 del acumulador 1 cuatro posiciones a la izquierda.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 6

// Cargar el n√∫mero de rotaci√≥n en el acumulador 1.

L "Tag_Value_2"

// Desplazar el n√∫mero de rotaci√≥n al byte derecho del
acumulador 2.
// Cargar el valor del operando en el acumulador 1.

1750

RLD

// Rotar los bits 0 a 31 del acumulador 1 seis posiciones a la izquierda.

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‚Äê
sult_1

1111

0110

0100

0101

1101

0011

1011

0101

Tag_Value_2 1010

1000

1010

0010

1001

1011

1100

1101

Tag_Re‚Äê
sult_2

1000

1010

0110

1111

0011

0110

1010

0010

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Bases de AWL (P√°gina 8065)

RRD: Rotar a la derecha por palabras dobles
Descripci√≥n
La instrucci√≥n "Rotar a la derecha por palabras dobles" rota bit por bit todo el contenido del
acumulador 1 hacia la derecha. Durante la ejecuci√≥n, la instrucci√≥n desplaza por bits los bits
0 a 31 del acumulador 1 hacia la derecha y rellena las posiciones que han quedado libres al
desplazar con las posiciones de bit desplazadas. Esta instrucci√≥n se ejecuta
independientemente del RLO. El bit de estado CC1 se ajusta al estado l√≥gico del √∫ltimo bit
desplazado.
Para indicar el n√∫mero de posiciones de bit que se rotar√°n existen las posibilidades siguientes:
‚óè Indicaci√≥n de un entero positivo como par√°metro de la instrucci√≥n. (<N√∫mero>)
‚óè Indicaci√≥n mediante el valor del byte derecho del acumulador 2. El byte se interpreta en
forma de entero positivo.
Se pueden utilizar los siguientes formatos:
‚óè RRD <N√∫mero>: El operando <N√∫mero> indica el n√∫mero de rotaci√≥n. Se admiten valores
entre 0 y 32. Los bits de estado CC0 y OV se ponen a "0" si <N√∫mero> es mayor que cero.
‚óè RRD: El valor del acumulador 2 indica el n√∫mero de rotaci√≥n. Se admiten valores entre 0 y
255. Los bits de estado CC0 y OV se ponen a "0" si el contenido del acumulador 2 es mayor
que cero.
Si el valor es mayor que 32, el n√∫mero de rotaci√≥n se calcula con una divisi√≥n m√≥dulo entre
32. Si, p. ej., el n√∫mero de rotaci√≥n es 34, los bits del acumulador 1 se rotar√°n 2 posiciones
de bit.
Si el n√∫mero de rotaci√≥n indicado es 32, el contenido del acumulador 1 no cambia.
Aunque el n√∫mero de rotaci√≥n indicado sea cero, la instrucci√≥n se ejecuta. El bit de estado CC
1 se pone a "0".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1751

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Rotar a la derecha por palabras
dobles":
Par√°metro

Formato

Descripci√≥n

<N√∫mero>

Enteros posi‚Äê N√∫mero de posiciones de bit que se rotar√°n.
tivos: SINT,
INT, UINT,
USINT

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

RRD 4

// Rotar los bits 0 a 31 del acumulador 1 cuatro posiciones a la derecha.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando.

L 6

// Cargar el n√∫mero de rotaci√≥n en el acumulador 1.

L "Tag_Value_2"

// Desplazar el n√∫mero de rotaci√≥n al byte derecho del
acumulador 2.
// Cargar el valor del operando en el acumulador 1.

RRD

// Rotar los bits 0 a 31 del acumulador 1 seis posiciones a la derecha.

T "Tag_Result_2"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value_1 0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‚Äê
sult_1

1011

0101

1111

0110

0100

0101

1101

0011

Tag_Value_2 1010

1000

1010

0010

1001

1011

1100

1101

Tag_Re‚Äê
sult_2

0110

1010

0010

1000

1010

0110

1111

0011

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Bases de AWL (P√°gina 8065)

1752

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

RLDA: Rotar a la izquierda v√≠a bit de estado CC 1
Descripci√≥n
La instrucci√≥n "Rotar a la izquierda v√≠a bit de estado CC 1" desplaza el contenido del
acumulador 1 un bit a la izquierda. La posici√≥n de bit que ha quedado libre al desplazar (0) se
rellena con el estado l√≥gico del bit de estado CC 1. El bit de estado CC 1 obtiene el estado
l√≥gico del bit desplazado (31).
Esta instrucci√≥n se ejecuta independientemente del RLO. Pone el bit de estado CC 0 a "0".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value"

// Cargar el valor del operando en el acumulador 1.

RLDA

// Rotar los bits 0 a 31 del acumulador 1 una posici√≥n
a la izquierda.
// Rellenar el bit 0 con el estado l√≥gico del bit de
estado CC 1.
// Escribir el bit desplazado en el bit de estado CC 1.

T "Tag_Result"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

CC 1

Valor

Tag_Value 1

0101

1111

0110

0100

0101

1101

0011

1011

Tag_Re‚Äê
sult

1011

1110

1100

1000

1011

1010

0111

0111

0

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Bases de AWL (P√°gina 8065)

RRDA: Rotar a la derecha v√≠a bit de estado CC 1
Descripci√≥n
La instrucci√≥n "Rotar a la derecha v√≠a bit de estado CC 1" desplaza el contenido del
acumulador 1 un bit a la derecha. La posici√≥n de bit que ha quedado libre al desplazar (31) se
rellena con el estado l√≥gico del bit de estado CC 1. El bit de estado CC 1 obtiene el estado
l√≥gico del bit desplazado (0).

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1753

Instrucciones
4.1 Instrucciones
Esta instrucci√≥n se ejecuta independientemente del RLO. Pone los bits de estado CC 0 y OVa
"0".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value"

// Cargar el valor del operando en el acumulador 1.

RRDA

// Rotar los bits 0 a 31 del acumulador 1 una posici√≥n
a la derecha.
// Rellenar el bit 31 con el estado l√≥gico del bit de
estado CC 1.
// Escribir el bit desplazado en el bit de estado CC 1.

T "Tag_Result"

// Transferir el contenido del acumulador 1 al operando.

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

CC 1

Valor

Tag_Value

1

0101

1111

0110

0100

0101

1101

0011

1011

Tag_Result 0

1010

1111

1011

0010

0010

1110

1001

1101

El bit de estado CC 1 tiene el valor "1", ya que el bit 0 del operando "Tag_Value" tambi√©n tiene
el valor "1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)
Bases de AWL (P√°gina 8065)

Otras instrucciones
Acumulador
TAK: Intercambiar contenido de los acumuladores 1 y 2
Descripci√≥n
La instrucci√≥n "Intercambiar contenido de los acumuladores 1 y 2" intercambia el contenido del
acumulador 1 con el contenido del acumulador 2.
La CPU ejecuta la instrucci√≥n independientemente del resultado l√≥gico y los bits de estado. La
instrucci√≥n no influye ni en el resultado l√≥gico ni en los bits de estado.

1754

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

>I

// Comparar si el valor del acumulador 2 es mayor que
el valor del acumulador 1.

JC NEXT

// Si la condici√≥n se cumple (RLO = "1"), saltar a la
etiqueta "NEXT".
// Si la condici√≥n no se cumple (RLO = "0"), procesar
la instrucci√≥n siguiente.

TAK

// Intercambiar contenido de los acumuladores 1 y 2.

NEXT: -I

// Etiqueta "NEXT"
// Restar el valor del acumulador 1 del valor del acumulador 2.

T "Tag_Output"

// Transferir el contenido del acumulador 1 al operando "Tag_Output".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

PUSH: Desplazar contenido al siguiente acumulador superior
Descripci√≥n
La instrucci√≥n "Desplazar contenido al siguiente acumulador superior" desplaza el contenido
del acumulador 1 al acumulador 2.
El contenido del acumulador 1 no se ve influido por la instrucci√≥n y permanece invariable una
vez ejecutada la misma. El contenido del acumulador 2 se pierde.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1755

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el contenido de los acumuladores 1 y 2 antes y despu√©s de ejecutar
la instrucci√≥n:
Estado

Acumulador
1

2

Antes de la ejecuci√≥n

Valor A

Valor B

Despu√©s de la ejecuci√≥n

Valor A

Valor A

La CPU ejecuta la instrucci√≥n independientemente del resultado l√≥gico y los bits de estado. La
instrucci√≥n no influye ni en el resultado l√≥gico ni en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando en el acumulador 1.

PUSH

// Desplazar el contenido de los acumuladores 1 a 2 al
siguiente acumulador superior en cada caso.

L "Tag_Value_2"

// Cargar el valor del operando en el acumulador 1.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

POP: Desplazar contenido al siguiente acumulador inferior
Descripci√≥n
La instrucci√≥n "Desplazar contenido al siguiente acumulador inferior" desplaza el contenido del
acumulador 2 al acumulador 1.
El contenido del acumulador 2 no se ve influido por la instrucci√≥n y permanece invariable una
vez ejecutada la misma. El contenido del acumulador 1 se pierde.
La tabla siguiente muestra el contenido de los acumuladores 1 y 2 antes y despu√©s de ejecutar
la instrucci√≥n:
Estado

Acumulador
1

1756

2

Antes de la ejecuci√≥n

Valor A

Valor B

Despu√©s de la ejecuci√≥n

Valor B

Valor B

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La CPU ejecuta la instrucci√≥n independientemente del resultado l√≥gico y los bits de estado. La
instrucci√≥n no influye ni en el resultado l√≥gico ni en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

T "Tag_Value_1"

// Transferir el contenido del acumulador 1 al operando "Tag_Value_1".

POP

// Desplazar el contenido del acumulador 2 al acumulador 1 inferior.

T "Tag_Value_2"

// Transferir el contenido del acumulador 1 al operando "Tag_Value_2".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

Registro de direcciones
+AR1: Sumar acumulador 1 a AR1
Descripci√≥n
La instrucci√≥n "Sumar acumulador 1 a AR1" suma un valor al contenido del registro de
direcciones 1. El tipo de puntero que est√° en el registro de direcciones 1 y el √°rea de operandos
se conservan.
Para indicar el valor que debe sumarse existen las posibilidades siguientes:
‚óè Indicaci√≥n mediante una constante: La instrucci√≥n suma el valor de la constante al registro
de direcciones 1. El valor de la constante debe equivaler al formato de un puntero interno
del √°rea (POINTER).
‚óè Indicaci√≥n mediante el valor de la palabra derecha del acumulador 1: la instrucci√≥n
interpreta el valor de la palabra derecha del acumulador 1 como un entero de 16 bits y lo
ampl√≠a a 24 bits con el signo correcto. Seguidamente, la instrucci√≥n suma el valor del
acumulador 1 al registro de direcciones 1. Se admiten valores de -32 768 a +32 767.
La CPU ejecuta la instrucci√≥n independientemente del resultado l√≥gico y los bits de estado. La
instrucci√≥n no influye ni en el resultado l√≥gico ni en los bits de estado.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1757

Instrucciones
4.1 Instrucciones
Los contenidos de los acumuladores no cambian debido a la instrucci√≥n.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Sumar acumulador 1 a AR1":
Par√°metro

Tipo de datos Descripci√≥n

<Constante>

POINTER

Valor que se suma al registro de direcciones 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

+AR1 P#10.0

// Sumar el puntero al registro de direcciones 1.

L "Tag_Value"

// Cargar el valor del operando "Tag_Value" en la palabra derecha del acumulador 1.

+AR1

// Sumar el valor del acumulador 1 al registro de direcciones 1.

TAR1 %MD24

// Transferir el contenido del registro de direcciones
1 a la palabra doble MD24.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

+AR2: Sumar acumulador 1 a AR2
Descripci√≥n
La instrucci√≥n "Sumar acumulador 1 a AR2" suma un valor al contenido del registro de
direcciones 2. El tipo de puntero que est√° en el registro de direcciones 2 y el √°rea de operandos
se conservan.

1758

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para indicar el valor que debe sumarse existen las posibilidades siguientes:
‚óè Indicaci√≥n mediante una constante: La instrucci√≥n suma el valor de la constante al registro
de direcciones 2. El valor de la constante debe equivaler al formato de un puntero interno
del √°rea (POINTER).
‚óè Indicaci√≥n mediante el valor de la palabra derecha del acumulador 1: la instrucci√≥n
interpreta el valor de la palabra derecha del acumulador 1 como un entero de 16 bits y lo
ampl√≠a a 24 bits con el signo correcto. Seguidamente, la instrucci√≥n suma el valor del
acumulador 1 al registro de direcciones 2. Se admiten valores de -32 768 a +32 767.
La CPU ejecuta la instrucci√≥n independientemente del resultado l√≥gico y los bits de estado. La
instrucci√≥n no influye ni en el resultado l√≥gico ni en los bits de estado.
Los contenidos de los acumuladores no cambian debido a la instrucci√≥n.
Nota
El registro de direcciones AR2 se utiiza para procesar multiinstancias. Si se programa la
instrucci√≥n "Sumar acumulador 1 a AR2", primero debe "salvarse" el contenido del registro de
direcciones 2 y volver a cargarlo despu√©s.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Sumar acumulador 1 a AR2":
Par√°metro

Tipo de datos Descripci√≥n

<Constante>

POINTER

Valor que se suma al registro de direcciones 1.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

+AR2 P#10.0

// Sumar el puntero al registro de direcciones 2.

L "Tag_Value"

// Cargar el valor del operando "Tag_Value" en la palabra derecha del acumulador 1.

+AR2

// Sumar el valor del acumulador 1 al registro de direcciones 2.

TAR2 %MD24

// Transferir el contenido del registro de direcciones
1 a la palabra doble MD24.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1759

Instrucciones
4.1 Instrucciones
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

Instrucciones nulas
BLD: Refresco de imagen (instrucci√≥n nula)
Descripci√≥n
La instrucci√≥n "Refresco de imagen (instrucci√≥n nula)" no ejecuta ninguna funci√≥n y no influye
en los bits de estado. La instrucci√≥n sirve para reconocer secuencias de c√≥digos en una
transferencia de par√°metros o en los segmentos KOP/FUP. Se genera autom√°ticamente
cuando se visualiza un programa KOP o FUP en AWL. El valor de par√°metro es el n√∫mero de
identificaci√≥n de la instrucci√≥n y es generado por la programadora.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Refresco de imagen (instrucci√≥n
nula)":
Par√°metro

Tipo de datos Descripci√≥n

<n√∫mero de
identifica‚Äê
ci√≥n>

WORD

N√∫mero de identificaci√≥n de la instrucci√≥n

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

NOP 0: Instrucci√≥n nula
Descripci√≥n
La instrucci√≥n "Instrucci√≥n nula" con un par√°metro 0 no ejecuta ninguna funci√≥n y no influye en
los bits de estado. El c√≥digo de la instrucci√≥n contiene un patr√≥n de bits con 16 ceros. La
instrucci√≥n solo es importante para la programadora cuando se visualiza un programa.

1760

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
AWL

Explicaci√≥n

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

>I

// Comparar si el valor del acumulador 2 es mayor que
el valor del acumulador 1.

A

// Consultar si el estado l√≥gico del operando es "1" y
combinar el resultado l√≥gicamente con Y con el RLO actual.

JC NEXT

// Si la condici√≥n se cumple (RLO = "1"), saltar a la
etiqueta "NEXT".
// Si la condici√≥n no se cumple (RLO = "0"), procesar
la instrucci√≥n siguiente.

TAK

// Intercambiar contenido de los acumuladores 1 y 2.

NEXT: NOP 0

// Etiqueta "NEXT"

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

NOP 1: Instrucci√≥n nula
Descripci√≥n
La instrucci√≥n "Instrucci√≥n nula" con un par√°metro 1 no ejecuta ninguna funci√≥n y no influye en
los bits de estado. El c√≥digo de la instrucci√≥n contiene un patr√≥n de bits con 16 unos. La
instrucci√≥n solo es importante para la programadora cuando se visualiza un programa.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
A√±adir instrucciones AWL (P√°gina 8079)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1761

Instrucciones
4.1 Instrucciones
Procesar instrucciones AWL (P√°gina 8098)
Instancias (P√°gina 61)
Consulta y activaci√≥n de los bits de estado en AWL (P√°gina 199)

4.1.3.4

SCL

Operaciones l√≥gicas con bits
R_TRIG: Detectar flanco de se√±al ascendente
Descripci√≥n
La instrucci√≥n "Detectar flanco de se√±al ascendente" permite detectar un cambio de estado de
"0" a "1" en la entrada CLK. La instrucci√≥n compara el valor actual de la entrada CLK con el
estado de la consulta anterior (marca de flanco), que est√° almacenada en la instancia indicada.
Cuando la instrucci√≥n detecta un cambio de estado de "0" a "1" en la entrada CLK, en la salida
Q se genera un flanco de se√±al ascendente, es decir, que la se√±al tiene el valor TRUE o "1"
exactamente durante un ciclo.
En todos los dem√°s casos, el estado l√≥gico de la salida de la instrucci√≥n es "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

CLK

Input

BOOL

I, Q, M, D, L

Se√±al entrante cuyo flanco
se consulta

Q

Output

BOOL

I, Q, M, D, L

Resultado de la evaluaci√≥n
de flancos

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"R_TRIG_DB"(CLK := "TagIn",
Q => "TagOut");

En la variable "R_TRIG_DB" se guarda el estado anterior de la variable en la entrada CLK. Si
en el operando "TagIn" se detecta un cambio del estado l√≥gico de "0" a "1", la salida "TagOut"
devuelve el estado l√≥gico "1" durante un ciclo.

1762

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

F_TRIG: Detectar flanco de se√±al descendente
Descripci√≥n
La instrucci√≥n "Detectar flanco de se√±al descendente" permite detectar un cambio de estado
de "1" a "0" en la entrada CLK. La instrucci√≥n compara el valor actual de la entrada CLK con
el estado de la consulta anterior (marca de flanco), que est√° almacenada en la instancia
indicada. Cuando la instrucci√≥n detecta un cambio de estado de "1" a "0" en la entrada CLK,
en la salida Q se genera un flanco de se√±al descendente, es decir, que la se√±al tiene el valor
TRUE o "1" exactamente durante un ciclo.
En todos los dem√°s casos, el estado l√≥gico de la salida de la instrucci√≥n es "0".

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

CLK

Input

BOOL

I, Q, M, D, L

Se√±al entrante cu‚Äê
yo flanco se consul‚Äê
ta

Q

Output

BOOL

I, Q, M, D, L

Resultado de la
evaluaci√≥n de flan‚Äê
cos

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"F_TRIG_DB"(CLK := "TagIn",
Q => "TagOut");

En la variable "F_TRIG_DB" se guarda el estado anterior de la variable en la entrada CLK. Si
en el operando "TagIn" se detecta un cambio del estado l√≥gico de "1" a "0", la salida "TagOut"
devuelve el estado l√≥gico "1" durante un ciclo.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1763

Instrucciones
4.1 Instrucciones

Temporizadores
Llamada de temporizadores CEI
Descripci√≥n
Existe la posibilidad de declarar el temporizador CEI como instancia individual o multiinstancia
y llamarlo en el c√≥digo del programa.
Est√°n disponibles las siguientes posibilidades sint√°cticas para la declaraci√≥n de un
temporizador CEI como multiinstancia dentro de una estructura de la interfaz del bloque:

Temporizador CEI como elemento de ARRAY
Declaraci√≥n en la interfaz del bloque:

C√≥digo del programa:
SCL
#MyARRAY[1].TOF(IN := <Operando>, PT := <Operando>)

Declaraci√≥n en la interfaz del bloque:

C√≥digo del programa:
SCL
#MyARRAY[#index](IN := <Operando>, PT := <Operando>)

Temporizador CEI en una estructura an√≥nima
Declaraci√≥n en la interfaz del bloque:

1764

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
C√≥digo del programa:
SCL
#MyStruct.FirstTime.TOF(IN := <Operando>, PT := <Operando>)

Declaraci√≥n en la interfaz del bloque:

C√≥digo del programa:
SCL
#MyStruct.FirstTime(IN := <Operando>, PT := <Operando>)

Temporizador CEI en el bloque de datos global
Declaraci√≥n en el bloque de datos:

C√≥digo del programa:
SCL
"MyGlobalDB".Timer.FirstTime.TOF(IN := <Operando>, PT := <Operando>)

Declaraci√≥n en el bloque de datos:

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1765

Instrucciones
4.1 Instrucciones
C√≥digo del programa:
SCL
"MyGlobalDB".Timer.SecondTime(IN := <Operando>, PT := <Operando>)

Temporizador CEI como elemento en la interfaz del bloque
Declaraci√≥n en la interfaz del bloque:

C√≥digo del programa:
SCL
#Timer.FirstTime.TOF(IN := <Operando>, PT := <Operando>)

Declaraci√≥n en la interfaz del bloque:

C√≥digo del programa:
SCL
#Timer.SecondTime(IN := <Operando>, PT := <Operando>)

Temporizador CEI en un DB de ARRAY
Declaraci√≥n en el DB de ARRAY:

1766

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
C√≥digo del programa:
SCL
"MyARRAYDB"."THIS"[0].FirstTime.TOF(IN := <Operando>, PT := <Operando>)

Declaraci√≥n en el DB de ARRAY:

C√≥digo del programa:
SCL
"MyARRAYDB"."THIS"[0].SecondTime(IN := <Operando>, PT := <Operando>)

TP: Impulso
Descripci√≥n
La instrucci√≥n "Impulso" activa el par√°metro Q por un tiempo programado. La instrucci√≥n se
inicia cuando el resultado l√≥gico (RLO) del par√°metro IN cambia de "0" a "1" (flanco de se√±al
ascendente). Cuando se inicia la instrucci√≥n, se empieza a contar el tiempo programado PT.
El par√°metro Q se activa por el tiempo PT, independientemente de c√≥mo evolucione la se√±al
de entrada. Durante el tiempo PT la detecci√≥n de un nuevo flanco de se√±al ascendente en la
entrada IN no influye en el estado l√≥gico de la salida Q.
El valor actual de tiempo se puede consultar en el par√°metro ET. Este valor de tiempo empieza
a contar a partir de T#0s y termina al alcanzarse el valor del tiempo PT. Si cuando se alcanza
el tiempo PT el estado l√≥gico del par√°metro IN es "0", se resetea el par√°metro ET.
Nota
Si en el programa no se llama la instrucci√≥n porque, p. ej., esta se omite, la salida ET devuelve
un valor constante en cuanto transcurre este tiempo.
A cada llamada de la instrucci√≥n "Impulso" debe asign√°rsele un temporizador CEI, en el que
se guarden los datos de instancia.
Encontrar√° informaci√≥n sint√°ctica sobre la llamada de temporizadores CEI en estructuras
(multiinstancia) aqu√≠: Llamada de temporizadores CEI (P√°gina 1764)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1767

Instrucciones
4.1 Instrucciones

Para las CPU de la serie S7-1200
El temporizador CEI es una estructura del tipo de datos IEC_TIMER o TP_TIME que se puede
declarar como se indica a continuaci√≥n:
‚óè Declaraci√≥n de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER (p.
ej., "MyIEC_TIMER_DB")
‚óè Declaraci√≥n como variable local del tipo de datos TP_TIME en la secci√≥n "Static" de un
bloque de programa (p. ej., #MyIEC_TIMER_Instance)

Para las CPU de la serie S7-1500
El temporizador CEI es una estructura del tipo de datos IEC_TIMER, IEC_LTIMER, TP_TIME
o TP_LTIME que se puede declarar como se indica a continuaci√≥n:
‚óè Declaraci√≥n de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER o
IEC_LTIMER (p. ej., "MyIEC_LTIMER_DB")
‚óè Declaraci√≥n como variable local del tipo de datos TP_TIME o TP_LTIME en la secci√≥n
"Static" de un bloque de programa (p. ej., #MyIEC_LTIMER_Instance)

Temporizador CEI como bloque de datos de instancia del tipo de datos de sistema
<Temporizador_CEI> (Shared DB)
Un temporizador CEI se puede declarar como bloque de datos del modo siguiente:
<DB_temporizador_CEI>.TP();

Temporizador CEI como variable local de la interfaz del bloque (multiinstancia)
El temporizador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Timer();

1768

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Actualizaci√≥n de los valores actuales en los datos de instancia
Los datos de instancia de "Impulso" se actualizan siguiendo las reglas indicadas a
continuaci√≥n:
‚óè Entrada IN
La instrucci√≥n "Impulso" compara el RLO actual con el RLO de la consulta anterior, que est√°
almacenado en el par√°metro IN de los datos de instancia. Si la instrucci√≥n detecta un
cambio del RLO de "0" a "1", significa que hay un flanco de se√±al ascendente y se empieza
a medir el tiempo. Una vez procesada la instrucci√≥n "Impulso", el valor del par√°metro IN se
actualiza en los datos de instancia y se utiliza como marca de flancos para la siguiente
consulta.
Tenga en cuenta que la evaluaci√≥n de flancos falla cuando el valor actual del par√°metro IN
es escrito o inicializado por otras funciones.
‚óè Entrada PT
El valor de la entrada PT se escribe en el par√°metro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
‚óè Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
‚Äì Al llamar la instrucci√≥n, si las salidas ET o Q est√°n interconectadas.
O bien:
‚Äì Al acceder a Q o ET.
Si las salidas no est√°n interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucci√≥n se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan par√°metros internos de la
instrucci√≥n "Impulso". Tenga en cuenta que la medici√≥n de tiempo falla cuando los valores
actuales de la instrucci√≥n son escritos o inicializados por otras funciones.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1769

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se est√° midiendo el
tiempo, se interfiere en la funci√≥n del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse da√±os materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicializaci√≥n de los valores actuales:
‚óè Cargar el bloque con reinicializaci√≥n
‚óè Cargar instant√°neas como valores actuales
‚óè Forzar valores actuales de forma normal o permanente
‚óè La instrucci√≥n "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
‚óè Aseg√∫rese de que la instalaci√≥n se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
‚óè Aseg√∫rese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
‚óè Si los valores actuales se sobrescriben con una instant√°nea, aseg√∫rese de que la
instant√°nea se haya generado en un instante en que la instalaci√≥n estaba en un estado
seguro.
‚óè Aseg√∫rese de que el programa no est√° leyendo ni escribiendo los datos afectados durante
la transferencia.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memo‚Äê Descripci√≥n
ria

IN

Input

BOOL

BOOL

I, Q, M, D, L, P

Entrada de
arranque

PT

Input

TIME

TIME, LTI‚Äê
ME

I, Q, M, D, L, P

Duraci√≥n del
impulso.
El valor del pa‚Äê
r√°metro PT de‚Äê
be ser positivo.

1770

Q

Output

BOOL

BOOL

I, Q, M, D, L, P

Operando que
se activa por el
tiempo PT.

ET

Output

TIME

TIME, LTI‚Äê
ME

I, Q, M, D, L, P

Valor de tiempo
actual

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el cronograma de impulsos de la instrucci√≥n "Impulso":
,1

4

37

37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"TP_DB".TP(IN := "Tag_Start",
PT := "Tag_PresetTime",
Q => "Tag_Status",
ET => "Tag_ElapsedTime");

Cuando el estado l√≥gico del operando "Tag_Start" cambia de "0" a "1", el tiempo programado
en el par√°metro PT empieza a contar y el operando "Tag_Status" se pone a "1". El valor de
tiempo actual se guarda en el operando "Tag_ElapsedTime".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1771

Instrucciones
4.1 Instrucciones

TON: Retardo al conectar
Descripci√≥n
La instrucci√≥n "Retardo al conectar" permite retardar la activaci√≥n del par√°metro Q por el
tiempo programado PT. La instrucci√≥n se inicia cuando el resultado l√≥gico (RLO) del par√°metro
IN cambia de "0" a "1" (flanco de se√±al ascendente). Cuando se inicia la instrucci√≥n, se
empieza a contar el tiempo programado PT. Una vez transcurrido el tiempo PT, el par√°metro
Q devuelve el estado l√≥gico "1". El par√°metro Q permanecer√° activado mientras la entrada de
arranque est√© puesta a "1". Cuando el estado l√≥gico del par√°metro IN cambia de "1" a "0", se
resetea el par√°metro Q. La funci√≥n de temporizaci√≥n se reinicia al detectarse un nuevo flanco
de se√±al ascendente en el par√°metro IN.
El valor de tiempo actual se puede consultar en el par√°metro ET. Este valor de tiempo empieza
a contar a partir de T#0s y termina al alcanzarse el valor del tiempo PT. El par√°metro ET se
resetea en cuanto el estado l√≥gico del par√°metro IN cambia a "0".
Nota
Si en el programa no se llama la instrucci√≥n porque, p. ej., esta se omite, la salida ET devuelve
un valor constante en cuanto ha transcurrido el tiempo PT.
A cada llamada de la instrucci√≥n "Retardo al conectar" debe asign√°rsele un temporizador CEI,
en el que se guarden los datos de instancia.
Encontrar√° informaci√≥n sint√°ctica sobre la llamada de temporizadores CEI en estructuras
(multiinstancia) aqu√≠: Llamada de temporizadores CEI (P√°gina 1764)

Para las CPU de la serie S7-1200
El temporizador CEI es una estructura del tipo de datos IEC_TIMER o TON_TIME que se
puede declarar como se indica a continuaci√≥n:
‚óè Declaraci√≥n de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER (p.
ej., "MyIEC_TIMER_DB")
‚óè Declaraci√≥n como variable local del tipo de datos TON_TIME en la secci√≥n "Static" de un
bloque de programa (p. ej., #MyIEC_TIMER_Instance)

Para las CPU de la serie S7-1500
El temporizador CEI es una estructura del tipo de datos IEC_TIMER, IEC_LTIMER, TON_TIME
o TON_LTIME que se puede declarar como se indica a continuaci√≥n:
‚óè Declaraci√≥n de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER o
IEC_LTIMER (p. ej., "MyIEC_TIMER_DB")
‚óè Declaraci√≥n como variable local del tipo de datos TON_TIME o TON_LTIME en la secci√≥n
"Static" de un bloque de programa (p. ej., #MyIEC_TIMER_Instance)

1772

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Temporizador CEI como bloque de datos de instancia del tipo de datos de sistema
<Temporizador_CEI> (Shared DB)
Un temporizador CEI se puede declarar como bloque de datos del modo siguiente:
<DB_temporizador_CEI>.TON();

Temporizador CEI como variable local de la interfaz del bloque (multiinstancia)
El temporizador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Timer();

Actualizaci√≥n de los valores actuales en los datos de instancia
Los datos de instancia de "Retardo al conectar" se actualizan siguiendo las reglas indicadas a
continuaci√≥n:
‚óè Entrada IN
La instrucci√≥n "Retardo al conectar" compara el RLO actual con el RLO de la consulta
anterior, que est√° almacenado en el par√°metro IN de los datos de instancia. Si la instrucci√≥n
detecta un cambio del RLO de "0" a "1", significa que hay un flanco de se√±al ascendente y
se empieza a medir el tiempo. Una vez procesada la instrucci√≥n "Retardo al conectar", el
valor del par√°metro IN se actualiza en los datos de instancia y se utiliza como marca de
flancos para la siguiente consulta.
Tenga en cuenta que la evaluaci√≥n de flancos falla cuando el valor actual del par√°metro IN
es escrito o inicializado por otras funciones.
‚óè Entrada PT
El valor de la entrada PT se escribe en el par√°metro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
‚óè Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
‚Äì Al llamar la instrucci√≥n, si las salidas ET o Q est√°n interconectadas.
O bien:
‚Äì Al acceder a Q o ET.
Si las salidas no est√°n interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucci√≥n se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan par√°metros internos de la
instrucci√≥n "Retardo al conectar". Tenga en cuenta que la medici√≥n de tiempo falla cuando
los valores actuales de la instrucci√≥n son escritos o inicializados por otras funciones.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1773

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se est√° midiendo el
tiempo, se interfiere en la funci√≥n del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse da√±os materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicializaci√≥n de los valores actuales:
‚óè Cargar el bloque con reinicializaci√≥n
‚óè Cargar instant√°neas como valores actuales
‚óè Forzar valores actuales de forma normal o permanente
‚óè La instrucci√≥n "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
‚óè Aseg√∫rese de que la instalaci√≥n se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
‚óè Aseg√∫rese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
‚óè Si los valores actuales se sobrescriben con una instant√°nea, aseg√∫rese de que la
instant√°nea se haya generado en un instante en que la instalaci√≥n estaba en un estado
seguro.
‚óè Aseg√∫rese de que el programa no est√° leyendo ni escribiendo los datos afectados durante
la transferencia.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memo‚Äê Descripci√≥n
ria

IN

Input

BOOL

BOOL

I, Q, M, D, L, P

Entrada de
arranque

PT

Input

TIME

TIME, LTI‚Äê
ME

I, Q, M, D, L, P

Tiempo de re‚Äê
tardo al conec‚Äê
tar.
El valor del pa‚Äê
r√°metro PT de‚Äê
be ser positivo.

1774

Q

Output

BOOL

BOOL

I, Q, M, D, L, P

Operando que
se activa una
vez transcurri‚Äê
do el tiempo PT.

ET

Output

TIME

TIME, LTI‚Äê
ME

I, Q, M, D, L, P

Valor de tiempo
actual

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el cronograma de impulsos de la instrucci√≥n "Retardo al conectar":
,1

4

37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"TON_DB".TON(IN := "Tag_Start",
PT := "Tag_PresetTime",
Q => "Tag_Status",
ET => "Tag_ElapsedTime");

Cuando el estado l√≥gico del operando "Tag_Start" cambia de "0" a "1", el tiempo programado
en el par√°metro PT empieza a contar. Una vez transcurrido el tiempo, el operando
"Tag_Status" se pone al estado l√≥gico "1". El operando "Tag_Status" permanece a "1" mientras
el operando "Tag_Start" tenga el estado l√≥gico "1". El valor de tiempo actual se guarda en el
operando "Tag_ElapsedTime". Cuando el estado l√≥gico del operando "Tag_Start" cambia de
"1" a "0", se restablece el operando "Tag_Status".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1775

Instrucciones
4.1 Instrucciones

TOF: Retardo al desconectar
Descripci√≥n
La instrucci√≥n "Retardo al desconectar" permite retardar el reset del par√°metro Q por el tiempo
programado PT. El par√°metro Q se activa cuando el resultado l√≥gico (RLO) del par√°metro IN
cambia de "1" a "0" (flanco de se√±al descendente). Cuando el estado l√≥gico del par√°metro IN
cambia nuevamente a "1", el tiempo programado PT deja de contar. El par√°metro Q
permanecer√° activado mientras transcurra el tiempo PT. Una vez transcurrido el tiempo PT se
resetea el par√°metro Q. Si el estado l√≥gico del par√°metro IN cambia a "1" antes de que
transcurra el tiempo PT, se inicializa el temporizador. El estado l√≥gico del par√°metro Q
permanece a "1".
El valor de tiempo actual se puede consultar en el par√°metro ET. Este valor de tiempo empieza
a contar a partir de T#0s y termina al alcanzarse el valor del tiempo PT. Una vez transcurrido
el tiempo PT, el valor actual del par√°metro ET se conservar√° hasta que el par√°metro IN cambie
nuevamente a "1". Si el par√°metro IN cambia a "1" antes de transcurrir el tiempo PT, el
par√°metro ET adopta el valor T#0s.
Nota
Si en el programa no se llama la instrucci√≥n porque, p. ej., esta se omite, la salida ET devuelve
un valor constante en cuanto transcurre este tiempo.
A cada llamada de la instrucci√≥n "Retardo al desconectar" debe asign√°rsele un temporizador
CEI, en el que se guarden los datos de instancia.
Encontrar√° informaci√≥n sint√°ctica sobre la llamada de temporizadores CEI en estructuras
(multiinstancia) aqu√≠: Llamada de temporizadores CEI (P√°gina 1764)

Para las CPU de la serie S7-1200
El temporizador CEI es una estructura del tipo de datos IEC_TIMER o TOF_TIME que se
puede declarar como se indica a continuaci√≥n:
‚óè Declaraci√≥n de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER (p.
ej., "MyIEC_TIMER_DB")
‚óè Declaraci√≥n como variable local del tipo de datos TOF_TIME en la secci√≥n "Static" de un
bloque de programa (p. ej., #MyIEC_TIMER_Instance)

Para las CPU de la serie S7-1500
El temporizador CEI es una estructura del tipo de datos IEC_TIMER, IEC_LTIMER, TOF_TIME
o TOF_LTIME que se puede declarar como se indica a continuaci√≥n:
‚óè Declaraci√≥n de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER o
IEC_LTIMER (p. ej., "MyIEC_TIMER_DB")
‚óè Declaraci√≥n como variable local del tipo de datos TOF_TIME o TOF_LTIME en la secci√≥n
"Static" de un bloque de programa (p. ej., #MyIEC_TIMER_Instance)

1776

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Temporizador CEI como bloque de datos de instancia del tipo de datos de sistema
<Temporizador_CEI> (Shared DB)
Un temporizador CEI se puede declarar como bloque de datos del modo siguiente:
<DB_temporizador_CEI.TOF();

Temporizador CEI como variable local de la interfaz del bloque (multiinstancia)
El temporizador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Timer();

Actualizaci√≥n de los valores actuales en los datos de instancia
Los datos de instancia de "Retardo al desconectar" se actualizan siguiendo las reglas
indicadas a continuaci√≥n:
‚óè Entrada IN
La instrucci√≥n "Retardo al desconectar" compara el RLO actual con el RLO de la consulta
anterior, que est√° almacenado en el par√°metro IN de los datos de instancia. Si la instrucci√≥n
detecta un cambio del RLO de "1" a "0", significa que hay un flanco de se√±al descendente
y se empieza a contar el tiempo. Una vez procesada la instrucci√≥n "Retardo al
desconectar", el valor del par√°metro IN se actualiza en los datos de instancia y se utiliza
como marca de flancos para la siguiente consulta.
Tenga en cuenta que la evaluaci√≥n de flancos falla cuando el valor actual del par√°metro IN
es escrito o inicializado por otras funciones.
‚óè Entrada PT
El valor de la entrada PT se escribe en el par√°metro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
‚óè Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
‚Äì Al llamar la instrucci√≥n, si las salidas ET o Q est√°n interconectadas.
O bien:
‚Äì Al acceder a Q o ET.
Si las salidas no est√°n interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucci√≥n se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan par√°metros internos de la
instrucci√≥n "Retardo al desconectar". Tenga en cuenta que la medici√≥n de tiempo falla
cuando los valores actuales de la instrucci√≥n son escritos o inicializados por otras
funciones.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1777

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se est√° midiendo el
tiempo, se interfiere en la funci√≥n del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse da√±os materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicializaci√≥n de los valores actuales:
‚óè Cargar el bloque con reinicializaci√≥n
‚óè Cargar instant√°neas como valores actuales
‚óè Forzar valores actuales de forma normal o permanente
‚óè La instrucci√≥n "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
‚óè Aseg√∫rese de que la instalaci√≥n se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
‚óè Aseg√∫rese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
‚óè Si los valores actuales se sobrescriben con una instant√°nea, aseg√∫rese de que la
instant√°nea se haya generado en un instante en que la instalaci√≥n estaba en un estado
seguro.
‚óè Aseg√∫rese de que el programa no est√° leyendo ni escribiendo los datos afectados durante
la transferencia.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memo‚Äê Descripci√≥n
ria

IN

Input

BOOL

BOOL

I, Q, M, D, L, P

Entrada de
arranque

PT

Input

TIME

TIME, LTI‚Äê
ME

I, Q, M, D, L, P

Tiempo de re‚Äê
tardo al desco‚Äê
nectar.
El valor del pa‚Äê
r√°metro PT de‚Äê
be ser positivo.

1778

Q

Output

BOOL

BOOL

I, Q, M, D, L, P

Operando que
se desactiva
una vez trans‚Äê
currido el tiem‚Äê
po PT.

ET

Output

TIME

TIME, LTI‚Äê
ME

I, Q, M, D, L, P

Valor de tiempo
actual

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el cronograma de impulsos de la instrucci√≥n "Retardo al
desconectar":
,1

4
37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"TOF_DB".TOF(IN := "Tag_Start",
PT := "Tag_PresetTime",
Q => "Tag_Status",
ET => "Tag_ElapsedTime");

Si se produce un cambio del estado l√≥gico del operando "Tag_Start" de "0" a "1", el operando
se pone a "Tag_Status". Cuando el estado l√≥gico del operando "Tag_Start" cambia de "1" a "0",
el tiempo programado en el par√°metro PT empieza a contar. Mientras transcurra el tiempo,
permanecer√° activado el operando "Tag_Status". Una vez transcurrido el tiempo, el operando
"Tag_Status" se desactiva. El valor de tiempo actual se guarda en el operando
"Tag_ElapsedTime".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1779

Instrucciones
4.1 Instrucciones

TONR: Acumulador de tiempo
Descripci√≥n
La instrucci√≥n "Acumulador de tiempo" acumula valores de tiempo dentro de un periodo
definido por el par√°metro PT. Cuando el estado l√≥gico del par√°metro IN cambia a "1", se
ejecuta la medici√≥n de tiempo y se empieza a contar el tiempo PT. Mientras transcurre el
tiempo PT se van acumulando los valores de tiempo que se leen cuando el estado l√≥gico del
par√°metro IN es "1". Si en la entrada "IN" el estado l√≥gico cambia a "0", se interrumpe la
medici√≥n de tiempo. Si en la entrada "IN" el estado l√≥gico cambia de nuevo a "1", se reanuda
la medici√≥n de tiempo. El tiempo acumulado se devuelve en el par√°metro ET y se puede
consultar all√≠. Una vez se alcanza el tiempo PT, el par√°metro Q devolver√° el estado l√≥gico "1".
El par√°metro Q permanece a "1" aunque el estado l√≥gico del par√°metro IN cambie a "0".
El par√°metro R desactiva los par√°metros ET y Q independientemente del estado l√≥gico del
par√°metro IN.
A cada llamada de la instrucci√≥n "Acumulador de tiempo" debe asign√°rsele un temporizador
CEI, en el que se guarden los datos de instancia.
Encontrar√° informaci√≥n sint√°ctica sobre la llamada de temporizadores CEI en estructuras
(multiinstancia) aqu√≠: Llamada de temporizadores CEI (P√°gina 1764)

Para las CPU de la serie S7-1200
El temporizador CEI es una estructura del tipo de datos IEC_TIMER o TONR_TIME que se
puede declarar como se indica a continuaci√≥n:
‚óè Declaraci√≥n de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER (p.
ej., "MyIEC_TIMER_DB")
‚óè Declaraci√≥n como variable local del tipo de datos TONR_TIME en la secci√≥n "Static" de un
bloque de programa (p. ej., #MyIEC_TIMER_Instance)

Para las CPU de la serie S7-1500
El temporizador CEI es una estructura del tipo de datos IEC_TIMER, IEC_LTIMER,
TONR_TIME o TONR_LTIME que se puede declarar como se indica a continuaci√≥n:
‚óè Declaraci√≥n de un bloque de datos de instancia del tipo de datos de sistema IEC_TIMER o
IEC_LTIMER (p. ej., "MyIEC_TIMER_DB")
‚óè Declaraci√≥n como variable local del tipo de datos TONR_TIME o TONR_LTIME en la
secci√≥n "Static" de un bloque de programa (p. ej., #MyIEC_TIMER_Instance)

Temporizador CEI como bloque de datos de instancia del tipo de datos de sistema
<Temporizador_CEI> (Shared DB)
Un temporizador CEI se puede declarar como bloque de datos del modo siguiente:
<DB_temporizador_CEI>.TONR();

1780

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Temporizador CEI como variable local de la interfaz del bloque (multiinstancia)
El temporizador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Timer();

Actualizaci√≥n de los valores actuales en los datos de instancia
Los datos de instancia de "Acumulador de tiempo" se actualizan siguiendo las reglas indicadas
a continuaci√≥n:
‚óè Entrada IN
La instrucci√≥n "Acumulador de tiempo" compara el RLO actual con el RLO de la consulta
anterior, que est√° almacenado en el par√°metro IN de los datos de instancia. Si la instrucci√≥n
detecta un cambio del RLO de "0" a "1", significa que hay un flanco de se√±al ascendente y
se reanuda la medici√≥n de tiempo. Si la instrucci√≥n detecta un cambio de "1" a "0" en el
RLO, significa que hay un flanco de se√±al descendente y la medici√≥n de tiempo se
interrumpe. Una vez procesada la instrucci√≥n "Acumulador de tiempo", el valor del
par√°metro IN se actualiza en los datos de instancia y se utiliza como marca de flancos para
la siguiente consulta.
Tenga en cuenta que la evaluaci√≥n de flancos falla cuando el valor actual del par√°metro IN
es escrito o inicializado por otras funciones.
‚óè Entrada PT
El valor de la entrada PT se escribe en el par√°metro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
‚óè Entrada R
La se√±al "1" en la entrada R inicializa la medici√≥n de tiempo y la bloquea. Los flancos en la
entrada IN se ignoran. La se√±al "0" en la entrada R habilita de nuevo la medici√≥n de tiempo.
‚óè Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
‚Äì Al llamar la instrucci√≥n, si las salidas ET o Q est√°n interconectadas.
O bien:
‚Äì Al acceder a Q o ET.
Si las salidas no est√°n interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucci√≥n se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan par√°metros internos de la
instrucci√≥n "Acumulador de tiempo". Tenga en cuenta que la medici√≥n de tiempo falla
cuando los valores actuales de la instrucci√≥n son escritos o inicializados por otras
funciones.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1781

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se est√° midiendo el
tiempo, se interfiere en la funci√≥n del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse da√±os materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicializaci√≥n de los valores actuales:
‚óè Cargar el bloque con reinicializaci√≥n
‚óè Cargar instant√°neas como valores actuales
‚óè Forzar valores actuales de forma normal o permanente
‚óè La instrucci√≥n "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
‚óè Aseg√∫rese de que la instalaci√≥n se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
‚óè Aseg√∫rese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
‚óè Si los valores actuales se sobrescriben con una instant√°nea, aseg√∫rese de que la
instant√°nea se haya generado en un instante en que la instalaci√≥n estaba en un estado
seguro.
‚óè Aseg√∫rese de que el programa no est√° leyendo ni escribiendo los datos afectados durante
la transferencia.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memo‚Äê Descripci√≥n
ria

IN

Input

BOOL

BOOL

I, Q, M, D, L, P

Entrada de
arranque

R

Input

BOOL

BOOL

I, Q, M, D, L, P

Inicializar los
par√°metros ET
yQ

PT

Input

TIME

TIME, LTI‚Äê
ME

I, Q, M, D, L, P

Tiempo m√°xi‚Äê
mo de lectura
del tiempo.
El valor del pa‚Äê
r√°metro PT de‚Äê
be ser positivo.

1782

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

S7-1200

Tipo de datos
S7-1500

√Årea de memo‚Äê Descripci√≥n
ria

Q

Output

BOOL

BOOL

I, Q, M, D, L, P

Operando que
permanece ac‚Äê
tivado una vez
transcurrido el
tiempo PT.

ET

Output

TIME

TIME, LTI‚Äê
ME

I, Q, M, D, L, P

Tiempo acumu‚Äê
lado

Cronograma de impulsos
La figura siguiente muestra el cronograma de impulsos de la instrucci√≥n "Acumulador de
tiempo":
,1

5

4

37

(7

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"TONR_DB".TONR(IN := "Tag_Start",
R := "Tag_Reset",
PT := "Tag_PresetTime",
Q => "Tag_Status",
ET => "Tag_Time");

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1783

Instrucciones
4.1 Instrucciones
Cuando el estado l√≥gico del operando "Tag_Start" cambia de "0" a "1", el tiempo programado
en el par√°metro PT empieza a contar. Mientras transcurre el tiempo, se van acumulando los
valores de tiempo que se leen cuando el estado l√≥gico del operando "Tag_Start" es "1". El
tiempo acumulado se almacena en el operando "Tag_Time". Una vez alcanzado el valor de
tiempo indicado en el par√°metro PT, el operando "Tag_Status" adopta el estado l√≥gico "1". El
valor de tiempo actual se guarda en el operando "Tag_Time".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

RESET_TIMER: Inicializar temporizador
Descripci√≥n
La instrucci√≥n "Inicializar temporizador" permite poner a "0" un temporizador CEI. Los
componentes de estructura del temporizador en el bloque de datos indicado se ponen a "0".

1784

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Actualizaci√≥n de los valores actuales
La instrucci√≥n no afecta al RLO. En el par√°metro TIMER se asigna a la instrucci√≥n "Inicializar
temporizador" un temporizador CEI declarado en el programa. La instrucci√≥n se debe
programar dentro de una instrucci√≥n IF. Los datos de la instrucci√≥n se actualizan √∫nicamente
al efectuar una llamada de la instrucci√≥n, y no cada vez que se accede al temporizador CEI
asignado. La consulta de datos es igual a la llamada de instrucci√≥n √∫nicamente hasta la
siguiente llamada de instrucci√≥n.
PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se est√° ejecutando
el temporizador, se interfiere en la funci√≥n del temporizador CEI. Esto puede provocar
incoherencias entre el programa y el proceso real. Como consecuencia pueden producirse
da√±os materiales y personales graves.
Las funciones siguientes pueden provocar la reinicializaci√≥n de los valores actuales:
‚óè Cargar el bloque con reinicializaci√≥n
‚óè Cargar instant√°neas como valores actuales
‚óè Forzar valores actuales de forma normal o permanente
‚óè La instrucci√≥n "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
‚óè Aseg√∫rese de que la instalaci√≥n se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
‚óè Aseg√∫rese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
‚óè Si los valores actuales se sobrescriben con una instant√°nea, aseg√∫rese de que la
instant√°nea se haya generado en un instante en que la instalaci√≥n estaba en un estado
seguro.
‚óè Aseg√∫rese de que el programa no est√° leyendo ni escribiendo los datos afectados durante
la transferencia.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1785

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro
<Temporizador
CEI>

Declaraci√≥n
Output

Tipo de datos

√Årea de memo‚Äê
ria

S7-1200

S7-1500

IEC_TI‚Äê
MER, TP_TI‚Äê
ME,
TON_TIME,
TOF_TIME,
TONR_TIME

IEC_TI‚Äê
D, L
MER,
IEC_LTI‚Äê
MER, TP_TI‚Äê
ME, TP_LTI‚Äê
ME,
TON_TIME,
TON_LTI‚Äê
ME, TOF_TI‚Äê
ME,
TOF_LTI‚Äê
ME,
TONR_TI‚Äê
ME,
TONR_LTI‚Äê
ME

Descripci√≥n
Temporizador
CEI que se ini‚Äê
cializa

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
IF #started = false THEN
"TON_DB".TON(IN := "Tag_Start",
PT := "Tag_PresetTime",
Q => "Tag_Status",
ET => "Tag_ElapsedTime");
#started := true;
END_IF;
IF "TON_DB".ET < T#25s THEN
RESET_TIMER(TIMER := "TON_DB");
#started := false;
END_IF;

Si la variable #started devuelve el estado l√≥gico "0", se ejecuta la instrucci√≥n "Retardo al
conectar" cuando se produce un flanco de se√±al ascendente en el operando "Tag_Start". El
temporizador CEI depositado en el bloque de datos de instancia "TON_DB" arranca con el
tiempo predeterminado por el operando "Tag_PresetTime". El operando "Tag_Status" se
activa una vez transcurrido el tiempo predeterminado por el operando "Tag_PresetTime". El
par√°metro Q permanecer√° activado mientras el operando "Tag_Start" tenga el estado l√≥gico
"1". Cuando el estado l√≥gico de la entrada de arranque cambia de "1" a "0", se desactiva el
operando en el par√°metro Q.

1786

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si el tiempo transcurrido del temporizador CEI "TON_DB" es inferior a 25 s, la instrucci√≥n
"Inicializar temporizador" se ejecuta y el temporizador depositado en el bloque de datos
instancia "TON_DB" se inicializa.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

PRESET_TIMER: Cargar tiempo
Descripci√≥n
La instrucci√≥n "Cargar tiempo" permite ajustar el tiempo de un temporizador CEI. La
instrucci√≥n se ejecuta en cada ciclo si el resultado l√≥gico (RLO) de la entrada de la instrucci√≥n
tiene el estado l√≥gico "1".
A la instrucci√≥n "Cargar tiempo" debe asign√°rsele un temporizador CEI declarado en el
programa. La instrucci√≥n escribe el tiempo indicado en la estructura del temporizador CEI
indicado.
La instrucci√≥n no afecta al RLO.
Nota
Si el temporizador CEI indicado se ejecuta mientras se ejecuta la instrucci√≥n, esta sobrescribe
el tiempo actual del temporizador CEI indicado. Esto puede modificar el estado del
temporizador CEI.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1787

Instrucciones
4.1 Instrucciones

Actualizaci√≥n de los valores actuales
La actualizaci√≥n de los datos de la instrucci√≥n se lleva a cabo cuando se llama la instrucci√≥n
y cada vez que se accede al temporizador CEI asignado. La consulta de Q o ET (p. ej.
"MyTimer".Q y "MyTimer".ET) actualiza la estructura de IEC_TIMER.
PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se est√° ejecutando
el temporizador, se interfiere en la funci√≥n del temporizador CEI. Esto puede provocar
incoherencias entre el programa y el proceso real. Como consecuencia pueden producirse
da√±os materiales y personales graves.
Las funciones siguientes pueden provocar la reinicializaci√≥n de los valores actuales:
‚óè Cargar el bloque con reinicializaci√≥n
‚óè Cargar instant√°neas como valores actuales
‚óè Forzar valores actuales de forma normal o permanente
‚óè La instrucci√≥n "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
‚óè Aseg√∫rese de que la instalaci√≥n se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
‚óè Aseg√∫rese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
‚óè Si los valores actuales se sobrescriben con una instant√°nea, aseg√∫rese de que la
instant√°nea se haya generado en un instante en que la instalaci√≥n estaba en un estado
seguro.
‚óè Aseg√∫rese de que el programa no est√° leyendo ni escribiendo los datos afectados durante
la transferencia.

1788

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memo‚Äê
ria

Descripci√≥n

I, Q, M, D, L

Tiempo que
cuenta el tempo‚Äê
rizador CEI.

<Tiempo>

Input

TIME

TIME, LTI‚Äê
ME

<Temporizador
CEI>

Output

IEC_TI‚Äê
MER, TP_TI‚Äê
ME,
TON_TIME,
TOF_TIME,
TONR_TIME

D, L
IEC_TI‚Äê
MER,
IEC_LTI‚Äê
MER, TP_TI‚Äê
ME, TP_LTI‚Äê
ME,
TON_TIME,
TON_LTI‚Äê
ME, TOF_TI‚Äê
ME,
TOF_LTI‚Äê
ME,
TONR_TI‚Äê
ME,
TONR_LTI‚Äê
ME

Temporizador
CEI cuyo tiempo
se ajusta.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
IF #started = false THEN
"TON_DB".TON(IN := "Tag_Start",
PT := "Tag_PresetTime",
Q => "Tag_Status",
ET => "Tag_ElapsedTime");
#started := true;
#preset = true
END_IF;
IF "TON_DB".ET < T#10s AND #preset = true THEN
PRESET_TIMER(PT := T#25s,
TIMER := "TON_DB");
#preset := false;
END_IF;

Si la variable #started tiene el estado l√≥gico "0" y el operando "Tag_Start" tiene un flanco de
se√±al ascendente, se ejecuta la instrucci√≥n "Retardo al conectar". El temporizador CEI
depositado en el bloque de datos de instancia "TON_DB" arranca con el tiempo
predeterminado por el operando "Tag_PresetTime". El operando "Tag_Status" se activa una
vez transcurrido el tiempo PT especificado por el operando "Tag_PresetTime". El par√°metro Q

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1789

Instrucciones
4.1 Instrucciones
permanecer√° activado mientras el operando "Tag_Start" tenga el estado l√≥gico "1". Cuando el
estado l√≥gico de la entrada de arranque cambia de "1" a "0", se desactiva el operando en el
par√°metro Q.
Si el tiempo transcurrido del temporizador CEI "TON_DB" es inferior a 10 s y la variable #preset
tiene el estado l√≥gico "1", se ejecuta la instrucci√≥n "Cargar tiempo". La instrucci√≥n escribe el
tiempo indicado en el par√°metro PT en el bloque de datos instancia "TON_DB" y sobrescribe
a la vez el valor de tiempo del operando "Tag_PresetTime" en el bloque de datos instancia.
Esto puede modificar el estado l√≥gico del estado del temporizador en la siguiente consulta o en
el siguiente acceso a "TON_DB".Q o "TON_DB".ET.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Legacy
S_PULSE: Parametrizar y arrancar temporizador como impulso
Descripci√≥n
La instrucci√≥n "Parametrizar y arrancar temporizador como impulso" arranca el temporizador
programado en el par√°metro T_NO cuando se detecta un cambio del resultado l√≥gico (RLO) de
"0" a "1" (flanco de se√±al ascendente) en el par√°metro S. El temporizador cuenta el tiempo
programado TV mientras el estado l√≥gico del par√°metro S sea "1".
Si el estado l√≥gico del par√°metro S cambia a "0" antes de que transcurra el tiempo programado,
el temporizador se detiene y el par√°metro "Q" adopta el estado l√≥gico "0".
El tiempo se compone internamente de un valor de tiempo y una base de tiempo y se programa
en el par√°metro TV. Cuando se inicia la instrucci√≥n, el valor de tiempo programado se cuenta
hacia atr√°s hasta cero. La base de tiempo indica con qu√© periodo de tiempo se modifica el valor
de tiempo. El valor actual de tiempo se deposita en el par√°metro BI.
Si el temporizador est√° contando y el estado l√≥gico de la entrada R cambia a "1", el valor actual
de tiempo y la base de tiempo tambi√©n se ponen a cero. Si el temporizador no est√° en marcha,
el estado l√≥gico "1" de la entrada R no provoca ning√∫n efecto.
El par√°metro Q devuelve el estado l√≥gico "1" mientras el temporizador est√° contando y el
estado l√≥gico del par√°metro S es "1". Si el estado l√≥gico del par√°metro S cambia a "0" antes
de que transcurra el tiempo programado, el par√°metro Q devuelve el estado l√≥gico "0". Si el
par√°metro R resetea el temporizador o si el tiempo ha transcurrido, el par√°metro Q tambi√©n
devuelve el estado l√≥gico "0".

1790

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los datos de la instrucci√≥n se actualizan con cada acceso. Por este motivo es posible que una
consulta de datos al principio del ciclo devuelva valores diferentes en comparaci√≥n con el fin
del ciclo.
Nota
En la c√©lula de temporizaci√≥n, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducci√≥n se realiza de modo as√≠ncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como m√°ximo hasta un
intervalo de la base de tiempo.
Encontrar√° un ejemplo de la estructura de una c√©lula de temporizaci√≥n en: Consulte tambi√©n
"L: Cargar valor del temporizador".

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

T_NO

Input

TIMER, INT

T

Temporizador que arranca.
El n√∫mero de temporizado‚Äê
res depende de la CPU.

S

Input

BOOL

I, Q, M, D, L

Entrada de arranque

TV

Input

S5TIME, WORD

I, Q, M, D, L

Valor de tiempo predetermi‚Äê
nado

R

Input

BOOL

I, Q, M, D, L, P

Entrada de reset

Q

Output

BOOL

I, Q, M, D, L, P

Estado del temporizador

BI

Output

WORD

I, Q, M, D, L, P

Valor actual de tiempo en c√≥‚Äê
digo dual

S5TIME

I, Q, M, D, L

Valor de tiempo actual

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1791

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La imagen siguiente muestra el cronograma de impulsos de la instrucci√≥n "Parametrizar y
arrancar temporizador como impulso":
W

W

W

5/2HQODHQWUDGD6

5/2HQODHQWUDGD5

(OWLHPSRWUDQVFXUUH

&RQVXOWD‡≤Ø‡≤Ø

&RQVXOWD‡≤Ø‡≤Ø

W WLHPSRSURJUDPDGR

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := S_PULSE(T_NO := "Timer_1",
S := "Tag_1",
TV := "Tag_Number",
R := "Tag_Reset",
Q => "Tag_Status",
BI => "Tag_Value");

Cuando el estado l√≥gico del operando "Tag_1" cambia de "0" a "1", el temporizador "Timer_1"
se pone en marcha. El temporizador empieza a contar con el valor de tiempo del operando
"Tag_Number" y sigue contando mientras el operando "Tag_1" devuelva el estado l√≥gico "1".
Si el estado l√≥gico del par√°metro S cambia a "0" antes de que transcurra el tiempo programado,
el operando "Tag_Status" adopta el estado l√≥gico "0". Si el par√°metro R resetea el
temporizador o si el tiempo ha transcurrido, el operando "Tag_Status" tambi√©n devuelve el
estado l√≥gico "0".

1792

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El valor actual de tiempo se guarda en c√≥digo dual en el operando "Tag_Value" y se devuelve
como valor de funci√≥n.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
L: Cargar valor del temporizador (P√°gina 1604)
Principios b√°sicos de SCL (P√°gina 8115)

S_PEXT: Parametrizar y arrancar temporizador como impulso prolongado
Descripci√≥n
La instrucci√≥n "Parametrizar y arrancar temporizador como impulso prolongado" arranca el
temporizador programado cuando se detecta un flanco de se√±al ascendente en el par√°metro
S. El temporizador deja de contar el tiempo programado TV aunque el estado l√≥gico del
par√°metro S cambie a "0". Mientras el temporizador est√° contando, el par√°metro Q devuelve
el estado l√≥gico "1".
Una vez transcurrido el tiempo, el par√°metro Q adopta el valor l√≥gico "0". Si el estado l√≥gico del
par√°metro S cambia de "0" a "1" mientras el temporizador est√° contando, el temporizador se
inicia de nuevo con el tiempo programado en el par√°metro TV.
El tiempo se compone internamente de un valor de tiempo y una base de tiempo y se programa
en el par√°metro TV. Cuando se inicia la instrucci√≥n, el valor de tiempo programado se cuenta
hacia atr√°s hasta cero. La base de tiempo indica con qu√© periodo de tiempo se modifica el valor
de tiempo. El valor actual de tiempo se deposita en el par√°metro BI.
Si el temporizador est√° contando y el estado l√≥gico del par√°metro R cambia a "1", el valor
actual de tiempo y la base de tiempo tambi√©n se ponen a cero. Si el temporizador no est√°
contando, el estado l√≥gico "1" en el par√°metro R no tiene ning√∫n efecto.
Los datos de la instrucci√≥n se actualizan con cada acceso. Por este motivo es posible que una
consulta de datos al principio del ciclo devuelva valores diferentes en comparaci√≥n con el fin
del ciclo.
Nota
En la c√©lula de temporizaci√≥n, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducci√≥n se realiza de modo as√≠ncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como m√°ximo hasta un
intervalo de la base de tiempo.
Encontrar√° un ejemplo de la estructura de una c√©lula de temporizaci√≥n en: Consulte tambi√©n
"L: Cargar valor del temporizador".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1793

Instrucciones
4.1 Instrucciones

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de me‚Äê
moria

Descripci√≥n

T_NO

Input

TIMER, INT

T

Temporizador que arranca.
El n√∫mero de temporizadores de‚Äê
pende de la CPU.

S

Input

BOOL

I, Q, M, D, L

Entrada de arranque

TV

Input

S5TIME,
WORD

I, Q, M, D, L

Valor de tiempo predeterminado

R

Input

BOOL

I, Q, M, D, L, P Entrada de reset

Q

Output

BOOL

I, Q, M, D, L, P Estado del temporizador

BI

Output

WORD

I, Q, M, D, L, P Valor actual de tiempo en c√≥digo
dual

S5TIME

I, Q, M, D, L

Valor de funci√≥n

Valor de tiempo actual

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

1794

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La imagen siguiente muestra el cronograma de impulsos de la instrucci√≥n "Parametrizar y
arrancar temporizador como impulso prolongado":
W

W

W

W

5/2HQODHQWUDGD6

5/2HQODHQWUDGD5

7HPSRUL]DGRUHQPDUFKD

&RQVXOWD

&RQVXOWD
W WLHPSRSURJUDPDGR

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := S_PEXT(T_NO := "Timer_1",
S := "Tag_1",
TV := "Tag_Number",
R := "Tag_Reset",
Q => "Tag_Status",
BI => "Tag_Value");

Cuando el estado l√≥gico del operando "Tag_1" cambia de "0" a "1", el temporizador "Timer_1"
se pone en marcha. Mientras el temporizador est√° en marcha, el operando "Tag_Status"
devuelve el estado l√≥gico "1". Una vez transcurrido el tiempo, el operando "Tag_Status" adopta
el valor l√≥gico "0". Si el estado l√≥gico de la entrada S cambia de "0" a "1" mientras el
temporizador est√° contando, el temporizador se inicia de nuevo con el tiempo "Tag_Number".
El valor actual de tiempo se guarda en c√≥digo dual en el operando "Tag_Value" y se devuelve
como valor de funci√≥n.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1795

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
L: Cargar valor del temporizador (P√°gina 1604)
Principios b√°sicos de SCL (P√°gina 8115)

S_ODT: Parametrizar y arrancar temporizador como retardo a la conexi√≥n
Descripci√≥n
La instrucci√≥n "Parametrizar y arrancar temporizador como retardo a la conexi√≥n" arranca el
temporizador programado como retardo a la conexi√≥n cuando se detecta un flanco de se√±al
ascendente en el par√°metro S. El temporizador cuenta el tiempo programado TV mientras el
estado l√≥gico del par√°metro S sea "1".
Si el tiempo ha transcurrido correctamente y el par√°metro S sigue presentando el estado l√≥gico
"1", el par√°metro Q devuelve el estado l√≥gico "1". Si el estado l√≥gico del par√°metro S cambia
de "1" a "0" mientras el temporizador est√° contando, este se detiene. En este caso, la salida Q
adopta el estado l√≥gico "0".
El tiempo se compone internamente de un valor de tiempo y una base de tiempo y se programa
en el par√°metro TV. Cuando se inicia la instrucci√≥n, el valor de tiempo programado se cuenta
hacia atr√°s hasta cero. La base de tiempo indica con qu√© periodo de tiempo se modifica el valor
de tiempo. El valor actual de tiempo se deposita en el par√°metro BI.
Si el temporizador est√° contando y el estado l√≥gico de la entrada R cambia de "0" a "1", el valor
actual de tiempo y la base de tiempo tambi√©n se ponen a cero. En este caso, el estado l√≥gico
del par√°metro Q es "0". El temporizador se resetea si el par√°metro R presenta el estado l√≥gico
"1", aunque el temporizador no est√© en marcha y el resultado l√≥gico (RLO) del par√°metro S sea
"1".
Los datos de la instrucci√≥n se actualizan con cada acceso. Por este motivo es posible que una
consulta de datos al principio del ciclo devuelva valores diferentes en comparaci√≥n con el fin
del ciclo.
Nota
En la c√©lula de temporizaci√≥n, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducci√≥n se realiza de modo as√≠ncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como m√°ximo hasta un
intervalo de la base de tiempo.
Encontrar√° un ejemplo de la estructura de una c√©lula de temporizaci√≥n en: Consulte tambi√©n
"L: Cargar valor del temporizador".

1796

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memoria Descripci√≥n

T_NO

Input

TIMER, INT

T

Temporizador que arranca.
El n√∫mero de temporizadores
depende de la CPU.

S

Input

BOOL

I, Q, M, D, L

Entrada de arranque

TV

Input

S5TIME,
WORD

I, Q, M, D, L

Valor de tiempo predetermina‚Äê
do

R

Input

BOOL

I, Q, M, D, L, P

Entrada de reset

Q

Output

BOOL

I, Q, M, D, L, P

Estado del temporizador

BI

Output

WORD

I, Q, M, D, L, P

Valor actual de tiempo en c√≥di‚Äê
go dual

S5TIME

I, Q, M, D, L

Valor de tiempo actual

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Cronograma de impulsos
La imagen siguiente muestra el cronograma de impulsos de la instrucci√≥n "Parametrizar y
arrancar temporizador como retardo a la conexi√≥n":
W

W

W

5/2HQODHQWUDGD6

5/2HQODHQWUDGD5

(OWLHPSRWUDQVFXUUH

&RQVXOWD‡≤Ø‡≤Ø

&RQVXOWD‡≤Ø‡≤Ø
W WLHPSRSURJUDPDGR

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1797

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := S_ODT(T_NO := "Timer_1",
S := "Tag_1",
TV := "Tag_Number",
R := "Tag_Reset",
Q => "Tag_Status",
BI => "Tag_Value");

Cuando el estado l√≥gico del operando "Tag_1" cambia de "0" a "1", el temporizador "Timer_1"
se pone en marcha. El temporizador cuenta el tiempo "Tag_Number" mientras el estado l√≥gico
del operando "Tag_1" sea "1".
Si el tiempo ha transcurrido correctamente y el operando "Tag_Status" presenta el estado
l√≥gico "1", el operando "Tag_Status" se pone a "1". Si el estado l√≥gico del operando "Tag_1"
cambia de "1" a "0" mientras el temporizador est√° contando, este se detiene. El operando
"Tag_Status" devuelve en ese caso el estado l√≥gico "0".
El valor actual de tiempo se guarda en c√≥digo dual en el operando "Tag_Value" y se devuelve
como valor de funci√≥n.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
L: Cargar valor del temporizador (P√°gina 1604)
Principios b√°sicos de SCL (P√°gina 8115)

S_ODTS: Parametrizar y arrancar temporizador como retardo a la conexi√≥n con memoria
Descripci√≥n
La instrucci√≥n "Parametrizar y arrancar temporizador como retardo a la conexi√≥n con
memoria" arranca el temporizador programado cuando se detecta un flanco de se√±al
ascendente en el par√°metro S. El temporizador deja de contar el tiempo programado TV
aunque el estado l√≥gico del par√°metro S cambie a "0".
Una vez transcurrido el tiempo, el par√°metro Q devuelve el estado l√≥gico "1"
independientemente del estado l√≥gico del par√°metro S. Si el estado l√≥gico del par√°metro S
cambia de "0" a "1" mientras el temporizador est√° contando, el temporizador se inicia de nuevo
con el tiempo programado TV.
El tiempo se compone internamente de un valor de tiempo y una base de tiempo y se programa
en el par√°metro TV. Cuando se inicia la instrucci√≥n, el valor de tiempo programado se cuenta
hacia atr√°s hasta cero. La base de tiempo indica con qu√© periodo de tiempo se modifica el valor
de tiempo. El valor actual de tiempo se deposita en el par√°metro BI.
El estado l√≥gico "1" del par√°metro R pone a "0" el valor actual de tiempo y la base de tiempo,
independientemente del estado l√≥gico del par√°metro S. En este caso, el estado l√≥gico del
par√°metro Q es "0".

1798

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los datos de la instrucci√≥n se actualizan con cada acceso. Por este motivo es posible que una
consulta de datos al principio del ciclo devuelva valores diferentes en comparaci√≥n con el fin
del ciclo.
Nota
En la c√©lula de temporizaci√≥n, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducci√≥n se realiza de modo as√≠ncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como m√°ximo hasta un
intervalo de la base de tiempo.
Encontrar√° un ejemplo de la estructura de una c√©lula de temporizaci√≥n en: Consulte tambi√©n
"L: Cargar valor del temporizador".

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

T_NO

Input

TIMER, INT

T

Temporizador que arranca.
El n√∫mero de temporizadores
depende de la CPU.

S

Input

BOOL

I, Q, M, D, L

Entrada de arranque

TV

Input

S5TIME,
WORD

I, Q, M, D, L

Valor de tiempo predetermina‚Äê
do

R

Input

BOOL

I, Q, M, D, L, P

Entrada de reset

Q

Output

BOOL

I, Q, M, D, L, P

Estado del temporizador

BI

Output

WORD

I, Q, M, D, L, P

Valor actual de tiempo en c√≥‚Äê
digo dual

S5TIME

I, Q, M, D, L

Valor de tiempo actual

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1799

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La imagen siguiente muestra el cronograma de impulsos de la instrucci√≥n "Parametrizar y
arrancar temporizador como retardo a la conexi√≥n con memoria":
W

W

W

W

5/2HQODHQWUDGD6

5/2HQODHQWUDGD5

(OWLHPSRWUDQVFXUUH

&RQVXOWD‡≤Ø‡≤Ø
&RQVXOWD‡≤Ø‡≤Ø
W WLHPSRSURJUDPDGR

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := S_ODTS(T_NO := "Timer_1",
S := "Tag_1",
TV := "Tag_Number",
R := "Tag_Reset",
Q => "Tag_Status",
BI => "Tag_Value");

Cuando el estado l√≥gico del operando "Tag_1" cambia de "0" a "1", el temporizador "Timer_1"
se pone en marcha. El temporizador cuenta el tiempo "Tag_Number".
Una vez transcurrido el tiempo, el operando "Tag_Status" devuelve el estado l√≥gico "1"
independientemente del estado l√≥gico del operando "Tag_1". Si el estado l√≥gico del operando
"Tag_1" cambia de "0" a "1" mientras el temporizador est√° contando, el temporizador se inicia
de nuevo con el tiempo "Tag_Number".
El valor actual de tiempo se guarda en c√≥digo dual en el operando "Tag_Value" y se devuelve
como valor de funci√≥n.

1800

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
L: Cargar valor del temporizador (P√°gina 1604)
Principios b√°sicos de SCL (P√°gina 8115)

S_OFFDT: Parametrizar y arrancar temporizador como retardo a la desconexi√≥n
Descripci√≥n
La instrucci√≥n "Parametrizar y arrancar temporizador como retardo a la desconexi√≥n" arranca
el temporizador programado cuando se detecta un flanco de se√±al descendente en el
par√°metro S. El temporizador cuenta el tiempo programado TV. Mientras el temporizador est√°
contando o el par√°metro S devuelve el estado l√≥gico "1", el par√°metro Q presenta el estado
l√≥gico "1".
Si el tiempo ha transcurrido y el estado l√≥gico es "0", el par√°metro Q adopta el valor l√≥gico "0".
Si el estado l√≥gico del par√°metro S cambia de "0" a "1" mientras el temporizador est√° en
marcha, este se detiene. El temporizador solo arranca de nuevo cuando se detecta un flanco
de se√±al descendente en el par√°metro S.
El tiempo se compone internamente de un valor de tiempo y una base de tiempo y se programa
en el par√°metro TV. Cuando se inicia la instrucci√≥n, el valor de tiempo programado se cuenta
hacia atr√°s hasta cero. La base de tiempo indica con qu√© periodo de tiempo se modifica el valor
de tiempo. El valor actual de tiempo se deposita en el par√°metro BI.
El estado l√≥gico "1" del par√°metro R pone a "0" el valor actual de tiempo y la base de tiempo.
En este caso, el estado l√≥gico del par√°metro Q es "0".
Los datos de la instrucci√≥n se actualizan con cada acceso. Por este motivo es posible que una
consulta de datos al principio del ciclo devuelva valores diferentes en comparaci√≥n con el fin
del ciclo.
Nota
En la c√©lula de temporizaci√≥n, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducci√≥n se realiza de modo as√≠ncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como m√°ximo hasta un
intervalo de la base de tiempo.
Encontrar√° un ejemplo de la estructura de una c√©lula de temporizaci√≥n en: Consulte tambi√©n
"L: Cargar valor del temporizador".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1801

Instrucciones
4.1 Instrucciones

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memo‚Äê Descripci√≥n
ria

T_NO

Input

TIMER, INT

T

Temporizador que arranca.
El n√∫mero de temporizadores
depende de la CPU.

S

Input

BOOL

I, Q, M, D, L

Entrada de arranque

TV

Input

S5TIME,
WORD

I, Q, M, D, L

Valor de tiempo predeterminado

R

Input

BOOL

I, Q, M, D, L, P

Entrada de reset

Q

Output

BOOL

I, Q, M, D, L, P

Estado del temporizador

BI

Output

WORD

I, Q, M, D, L, P

Valor actual de tiempo en c√≥di‚Äê
go dual

S5TIME

I, Q, M, D, L

Valor de tiempo actual

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Cronograma de impulsos
La imagen siguiente muestra el cronograma de impulsos de la instrucci√≥n "Parametrizar y
arrancar temporizador como retardo a la desconexi√≥n":
W

W

W

W

5/2HQODHQWUDGD6

5/2HQODHQWUDGD5

7HPSRUL]DGRUHQPDUFKD

&RQVXOWD

&RQVXOWD
W WLHPSRSURJUDPDGR

1802

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := S_OFFDT(T_NO := "Timer_1",
S := "Tag_1",
TV := "Tag_Number",
R := "Tag_Reset",
Q => "Tag_Status",
BI => "Tag_Value");

Cuando el estado l√≥gico del operando "Tag_1" cambia de "1" a "0", el temporizador "Timer_1"
arranca. El temporizador cuenta el tiempo "Tag_Number". Mientras el temporizador est√°
contando o el operando "Tag_1" devuelve el estado l√≥gico "1", el operando "Tag_Status"
presenta el estado l√≥gico "1".
Si el tiempo ha transcurrido y el estado l√≥gico del operando "Tag_1" es "0", el operando
"Tag_Status" adopta el valor l√≥gico "0". Si el estado l√≥gico del operando "Tag_1" cambia de "0"
a "1" mientras el temporizador est√° en marcha, el temporizador se reinicia. El temporizador
solo arranca de nuevo cuando se detecta un flanco descendente en el par√°metro S.
El valor actual de tiempo se guarda en c√≥digo dual en el operando "Tag_Value" y se devuelve
como valor de funci√≥n.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
L: Cargar valor del temporizador (P√°gina 1604)
Principios b√°sicos de SCL (P√°gina 8115)

Contadores
Llamada de contadores CEI
Descripci√≥n
Existe la posibilidad de declarar el contador CEI como instancia individual o multiinstancia y
llamarlo en el c√≥digo del programa.
Est√°n disponibles las siguientes posibilidades sint√°cticas para la declaraci√≥n de un contador
CEI como multiinstancia dentro de una estructura de la interfaz del bloque:

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1803

Instrucciones
4.1 Instrucciones

Contador CEI como elemento ARRAY
Declaraci√≥n en la interfaz del bloque:

C√≥digo del programa:
SCL
#MyARRAY[1].CTU(CU := <Operando>, PV := <Operando>)

Declaraci√≥n en la interfaz del bloque:

C√≥digo del programa:
SCL
#MyARRAY[#index](CU := <Operando>, PV := <Operando>)

Contador CEI en una estructura an√≥nima
Declaraci√≥n en la interfaz del bloque:

C√≥digo del programa:
SCL
#MyStruct.FirstTime.CTU(CU := <Operando>, PV := <Operando>)

Declaraci√≥n en la interfaz del bloque:

1804

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

C√≥digo del programa:
SCL
#MyStruct.FirstTime(CU := <Operando>, PV := <Operando>)

Contador CEI en el bloque de datos global
Declaraci√≥n en el bloque de datos:

C√≥digo del programa:
SCL
"MyGlobalDB".Counter.FirstCount.CTU(CU := <Operando>, PV := <Operando>)

Declaraci√≥n en el bloque de datos:

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1805

Instrucciones
4.1 Instrucciones

C√≥digo del programa:
SCL
"MyGlobalDB".Counter.SecondCount(CU := <Operando>, PV := <Operando>)

Contador CEI como elemento en la interfaz del bloque
Declaraci√≥n en la interfaz del bloque:

C√≥digo del programa:
SCL
#Counter.FirstCount.CTU(CU := <Operando>, PV := <Operando>)

Declaraci√≥n en la interfaz del bloque:

1806

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

C√≥digo del programa:
SCL
#Counter.SecondCount(CU := <Operando>, PV := <Operando>)

Contador CEI en un DB de ARRAY
Declaraci√≥n en el DB de ARRAY:

C√≥digo del programa:
SCL
"MyARRAYDB"."THIS"[0].FirstCount.CTU(CU := <Operando>, PV := <Operando>)

Declaraci√≥n en el DB de ARRAY:

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1807

Instrucciones
4.1 Instrucciones

C√≥digo del programa:
SCL
"MyARRAYDB"."THIS"[0].SecondCount(CU := <Operando>, PV := <Operando>)

CTU: Contador ascendente
Descripci√≥n
La instrucci√≥n "Contador ascendente" incrementa el valor del par√°metro CV. Cuando el estado
l√≥gico del par√°metro CU cambia de "0" a "1" (flanco de se√±al ascendente), se ejecuta la
instrucci√≥n y el valor de contaje actual del par√°metro CV se incrementa en uno. El valor de
contaje se incrementa cada vez que se detecta un flanco de se√±al ascendente, hasta alcanzar
el valor l√≠mite superior del tipo de datos indicado en el par√°metro CV. Cuando se alcanza el
valor l√≠mite superior, el estado l√≥gico del par√°metro CU deja de tener efecto en la instrucci√≥n.
El estado del contador se puede consultar en el par√°metro Q. El estado l√≥gico del par√°metro
Q es determinado por el par√°metro PV. Si el valor de contaje actual es mayor o igual al valor
del par√°metro PV, el par√°metro Q adopta el estado l√≥gico "1". En los restantes casos, el estado
l√≥gico del par√°metro Q es "0". En el par√°metro PV tambi√©n se puede indicar una constante.
El valor del par√°metro CV se pone a cero cuando el estado l√≥gico del par√°metro R cambia a
"1". Mientras el par√°metro R tenga el estado l√≥gico "1", el estado l√≥gico del par√°metro CU no
tendr√° efecto alguno en la instrucci√≥n.
Nota
Utilice el contador en una sola posici√≥n del programa para evitar fallos de contaje.
A cada llamada de la instrucci√≥n "Contador ascendente" debe asign√°rsele un contador CEI, en
el que se guarden los datos de la instrucci√≥n. Un contador CEI es una estructura con uno de
los tipos de datos siguientes:

1808

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Para las CPU de la serie S7-1200
Bloque de datos del tipo de datos de sistema
IEC_<Contador> (Shared DB)

Variable local

‚óè IEC_SCOUNTER / IEC_USCOUNTER

‚óè CTU_SINT / CTU_USINT

‚óè IEC_COUNTER / IEC_UCOUNTER

‚óè CTU_INT / CTU_UINT

‚óè IEC_DCOUNTER / IEC_UDCOUNTER

‚óè CTU_DINT / CTU_UDINT

Para las CPU de la serie S7-1500
Bloque de datos del tipo de datos de sistema
IEC_<Contador> (Shared DB)

Variable local

‚óè IEC_SCOUNTER / IEC_USCOUNTER

‚óè CTU_SINT / CTU_USINT

‚óè IEC_COUNTER / IEC_UCOUNTER

‚óè CTU_INT / CTU_UINT

‚óè IEC_DCOUNTER / IEC_UDCOUNTER

‚óè CTU_DINT / CTU_UDINT

‚óè IEC_LCOUNTER / IEC_ULCOUNTER

‚óè CTU_LINT / CTU_ULINT

Un contador CEI se puede declarar del modo siguiente:
‚óè Declaraci√≥n de un bloque de datos de instancia del tipo de datos de sistema
IEC_<nombre_del_contador> (p. ej. "MyIEC_COUNTER_DB")
‚óè Declaraci√≥n como variable local del tipo de datos CTU_<tipo de datos> en la secci√≥n
"Static" de un bloque de programa (p. ej., #MyIEC_COUNTER_Instance)
Si el contador CEI se crea en un bloque de datos propio (instancia individual), el bloque de
datos de instancia se crea de forma est√°ndar con "acceso optimizado al bloque" y las distintas
variables se declaran remanentes.
Si el contador CEI se crea como variable local (multiinstancia) en un bloque de funci√≥n con
"acceso optimizado al bloque", esta se declara remanente en la interfaz del bloque.

Contador CEI como bloque de datos del tipo de datos de sistema IEC_<Nombre_del_contador> (Shared
DB)
Un contador CEI se puede declarar como bloque de datos del modo siguiente:
<IEC_contador_DB>.CTU();

Contador CEI como variable local de la interfaz del bloque (multiinstancia)
El contador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Counter();
Encontrar√° informaci√≥n sint√°ctica sobre la llamada de contadores CEI en estructuras
(multiinstancia) aqu√≠: Llamada de contadores CEI (P√°gina 1803)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1809

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

CU

Input

R

Input

PV

Tipo de datos

√Årea de memoria

Descripci√≥n

BOOL

I, Q, M, D, L

Entrada de contaje

BOOL

I, Q, M, D, L, P

Entrada de reset

Input

Enteros

I, Q, M, D, L, P

Valor con el que se activa la
salida Q

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"IEC_COUNTER_DB".CTU(CU := "Tag_Start",
R := "Tag_Reset",
PV := "Tag_PresetValue",
Q => "Tag_Status",
CV => "Tag_CounterValue");

Cuando el estado l√≥gico del operando "Tag_Start" cambia de "0" a "1", se ejecuta la instrucci√≥n
"Contador ascendente" y el valor de contaje actual del operando "Tag_CounterValue" se
incrementa en uno. Con cada flanco de se√±al ascendente posterior, el valor de contaje ir√°
incrementando hasta alcanzar el valor l√≠mite superior del tipo de datos indicado (INT = 32767).
La salida "Tag_Status" devuelve el estado l√≥gico "1" mientras el valor de contaje actual sea
mayor o igual que el valor del operando "Tag_PresetValue". En todos los dem√°s casos, la
salida "Tag_Status" devuelve el estado l√≥gico "0". El valor de contaje actual se guarda en el
operando "Tag_CounterValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Ajustar la remanencia en un bloque de datos de instancia (P√°gina 7855)
Principios b√°sicos de SCL (P√°gina 8115)

1810

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CTD: Contador descendente
Descripci√≥n
La instrucci√≥n "Contador descendente" decrementa el valor del par√°metro CV. Cuando el
estado l√≥gico del par√°metro CD cambia de "0" a "1" (flanco de se√±al ascendente), se ejecuta
la instrucci√≥n y el valor de contaje actual del par√°metro CV se decrementa en uno. Cada vez
que se detecta un flanco de se√±al ascendente, el valor de contaje se decrementa hasta
alcanzar el valor l√≠mite inferior del tipo de datos indicado. Cuando se alcanza el valor l√≠mite
inferior, el estado l√≥gico del par√°metro CD deja de tener efecto en la instrucci√≥n.
El estado del contador se puede consultar en el par√°metro Q. Si el valor de contaje actual es
menor o igual a cero, el par√°metro Q adopta el estado l√≥gico "1". En los restantes casos, el
estado l√≥gico del par√°metro Q es "0". En el par√°metro PV tambi√©n se puede indicar una
constante.
El valor del par√°metro CV se pone al valor del par√°metro PV cuando el estado l√≥gico del
par√°metro LD cambia a "1". Mientras el par√°metro LD tenga el estado l√≥gico "1", el estado
l√≥gico del par√°metro CD no tendr√° efecto alguno en la instrucci√≥n.
Nota
Utilice el contador en una sola posici√≥n del programa para evitar fallos de contaje.
A cada llamada de la instrucci√≥n "Contador descendente" debe asign√°rsele un contador CEI,
en el que se guarden los datos de la instrucci√≥n. Un contador CEI es una estructura con uno
de los tipos de datos siguientes:

Para las CPU de la serie S7-1200
Bloque de datos del tipo de datos de sistema
IEC_<Contador> (Shared DB)

Variable local

‚óè IEC_SCOUNTER / IEC_USCOUNTER

‚óè CTD_SINT / CTD_USINT

‚óè IEC_COUNTER / IEC_UCOUNTER

‚óè CTD_INT / CTD_UINT

‚óè IEC_DCOUNTER / IEC_UDCOUNTER

‚óè CTD_DINT / CTD_UDINT

Para las CPU de la serie S7-1500
Bloque de datos del tipo de datos de sistema
IEC_<Contador> (Shared DB)

Variable local

‚óè IEC_SCOUNTER / IEC_USCOUNTER

‚óè CTD_SINT / CTD_USINT

‚óè IEC_COUNTER / IEC_UCOUNTER

‚óè CTD_INT / CTD_UINT

‚óè IEC_DCOUNTER / IEC_UDCOUNTER

‚óè CTD_DINT / CTD_UDINT

‚óè IEC_LCOUNTER / IEC_ULCOUNTER

‚óè CTD_LINT / CTD_ULINT

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1811

Instrucciones
4.1 Instrucciones
Un contador CEI se puede declarar del modo siguiente:
‚óè Declaraci√≥n de un bloque de datos de instancia del tipo de datos de sistema
IEC_<nombre_del_contador> (p. ej. "MyIEC_COUNTER_DB")
‚óè Declaraci√≥n como variable local del tipo de datos CTD_<tipo de datos> en la secci√≥n
"Static" de un bloque de programa (p. ej., #MyIEC_COUNTER_Instance)
Si el contador CEI se crea en un bloque de datos propio (instancia individual), el bloque de
datos de instancia se crea de forma est√°ndar con "acceso optimizado al bloque" y las distintas
variables se declaran remanentes.
Si el contador CEI se crea como variable local (multiinstancia) en un bloque de funci√≥n con
"acceso optimizado al bloque", esta se declara remanente en la interfaz del bloque.

Contador CEI como bloque de datos del tipo de datos de sistema IEC_<Nombre_del_contador> (Shared
DB)
Un contador CEI se puede declarar como bloque de datos del modo siguiente:
<IEC_Nombre_del_contador_DB>.CTD();

Contador CEI como variable local de la interfaz del bloque (multiinstancia)
El contador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Counter();
Encontrar√° informaci√≥n sint√°ctica sobre la llamada de contadores CEI en estructuras
(multiinstancia) aqu√≠: Llamada de contadores CEI (P√°gina 1803)

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:

1812

Par√°metro

Declaraci√≥n

CD

Input

LD
PV

Tipo de datos

√Årea de memoria

Descripci√≥n

BOOL

I, Q, M, D, L

Entrada de contaje

Input

BOOL

I, Q, M, D, L, P

Entrada de carga

Input

Enteros

I, Q, M, D, L, P

Valor al que se pone la salida
CV cuando LD = 1.

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"IEC_SCOUNTER_DB".CTD(CD := "Tag_Start",
LD := "Tag_Load",
PV := "Tag_PresetValue",
Q => "Tag_Status",
CV => "Tag_CounterValue");

Cuando el estado l√≥gico del operando "Tag_Start" cambia de "0" a "1", la instrucci√≥n se ejecuta
y el valor del operando "Tag_CounterValue" se decrementa en uno. Con cada flanco de se√±al
ascendente posterior, el valor de contaje ir√° decrementando hasta alcanzar el valor l√≠mite
inferior del tipo de datos indicado (-128).
El operando "Tag_Status" devuelve el estado l√≥gico "1" mientras el valor del contador actual
sea menor o igual a cero. En todos los dem√°s casos, la salida "Tag_Status" devuelve el estado
l√≥gico "0". El valor de contaje actual se guarda en el operando "Tag_CounterValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Ajustar la remanencia en un bloque de datos de instancia (P√°gina 7855)
Principios b√°sicos de SCL (P√°gina 8115)

CTUD: Contador ascendente - descendente
Descripci√≥n
La instrucci√≥n "Contador ascendente - descendente" incrementa y decrementa el valor de
contaje del par√°metro CV. Cuando el estado l√≥gico del par√°metro CU cambia de "0" a "1"
(flanco de se√±al ascendente), el valor de contaje actual del par√°metro CV se incrementa en
uno. Cuando el estado l√≥gico del par√°metro CD cambia de "0" a "1" (flanco de se√±al
ascendente), el valor de contaje del par√°metro CV se decrementa en uno. Si en un ciclo del
programa se detecta un flanco de se√±al ascendente en las entradas CU y CD, el valor de
contaje actual no cambia en el par√°metro CV.
El valor de contaje se puede seguir incrementando hasta alcanzar el valor l√≠mite superior del
tipo de datos indicado en el par√°metro CV. Una vez alcanzado el valor l√≠mite superior, el valor
de contaje no se incrementa m√°s aunque se detecte un flanco de se√±al ascendente. Cuando
se alcanza el valor l√≠mite inferior del tipo de datos indicado, ya no se decrementa el valor de
contaje.
Cuando el estado l√≥gico del par√°metro LD cambia a "1", el valor de contaje del par√°metro CV
se pone al valor del par√°metro PV. Mientras el par√°metro LD tenga el estado l√≥gico "1", el
estado l√≥gico de los par√°metros CU y CD no tendr√° efecto alguno en la instrucci√≥n.
El valor de contaje se pone a cero cuando el estado l√≥gico del par√°metro R cambia a "1".
Mientras el estado l√≥gico del par√°metro R sea "1", un cambio del estado l√≥gico de los
par√°metros CU, CD y LD no tendr√° efecto alguno en la instrucci√≥n "Contador ascendente descendente".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1813

Instrucciones
4.1 Instrucciones
El estado del contador ascendente se puede consultar en el par√°metro QU. Si el valor de
contaje actual es mayor o igual al valor del par√°metro PV, el par√°metro QU adopta el estado
l√≥gico "1". En los restantes casos, el estado l√≥gico del par√°metro QU es "0". En el par√°metro
PV tambi√©n se puede indicar una constante.
El estado del contador descendente se puede consultar en el par√°metro QD. Si el valor de
contaje actual es menor o igual a cero, el par√°metro QD adopta el estado l√≥gico "1". En los
restantes casos, el estado l√≥gico del par√°metro QD es "0".
Nota
Utilice el contador en una sola posici√≥n del programa para evitar fallos de contaje.
A cada llamada de la instrucci√≥n "Contador ascendente - descendente" debe asign√°rsele un
contador CEI en el que se guarden los datos de la instrucci√≥n. Un contador CEI es una
estructura con uno de los tipos de datos siguientes:

Para las CPU de la serie S7-1200
Bloque de datos del tipo de datos de sistema
IEC_<Contador> (Shared DB)

Variable local

‚óè IEC_SCOUNTER / IEC_USCOUNTER

‚óè CTUD_SINT / CTUD_USINT

‚óè IEC_COUNTER / IEC_UCOUNTER

‚óè CTUD_INT / CTUD_UINT

‚óè IEC_DCOUNTER / IEC_UDCOUNTER

‚óè CTUD_DINT / CTUD_UDINT

Para las CPU de la serie S7-1500
Bloque de datos del tipo de datos de sistema
IEC_<Contador> (Shared DB)

Variable local

‚óè IEC_SCOUNTER / IEC_USCOUNTER

‚óè CTUD_SINT / CTUD_USINT

‚óè IEC_COUNTER / IEC_UCOUNTER

‚óè CTUD_INT / CTUD_UINT

‚óè IEC_DCOUNTER / IEC_UDCOUNTER

‚óè CTUD_DINT / CTUD_UDINT

‚óè IEC_LCOUNTER / IEC_ULCOUNTER

‚óè CTUD_LINT / CTUD_ULINT

Un contador CEI se puede declarar del modo siguiente:
‚óè Declaraci√≥n de un bloque de datos de instancia del tipo de datos de sistema
IEC_<nombre_del_contador> (p. ej. "MyIEC_COUNTER_DB")
‚óè Declaraci√≥n como variable local del tipo de datos CTUD_<tipo de datos> en la secci√≥n
"Static" de un bloque de programa (p. ej., #MyCTUD_COUNTER_Instance)
Si el contador CEI se crea en un bloque de datos propio (instancia individual), el bloque de
datos de instancia se crea de forma est√°ndar con "acceso optimizado al bloque" y las distintas
variables se declaran remanentes.
Si el contador CEI se crea como variable local (multiinstancia) en un bloque de funci√≥n con
"acceso optimizado al bloque", esta se declara remanente en la interfaz del bloque.

1814

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Contador CEI como bloque de datos del tipo de datos de sistema IEC_<Nombre_del_contador> (Shared
DB)
Un contador CEI se puede declarar como bloque de datos del modo siguiente:
<IEC_Nombre_del_contador_DB>.CTUD();

Contador CEI como variable local de la interfaz del bloque (multiinstancia)
El contador CEI se puede declarar como variable local del modo siguiente:
#myLocal_Counter();
Encontrar√° informaci√≥n sint√°ctica sobre la llamada de contadores CEI en estructuras
(multiinstancia) aqu√≠: Llamada de contadores CEI (P√°gina 1803)

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

CU

Input

CD

Tipo de datos

√Årea de memoria

Descripci√≥n

BOOL

I, Q, M, D, L

Entrada de contaje ascen‚Äê
dente

Input

BOOL

I, Q, M, D, L

Entrada de contaje descen‚Äê
dente

R

Input

BOOL

I, Q, M, D, L, P

Entrada de reset

LD

Input

BOOL

I, Q, M, D, L, P

Entrada de carga

PV

Input

Enteros

I, Q, M, D, L, P

Valor con el que se activa la
salida QU. / Valor al que se
pone la salida CV cuando LD
= 1.

QU

Output

BOOL

I, Q, M, D, L

Estado del contador ascen‚Äê
dente

QD

Output

BOOL

I, Q, M, D, L

Estado del contador descen‚Äê
dente

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"IEC_COUNTER_DB".CTUD(CU := "Tag_Start1",
CD := "Tag_Start2",
LD := "Tag_Load",
R := "Tag_Reset",
PV := "Tag_PresetValue",
QU => "Tag_CU_Status",
QD => "Tag_CD_Status",
CV => "Tag_CounterValue");

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1815

Instrucciones
4.1 Instrucciones
Cuando se detecta un flanco de se√±al ascendente en el estado l√≥gico del operando
"Tag_Start1", el valor actual del contador se incrementa en uno y se deposita en el operando
"Tag_CounterValue". Cuando se detecta un flanco de se√±al ascendente en el estado l√≥gico del
operando "Tag_Start2", el valor del contador se decrementa en uno y se deposita tambi√©n en
el operando "Tag_CounterValue". Cuando se detecta un flanco de se√±al ascendente en el
par√°metro CU, el valor del contador se va incrementando hasta alcanzar el valor l√≠mite superior
del tipo de datos indicado (INT). Cuando se detecta un flanco de se√±al ascendente en el
par√°metro CD, el valor del contador se va decrementando hasta alcanzar el valor l√≠mite inferior
del tipo de datos indicado (INT).
El operando "Tag_CU_Status" devuelve el estado l√≥gico "1" mientras el valor de contaje actual
sea mayor o igual al valor del operando "Tag_PresetValue". En todos los dem√°s casos, la
salida "Tag_CU_Status" devuelve el estado l√≥gico "0".
El operando "Tag_CD_Status" devuelve el estado l√≥gico "1" mientras el valor del contador
actual sea menor o igual a cero. En todos los dem√°s casos, la salida "Tag_CD_Status"
devuelve el estado l√≥gico "0".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Ajustar la remanencia en un bloque de datos de instancia (P√°gina 7855)
Principios b√°sicos de SCL (P√°gina 8115)

Legacy
S_CU: Parametrizar e incrementar contador
Descripci√≥n
La instrucci√≥n "Parametrizar e incrementar contador" permite incrementar el valor de un
contador. Si el estado l√≥gico del par√°metro CU cambia de "0" a "1" (flanco de se√±al
ascendente), el valor de contaje actual se incrementa en uno. El valor de contaje actual se
deposita en el par√°metro CV. El valor de contaje sigue incrementando hasta alcanzar el l√≠mite
de "999". Una vez alcanzado el valor l√≠mite, el valor de contaje no se incrementa m√°s aunque
se detecte un flanco de se√±al ascendente.
Cuando el estado l√≥gico del par√°metro S cambia de "0" a "1", el valor de contaje adopta el valor
del par√°metro PV. Si el contador se activa y el resultado l√≥gico (RLO) de la entrada CU es "1",
el contador cuenta una √∫nica vez en el ciclo siguiente aunque no se detecte ning√∫n cambio de
flanco.
El valor de contaje se pone a cero cuando el estado l√≥gico del par√°metro R cambia a "1".
Mientras el estado l√≥gico del par√°metro R sea "1", un cambio en el estado l√≥gico de los
par√°metros CU y S no tiene ning√∫n efecto sobre el valor de contaje.

1816

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El estado l√≥gico del par√°metro Q es "1" si el valor de contaje es mayor que cero. Si el valor de
contaje es igual a cero, el par√°metro Q devuelve el estado l√≥gico "0".
Nota
Utilice el contador en una sola posici√≥n del programa para evitar fallos de contaje.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

C_NO

Input

COUNTER, INT

C

Contador
El n√∫mero de contadores de‚Äê
pende de la CPU.

CU

Input

BOOL

I, Q, M, D, L

Entrada de contaje ascen‚Äê
dente

S

Input

BOOL

I, Q, M, D, L

Entrada para preajustar el
contador

PV

Input

WORD

I, Q, M, D, L

Valor de contaje predetermi‚Äê
nado (C#0 a C#999) en for‚Äê
mato BCD

R

Input

BOOL

I, Q, M, D, L

Entrada de reset

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

WORD

I, Q, M, D, L

Valor de contaje actual

WORD

I, Q, M, D, L

Valor de contaje actual en
formato BCD

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := S_CU(C_NO := "Counter_1",
CU := "Tag_Start",
S := "Tag_1",
PV := "Tag_PresetValue",
R := "Tag_Reset",
Q => "Tag_Status",
CV => "Tag_Value");

Cuando el estado l√≥gico del par√°metro "Tag_Start" cambia de "0" a "1" (flanco de se√±al
ascendente) y el valor de contaje actual es menor que "999", este valor se incrementar√° en
uno. Si el estado l√≥gico de la entrada "Tag_1" cambia de "0" a "1", el valor de contaje en formato
BCD se pone al valor del operando "Tag_PresetValue". El valor de contaje se pone a "0" si el
operando "Tag_Reset" tiene el estado l√≥gico "1".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1817

Instrucciones
4.1 Instrucciones
El valor de contaje actual se almacena en formato hexadecimal en el operando "Tag_Value".
La salida "Tag_Status" devuelve el estado l√≥gico "1" mientras el valor de contaje actual sea
diferente a "0". El valor actual de contaje se guarda en el operando "Tag_Value" y se devuelve
como valor de funci√≥n.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

S_CD: Parametrizar y decrementar contador
Descripci√≥n
La instrucci√≥n "Parametrizar y decrementar contador" permite decrementar el valor de un
contador. Si el estado l√≥gico del par√°metro CD cambia de "0" a "1" (flanco de se√±al
ascendente), el valor de contaje se decrementa en uno. El valor de contaje actual se deposita
en el par√°metro CV. El valor de contaje sigue decrementando hasta alcanzar el l√≠mite inferior
"0". Una vez alcanzado el valor l√≠mite, el valor de contaje no se decrementa m√°s al detectarse
un flanco de se√±al ascendente.
Cuando el estado l√≥gico del par√°metro S cambia de "0" a "1", el valor de contaje adopta el valor
del par√°metro PV. Si el contador se activa y el resultado l√≥gico (RLO) del par√°metro CD es "1",
el contador cuenta una √∫nica vez en el ciclo siguiente aunque no se detecte ning√∫n cambio de
flanco.
El valor de contaje se pone a cero cuando el estado l√≥gico del par√°metro R cambia a "1".
Mientras el estado l√≥gico del par√°metro R sea "1", un cambio en el estado l√≥gico de los
par√°metros CD y S no tiene ning√∫n efecto sobre el valor de contaje.
El estado l√≥gico del par√°metro Q es "1" si el valor de contaje es mayor que cero. Si el valor de
contaje es igual a cero, el par√°metro Q devuelve el estado l√≥gico "0".
Nota
Utilice el contador en una sola posici√≥n del programa para evitar fallos de contaje.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

C_NO

Input

COUNTER, INT

C

Contador
El n√∫mero de contadores de‚Äê
pende de la CPU.

1818

CD

Input

BOOL

I, Q, M, D, L

Entrada de contaje descen‚Äê
dente

S

Input

BOOL

I, Q, M, D, L

Entrada para preajustar el
contador

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

PV

Input

WORD

I, Q, M, D, L

Valor de contaje predetermi‚Äê
nado (C#0 a C#999) en for‚Äê
mato BCD

R

Input

BOOL

I, Q, M, D, L

Entrada de reset

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

WORD

I, Q, M, D, L

Valor de contaje actual

WORD

I, Q, M, D, L

Valor de contaje actual en
formato BCD

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := S_CD(C_NO := "Counter_1",
CD := "Tag_Start",
S := "Tag_1",
PV := "Tag_PresetValue",
R := "Tag_Reset",
Q => "Tag_Status",
CV => "Tag_Value");

Cuando el estado l√≥gico del operando "Tag_Start" cambia de "0" a "1" (flanco de se√±al
ascendente) y el valor de contaje actual es superior a "0", el valor de contaje se decrementa en
uno. Cuando el estado l√≥gico del operando "Tag_1" cambia de "0" a "1", el valor de contaje
adopta el valor del operando "Tag_PresetValue" en formato BCD. El valor de contaje se pone
a "0" si el operando "Tag_Reset" tiene el estado l√≥gico "1".
El valor de contaje actual se almacena en el operando "Tag_Value".
El operando "Tag_Status" devuelve el estado l√≥gico "1" mientras el valor de contaje actual sea
distinto de "0". El valor actual de contaje se guarda en el operando "Tag_Value" y se devuelve
como valor de funci√≥n.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1819

Instrucciones
4.1 Instrucciones

S_CUD: Parametrizar e incrementar/decrementar contador
Descripci√≥n
La instrucci√≥n "Parametrizar e incrementar/decrementar contador" permite incrementar y
decrementar el valor de un contador. Si el estado l√≥gico del par√°metro CU cambia de "0" a "1"
(flanco de se√±al ascendente), el valor de contaje actual se incrementa en uno. Si el estado
l√≥gico del par√°metro CD cambia de "0" a "1" (flanco de se√±al ascendente), el valor de contaje
se decrementa en uno. El valor de contaje actual se deposita en el par√°metro CV. Si en un ciclo
del programa se detecta un flanco de se√±al ascendente en los par√°metros CU y CD el valor de
contaje permanece invariable.
El valor de contaje sigue incrementando hasta alcanzar el l√≠mite superior "999". Una vez
alcanzado el valor l√≠mite superior, el valor de contaje no se incrementa m√°s aunque se detecte
un flanco de se√±al ascendente. Cuando se alcanza el valor l√≠mite inferior "0", no se decrementa
m√°s el valor de contaje.
Cuando el estado l√≥gico del par√°metro S cambia de "0" a "1", el valor de contaje adopta el valor
del par√°metro PV. Si el contador se activa y el resultado l√≥gico (RLO) de los par√°metros CU y
CD es "1", el contador cuenta una √∫nica vez en el ciclo siguiente aunque no se detecte ning√∫n
cambio de flanco.
El valor de contaje se pone a cero cuando el estado l√≥gico del par√°metro R cambia a "1".
Mientras el par√°metro R tenga el estado l√≥gico "1", el estado l√≥gico de los par√°metros CU, CD
y S no tiene ning√∫n efecto sobre el valor de contaje.
El estado l√≥gico del par√°metro Q es "1" si el valor de contaje es mayor que cero. Si el valor de
contaje es igual a cero, el par√°metro Q devuelve el estado l√≥gico "0".
Nota
Utilice el contador en una sola posici√≥n del programa para evitar fallos de contaje.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

C_NO

Input

COUNTER, INT

C

Contador
El n√∫mero de contadores de‚Äê
pende de la CPU.

1820

CU

Input

BOOL

I, Q, M, D, L

Entrada de contaje ascen‚Äê
dente

CD

Input

BOOL

I, Q, M, D, L

Entrada de contaje descen‚Äê
dente

S

Input

BOOL

I, Q, M, D, L

Entrada para preajustar el
contador

PV

Input

WORD

I, Q, M, D, L

Valor de contaje predetermi‚Äê
nado (C#0 a C#999) en for‚Äê
mato BCD

R

Input

BOOL

I, Q, M, D, L

Entrada de reset

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

WORD

I, Q, M, D, L

Valor de contaje actual (he‚Äê
xadecimal)

WORD

I, Q, M, D, L

Valor de contaje actual en
formato BCD

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := S_CD(C_NO := "Counter_1",
CU := "Tag_CU",
CD := "Tag_CD",
S := "Tag_1",
PV := "Tag_PresetValue",
R := "Tag_Reset",
Q => "Tag_Status",
CV => "Tag_Value");

Cuando se detecta un flanco de se√±al ascendente en el estado l√≥gico del operando "Tag_CU"
y el valor de contaje actual es menor que "999", el valor de contaje se incrementa en uno.
Cuando se detecta un flanco de se√±al ascendente en el estado l√≥gico del operando "Tag_CD"
y el valor de contaje actual es mayor que "0", el valor de contaje se decrementa en uno.
Cuando el estado l√≥gico del operando "Tag_1" cambia de "0" a "1", el valor de contaje adopta
el valor del operando "Tag_PresetValue" en formato BCD. El valor de contaje se pone a "0" si
el operando "Tag_Reset" tiene el estado l√≥gico "1".
El valor de contaje actual se almacena en el operando "Tag_Value".
El operando "Tag_Status" devuelve el estado l√≥gico "1" mientras el valor de contaje actual sea
distinto de "0". El valor actual de contaje se guarda en el operando "Tag_Value" y se devuelve
como valor de funci√≥n.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1821

Instrucciones
4.1 Instrucciones

Comparaci√≥n
TypeOf: Consultar tipo de datos de una variable VARIANT
Descripci√≥n
Con la instrucci√≥n "Consultar tipo de datos de una variable VARIANT" se consulta qu√© tipo de
datos tiene una variable a la que apunta un VARIANT. El tipo de datos de la variable declarada
en la interfaz del bloque se puede comparar con el tipo de datos de otra variable o directamente
con un tipo de datos para determinar si es "Igual" o "Diferente".
El operando de comparaci√≥n puede ser un tipo de datos elemental o un tipo de datos PLC.
La instrucci√≥n "Consultar tipo de datos de una variable VARIANT" solo se puede utilizar dentro
de una instrucci√≥n IF o CASE.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros binarios,
enteros, n√∫meros
en coma flotante,
temporizadores,
fecha y hora, cade‚Äê
nas de caracteres,
VARIANT

L (puede declarar‚Äê Operando que debe consul‚Äê
se en las seccio‚Äê
tarse
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra la comparaci√≥n con otra variable:
SCL
IF TypeOf(#TagVARIANT) = TypeOf("TagBYTE") THEN
...;
END_IF;

El siguiente ejemplo muestra la comparaci√≥n con un tipo de datos:
SCL
IF TypeOf(#TagVARIANT) = BYTE THEN
...;
END_IF;

Si el operando al que apunta el VARIANT #TagVARIANT es del tipo de datos BYTE, entonces
se cumple la condici√≥n de comparaci√≥n.

1822

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Ejemplo de programaci√≥n de una cola de espera (FIFO) (P√°gina 348)
Principios b√°sicos de VARIANT (P√°gina 335)
Principios b√°sicos de SCL (P√°gina 8115)

TypeOfElements: Consultar tipo de datos de un elemento de ARRAY de una variable VARIANT
Descripci√≥n
Con la instrucci√≥n "Consultar tipo de datos de un elemento de ARRAY de una variable
VARIANT" se consulta qu√© tipo de datos tiene una variable a la que apunta un VARIANT. El
tipo de datos de la variable declarada en la interfaz del bloque se compara con el tipo de datos
de una variable para determinar si es "Igual" o "Diferente".
El operando debe ser del tipo de datos VARIANT. El operando de comparaci√≥n puede ser un
tipo de datos elemental o un tipo de datos PLC.
Si el tipo de datos de la variable VARIANT es un ARRAY, se compara el tipo de datos de los
elementos del ARRAY.
La instrucci√≥n "Consultar tipo de datos de un elemento de ARRAY de una variable VARIANT"
solo se puede utilizar dentro de una instrucci√≥n IF o CASE.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

VARIANT

L (puede declarar‚Äê Operando que debe consul‚Äê
se en las seccio‚Äê
tarse
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
IF TypeOfElements("Tag_Variant") = TypeOF("GlobalDB".Product[1]) THEN
"Tag_Variant" := "GlobalDB".Product[1] * 3;
END_IF;

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1823

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

"GlobalDB".Product[1]

1.5

Tag_Variant

4.5

Si la variable a la que se√±ala VARIANT y el operando "GlobalDB".Product[1] son del tipo de
datos REAL, el operando "GlobalDB".Product[1] se multiplica por 3 y el resultado se escribe en
el operando "Tag_Variant".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Ejemplo de programaci√≥n de una cola de espera (FIFO) (P√°gina 348)
Principios b√°sicos de VARIANT (P√°gina 335)
Principios b√°sicos de SCL (P√°gina 8115)

IS_ARRAY: Consultar si es un ARRAY
Descripci√≥n
La instrucci√≥n "Consultar si es un ARRAY" permite saber si VARIANT apunta a una variable
del tipo de datos ARRAY.
La instrucci√≥n "Consultar si es un ARRAY" solo se puede utilizar dentro de una instrucci√≥n IF.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Consultar si es un ARRAY":
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

<Operando>

Input

VARIANT

L (puede declarar‚Äê Operando que se consulta si
se en las seccio‚Äê
es un ARRAY
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

UDINT

I, Q, M, D, L

Valor de funci√≥n

1824

Descripci√≥n

Resultado de la instrucci√≥n

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".
Nota
Consulta de un bloque de datos ARRAY
Si utiliza la instrucci√≥n IS_ARRAY en relaci√≥n con un ArrayDB y genera el par√°metro de
entrada VARIANT con DB_ANY_TO_VARIANT , en un punto cualquiera del programa deber√°
utilizarse el ArrayDB en forma de s√≠mbolo como par√°metro actual de un par√°metro formal del
tipo de datos de datos VARIANT. Para que funcione correctamente es suficiente que se haya
descargado el lugar de uso. No es necesario que se ejecute.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
IF IS_ARRAY(#Tag_VARIANTToArray) THEN
"Tag_Result" := CountOfElements(#Tag_VARIANTToArray);
END_IF;

Si la variable a la que se√±ala VARIANT es ARRAY, se devuelve el n√∫mero de elementos
ARRAY.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Ejemplo de programaci√≥n de una cola de espera (FIFO) (P√°gina 348)
Principios b√°sicos de VARIANT (P√°gina 335)
Principios b√°sicos de SCL (P√°gina 8115)

TypeOfDB: Consultar el tipo de datos de un DB
Descripci√≥n
La instrucci√≥n "Consultar el tipo de datos de un DB" sirve para consultar el tipo de datos que
tiene el bloque de datos direccionado por la variable del tipo de datos DB_ANY. El tipo de datos
del DB direccionado con la variable <Operando> se puede comparar con el tipo de datos de
otra variable o bien directamente con un tipo de datos para determinar si es "Igual" o
"Diferente".
La variable debe ser del tipo de datos DB_ANY. El operando de comparaci√≥n puede ser, p. ej.,
un tipo de datos PLC, un tipo de datos de sistema, un eje o un FB.
La instrucci√≥n "Consultar el tipo de datos de un DB" solo se puede utilizar dentro de una
instrucci√≥n IF o CASE.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1825

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

DB_ANY

L (puede declarar‚Äê Operando que de‚Äê
se en las seccio‚Äê
be consultarse
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
IF TypeOfDB(#InputDBAny) = TO_SpeedAxis THEN
"TagOut" := 1;
END_IF;

La salida "TagOut" se activa si el tipo de datos del DB direccionado por el operando
#InputDBAny es igual al tipo de datos TO_SpeedAxis.
La salida "TagOut" no se activa cuando se cumplen las condiciones siguientes:
‚óè El n√∫mero del bloque de datos es "0".
‚óè El bloque de datos no existe.
‚óè El bloque de datos es un DB de ARRAY.
‚óè El bloque de datos contiene una variable del tipo de datos UDT (tipo de datos PLC).

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Uso del tipo de datos DB_ANY (P√°gina 216)
Principios b√°sicos de SCL (P√°gina 8115)

Funciones matem√°ticas
ABS: Calcular valor absoluto
Descripci√≥n
La instrucci√≥n "Calcular valor absoluto" permite calcular el valor absoluto de un valor de
entrada y guardar el resultado en el operando indicado.

1826

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros
<Expresi√≥n>

Valor de funci√≥n

Declaraci√≥n
Input

Tipo de datos

√Årea de memo‚Äê Descripci√≥n
ria

S7-1200

S7-1500

SINT, INT,
DINT, n√∫meros
en coma flotan‚Äê
te

SINT, INT,
DINT, LINT,
n√∫meros en
coma flotan‚Äê
te

I, Q, M, D, L, P

Valor de entra‚Äê
da

SINT, INT,
DINT, n√∫meros
en coma flotan‚Äê
te

SINT, INT,
DINT, LINT,
n√∫meros en
coma flotan‚Äê
te

I, Q, M, D, L, P

Valor absoluto
del valor de en‚Äê
trada

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result1" := ABS("Tag_Value");
"Tag_Result2" := ABS("Tag_Value1"*"Tag_Value2");

El valor absoluto del valor de entrada se devuelve en el formato del valor de entrada como valor
de funci√≥n.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

-2

Tag_Result1

2

Tag_Value1

4

Tag_Value2

-1

Tag_Result2

4

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1827

Instrucciones
4.1 Instrucciones

MIN: Determinar m√≠nimo
Descripci√≥n
Con la instrucci√≥n "Determinar m√≠nimo" se comparan los valores de las entradas disponibles
y se devuelve el menor como resultado.
En la instrucci√≥n se pueden indicar como m√≠nimo dos y como m√°ximo 32 entradas.
El resultado no es v√°lido si se cumple una de las siguientes condiciones:
‚óè La conversi√≥n impl√≠cita de los tipos de datos falla durante la ejecuci√≥n de la instrucci√≥n.
‚óè Un n√∫mero en coma flotante tiene un valor no v√°lido.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Determinar m√≠nimo":
Par√°metro

1828

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memo‚Äê Descripci√≥n
ria

IN1

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante, TIME,
TOD, DATE,
DTL

Enteros, n√∫‚Äê I, Q, M, D, L, P
meros en co‚Äê
ma flotante,
TIME, LTI‚Äê
ME, TOD,
LTOD, DA‚Äê
TE, LDT,
DT, DTL

Primer valor de
entrada

IN2

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante, TIME,
TOD, DATE,
DTL

Enteros, n√∫‚Äê I, Q, M, D, L, P
meros en co‚Äê
ma flotante,
TIME, LTI‚Äê
ME, TOD,
LTOD, DA‚Äê
TE, LDT,
DT, DTL

Segundo valor
de entrada

INn

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante, TIME,
TOD, DATE,
DTL

Enteros, n√∫‚Äê I, Q, M, D, L, P
meros en co‚Äê
ma flotante,
TIME, LTI‚Äê
ME, TOD,
LTOD, DA‚Äê
TE, LDT,
DT, DTL

Entradas inser‚Äê
tadas adicional‚Äê
mente cuyos
valores se com‚Äê
paran

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro
Valor de funci√≥n

Declaraci√≥n

Tipo de datos

√Årea de memo‚Äê Descripci√≥n
ria

S7-1200

S7-1500

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante, TIME,
TOD, DATE,
DTL

Enteros, n√∫‚Äê I, Q, M, D, L, P
meros en co‚Äê
ma flotante,
TIME, LTI‚Äê
ME, TOD,
LTOD, DA‚Äê
TE, LDT,
DT, DTL

Resultado de la
instrucci√≥n

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar cuando la verificaci√≥n CEI est√°
desactivada.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := MIN(IN1 := "Tag_Value1",
IN2 := "Tag_Value2",
IN3 := "Tag_Value3");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN1

Tag_Value1

12222

IN2

Tag_Value2

14444

IN3

Tag_Value3

13333

Valor de funci√≥n

Tag_Result

12222

La instrucci√≥n compara los valores de las entradas disponibles y copia el valor menor
(Tag_Value1) en el operando "Tag_Result".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

MAX: Determinar m√°ximo
Descripci√≥n
Con la instrucci√≥n "Determinar m√°ximo" se comparan los valores de las entradas disponibles
y se devuelve el mayor como resultado.
En la instrucci√≥n se pueden indicar como m√≠nimo dos y como m√°ximo 32 entradas.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1829

Instrucciones
4.1 Instrucciones
El resultado no es v√°lido si se cumple una de las siguientes condiciones:
‚óè La conversi√≥n impl√≠cita de los tipos de datos falla durante la ejecuci√≥n de la instrucci√≥n.
‚óè Un n√∫mero en coma flotante tiene un valor no v√°lido.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Determinar m√°ximo":
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memo‚Äê Descripci√≥n
ria

IN1

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante, TIME,
TOD, DATE,
DTL

Enteros, n√∫‚Äê I, Q, M, D, L, P
meros en co‚Äê
ma flotante,
TIME, LTI‚Äê
ME, TOD,
LTOD, DA‚Äê
TE, LDT,
DT, DTL

Primer valor de
entrada

IN2

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante, TIME,
TOD, DATE,
DTL

Enteros, n√∫‚Äê I, Q, M, D, L, P
meros en co‚Äê
ma flotante,
TIME, LTI‚Äê
ME, TOD,
LTOD, DA‚Äê
TE, LDT,
DT, DTL

Segundo valor
de entrada

INn

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante, TIME,
TOD, DATE,
DTL

Enteros, n√∫‚Äê I, Q, M, D, L, P
meros en co‚Äê
ma flotante,
TIME, LTI‚Äê
ME, TOD,
LTOD, DA‚Äê
TE, LDT,
DT, DTL

Entradas inser‚Äê
tadas adicional‚Äê
mente cuyos
valores se com‚Äê
paran

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante, TIME,
TOD, DATE,
DTL

Enteros, n√∫‚Äê I, Q, M, D, L, P
meros en co‚Äê
ma flotante,
TIME, LTI‚Äê
ME, TOD,
LTOD, DA‚Äê
TE, LDT,
DT, DTL

Resultado de la
instrucci√≥n

Valor de funci√≥n

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar cuando la verificaci√≥n CEI est√°
desactivada.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

1830

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := MAX(IN1 := "Tag_Value1",
IN2 := "Tag_Value2",
IN3 := "Tag_Value3");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN1

Tag_Value1

12 222

IN2

Tag_Value2

14 444

IN3

Tag_Value3

13 333

Valor de funci√≥n

Tag_Result

14 444

La instrucci√≥n compara los valores de los operandos indicados y copia el valor mayor
("Tag_Value2") en el operando "Tag_Result".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

LIMIT: Ajustar valor l√≠mite
Descripci√≥n
La instrucci√≥n "Ajustar valor l√≠mite" limita el valor del par√°metro IN a los valores de los
par√°metros MN y MX. Para ello, el valor del par√°metro MN no puede ser mayor que el valor del
par√°metro MX.
Si el valor del par√°metro IN cumple la condici√≥n MN <= IN <= MX, se devuelve como resultado
de la instrucci√≥n. Si no se cumple la condici√≥n y el valor de entrada IN rebasa por defecto el
l√≠mite inferior MN, se devuelve como resultado el valor del par√°metro MN. Si se rebasa por
exceso el l√≠mite superior MX se devuelve como resultado el valor del par√°metro MX.
Si el valor de la entrada MN es mayor que el de la entrada MX, el resultado ser√° el valor
indicado en el par√°metro IN y la salida de habilitaci√≥n ENO ser√° "0".
Para poder ejecutar la instrucci√≥n, es imprescindible que los operandos de todos los
par√°metros sean del mismo tipo de datos.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1831

Instrucciones
4.1 Instrucciones

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memo‚Äê Descripci√≥n
ria

MN

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante, TIME,
TOD, DATE,
DTL

Enteros, n√∫‚Äê I, Q, M, D, L, P
meros en co‚Äê
ma flotante,
TIME, LTI‚Äê
ME, TOD,
LTOD, DA‚Äê
TE, LDT,
DT, DTL

L√≠mite inferior

IN

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante, TIME,
TOD, DATE,
DTL

Enteros, n√∫‚Äê I, Q, M, D, L, P
meros en co‚Äê
ma flotante,
TIME, LTI‚Äê
ME, TOD,
LTOD, DA‚Äê
TE, LDT,
DT, DTL

Valor de entra‚Äê
da

MX

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante, TIME,
TOD, DATE,
DTL

Enteros, n√∫‚Äê I, Q, M, D, L, P
meros en co‚Äê
ma flotante,
TIME, LTI‚Äê
ME, TOD,
LTOD, DA‚Äê
TE, LDT,
DT, DTL

L√≠mite superior

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante, TIME,
TOD, DATE,
DTL

Enteros, n√∫‚Äê I, Q, M, D, L, P
meros en co‚Äê
ma flotante,
TIME, LTI‚Äê
ME, TOD,
LTOD, DA‚Äê
TE, LDT,
DT, DTL

Resultado de la
instrucci√≥n

Valor de funci√≥n

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar cuando la verificaci√≥n CEI est√°
desactivada.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := LIMIT(MN := "Tag_Minimum",
IN := "Tag_Value",
MX := "Tag_Maximum");

1832

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

MN

Tag_Minimum

12 000

IN

Tag_Value

8 000

MX

Tag_Maximum

16 000

Valor de funci√≥n

Tag_Result

12 000

El valor del operando "Tag_Value" se compara con los valores de los operandos
"Tag_Minimum" y "Tag_Maximum". Puesto que el valor del operando "Tag_Value" es menor
que el valor l√≠mite inferior, el valor del operando "Tag_Minimum" se copia en el operando
"Tag_Result".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

SQR: Calcular cuadrado
Descripci√≥n
La instrucci√≥n "Calcular cuadrado" permite elevar al cuadrado el valor de entrada y guardar el
resultado en el operando indicado.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P

Valor de entrada

N√∫meros en coma
flotante

I, Q, M, D, L, P

Cuadrado del valor de entra‚Äê
da

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result1" := SQR("Tag_Value");
"Tag_Result2" := SQR((SQR("Tag_Value1"))*"Tag_Value2");

El cuadrado del valor de entrada se devuelve en el operando "Tag_Resultxy" como valor de
funci√≥n.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1833

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

2.5

Tag_Result1

6.25

Tag_Value1

6.0

Tag_Value2

2.0

Tag_Result2

5184.0

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

SQRT: Calcular ra√≠z cuadrada
Descripci√≥n
La instrucci√≥n "Calcular ra√≠z cuadrada" permite extraer la ra√≠z cuadrada del valor de entrada y
guardar el resultado en el operando indicado. La instrucci√≥n da un resultado positivo si el valor
de entrada es mayor que cero. En los valores de entrada menores que cero, la instrucci√≥n
devuelve un n√∫mero en coma flotante no v√°lido. Si el valor de entrada es "0", el resultado
tambi√©n es "0".

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P

Valor de entrada

N√∫meros en coma
flotante

I, Q, M, D, L, P

Ra√≠z cuadrada del valor de
entrada

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result1" := SQRT("Tag_Value");
"Tag_Result2" := SQRT((SQR("Tag_Value1"))+"Tag_Value2");

La ra√≠z cuadrada del valor de entrada se devuelve en el operando "Tag_Resultxy" como valor
de funci√≥n.

1834

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

4.0

Tag_Result1

2.0

Tag_Value1

3.0

Tag_Value2

16.0

Tag_Result2

5.0

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

LN: Calcular logaritmo natural
Descripci√≥n
La instrucci√≥n "Calcular logaritmo natural" permite calcular el logaritmo natural en base e (e =
2,718282) a partir del valor de entrada. La instrucci√≥n da un resultado positivo si el valor de
entrada es mayor que cero. En los valores de entrada menores que cero, la instrucci√≥n
devuelve un n√∫mero en coma flotante no v√°lido.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P

Valor de entrada

N√∫meros en coma
flotante

I, Q, M, D, L, P

Logaritmo natural del valor
de entrada

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result1" := LN("Tag_Value");
"Tag_Result2" := LN("Tag_Value1"+"Tag_Value2");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Resultxy" como valor de
funci√≥n.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1835

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

2.5

Tag_Result1

0.916

Tag_Value1

1.5

Tag_Value2

3.2

Tag_Result2

1.548

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

EXP: Calcular valor exponencial
Descripci√≥n
La instrucci√≥n "Calcular valor exponencial" permite calcular la potencia en base e (e =
2,718282) a partir del valor de entrada y guardar el resultado en el operando indicado.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P

Valor de entrada

N√∫meros en coma
flotante

I, Q, M, D, L, P

Valor exponencial del valor
de entrada

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result1" := EXP("Tag_Value");
"Tag_Result2" := EXP("Tag_Value1"/"Tag_Value2");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Resultxy" como valor de
funci√≥n.

1836

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

20.5

Tag_Result1

799 902 200

Tag_Value1

15.5

Tag_Value2

30.2

Tag_Result2

1.671

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

SIN: Calcular valor de seno
Descripci√≥n
La instrucci√≥n "Calcular valor de seno" permite calcular el seno del valor de entrada. El valor
de entrada se ha de indicar en radianes.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P

Valor de entrada (tama√±o de
un √°ngulo en radianes)

N√∫meros en coma
flotante

I, Q, M, D, L, P

Resultado de la instrucci√≥n

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := SIN("Tag_Value");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1837

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

+1.570796 (œÄ/2)

Tag_Result

1.0

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

COS: Calcular valor de coseno
Descripci√≥n
La instrucci√≥n "Calcular valor de coseno" permite calcular el coseno del valor de entrada. El
valor de entrada se ha de indicar en radianes.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P

Valor de entrada (tama√±o de
un √°ngulo en radianes)

N√∫meros en coma
flotante

I, Q, M, D, L, P

Resultado de la instrucci√≥n

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := COS("Tag_Value");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:

1838

Operando

Valor

Tag_Value

+1.570796 (œÄ/2)

Tag_Result

0

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

TAN: Calcular valor de tangente
Descripci√≥n
La instrucci√≥n "Calcular valor de tangente" permite calcular la tangente del valor de entrada. El
valor de entrada se ha de indicar en radianes.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P

Valor de entrada (tama√±o de
un √°ngulo en radianes)

N√∫meros en coma
flotante

I, Q, M, D, L, P

Resultado de la instrucci√≥n

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := TAN("Tag_Value");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

+3.141593 (œÄ)

Tag_Result

0

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1839

Instrucciones
4.1 Instrucciones

ASIN: Calcular valor de arcoseno
Descripci√≥n
La instrucci√≥n "Calcular valor de arcoseno" permite calcular a partir del valor de seno el tama√±o
del √°ngulo que equivale a este valor. Como valores de entrada solo se pueden indicar n√∫meros
en coma flotante v√°lidos, comprendidos en un rango de valores entre -1 y +1. El tama√±o del
√°ngulo calculado se devuelve en radianes y puede estar comprendido entre -œÄ/2 y +œÄ/2.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P

Valor de seno

N√∫meros en coma
flotante

I, Q, M, D, L, P

Tama√±o del √°ngulo en radia‚Äê
nes

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := ASIN("Tag_Value");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

1.0

Tag_Result

+1.570796 (œÄ/2)

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

1840

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

ACOS: Calcular valor de arcocoseno
Descripci√≥n
La instrucci√≥n "Calcular valor de arcocoseno" permite calcular a partir del valor de coseno el
tama√±o del √°ngulo que equivale a este valor. Como valores de entrada solo se pueden indicar
n√∫meros en coma flotante v√°lidos, comprendidos en un rango de valores entre -1 y +1. El
tama√±o del √°ngulo calculado se devuelve en radianes y puede estar comprendido entre 0 y +œÄ.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P

Valor de coseno

N√∫meros en coma
flotante

I, Q, M, D, L, P

Tama√±o del √°ngulo en radia‚Äê
nes

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := ACOS("Tag_Value");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

0

Tag_Result

+1.570796 (œÄ/2)

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1841

Instrucciones
4.1 Instrucciones

ATAN: Calcular valor de arcotangente
Descripci√≥n
La instrucci√≥n "Calcular valor de arcotangente" permite calcular a partir del valor de tangente
el tama√±o del √°ngulo que equivale a este valor. Solo se pueden indicar valores de entrada que
sean n√∫meros en coma flotante v√°lidos (o -NaN/+NaN). El tama√±o del √°ngulo calculado se
devuelve en radianes y puede estar comprendido entre -œÄ/2 y +œÄ/2.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P

Valor de tangente

N√∫meros en coma
flotante

I, Q, M, D, L, P

Tama√±o del √°ngulo en radia‚Äê
nes

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := ATAN("Tag_Value");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

1.0

Tag_Result

+0,785398 (œÄ/4)

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
N√∫meros en coma flotante no v√°lidos (P√°gina 263)
Principios b√°sicos de SCL (P√°gina 8115)

1842

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

FRAC: Determinar decimales
Descripci√≥n
La instrucci√≥n "Determinar decimales" devuelve como resultado los decimales de un valor. As√≠,
por ejemplo, el valor de entrada 123.4567 proporciona como resultado el valor 0.4567.
Para modificar el tipo de datos de la instrucci√≥n, utilice la sintaxis siguiente:
FRAC_<tipo de datos>();

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memo‚Äê Descripci√≥n
ria

<Expresi√≥n>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P

Valor de entrada

N√∫meros en coma
flotante

-

Tipo de datos del valor de
funci√≥n:

_<tipo de datos>

Ajuste predetermi‚Äê
nado: REAL

1. El tipo de datos de la
instrucci√≥n se puede
indicar expl√≠citamente
con "_".
2. Si el tipo de datos no se
indica expl√≠citamente, se
determinar√° a partir de
las variables utilizadas o
de las constantes con
tipos.
3. Si el tipo de datos no se
indica expl√≠citamente ni
se indican variables
definidas ni constantes
con tipo, se utilizar√° el
tipo de datos
predeterminado.

Valor de funci√≥n

N√∫meros en coma
flotante

I, Q, M, D, L, P

Decimales del valor de entra‚Äê
da

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result1" := FRAC("Tag_Value");
"Tag_Result2" := FRAC_LREAL("Tag_Value");

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1843

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

2.555

-14 421

Tag_Result1

0.555

-0.4421

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
N√∫meros en coma flotante no v√°lidos (P√°gina 263)
Principios b√°sicos de SCL (P√°gina 8115)

Transferencia
Deserialize: Deserializar
Descripci√≥n
La instrucci√≥n "Deserializar" reconvierte la forma de representaci√≥n secuencial de un tipo de
datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> y rellena todo su contenido.
El √°rea de memoria en la que se encuentra la forma de representaci√≥n secuencial de un tipo
de datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> debe ser del tipo de datos ARRAY
of BYTE o ARRAY of CHAR y tener declarado el acceso est√°ndar en la versi√≥n 1.0. A partir de
la versi√≥n 2.0 se permiten tambi√©n √°reas de memoria optimizadas. La capacidad del √°rea de
memoria est√°ndar es de 64 KB. Antes de la conversi√≥n aseg√∫rese de que hay suficiente
memoria disponible. Si el √°rea de memoria se ha rellenado utilizando la instrucci√≥n "Serializar"
y se han insertado bytes de relleno, estos no se tendr√°n en cuenta en la conversi√≥n.
Se recomienda definir a "0" el l√≠mite inferior del ARRAY, ya que entonces el √≠ndice dentro del
ARRAY se corresponde con el valor del par√°metro POS, p. ej. ARRAY[0] = POS 0. La
descripci√≥n y el ejemplo que sigue m√°s abajo se basan en estos fundamentos.
Esta instrucci√≥n reconvierte paso a paso a su estado original varias formas de representaci√≥n
secuenciales de datos convertidos.
Para reconvertir una sola forma de representaci√≥n secuencial de un tipo de datos PLC (UDT),
STRUCT o ARRAY of <tipo de datos> tambi√©n se puede utilizar directamente la instrucci√≥n
"TRCV: Recibir datos a trav√©s de la conexi√≥n".

Tama√±o del √°rea de memoria
Debido a las reglas de alineaci√≥n, no se insertan bytes de relleno en las estructuras sencillas
del √°rea de memoria optimizada. Por consiguiente, una estructura del √°rea de memoria
optimizada es m√°s peque√±a que en el √°rea de memoria est√°ndar. Los ARRAY de estructuras
y las estructuras anidadas tienen bytes de relleno. Por lo general no es posible saber de
antemano en qu√© √°rea de memoria requiere m√°s espacio una estructura compuesta.
V√°lido para las CPU de la serie S7-1500:

1844

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En un bloque con la propiedad "Acceso optimizado al bloque", el BOOL tiene una longitud de
1 byte. Esto hace que una estructura, que b√°sicamente est√° formada por el tipo de datos
BOOL, sea mayor en el √°rea de memoria optimizada que en el √°rea de memoria est√°ndar. Las
estructuras compuestas con un porcentaje reducido de tipos de datos BOOL son menores en
el √°rea de memoria optimizada que en el √°rea de memoria est√°ndar.
Nota
Serializaci√≥n de varias estructuras en una CPU-S7-1200
Si desea serializar varias estructuras en un b√∫fer de una CPU-S7-1200 y establecer
comunicaci√≥n con ellas (p. ej., con un sistema de control o una CPU-S7-1500), deber√°
comprobar si el valor de retorno (√≠ndice del par√°metro POS) es par. Si este no es el caso,
deber√° incrementar el valor de retorno en 1 antes de serializar la segunda estructura, ya que
la primera estructura no se rellena con un byte de relleno.
Ejemplo:
Estructura compuesta por 1 DWORD y 1 BYTE
La direcci√≥n inicial para la siguiente estructura serializada en el b√∫fer es 5. A√±ada +1 para que
la direcci√≥n inicial sea un n√∫mero par.

√Årea de memoria optimizada
Para deserializar estructuras de mayor tama√±o, el √°rea de memoria para la representaci√≥n
secuencial puede declararse tambi√©n con acceso optimizado a partir de la versi√≥n de firmware
>= 4.2 de las CPU de la serie S7-1200 y a partir de la versi√≥n de firmware >= 2.0 de las CPU
de la serie S7-1500. El contenido de la representaci√≥n secuencial no cambia, igual que en un
√°rea de memoria est√°ndar. El acceso a los bytes del ARRAY solo es posible simb√≥licamente.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1845

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

SRC_ARRA
Y

Input

ARRAY[*] of
BYTE 1)

I, Q, D, interfaz de
bloque de un FB
(son posibles las
secciones Input,
Output, Static y
Temp).

ARRAY of BYTE o ARRAY of
CHAR, en el que se guarda el
flujo de datos que debe dese‚Äê
rializarse.

o bien
ARRAY of CHAR

S7-1500:

Para obtener el m√°ximo ren‚Äê
ning√∫n dato de pe‚Äê dimiento, no transfiera valo‚Äê
riferia
res a este par√°metro con un
puntero VARIANT.

DEST_VA‚Äê
RIABLE

InOut

Todos los tipos de
datos

I, Q, D, interfaz de
bloque de un FB

Variable, en la que se escri‚Äê
bir√°n los datos deserializa‚Äê
ning√∫n dato de pe‚Äê dos.
riferia
S7-1500:
Para obtener el m√°ximo ren‚Äê
dimiento, no transfiera valo‚Äê
res a este par√°metro con un
puntero VARIANT.

POS

InOut

Valor de funci√≥n

DINT

I, Q, M, D, L

El operando del par√°metro
POS almacena el √≠ndice del
primer byte tras el n√∫mero de
bytes que ocupan los datos
de cliente convertidos. El pa‚Äê
r√°metro POS se calcula ba‚Äê
sado en cero.

INT

I, Q, M, D, L

Informaci√≥n de error

Posible con CPU de la serie S7-1200 a partir de la versi√≥n de firmware >= 4.2 y con CPU de la serie
S7-1500 a partir de la versi√≥n de firmware >= 2.0
1)

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:

1846

C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

80B0

Las √°reas de memoria de los par√°metros SRC_ARRAY y DEST_VARIABLE se solapan.

8136

La variable del par√°metro SRC_ARRAY no est√° en un bloque con acceso est√°ndar.

8150

El tipo de datos VARIANT del par√°metro SRC_ARRAY contiene un puntero IGUAL A
CERO.

8151

El par√°metro SRC_ARRAY no tiene una referencia v√°lida.

8153

En el par√°metro SRC_ARRAY no hay suficiente espacio de memoria disponible.

8154

Tipo de datos no v√°lido en el par√°metro SRC_ARRAY

8250

En el par√°metro DEST_ARRAY se ha transferido un puntero CERO.

8251

El par√°metro DEST_VARIABLE no tiene una referencia v√°lida.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

8382

El valor del par√°metro POS se encuentra fuera de los valores l√≠mite del array.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Particularidades a partir de la versi√≥n de firmware 4.2 (S7-1200) y 2.0 (S7-1500):
El c√≥digo de error siguiente tiene un significado distinto:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

8136

El acceso al √°rea de memoria en el par√°metro SRC_ARRAY no es v√°lido.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Particularidades a partir de la versi√≥n de firmware 2.8 (S7-1500):
El rendimiento de la instrucci√≥n "Deserializar" (versi√≥n 2.1) mejora si no se transfieren valores
a los par√°metros SRC_ARRAY y DEST_VARIABLE con un puntero VARIANT, sino con un tipo
de datos concreto.
Tenga en cuenta que el comportamiento err√≥neo de la instrucci√≥n cambia en este caso. En
determinados escenarios de error, la CPU no devuelve c√≥digos de error, sino que pasa a
STOP con un error de acceso. Para evitar que esto ocurra, utilice el tratamiento de errores local
con las instrucciones "GET_ERROR" y "GET_ERR_ID".

Ejemplo
La tabla siguiente muestra la declaraci√≥n de los operandos:
Operando

Tipo de datos

Declaraci√≥n

DeliverPos

INT

En la secci√≥n "Input" de la inter‚Äê
faz del bloque de un FB o una FC

BufferPos

DINT

Error

INT

En la secci√≥n "Temp" de la inter‚Äê
faz del bloque de un FB o una FC

Label

STRING[4]

La siguiente tabla muestra la declaraci√≥n de los tipos de datos PLC:
Nombre de los tipos de datos
PLC

Nombre

Tipo de datos

Article

Number

DINT

Declaration

STRING

Colli

INT

Title

INT

First name

STRING[10]

Surname

STRING[10]

Client

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1847

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra la declaraci√≥n de los bloques de datos:
Nombre de los bloques de datos Nombre

Tipo de datos

Target

Client

"Client" (tipo de datos PLC)

Article

Array[0..10] of "Article" (tipo de
datos PLC)

Bill

Array[0..10] of INT

Field

Array[0..294] of BYTE

Buffer

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
#Tag_RetVal := Deserialize(SRC_ARRAY := "Buffer".Field,
DEST_VARIABLE := "Target".Client,
POS := #BufferPos);
#Tag_RetVal := Deserialize(SRC_ARRAY := "Buffer".Field,
DEST_VARIABLE := #Label,
POS := #BufferPos);
IF #Label = 'arti' THEN
#Tag_RetVal := Deserialize(SRC_ARRAY := "Buffer".Field,
DEST_VARIABLE := "Target".Article[#DeliverPos],
POS := #BufferPos);
ELSIF #Label = 'Bill' THEN
#Tag_RetVal := Deserialize(SRC_ARRAY := "Buffer".Field,
DEST_VARIABLE := "Target".Bill[#DeliverPos],
POS := #BufferPos);
;
ELSE
;
END_IF;

La instrucci√≥n "Deserializar" deserializa la forma de representaci√≥n secuencial de los datos de
cliente de la variable "Buffer" y los escribe en la variable "Target". El operando #BufferPos
almacena el √≠ndice del primer byte tras el n√∫mero de bytes que ocupan los datos de cliente
convertidos.
La instrucci√≥n "Deserializar" deserializa la forma de representaci√≥n secuencial del separador
(depositado despu√©s de los datos de cliente en la forma de representaci√≥n secuencial) de la
variable "Buffer" y escribe los caracteres en el operando #Label. Los caracteres se comparan
en relaci√≥n con "arti" y "Bill" mediante instrucciones de comparaci√≥n. Si la comparaci√≥n en
relaci√≥n con "arti" = TRUE, se trata de datos de art√≠culo que se deserializan y se escriben en
la variable "Target". Si la comparaci√≥n en relaci√≥n con "Bill" = TRUE, se trata de datos de
c√°lculo que se deserializan y se escriben en la variable "Target".

1848

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de los tipos de datos PLC (UDT) (P√°gina 283)
Estructura de una variable ARRAY (P√°gina 298)
Estructura de una variable STRUCT (P√°gina 290)
Estructura de una variable STRING (P√°gina 277)
Bytes de relleno cuando se usan tipos de datos estructurados (P√°gina 143)
Principios b√°sicos de SCL (P√°gina 8115)

Serialize: Serializar
Descripci√≥n
Mediante la instrucci√≥n "Serializar" se convierten varios tipos de datos PLC (UDT), STRUCT
o ARRAY of <tipo de datos> a una forma de representaci√≥n secuencial sin que se pierdan
partes de su estructura.
La instrucci√≥n permite guardar temporalmente varios datos estructurados del programa en un
b√∫fer, ubicado preferentemente en un bloque de datos global, y enviarlos a otra CPU. El √°rea
de memoria en la que se depositen los datos convertidos debe ser del tipo de datos ARRAY of
BYTE o ARRAY of CHAR y tener declarado el acceso est√°ndar en la versi√≥n 1.0. A partir de
la versi√≥n 2.0 se permiten tambi√©n datos optimizados. Los datos de relleno del √°rea de datos
del origen no est√°n definidos en el ARRAY de destino. Pueden ser tanto bytes o bits de relleno
de un √°rea de datos (p. ej., ARRAY, STRUCT o tipo de datos PLC (UDT)) como los caracteres
de una cadena que no se utilicen en ese momento.
La capacidad del √°rea de memoria est√°ndar es de 64 KB. Las estructuras mayores que 64 KB
seg√∫n las reglas para √°reas de memoria est√°ndar no pueden serializarse si el operando del
par√°metro DEST_ARRAY est√° en un √°rea de memoria est√°ndar.
Se recomienda definir a "0" el l√≠mite inferior del ARRAY, ya que entonces el √≠ndice dentro del
ARRAY se corresponde con el valor del par√°metro POS, p. ej. ARRAY[0] = POS 0. La
descripci√≥n y el ejemplo que sigue m√°s abajo se basan en estos fundamentos.
El operando del par√°metro POS contiene la informaci√≥n sobre el n√∫mero de bytes que ocupan
los datos convertidos.
Para enviar un solo tipo de datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> se puede
llamar directamente la instrucci√≥n "TSEND: Enviar datos a trav√©s de la conexi√≥n".
Nota
Comparaci√≥n de estructuras
Para comparar estructuras no es necesario serializarlas antes. En su lugar, utilice una
expresi√≥n de comparaci√≥n.
Encontrar√° m√°s informaci√≥n aqu√≠: Expresiones de comparaci√≥n (P√°gina 8120)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1849

Instrucciones
4.1 Instrucciones

Tama√±o del √°rea de memoria
Debido a las reglas de alineaci√≥n, no se insertan bytes de relleno en las estructuras sencillas
del √°rea de memoria optimizada. Por consiguiente, una estructura del √°rea de memoria
optimizada es m√°s peque√±a que en el √°rea de memoria est√°ndar. Los ARRAY de estructuras
y las estructuras anidadas tienen bytes de relleno. Por lo general no es posible saber de
antemano en qu√© √°rea de memoria requiere m√°s espacio una estructura compuesta.
V√°lido para las CPU de la serie S7-1500:
En un bloque con la propiedad "Acceso optimizado al bloque", la longitud del BOOL depende
del tipo de datos que sigue. Por ejemplo, si lo que sigue es un BYTE, el BOOL tiene una
longitud de 1 byte. Si lo que sigue es WORD, el BOOL tiene una longitud de 2 bytes. Esto hace
que una estructura, que b√°sicamente est√° formada por el tipo de datos BOOL, sea mayor en
el √°rea de memoria optimizada que en el √°rea de memoria est√°ndar. Las estructuras
compuestas con un porcentaje reducido de tipos de datos BOOL son menores en el √°rea de
memoria optimizada que en el √°rea de memoria est√°ndar.
Por eso se recomienda que el √°rea de datos de origen para la serializaci√≥n empiece con tipos
de datos grandes y termine con elementos booleanos. De este modo se reduce
considerablemente el relleno con bits de relleno.
Nota
Serializaci√≥n de varias estructuras en una CPU-S7-1200
Si desea serializar varias estructuras en un b√∫fer de una CPU-S7-1200 y establecer
comunicaci√≥n con ellas (p. ej., con un sistema de control o una CPU-S7-1500), deber√°
comprobar si el valor de retorno (√≠ndice del par√°metro POS) es par. Si este no es el caso,
deber√° incrementar el valor de retorno en 1 antes de serializar la segunda estructura, ya que
la primera estructura no se rellena con un byte de relleno.
Ejemplo:
Estructura compuesta por 1 DWORD y 1 BYTE
La direcci√≥n inicial para la siguiente estructura serializada en el b√∫fer es 5. A√±ada +1 para que
la direcci√≥n inicial sea un n√∫mero par.

√Årea de memoria optimizada
Para serializar estructuras de mayor tama√±o, el √°rea de memoria puede declararse tambi√©n
con acceso optimizado a partir de la versi√≥n de firmware >= 4.2 de las CPU de la serie S7-1200
y a partir de la versi√≥n de firmware >= 2.0 de las CPU de la serie S7-1500. La representaci√≥n
secuencial no cambia, igual que en un √°rea de memoria est√°ndar.

1850

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

SRC_VARIA‚Äê Input
BLE

Todos los tipos de
datos

I, Q, D, interfaz de
bloque de un FB,

Variable que se serializar√°.

DEST_ARRA InOut
Y

ARRAY of BYTE o
ARRAY of CHAR

I, Q, D, interfaz de
bloque de un FB
(son posibles las
secciones Input,
Output, Static y
Temp).

Array en el que se guarda el
flujo de datos generado.

DINT

I, Q, M, D, L

El operando del par√°metro
POS almacena el √≠ndice del
primer byte tras el n√∫mero to‚Äê
tal de bytes que han ocupado
los datos de cliente converti‚Äê
dos. El par√°metro POS se
calcula basado en cero.

INT

I, Q, M, D, L

Informaci√≥n de error

S7-1500:
ning√∫n dato de pe‚Äê Para obtener el m√°ximo ren‚Äê
riferia
dimiento, no transfiera valo‚Äê
res a este par√°metro con un
puntero VARIANT.

S7-1500:

Para obtener el m√°ximo ren‚Äê
dimiento, no transfiera valo‚Äê
res a este par√°metro con un
ning√∫n dato de pe‚Äê puntero VARIANT.
riferia

POS

InOut

Valor de funci√≥n

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

80B0

Las √°reas de memoria de los par√°metros SRC_VARIABLE y DEST_ARRAY se solapan.

8150

El tipo de datos VARIANT del par√°metro SRC_VARIABLE contiene un puntero IGUAL A
CERO.

8151

El par√°metro SRC_VARIABLE no tiene una referencia v√°lida.

8236

La variable del par√°metro SRC_ARRAY no est√° en un bloque con acceso est√°ndar.

8250

En el par√°metro DEST_ARRAY se ha transferido un puntero CERO.

8251

El par√°metro DEST_ARRAY no tiene una referencia v√°lida.

8253

La variable del par√°metro DEST_ARRAY no ofrece suficiente espacio de memoria para
el contenido de la variable del par√°metro SRC_VARIABLE. El valor de entrada de la
variable del par√°metro POS reduce el espacio de memoria disponible. El valor de entrada
del par√°metro POS determina en qu√© posici√≥n de la variable se comienza en el par√°metro
DEST_ARRAY.

8254

Tipo de datos no v√°lido en el par√°metro DEST_ARRAY

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1851

Instrucciones
4.1 Instrucciones
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

8382

El valor del par√°metro POS se encuentra fuera de los valores l√≠mite del array.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Particularidades a partir de la versi√≥n de firmware 4.2 (S7-1200) y 2.0 (S7-1500):
El c√≥digo de error siguiente tiene un significado distinto:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

8236

El acceso al √°rea de memoria en el par√°metro DEST_ARRAY no es v√°lido.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Particularidades a partir de la versi√≥n de firmware 2.8 (S7-1500):
El rendimiento de la instrucci√≥n "Serializar" (versi√≥n 2.1) mejora si no se transfieren valores a
los par√°metros SRC_VARIABLE y DEST_ARRAY con un puntero VARIANT, sino con un tipo
de datos concreto.
Tenga en cuenta que el comportamiento err√≥neo de la instrucci√≥n cambia en este caso. En
determinados escenarios de error, la CPU no devuelve c√≥digos de error, sino que pasa a
STOP con un error de acceso. Para evitar que esto ocurra, utilice el tratamiento de errores local
con las instrucciones "GET_ERROR" y "GET_ERR_ID".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
#Tag_RetVal := Serialize(SRC_VARIABLE := "Source".Client,
DEST_ARRAY := "Buffer".Field,
POS := #BufferPos);
#Label := STRING_TO_WSTRING('arti');
#Tag_RetVal := Serialize(SRC_VARIABLE := #Label,
DEST_ARRAY := "Buffer".Field,
POS := #BufferPos);
#Tag_RetVal := Serialize(SRC_VARIABLE := "Source".Article[#DeliverPos],
DEST_ARRAY := "Buffer".Field,
POS := #BufferPos);

1852

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucci√≥n "Deserializar" serializa los datos de cliente de la variable "Source" y los escribe,
en representaci√≥n secuencial, en la variable "Buffer". El √≠ndice del siguiente byte no escrito del
operando "Buffer".Field se almacena en el operando #BufferPos.
Para facilitar la posterior deserializaci√≥n de la forma de representaci√≥n secuencial, ahora se
inserta una especie de separador. La instrucci√≥n "Desplazar cadena de caracteres" copia los
caracteres "arti" en el operando #Label. La instrucci√≥n "Serializar" escribe estos caracteres,
tras los datos de cliente, en la variable "Buffer". Se incrementa correspondientemente el valor
del operando "#BufferPos".
La instrucci√≥n "Serializar" serializa los datos de un determinado art√≠culo, que se calcula en
tiempo de ejecuci√≥n, de la variable "Source", y los escribe en forma de representaci√≥n
secuencial despu√©s de los caracteres "arti" en la variable "Buffer".
La tabla siguiente muestra la declaraci√≥n de los operandos:
Operando

Tipo de datos

Declaraci√≥n

DeliverPos

INT

En la secci√≥n "Input" de la inter‚Äê
faz del bloque

BufferPos

DINT

En la secci√≥n "Temp" de la inter‚Äê
faz del bloque

Error

INT

En la secci√≥n "Temp" de la inter‚Äê
faz del bloque

Label

STRING[4]

En la secci√≥n "Temp" de la inter‚Äê
faz del bloque

La siguiente tabla muestra la declaraci√≥n de los tipos de datos PLC:
Nombre de los tipos de datos
PLC

Nombre

Tipo de datos

Article

Number

DINT

Declaration

STRING

Colli

INT

Title

INT

First name

STRING[10]

Surname

STRING[10]

Client

La tabla siguiente muestra la declaraci√≥n de los bloques de datos:
Nombre de los bloques de datos Nombre

Tipo de datos

Source

Client

"Client" (tipo de datos PLC)

Article

Array[0..10] of "Article" (tipo de
datos PLC)

Field

Array[0..294] of BYTE

Buffer

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de los tipos de datos PLC (UDT) (P√°gina 283)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1853

Instrucciones
4.1 Instrucciones
Estructura de una variable ARRAY (P√°gina 298)
Estructura de una variable STRUCT (P√°gina 290)
Estructura de una variable STRING (P√°gina 277)
Bytes de relleno cuando se usan tipos de datos estructurados (P√°gina 143)
Principios b√°sicos de SCL (P√°gina 8115)

MOVE_BLK: Copiar √°rea
Descripci√≥n
La instrucci√≥n "Copiar √°rea" copia los contenidos de un √°rea de memoria (√°rea de origen) en
un √°rea de memoria diferente (√°rea de destino). El n√∫mero de elementos que se copian en el
√°rea de destino se determina con el par√°metro COUNT. El ancho del primer elemento del √°rea
de origen define el ancho de los elementos que deben copiarse.
Para poder ejecutar la instrucci√≥n, el √°rea de origen y el √°rea de destino deben ser del mismo
tipo de datos.
El valor de la salida OUT no es v√°lido si se cumple la siguiente condici√≥n:
‚óè Se copian m√°s datos de los que est√°n disponibles en el par√°metro IN o en el par√°metro
OUT.
Nota
Uso de ARRAYs
La instrucci√≥n copia el contenido a partir del elemento definido n elementos (n = depende del
valor del par√°metro COUNT) desde el √°rea de origen al √°rea de destino, comenzando por el
√≠ndice especificado.

1854

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memo‚Äê Descripci√≥n
ria

IN 1)

Input

N√∫meros bina‚Äê
rios, enteros,
n√∫meros en co‚Äê
ma flotante,
tiempos, DA‚Äê
TE, CHAR,
WCHAR, TOD

N√∫meros bi‚Äê D, L
narios, ente‚Äê
ros, n√∫me‚Äê
ros en coma
flotante,
tiempos, DA‚Äê
TE, CHAR,
WCHAR,
TOD, LTOD

Primer elemen‚Äê
to del √°rea de
origen que se
copia

COUNT

Input

USINT, UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

N√∫mero de ele‚Äê
mentos que se
copian del √°rea
de origen al
√°rea de destino

OUT 1)

Output

N√∫meros bina‚Äê
rios, enteros,
n√∫meros en co‚Äê
ma flotante,
tiempos, DA‚Äê
TE, CHAR,
WCHAR, TOD

N√∫meros bi‚Äê D, L
narios, ente‚Äê
ros, n√∫me‚Äê
ros en coma
flotante,
tiempos, DA‚Äê
TE, CHAR,
WCHAR,
TOD, LTOD

1)

I, Q, M, D, L, P

Primer elemen‚Äê
to del √°rea de
destino en la
que se copian
los contenidos
del √°rea de ori‚Äê
gen

Los tipos de datos indicados solamente pueden utilizarse como elementos de una estructura ARRAY.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
MOVE_BLK(IN := #a_array[2],
COUNT := "Tag_Count",
OUT => #b_array[1]);

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1855

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

a_array[2]

El operando "a_array" es del tipo
de datos ARRAY[0..5] of INT.
Consta de 6 elementos del tipo
de datos INT.

COUNT

Tag_Count

3

OUT

b_array[1]

El operando "b_array" es del tipo
de datos ARRAY[0..6] of INT.
Consta de 7 elementos del tipo
de datos INT.

La instrucci√≥n selecciona a partir del tercer elemento tres elementos INT de la variable
#a_array y copia su contenido en la variable de salida #b_array, comenzando por el segundo
elemento.
Nota
Encontrar√° m√°s informaci√≥n sobre la instrucci√≥n MOVE_BLK en el Siemens Industry Online
Support, en el art√≠culo siguiente:
¬øC√≥mo se copian √°reas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

MOVE_BLK_VARIANT: Copiar √°rea
Descripci√≥n
La instrucci√≥n "Copiar √°rea" copia los contenidos de un √°rea de memoria (√°rea de origen) en
un √°rea de memoria diferente (√°rea de destino). Se pueden copiar elementos de un ARRAY o
un ARRAY completo en otro ARRAY del mismo tipo de datos. El tama√±o (n√∫mero de
elementos) de los ARRAY de origen y de destino puede diferir. Se pueden copiar varios
elementos dentro de un mismo ARRAY o bien copiar elementos individuales.
El n√∫mero de elementos que deben copiarse no puede rebasar el √°rea de origen o destino
seleccionado.
Cuando se utiliza la instrucci√≥n no es necesario conocer el ARRAY en el momento de crear el
bloque, puesto que el origen y el destino se transfieren v√≠a VARIANT.
El recuento en los par√°metros SRC_INDEX y DEST_INDEX comienza siempre por el l√≠mite
inferior "0", independientemente de la declaraci√≥n posterior del ARRAY.

1856

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucci√≥n no se ejecuta si se copian m√°s datos de los que est√°n disponibles.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

SRC

Input

VARIANT (que
apunta a un
ARRAY o a un ele‚Äê
mento individual
del ARRAY),
ARRAY of <tipo de
datos>

L (puede declarar‚Äê El √°rea de origen de la que se
se en las seccio‚Äê
copia
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

COUNT

Input

UDINT

I, Q, M, D, L

2)

Descripci√≥n

N√∫mero de elementos que
se copian
Asigne al par√°metro COUNT
el valor "1" si en el par√°metro
SRC o en el par√°metro DEST
no hay indicado ning√∫n
ARRAY.

SRC_INDEX

Input

DINT

I, Q, M, D, L

Define el primer elemento
que se copia:
‚óè El par√°metro
SRC_INDEX se calcula
basado en cero. Si en el
par√°metro SRC hay
indicado un ARRAY, el
entero del par√°metro
SRC_INDEX indica el
primer elemento del √°rea
de origen de la que debe
copiarse. Esto es as√≠
independientemente de
los l√≠mites declarados del
ARRAY.
‚óè Si en el par√°metro SRC
no hay indicado ning√∫n
ARRAY o solo un
elemento individual de un
ARRAY, asigne el valor
"0" al par√°metro
SRC_INDEX.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1857

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

DEST_IN‚Äê
DEX

Input

DINT

I, Q, M, D, L

Define el inicio del √°rea de
memoria de destino:
‚óè El par√°metro
DEST_INDEX se calcula
basado en cero. Si en el
par√°metro DEST hay
indicado un ARRAY, el
entero del par√°metro
DEST_INDEX indica el
primer elemento del √°rea
de destino en la que debe
copiarse. Esto es as√≠
independientemente de
los l√≠mites declarados del
ARRAY.
‚óè Si en el par√°metro DEST
no hay indicado ning√∫n
ARRAY, asigne el valor
"0" al par√°metro
DEST_INDEX.

DEST

Output 1)

Valor de funci√≥n (RET_VAL)

VARIANT

L (puede declarar‚Äê √Årea de destino a la que se
se en las seccio‚Äê
copia el contenido del √°rea
nes "Input",
de origen.
"InOut" y "Temp"
de la interfaz del
bloque.)

INT

I, Q, M, D, L

Informaci√≥n de error

1) El par√°metro DEST est√° declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.
2) En el par√°metro SRC, los tipos de datos BOOL y ARRAY of BOOL no est√°n permitidos.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)

1858

0000

Ning√∫n error

80B4

Los tipos de datos no coinciden. En lugar de un ARRAY of Struct utilice un ARRAY of tipo
de datos PLC (UDT).

8151

No es posible acceder al par√°metro SRC.

8152

El operando del par√°metro SRC no est√° tipificado.

8153

Error de creaci√≥n de c√≥digo en el par√°metro SRC

8154

El operando del par√°metro SRC es del tipo de datos BOOL.

8281

Valor no v√°lido en el par√°metro COUNT

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
8382

El valor del par√°metro SRC_INDEX es menor que CERO.

8383

El valor del par√°metro SRC_INDEX se encuentra fuera del l√≠mite superior del ARRAY.

8482

El valor del par√°metro DEST_INDEX se encuentra fuera de los l√≠mites del ARRAY.

8483

El ARRAY al que se√±ala el par√°metro DEST es demasiado peque√±o para los datos que
deben copiarse.

8534

El par√°metro DEST est√° protegido contra escritura

8551

No es posible acceder al par√°metro DEST.

8552

El operando del par√°metro DEST no est√° tipificado.

8553

Error de creaci√≥n de c√≥digo en el par√°metro DEST

8554

El operando del par√°metro DEST es del tipo de datos BOOL.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := MOVE_BLK_VARIANT(SRC := #SrcField,
COUNT := "Tag_Count",
SRC_INDEX := "Tag_Src_Index",
DEST_INDEX := "Tag_Dest_Index",
DEST => #DestField);

La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Declaraci√≥n en la inter‚Äê
faz del bloque

Operando

Valor

SRC

Input

#SrcField

El operando local
#SrcField utiliza un tipo
de datos PLC todav√≠a
desconocido en el mo‚Äê
mento de programar el
bloque. (ARRAY[0..10]
of "MOVE_UDT"

COUNT

Input

Tag_Count

2

SRC_INDEX

Input

Tag_Src_Index

3

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1859

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n en la inter‚Äê
faz del bloque

Operando

Valor

DEST_INDEX

Input

Tag_Dest_Index

3

DEST

InOut

#DestField

El operando local
#DestField utiliza un ti‚Äê
po de datos PLC toda‚Äê
v√≠a desconocido en el
momento de programar
el bloque.
(ARRAY[10..20] of "MO‚Äê
VE_UDT"

En el √°rea de destino se copian dos elementos del √°rea de origen, empezando por el cuarto
elemento del ARRAY[0..10] of MOVE_UDT. Las copias se insertan en el ARRAY[10..20] of
MOVE_UDT a partir del cuarto elemento.
Nota
Encontrar√° m√°s informaci√≥n sobre la instrucci√≥n MOVE_BLK_VARIANT en el Siemens
Industry Online Support, en el art√≠culo siguiente:
¬øC√≥mo se copian √°reas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
VariantGet: Leer valor de una variable VARIANT (P√°gina 1914)
Principios b√°sicos de SCL (P√°gina 8115)

UMOVE_BLK: Copiar √°rea sin interrupciones
Descripci√≥n
La instrucci√≥n "Copiar √°rea sin interrupciones" copia sin interrupciones los contenidos de un
√°rea de memoria (√°rea de origen) en un √°rea de memoria diferente (√°rea de destino). El
n√∫mero de elementos que se copian en el √°rea de destino se determina con el par√°metro
COUNT. El ancho del primer elemento del √°rea de origen define el ancho de los elementos que
deben copiarse.

1860

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para poder ejecutar la instrucci√≥n, el √°rea de origen y el √°rea de destino deben ser del mismo
tipo de datos.
Nota
La operaci√≥n de copia no debe ser interrumpida por otras actividades del sistema operativo.
Por este motivo, los tiempos de reacci√≥n a alarmas de la CPU podr√≠an aumentar al ejecutar la
instrucci√≥n "Copiar √°rea sin interrupciones".
El valor de la salida OUT no es v√°lido si se cumple la siguiente condici√≥n:
‚óè Se copian m√°s datos de los que est√°n disponibles en el par√°metro IN o en el par√°metro
OUT.
La instrucci√≥n "Copiar √°rea sin interrupciones" permite copiar 16 KB como m√°ximo. A este
respecto deben tenerse en cuenta las limitaciones espec√≠ficas de la CPU.
Nota
Uso de ARRAYs
La instrucci√≥n copia el contenido a partir del elemento definido n elementos (n = depende del
valor del par√°metro COUNT) desde el √°rea de origen al √°rea de destino, comenzando por el
√≠ndice especificado.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

S7-1200

S7-1500

IN 1)

Input

N√∫meros bina‚Äê
rios, enteros,
n√∫meros en co‚Äê
ma flotante,
tiempos, DA‚Äê
TE, CHAR,
WCHAR, TOD

N√∫meros bi‚Äê D, L
narios, ente‚Äê
ros, n√∫me‚Äê
ros en coma
flotante,
tiempos, DA‚Äê
TE, CHAR,
WCHAR,
TOD, LTOD

Primer elemen‚Äê
to del √°rea de
origen que se
copia

COUNT

Input

USINT, UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

N√∫mero de ele‚Äê
mentos que se
copian del √°rea
de origen al
√°rea de destino

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Tipo de datos

√Årea de memo‚Äê Descripci√≥n
ria

I, Q, M, D, L, P

1861

Instrucciones
4.1 Instrucciones
Par√°metro
OUT 1)

1)

Declaraci√≥n
Output

Tipo de datos

√Årea de memo‚Äê Descripci√≥n
ria

S7-1200

S7-1500

N√∫meros bina‚Äê
rios, enteros,
n√∫meros en co‚Äê
ma flotante,
tiempos, DA‚Äê
TE, CHAR,
WCHAR, TOD

N√∫meros bi‚Äê D, L
narios, ente‚Äê
ros, n√∫me‚Äê
ros en coma
flotante,
tiempos, DA‚Äê
TE, CHAR,
WCHAR,
TOD, LTOD

Primer elemen‚Äê
to del √°rea de
destino en la
que se copian
los contenidos
del √°rea de ori‚Äê
gen

Los tipos de datos indicados solamente pueden utilizarse como elementos de una estructura ARRAY.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
UMOVE_BLK(IN := #a_array[2],
COUNT := "Tag_Count",
OUT => #b_array[1]);

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

a_array[2]

El operando "a_array" es del tipo
de datos ARRAY[0..5] of INT.
Consta de 6 elementos del tipo
de datos INT.

COUNT

Tag_Count

3

OUT

b_array[1]

El operando "b_array" es del tipo
de datos ARRAY[0..6] of INT.
Consta de 7 elementos del tipo
de datos INT.

La instrucci√≥n selecciona a partir del tercer elemento tres elementos INT de la variable
#a_array y copia su contenido en la variable de salida #b_array, comenzando por el segundo
elemento. La operaci√≥n de copia no debe ser interrumpida por otras actividades del sistema
operativo.
Nota
Encontrar√° m√°s informaci√≥n sobre la instrucci√≥n UMOVE_BLK en el Siemens Industry Online
Support, en el art√≠culo siguiente:
¬øC√≥mo se copian √°reas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

1862

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

FILL_BLK: Rellenar √°rea
Descripci√≥n
La instrucci√≥n "Rellenar √°rea" permite rellenar un √°rea de memoria (√°rea de destino) con el
valor de la entrada IN. El √°rea de destino se rellena a partir de la direcci√≥n indicada en la salida
OUT. El n√∫mero de repeticiones de copia se determina mediante el par√°metro COUNT. Al
ejecutar la instrucci√≥n, el valor de la entrada IN se copia en el √°rea de destino el n√∫mero de
veces especificado por el valor del par√°metro COUNT.
Para poder ejecutar la instrucci√≥n, el √°rea de origen y el √°rea de destino deben ser del mismo
tipo de datos.
Como m√°ximo se modifican tantos elementos como tiene el ARRAY o la estructura. Si se
copian m√°s datos que los elementos disponibles en la salida OUT, el resultado no ser√° el
deseado.
Nota
Uso de ARRAYs
La instrucci√≥n lee en el √°rea de origen el contenido del elemento seleccionado y lo copia n
veces (n = depende del valor del par√°metro COUNT) en el √°rea de destino, comenzado a partir
del √≠ndice especificado.

Rellenar estructuras
Adem√°s de los elementos de un ARRAY, tambi√©n es posible rellenar varios elementos de una
estructura (STRUCT, tipo de datos PLC) con el mismo valor. La estructura cuyos elementos
deben rellenarse puede contener √∫nicamente elementos individuales del mismo tipo de datos
elemental. No obstante, la estructura propiamente dicha puede estar incrustada en otra
estructura.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1863

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de me‚Äê
moria

Descripci√≥n

IN

Input

N√∫meros bina‚Äê
rios, enteros, n√∫‚Äê
meros en coma
flotante, tempori‚Äê
zadores, TOD,
DATE, CHAR,
WCHAR

N√∫meros bina‚Äê
rios, enteros, n√∫‚Äê
meros en coma
flotante, tiempos,
DATE, CHAR,
WCHAR, TOD,
LTOD

I, Q, M, D, L,
P

Elemento con el
que se rellena el
√°rea de destino

COUNT

Input

USINT, UINT,
UDINT

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L,
P

N√∫mero de repe‚Äê
ticiones de copia

OUT

Output

N√∫meros bina‚Äê
rios, enteros, n√∫‚Äê
meros en coma
flotante, tempori‚Äê
zadores, TOD,
DATE, CHAR,
WCHAR

N√∫meros bina‚Äê
rios, enteros, n√∫‚Äê
meros en coma
flotante, tiempos,
DATE, CHAR,
WCHAR, TOD,
LTOD

D, L

Direcci√≥n del
√°rea de destino
a partir de la
cual se rellena

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo con un ARRAY
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n cuando debe rellenarse un
ARRAY:
SCL
FILL_BLK(IN := #FillValue,
COUNT := "Tag_Count",
OUT => #TargetArea[1]);

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

FillValue

El operando es del tipo de datos
INT.

COUNT

Tag_Count

3

OUT

TargetArea

El operando TargetArea es del
tipo de datos ARRAY[1..5] of
INT. Consta de 5 elementos del
tipo de datos INT.

La instrucci√≥n copia tres veces el valor del operando #FillValue en la variable de salida
#TargetArea, empezando por el primer elemento.

1864

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplos con una estructura
Los siguientes ejemplos muestran el funcionamiento de la instrucci√≥n cuando debe rellenarse
una estructura.
Cree un bloque de datos global con los elementos siguientes:
Data_block_1

Tipo de datos

MyStruct1

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

MyStruct2

STRUCT

SubArray

ARRAY[1..2] of STRUCT

SubArray[1]

STRUCT

NestedStruct

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

SubArray[2]

STRUCT

Nes‚Äê
tedStruct

STRUCT
Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

Cree el c√≥digo de programa siguiente para direccionar la variable MyStruct1:
SCL
FILL_BLK(IN := 10,
COUNT := 2,
OUT => "Data_block_1".MyStruct1.Member_2);

Cree el c√≥digo de programa siguiente para direccionar la variable MyStruct2:
SCL
FILL_BLK(IN := 10,
COUNT := 2,
OUT => "Data_block_1".MyStruct2.SubArray[1].NestedStruct.Member_2);

En ambos ejemplos, el valor 10 del par√°metro IN se copia dos veces en el operando del
par√°metro OUT, empezando por el elemento Member_2. Esto significa que el valor 10 se copia
tanto en el elemento Member_2 como en el Member_3. Los otros dos elementos, Member_1
y Member_4, no cambian.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1865

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

UFILL_BLK: Rellenar √°rea sin interrupciones
Descripci√≥n
La instrucci√≥n "Rellenar √°rea sin interrupciones" rellena sin interrupciones un √°rea de memoria
(√°rea de destino) con el valor de la entrada IN. El √°rea de destino se rellena a partir de la
direcci√≥n indicada en la salida OUT. El n√∫mero de repeticiones de copia se determina
mediante el par√°metro COUNT. Al ejecutar la instrucci√≥n, el valor de la entrada IN se copia en
el √°rea de destino el n√∫mero de veces especificado por el valor del par√°metro COUNT.
Para poder ejecutar la instrucci√≥n, el √°rea de origen y el √°rea de destino deben ser del mismo
tipo de datos.
Nota
La operaci√≥n de copia no debe ser interrumpida por otras actividades del sistema operativo.
Por este motivo, los tiempos de reacci√≥n a alarmas de la CPU podr√≠an aumentar al ejecutar la
instrucci√≥n "Rellenar √°rea sin interrupciones".
Como m√°ximo se modifican tantos elementos como tiene el ARRAY o la estructura. Si se
copian m√°s datos que los elementos disponibles en la salida OUT, el resultado no ser√° el
deseado.
Nota
Uso de ARRAYs
La instrucci√≥n lee en el √°rea de origen el contenido del elemento seleccionado y lo copia n
veces (n = depende del valor del par√°metro COUNT) en el √°rea de destino, comenzado a partir
del √≠ndice especificado.
La instrucci√≥n "Rellenar √°rea sin interrupciones" permite copiar 16 KB como m√°ximo. A este
respecto deben tenerse en cuenta las limitaciones espec√≠ficas de la CPU.

Rellenar estructuras
Adem√°s de los elementos de un ARRAY, tambi√©n es posible rellenar varios elementos de una
estructura (STRUCT, tipo de datos PLC) con el mismo valor. La estructura cuyos elementos
deben rellenarse puede contener √∫nicamente elementos individuales del mismo tipo de datos
elemental. No obstante, la estructura propiamente dicha puede estar incrustada en otra
estructura.

1866

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de me‚Äê
moria

Descripci√≥n

IN

Input

N√∫meros bina‚Äê
rios, enteros,
n√∫meros en
coma flotante,
tiempos, DA‚Äê
TE, CHAR,
WCHAR, TOD

N√∫meros bina‚Äê
rios, enteros,
n√∫meros en co‚Äê
ma flotante,
tiempos, DATE,
CHAR,
WCHAR, TOD,
LTOD

I, Q, M, D, L, P Elemento con el
que se rellena el
√°rea de destino

COUNT

Input

USINT, UINT,
UDINT

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P N√∫mero de repeti‚Äê
ciones de copia

OUT

Output

N√∫meros bina‚Äê
rios, enteros,
n√∫meros en
coma flotante,
temporizado‚Äê
res, TOD, DA‚Äê
TE, CHAR,
WCHAR

N√∫meros bina‚Äê
rios, enteros,
n√∫meros en co‚Äê
ma flotante,
tiempos, DATE,
CHAR,
WCHAR, TOD,
LTOD

D, L

Direcci√≥n del √°rea
de destino a partir
de la cual se relle‚Äê
na

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo con un ARRAY
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n cuando debe rellenarse un
ARRAY:
SCL
UFILL_BLK(IN := #FillValue,
COUNT := "Tag_Count",
OUT => #TargetArea[1]);

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

FillValue

El operando es del tipo de datos
INT.

COUNT

Tag_Count

3

OUT

TargetArea

El operando TargetArea es del
tipo de datos ARRAY[1..5] of
INT. Consta de 5 elementos del
tipo de datos INT.

La instrucci√≥n copia tres veces el valor del operando #FillValue en la variable de salida
#TargetArea, empezando por el primer elemento. La operaci√≥n de copia no debe ser
interrumpida por otras actividades del sistema operativo.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1867

Instrucciones
4.1 Instrucciones

Ejemplos con una estructura
Los siguientes ejemplos muestran el funcionamiento de la instrucci√≥n cuando debe rellenarse
una estructura.
Cree un bloque de datos global con los elementos siguientes:
Data_block_1

Tipo de datos

MyStruct1

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

MyStruct2

STRUCT

SubArray

ARRAY[1..2] of STRUCT

SubArray[1]

STRUCT

NestedStruct

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

SubArray[2]

STRUCT

Nes‚Äê
tedStruct

STRUCT
Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

Cree el c√≥digo de programa siguiente para direccionar la variable MyStruct1:
SCL
UFILL_BLK(IN := 10,
COUNT := 2,
OUT => "Data_block_1".MyStruct1.Member_2);

Cree el c√≥digo de programa siguiente para direccionar la variable MyStruct2:
SCL
UFILL_BLK(IN := 10,
COUNT := 2,
OUT => "Data_block_1".MyStruct2.SubArray[1].NestedStruct.Member_2);

En ambos ejemplos, el valor 10 del par√°metro IN se copia dos veces en el operando del
par√°metro OUT, empezando por el elemento Member_2. Esto significa que el valor 10 se copia
tanto en el elemento Member_2 como en el Member_3. Los otros dos elementos, Member_1
y Member_4, no cambian.

1868

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

SCATTER: Dispersi√≥n de una secuencia de bits en bits individuales
Descripci√≥n
La instrucci√≥n "Dispersi√≥n de una secuencia de bits en bits individuales" descompone una
variable del tipo de datos BYTE, WORD, DWORD o LWORD en bits individuales y los guarda
en un ARRAY of BOOL, un STRUCT an√≥nimo o un tipo de datos PLC con elementos
booleanos exclusivamente.
Nota
ARRAY of BOOL multidimensional
En la instrucci√≥n "Dispersi√≥n de una secuencia de bits en bits individuales" no est√° permitido
utilizar un ARRAY of BOOL multidimensional.
Nota
Longitud del ARRAY, del STRUCT o del tipo de datos PLC
El ARRAY, el STRUCT an√≥nimo o el tipo de datos PLC deben tener tantos elementos como se
especifique en la secuencia de bits.
Es decir, en el tipo de datos BYTE, p. ej., el ARRAY, el STRUCT o el tipo de datos PLC deben
tener exactamente 8 elementos (WORD = 16, DWORD = 32 y LWORD = 64).
Nota
Disponibilidad de la instrucci√≥n
La instrucci√≥n puede utilizarse en las CPU de la serie S7-1200 a partir de la versi√≥n de firmware
>4.2 y en las CPU de la serie S7-1500 a partir de la versi√≥n de firmware 2.1.
De este modo es posible, p. ej., descomponer una palabra de estado y leer y modificar por
√≠ndice el estado de los bits individuales. Mediante GATHER pueden juntarse nuevamente los
bits en una secuencia de bits.
La salida de habilitaci√≥n ENO devuelve el estado l√≥gico "0" si se cumple una de las siguientes
condiciones:
‚óè La entrada de habilitaci√≥n EN devuelve el estado l√≥gico "0".
‚óè El ARRAY, STRUCT o tipo de datos PLC no proporciona suficientes elementos BOOL.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1869

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declara‚Äê
ci√≥n

IN

Input

OUT

Output

Tipo de datos
S7-1200

S7-1500

BYTE, WORD,
DWORD

BYTE,
WORD,
DWORD,
LWORD

√Årea de me‚Äê Descripci√≥n
moria
I, Q, M, D, L Secuencia de bits que se des‚Äê
compone.
Los valores no pueden encon‚Äê
trarse en el √°rea de periferia o
en el DB de un objeto tecnol√≥‚Äê
gico.

ARRAY[*] of
BOOL,
STRUCT o ti‚Äê
po de datos
PLC

ARRAY[*] of I, Q, M, D, L ARRAY, STRUCT o tipo de da‚Äê
tos PLC en el/los que se guar‚Äê
BOOL,
dan los bits individuales
STRUCT o
tipo de datos
PLC

*: 8, 16, 32 o
64 elementos

*: 8, 16, 32 o
64 elemen‚Äê
tos

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo con un ARRAY
Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceWord

Input

WORD

DestinationArray

Output

ARRAY[0..15] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
SCATTER(IN := #SourceWord,
OUT => #DestinationArray);

La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceWord

WORD (16 bits)

OUT

DestinationArray

El operando "DestinationArray"
es del tipo de datos
ARRAY[0..15] of BOOL. Consta
de 16 elementos y, por tanto, tie‚Äê
ne el mismo tama√±o que la
WORD que se debe descompo‚Äê
ner.

El operando #SourceWord del tipo de datos WORD se descompone en sus bits individuales
(16) y se asigna a los distintos elementos del operando #DestinationArray.

1870

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo con un tipo de datos PLC (UDT)
Cree el siguiente tipo de datos PLC "myBits":

Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceWord

Input

WORD

DestinationUDT

Output

"myBits"

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
SCATTER(IN := #SourceWord,
OUT => #DestinationUDT);

La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceWord

WORD (16 bits)

OUT

DestinationUDT

El operando "DestinationUDT"
es del tipo de datos PLC (UDT).
Consta de 16 elementos y, por
tanto, tiene el mismo tama√±o
que la WORD que se debe des‚Äê
componer.

El operando #SourceWord del tipo de datos WORD se descompone en sus bits individuales
(16) y se asigna a los distintos elementos del operando #DestinationUDT.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1871

Instrucciones
4.1 Instrucciones

SCATTER_BLK: Dispersi√≥n de elementos de un ARRAY of secuencia de bits en bits individuales
Descripci√≥n
La instrucci√≥n "Dispersi√≥n de elementos de un ARRAY of secuencia de bits en bits
individuales" descompone uno o varios elementos de un ARRAY of BYTE, WORD, DWORD
o LWORD en bits individuales y los guarda en un ARRAY of BOOL, un STRUCT an√≥nimo o un
tipo de datos PLC con elementos booleanos exclusivamente. En el par√°metro COUNT_IN se
introduce el n√∫mero de elementos del ARRAY de origen que deben dispersarse. El ARRAY de
origen en el par√°metro IN puede tener m√°s elementos que los indicados en el par√°metro
COUNT_IN. El ARRAY of BOOL, el STRUCT an√≥nimo o el tipo de datos PLC deben tener
suficientes elementos para poder guardar los bits de la secuencia de bits descompuesta. El
√°rea de memoria de destino tambi√©n puede ser mayor.
Nota
ARRAY of BOOL multidimensional
Si el ARRAY es un ARRAY of BOOL multidimensional, se cuentan tambi√©n los bits de relleno
de las dimensiones contenidas, aunque no se hayan declarado expl√≠citamente.
Ejemplo 1: un ARRAY[1..10,0..4,1..2] of BOOL recibe el mismo tratamiento que un
ARRAY[1..10,0..4,1..8] of BOOL o que un ARRAY[0..399] of BOOL.
Ejemplo 2: En el par√°metro IN hay un ARRAY[0..5] of WORD (sourceArrayWord[2])
interconectado. El par√°metro COUNT_IN tiene el valor "3". En el par√°metro OUT hay un
ARRAY[0..1,0..5,0..7] of BOOL (destinationArrayBool[0,0,0]) interconectado. Tanto el array
del par√°metro IN como el del par√°metro OUT tienen 96 bits de tama√±o. El ARRAY of WORD
se descompone en 48 bits individuales.
Nota
Si el l√≠mite inferior del ARRAY de destino no es "0", cabe considerar lo siguiente:
Por motivos de rendimiento, el √≠ndice debe comenzar siempre en un l√≠mite de BYTE, WORD,
DWORD o LWORD. Esto significa que debe calcularse el √≠ndice partiendo del l√≠mite inferior del
ARRAY. Como base para el c√°lculo se utiliza la siguiente f√≥rmula:
√çndice v√°lido = l√≠mite inferior del ARRAY + n(n√∫mero de secuencias de bits) * n√∫mero de bits
de la secuencia de bits deseada
Para un ARRAY[-2..45] of BOOL y la secuencia de bits WORD, el c√°lculo es el siguiente:
‚óè √çndice v√°lido (-2) = -2 + 0 * 16
‚óè √çndice v√°lido (14) = -2 + 1 * 16
‚óè √çndice v√°lido (30) = -2 + 2 * 16
Ver un ejemplo m√°s adelante.
Nota
Disponibilidad de la instrucci√≥n
La instrucci√≥n puede utilizarse en las CPU de la serie S7-1200 a partir de la versi√≥n de firmware
>4.2 y en las CPU de la serie S7-1500 a partir de la versi√≥n de firmware 2.1.

1872

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
De este modo es posible, p. ej., descomponer palabras de estado y leer y modificar por √≠ndice
el estado de los bits individuales. Mediante GATHER pueden juntarse nuevamente los bits en
una secuencia de bits.
La salida de habilitaci√≥n ENO devuelve el estado l√≥gico "0" si se cumple una de las siguientes
condiciones:
‚óè La entrada de habilitaci√≥n EN devuelve el estado l√≥gico "0".
‚óè El ARRAY de origen tiene menos elementos que los que se especifican en el par√°metro
COUNT_IN.
‚óè El √≠ndice del ARRAY de destino no empieza en un l√≠mite de BYTE, WORD, DWORD o
LWORD. En este caso no se escribe ning√∫n resultado en el ARRAY of BOOL.
‚óè El ARRAY[*] of BOOL, el STRUCT o el tipo de datos PLC no proporcionan el n√∫mero
necesario de elementos.
‚Äì CPU S7-1500: se descomponen tantas secuencias de bits como sea posible y se
escriben en el ARRAY of BOOL, STRUCT an√≥nimo o tipo de datos PLC. El resto de
secuencias de bits no se tiene en cuenta.
‚Äì CPU S7-1200: no se efect√∫a ninguna copia.
Nota
CPU S7-1200: Salida de habilitaci√≥n ENO = 0
Si la salida de habilitaci√≥n ENO devuelve el estado l√≥gico "0", no se escribir√°n datos en el
par√°metro de salida OUT.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1873

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro
IN

COUNT_IN

Declara‚Äê
ci√≥n
Input

Input

Tipo de datos

√Årea de
memoria

Descripci√≥n

S7-1200

S7-1500

Elemento de un
ARRAY[*] of
<secuencia de
bits>

Elemento de
un
ARRAY[*] of
<secuencia
de bits>

I, Q, M, D, L ARRAY of <secuencia de
bits> que se descompone.

USINT, UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

I, Q, M, D, L Contador del n√∫mero de ele‚Äê
mentos del ARRAY de ori‚Äê
gen que deben descompo‚Äê
nerse.

Los valores no pueden en‚Äê
contrarse en el √°rea de peri‚Äê
feria o en el DB de un objeto
tecnol√≥gico.

El valor no puede encontrar‚Äê
se en el √°rea de periferia o
en el DB de un objeto tecno‚Äê
l√≥gico.
OUT

Output

Elemento de un
ARRAY[*] of
BOOL,
STRUCT o tipo
de datos PLC

Elemento de I, Q, M, D, L ARRAY, STRUCT o tipo de
datos PLC en el/los que se
un
guardan los bits individuales
ARRAY[*] of
BOOL,
STRUCT o
tipo de datos
PLC

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo de un ARRAY de destino con el l√≠mite inferior de "0"
Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceArrayWord

Input

ARRAY[0..5] of WORD

CounterInput
DestinationArrayBool

UDINT
Output

ARRAY[0..95] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
SCATTER_BLK(IN := #SourceArrayWord[2],
COUNT_IN := #CounterInput,
OUT => #DestinationArrayBool[0]);

1874

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceArrayWord[2]

ARRAY[0..5] of WORD (Pueden
dispersarse 96 bits.)

COUNT_IN

CounterInput = 3

UDINT3 (deben descomponerse
3 WORD o 48 bits. Esto significa
que en el ARRAY de destino de‚Äê
be haber al menos 48 bits).

OUT

DestinationArrayBool[0]

El operando "DestinationArray‚Äê
Bool" es del tipo de datos
ARRAY[0..95] of BOOL. Hay por
tanto 96 elementos BOOL dispo‚Äê
nibles.

La 3.¬™, 4.¬™ y 5.¬™ WORD del operando #SourceArrayWord se descomponen en sus bits
individuales (48) y se asignan a los distintos elementos del operando #DestinationArrayBool a
partir del 1.er elemento.

Ejemplo de ARRAY de destino con el l√≠mite inferior de "-2"
Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceArrayWord

Input

ARRAY[0..5] of WORD

CounterInput

UDINT

DestinationArrayBool

Output

ARRAY[-2..93] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
SCATTER_BLK(IN := #SourceArrayWord[2],
COUNT_IN := #CounterInput,
OUT => #DestinationArrayBool[14]);

La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceArrayWord[2]

ARRAY[0..5] of WORD (Pueden
dispersarse 96 bits.)

COUNT_IN

CounterInput = 3

UDINT3 (deben descomponerse
3 WORD o 48 bits. Esto significa
que en el ARRAY de destino de‚Äê
be haber al menos 48 bits).

OUT

DestinationArrayBool[14]

El operando "DestinationArray‚Äê
Bool" es del tipo de datos
ARRAY[-2..93] of BOOL. Hay
por tanto 96 elementos BOOL
disponibles.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1875

Instrucciones
4.1 Instrucciones
La 3.¬™, 4.¬™ y 5.¬™ WORD del operando #SourceArrayWord se descompone en sus bits
individuales (48) y a partir del 16.¬∫ elemento se asignan a los distintos elementos del operando
#DestinationArrayBool.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

GATHER: Recopilaci√≥n de bits individuales en una secuencia de bits
Descripci√≥n
La instrucci√≥n "Recopilaci√≥n de bits individuales en una secuencia de bits" recompone los bits
de un ARRAY of BOOL, un STRUCT an√≥nimo o un tipo de datos PLC en una secuencia de bits
con elementos booleanos exclusivamente. La secuencia de bits se guarda en una variable del
tipo de datos BYTE, WORD, DWORD o LWORD.
Nota
ARRAY of BOOL multidimensional
En la instrucci√≥n "Recopilaci√≥n de bits individuales en una secuencia de bits" no est√° permitido
utilizar un ARRAY of BOOL multidimensional.
Nota
Longitud del ARRAY, del STRUCT o del tipo de datos PLC
El ARRAY, el STRUCT o el tipo de datos PLC deben tener tantos elementos como se
especifique en la secuencia de bits.
Es decir, en el tipo de datos BYTE, p. ej., el ARRAY, el STRUCT an√≥nimo o el tipo de datos PLC
deben tener exactamente 8 elementos (WORD = 16, DWORD = 32 y LWORD = 64).
Nota
Disponibilidad de la instrucci√≥n
La instrucci√≥n puede utilizarse en las CPU de la serie S7-1200 a partir de la versi√≥n de firmware
>4.2 y en las CPU de la serie S7-1500 a partir de la versi√≥n de firmware 2.1.
La salida de habilitaci√≥n ENO devuelve el estado l√≥gico "0" si se cumple una de las siguientes
condiciones:
‚óè La entrada de habilitaci√≥n EN devuelve el estado l√≥gico "0".
‚óè El ARRAY, STRUCT o tipo de datos PLC (UDT) tiene m√°s o menos elementos BOOL que
lo que especifica la secuencia de bits. En este caso no se transfieren los elementos BOOL.
‚óè Hay menos bits que el n√∫mero de bits necesario.

1876

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro
IN

Declara‚Äê
ci√≥n
Input

Tipo de datos
S7-1500

ARRAY[*] of
BOOL,
STRUCT o tipo
de datos PLC

ARRAY[*] of I, Q, M, D, L
BOOL,
STRUCT o
tipo de datos
PLC

*: 8, 16, 32 o 64
elementos

OUT

Output

√Årea de me‚Äê
moria

S7-1200

BYTE, WORD,
DWORD

*: 8, 16, 32 o
64 elemen‚Äê
tos
BYTE,
WORD,
DWORD,
LWORD

I, Q, M, D, L

Descripci√≥n
ARRAY, STRUCT o tipo
de datos PLC cuyos bits
se recomponen en una
secuencia de bits.
Los valores no pueden
encontrarse en el √°rea de
periferia o en el DB de un
objeto tecnol√≥gico.
Secuencia de bits recopi‚Äê
lada que est√° guardada
en una variable

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo con un ARRAY
Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceArray

Input

ARRAY[0..15] of BOOL

DestinationWord

Output

WORD

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
GATHER(IN := #SourceArray,
OUT => #DestinationWord);

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operando
concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceArray

El operando "SourceArray" es
del tipo de datos ARRAY[0..15]
of BOOL. Consta de 16 elemen‚Äê
tos y, por tanto, tiene el mismo
tama√±o que la WORD en la que
se deben recomponer los bits.

OUT

DestinationWord

WORD (16 bits)

Los bits del operando #SourceArray se recopilan en una WORD.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1877

Instrucciones
4.1 Instrucciones

Ejemplo con un tipo de datos PLC (UDT)
Cree el siguiente tipo de datos PLC "myBits":

Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceUDT

Input

"myBits"

DestinationWord

Output

WORD

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
GATHER(IN := #SourceUDT,
OUT => #DestinationWord);

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operando
concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceUDT

El operando "SourceUDT" es del
tipo de datos PLC (UDT). Consta
de 16 elementos y, por tanto, tie‚Äê
ne el mismo tama√±o que la
WORD en la que se deben re‚Äê
componer los bits.

OUT

DestinationWord

WORD (16 bits)

Los bits del operando #SourceUDT se recomponen en una WORD.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

1878

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

GATHER_BLK: Recopilaci√≥n de bits individuales en varios elementos de un ARRAY of secuencia de bits
Descripci√≥n
La instrucci√≥n "Recopilaci√≥n de bits individuales en varios elementos de un ARRAY of
secuencia de bits" recompone los bits de un ARRAY of BOOL, un STRUCT an√≥nimo o un tipo
de datos PLC con elementos booleanos exclusivamente en uno o varios elementos de un
ARRAY of <secuencia de bits>. En el par√°metro COUNT_OUT se introduce el n√∫mero de
elementos del ARRAY de destino que deben escribirse. Al hacerlo se especifica
impl√≠citamente cu√°ntos elementos del ARRAY of BOOL, del STRUCT an√≥nimo o del tipo de
datos PLC se necesitan. El ARRAY de destino en el par√°metro OUT puede tener m√°s
elementos que los indicados en el par√°metro COUNT_OUT. El ARRAY of <secuencia de bits>
debe tener suficientes elementos para poder guardar los bits que deben recopilarse. El
ARRAY de destino tambi√©n puede ser mayor.
Nota
ARRAY of BOOL multidimensional
Si el ARRAY es un ARRAY of BOOL multidimensional, se cuentan tambi√©n los bits de relleno
de las dimensiones contenidas, aunque no se hayan declarado expl√≠citamente.
Ejemplo 1: un ARRAY[1..10,0..4,1..2] of BOOL recibe el mismo tratamiento que un
ARRAY[1..10,0..4,1..8] of BOOL o que un ARRAY[0..399] of BOOL.
Ejemplo 2: En el par√°metro OUT hay un ARRAY[0..5] of WORD (sourceArrayWord[2])
interconectado. El par√°metro COUNT_IN tiene el valor "3". En el par√°metro IN hay un
ARRAY[0..1,0..5,0..7] of BOOL (destinationArrayBool[0,0,0]) interconectado. Tanto el array
del par√°metro IN como el del par√°metro OUT tienen 96 bits de tama√±o. A partir del ARRAY of
BOOL se recomponen 48 bits individuales.
Nota
Si el l√≠mite inferior del ARRAY de origen no es "0", cabe considerar lo siguiente:
Por motivos de rendimiento, el √≠ndice debe comenzar siempre en un l√≠mite de BYTE, WORD,
DWORD o LWORD. Esto significa que debe calcularse el √≠ndice partiendo del l√≠mite inferior del
ARRAY. Como base para el c√°lculo se utiliza la siguiente f√≥rmula:
√çndice v√°lido = l√≠mite inferior del ARRAY + n(n√∫mero de secuencias de bits) * n√∫mero de bits
de la secuencia de bits deseada
Para un ARRAY[-2..45] of BOOL y la secuencia de bits WORD, el c√°lculo es el siguiente:
‚óè √çndice v√°lido (-2) = -2 + 0 * 16
‚óè √çndice v√°lido (14) = -2 + 1 * 16
‚óè √çndice v√°lido (30) = -2 + 2 * 16
Ver un ejemplo m√°s adelante.
Nota
Disponibilidad de la instrucci√≥n
La instrucci√≥n puede utilizarse en las CPU de la serie S7-1200 a partir de la versi√≥n de firmware
>4.2 y en las CPU de la serie S7-1500 a partir de la versi√≥n de firmware 2.1.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1879

Instrucciones
4.1 Instrucciones
La salida de habilitaci√≥n ENO devuelve el estado l√≥gico "0" si se cumple una de las siguientes
condiciones:
‚óè La entrada de habilitaci√≥n EN devuelve el estado l√≥gico "0".
‚óè El √≠ndice del ARRAY de origen no empieza en un l√≠mite de BYTE, WORD, DWORD o
LWORD. En este caso no se escribe ning√∫n resultado en el ARRAY of <secuencia de bits>.
‚óè El ARRAY[*] of <secuencia de bits> no proporciona el n√∫mero necesario de elementos.
‚Äì CPU S7-1500: se juntan tantas secuencias de bits como sea posible y se escriben en el
ARRAY of <secuencia de bits>. El resto de los bits no se tiene en cuenta.
‚Äì CPU S7-1200: no se efect√∫a ninguna copia.
Nota
CPU S7-1200: Salida de habilitaci√≥n ENO = 0
Si la salida de habilitaci√≥n ENO devuelve el estado l√≥gico "0", no se escribir√°n datos en el
par√°metro de salida OUT.

1880

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro
IN

Declaraci√≥n

Tipo de datos

Input

√Årea de memo‚Äê Descripci√≥n
ria

S7-1200

S7-1500

Elemento de un
ARRAY[*] of
BOOL,
STRUCT o tipo
de datos PLC

Elemento de I, Q, M, D, L
un
ARRAY[*] of
BOOL,
STRUCT o
tipo de datos
PLC

ARRAY of
BOOL,
STRUCT o tipo
de datos PLC
cuyos bits se re‚Äê
componen
(ARRAY de ori‚Äê
gen).
Los valores no
pueden encon‚Äê
trarse en el
√°rea de perife‚Äê
ria o en el DB
de un objeto
tecnol√≥gico.

COUNT_OUT

Input

USINT, UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

I, Q, M, D, L

Contador del
n√∫mero de ele‚Äê
mentos del
ARRAY de des‚Äê
tino que deben
escribirse.
El valor no pue‚Äê
de encontrarse
en el √°rea de
periferia o en el
DB de un obje‚Äê
to tecnol√≥gico.

OUT

Output

Elemento de un
ARRAY[*] of
<secuencia de
bits>

Elemento de
un
ARRAY[*] of
<secuencia
de bits>

I, Q, M, D, L

ARRAY de <se‚Äê
cuencia de
bits> en el que
se guardan los
bits (ARRAY de
destino)

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo de ARRAY de origen con el l√≠mite inferior de "0"
Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceArrayBool

Input

ARRAY[0..95] of BOOL

CounterOutput
DestinationArrayWord

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

UDINT
Output

ARRAY[0..5] of WORD

1881

Instrucciones
4.1 Instrucciones
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
GATHER_BLK(IN := #SourceArrayBool[0],
COUNT_OUT := #CounterOutput,
OUT => #DestinationArrayWord[2]);

La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceArrayBool[0]

El operando "SourceArrayBool"
es del tipo de datos
ARRAY[0..95] of BOOL. Hay por
tanto 96 elementos BOOL dispo‚Äê
nibles que pueden volver a reco‚Äê
pilarse en palabras.

COUNT_OUT

CounterOutput = 3

UDINT3 (deben escribirse 3 pa‚Äê
labras. Esto significa que en el
ARRAY de origen debe haber 48
bits).

OUT

DestinationArrayWord[2]

El operando "DestinationArray‚Äê
Word" es del tipo de datos
ARRAY[0..5] of WORD. Hay 6
elementos WORD disponibles.

Si el operando #Enable devuelve el estado l√≥gico "1" en la entrada de habilitaci√≥n EN, se
ejecuta la instrucci√≥n. A partir del 1.er elemento del operando #SourceArrayBool se
recomponen 48 bits en el operando #DestinationArrayWord. En el ARRAY de destino se
empieza a partir del 3.er elemento. Esto significa que los primeros 16 bits se escriben en la 3.¬™
palabra, los segundos 16 bits en la 4.¬™ palabra y los terceros 16 bits en la 5.¬™ palabra del
ARRAY de destino. Si ocurre un error durante la ejecuci√≥n de la instrucci√≥n, el operando
#EnableOut devuelve el estado l√≥gico "0" en la salida de habilitaci√≥n ENO.

Ejemplo de ARRAY de origen con el l√≠mite inferior de "-2"
Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceArrayBool

Input

ARRAY[-2..93] of BOOL

CounterOutput

UDINT

DestinationArrayWord

Output

ARRAY[0..5] of WORD

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
GATHER_BLK(IN := #SourceArrayBool[14],
COUNT_OUT := #CounterOutput,
OUT => #DestinationArrayWord[2]);

1882

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceArrayBool[14]

El operando "SourceArrayBool"
es del tipo de datos
ARRAY[-2..93] of BOOL. Dado
que se empieza a partir del 16.¬∫
elemento, hay solo 80 elemen‚Äê
tos BOOL disponibles que pue‚Äê
dan volver a recopilarse en pala‚Äê
bras.

COUNT_OUT

CounterOutput = 3

UDINT3 (deben escribirse 3 pa‚Äê
labras. Esto significa que en el
ARRAY de origen debe haber 48
bits).

OUT

DestinationArrayWord[2]

El operando "DestinationArray‚Äê
Word" es del tipo de datos
ARRAY[0..5] of WORD. Hay 6
elementos WORD disponibles.

Si el operando #Enable devuelve el estado l√≥gico "1" en la entrada de habilitaci√≥n EN, se
ejecuta la instrucci√≥n. A partir del 16.¬∫ elemento del operando #SourceArrayBool se recopilan
48 bits en el operando #DestinationArrayWord. En el ARRAY de destino se empieza a partir del
3.er elemento. Esto significa que los primeros 16 bits del ARRAY de origen no se tienen en
cuenta. Los segundos 16 bits se escriben en la 3.¬™ palabra, los terceros 16 bits en la 4.¬™ palabra
y los cuartos 16 bits en la 5.¬™ palabra del ARRAY de destino. Los 64 bits restantes del ARRAY
de origen tampoco se tienen en cuenta. Si ocurre un error durante la ejecuci√≥n de la
instrucci√≥n, el operando #EnableOut devuelve el estado l√≥gico "0" en la salida de habilitaci√≥n
ENO.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

AssignmentAttempt: Intento de asignaci√≥n de VARIANT a una referencia
Descripci√≥n
La instrucci√≥n "AssignmentAttempt" intenta asignar una variable VARIANT a una variable de
referencia. El tipo de datos de una variable de referencia se define en el momento de la
declaraci√≥n, mientras que el tipo de datos de una variable VARIANT se determina en tiempo
de ejecuci√≥n. En las variables de referencia no est√° permitida la conversi√≥n impl√≠cita del tipo
de datos. Para asignar un tipo de datos al otro se utiliza el intento de asignaci√≥n.
En el intento de asignaci√≥n, se comprueba en tiempo de ejecuci√≥n si la variable VARIANT es
del tipo de datos correcto. Si es as√≠, se ejecuta la asignaci√≥n. Una vez ejecutada
correctamente, en la variable de destino hay una referencia v√°lida; en caso contrario, hay
CERO.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1883

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

SRC

Input

VARIANT

‚óè Interfaz de
bloque de una
FC:
Input, Output,
InOut, Temp

Puntero hacia la
variable origen cu‚Äê
ya direcci√≥n se ha
le√≠do

‚óè Interfaz de
bloque de un
FB:
Input, Output,
Temp
DST

Output

Referencia a:
‚óè Secuencias de
bits, excepto
BOOL,
‚óè Enteros,
‚óè N√∫meros en
coma flotante,
‚óè Cadenas de
caracteres,

‚óè Interfaz de
bloque de una
FC:
Input, Output,
Temp

Referencia a la
que se transfiere
la direcci√≥n de la
variable de origen

‚óè Interfaz de
bloque de un
FB:
Temp

‚óè Tipos de datos
PLC (UDT),
‚óè Tipos de datos
de sistema
(SDT),
‚óè ARRAYs de
los tipos de
datos citados

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Reglas
Para el intento de asignaci√≥n se aplican las siguientes reglas: Las variables VARIANT que no
satisfacen estas reglas devuelven el valor "NULL" en tiempo de ejecuci√≥n.
‚óè VARIANT debe se√±alar a una direcci√≥n de un √°rea de memoria optimizada.
‚óè VARIANT no puede se√±alar a una direcci√≥n de un √°rea de memoria temporal.
‚óè Si desea asignar un VARIANT a una referencia a un ARRAY, se aplican las siguientes
reglas:
‚Äì La variable VARIANT debe se√±alar a un ARRAY cuyos l√≠mites coincidan exactamente
con los de la referencia declarada. Una variable VARIANT que se√±ala a un ARRAY [0..9]
no concuerda con una variable REF_TO ARRAY[1..10].
‚Äì Adem√°s, los bloques que forman el valor de la variable VARIANT deben compilarse una
vez en una CPU de la serie S7-1500, con firmware de la versi√≥n V2.5.

1884

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
En la interfaz del bloque se han declarado la VARIANT "myVariant" y la variable de referencia
"myReference".

En el c√≥digo de programa se intenta asignar "myVariant" a la variable de referencia
"myReference". Si en tiempo de ejecuci√≥n "myVariant" tiene el tipo de datos "Int", en
"myReference" hay una referencia v√°lida a la variable de destino de VARIANT; en caso
contrario, hay CERO. Si la siguiente consulta de si es "NOT_NULL" es verdadera, significa que
la asignaci√≥n se ha efectuado correctamente y se puede escribir el valor "10" en la variable de
destino.

Consulte tambi√©n
Principios b√°sicos de las referencias (P√°gina 310)
Intento de asignaci√≥n de VARIANT a una referencia (P√°gina 325)
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)

SWAP: Cambiar disposici√≥n
Descripci√≥n
La instrucci√≥n "Cambiar disposici√≥n" permite cambiar la disposici√≥n de los bytes de un valor de
entrada y guardar el resultado en el operando indicado.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1885

Instrucciones
4.1 Instrucciones
La figura siguiente muestra c√≥mo se intercambian los bytes de un operando del tipo de datos
DWORD utilizando la instrucci√≥n "Cambiar disposici√≥n":


9DORUGHHQWUDGD

 

 

 

 

 

 


 



 

 

 

 

 

 




 

 

 


 


 



 

 

 






5HVXOWDGR

 



 

 


 



 




 

 

 

 


 


 

 

 





Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros
<Expresi√≥n>

Declaraci√≥n
Input

Valor de funci√≥n

Tipo de datos

√Årea de memo‚Äê Descripci√≥n
ria

S7-1200

S7-1500

WORD,
DWORD

WORD,
DWORD,
LWORD

I, Q, M, D, L, P

Valor de entra‚Äê
da

WORD,
DWORD

WORD,
DWORD,
LWORD

I, Q, M, D, L, P

Resultado de la
instrucci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := SWAP("Tag_Value");

El resultado de la instrucci√≥n se devuelve como valor de funci√≥n.

1886

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

0000 1111 0101 0101

Tag_Result

0101 0101 0000 1111

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

DB ARRAY
ReadFromArrayDB: Leer en un bloque de datos ARRAY
Descripci√≥n
La instrucci√≥n "Leer en un bloque de datos ARRAY" lee el elemento de un bloque de datos del
tipo ARRAY-DB al que hace referencia el √≠ndice y escribe el valor en el √°rea de destino.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el l√≠mite inferior "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

DB

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
lee

INDEX

Input

DINT

I, Q, M, D, L, P

Elemento del DB que se lee.
Puede ser una constante,
una variable global o un valor
indexado.

VALUE

Output 1)

VARIANT

L (puede declarar‚Äê Valor que se lee y se devuel‚Äê
se en las seccio‚Äê
ve
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

INT

I, Q, M, D, L

Valor de funci√≥n (RET_VAL)

Resultado de la instrucci√≥n

1) El par√°metro VALUE est√° declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1887

Instrucciones
4.1 Instrucciones

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
0000

Ning√∫n error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

80B5

La operaci√≥n de copia se ha cancelado.

8132

El bloque de datos no existe, es demasiado corto, est√° protegido contra escritura o est√°
en la memoria de carga.

8135

El bloque de datos de ARRAY contiene valores no v√°lidos.

8154

El bloque de datos es de un tipo incorrecto.

8282

El valor del par√°metro INDEX se encuentra fuera de los valores l√≠mite del ARRAY.

8450

El tipo de datos VARIANT del par√°metro VALUE devuelve el valor "0".

8452

Error de creaci√≥n de c√≥digo

8453

Hay dos posibles causas de error:
‚óè El tama√±o del par√°metro VALUE no coincide con la longitud del elemento en el bloque
de datos ARRAY.
‚óè Ninguna de las dos variables se encuentra en un √°rea de memoria con acceso
optimizado. Encontrar√° m√°s informaci√≥n sobre los tipos de acceso al √°rea de memoria
aqu√≠: Fundamentos del acceso a bloques (P√°gina 54)

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"TagResult" := ReadFromArrayDB(DB := "ArrayDB",
INDEX := 2,
VALUE => "TargetField");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:

1888

Par√°metro

Operando

Valor

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
Array [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

TargetField

El operando "TargetField" es
una variable global del tipo de
datos INT.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El segundo elemento se lee en el "ArrayDB" y se escribe en el operando "TargetField".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Ejemplo de uso de bloques de datos ARRAY (P√°gina 43)
Principios b√°sicos de SCL (P√°gina 8115)

WriteToArrayDB: Escribir en un bloque de datos ARRAY
Descripci√≥n
La instrucci√≥n "Escribir en un bloque de datos ARRAY" escribe el elemento al que hace
referencia el √≠ndice en un bloque de datos del tipo ARRAY-DB.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el l√≠mite inferior "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

DB

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
escribe

INDEX

Input

DINT

I, Q, M, D, L, P

Elemento del DB en el que se
escribe. Puede ser una cons‚Äê
tante, una variable global o
un valor indexado.

VALUE

Input

VARIANT

L (puede declarar‚Äê Valor que se escribe
se en las seccio‚Äê
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

INT

I, Q, M, D, L

Valor de funci√≥n (RET_VAL)

Resultado de la instrucci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1889

Instrucciones
4.1 Instrucciones

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
0000

Ning√∫n error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

80B5

La operaci√≥n de copia se ha cancelado.

8132

El bloque de datos no existe, es demasiado corto o est√° en la memoria de carga.

8134

El bloque de datos est√° protegido contra escritura.

8135

El bloque de datos no es un bloque de datos de ARRAY.

8154

El bloque de datos es de un tipo incorrecto.

8282

El valor del par√°metro INDEX se encuentra fuera de los valores l√≠mite del ARRAY.

8350

El tipo de datos VARIANT del par√°metro VALUE devuelve el valor "0".

8352

Error de creaci√≥n de c√≥digo

8353

Hay dos posibles causas de error:
‚óè El tama√±o del par√°metro VALUE no coincide con la longitud del elemento en el bloque
de datos ARRAY.
‚óè Ninguna de las dos variables se encuentra en un √°rea de memoria con acceso
optimizado. Encontrar√° m√°s informaci√≥n sobre los tipos de acceso al √°rea de memoria
aqu√≠: Fundamentos del acceso a bloques (P√°gina 54)

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"TagResult" := WriteToArrayDB(DB := "ArrayDB",
INDEX := 2,
VALUE := "SourceField");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:

1890

Par√°metro

Operando

Valor

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
Array [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

SourceField

El operando "SourceField" es
una variable global del tipo de
datos INT.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El valor del operando "SourceField" se escribe en el segundo elemento del DB de ARRAY.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Ejemplo de uso de bloques de datos ARRAY (P√°gina 43)
Principios b√°sicos de SCL (P√°gina 8115)

ReadFromArrayDBL: Leer en un bloque de datos ARRAY de la memoria de carga
Descripci√≥n
La instrucci√≥n "Leer en un bloque de datos ARRAY de la memoria de carga" lee el elemento
de un bloque de datos del tipo ARRAY-DB de la memoria de carga al que hace referencia el
√≠ndice y lo escribe en el √°rea de destino.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el l√≠mite inferior "0".
Si el bloque de datos ARRAY se ha marcado con el atributo de bloque "Depositar s√≥lo en la
memoria de carga", se guarda √∫nicamente en la memoria de carga.
Si en el par√°metro REQ se detecta un flanco de se√±al ascendente, se ejecuta la instrucci√≥n.
El par√°metro BUSY devuelve el estado l√≥gico "1". Si en el par√°metro BUSY se detecta un
flanco de se√±al descendente, finaliza la instrucci√≥n. Durante un ciclo del programa, el
par√°metro DONE tiene el estado l√≥gico "1" y durante este ciclo se emite el valor le√≠do en el
par√°metro VALUE. En los dem√°s ciclos del programa, el valor del par√°metro VALUE no se
modifica.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

REQ

Input

BOOL

I, Q, M, D, L

REQ = "1": Comenzar la lec‚Äê
tura del DB de array

DB 1)

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
lee

INDEX

Input

DINT

I, Q, M, D, L, P

Elemento del DB que se lee.
Puede ser una constante,
una variable global o un valor
indexado.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1891

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

VALUE 1)

InOut

VARIANT

D (elemento de un
bloque de datos
global)

Puntero al bloque de datos
de la memoria de trabajo que
se lee y cuyo valor se escribe.

L (puede declarar‚Äê No est√° permitido utilizar
constantes locales o varia‚Äê
se en las seccio‚Äê
bles de la secci√≥n TEMP.
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)
BUSY

Output

BOOL

I, Q, M, D, L

BUSY = "1": La lectura del
DB de array todav√≠a no ha fi‚Äê
nalizado

DONE

Output

BOOL

I, Q, M, D, L

DONE = "1": La instrucci√≥n
se ha ejecutado correcta‚Äê
mente

ERROR

Output

INT

I, Q, M, D, L

Informaci√≥n de error:
El par√°metro ERROR devuel‚Äê
ve un c√≥digo de error cuando
ocurre un error durante la eje‚Äê
cuci√≥n de la instrucci√≥n.

1)

Los bloques de datos deben crearse con la propiedad de bloque "Optimizado".

Par√°metro ERROR
La tabla siguiente muestra el significado de los valores del par√°metro ERROR:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
0000

Ning√∫n error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8230

El n√∫mero del bloque de datos es incorrecto.

8231

El bloque de datos no existe.

8232

El bloque de datos es demasiado corto o no est√° en la memoria de carga.

8235

El bloque de datos no es un DB de ARRAY.

8254

El bloque de datos es de un tipo incorrecto.

8382

El valor del par√°metro INDEX se encuentra fuera de los valores l√≠mite del ARRAY.

8750

El tipo de datos VARIANT del par√°metro VALUE devuelve el valor "0".

8751

Error de creaci√≥n de c√≥digo

8752

Error de creaci√≥n de c√≥digo

8753

El tama√±o del par√°metro VALUE no coincide con la longitud del elemento en el bloque de
datos ARRAY.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

1892

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrar√° la descripci√≥n de los c√≥digos de error activados por las instrucciones "READ_DBL"
y "WRIT_DBL" en las descripciones de las instrucciones correspondientes.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"ReadFromArrayDBL_DB"(REQ := "TagReg",
DB := "ArrayDB",
INDEX := 2,
VALUE := "TargetField",
BUSY => "TagBusy",
DONE => "TagDone",
ERROR => "TagError");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

REQ

TagReq

BOOL

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
ARRAY [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

TargetField

El operando "TargetField" es
una variable global del tipo de
datos INT.

BUSY

TagBusy

BOOL

DONE

TagDone

BOOL

Si en el operando "TagReq" se detecta un flanco de se√±al ascendente, se ejecuta la
instrucci√≥n. El segundo elemento se lee en el "ArrayDB" y se devuelve en el par√°metro
"VALUE". En cuanto se detecta un flanco de se√±al descendente en el operando "TagBusy",
finaliza la instrucci√≥n y el valor del par√°metro VALUE ya no se modifica. Despu√©s de ejecutar
la instrucci√≥n, el operando "TagDone" tiene el estado l√≥gico TRUE.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
READ_DBL: Leer de un bloque de datos de la memoria de carga (P√°gina 2919)
WRIT_DBL: Escribir en un bloque de datos de la memoria de carga (P√°gina 2923)
Ejemplo de uso de bloques de datos ARRAY (P√°gina 43)
Diferencia entre las instrucciones que funcionan s√≠ncronamente y las que funcionan
as√≠ncronamente (P√°gina 618)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1893

Instrucciones
4.1 Instrucciones

WriteToArrayDBL: Escribir en un bloque de datos ARRAY de la memoria de carga
Descripci√≥n
La instrucci√≥n "Escribir en un bloque de datos ARRAY de la memoria de carga" escribe el
elemento al que hace referencia el √≠ndice en un bloque de datos del tipo ARRAY-DB de la
memoria de carga.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el l√≠mite inferior "0".
Si el bloque de datos ARRAY se ha marcado con el atributo de bloque "Depositar s√≥lo en la
memoria de carga", se guarda √∫nicamente en la memoria de carga.
Si en el par√°metro REQ se detecta un flanco de se√±al ascendente, se ejecuta la instrucci√≥n.
El par√°metro BUSY devuelve el estado l√≥gico "1". Si en el par√°metro BUSY se detecta un
flanco de se√±al descendente, finaliza la instrucci√≥n y el valor del par√°metro VALUE se escribe
en el bloque de datos. Durante un ciclo del programa, el par√°metro DONE tiene el estado
l√≥gico "1".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

REQ

Input

BOOL

I, Q, M, D, L

REQ = "1": Comenzar a es‚Äê
cribir en el DB de array

DB 1)

Input

DB_ANY

I, Q, M, D, L

Bloque de datos ARRAY en
el que se escribe

INDEX

Input

DINT

I, Q, M, D, L, P

Elemento del DB en el que se
escribe. Puede ser una cons‚Äê
tante, una variable global o
un valor indexado.

VALUE 1)

Input

VARIANT

D (elemento de un
bloque de datos
global)

Puntero al bloque de datos
de la memoria de trabajo que
se lee y cuyo valor se escribe.

L (puede declarar‚Äê No est√° permitido utilizar
constantes locales o varia‚Äê
se en las seccio‚Äê
bles de la secci√≥n TEMP.
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

1894

BUSY

Output

BOOL

I, Q, M, D, L

BUSY = "1": Todav√≠a no se
ha terminado de escribir en el
DB de array

DONE

Output

BOOL

I, Q, M, D, L

DONE = "1": La instrucci√≥n
se ha ejecutado correcta‚Äê
mente

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

ERROR

Output

INT

I, Q, M, D, L

Informaci√≥n de error:
El par√°metro ERROR devuel‚Äê
ve un c√≥digo de error cuando
ocurre un error durante la eje‚Äê
cuci√≥n de la instrucci√≥n.

1)

Los bloques de datos deben crearse con la propiedad de bloque "Optimizado".

Par√°metro ERROR
La tabla siguiente muestra el significado de los valores del par√°metro ERROR:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
0000

Ning√∫n error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8230

El n√∫mero del bloque de datos es incorrecto.

8231

El bloque de datos no existe.

8232

El bloque de datos es demasiado corto o no est√° en la memoria de carga.

8234

El bloque de datos est√° protegido contra escritura.

8235

El bloque de datos no es un DB de ARRAY.

8254

El bloque de datos es de un tipo incorrecto.

8382

El valor del par√°metro INDEX se encuentra fuera de los valores l√≠mite del ARRAY.

8450

El tipo de datos VARIANT del par√°metro VALUE devuelve el valor "0".

8751

Error de creaci√≥n de c√≥digo

8752

Error de creaci√≥n de c√≥digo

8753

El tama√±o del par√°metro VALUE no coincide con la longitud del elemento en el bloque de
datos ARRAY.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Encontrar√° la descripci√≥n de los c√≥digos de error activados por las instrucciones "READ_DBL"
y "WRIT_DBL" en las descripciones de las instrucciones correspondientes.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"WriteToArrayDBL_DB"(REQ := "TagReg",
DB := "ArrayDB",
INDEX := 2,
VALUE := "SourceField",
BUSY => "TagBusy",
DONE => "TagDone",

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1895

Instrucciones
4.1 Instrucciones
SCL
ERROR => "TagError");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

REQ

TagReq

BOOL

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
ARRAY [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

SourceField

El operando "SourceField" es
una variable global del tipo de
datos INT.

BUSY

TagBusy

BOOL

DONE

TagDone

BOOL

Si en el operando "TagReq" se detecta un flanco de se√±al ascendente, se ejecuta la
instrucci√≥n. En cuanto se detecta un flanco descendente en el operando "TagBusy", la
instrucci√≥n finaliza y el valor del par√°metro VALUE se escribe en el segundo elemento del
"ArrayDB". Despu√©s de ejecutar la instrucci√≥n, el operando "TagDone" tiene el estado l√≥gico
TRUE.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
READ_DBL: Leer de un bloque de datos de la memoria de carga (P√°gina 2919)
WRIT_DBL: Escribir en un bloque de datos de la memoria de carga (P√°gina 2923)
Ejemplo de uso de bloques de datos ARRAY (P√°gina 43)
Diferencia entre las instrucciones que funcionan s√≠ncronamente y las que funcionan
as√≠ncronamente (P√°gina 618)
Principios b√°sicos de SCL (P√°gina 8115)

Acceso de lectura/escritura
PEEK: Leer direcci√≥n de memoria
Descripci√≥n
La instrucci√≥n "Leer direcci√≥n de memoria" permite leer una direcci√≥n de memoria de un √°rea
de memoria est√°ndar sin indicar un tipo de datos.
Para modificar el tipo de datos de la instrucci√≥n, utilice la sintaxis siguiente:
PEEK_<tipo de datos>();

1896

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Uso del √°rea de memoria 16#84: DB
Si como √°rea de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
c√≥digo del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso:
SCL
#Peeker := PEEK(AREA := 16#84,
DBNUMBER := 1,
BYTEOFFSET := 2,
ENO => ENO);
IF NOT ENO THEN;
#Peeker := 16#ffff;
END_IF;

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declara‚Äê
ci√≥n

Tipo de datos √Årea de memo‚Äê
ria

Descripci√≥n

AREA

Input

BYTE

Pueden seleccionarse las siguientes
√°reas:

I, Q, M, D

‚óè 16#81: Input
‚óè 16#82: Output
‚óè 16#83: Marcas
‚óè 16#84: DB
‚óè 16#1: Entrada de periferia (solo
S7-1500)
DBNUM‚Äê
BER

Input

DINT,
DB_ANY

D

BYTEOFF‚Äê
SET

Input

DINT

I, Q, M, D

_<tipo de datos>

N√∫mero del bloque de datos si AREA =
DB, de lo contrario "0"
Direcci√≥n en la que se lee
Solo se utilizan los 16 bits menos signi‚Äê
ficativos.

Secuencias
de bits
Valor prede‚Äê
terminado:
BYTE

-

Tipo de datos del valor de funci√≥n:
1. El tipo de datos de la instrucci√≥n se
puede indicar expl√≠citamente con "_".
2. Si el tipo de datos no se indica
expl√≠citamente, se determinar√° a
partir de las variables utilizadas o de
las constantes con tipos.
3. Si el tipo de datos no se indica
expl√≠citamente ni se indican
variables definidas ni constantes con
tipo, se utilizar√° el tipo de datos
predeterminado.

Valor de funci√≥n

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Secuencias
de bits

I, Q, M, D

Resultado de la instrucci√≥n

1897

Instrucciones
4.1 Instrucciones

Nota
Si se lee la direcci√≥n de memoria en las √°reas Input, Output o Marcas, se debe suministrar el
valor "0" al par√°metro DBNUMBER, ya que de lo contrario la instrucci√≥n ser√° err√≥nea.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result1" := PEEK(AREA := "Tag_Area",
DBNUMBER := "Tag_DBNumber",
BYTEOFFSET := "Tag_Byte");

SCL
"Tag_Result2" := PEEK_WORD(AREA := "Tag_Area",
DBNUMBER := "Tag_DBNumber",
BYTEOFFSET := "Tag_Byte");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

AREA

Tag_Area

16#84

DBNUMBER

Tag_DBNumber

5

BYTEOFFSET

Tag_Byte

20

Valor de funci√≥n

Tag_Result1

Valor del byte "20"

Valor de funci√≥n

Tag_Result2

Valor de la palabra "20"

La instrucci√≥n lee el valor de la direcci√≥n "20" del operando "Tag_Byte" del bloque de datos "5"
y devuelve el resultado como valor de la funci√≥n en el operando "Tag_Result".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

PEEK_BOOL: Leer bit de memoria
Descripci√≥n
La instrucci√≥n "Leer bit de memoria" permite leer un bit de memoria de un √°rea de memoria
est√°ndar sin indicar un tipo de datos.

1898

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Uso del √°rea de memoria 16#84: DB
Si como √°rea de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
c√≥digo del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso:
SCL
#Peeker_BOOL := PEEK_BOOL(AREA := 16#84,
DBNUMBER := 1,
BYTEOFFSET := 2,
BITOFFSET := 1,
ENO => ENO);
IF NOT ENO THEN;
#Peeker_BOOL := 0;
END_IF;

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memo‚Äê
ria

Descripci√≥n

AREA

Input

BYTE

I, Q, M, D

Pueden seleccionarse las siguientes
√°reas:
‚óè 16#81: Input
‚óè 16#82: Output
‚óè 16#83: Marcas
‚óè 16#84: DB
‚óè 16#1: Entrada de periferia (solo
S7-1500)

DBNUM‚Äê
BER

Input

DINT,
DB_ANY

D

N√∫mero del bloque de datos si AREA
= DB, de lo contrario "0"

BYTEOFF‚Äê
SET

Input

DINT

I, Q, M, D

Direcci√≥n en la que se lee
Solo se utilizan los 16 bits menos sig‚Äê
nificativos.

BITOFFSET Input

INT

I, Q, M, D

Bit en el que se lee

Valor de funci√≥n

BOOL

I, Q, M, D

Resultado de la instrucci√≥n

Nota
Si se lee el bit de memoria en las √°reas Input, Output o Marcas, se debe suministrar el valor "0"
al par√°metro DBNUMBER, ya que de lo contrario la instrucci√≥n ser√° err√≥nea.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1899

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := PEEK_BOOL(AREA := "Tag_Area",
DBNUMBER := "Tag_DBNumber",
BYTEOFFSET := "Tag_Byte",
BITOFFSET := "Tag_Bit");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

AREA

Tag_Area

16#84

DBNUMBER

Tag_DBNumber

5

BYTEOFFSET

Tag_Byte

20

BITOFFSET

Tag_Bit

3

Valor de funci√≥n

Tag_Result

3

La instrucci√≥n lee el valor del bit de memoria "3" del operando "Tag_Bit" del bloque de datos
"5" del byte "20" y devuelve el resultado como valor de funci√≥n en el operando "Tag_Result".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

POKE: Escribir direcci√≥n de memoria
Descripci√≥n
La instrucci√≥n "Escribir direcci√≥n de memoria" permite escribir una direcci√≥n de memoria en un
√°rea de memoria est√°ndar sin indicar un tipo de datos.

Uso del √°rea de memoria 16#84: DB
Si como √°rea de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
c√≥digo del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso:
SCL
POKE(AREA := 16#84,
DBNUMBER := 1,
BYTEOFFSET := 2,
VALUE := BYTE#7,
ENO => ENO);

1900

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros Declaraci√≥n

Tipo de datos √Årea de memo‚Äê
ria

Descripci√≥n

AREA

BYTE

Pueden seleccionarse las siguientes
√°reas:

Input

I, Q, M, D

‚óè 16#81: Input
‚óè 16#82: Output
‚óè 16#83: Marcas
‚óè 16#84: DB
‚óè 16#2: Salida de periferia (solo
S7-1500)
DBNUM‚Äê
BER

Input

DINT,
DB_ANY

D

BYTEOFF‚Äê
SET

Input

DINT

I, Q, M, D

VALUE

Input

N√∫mero del bloque de datos si AREA =
DB, de lo contrario "0"
Direcci√≥n que se escribe
Solo se utilizan los 16 bits menos signi‚Äê
ficativos.

Secuencias
de bits

I, Q, M, D

Valor que se escribe

Nota
Si se escribe la direcci√≥n de memoria en las √°reas Input, Output o Marcas, se debe suministrar
el valor "0" al par√°metro DBNUMBER, ya que de lo contrario la instrucci√≥n ser√° err√≥nea.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
POKE(AREA := "Tag_Area",
DBNUMBER := "Tag_DBNumber",
BYTEOFFSET := "Tag_Byte",
VALUE := "Tag_Value");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operando
concretos:
Par√°metro

Operando

Valor

AREA

Tag_Area

16#84

DBNUMBER

Tag_DBNumber

5

BYTEOFFSET

Tag_Byte

20

VALUE

Tag_Value

16#11

La instrucci√≥n sobrescribe la direcci√≥n de memoria "20" en el bloque de datos "5" con el valor
"16#11".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1901

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

POKE_BOOL: Escribir bit de memoria
Descripci√≥n
La instrucci√≥n "Escribir bit de memoria" permite escribir un bit de memoria en un √°rea de
memoria est√°ndar sin indicar un tipo de datos.

Uso del √°rea de memoria 16#84: DB
Si como √°rea de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
c√≥digo del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso:
SCL
POKE(AREA := 16#84,
DBNUMBER := 1,
BYTEOFFSET := 2,
BITOFFSET := 4,
VALUE := TRUE,
ENO => ENO);

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declara‚Äê
ci√≥n

Tipo de da‚Äê
tos

√Årea de memo‚Äê Descripci√≥n
ria

AREA

Input

BYTE

I, Q, M, D

Pueden seleccionarse las siguientes
√°reas:
‚óè 16#81: Input
‚óè 16#82: Output
‚óè 16#83: Marcas
‚óè 16#84: DB
‚óè 16#2: Salida de periferia (solo
S7-1500)

1902

DBNUM‚Äê
BER

Input

DINT,
DB_ANY

D

BYTEOFF‚Äê
SET

Input

DINT

I, Q, M, D

N√∫mero del bloque de datos si AREA =
DB, de lo contrario "0"
Direcci√≥n que se escribe
Solo se utilizan los 16 bits menos signifi‚Äê
cativos.

BITOFFSET Input

INT

I, Q, M, D

Bit que se escribe

VALUE

BOOL

I, Q, M, D

Valor que se escribe

Input

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Nota
Si se escribe el bit de memoria en las √°reas Input, Output o Marcas, se debe suministrar el valor
"0" al par√°metro DBNUMBER, ya que de lo contrario la instrucci√≥n ser√° err√≥nea.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
POKE_BOOL(AREA := "Tag_Area",
DBNUMBER := "Tag_DBNumber",
BYTEOFFSET := "Tag_Byte",
BITOFFSET := "Tag_Bit",
VALUE := "Tag_Value");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

AREA

Tag_Area

16#84

DBNUMBER

Tag_DBNumber

5

BYTEOFFSET

Tag_Byte

20

BITOFFSET

Tag_Bit

3

VALUE

Tag_Value

M0.0

La instrucci√≥n sobrescribe el bit de memoria "3" en el bloque de datos "5" en el byte "20" con
el valor "M0.0".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

POKE_BLK: Escribir √°rea de memoria
Descripci√≥n
La instrucci√≥n "Escribir √°rea de memoria" permite escribir un √°rea de memoria en un √°rea de
memoria est√°ndar diferente sin indicar un tipo de datos.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1903

Instrucciones
4.1 Instrucciones

Uso del √°rea de memoria 16#84: DB
Si como √°rea de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
c√≥digo del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso:
SCL
POKE_BLK(AREA_SRC := 16#84,
DBNUMBER_SRC := 1,
BYTEOFFSET_SRC := 2,
AREA_DEST := 16#84,
DBNUMBER_DEST := 11,
BYTEOFFSET_DEST := 22,
COUNT := 3,
ENO => ENO);

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declara‚Äê
ci√≥n

Tipo de da‚Äê
tos

√Årea de memo‚Äê Descripci√≥n
ria

AREA_SRC

Input

BYTE

I, Q, M, D

Las siguientes √°reas pueden se‚Äê
leccionarse en el √°rea de memoria
de origen:
‚óè 16#81: Input
‚óè 16#82: Output
‚óè 16#83: Marcas
‚óè 16#84: DB

DBNUMBER_SRC

Input

DINT,
DB_ANY 1)

D

N√∫mero del bloque de datos en el
√°rea de memoria de origen, si
AREA = DB, de lo contrario "0"

BYTEOFF‚Äê
SET_SRC

Input

DINT

I, Q, M, D

Direcci√≥n en el √°rea de memoria
de origen, en la que se escribe
Solo se utilizan los 16 bits menos
significativos.

AREA_DEST

Input

BYTE

I, Q, M, D

Las siguientes √°reas pueden se‚Äê
leccionarse en el √°rea de memoria
de destino:
‚óè 16#81: Input
‚óè 16#82: Output
‚óè 16#83: Marcas
‚óè 16#84: DB

DBNUM‚Äê
BER_DEST

1904

Input

DINT,
DB_ANY 1)

D

N√∫mero del bloque de datos en el
√°rea de memoria de destino, si
AREA = DB, de lo contrario "0"

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metros

Declara‚Äê
ci√≥n

Tipo de da‚Äê
tos

√Årea de memo‚Äê Descripci√≥n
ria

BYTEOFF‚Äê
SET_DEST

Input

DINT

I, Q, M, D

Direcci√≥n en el √°rea de memoria
de destino, en la que se escribe
Solo se utilizan los 16 bits menos
significativos.

COUNT

Input

DINT

I, Q, M, D

N√∫mero de bytes que se copian

Los tipos de datos de los par√°metros DBNUMBER_SRC y DBNUMBER_DEST deben ser id√©nticos.
Es decir, las dos variables deben ser bien del tipo de datos DINT bien del tipo de datos DB_ANY.

1)

Nota
Si se escribe la direcci√≥n de memoria en las √°reas Input, Output o Marcas, se debe suministrar
el valor "0" al par√°metro DBNUMBER, ya que de lo contrario la instrucci√≥n ser√° err√≥nea.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
POKE_BLK(AREA_SRC := "Tag_Source_Area",
DBNUMBER_SRC := "Tag_Source_DBNumber",
BYTEOFFSET_SRC := "Tag_Source_Byte"),
AREA_DEST := "Tag_Destination_Area",
DBNUMBER_DEST := "Tag_Destination_DBNumber",
BYTEOFFSET_DEST := "Tag_Destination_Byte",
COUNT := "Tag_Count");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

AREA_SRC

Tag_Source_Area

16#84

DBNUMBER_SRC

Tag_Source_DBNumber

5

BYTEOFFSET_SRC

Tag_Source_Byte

20

AREA_DEST

Tag_Destination_Area

16#83

DBNUMBER_DEST

Tag_Destination_DBNumber

0

BYTEOFFSET_DEST

Tag_Destination_Byte

30

COUNT

Tag_Count

100

La instrucci√≥n escribe 100 bytes del bloque de datos "5" comenzando por la direcci√≥n "20" en
el √°rea de memoria Marcas comenzado por la direcci√≥n "30".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1905

Instrucciones
4.1 Instrucciones

READ_LITTLE: Leer datos en formato Little-Endian
Descripci√≥n
La instrucci√≥n "Leer datos en formato Little-Endian" permite leer datos de un √°rea de memoria
y escribirlos en una √∫nica variable en el orden de bytes Little-Endian. En el formato LittleEndian, primero se guarda el byte con los bits menos significativos, es decir, en la direcci√≥n de
memoria m√°s baja.
Los par√°metros SRC_ARRAY y DEST_VARIABLE son del tipo de datos VARIANT. No
obstante, hay algunas restricciones en cuanto al tipo de datos con el que pueden
interconectarse los par√°metros. El VARIANT del par√°metro DEST_VARIABLE debe apuntar a
un tipo de datos simple. El VARIANT del par√°metro SRC_ARRAY apunta a un √°rea de
memoria que se lee, y debe ser un ARRAY of BYTE.
En los par√°metros SRC_ARRAY y DEST_VARIABLE tambi√©n es posible utilizar un par√°metro
actual con un √≠ndice de ARRAY variable.
El operando del par√°metro POS determina la posici√≥n del √°rea de memoria en la que se inicia
la lectura.
Nota
Leer variable del tipo de datos VARIANT o BOOL
Para leer una variable a la que apunta un VARIANT se pueden utilizar las instrucciones
"Serializar" o "Deserializar".
Para leer una variable del tipo de datos BOOL se puede utilizar un "acceso slice".

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200 a
S7-1500
partir de V4.0

1906

√Årea de me‚Äê Descripci√≥n
moria

SRC_ARRA
Y

Input

ARRAY of
BYTE

ARRAY of
BYTE

I, Q, M, D, L

√Årea de memoria de la
que se lee

DEST_VA‚Äê
RIABLE

Output

Secuencias
de bits, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, TOD,
DATE,
CHAR,
WCHAR

Secuencias
de bits, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, LDT,
TOD, LTOD,
DATE,
CHAR,
WCHAR

I, Q, M, D, L

Valor le√≠do

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200 a
S7-1500
partir de V4.0

POS

InOut

Valor de funci√≥n (RET_VAL)

√Årea de me‚Äê Descripci√≥n
moria

DINT

DINT

I, Q, M, D, L

Determina la posici√≥n
en la que se inicia la lec‚Äê
tura. El par√°metro POS
se calcula basado en ce‚Äê
ro.

INT

INT

I, Q, M, D, L

Informaci√≥n de error

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

80B4

El tipo de datos del par√°metro SRC_ARRAY no es un ARRAY of BYTE.

8382

El valor del par√°metro POS se encuentra fuera de los valores l√≠mite del ARRAY.

8383

El valor del par√°metro POS se encuentra dentro de los valores l√≠mite del ARRAY, pero el
tama√±o del √°rea de memoria excede el l√≠mite superior del ARRAY.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
#TagResult := READ_LITTLE(SRC_ARRAY := #SourceField,
DEST_VARIABLE => #DINTVariable,
POS := #TagPos);

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

SRC_ARRAY

#SourceField

ARRAY[0..3] of BYTE
:= 16#1A, 16#2B, 16#3C, 16#4D

DEST_VARIABLE

#DINTVariable

1295788826
16#4D3C2B1A

POS

#TagPos

0 => 4

La instrucci√≥n lee el entero 1_295_788_826 del √°rea de memoria "#SourceField" y lo escribe
en formato Little-Endian en el operando #DINTVariable. El tipo de datos del par√°metro
DEST_VARIABLE indica cu√°ntos bytes se leen. En el operando #TagPos se guarda el n√∫mero
4.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1907

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Deserialize: Deserializar (P√°gina 1844)
Serialize: Serializar (P√°gina 1849)
Direccionar √°reas de una variable con accesos Slice (P√°gina 116)
Principios b√°sicos de SCL (P√°gina 8115)

WRITE_LITTLE: Escribir datos en formato Little-Endian
Descripci√≥n
La instrucci√≥n "Escribir datos en formato Little-Endian" permite escribir los datos de una √∫nica
variable de la orden de bytes Little-Endian en un √°rea de memoria. En el formato Little-Endian,
primero se guarda el byte con los bits menos significativos, es decir, en la direcci√≥n de memoria
m√°s baja.
Los par√°metros SRC_VARIABLE y DEST_ARRAY son del tipo de datos VARIANT. No
obstante, hay algunas restricciones en cuanto al tipo de datos con el que pueden
interconectarse los par√°metros. El VARIANT del par√°metro SRC_VARIABLE debe apuntar a
un tipo de datos simple. El VARIANT del par√°metro DEST_ARRAY apunta a un √°rea de
memoria en la que se escriben los datos, y debe ser un ARRAY of BYTE.
En los par√°metros SRC_ARRAY y DEST_VARIABLE tambi√©n es posible utilizar un par√°metro
actual con un √≠ndice de ARRAY variable.
El operando del par√°metro POS determina la posici√≥n del √°rea de memoria en la que se inicia
la escritura.
Nota
Escribir variable del tipo de datos VARIANT o BOOL
Para escribir una variable a la que apunta un VARIANT se pueden utilizar las instrucciones
"Serializar" o "Deserializar".
Para escribir una variable del tipo de datos BOOL se puede utilizar un "acceso slice".

1908

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de me‚Äê Descripci√≥n
moria

S7-1200 a
partir de
V4.0

S7-1500

SRC_VARIA‚Äê Input
BLE

Secuencias
de bits, ente‚Äê
ros, n√∫me‚Äê
ros en coma
flotante,
TOD, DATE,
CHAR,
WCHAR

Secuencias de
bits, enteros,
n√∫meros en
coma flotante,
LDT, TOD,
LTOD, DATE,
CHAR,
WCHAR

I, Q, M, D, L Variable cuyos datos se
escriben

DEST_ARRA InOut
Y

ARRAY of
BYTE

ARRAY of
BYTE

I, Q, M, D, L √Årea de memoria en la
que se escriben los da‚Äê
tos

POS

DINT

DINT

I, Q, M, D, L Determina la posici√≥n
en la que se inicia la es‚Äê
critura. El par√°metro
POS se calcula basado
en cero.

INT

INT

I, Q, M, D, L Informaci√≥n de error

InOut

Valor de funci√≥n (RET_VAL)

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

80B4

El tipo de datos del par√°metro SRC_ARRAY no es un ARRAY of BYTE.

8382

El valor del par√°metro POS se encuentra fuera de los valores l√≠mite del ARRAY.

8383

El valor del par√°metro POS se encuentra dentro de los valores l√≠mite del ARRAY, pero el
tama√±o del √°rea de memoria excede el l√≠mite superior del ARRAY.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
#TagResult := WRITE_LITTLE(SRC_VARIABLE := #DINTVariable,
DEST_ARRAY := #TargetField,
POS := #TagPos);

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1909

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

SRC_VARIABLE

#DINTVariable

1295788826

DEST_ARRAY

#TargetField

ARRAY[0..10] of BYTE

POS

#TagPos

0 => 4

16#4D3C2B1A
= 16#1A, 16#2B, 16#3C, 16#4D

La instrucci√≥n escribe el entero 1_295_788_826 del operando #DINTVariable en formato Little
Endian en el √°rea de memoria #TargetField. El tipo de datos del par√°metro SRC_VARIABLE
indica cu√°ntos bytes se escriben. En el operando #TagPos se guarda el n√∫mero 4.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Deserialize: Deserializar (P√°gina 1844)
Serialize: Serializar (P√°gina 1849)
Direccionar √°reas de una variable con accesos Slice (P√°gina 116)
Principios b√°sicos de SCL (P√°gina 8115)

READ_BIG: Leer datos en formato Big-Endian
Descripci√≥n
La instrucci√≥n "Leer datos en formato Big-Endian" permite leer datos de un √°rea de memoria
y escribirlos en una √∫nica variable en el orden de bytes Big-Endian. En el formato Big-Endian,
primero se guarda el byte con los bits m√°s significativos, es decir, en la direcci√≥n de memoria
m√°s baja.
Los par√°metros SRC_ARRAY y DEST_VARIABLE son del tipo de datos VARIANT. No
obstante, hay algunas restricciones en cuanto al tipo de datos con el que pueden
interconectarse los par√°metros. El VARIANT del par√°metro DEST_VARIABLE debe apuntar a
un tipo de datos simple. El VARIANT del par√°metro SRC_ARRAY apunta a un √°rea de
memoria que se lee, y debe ser un ARRAY of BYTE.
En los par√°metros SRC_ARRAY y DEST_VARIABLE tambi√©n es posible utilizar un par√°metro
actual con un √≠ndice de ARRAY variable.

1910

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El operando del par√°metro POS determina la posici√≥n del √°rea de memoria en la que se inicia
la lectura.
Nota
Leer variable del tipo de datos VARIANT o BOOL
Para leer una variable a la que apunta un VARIANT se pueden utilizar las instrucciones
"Serializar" o "Deserializar".
Para leer una variable del tipo de datos BOOL se puede utilizar un "acceso slice".

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

S7-1200 a
partir de V4.0

Tipo de datos
S7-1500

√Årea de
memoria

Descripci√≥n

SRC_ARRA
Y

Input

ARRAY of
BYTE

ARRAY of
BYTE

I, Q, M, D, L √Årea de memoria de la
que se lee

DEST_VA‚Äê
RIABLE

Output

Secuencias
de bits, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, TOD,
DATE,
CHAR,
WCHAR

Secuencias
de bits, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, LDT,
TOD, LTOD,
DATE,
CHAR,
WCHAR

I, Q, M, D, L Valor le√≠do

POS

InOut

DINT

DINT

I, Q, M, D, L Determina la posici√≥n en
la que se inicia la lectura.
El par√°metro POS se cal‚Äê
cula basado en cero.

INT

INT

I, Q, M, D, L Informaci√≥n de error

Valor de funci√≥n (RET_VAL)

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

80B4

El tipo de datos del par√°metro SRC_ARRAY no es un ARRAY of BYTE.

8382

El valor del par√°metro POS se encuentra fuera de los valores l√≠mite del ARRAY.

8383

El valor del par√°metro POS se encuentra dentro de los valores l√≠mite del ARRAY, pero el
tama√±o del √°rea de memoria excede el l√≠mite superior del ARRAY.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1911

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
#TagResult := READ_BIG(SRC_ARRAY := #SourceField,
DEST_VARIABLE => #DINTVariable,
POS := #TagPos);

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

SRC_ARRAY

#SourceField

ARRAY[0..10] of BYTE
:= 16#1A, 16#2B, 16#3C, 16#4D

DEST_VARIABLE

#DINTVariable

439041101
16#1A2B3C4D

POS

#TagPos

0 => 4

La instrucci√≥n lee el entero 439_041_101 del √°rea de memoria "#SourceField" y lo escribe en
formato Big-Endian en el operando #DINTVariable. El tipo de datos del par√°metro
DEST_VARIABLE indica cu√°ntos bytes se leen. En el operando #TagPos se guarda el n√∫mero
4.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Deserialize: Deserializar (P√°gina 1844)
Serialize: Serializar (P√°gina 1849)
Direccionar √°reas de una variable con accesos Slice (P√°gina 116)
Principios b√°sicos de SCL (P√°gina 8115)

WRITE_BIG: Escribir datos en formato Big-Endian
Descripci√≥n
La instrucci√≥n "Escribir datos en formato Big-Endian" permite escribir los datos de una √∫nica
variable de la orden de bytes Big-Endian en un √°rea de memoria. En el formato Big-Endian,
primero se guarda el byte con los bits m√°s significativos, es decir, en la direcci√≥n de memoria
m√°s baja.
Los par√°metros SRC_VARIABLE y DEST_ARRAY son del tipo de datos VARIANT. No
obstante, hay algunas restricciones en cuanto al tipo de datos con el que pueden
interconectarse los par√°metros. El VARIANT del par√°metro SRC_VARIABLE debe apuntar a
un tipo de datos simple. El VARIANT del par√°metro DEST_ARRAY apunta a un √°rea de
memoria en la que se escriben los datos, y debe ser un ARRAY of BYTE.
En los par√°metros SRC_ARRAY y DEST_VARIABLE tambi√©n es posible utilizar un par√°metro
actual con un √≠ndice de ARRAY variable.

1912

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El operando del par√°metro POS determina la posici√≥n del √°rea de memoria en la que se inicia
la escritura.
Nota
Escribir variable del tipo de datos VARIANT o BOOL
Para escribir una variable a la que apunta un VARIANT se pueden utilizar las instrucciones
"Serializar" o "Deserializar".
Para escribir una variable del tipo de datos BOOL se puede utilizar un "acceso slice".

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200 a
S7-1500
partir de V4.0

√Årea de me‚Äê Descripci√≥n
moria

SRC_VARIA‚Äê Input
BLE

Secuencias
de bits, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, TOD,
DATE,
CHAR,
WCHAR

Secuencias
de bits, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, LDT,
TOD, LTOD,
DATE,
CHAR,
WCHAR

I, Q, M, D, L Variable cuyos datos se
escriben

DEST_ARRA InOut
Y

ARRAY of
BYTE

ARRAY of
BYTE

I, Q, M, D, L √Årea de memoria en la
que se escriben los datos

POS

DINT

DINT

I, Q, M, D, L Determina la posici√≥n en
la que se inicia la escri‚Äê
tura. El par√°metro POS
se calcula basado en ce‚Äê
ro.

INT

INT

I, Q, M, D, L Informaci√≥n de error

InOut

Valor de funci√≥n (RET_VAL)

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

80B4

El tipo de datos del par√°metro SRC_ARRAY no es un ARRAY of BYTE.

8382

El valor del par√°metro POS se encuentra fuera de los valores l√≠mite del ARRAY.

8383

El valor del par√°metro POS se encuentra dentro de los valores l√≠mite del ARRAY, pero el
tama√±o del √°rea de memoria excede el l√≠mite superior del ARRAY.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1913

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
#TagResult := WRITE_BIG(SRC_VARIABLE := #DINTVariable,
DEST_ARRAY := #TargetField,
POS := #TagPos);

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

SRC_VARIABLE

#DINTVariable

439041101
16#1A2B3C4D

DEST_ARRAY

#TargetField

ARRAY[0..10] of BYTE
= 16#1A, 16#2B, 16#3C, 16#4D

POS

#TagPos

0 => 4

La instrucci√≥n escribe el entero 439_041_101 del operando #DINTVariable en formato Little
Endian en el √°rea de memoria #TargetField. El tipo de datos del par√°metro SRC_VARIABLE
indica cu√°ntos bytes se escriben. En el operando #TagPos se guarda el n√∫mero 4.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Deserialize: Deserializar (P√°gina 1844)
Serialize: Serializar (P√°gina 1849)
Direccionar √°reas de una variable con accesos Slice (P√°gina 116)
Principios b√°sicos de SCL (P√°gina 8115)

VARIANT
VariantGet: Leer valor de una variable VARIANT
Descripci√≥n
Con la instrucci√≥n "Leer valor de una variable VARIANT" se lee el valor de la variable a la que
apunta VARIANT en el par√°metro SRC y se escribe este valor en la variable del par√°metro
DST.
El par√°metro SRC es del tipo de datos VARIANT. En el par√°metro DST se puede indicar
cualquier tipo de datos excepto VARIANT.

1914

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El tipo de datos de la variable indicada en el par√°metro DST debe coincidir con el tipo de datos
al que apunta VARIANT.
Nota
Para copiar estructuras y ARRAY tambi√©n se puede utilizar la instrucci√≥n
"MOVE_BLK_VARIANT: Copiar √°rea". Encontrar√° m√°s informaci√≥n al respecto en "Consulte
tambi√©n".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria
S7-1200

SRC

Input

VARIANT

DST

Output

I, Q, M, D, L
Secuencias de
bits, enteros, n√∫‚Äê
meros en coma flo‚Äê
tante, tiempos, fe‚Äê
cha y hora, se‚Äê
cuencias de carac‚Äê
teres, elementos
de ARRAY, tipos
de datos PLC

Descripci√≥n

S7-1500

L (puede declararse en las
secciones "Input", "InOut" y
"Temp" de la interfaz del blo‚Äê
que.)
I, Q, M, D, L,
P

Variable que se
lee

Resultado de la
instrucci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
VariantGet(SRC := #TagIn_Source,
DST => "TagOut_Dest");

El valor de la variable a la que se√±ala VARIANT en el operando "#TagIn_Source" se lee y se
escribe en el operando "TagOut_Dest".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
MOVE_BLK_VARIANT: Copiar √°rea (P√°gina 1856)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1915

Instrucciones
4.1 Instrucciones

VariantPut: Escribir valor en una variable VARIANT
Descripci√≥n
La instrucci√≥n "Escribir valor en una variable VARIANT" escribe el valor de la variable indicada
en el par√°metro SRC en la memoria del par√°metro DST al que apunta VARIANT.
El par√°metro DST es del tipo de datos VARIANT. En el par√°metro SRC se puede indicar
cualquier tipo de datos excepto VARIANT.
El tipo de datos de la variable del par√°metro SRC debe coincidir con el tipo de datos al que
apunta VARIANT.
Nota
Para copiar estructuras y ARRAY tambi√©n se puede utilizar la instrucci√≥n
"MOVE_BLK_VARIANT: Copiar √°rea". Encontrar√° m√°s informaci√≥n al respecto en "Consulte
tambi√©n".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria
S7-1200

Descripci√≥n

S7-1500

SRC

Input

Secuencias de
I, Q, M, D, L
bits, enteros, n√∫‚Äê
meros en coma flo‚Äê
tante, tiempos, fe‚Äê
cha y hora, se‚Äê
cuencias de carac‚Äê
teres, elementos
de ARRAY, tipos
de datos PLC

DST

Input

VARIANT

I, Q, M, D, L,
P

Variable que se
lee

L (puede declararse en las
secciones "Input", "InOut" y
"Temp" de la interfaz del blo‚Äê
que.)

Resultado de la
instrucci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
VariantPut(SRC := "TagIn_Source",
DST := #TagIn_Dest);

El valor del operando "TagIn_Source" se escribe en la variable a la que apunta VARIANT en
el operando #TagIn_Dest.

1916

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
MOVE_BLK_VARIANT: Copiar √°rea (P√°gina 1856)
Principios b√°sicos de SCL (P√°gina 8115)

CountOfElements: Consultar n√∫mero de elementos de ARRAY
Descripci√≥n
La instrucci√≥n "Consultar n√∫mero de elementos de ARRAY" permite saber el n√∫mero de
elementos de ARRAY que tiene una variable a la que apunta VARIANT.
Si el ARRAY es unidimensional, el resultado se devuelve como n√∫mero de elementos ARRAY.
(La diferencia entre el l√≠mite superior e inferior + 1). Si el ARRAY es multidimensional, el
resultado se devuelve como cantidad de todas las dimensiones.
Si desea consultar los elementos de un DB de ARRAY deber√° utilizar las instrucciones
"ReadFromArrayDB" o "WriteFromArrayDB", puesto que estas permiten una evaluaci√≥n de
errores m√°s precisa para el n√∫mero de elementos.
Nota
Instancias
El puntero VARIANT no puede se√±alar a ninguna instancia y, por lo tanto, tampoco a ninguna
multiinstancia o ARRAY of multiinstancias.
Nota
ARRAY en un bloque de datos
Si desea consultar el n√∫mero de elementos de un ARRAY que se encuentra en un bloque de
datos, en este no debe estar activado el atributo de bloque "Bloque de datos protegido contra
escritura en el dispositivo". De lo contrario, el par√°metro RET_VAL devuelve el resultado "0",
independientemente de cu√°ntos elementos contenga el ARRAY.
El resultado tambi√©n es "0" si la variable VARIANT no es ARRAY.
Si VARIANT apunta a un ARRAY of BOOL, se cuentan tambi√©n los elementos de relleno. (P.
ej. con un ARRAY[0..1] of BOOL se devuelve 8.)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1917

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

<Operando>

Input

VARIANT

L (puede declarar‚Äê Variable que se consulta
se en las seccio‚Äê
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

UDINT

I, Q, M, D, L

Valor de funci√≥n

Descripci√≥n

Resultado de la instrucci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
IF IS_ARRAY(#Tag_VARIANTToArray) THEN
"Tag_Result" := CountOfElements(#Tag_VARIANTToArray);
END_IF;

Si la variable a la que se√±ala VARIANT es ARRAY, se devuelve el n√∫mero de elementos
ARRAY.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

ARRAY[*]
LOWER_BOUND: Leer l√≠mite inferior del ARRAY
Descripci√≥n
En la interfaz de un bloque de funci√≥n o de una funci√≥n se pueden declarar variables del tipo
de datos ARRAY[*]. Para estas variables locales pueden leerse los l√≠mites del ARRAY. En el
par√°metro DIM debe indicarse la dimensi√≥n deseada.

1918

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para leer el l√≠mite inferior variable del ARRAY est√° disponible la instrucci√≥n "Leer l√≠mite inferior
del ARRAY".
Nota
Disponibilidad de la instrucci√≥n
La instrucci√≥n est√° disponible en las CPU de la serie S7-1200 a partir de la versi√≥n de firmware
>= 4.2 y en las CPU de la serie S7-1500 a partir de la versi√≥n de firmware >= 2.0.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

ARR

Input

ARRAY[*]

FB => secci√≥n
InOut

ARRAY cuyo l√≠mite inferior
variable debe leerse.

FC => secci√≥n In‚Äê
put y InOut
DIM

Input

Valor de funci√≥n

UDINT

I, Q, M, D, L, P o
constante

Dimensi√≥n del ARRAY cuyo
l√≠mite inferior variable debe
leerse.

DINT

I, Q, M, D, L, P

Resultado

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Result" := LOWER_BOUND(ARR := #ARRAY_A,
DIM := 2);

La instrucci√≥n lee el l√≠mite inferior variable del ARRAY #ARRAY_A de la segunda dimensi√≥n.
Si no se producen errores al ejecutar la instrucci√≥n, el resultado se escribe en el operando
"Result".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos del ARRAY (P√°gina 293)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1919

Instrucciones
4.1 Instrucciones

UPPER_BOUND: Leer l√≠mite superior de ARRAY
Descripci√≥n
En la interfaz de un bloque de funci√≥n o de una funci√≥n se pueden declarar variables del tipo
de datos ARRAY[*]. Para estas variables locales pueden leerse los l√≠mites del ARRAY. En el
par√°metro DIM debe indicarse la dimensi√≥n deseada.
Para leer el l√≠mite superior variable del ARRAY est√° disponible la instrucci√≥n "Leer l√≠mite
superior de ARRAY".
Nota
Disponibilidad de la instrucci√≥n
La instrucci√≥n est√° disponible en las CPU de la serie S7-1200 a partir de la versi√≥n de firmware
>= 4.2 y en las CPU de la serie S7-1500 a partir de la versi√≥n de firmware >= 2.0.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

ARR

Input

ARRAY[*]

FB => secci√≥n
InOut

ARRAY cuyo l√≠mite superior
variable debe leerse.

FC => secci√≥n In‚Äê
put y InOut
DIM

Input

Valor de funci√≥n

UDINT

I, Q, M, D, L, P o
constante

Dimensi√≥n del ARRAY cuyo
l√≠mite superior variable debe
leerse.

DINT

I, Q, M, D, L, P

Resultado

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Result" := UPPER_BOUND(ARR := #ARRAY_A,
DIM := 2);

La instrucci√≥n lee el l√≠mite superior variable del ARRAY #ARRAY_A de la segunda dimensi√≥n.
Si no se producen errores al ejecutar la instrucci√≥n, el resultado se escribe en el operando
"Result".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos del ARRAY (P√°gina 293)
Principios b√°sicos de SCL (P√°gina 8115)

1920

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Legacy
BLKMOV: Copiar √°rea
Descripci√≥n
La instrucci√≥n "Copiar √°rea" permite copiar los contenidos de un √°rea de memoria (√°rea de
origen) en un √°rea de memoria diferente (√°rea de destino). La operaci√≥n de copia se realiza por
orden ascendente de direcciones. Las √°reas de origen y destino se definen mediante
VARIANT.
Nota
Las variables de la instrucci√≥n s√≥lo se pueden usar en √°reas de memoria en las que no est√©
activado el atributo "Acceso optimizado al bloque". Esto es v√°lido para bloques de datos (DB),
bloques de organizaci√≥n (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucci√≥n se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable tambi√©n se puede usar en √°reas de memoria "con acceso
optimizado al bloque".
La figura siguiente muestra el principio de la operaci√≥n de copia:

'%'%:

$

%

'%'%:

&

'

'%'%:

(

)

'%'%:

*

+

0:

$

%

0:

&

'

0:

(

)

0:

*

+

&RSLD
/DRSHUDFL¬µQGHFRSLDVH
UHDOL]DSRURUGHQ
DVFHQGHQWHGH
GLUHFFLRQHV

¬ÉUHDGHPHPRULD

Coherencia de los datos de origen y destino
Tenga en cuenta que durante la ejecuci√≥n de la instrucci√≥n "Copiar √°rea" no se modifican los
datos de origen pues, de lo contrario, no se podr√≠a garantizar la coherencia de los datos de
destino.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1921

Instrucciones
4.1 Instrucciones

Posibilidad de interrupci√≥n
No hay limitaciones en cuanto a la profundidad de anidamiento.

√Åreas de memoria
La instrucci√≥n "Copiar √°rea" permite copiar las siguientes √°reas de memoria:
‚óè √Åreas de un bloque de datos
‚óè Marcas
‚óè Memoria imagen de proceso de las entradas
‚óè Memoria imagen de proceso de las salidas

Reglas generales para copiar
Las √°reas de origen y destino no deben solaparse. Si las √°reas de origen y destino son de
diferente longitud, se copia solo hasta la longitud del √°rea m√°s peque√±a.
Si el √°rea de origen es m√°s peque√±a que el √°rea de destino, el √°rea de origen se copiar√° por
completo en el √°rea de destino. Los restantes bytes del √°rea de destino permanecen
inalterados.
Si el √°rea de destino es m√°s peque√±a que el √°rea de origen, se escribir√° en toda el √°rea de
destino. Los restantes bytes del √°rea de origen se ignoran.
Al copiar un √°rea del tipo de datos BOOL, la variable debe direccionarse de forma absoluta y
la longitud indicada del √°rea debe ser un m√∫ltiplo de 8, pues de lo contrario no se ejecutar√° la
instrucci√≥n.

Reglas para copiar cadenas de caracteres
La instrucci√≥n "Copiar √°rea" permite copiar asimismo √°reas de origen y destino del tipo de
datos STRING. Si solo el √°rea de origen es del tipo de datos STRING, se copiar√°n los
caracteres que realmente contiene la cadena de caracteres. La informaci√≥n sobre la longitud
real y m√°xima tambi√©n se escribe en el √°rea de destino. Si tanto el √°rea de origen como el √°rea
de destino son del tipo de datos STRING, la longitud actual de la cadena de caracteres en el
√°rea de destino se pone al n√∫mero de caracteres realmente copiados.
Si se desea copiar informaci√≥n sobre la longitud m√°xima y real de una cadena de caracteres,
las √°reas de los par√°metros SRCBLK y DSTBLK deben indicarse en bytes.

1922

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

SRCBLK

Input

VARIANT

I, Q, M, D, L, P

Indicaci√≥n del √°rea de memo‚Äê
ria que se copia (√°rea de ori‚Äê
gen).

DSTBLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicaci√≥n del √°rea de memo‚Äê
ria en la que se copia (√°rea
de destino).

INT

I, Q, M, D, L, P

Informaci√≥n de error

Valor de funci√≥n (RET_VAL)

1) El par√°metro DSTBLK est√° declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

8092

El √°rea de origen o destino est√° solo en la memoria de carga.

8152

En el par√°metro SRCBLK no est√°n permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

8352

En el par√°metro DSTBLK no est√°n permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

Consulte tambi√©n: "GET_ERR_ID: Consultar ID de error localmente"
Informaci√≥n
de error gene‚Äê
ral
*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_RetVal" := BLKMOV(SRCBLK := P#M100.0 BYTE 10,
DSTBLK => P#DB1.DBX0.0 BYTE 10);

La instrucci√≥n copia 10 bytes a partir de MB100 y los escribe en el DB1. Si ocurre un error
durante la operaci√≥n de copia, el respectivo c√≥digo de error se indica en la variable
"Tag_RetVal".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1923

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
GET_ERR_ID: Consultar ID de error localmente (P√°gina 1982)
Principios b√°sicos de SCL (P√°gina 8115)

UBLKMOV: Copiar √°rea sin interrupciones
Descripci√≥n
La instrucci√≥n "Copiar √°rea sin interrupciones" permite copiar los contenidos de un √°rea de
memoria (√°rea de origen) en un √°rea de memoria diferente (√°rea de destino). La operaci√≥n de
copia se realiza por orden ascendente de direcciones. Las √°reas de origen y destino se definen
mediante VARIANT.
La operaci√≥n de copia no debe ser interrumpida por otras actividades del sistema operativo.
Ello puede aumentar el tiempo de reacci√≥n a alarmas de la CPU durante la ejecuci√≥n de la
instrucci√≥n "Copiar √°rea sin interrupciones".
Nota
Las variables de la instrucci√≥n s√≥lo se pueden usar en √°reas de memoria en las que no est√©
activado el atributo "Acceso optimizado al bloque". Esto es v√°lido para bloques de datos (DB),
bloques de organizaci√≥n (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucci√≥n se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable tambi√©n se puede usar en √°reas de memoria "con acceso
optimizado al bloque".

√Åreas de memoria
La instrucci√≥n "Copiar √°rea sin interrupciones" permite copiar las siguientes √°reas de memoria:
‚óè √Åreas de un bloque de datos
‚óè Marcas
‚óè Memoria imagen de proceso de las entradas
‚óè Memoria imagen de proceso de las salidas

Reglas generales para copiar
Al ejecutar la instrucci√≥n "Copiar √°rea sin interrupciones" no pueden solaparse las √°reas de
origen y destino. Si el √°rea de origen es m√°s peque√±a que el √°rea de destino, el √°rea de origen
se copiar√° por completo en el √°rea de destino. Los restantes bytes del √°rea de destino
permanecen inalterados.
Si el √°rea de destino es m√°s peque√±a que el √°rea de origen, se escribir√° en toda el √°rea de
destino. Los restantes bytes del √°rea de origen se ignoran.

1924

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si un √°rea de origen o destino definida como par√°metro formal es menor que un √°rea de origen
o destino indicada en los par√°metros SRCBLK o DSTBLK, no se transferir√°n datos.
Al copiar un √°rea del tipo de datos BOOL, la variable debe direccionarse de forma absoluta y
la longitud indicada del √°rea debe ser un m√∫ltiplo de 8, pues de lo contrario no se ejecutar√° la
instrucci√≥n.
La instrucci√≥n "Copiar √°rea sin interrupciones" permite copiar 16 KB como m√°ximo. A este
respecto deben tenerse en cuenta las limitaciones espec√≠ficas de la CPU.

Reglas para copiar cadenas de caracteres
La instrucci√≥n "Copiar √°rea sin interrupciones" permite copiar asimismo √°reas de origen y
destino del tipo de datos STRING. Si solo el √°rea de origen es del tipo de datos STRING, se
copiar√°n los caracteres que realmente contiene la cadena de caracteres. La informaci√≥n sobre
la longitud real y m√°xima no se escribe en el √°rea de destino. Si tanto el √°rea de origen como
el √°rea de destino son del tipo de datos STRING, la longitud actual de la cadena de caracteres
en el √°rea de destino se pone al n√∫mero de caracteres realmente copiados. Si se copian √°reas
del tipo de datos STRING, debe indicarse "1" como longitud del √°rea.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

SRCBLK

Input

VARIANT

I, Q, M, D, L, P

Indicaci√≥n del √°rea de memo‚Äê
ria que se copia (√°rea de ori‚Äê
gen).

DSTBLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicaci√≥n del √°rea de memo‚Äê
ria en la que se copia (√°rea
de destino).

INT

I, Q, M, D, L, P

Informaci√≥n de error

Valor de funci√≥n (RET_VAL)

1) El par√°metro DSTBLK est√° declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error
(W#16#....)

Explicaci√≥n

0000

Ning√∫n error

8091

El √°rea de origen o destino est√° solo en la memoria de carga.

8152

En el par√°metro SRCBLK no est√°n permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

8352

En el par√°metro DSTBLK no est√°n permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1925

Instrucciones
4.1 Instrucciones
C√≥digo de
error
(W#16#....)

Explicaci√≥n

Informaci√≥n
de error ge‚Äê
neral

Consulte tambi√©n: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_RetVal" := UBLKMOV(SRCBLK := P#M100.0 BYTE 10,
DSTBLK => P#DB1.DBX0.0 BYTE 10);

La instrucci√≥n copia 10 bytes a partir de MB100 y los escribe en el DB1. Si ocurre un error
durante la operaci√≥n de copia, el respectivo c√≥digo de error se indica en la variable
"Tag_RetVal".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
GET_ERR_ID: Consultar ID de error localmente (P√°gina 1982)
Principios b√°sicos de SCL (P√°gina 8115)

FILL: Rellenar √°rea
Descripci√≥n
La instrucci√≥n "Rellenar √°rea" rellena un √°rea de memoria (√°rea de destino) con el contenido
de un √°rea de memoria diferente (√°rea de origen). La instrucci√≥n "Rellenar √°rea" copia el
contenido del √°rea de origen en el √°rea de destino las veces necesarias hasta que el √°rea de
destino quede escrita por completo. La operaci√≥n de copia se realiza por orden ascendente de
direcciones.

1926

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Las √°reas de origen y destino se definen mediante VARIANT.
Nota
Las √°reas de origen y destino tambi√©n se pueden definir mediante el tipo de datos ANY.
Si se utiliza el tipo de datos ANY, hay que tener en cuenta lo siguiente en relaci√≥n con el tipo
de datos STRING:
‚óè En una asignaci√≥n de STRING (√°rea de origen) mediante ANY a STRING (√°rea de destino),
el contenido del STRING se copia una y otra vez en el √°rea de destino hasta llenarla.
√Årea de origen: 'STEP7-SCL-TIA-Portal'
√Årea de destino: 'STEP7-SCL-TIA-PortalSTEP7-SCL-TIA-PortalSTEP7-SCL'
‚óè En una asignaci√≥n de WSTRING (√°rea de origen) mediante ANY a WSTRING (√°rea de
destino), el WSTRING completo, incluida la tipificaci√≥n, solo se copia una vez en el √°rea de
destino.
√Årea de origen: WSTRING#'STEP7-SCL-TIA-Portal'
√Årea de destino: WSTRING#'STEP7-SCL-TIA-Portal'
Nota
Las variables de la instrucci√≥n s√≥lo se pueden usar en √°reas de memoria en las que no est√©
activado el atributo "Acceso optimizado al bloque". Esto es v√°lido para bloques de datos (DB),
bloques de organizaci√≥n (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucci√≥n se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable tambi√©n se puede usar en √°reas de memoria "con acceso
optimizado al bloque".
Para los bloques con el atributo "Acceso optimizado al bloque" puede utilizarse la instrucci√≥n
"FILL_BLK: Rellenar √°rea".
La figura siguiente muestra el principio de la operaci√≥n de copia:
),//

%9$/

$

%

0:

$

%

0:

&

'

0:

&

'

0:

(

)

0:

(

)

0:

*

+

0:

*

+

0:

$

%

0:

&

'

0:

(

)

0:

*

+

0:

$

%

0:

&

'

0:

%/.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1927

Instrucciones
4.1 Instrucciones
Ejemplo: el contenido del √°rea MW100 a MW118 debe inicializarse con el contenido de las
palabras de marcas MW14 a MW20.

Coherencia de los datos de origen y destino
Tenga en cuenta que al ejecutar la instrucci√≥n "Rellenar √°rea" no se modifican los datos de
origen, pues de lo contrario no se podr√≠a garantizar la coherencia de los datos de destino.

√Åreas de memoria
La instrucci√≥n "Rellenar √°rea" permite copiar las siguientes √°reas de memoria:
‚óè √Åreas de un bloque de datos
‚óè Marcas
‚óè Memoria imagen de proceso de las entradas
‚óè Memoria imagen de proceso de las salidas

Reglas generales para copiar
Las √°reas de origen y destino no deben solaparse. Aunque el √°rea de destino que se debe
inicializar no sea m√∫ltiplo entero de la longitud del par√°metro de entrada BVAL, el √°rea de
destino se rellenar√° igualmente hasta el √∫ltimo byte.
Si el √°rea de destino que se debe rellenar es menor que el √°rea de origen, s√≥lo se copiar√°n los
datos que quepan en el √°rea de destino.
Si el √°rea de origen o destino realmente existente es menor que el tama√±o del √°rea de memoria
parametrizada para el √°rea de origen o destino (par√°metros BVAL, BLK), los datos no se
transfieren.
Si el puntero ANY (origen o destino) es del tipo de datos BOOL, debe direccionarse de forma
absoluta y la longitud indicada del √°rea debe ser un m√∫ltiplo de 8, pues de lo contrario no se
ejecutar√° la instrucci√≥n.
Si el √°rea de destino es del tipo de datos STRING, la instrucci√≥n escribe la cadena de
caracteres completa, incluida la informaci√≥n de administraci√≥n.

Reglas para copiar estructuras
Al transferir una estructura a modo de par√°metro de entrada, tenga en cuenta que la longitud
de una estructura se rige siempre por un n√∫mero par de bytes. Si se declara una estructura con
un n√∫mero impar de bytes, la estructura necesitar√° un byte adicional de espacio en memoria.

1928

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

BVAL

Input

VARIANT

I, Q, M, D, L, P

Indicaci√≥n del √°rea de memo‚Äê
ria (√°rea de origen) con cuyo
contenido se rellena el √°rea
de destino en el par√°metro
BLK.

BLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicaci√≥n del √°rea de memo‚Äê
ria que se rellena con el con‚Äê
tenido del √°rea de origen.

INT

I, Q, M, D, L, P

Informaci√≥n de error

Valor de funci√≥n (RET_VAL)

1) El par√°metro BLK est√° declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro BVAL
Al indicar una estructura a modo de par√°metro de entrada, tenga en cuenta que la longitud de
una estructura se adapta siempre a un n√∫mero entero de bytes. Si se declara una estructura
con un n√∫mero impar de bytes, la estructura necesitar√° un byte adicional de espacio en
memoria.

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de Explicaci√≥n
error
(W#16#....)
0000

Ning√∫n error

8092

El √°rea de origen o destino est√° solo en la memoria de carga.

8152

En el par√°metro BVAL no est√°n permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

8352

En el par√°metro BLK no est√°n permitidos los tipos de datos WSTRING, WCHAR, BOOL,
ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

Informa‚Äê
Consulte tambi√©n: "GET_ERR_ID: Consultar ID de error localmente"
ci√≥n de
error gene‚Äê
ral
*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1929

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_RetVal" := FILL(BVAL := P#M14.0 WORD 4,
BLK => P#M100.0 WORD 10);

La instrucci√≥n copia el √°rea de origen de MW14 a MW20 y rellena el √°rea de destino de MW100
a MW118 con el contenido de las 4 palabras contenidas en el √°rea de memoria del par√°metro
BVAL.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
GET_ERR_ID: Consultar ID de error localmente (P√°gina 1982)
Principios b√°sicos de SCL (P√°gina 8115)

Conversi√≥n
CONVERT: Convertir valor
Descripci√≥n
La instrucci√≥n "Convertir valor" permite programar conversiones expl√≠citas. Al insertar la
instrucci√≥n se abre el cuadro de di√°logo "CONVERT". En √©l se indica el tipo de datos de origen
y el tipo de datos de destino de la conversi√≥n. El valor de origen se lee y se convierte al tipo de
datos de destino indicado.

1930

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Opciones de conversi√≥n de secuencias de bits
En el cuadro de la instrucci√≥n no se pueden seleccionar las secuencias de bits BYTE y WORD.
Sin embargo es posible indicar un operando del tipo de datos DWORD o LWORD en un
par√°metro de la instrucci√≥n si coinciden la longitud del operando de entrada y la del operando
de salida. En tal caso, el operando del tipo de datos de una secuencia de bits se interpreta
conforme al tipo de datos del par√°metro de entrada o salida y se convierte impl√≠citamente. El
tipo de datos DWORD se interpreta, p. ej., como DINT/UDINT, y LWORD como LINT/ULINT.
Estas opciones de conversi√≥n tambi√©n est√°n disponibles estando activada la verificaci√≥n CEI.
Nota
Para las CPU de las series S7-1500 se aplica: Los tipos de datos DWORD y LWORD s√≥lo se
pueden convertir a o desde el tipo de datos REAL o LREAL.
El patr√≥n de bits del valor de origen se transfiere sin cambios y justificado a la derecha al tipo
de datos de destino. Si no se producen errores durante la conversi√≥n, el estado de se√±al de la
salida de habilitaci√≥n ENO = 1; si se produce un error durante la ejecuci√≥n, el estado de se√±al
de la salida de habilitaci√≥n ENO = 0.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

<Tipo de ori‚Äê
gen>

Input

N√∫meros binarios, I, Q, M, D, L, P o
enteros, n√∫meros constante
en coma flotante,
temporizadores,
fecha y hora, cade‚Äê
nas de caracteres,
BCD16, BCD32

Valor que se convierte.

N√∫meros binarios, I, Q, M, D, L, P o
enteros, n√∫meros constante
en coma flotante,
temporizadores,
fecha y hora, cade‚Äê
nas de caracteres,
BCD16, BCD32

Resultado de la conversi√≥n

<Tipo de des‚Äê Output
tino>

√Årea de memoria

Descripci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_INT" := REAL_TO_INT("Tag_REAL");

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1931

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Tipo de datos

Valor

Tag_REAL

REAL

20.56

Tag_INT

INT

21

En la conversi√≥n, el valor del operando "Tag_REAL" se redondea al siguiente entero y se
deposita en el operando "Tag_INT".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

ROUND: Redondear n√∫mero
Descripci√≥n
La instrucci√≥n "Redondear n√∫mero" permite redondear el valor de la entrada IN al siguiente
n√∫mero entero. La instrucci√≥n interpreta el valor de la entrada IN como n√∫mero en coma
flotante y lo convierte a un n√∫mero entero o a un n√∫mero en coma flotante. Si el valor de
entrada se encuentra entre un n√∫mero par y uno impar, se selecciona el n√∫mero par.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en
coma flotante

I, Q, M, D, L, P

Valor de entrada
que se debe redon‚Äê
dear.

Valor de funci√≥n

Enteros, n√∫me‚Äê I, Q, M, D, L, P
ros en coma
flotante

Resultado del re‚Äê
dondeo

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := ROUND("Tag_Value");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.

1932

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

1.50000000

-1.50000000

Tag_Result

2

-2

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

CEIL: Redondear un n√∫mero en coma flotante al siguiente entero superior
Descripci√≥n
La instrucci√≥n "Redondear un n√∫mero en coma flotante al siguiente entero superior" permite
redondear el valor al siguiente n√∫mero entero superior. La instrucci√≥n interpreta el valor de
entrada como n√∫mero en coma flotante y lo convierte al n√∫mero entero superior m√°s pr√≥ximo.
El valor de la funci√≥n puede ser mayor o igual al valor de entrada.
Para modificar el tipo de datos de la instrucci√≥n, utilice la sintaxis siguiente:
CEIL_<Tipo de datos>();

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1933

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memoria Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en
coma flotante

I, Q, M, D, L, P

_<tipo de datos>

Valor de entrada

Enteros, n√∫me‚Äê ros en coma
flotante, valor
predetermina‚Äê
do: DINT

Tipo de datos del valor de funci√≥n:
1. El tipo de datos de la
instrucci√≥n se puede indicar
expl√≠citamente con "_".
2. Si el tipo de datos no se indica
expl√≠citamente, se
determinar√° a partir de las
variables utilizadas o de las
constantes con tipos.
3. Si el tipo de datos no se indica
expl√≠citamente ni se indican
variables definidas ni
constantes con tipo, se
utilizar√° el tipo de datos
predeterminado.

Valor de funci√≥n

Enteros, n√∫me‚Äê I, Q, M, D, L
ros en coma
flotante

Valor de entrada redondeado

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result1" := CEIL("Tag_Value");
"Tag_Result2" := CEIL_REAL("Tag_Value");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

0.5

-0.5

Tag_Result1

1

0

Tag_Result2

1.0

0.0

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Resultxy" como valor de
funci√≥n.

1934

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

FLOOR: Redondear un n√∫mero en coma flotante al siguiente entero inferior
Descripci√≥n
La instrucci√≥n "Redondear un n√∫mero en coma flotante al siguiente entero inferior" permite
redondear el valor al siguiente n√∫mero entero inferior. La instrucci√≥n interpreta el valor de
entrada como n√∫mero en coma flotante y lo convierte al n√∫mero entero inferior m√°s pr√≥ximo.
El valor de funci√≥n puede ser menor o igual al valor de entrada.
Para modificar el tipo de datos de la instrucci√≥n, utilice la sintaxis siguiente:
FLOOR_<Tipo de datos>();

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en
coma flotante

I, Q, M, D, L, P

_<tipo de datos>

Enteros, n√∫me‚Äê ros en coma
flotante, valor
predetermina‚Äê
do: DINT

Valor de entrada
Tipo de datos del valor de fun‚Äê
ci√≥n:
1. El tipo de datos de la
instrucci√≥n se puede indicar
expl√≠citamente con "_".
2. Si el tipo de datos no se
indica expl√≠citamente, se
determinar√° a partir de las
variables utilizadas o de las
constantes con tipos.
3. Si el tipo de datos no se
indica expl√≠citamente ni se
indican variables definidas
ni constantes con tipo, se
utilizar√° el tipo de datos
predeterminado.

Valor de funci√≥n

Enteros, n√∫me‚Äê I, Q, M, D, L
ros en coma
flotante

Valor de entrada redondeado

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1935

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result1" := FLOOR("Tag_Value");
"Tag_Result2" := FLOOR_REAL("Tag_Value");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

0.5

-0.5

Tag_Result1

0

-1

Tag_Result2

0.0

-1.0

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Resultxy" como valor de
funci√≥n.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

TRUNC: Truncar a entero
Descripci√≥n
La instrucci√≥n "Truncar a entero" permite generar un valor entero no redondeado a partir del
valor de entrada. La instrucci√≥n selecciona solo la parte entera del valor de entrada y la
devuelve sin decimales como valor de funci√≥n.
Para modificar el tipo de datos de la instrucci√≥n, utilice la sintaxis siguiente:
TRUNC_<Tipo de datos>();

1936

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Expresi√≥n>

Input

N√∫meros en
coma flotante

I, Q, M, D, L

Valor de entrada

_<tipo de datos>

Enteros, n√∫me‚Äê ros en coma
flotante
Valor predeter‚Äê
minado: DINT

Tipo de datos del valor de
funci√≥n:
1. El tipo de datos de la
instrucci√≥n se puede
indicar expl√≠citamente
con "_".
2. Si el tipo de datos no se
indica expl√≠citamente,
se determinar√° a partir
de las variables
utilizadas o de las
constantes con tipos.
3. Si el tipo de datos no se
indica expl√≠citamente ni
se indican variables
definidas ni constantes
con tipo, se utilizar√° el
tipo de datos
predeterminado.

Valor de funci√≥n

Enteros, n√∫me‚Äê I, Q, M, D, L
ros en coma
flotante

Parte entera del valor de en‚Äê
trada

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result1" := TRUNC("Tag_Value1");
"Tag_Result2" := TRUNC("Tag_Value2"+"Tag_Value3");
"Tag_Result3" := TRUNC_SINT("Tag_Value4");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value1

-1.5

Tag_Result1

-1

Tag_Value2

2.1

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1937

Instrucciones
4.1 Instrucciones
Operando

Valor

Tag_Value3

3.2

Tag_Result2

5

Tag_Result3

2

Tag_Value4

2.4

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

SCALE_X: Escalar
Descripci√≥n
La instrucci√≥n "Escalar" permite escalar un n√∫mero en coma flotante mape√°ndolo en un
determinado rango de valores. El rango de valores se especifica con los par√°metros MIN y
MAX. El resultado de la escala es un entero.
Para modificar el tipo de datos de la instrucci√≥n, utilice la sintaxis siguiente:
SCALE_X_<Tipo de datos>();
La figura siguiente muestra un ejemplo de c√≥mo pueden escalarse los valores:

0$;
5HVXOWDGR!
0,1




([SUHVL¬µQ!

La instrucci√≥n "Escalar" utiliza la siguiente ecuaci√≥n:

1938

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
OUT = [VALUE ‚àó (MAX ‚Äì MIN)] + MIN
Nota
Encontrar√° m√°s informaci√≥n sobre la conversi√≥n de valores anal√≥gicos en el manual de
producto correspondiente.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memo‚Äê Descripci√≥n
ria

MIN

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante

I, Q, M, D, L

L√≠mite inferior del rango de
valores

VALUE

Input

N√∫meros en co‚Äê
ma flotante

I, Q, M, D, L

Valor que se escala. Si se in‚Äê
dica una constante, esta de‚Äê
be declararse.

MAX

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante

I, Q, M, D, L

L√≠mite superior del rango de
valores

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante
valor predeter‚Äê
minado: INT

-

Tipo de datos del valor de fun‚Äê
ci√≥n:

_<tipo de datos>

1. El tipo de datos de la
instrucci√≥n se puede
indicar expl√≠citamente con
"_".
2. Si el tipo de datos no se
indica expl√≠citamente, se
determinar√° a partir de las
variables utilizadas o de
las constantes con tipos.
3. Si el tipo de datos no se
indica expl√≠citamente ni
se indican variables
definidas ni constantes
con tipo, se utilizar√° el tipo
de datos predeterminado.

Valor de funci√≥n

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante

-

Resultado de la escala

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".
Encontrar√° m√°s informaci√≥n sobre la declaraci√≥n de constantes en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1939

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result1" := SCALE_X(MIN := "Tag_Value1",
VALUE := "Tag_Real",
MAX := "Tag_Value2");
"Tag_Result2" := SCALE_X_REAL(MIN := "Tag_Value1",
VALUE := "Tag_Real",
MAX := "Tag_Value2");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Real

0.5

Tag_Value1

10

Tag_Value2

30

Tag_Result1

20

Tag_Result2

20.0

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Declarar constantes globales (P√°gina 7910)
Principios b√°sicos de SCL (P√°gina 8115)

NORM_X: Normalizar
Descripci√≥n
La instrucci√≥n "Normalizar" normaliza el valor de la variable de la entrada VALUE
represent√°ndolo en una escala lineal. Los par√°metros MIN y MAX sirven para definir los l√≠mites
de un rango de valores que se refleja en la escala. En funci√≥n de la posici√≥n del valor que se
debe normalizar en este rango de valores, se calcula el resultado y se deposita como n√∫mero
en coma flotante en la salida OUT. Si el valor que se debe normalizar es igual al valor de la
entrada MIN, la instrucci√≥n devuelve el valor "0.0" como resultado. Si el valor que se debe
normalizar es igual al valor de la entrada MAX, la instrucci√≥n devuelve el valor "1.0" como
resultado.
Para modificar el tipo de datos de la instrucci√≥n, utilice la sintaxis siguiente:
NORM_X_<Tipo de datos>();
La figura siguiente muestra un ejemplo de c√≥mo pueden normalizarse los valores:

1940

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones


5HVXOWDGR!

0,1

0$;

([SUHVL¬µQ!

La instrucci√≥n "Normalizar" utiliza la siguiente ecuaci√≥n:
OUT = (VALUE ‚Äì MIN) / (MAX ‚Äì MIN)
Nota
Encontrar√° m√°s informaci√≥n sobre la conversi√≥n de valores anal√≥gicos en el manual de
producto correspondiente.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memo‚Äê
ria

Descripci√≥n

MIN 1)

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante

I, Q, M, D, L

L√≠mite inferior del rango de
valores

VALUE 1)

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante

I, Q, M, D, L

Valor que se normaliza.

MAX 1)

Input

Enteros, n√∫me‚Äê
ros en coma flo‚Äê
tante

I, Q, M, D, L

L√≠mite superior del rango de
valores

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1941

Instrucciones
4.1 Instrucciones
Par√°metros
_<tipo de datos>

Declaraci√≥n

Tipo de datos

√Årea de memo‚Äê
ria

Descripci√≥n

N√∫meros en co‚Äê
ma flotante
Valor predeter‚Äê
minado: REAL

-

Tipo de datos del valor de
funci√≥n:
1. El tipo de datos de la
instrucci√≥n se puede
indicar expl√≠citamente
con "_".
2. Si el tipo de datos no se
indica expl√≠citamente, se
determinar√° a partir de
las variables utilizadas o
de las constantes con
tipos.
3. Si el tipo de datos no se
indica expl√≠citamente ni
se indican variables
definidas ni constantes
con tipo, se utilizar√° el
tipo de datos
predeterminado.

Valor de funci√≥n
1)

N√∫meros en co‚Äê
ma flotante

I, Q, M, D, L

Resultado de la normaliza‚Äê
ci√≥n

Si se utilizan constantes en estos tres par√°metros, basta con declarar una de ellas.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".
Encontrar√° m√°s informaci√≥n sobre la declaraci√≥n de constantes en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result1" := NORM_X(MIN := "Tag_Value1",
VALUE := "Tag_InputValue",
MAX := "Tag_Value2");
"Tag_Result2" := NORM_X_LREAL(MIN := "Tag_Value1",
VALUE := "Tag_InputValue",
MAX := "Tag_Value2");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:

1942

Operando

Valor

Tag_InputValue

20

Tag_Value1

10

Tag_Value2

30

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Operando

Valor

Tag_Result1

0.5

Tag_Result2

0.5

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Declarar constantes globales (P√°gina 7910)
Principios b√°sicos de SCL (P√°gina 8115)

REF: Crear referencia a una variable
Descripci√≥n
Con la palabra clave "REF()" se especifica la variable a la que debe se√±alar una referencia
previamente declarada. Como par√°metro se indica la variable que debe referenciarse.

Nota
Declaraci√≥n de referencias
Antes de utilizar la palabra clave "REF()" es necesario declarar una referencia en la interfaz del
bloque.
Consulte tambi√©n:
Declarar referencias (P√°gina 314)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1943

Instrucciones
4.1 Instrucciones

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Expresi√≥n>

Input

Secuencias de
bits, excepto
BOOL,

Variable DB (opti‚Äê
mizada),

Variable a la que
debe se√±alar la re‚Äê
ferencia

Enteros,
N√∫meros en coma
flotante,

Interfaz de un blo‚Äê
que FB (optimiza‚Äê
do)

Cadenas de carac‚Äê
teres,
Tipos de datos
PLC (UDT),
Tipos de datos de
sistema (SDT),
ARRAYs de los ti‚Äê
pos de datos cita‚Äê
dos
Valor de funci√≥n

El tipo de datos del
valor de funci√≥n
concuerda con el
de la variable de
referencia declara‚Äê
da.

Interfaz de bloque
de una FC: Input,
Output, Temp

Direcci√≥n de la va‚Äê
riable referenciada

Interfaz de bloque
de un FB: Temp

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Reglas
Para el referenciado se aplican las reglas siguientes:
‚óè El tipo de datos de la variable, que se indica entre par√©ntesis, debe coincidir exactamente
con el tipo de datos de la referencia declarada. Una referencia del tipo "REF_TO Int" s√≥lo
puede se√±alar por tanto a una variable del tipo "Int". No se produce una conversi√≥n de tipos
de datos.
‚óè La variable que se especifique como par√°metro para "REF()" debe estar en un √°rea de
memoria optimizada.
‚óè Una referencia no debe se√±alar a los datos siguientes:
‚Äì datos temporales (TEMP)
‚Äì variables globales procedentes de la tabla de variables PLC
‚Äì par√°metros de bloque
‚Äì constantes
‚Äì variables protegidas contra escritura

1944

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para referencias a arrays (matrices) se aplica:
‚óè Los l√≠mites de arrays (matrices) y dimensiones de la referencia y de la variable referenciada
deben ser id√©nticos.
‚óè Array[*] no se soporta.
‚óè Las referencias a los DB ARRAY que se basan en un tipo de datos PLC deben crearse del
siguiente modo:
REF("my_ArrayDB_UDT".THIS)
REF("my_ArrayDB_UDT"."THIS"[i])

Ejemplo
En la interfaz del bloque se han declarado las variables temporales "#myRefInt",
"#myRefType" y "#myRefArray".

En el c√≥digo del programa se han asignado variables concretas a estas referencias:
SCL
#myRefInt := REF(#a);
#myRefType := REF("myDB".myUDT);
#myRefType := REF("myArrayDB_UDT"."THIS"[1]);
#myRefARRAY := REF("myDB".myArray);

Consulte tambi√©n
Principios b√°sicos de las referencias (P√°gina 310)
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1945

Instrucciones
4.1 Instrucciones

VARIANT
VARIANT_TO_DB_ANY: Convertir VARIANT en DB_ANY
Descripci√≥n
La instrucci√≥n "Convertir VARIANT en DB_ANY" consulta el n√∫mero de bloque de datos que
direcciona el operando indicado en el par√°metro IN. Se puede tratar de un bloque de datos de
instancia o de un bloque de datos ARRAY. El operando del par√°metro IN es del tipo de datos
VARIANT, por lo que al escribir el programa no se necesita saber qu√© tipo de datos tiene el
bloque de datos, cuyo n√∫mero debe consultarse. El n√∫mero del bloque de datos se lee en
tiempo de ejecuci√≥n y se escribe en el operando indicado en el par√°metro RET_VAL.

Requisitos
Si se cumplen los requisitos, se ejecuta la instrucci√≥n. Si no se cumplen los requisitos, se
devuelve "0" como n√∫mero del bloque de datos.

1946

La variable de salida...

referencia...

Posibilidades de conversi√≥n

VARIANT

... un bloque de datos que puede
ser un bloque de datos de ins‚Äê
tancia de un tipo de datos PLC o
de un tipo de datos del sistema
(SDT).

Es posible convertir la variable
de salida a un n√∫mero del bloque
de datos.

VARIANT

... un bloque de datos que es un
DB de ARRAY.

Es posible convertir la variable
de salida a un n√∫mero del bloque
de datos.

VARIANT

... una variable con un tipo de
datos simple.

No es posible convertir la varia‚Äê
ble de salida a un n√∫mero del
bloque de datos, puesto que un
bloque de datos nunca consta
solamente de un tipo de datos
simple.

VARIANT

... una estructura de un bloque
de datos.

No es posible convertir la varia‚Äê
ble de salida a un n√∫mero del
bloque de datos, puesto que so‚Äê
lo se trata de una parte del blo‚Äê
que de datos.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

VARIANT

L (puede declarar‚Äê
se en las seccio‚Äê
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

Variable que se lee. (Valor de
funci√≥n de la instrucci√≥n
"DB_ANY_TO_VARIANT")
En el par√°metro IN puede
emplearse una variable local
o global.

ERR

Output

INT

I, Q, M, D, L

Informaci√≥n de error

DB_ANY

I, Q, M, D, L

Resultado: n√∫mero de DB

Valor de funci√≥n (RET_VAL)

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro ERR
La tabla siguiente muestra el significado de los valores del par√°metro ERR:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
0000

Ning√∫n error

252C

El tipo de datos VARIANT del par√°metro IN devuelve el valor "0" y la CPU pasa al estado
operativo STOP.

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8130

El par√°metro IN es del tipo de datos ANY.

8131

El bloque de datos no existe, es demasiado corto o est√° en la memoria de carga.

8132

El bloque de datos es demasiado corto y no es un bloque de datos ARRAY.

8150

El tipo de datos VARIANT del par√°metro IN devuelve el valor "0". Para recibir este men‚Äê
saje de error, la propiedad de bloque "Tratamiento local de errores en el bloque" debe
estar activada. En caso contrario, la CPU pasa al estado operativo STOP y devuelve el
c√≥digo de error 16#252C.

8153

El tipo de datos VARIANT del par√°metro IN no apunta al principio de un bloque de datos
ARRAY o bien la longitud del VARIANT no concuerda con la del bloque de datos.

8154

El bloque de datos es de un tipo incorrecto.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"OutputDBNumber" := VARIANT_TO_DB_ANY(IN := #tempVARIANT,
ERR := "Tag_Error");

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1947

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Declaraci√≥n en la inter‚Äê
faz del bloque

Operando

Valor

IN

Input

tempVARIANT

-

<Valor de funci√≥n>

Output

OutputDBNumber

11

Se lee el n√∫mero de un bloque de datos indicado en el operando tempVARIANT. Puesto que
el operando es del tipo de datos VARIANT, en el momento de la elaboraci√≥n del programa a√∫n
no es necesario saber de qu√© tipo de datos es la variable. El n√∫mero se escribe en la variable
"OutputDBNumber" que tiene el tipo de datos DB_ANY.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

DB_ANY_TO_VARIANT: Convertir DB_ANY en VARIANT
Descripci√≥n
La instrucci√≥n "Convertir DB_ANY en VARIANT" permite generar, a partir de un bloque de
datos, una variable VARIANT que cumple los requisitos abajo indicados. El operando del
par√°metro IN es del tipo de datos DB_ANY, por lo que al escribir el programa no es necesario
conocer el bloque de datos. El n√∫mero del bloque de datos se lee en tiempo de ejecuci√≥n.

Requisitos
Si se cumplen los requisitos, se ejecuta la instrucci√≥n. Si no se cumplen los requisitos o el
bloque de datos no existe, se devuelve el valor NULL en el par√°metro RET_VAL. Los dem√°s
accesos con la variable RET_VAL dan error.

1948

La variable de entrada del tipo
de datos...

referencia...

Posibilidades de conversi√≥n

DB_ANY

... un bloque de datos que puede
ser un bloque de datos de ins‚Äê
tancia de un tipo de datos PLC o
de un tipo de datos del sistema
(SDT).

La conversi√≥n es posible

DB_ANY

... un bloque de datos que es un
DB de ARRAY.

La conversi√≥n es posible

DB_ANY

... un bloque de datos que puede
ser un bloque de datos de ins‚Äê
tancia de un bloque de funci√≥n o
un bloque de datos global.

La conversi√≥n no es posible

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

DB_ANY

I, Q, M, D, L

Bloque de datos cuyo n√∫me‚Äê
ro se lee. En el par√°metro IN
puede emplearse una varia‚Äê
ble local o global.

ERR

Output

INT

I, Q, M, D, L

Informaci√≥n de error

VARIANT

L (puede declarar‚Äê N√∫mero del bloque de datos
se en las seccio‚Äê
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

Valor de funci√≥n
(RET_VAL) 1)

1) El par√°metro RET_VAL est√° declarado como Output, ya que los datos desembocan en la variable.
Sin embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro ERR
La tabla siguiente muestra el significado de los valores del par√°metro ERR:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
0000

Ning√∫n error

8130

El n√∫mero del bloque de datos es "0".

8131

El bloque de datos no existe, es demasiado corto o est√° en la memoria de carga.

8132

El bloque de datos es demasiado corto y no es un bloque de datos ARRAY.

8134

El bloque de datos est√° protegido contra escritura.

8154

El bloque de datos es de un tipo incorrecto.

8155

El bloque de datos es de un tipo de datos desconocido. 1)

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".
1)

La causa del c√≥digo de error #8155 es la siguiente:

Se ha declarado un tipo de datos PLC (UDT1) y a continuaci√≥n se crea un bloque de datos
(DB2) del tipo de datos "UDT1". En la tabla de variables hay una variable (3) del tipo de datos
DB_ANY. En un bloque de programa (4) se llam√≥ entonces la instrucci√≥n
"DB_ANY_TO_VARIANT" y se le asign√≥ la variable (3) en el par√°metro IN. Al ejecutar la
instrucci√≥n "DB_ANY_TO_VARIANT", se emite el c√≥digo de error 16#8155.
Para resolver el c√≥digo de error, haga lo siguiente:
1. Cree una funci√≥n (FC5) y declare una variable del tipo de datos VARIANT en la interfaz
InOut.
2. Cree otra funci√≥n (FC6) y en ella llame FC5.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1949

Instrucciones
4.1 Instrucciones
3. En FC6, en la interfaz Temp, cree una variable (7) del tipo de datos "UDT1".
4. Asigne a la interfaz InOut de FC5 la variable (7).
5. Compile y cargue los dos bloques (FC5 y FC6) en la CPU. No hace falta que llame estos
bloques (FC5 y FC6) en el programa de usuario.
Resultado:
El c√≥digo de error 16#8155 no se emite, puesto que el programa de usuario ya conoce el tipo
de datos.
Este proceso no es necesario si despu√©s de llamar la instrucci√≥n "DB_ANY_TO_VARIANT",
llama una de las dos instrucciones "VariantGet" o "VariantPut".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
#tempVARIANT := DB_ANY_TO_VARIANT(IN := "InputDB",
ERR := "Tag_Error");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Declaraci√≥n en la Operando
interfaz del bloque

Valor

IN

Input

InputDB

11

<Valor de funci√≥n>

Temp

tempVARIANT

-

El n√∫mero de un bloque de datos cualquiera indicado en el operando "InputDB" se utiliza para
generar una variable del tipo de datos VARIANT que direccione el bloque de datos. Puesto que
el operando del par√°metro IN es del tipo de datos DB_ANY, al escribir el programa a√∫n no es
necesario saber qu√© bloque de datos se utilizar√° en tiempo de ejecuci√≥n, ni tampoco el nombre
y el n√∫mero del bloque de datos. Puesto que el operando del par√°metro RET_VAL es del tipo
de datos VARIANT, al escribir el programa a√∫n no es necesario saber qu√© tipo de datos tiene
el bloque de datos.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

1950

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Legacy
SCALE: Escalar
Descripci√≥n
La instrucci√≥n "Escalar" convierte el entero del par√°metro IN en un n√∫mero en coma flotante
que se escala en unidades f√≠sicas entre un l√≠mite inferior y uno superior. Los l√≠mites inferior y
superior del rango de valores en el que se escala el valor de entrada se definen mediante los
par√°metros LO_LIM y HI_LIM. El resultado de la instrucci√≥n se devuelve en el par√°metro OUT.
La instrucci√≥n "Escalar" utiliza la siguiente ecuaci√≥n:
OUT = [((FLOAT (IN) ‚Äì K1)/(K2‚ÄìK1)) ‚àó (HI_LIM‚ÄìLO_LIM)] + LO_LIM
El estado l√≥gico del par√°metro BIPOLAR determina los valores de las constantes "K1" y "K2".
El par√°metro BIPOLAR puede tener los siguientes estados l√≥gicos:
‚óè Estado l√≥gico "1": se presupone que el valor del par√°metro IN es bipolar y est√° comprendido
en un rango de valores entre -27648 y 27648. En este caso, la constante "K1" tiene el valor
-27648,0, y la constante "K2", el valor +27648,0.
‚óè Estado l√≥gico "0": se presupone que el valor del par√°metro IN es unipolar y est√°
comprendido en un rango de valores entre 0 y 27648. En este caso, la constante "K1" tiene
el valor 0,0, y la constante "K2", el valor +27648,0.
Si el valor del par√°metro IN es mayor que el de la constante "K2", el resultado de la instrucci√≥n
se pone al valor del l√≠mite superior (HI_LIM) y se emite un error.
Si el valor del par√°metro IN es menor que el de la constante "K1", el resultado de la instrucci√≥n
se pone al valor del l√≠mite inferior (LO_LIM) y se emite un error.
Si el l√≠mite inferior indicado es mayor que el l√≠mite superior (LO_LIM > HI_LIM), el resultado se
escala de forma inversamente proporcional al valor de entrada.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

INT

I, Q, M, D, L, P

Valor de entrada que se es‚Äê
cala.

HI_LIM

Input

REAL

I, Q, M, D, L, P

Valor l√≠mite superior

LO_LIM

Input

REAL

I, Q, M, D, L, P

Valor l√≠mite inferior

BIPOLAR

Input

BOOL

I, Q, M, D, L

Indica si el valor del par√°me‚Äê
tro IN se interpreta como bi‚Äê
polar o unipolar. El par√°me‚Äê
tro puede adoptar los valores
siguientes:
1: Bipolar
0: Unipolar

OUT

Output

Valor de funci√≥n (RET_VAL)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

REAL

I, Q, M, D, L, P

Resultado de la instrucci√≥n

WORD

I, Q, M, D, L, P

Informaci√≥n de error

1951

Instrucciones
4.1 Instrucciones
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de Explicaci√≥n
error
(W#16#....)
0000

Ning√∫n error

0008

El valor del par√°metro IN es mayor que 27 648 o menor que 0 (unipolar) o -27 648 (bipolar).

Informa‚Äê
Consulte tambi√©n: "GET_ERR_ID: Consultar ID de error localmente"
ci√≥n de
error gene‚Äê
ral
*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_ErrorCode" := SCALE(IN := "Tag_InputValue",
HI_LIM := "Tag_HighLimit",
LO_LIM := "Tag_LowLimit",
BIPOLAR := "Tag_Bipolar",
OUT => "Tag_Result");

La informaci√≥n de error se devuelve en el operando "Tag_ErrorCode" como valor de funci√≥n.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

Tag_InputValue

22

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

OUT

Tag_Result

50.03978588

RET_VAL

Tag_ErrorCode

W#16#0000

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
GET_ERR_ID: Consultar ID de error localmente (P√°gina 1982)

1952

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Principios b√°sicos de SCL (P√°gina 8115)

UNSCALE: Desescalar
Descripci√≥n
La instrucci√≥n "Desescalar" permite desescalar el n√∫mero en coma flotante del par√°metro IN
en unidades f√≠sicas comprendidas entre un l√≠mite inferior y uno superior y convertirlo en un
n√∫mero entero. Los l√≠mites inferior y superior del rango de valores en el que se desescala el
valor de entrada se definen mediante los par√°metros LO_LIM y HI_LIM. El resultado de la
instrucci√≥n se devuelve en el par√°metro OUT.
La instrucci√≥n "Desescalar" utiliza la siguiente ecuaci√≥n:
OUT = [((IN‚ÄìLO_LIM)/(HI_LIM‚ÄìLO_LIM)) ‚àó (K2‚ÄìK1)] + K1
El estado l√≥gico del par√°metro BIPOLAR determina los valores de las constantes "K1" y "K2".
El par√°metro BIPOLAR puede tener los siguientes estados l√≥gicos:
‚óè Estado l√≥gico "1": se presupone que el valor del par√°metro IN es bipolar y est√° comprendido
en un rango de valores entre -27648 y 27648. En este caso, la constante "K1" tiene el valor
-27648,0, y la constante "K2", el valor +27648,0.
‚óè Estado l√≥gico "0": se presupone que el valor del par√°metro IN es unipolar y est√°
comprendido en un rango de valores entre 0 y 27648. En este caso, la constante "K1" tiene
el valor 0,0, y la constante "K2", el valor +27648,0.
Si el valor del par√°metro IN no se encuentra dentro de los l√≠mites definidos por HI_LIM y
LO_LIM, se emite un error. El resultado se ajusta al l√≠mite m√°s pr√≥ximo.
Si el l√≠mite inferior indicado es mayor que el l√≠mite superior (LO_LIM > HI_LIM), el resultado se
escala de forma inversamente proporcional al valor de entrada.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

REAL

I, Q, M, D, L, P

Valor de entrada que se de‚Äê
sescala en un valor entero.

HI_LIM

Input

REAL

I, Q, M, D, L, P

Valor l√≠mite superior

LO_LIM

Input

REAL

I, Q, M, D, L, P

Valor l√≠mite inferior

BIPOLAR

Input

BOOL

I, Q, M, D, L

Indica si el valor del par√°me‚Äê
tro IN se interpreta como bi‚Äê
polar o unipolar. El par√°me‚Äê
tro puede adoptar los valores
siguientes:
1: Bipolar
0: Unipolar

OUT

Output

Valor de funci√≥n (RET_VAL)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

INT

I, Q, M, D, L, P

Resultado de la instrucci√≥n

WORD

I, Q, M, D, L, P

Informaci√≥n de error

1953

Instrucciones
4.1 Instrucciones
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de Explicaci√≥n
error
(W#16#....)
0000

Ning√∫n error

0008

El valor del par√°metro IN es mayor que el del l√≠mite superior (HI_LIM) o menor que el del
l√≠mite inferior (LO_LIM).

Informa‚Äê
Consulte tambi√©n: "GET_ERR_ID: Consultar ID de error localmente"
ci√≥n de
error gene‚Äê
ral
*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n aqu√≠: Cambiar
formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:

"Tag_ErrorCode" := UNSCALE(IN := "Tag_InputValue",
HI_LIM := "Tag_HighLimit",
LO_LIM := "Tag_LowLimit",
BIPOLAR := "Tag_Bipolar",
OUT => "Tag_Result");

La informaci√≥n de error se devuelve en el operando "Tag_ErrorCode" como valor de funci√≥n.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

Tag_InputValue

50.03978588

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

OUT

Tag_Result

22

RET_VAL

Tag_ErrorCode

W#16#0000

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
GET_ERR_ID: Consultar ID de error localmente (P√°gina 1982)

1954

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Principios b√°sicos de SCL (P√°gina 8115)

Control del programa
IF: Ejecuci√≥n condicional
Descripci√≥n
La instrucci√≥n "Ejecuci√≥n condicional" permite ramificar el flujo del programa en funci√≥n de una
condici√≥n. La condici√≥n es una expresi√≥n con un valor booleano (TRUE o FALSE). Como
condici√≥n se pueden indicar expresiones l√≥gicas o expresiones de comparaci√≥n.
Al ejecutar la instrucci√≥n, se eval√∫an las expresiones indicadas. Si el valor de una expresi√≥n
es TRUE, la condici√≥n se considera cumplida; en el caso de FALSE se considera que la
condici√≥n no se cumple.

Par√°metros
Dependiendo del tipo de ramificaci√≥n se pueden programar las siguientes formas de la
instrucci√≥n:
‚óè Ramificaci√≥n con IF:
IF <condici√≥n> THEN <instrucciones>
END_IF;
Si se cumple la condici√≥n, se ejecutan las instrucciones que est√°n programadas despu√©s de
THEN. Si la condici√≥n no se cumple, el procesamiento del programa contin√∫a con la siguiente
instrucci√≥n despu√©s de END_IF.
‚óè Ramificaci√≥n con IF y ELSE:
IF <condici√≥n> THEN <instrucciones1>
ELSE <Instrucciones0>
END_IF;
Si se cumple la condici√≥n, se ejecutan las instrucciones que est√°n programadas despu√©s de
THEN. Si no se cumple la condici√≥n, se ejecutan las instrucciones que est√°n programadas
despu√©s de ELSE. Despu√©s, el procesamiento del programa contin√∫a con la siguiente
instrucci√≥n despu√©s de END_IF.
‚óè Ramificaci√≥n con IF, ELSIF y ELSE:
IF <condici√≥n1> THEN <instrucciones1>
IF <condici√≥n2> THEN <instrucciones2>
ELSE <Instrucciones0>
END_IF;
Si se cumple la primera condici√≥n (<condici√≥n1>), se ejecutan las instrucciones
(<instrucciones1>) despu√©s de THEN. Despu√©s de ejecutar las instrucciones, el
procesamiento del programa contin√∫a despu√©s de END_IF.
Si no se cumple la primera condici√≥n, se comprueba la segunda (<condici√≥n2>). Si se cumple
la segunda condici√≥n (<condici√≥n2>), se ejecutan las instrucciones (<instrucciones2>)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1955

Instrucciones
4.1 Instrucciones
despu√©s de THEN. Despu√©s de ejecutar las instrucciones, el procesamiento del programa
contin√∫a despu√©s de END_IF.
Si no se cumple ninguna condici√≥n, se ejecutan las instrucciones (<instrucciones0> despu√©s
de ELSE y, a continuaci√≥n, contin√∫a el procesamiento del programa despu√©s de END_IF.
En una instrucci√≥n IF se pueden anidar tantas combinaciones de ELSIF y THEN como se
desee. La programaci√≥n de una rama ELSE es opcional.
La sintaxis de la instrucci√≥n IF se compone de las siguientes partes:
Par√°metro

Tipo de datos √Årea de memoria

Descripci√≥n

<Condici√≥n>

BOOL

Expresi√≥n que se eval√∫a.

<Instruccio‚Äê
nes>

-

I, Q, M, D, L

Instrucciones que se ejecutan si se cumple la con‚Äê
dici√≥n. Una excepci√≥n son las instrucciones que
est√°n programadas despu√©s de ELSE. Estas se
ejecutan si no se cumple ninguna condici√≥n dentro
del bucle.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
IF "Tag_1" = 1
THEN "Tag_Value" :=
ELSIF "Tag_2" = 1
THEN "Tag_Value" :=
ELSIF "Tag_3" = 1
THEN "Tag_Value" :=
ELSE "Tag_Value" :=
END_IF;

10;
20;
30;
0;

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_1

1

0

0

0

Tag_2

0

1

0

0

Tag_3

0

0

1

0

Tag_Value

10

20

30

0

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

1956

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CASE: Estructura selectiva m√∫ltiple
Descripci√≥n
La instrucci√≥n "Estructura selectiva m√∫ltiple" permite procesar una de varias secuencias de
instrucciones en funci√≥n del valor de una expresi√≥n.
El valor de la expresi√≥n puede ser un n√∫mero entero o una secuencia de bits. Al ejecutar la
instrucci√≥n CASE se compara el valor de la expresi√≥n (variable) con los valores de varias
constantes. Si el valor de la expresi√≥n (variable) coincide con el de una constante, se cumple
la condici√≥n y se ejecutan las instrucciones que est√°n programadas directamente despu√©s de
esta constante. Al hacerlo, las constantes pueden adoptar distintos valores.
La instrucci√≥n se puede declarar del siguiente modo:
CASE <Variable> OF
<Constante1>: <Instrucciones1>;
<Constante2>: <Instrucciones2>;
<ConstanteX>: <InstruccionesX>; // X >= 3
ELSE <Instrucciones0>;
END_CASE;

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1957

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Tipo de datos √Årea de memoria

Descripci√≥n

<Variable>

Secuencias
de bits, ente‚Äê
ros

I, Q, M, D, L

Valor que se compara con los valores de constan‚Äê
tes programados.

<Constante>

Secuencias
de bits

-

En el caso de una secuencia de bits, las constan‚Äê
tes pueden adoptar los siguientes valores:

Pueden pro‚Äê
gramarse
constantes
locales y glo‚Äê
bales.

‚óè N√∫mero binario (p. ej., 2#10)
‚óè N√∫mero octal (p. ej., 8#77)
‚óè N√∫mero hexadecimal (p. ej., 16#AD)
‚óè Constante sin tipo (p. ej., 1000)
En caso de una variable Byte tipificada, deben
programarse constantes Byte (p. ej., BYTE#2).
En caso de una variable Word tipificada, pueden
programarse constantes Byte o Word (p. ej.,
BYTE#2, WORD#2).
En caso de una variable DWord tipificada, pueden
programarse constantes Byte, Word o DWord
(p. ej., BYTE#2, WORD#2, DWORD#2).
En caso de una variable LWord tipificada, pueden
programarse constantes Byte, Word, DWord o
LWord (p. ej., BYTE#2, WORD#2, DWORD#2,
LWORD#2).
Enteros

En el caso de un n√∫mero entero, las constantes
pueden adoptar los siguientes valores:
‚óè un n√∫mero entero (p. ej., 5)
‚óè un rango de enteros (p. ej., 15 a 20)
‚óè una enumeraci√≥n de n√∫meros enteros y
rangos (p. ej., 10, 11, 15..20)

<Instrucci√≥n> -

-

Cualquier instrucci√≥n que se ejecuta si el valor de
la expresi√≥n coincide con el valor de una constan‚Äê
te. Una excepci√≥n son las instrucciones que est√°n
programadas despu√©s de ELSE. Estas se ejecu‚Äê
tan cuando los valores no coinciden.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".
Si el valor de la expresi√≥n coincide con el valor de la primera constante (<Constante1>), se
ejecutan las instrucciones (<instrucciones1>) que est√°n programadas directamente despu√©s
de la primera constante. Luego, el procesamiento del programa contin√∫a despu√©s de
END_CASE.
Si el valor de la expresi√≥n no coindice con el valor de la primera constante (<Constante1), este
se compara con el valor de la constante que est√° programada a continuaci√≥n. De esta manera
la instrucci√≥n CASE se ejecuta hasta que coincidan los valores. Si el valor de la expresi√≥n no
se corresponde con ninguno de los valores programados de las constantes, se ejecutan las
instrucciones (<instrucciones0>) que est√°n programadas despu√©s de ELSE. ELSE es una
parte opcional de la sintaxis y se puede omitir.

1958

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucci√≥n CASE tambi√©n se puede anidar sustituyendo un bloque de instrucciones por
CASE. END_CASE cierra la instrucci√≥n CASE.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
CASE "Tag_Value" OF
0 :
"Tag_1" :=
1,3,5 :
"Tag_2" :=
6..10 :
"Tag_3" :=
16,17,20..25 :
"Tag_4" :=
ELSE
"Tag_5" :=
END_CASE;

1;
1;
1;
1;
1;

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valores

Tag_Value

0

1, 3 , 5

6, 7, 8, 9, 10

16,17, 20, 21,
22, 23, 24, 25

2

Tag_1

1

-

-

-

-

Tag_2

-

1

-

-

-

Tag_3

-

-

1

-

-

Tag_4

-

-

-

1

-

Tag_5

-

-

-

-

1

1: El operando se pone al estado l√≥gico "1".
-: El estado l√≥gico del operando permanece sin cambios.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

FOR: Ejecutar en bucle contador
Descripci√≥n
La instrucci√≥n "Ejecutar en bucle contador" permite procesar un bucle mientras la variable de
contaje se encuentre dentro del rango de valores indicado.
Los bucles tambi√©n se pueden anidar. Dentro de un bucle se pueden programar otros bucles
con otras variables de contaje.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1959

Instrucciones
4.1 Instrucciones
La ejecuci√≥n actual de un bucle se puede finalizar con la instrucci√≥n "Verificar condici√≥n de
bucle" (CONTINUE). La instrucci√≥n "Abandonar el bucle inmediatamente" (EXIT) permite
finalizar el procesamiento de todo el bucle. Encontrar√° m√°s informaci√≥n al respecto en
"Consulte tambi√©n".
Nota
Informaci√≥n sobre el n√∫mero de ejecuciones y sobre la variable de control
El n√∫mero de ejecuciones no puede modificarse durante la ejecuci√≥n del programa.
Por motivos de rendimiento, la variable de control debe declararse en la secci√≥n "Temp" de la
interfaz del bloque. Tampoco es posible modificar la variable de control desde el propio bucle.
El ejemplo siguiente tendr√≠a pues un error de sintaxis, por lo que no se podr√≠a compilar:
FOR #i := 1 TO 10 DO
#i := #i + 1;
END_FOR;

Valores l√≠mite para instrucciones FOR
Para programar instrucciones FOR "seguras" que no se ejecuten de manera infinita, tenga en
cuenta las siguientes reglas y los siguientes valores l√≠mite:
FOR <variable de contaje> := <valor inicial> TO <valor final> BY <incremento> DO
<instrucciones>;
END_FOR;
Si...

... entonces

Observaci√≥n

Valor inicial < valor final

Valor final < (PMAX - paso)

La variable de contaje cuenta en
sentido positivo

Valor inicial > valor final AND in‚Äê Valor final > (NMAX - paso)
cremento < O

La variable de contaje cuenta en
sentido negativo

Nota
Uso de tipo de datos y sentido de ejecuci√≥n
No est√° permitido combinar enteros con y sin signo en una instrucci√≥n FOR.
En caso de utilizar enteros sin signo tampoco es posible programar un bucle en sentido
negativo.
Valores l√≠mite
Para los tipos de datos posibles son v√°lidos diferentes valores l√≠mite:
Tipo de datos

PMAX

Variable de contaje del tipo SINT 127
Variable de contaje del tipo INT

32767

Variable de contaje del tipo DINT 2147483647

1960

NMAX
-128
-32768
-2147483648

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tipo de datos

PMAX

NMAX

Variable de contaje del tipo LINT 9223372036854775807

-9223372036854775808

Variable de recuento del tipo
USINT

255

-

Variable de recuento del tipo
UINT

65535

-

Variable de recuento del tipo
UDINT

4294967295

-

Variable de recuento del tipo
ULINT

18446744073709551615

-

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Tipo de datos
S7-1200

S7-1500

√Årea de me‚Äê
moria

Descripci√≥n

<Variable
SINT, INT,
de contaje> DINT,
USINT,
UINT, UDINT

SINT, INT,
DINT, LINT,
USINT, UINT,
UDINT, ULINT

I, Q, M, D, L

Operando, cuyo valor se eval√∫a du‚Äê
rante el procesamiento del bucle. El
tipo de datos de la variable de contaje
determina el tipo de datos de los pa‚Äê
r√°metros restantes.

<Valor ini‚Äê
cial>

SINT, INT,
DINT,
USINT,
UINT, UDINT

SINT, INT,
DINT, LINT,
USINT, UINT,
UDINT, ULINT

I, Q, M, D, L

Expresi√≥n, cuyo valor se asigna a la
variable de contaje al comienzo del
procesamiento del bucle.

<Valor fi‚Äê
nal>

SINT, INT,
DINT,
USINT,
UINT, UDINT

SINT, INT,
DINT, LINT,
USINT, UINT,
UDINT, ULINT

I, Q, M, D, L

Expresi√≥n, cuyo valor determina la √∫l‚Äê
tima ejecuci√≥n del bucle. Antes de ca‚Äê
da ejecuci√≥n del bucle se comprueba
qu√© valor tiene la variable de contaje:
‚óè Valor final no alcanzado:
Se ejecutar√°n las instrucciones
seg√∫n DO
‚óè Valor final alcanzado:
El bucle FOR se ejecuta por √∫ltima
vez
‚óè Valor final sobrepasado:
El bucle FOR finaliza
No se puede modificar el valor final
durante la ejecuci√≥n de la instrucci√≥n.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1961

Instrucciones
4.1 Instrucciones
Par√°metro

Tipo de datos
S7-1200

<Incremen‚Äê SINT, INT,
to>
DINT,
USINT,
UINT, UDINT

S7-1500
SINT, INT,
DINT, LINT,
USINT, UINT,
UDINT, ULINT

√Årea de me‚Äê
moria

Descripci√≥n

I, Q, M, D, L

Expresi√≥n, en cuyo valor aumenta (in‚Äê
cremento positivo) o disminuye (incre‚Äê
mento negativo) la variable de contaje
despu√©s de cada ejecuci√≥n del bucle.
La indicaci√≥n del incremento es opcio‚Äê
nal. Si no se ha indicado ning√∫n incre‚Äê
mento, el valor de la variable de con‚Äê
taje aumenta en 1 despu√©s de cada
ejecuci√≥n del bucle.
No se puede modificar el incremento
durante la ejecuci√≥n de la instrucci√≥n.

<Instruccio‚Äê nes>

-

Instrucciones que se ejecutan durante
cada ejecuci√≥n del bucle mientras el
valor de la variable de control se en‚Äê
cuentre en el rango de valores. El ran‚Äê
go de valores se especifica mediante
los valores inicial y final.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
FOR i := 2 TO 8 BY 2
DO "a_array[i] := "Tag_Value"*"b_array[i]";
END_FOR;

El operando "Tag_Value" se multiplica por los elementos (2, 4, 6, 8) de las variables ARRAY
"b_array". El resultado se lee en los elementos (2, 4, 6, 8) de las variables ARRAY "a_array".

Consulte tambi√©n
CONTINUE: Verificar condici√≥n de bucle (P√°gina 1965)
EXIT: Abandonar el bucle inmediatamente (P√°gina 1966)
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

WHILE: Ejecutar cuando se cumpla la condici√≥n
Descripci√≥n
La instrucci√≥n "Ejecutar cuando se cumpla la condici√≥n" permite procesar un bucle mientras se
cumpla una condici√≥n de ejecuci√≥n. La condici√≥n es una expresi√≥n con un valor booleano
(TRUE o FALSE). Como condici√≥n se pueden indicar expresiones l√≥gicas o expresiones de
comparaci√≥n.

1962

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Al ejecutar la instrucci√≥n, se eval√∫an las expresiones indicadas. Si el valor de una expresi√≥n
es TRUE, la condici√≥n se considera cumplida; en el caso de FALSE se considera que la
condici√≥n no se cumple.
Los bucles tambi√©n se pueden anidar. Dentro de un bucle se pueden programar otros bucles
con otras variables de contaje.
La ejecuci√≥n actual de un bucle se puede finalizar con la instrucci√≥n "Verificar condici√≥n de
bucle" (CONTINUE). La instrucci√≥n "Abandonar el bucle inmediatamente" (EXIT) permite
finalizar el procesamiento de todo el bucle. Encontrar√° m√°s informaci√≥n al respecto en
"Consulte tambi√©n".
La instrucci√≥n se puede declarar del siguiente modo:
WHILE <condici√≥n> DO <instrucciones>;
END_WHILE;

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Tipo de datos √Årea de memoria

Descripci√≥n

<Condici√≥n>

BOOL

Expresi√≥n que se eval√∫a antes de cada ejecuci√≥n
del bucle.

<Instruccio‚Äê
nes>

-

I, Q, M, D, L

Instrucciones que se ejecutan si se cumple la con‚Äê
dici√≥n. Si no se cumple la condici√≥n, el procesa‚Äê
miento del programa contin√∫a despu√©s de
END_WHILE.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
WHILE
"Tag_Value1" <> "Tag_Value2"
DO "Tag_Result"
:= "Tag_Input";
END_WHILE:

Mientras difieran los valores de los operandos "Tag_Value1" y "Tag_Value2", al operando
"Tag_Result" se le asignar√° el valor del operando "Tag_Input".

Consulte tambi√©n
EXIT: Abandonar el bucle inmediatamente (P√°gina 1966)
CONTINUE: Verificar condici√≥n de bucle (P√°gina 1965)
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1963

Instrucciones
4.1 Instrucciones

REPEAT: Ejecutar cuando no se cumpla la condici√≥n
Descripci√≥n
La instrucci√≥n "Ejecutar cuando no se cumpla la condici√≥n" permite procesar un bucle mientras
no se cumpla una condici√≥n de interrupci√≥n. La condici√≥n es una expresi√≥n con un valor
booleano (TRUE o FALSE). Como condici√≥n se pueden indicar expresiones l√≥gicas o
expresiones de comparaci√≥n.
Al ejecutar la instrucci√≥n, se eval√∫an las expresiones indicadas. Si el valor de una expresi√≥n
es TRUE, la condici√≥n se considera cumplida; en el caso de FALSE se considera que la
condici√≥n no se cumple.
Las instrucciones se ejecutan una vez aunque se cumpla la condici√≥n de interrupci√≥n.
Los bucles tambi√©n se pueden anidar. Dentro de un bucle se pueden programar otros bucles
con otras variables de contaje.
La ejecuci√≥n actual de un bucle se puede finalizar con la instrucci√≥n "Verificar condici√≥n de
bucle" (CONTINUE). La instrucci√≥n "Abandonar el bucle inmediatamente" (EXIT) permite
finalizar el procesamiento de todo el bucle. Encontrar√° m√°s informaci√≥n al respecto en
"Consulte tambi√©n".
La instrucci√≥n se puede declarar del siguiente modo:
REPEAT <instrucciones>;
UNTIL <condici√≥n> END_REPEAT;

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Tipo de datos √Årea de memoria

Descripci√≥n

<Instruccio‚Äê
nes>

-

Instrucciones que se ejecutan mientras la condi‚Äê
ci√≥n programada tenga el valor FALSE. Las ins‚Äê
trucciones se ejecutan una vez aunque se cumpla
la condici√≥n de interrupci√≥n.

<Condici√≥n>

BOOL

I, Q, M, D, L

Expresi√≥n que se eval√∫a despu√©s de cada ejecu‚Äê
ci√≥n del bucle. Si la expresi√≥n tiene el valor FAL‚Äê
SE, el bucle se procesa de nuevo. Si la expresi√≥n
tiene el valor TRUE, el procesamiento del progra‚Äê
ma contin√∫a despu√©s de END_REPEAT.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
REPEAT "Tag_Result"
:= "Tag_Value";
UNTIL "Tag_Error"
END_REPEAT;

1964

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Mientras el valor del operando "Tag_Error" tenga el estado l√≥gico "0", se le asignar√° al
operando "Tag_Result" el valor del operando "Tag_Value".

Consulte tambi√©n
CONTINUE: Verificar condici√≥n de bucle (P√°gina 1965)
EXIT: Abandonar el bucle inmediatamente (P√°gina 1966)
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

CONTINUE: Verificar condici√≥n de bucle
Descripci√≥n
La instrucci√≥n "Verificar condici√≥n de bucle" permite finalizar la ejecuci√≥n actual de un bucle
FOR, WHILE o REPEAT.
Despu√©s de ejecutar la instrucci√≥n, se eval√∫an de nuevo las condiciones para continuar el
bucle. La instrucci√≥n tiene efecto sobre el bucle que incluye directamente la instrucci√≥n.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
FOR i
:= 1 TO 15 BY 2 DO
IF (i < 5) THEN
CONTINUE;
END_IF;
"DB10".Test[i] := 1;
END_FOR;

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".
Si se cumple la condici√≥n i < 5, no se ejecuta la siguiente asignaci√≥n de valor
("DB10".Test[i] :=1). La variable de contaje (i) se incrementa en "2" y se comprueba si su valor
actual se encuentra en el rango de valores programados. Si la variable de contaje se encuentra
en el rango de valores, se eval√∫a de nuevo una condici√≥n IF.
Si no se cumple la condici√≥n i < 5, se ejecuta la siguiente asignaci√≥n de valor ("DB10".Test[i] :=
1) y se inicia una nueva ejecuci√≥n del bucle. La variable de control tambi√©n se aumenta con el
incremento "2" y se comprueba.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1965

Instrucciones
4.1 Instrucciones

EXIT: Abandonar el bucle inmediatamente
Descripci√≥n
La instrucci√≥n "Abandonar el bucle inmediatamente" permite interrumpir en cualquier punto la
ejecuci√≥n de un bucle FOR, WHILE o REPEAT independientemente de las condiciones. El
procesamiento del programa contin√∫a despu√©s finalizar el bucle (END_FOR, END_WHILE,
END_REPEAT).
La instrucci√≥n tiene efecto sobre el bucle que incluye directamente la instrucci√≥n.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
FOR i := 15 TO 1 BY -2 DO
IF (i < 5)
THEN EXIT;
END_IF;
"DB10".Test[i] := 1;
END_FOR;

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".
Si se cumple la condici√≥n i < 5, se interrumpe el procesamiento del bucle. El procesamiento
contin√∫a despu√©s de END_FOR.
Si no se cumple la condici√≥n i < 5, se ejecuta la siguiente asignaci√≥n de valor
("DB10".Test[i] :=1) y se inicia una nueva ejecuci√≥n del bucle. La variable de contaje (i) se
decrementa en "-2" y se comprueba si su valor actual se encuentra en el rango de valores
programados. Si la variable de control (i) se encuentra en el rango de valores, la condici√≥n IF
se eval√∫a de nuevo.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

GOTO: Saltar
Descripci√≥n
La instrucci√≥n "Saltar" permite continuar el procesamiento del programa en un punto marcado
con una etiqueta.
La etiqueta y la instrucci√≥n "Saltar" deben estar en el mismo bloque. La denominaci√≥n de la
etiqueta debe ser un√≠voca en un bloque. A toda etiqueta pueden acceder distintas
instrucciones de salto.
No se permite saltar a un bucle desde "fuera", pero s√≠ es posible saltar desde un bucle hacia
"fuera".

1966

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para la etiqueta deben observarse las siguientes reglas gramaticales:
‚óè Letras (a - z, A - Z)
‚óè Una combinaci√≥n de letras y n√∫meros. Es importante observar el orden, es decir, primero
las letras y despu√©s los n√∫meros (a - z, A - Z, 0 - 9).
‚óè No pueden utilizarse caracteres especiales o una combinaci√≥n de letras y n√∫meros en
orden inverso, es decir, primero los n√∫meros y despu√©s las letras (0 - 9, a - z, A - Z).
La instrucci√≥n se puede declarar del siguiente modo:
GOTO <Etiqueta>;
...
<Etiqueta>: <Instrucciones>

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Tipo de datos

Descripci√≥n

<Etiqueta>

-

Etiqueta a la que se salta

<Instrucciones>

-

Instrucciones que se ejecutan despu√©s del salto.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
CASE "Tag_Value" OF
1 : GOTO MyLABEL1;
2 : GOTO MyLABEL2;
3 : GOTO MyLABEL3;
ELSE GOTO MyLABEL4;
END_CASE;
MyLABEL1: "Tag_1" := 1;
MyLABEL2: "Tag_2" := 1;
MyLABEL3: "Tag_3" := 1;
MyLABEL4: "Tag_4" := 1;

Dependiendo del valor del operando "Tag_Value", el procesamiento del programa se contin√∫a
en el punto marcado por la etiqueta correspondiente. Por ejemplo, si el operando "Tag_Value"
tiene el valor "2", el procesamiento del programa contin√∫a a partir de la etiqueta "MyLABEL2".
En este caso, la l√≠nea del programa marcada con la etiqueta "MyLABEL1" se omite.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1967

Instrucciones
4.1 Instrucciones

RETURN: Abandonar el bloque
Descripci√≥n
La instrucci√≥n "Abandonar el bloque" permite finalizar el procesamiento del programa en el
bloque que se est√° ejecutando y continuar en el bloque invocante.
En el fin del bloque se puede omitir la instrucci√≥n.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
IF "Tag_Error" <>0 THEN RETURN;
END_IF;

Si el estado l√≥gico del operando "Tag_Error" no es igual a cero, el procesamiento del programa
se finaliza en el bloque que se est√° procesando.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

(*...*): Insertar secci√≥n de comentario
Descripci√≥n
La instrucci√≥n "Insertar secci√≥n de comentario" permite insertar una secci√≥n de comentario. El
texto encerrado entre par√©ntesis (*...*) se trata como un comentario.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
(*Esta es una secci√≥n de comentario.*)

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

1968

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

(/*...*/): Insertar comentario multiling√ºe
Descripci√≥n
Con la instrucci√≥n "Insertar comentario multiling√ºe" se inserta un comentario que puede
traducirse a otros idiomas del proyecto. Un comentario multiling√ºe se inicia con "(/*" y se cierra
con "*/)", lo que lo convierte en una unidad. Esto significa que, en cualquier caso, solo se puede
marcar o seleccionar el comentario entero y no partes por separado. Los comentarios
multiling√ºes no pueden anidarse unos dentro de otros, pero pueden utilizarse dentro de
comentarios de l√≠neas y secciones de comentarios. A diferencia de ello, no es posible emplear
comentarios de l√≠neas o secciones de comentarios sencillas dentro de comentarios
multiling√ºes, ya que todo lo incluido entre "(/*" y "*/)" se interpreta como texto normal.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
(/*Este es un comentario que puede traducirse a otros idiomas del
proyecto.*/)

Consulte tambi√©n
Inserci√≥n de comentarios (P√°gina 8179)

REGION: Estructurar el c√≥digo del programa
Descripci√≥n
La instrucci√≥n "Estructurar el c√≥digo del programa" permite estructurar el c√≥digo del programa
en un bloque SCL dividi√©ndolo en diferentes √°reas.
Encontrar√° m√°s informaci√≥n sobre c√≥mo trabajar con √°reas aqu√≠: Trabajar con √°reas
(P√°gina 8153)
La instrucci√≥n se puede declarar del siguiente modo:
REGION <Nombre>
<Instrucciones>
END_REGION

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1969

Instrucciones
4.1 Instrucciones

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Tipo de datos

√Årea de memoria

Descripci√≥n

REGION

-

-

Palabra clave con la
que empieza el √°rea

<Nombre>

-

-

Texto que designa RE‚Äê
GION

<Instrucciones>

-

-

C√≥digo de programa
que comprende RE‚Äê
GION

END_REGION

-

-

Palabra clave con la
que finaliza el √°rea

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
REGION Feeder System
// Estructura el c√≥digo fuente para el sistema de alimentaci√≥n
IF "Variable_1" = 0 THEN
"Variable_2" := 10;
END_IF;
END_REGION

El √°rea Feeder System abarca el c√≥digo del programa completo.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Control del tiempo de ejecuci√≥n
ENDIS_PW: Limitar y habilitar legitimaci√≥n de la contrase√±a
Descripci√≥n
La instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a" permite definir si las
contrase√±as configuradas para la CPU est√°n legitimadas o no. Con ello, se pueden impedir
conexiones legitimadas, aun conociendo la contrase√±a correcta.
Si se llama la instrucci√≥n y el par√°metro REQ tiene el estado l√≥gico "0", en los par√°metros de
salida se muestra el estado ajustado en ese momento. Si se han realizado cambios en los
par√°metros de entrada, estos no se transfieren a los par√°metros de salida.

1970

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si se ejecuta la instrucci√≥n y el par√°metro REQ tiene el estado l√≥gico "1", se aplica el estado
l√≥gico de los par√°metros de entrada (F_PWD, FULL_PWD, R_PWD, HMI_PWD):
‚óè Con el estado l√≥gico "0", no est√° permitida la legitimaci√≥n por contrase√±a.
‚óè Con el estado l√≥gico "1" se puede utilizar la contrase√±a.
Es posible permitir o prohibir individualmente el bloqueo o la habilitaci√≥n de las contrase√±as.
Por ejemplo, pueden prohibirse todas las contrase√±as excepto la contrase√±a de seguridad
positiva. Esto permite limitar las posibilidades de acceso a un reducido grupo de usuarios. Los
par√°metros de salida (F_PWD_ON, FULL_PWD_ON, R_PWD_ON, HMI_PWD_ON) siempre
muestran el estado actual del uso de contrase√±as, independientemente del par√°metro REQ.
Las contrase√±as no configuradas deben tener el estado l√≥gico TRUE en la entrada y devolver
el estado l√≥gico TRUE en la salida. La contrase√±a de seguridad solo puede parametrizarse
para una CPU F y por eso en una CPU est√°ndar debe interconectarse siempre con el estado
l√≥gico TRUE. Si la instrucci√≥n devuelve un error, la llamada permanece sin efecto, es decir, el
bloqueo anterior sigue en vigor.
Las contrase√±as bloqueadas pueden volver a habilitarse en las condiciones siguientes:
‚óè Se ha restablecido la configuraci√≥n de f√°brica de la CPU.
‚óè El panel frontal de la CPU S7-1500 soporta un cuadro de di√°logo que permite navegar al
men√∫ adecuado y volver a habilitar las contrase√±as.
‚óè Cuando se llama la instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a", el
par√°metro de entrada de la contrase√±a deseada tiene el estado l√≥gico "1".
‚óè Ponga el selector de modo a STOP. La restricci√≥n de la legitimaci√≥n de contrase√±a se
activa de nuevo en cuanto se mueve el selector nuevamente a RUN.
‚óè La inserci√≥n de una tarjeta de memoria vac√≠a (tarjeta de transferencia o tarjeta de
programa) en una CPU S7-1200.
‚óè La transici√≥n de POWER OFF-POWER ON desactiva la protecci√≥n en la CPU S7-1200. La
instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a" debe volverse a llamar en el
programa (por ejemplo en el OB de arranque).
Nota
Si la contrase√±a HMI no est√° habilitada, la instrucci√≥n "Limitar y habilitar legitimaci√≥n de la
contrase√±a" bloquea el acceso de los sistemas HMI.
Nota
Las conexiones ya existentes y legitimadas conservan sus derechos de acceso y no pueden
limitarse con la instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a".

Impedir el bloqueo no intencionado en una CPU S7-1500
Los ajustes pueden realizarse en el panel frontal de la CPU, que guarda el √∫ltimo ajuste en
cada caso.
Para impedir un bloqueo no intencionado, en una CPU S7-1500 es posible desactivar la
protecci√≥n moviendo el selector de modo a STOP. La protecci√≥n se activa autom√°ticamente
despu√©s de mover el selector de modo a RUN sin que tenga que volver a llamarse la
Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1971

Instrucciones
4.1 Instrucciones
instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a" o deban realizarse otras acciones
en el panel frontal.

Impedir el bloqueo no intencionado en una CPU S7-1200
Como la CPU S7-1200 no dispone de selector de modo, la protecci√≥n se desactiva con
POWER OFF-POWER ON. De este modo es posible y recomendable impedir el bloqueo no
intencionado con ayuda de determinadas secuencias en el programa.
Para ello, programe un control de tiempo, ya sea mediante un OB de alarma c√≠clica o un
temporizador en el Main OB (OB 1). De este modo, tras una transici√≥n de POWER OFFPOWER ON y la consiguiente desactivaci√≥n de la protecci√≥n, se puede volver a llamar
r√°pidamente la instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a" en el OB
correspondiente (por ejemplo OB 1 u OB 35). Para que la ventana temporal en la que la
instrucci√≥n no est√° activa y en la que por tanto no existen limitaciones en la legitimaci√≥n de la
contrase√±a sea lo m√°s peque√±a posible, llame la instrucci√≥n en el OB de arranque (OB 100).
Este procedimiento ofrece la mayor protecci√≥n posible contra accesos no autorizados.
Si se ha producido un bloqueo no intencionado, puede omitirse la llamada en el OB de
arranque (por ejemplo mediante consulta de un par√°metro de entrada) y se dispondr√° del
tiempo configurado (por ejemplo de 10 segundos a 1 minuto) para establecer una conexi√≥n con
la CPU antes de que el bloqueo vuelva a activarse.
Si no se ha previsto ning√∫n temporizador en el c√≥digo del programa y se produce un bloqueo,
inserte en la CPU una tarjeta de transferencia o una tarjeta de programa vac√≠a. La tarjeta de
transferencia o la tarjeta de programa vac√≠a borra la memoria de carga interna de la CPU.
Despu√©s deber√° cargarse nuevamente el programa de usuario de STEP 7 en la CPU.

Procedimiento en caso de p√©rdida de contrase√±a en una CPU S7-1200
Si ha perdido la contrase√±a de una CPU S7-1200 protegida por contrase√±a, borre el programa
protegido por contrase√±a con una tarjeta de transferencia o una tarjeta de programa vac√≠a. La
tarjeta de transferencia o la tarjeta de programa vac√≠a borra la memoria de carga interna de la
CPU. A continuaci√≥n, puede transferir un nuevo programa de usuario de STEP 7 Basic a la
CPU.
ADVERTENCIA
Inserci√≥n de una tarjeta de transferencia vac√≠a
Cuando se inserta una tarjeta de transferencia en una CPU en funcionamiento, la CPU pasa
a STOP. En caso de estados operativos no seguros, los controladores pueden fallar y, con
ello, provocar un funcionamiento descontrolado de los dispositivos que se controlan. El
resultado es un funcionamiento impredecible del sistema de automatizaci√≥n, que puede
provocar lesiones mortales o graves, as√≠ como da√±os materiales.
El contenido de la tarjeta de transferencia se encuentra en la memoria de carga interna
despu√©s de su extracci√≥n. Compruebe aqu√≠ que la tarjeta no contenga ning√∫n programa.

1972

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
ADVERTENCIA
Inserci√≥n de una tarjeta de programa vac√≠a
Cuando se inserta una tarjeta de programa en una CPU en funcionamiento, la CPU pasa a
STOP. En caso de estados operativos no seguros, los controladores pueden fallar y, con ello,
provocar un funcionamiento descontrolado de los dispositivos que se controlan. El resultado
es un funcionamiento impredecible del sistema de automatizaci√≥n, que puede provocar
lesiones mortales o graves, as√≠ como da√±os materiales.
Aseg√∫rese de que la tarjeta de programa est√© vac√≠a. La memoria de carga interna se copiar√°
en la tarjeta de programa vac√≠a. Despu√©s de retirar la tarjeta de programa previamente vac√≠a,
la memoria de carga interna quedar√° vac√≠a.
Debe retirarse la tarjeta de transferencia o la tarjeta de programa antes de poner la CPU en
RUN.

Efectos del uso de contrase√±as en los modos de operaci√≥n
La siguiente tabla muestra qu√© efectos tiene el uso de contrase√±as en los modos de operaci√≥n
y en las respectivas acciones del usuario mediante la instrucci√≥n "Limitar y habilitar
legitimaci√≥n de la contrase√±a".
Acci√≥n

Protecci√≥n por contrase√±a mediante la instruc‚Äê
ci√≥n

Estado b√°sico despu√©s de

No activado

‚óè Selector de modo en STOP

(sin limitaciones)

‚óè Restablecimiento manual de la memoria (PG,
interruptor, cambio de MC (Motion Control))
‚óè Restablecimiento de la configuraci√≥n de f√°brica
Estado b√°sico tras conexi√≥n (POWER ON)

‚óè CPU S7-1200:
El bloqueo est√° desactivado y la
instrucci√≥n tiene que volverse a ejecutar
en el programa (por ejemplo en el OB de
arranque).
‚óè CPU S7-1500:
Activada (si antes de la desconexi√≥n
(POWER OFF) hab√≠a un bloqueo activo)
La posibilidad de no permitir contrase√±as
es remanente.

Activado
Transici√≥n del estado operativo RUN/ARRANQUE/
PARADA -> STOP (mediante finalizaci√≥n de la ins‚Äê
Las contrase√±as siguen sin poder utilizarse.
trucci√≥n, un error o comunicaci√≥n) o STOP -> ARRAN‚Äê
QUE/RUN/PARADA

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1973

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

REQ

Input

BOOL

I, Q, M, D, L o
constante

Si el par√°metro REQ tiene el
estado l√≥gico "0", se consulta
el estado l√≥gico ajustado ac‚Äê
tualmente para las contrase‚Äê
√±as.

F_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura/escritura
incluido failsafe
‚óè F_PWD = "0": No permitir
contrase√±a
‚óè F_PWD = "1": Permitir
contrase√±a

FULL_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura/escritura
‚óè FULL_PWD = "0": No
permitir contrase√±a
‚óè FULL_PWD = "1":
Permitir contrase√±a

R_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura
‚óè R_PWD = "0": No permitir
contrase√±a
‚óè R_PWD = "1": Permitir
contrase√±a

HMI_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso a la HMI
‚óè HMI_PWD = "0": No
permitir contrase√±a
‚óè HMI_PWD = "1": Permitir
contrase√±a

F_PWD_ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura/
escritura incluido failsafe
‚óè F_PWD_ON = "0":
Contrase√±a no permitida
‚óè F_PWD_ON = "1":
Contrase√±a permitida

FULL_PWD_
ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura/
escritura
‚óè FULL_PWD_ON = "0":
Contrase√±a no permitida
‚óè FULL_PWD_ON = "1":
Contrase√±a permitida

R_PWD_ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura
‚óè R_PWD_ON = "0":
Contrase√±a no permitida
‚óè R_PWD_ON = "1":
Contrase√±a permitida

1974

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

HMI_PWD_O Output
N

Tipo de datos

√Årea de memoria

Descripci√≥n

BOOL

I, Q, M, D, L

Estado del acceso a la HMI
‚óè HMI_PWD_ON = "0":
Contrase√±a no permitida
‚óè HMI_PWD_ON = "1":
Contrase√±a permitida

Valor de funci√≥n (RET_VAL)

WORD

I, Q, M, D, L

Informaci√≥n de error

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
0000

Ning√∫n error

8090

No se soporta la instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a".

80D0

La contrase√±a de seguridad no est√° configurada. En las CPU est√°ndar, el estado l√≥gico
tiene que ser TRUE.

80D1

El acceso de lectura/escritura no est√° configurado

80D2

El acceso de lectura no est√° configurado

80D3

El acceso HMI no est√° configurado

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := ENDIS_PW(REQ := 0,
F_PWD := 0,
FULL_PWD := 0,
R_PWD := 1,
HMI_PWD := 0,
F_PWD_ON => "Status_F_PWD",
FULL_PWD_ON => "Status_FULL_PWD",
R_PWD_ON => "Status_R_PWD",
HMI_PWD_ON => "Status_HMI_PWD");

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1975

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Tipo de datos

Valor

REQ

BOOL

0

F_PWD

BOOL

0

FULL_PWD

BOOL

0

R_PWD

BOOL

1

HMI_PWD

BOOL

0

Status_F_PWD

BOOL

0

Status_FULL_PWD

BOOL

0

Status_R_PWD

BOOL

1

Status_HMI_PWD

BOOL

0

La instrucci√≥n se ejecuta ya que el operando REQ tiene el estado l√≥gico "1". El operando
R_PWD tiene el estado l√≥gico "1", lo que significa que al introducir la contrase√±a asignada se
otorga acceso de lectura. El operando de estado R_PWD_ON tambi√©n tiene el estado l√≥gico
"1", lo que indica que el operando R_PWD est√° activado.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de SCL (P√°gina 8115)

Sistemas de PC
SHUT_DOWN: Apagar sistema de destino
Descripci√≥n
Con la instrucci√≥n "SHUT_DOWN: Apagar sistema de destino" se apaga el sistema de
automatizaci√≥n basado en PC y se rearranca el controlador por software S7 CPU 150xS o
Windows en el sistema de automatizaci√≥n basado en PC.
Encontrar√° la instrucci√≥n en la Task Card "Instrucciones", secci√≥n Instrucciones b√°sicas >
Control del programa > Control del tiempo de ejecuci√≥n.
Un reinicio puede ser √∫til en las situaciones siguientes, p. ej.:
‚óè Un SAI industrial (sistema de alimentaci√≥n ininterrumpida) notifica un fallo de tensi√≥n
mediante una entrada digital.
‚óè Windows no responde o presenta una "pantalla azul".
‚óè En el programa de usuario se llaman demasiados OB de error.

1976

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Apagar sistema de destino":
Par√°metro

Declaraci√≥n

Tipo de
datos

√Årea de memoria

Descripci√≥n

MODE

Input

UINT

I, Q, M, D, L o constan‚Äê MODE = 1: apagar CPU 150xS y Windows
te
La CPU pasa a STOP y guarda los datos remanentes. Se‚Äê
guidamente se apagan la CPU y Windows. El sistema debe
rearrancarse manualmente.
MODE = 2: rearrancar CPU 150xS
La CPU pasa a STOP y guarda los datos remanentes. A
continuaci√≥n la CPU se apaga y se reinicia.
MODE = 3: Reiniciar Windows. La CPU permanece en RUN.
Windows se reinicia (desde TIA Portal V14, el MODE 3 solo
est√° autorizado en caso de compatibilidad descendente. Se
recomienda usar MODE 4 o MODE 5).
MODE = 4: Windows se apaga correctamente y se reinicia.
La CPU permanece en RUN.
MODE = 5: Reiniciar Windows. (comparable al MODE 3;
excepci√≥n: MODE 5 solo debe usarse si se ha ca√≠do Win‚Äê
dows).

COM‚Äê
MENT

Input

STRING

I, Q, M, D, L

Con Mode = 1, 3 y 4 es posible indicar el motivo del reinicio.
El motivo se mostrar√° en el registro de eventos de Windows.

Ret_Val

Return

WORD

Q, M, D, L

Ret_Val = 0: ning√∫n error
Ret_Val = 8090: el valor transferido a MODE no se soporta.
Ret_Val = 8091: Windows no responde a la llamada de la
instrucci√≥n Shut_Down (solo v√°lido para Mode 3 y 4).
Ret_Val = 8092: Si aparece este error dir√≠jase al SIMATIC
Customer Support (solo v√°lido para Mode 3 y 4).

RE_TRIGR: Reiniciar tiempo de vigilancia del ciclo
Descripci√≥n
La instrucci√≥n "Reiniciar tiempo de vigilancia del ciclo" reinicia el tiempo de vigilancia del ciclo
de la CPU. El tiempo de vigilancia del ciclo se reinicia entonces con la duraci√≥n ajustada en la
configuraci√≥n de la CPU.
La instrucci√≥n se ejecuta correctamente durante un intervalo de tiempo (10 veces el ciclo
m√°ximo del programa), independientemente del n√∫mero de llamadas. Transcurrido ese
tiempo, el ciclo del programa ya no puede prolongarse.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1977

Instrucciones
4.1 Instrucciones

Llamada de la instrucci√≥n
Se aplican las siguientes condiciones de llamada:
‚óè En las CPU de la serie S7-1200:
En las versiones de firmware < 2.2 solo es posible llamar la instrucci√≥n en un bloque de
organizaci√≥n c√≠clico de la prioridad 1. Equivale a la prioridad m√°s baja de todos los bloques
de organizaci√≥n. Si la instrucci√≥n se llama desde un bloque de organizaci√≥n de prioridad
superior, no se ejecuta y el resultado (bit BR, salida de habilitaci√≥n ENO) es siempre "0".
En las versiones de firmware >= 2.2 puede llamarse la instrucci√≥n en todos los bloques de
organizaci√≥n, independientemente de la prioridad.
‚óè En las CPU de la serie S7-1500:
La instrucci√≥n puede llamarse en todos los bloques de organizaci√≥n, independientemente
de la prioridad.

Par√°metro
La instrucci√≥n "Reiniciar tiempo de vigilancia del ciclo" no tiene par√°metros y no devuelve
informaci√≥n de error.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

STP: Finalizar programa
Descripci√≥n
La instrucci√≥n "Finalizar programa" conmuta la CPU al estado operativo STOP, con lo que se
finaliza la ejecuci√≥n del programa. Los efectos al conmutar de RUN a STOP dependen de la
configuraci√≥n de la CPU.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

GET_ERROR: Consultar error localmente
Descripci√≥n
La instrucci√≥n "Consultar error localmente" consulta si se han producido errores en un bloque
de programa. Suele tratarse de un error de programaci√≥n o de acceso. Si el sistema notifica
errores durante la ejecuci√≥n del bloque de programa, en el operando <Operando> se guarda
informaci√≥n detallada acerca del primer error de ejecuci√≥n del bloque de probrama ocurrido
desde la √∫ltima vez que se ejecut√≥ la instrucci√≥n.

1978

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La informaci√≥n relativa al error solo se puede guardar en operandos del tipo de datos de
sistema "ErrorStruct". El tipo de datos de sistema "ErrorStruct" especifica la estructura exacta
con la que debe guardarse la informaci√≥n acerca del error que ha ocurrido. Con ayuda de otras
instrucciones se puede evaluar esta estructura y programar la reacci√≥n correspondiente. Si se
producen varios errores en el bloque de programa, la instrucci√≥n devolver√° informaci√≥n sobre
el siguiente error ocurrido solo tras haberse solucionado el primer error.
Nota
<Operando>
El <operando> solo se modifica si hay una informaci√≥n de error. Para volver a poner el
operando a "0" tras tratar un error existen las siguientes posibilidades:
‚óè Declare el operando en la secci√≥n "Temp" de la interfaz de bloque.
‚óè Ponga el operando de nuevo a "0" antes de llamar la instrucci√≥n.
Nota
Activaci√≥n del tratamiento local de errores
En cuanto se inserta la instrucci√≥n en el c√≥digo de un bloque de programa, se activa el
tratamiento local de errores y se ignoran las reacciones preajustadas del sistema cuando se
producen errores.

Posibilidades del tratamiento de errores
Este apartado ofrece una visi√≥n general de las posibilidades del tratamiento de
errores: Sinopsis de los mecanismos para el tratamiento de errores (P√°gina 149)
Encontrar√° un ejemplo detallado del tratamiento local de errores que ofrece varias opciones de
tratamiento aqu√≠: Ejemplo de tratamiento de errores de ejecuci√≥n del programa (P√°gina 180)

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Tipo de datos √Årea de memoria

Descripci√≥n

<Operando>

ErrorStruct

Informaci√≥n sobre los errores ocurridos

D, L

Tipo de datos "ErrorStruct"
El tipo de datos "ErrorStruct" se puede insertar en un bloque de datos global o en la interfaz del
bloque. Tambi√©n se puede insertar el tipo de datos varias veces siempre que se asigne cada
vez un nombre distinto para la estructura de datos. La estructura de datos y el nombre de los
distintos elementos de la estructura no se pueden modificar. Si guarda la informaci√≥n del error
en un bloque de datos global, se podr√° leer desde otro bloque de programa.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1979

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra la estructura del tipo de datos "ErrorStruct":
Componente de estructura

Tipo de datos

Descripci√≥n

ERROR_ID

WORD

ID de error

FLAGS

BYTE

Muestra si el error se ha producido durante
la llamada de un bloque de programa.
16#01: error durante la llamada de un blo‚Äê
que de programa
16#00: no hay errores durante la llamada
de un bloque de programa

REACTION

BYTE

Reacci√≥n predeterminada:
0: ignorar (error de escritura)
1: continuar con el valor sustitutivo "0"
(error de lectura)
2: omitir instrucci√≥n (error de sistema)

CODE_ADDRESS
BLOCK_TYPE

CREF

Informaci√≥n sobre la direcci√≥n y el tipo del
bloque de programa

BYTE

Tipo de bloque de programa en el que se
ha producido el error:
1: bloque de organizaci√≥n (OB)
2: funci√≥n (FC)
3: bloque de funci√≥n (FB)

CB_NUMBER

UINT

N√∫mero del bloque l√≥gico

OFFSET

UDINT

Referencia a la memoria interna

MODE

BYTE

Informaci√≥n sobre la direcci√≥n de un ope‚Äê
rando

OPERAND_NUMBER

UINT

N√∫mero de operando del comando de la
m√°quina

POINTER_NUMBER_LOCA‚Äê
TION

UINT

(A) Puntero interno

SLOT_NUMBER_SCOPE

UINT

(B) √Årea de almacenamiento en la memo‚Äê
ria interna

DATA_ADDRESS

NREF

Informaci√≥n sobre la direcci√≥n de un ope‚Äê
rando

BYTE

(C) √Årea de memoria:

AREA

L: 16#40...16#7F, 16#86, 16#87, 16#8E,
16#8F, 16#C0...16#FF
I: 16#81
Q: 16#82
M: 16#83
DB: 16#40, 16#84, 16#85, 16#8A, 16#8B
PI: 16#01
PQ: 16#02
Objetos tecnol√≥gicos: 16#04

1980

DB_NUMBER

UINT

(D) N√∫mero del bloque de datos

OFFSET

UDINT

(E) Direcci√≥n relativa del operando

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Componente de estructura "ERROR_ID"
La tabla siguiente muestra los valores que pueden devolverse en el componente de estructura
"ERROR_ID":
ID*
(hexadecimal)

ID*
(decimal)

Descripci√≥n

0

0

Ning√∫n error

2503

9475

Puntero no v√°lido

2520

9504

STRING no v√°lido

2522

9506

Error de lectura: operando fuera del rango v√°lido

2523

9507

Error de escritura: operando fuera del rango v√°lido

2524

9508

Error de lectura: operando no v√°lido

2525

9509

Error de escritura: operando no v√°lido

2528

9512

Error de lectura: alineaci√≥n de datos

2529

9513

Error de escritura: alineaci√≥n de datos

252C

9516

Puntero no v√°lido

2530

9520

Error de escritura: Bloque de datos

2533

9523

Referencia usada no v√°lida

2538

9528

Error de acceso: el DB no existe

2539

9529

Error de acceso: se ha utilizado un DB incorrecto

253A

9530

El bloque de datos global no existe

253C

9532

Indicaci√≥n err√≥nea o la funci√≥n no existe

253D

9533

La funci√≥n de sistema no existe

253E

9534

Indicaci√≥n err√≥nea o el bloque de funci√≥n no existe

253F

9535

El bloque de sistema no existe

2550

9552

Error de acceso: el DB no existe

2551

9553

Error de acceso: se ha utilizado un DB incorrecto

2575

9589

Error en la profundidad de anidamiento del programa

2576

9590

Error en la distribuci√≥n de datos locales

2577

9591

La propiedad de bloque "Alimentaci√≥n de par√°metros a trav√©s de
registros" no est√° activada.

25A0

9632

Error interno en TP

25A1

9633

Variable protegida contra escritura

25A2

9634

Valor num√©rico no v√°lido de la variable

2942

10562

Error de lectura: entrada

2943

10563

Error de escritura: salida

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1981

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
LABEL: #TagOut := #Field[#index] * REAL#40.5;
GET_ERROR(#Error);
IF #Error.REACTION = 1 THEN
GOTO LABEL;
;
END_IF;

Se ha producido un error al acceder a la variable #Field[#index]. A pesar del error de lectura y
acceso, el operando #TagOut devuelve el estado l√≥gico "1" y la multiplicaci√≥n se realiza con el
valor "0.0". Si se produce este error se recomienda programar la instrucci√≥n "Consultar error
localmente" tras la multiplicaci√≥n para capturar el error. La informaci√≥n de error suministrada
por la instrucci√≥n "Consultar error localmente" se eval√∫a con una comparaci√≥n. Si el
componente de estructura #Error.REACTION tiene el valor "1", se trata de un error de lectura/
acceso y la ejecuci√≥n del programa comienza de nuevo en la etiqueta de salto LABEL.

Consulte tambi√©n
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos del mecanismo EN/ENO (P√°gina 152)
Uso de las instrucciones GET_ERROR y GET_ERR_ID (P√°gina 178)
Principios b√°sicos de SCL (P√°gina 8115)

GET_ERR_ID: Consultar ID de error localmente
Descripci√≥n
La instrucci√≥n "Consultar ID de error localmente" consulta si se han producido errores en un
bloque. Suele tratarse de un error de acceso. Si al ejecutar el bloque el sistema notifica errores
de ejecuci√≥n desde que se ejecut√≥ la instrucci√≥n por √∫ltima vez, la instrucci√≥n emite la ID del
primer error ocurrido.

1982

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La ID de error solo se puede guardar en operandos del tipo de datos WORD. Si se producen
varios errores en el bloque, la instrucci√≥n soluciona el primer error ocurrido, y solo entonces la
instrucci√≥n emite la ID de error del siguiente error ocurrido.
Nota
El <operando> solo se modifica si hay una informaci√≥n de error. Para volver a poner el
operando a "0" tras tratar un error existen las siguientes posibilidades:
‚óè Declare el operando en la secci√≥n "Temp" de la interfaz de bloque.
‚óè Ponga el operando de nuevo a "0" antes de llamar la instrucci√≥n.
La salida de la instrucci√≥n "Consultar ID de error localmente" se activa √∫nicamente si existe
una informaci√≥n de error. Si no se cumple esta condici√≥n, el procesamiento ulterior del
programa no se ve afectado por la instrucci√≥n "Consultar ID de error localmente".
Encontrar√° un ejemplo sobre c√≥mo utilizar la instrucci√≥n en combinaci√≥n con otras
posibilidades de tratamiento de errores, en "Consulte tambi√©n".
Nota
La instrucci√≥n "Consultar ID de error localmente" activa el tratamiento local de errores dentro
del bloque. Si en la l√≥gica de un bloque se ha insertado la instrucci√≥n "Consultar ID de error
localmente", se ignoran las reacciones predeterminadas del sistema al ocurrir errores.

Posibilidades del tratamiento de errores
Este apartado ofrece una visi√≥n general de las posibilidades del tratamiento de
errores: Sinopsis de los mecanismos para el tratamiento de errores (P√°gina 149)
Encontrar√° un ejemplo detallado del tratamiento local de errores que ofrece varias opciones de
tratamiento aqu√≠: Ejemplo de tratamiento de errores de ejecuci√≥n del programa (P√°gina 180)

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Tipo de datos √Årea de memoria

Descripci√≥n

Valor de fun‚Äê
ci√≥n

WORD

ID de error

D, L

ID de error
La tabla siguiente muestra los valores que pueden devolverse:
ID*
(hexadecimal)

ID*
(decimal)

Descripci√≥n

0

0

Ning√∫n error

2503

9475

Puntero no v√°lido

2520

9504

STRING no v√°lido

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1983

Instrucciones
4.1 Instrucciones
ID*
(hexadecimal)

ID*
(decimal)

Descripci√≥n

2522

9506

Error de lectura: operando fuera del rango v√°lido

2523

9507

Error de escritura: operando fuera del rango v√°lido

2524

9508

Error de lectura: operando no v√°lido

2525

9509

Error de escritura: operando no v√°lido

2528

9512

Error de lectura: alineaci√≥n de datos

2529

9513

Error de escritura: alineaci√≥n de datos

252C

9516

Puntero no v√°lido

2530

9520

Error de escritura: Bloque de datos

2533

9523

Referencia usada no v√°lida

2538

9528

Error de acceso: el DB no existe

2539

9529

Error de acceso: se ha utilizado un DB incorrecto

253A

9530

El bloque de datos global no existe

253C

9532

Indicaci√≥n err√≥nea o la funci√≥n no existe

253D

9533

La funci√≥n de sistema no existe

253E

9534

Indicaci√≥n err√≥nea o el bloque de funci√≥n no existe

253F

9535

El bloque de sistema no existe

2550

9552

Error de acceso: el DB no existe

2551

9553

Error de acceso: se ha utilizado un DB incorrecto

2575

9589

Error en la profundidad de anidamiento del programa

2576

9590

Error en la distribuci√≥n de datos locales

2577

9591

La propiedad de bloque "Alimentaci√≥n de par√°metros a trav√©s de
registros" no est√° activada.

25A0

9632

Error interno en TP

25A1

9633

Variable protegida contra escritura

25A2

9634

Valor num√©rico no v√°lido de la variable

2942

10562

Error de lectura: entrada

2943

10563

Error de escritura: salida

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
#TagOut := #Field[#index] * REAL#40.5;
#TagID := GET_ERR_ID();
IF #TagID = 16#2522 THEN
MOVE_BLK(IN := #TagArrayIn[0],
COUNT := 1,

1984

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
OUT => #TagArrayOut[1]);
END_IF;

Se ha producido un error al acceder a la variable #Field[#index]. A pesar del error de lectura y
acceso, el operando #TagOut devuelve el estado l√≥gico "1" y la multiplicaci√≥n se realiza con el
valor "0.0". Si se produce este error se recomienda programar la instrucci√≥n "Consultar ID de
error localmente" tras la multiplicaci√≥n para capturar el error. La ID de error suministrada por
la instrucci√≥n "Consultar ID de error localmente" se eval√∫a con una comparaci√≥n. Si el
operando #TagID devuelve la ID 16#2522, se trata de un error de lectura/acceso y el valor
"100.0" del operando #TagArrayIn[0] se copia en el operando #TagArrayOut[1].

Consulte tambi√©n
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos del mecanismo EN/ENO (P√°gina 152)
Uso de las instrucciones GET_ERROR y GET_ERR_ID (P√°gina 178)
Principios b√°sicos de SCL (P√°gina 8115)

INIT_RD: Inicializar todos los datos remanentes
Descripci√≥n
La instrucci√≥n "Inicializar todos los datos remanentes" permite inicializar todos los datos
remanentes de todos los bloques de datos, marcas y temporizadores y contadores SIMATIC
al mismo tiempo. La instrucci√≥n solo puede ejecutarse dentro de un OB de arranque, puesto
que su ejecuci√≥n exceder√≠a el tiempo de ciclo de programa.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

BOOL

I, Q, M, D, L

Si la entrada REQ devuelve
el estado l√≥gico "1", se inicia‚Äê
lizan todos los datos rema‚Äê
nentes.

INT

I, Q, M, D, L

Informaci√≥n de error:

Valor de funci√≥n (RET_VAL)

El par√°metro RET_VAL de‚Äê
vuelve un c√≥digo de error
cuando ocurre un error du‚Äê
rante la ejecuci√≥n de la ins‚Äê
trucci√≥n.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1985

Instrucciones
4.1 Instrucciones

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

80B5

No puede ejecutarse la instrucci√≥n porque no ha sido programada dentro de un OB de arranque.

Informaci√≥n
Consulte tambi√©n: "GET_ERR_ID: Consultar ID de error localmente"
de error gene‚Äê
ral
*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexadecimales. Encontrar√°
m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := INIT_RD("Tag_REQ");

Si el operando "Tag_REQ" devuelve el estado l√≥gico "1", se ejecuta la instrucci√≥n. Se
inicializan todos los datos remanentes de todos los bloques de datos, marcas y
temporizadores y contadores SIMATIC.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
GET_ERR_ID: Consultar ID de error localmente (P√°gina 1982)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Principios b√°sicos de SCL (P√°gina 8115)

WAIT: Programar retardo
Descripci√≥n
La instrucci√≥n "Programar retardo" permite detener la ejecuci√≥n del programa durante un
periodo predeterminado. El periodo se indica en microsegundos en el par√°metro WT de la
instrucci√≥n.
Es posible programar tiempos de retardo de -32768 a 32767 microsegundos (Œºs). El tiempo de
retardo m√≠nimo depende de la CPU utilizada y equivale al tiempo de ejecuci√≥n de la instrucci√≥n.

1986

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La ejecuci√≥n de la instrucci√≥n puede verse interrumpida por eventos de prioridad superior y no
arrojar√° informaci√≥n de error.
Nota
Tiempo de retardo negativo
Si indica un tiempo de retardo negativo en el par√°metro WT, la salida de habilitaci√≥n ENO, o
el RLO y el bit BR arrojan el estado l√≥gico FALSE. Un tiempo de retardo negativo no afecta a
la CPU. En KOP y FUP no se ejecutan las siguientes instrucciones vinculadas a la salida de
habilitaci√≥n ENO.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

WT

Input

INT

I, Q, M, D, L, P o
constante

Tiempo de retardo en micro‚Äê
segundos (Œºs)

Ejemplo de c√≥mo influir en el tiempo de retardo previsto
En el ejemplo siguiente se ve la influencia del tiempo de retardo de la instrucci√≥n "WAIT" en
diferentes escenarios.
La figura siguiente ilustra los escenarios esquem√°ticamente:

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1987

Instrucciones
4.1 Instrucciones
6HQG&ORFN

&DVR 
2%

PV

:$,7  PV
7'HOD\ PV

7&RGH PV

7'HOD\ PV

7&RGH PV

7'HOD\ PV

7&RGH PV

75H PV

&DVR
2%GHDODUPD

75H PV

&DVR
2%GHDODUPD

7&RGH PV

&DVR
2%GHDODUPD
72Y PV
6HQG&ORFN 7LHPSRGHFLFORGHHPLVL¬µQGHOD&38
7'HOD\ 7LHPSRGHUHWDUGRGHO2%GHDODUPD
7&RGH 7LHPSRGHHMHFXFL¬µQGHOSURJUDPD
75H 7LHPSRUHVWDQWH
72Y 7LHPSRHQHOTXHVHSURORQJDHOWLHPSRGHFLFORGHHPLVL¬µQ
(O2%FRQODLQVWUXFFL¬µQ:$,7WDPEL¬´QIRUPDSDUWHGHORVFDVRV\\GHEH
WHQHUVHHQFXHQWD

Tiempo restante = intervalo entre el final del tiempo de retardo previsto (mediante "WAIT") y la
finalizaci√≥n del OB de alarma
Tiempo de prolongaci√≥n = intervalo entre la finalizaci√≥n del OB de alarma y el final del tiempo
de retardo previsto (mediante "WAIT")
Caso 1:
La instrucci√≥n "WAIT" se llama en un OB1. La instrucci√≥n "WAIT" puede verse interrumpida por
OB o procesos de mayor prioridad (p. ej. System Threads). Sin embargo, el tiempo de retardo
de la instrucci√≥n "WAIT" no se ha modificado ni se ha aplazado.
Casos 2 y 3:
El procesamiento del programa en el OB1 prosigue tras un retardo de 20 ms. Este retardo se
calcula con la llamada de la instrucci√≥n "WAIT" en el OB1 (consulte OB1 con WAIT). En esos
20 ms, un OB de alarma puede ejecutar su propio c√≥digo de programa. El tiempo de ciclo de
emisi√≥n de la CPU no cambia.

1988

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Caso 4:
El procesamiento del programa en el OB1 prosigue tras finalizar el proceso de mayor prioridad.
Los 20 ms de retardo en el OB1 han transcurrido, pero el proceso de mayor prioridad todav√≠a
no ha finalizado. El tiempo de ciclo de emisi√≥n de la CPU aumenta.
Nota
Secuencia de ejecuci√≥n de procesos del sistema o de comunicaci√≥n (System Threads)
Los threads del sistema suelen utilizar la prioridad "15". Tambi√©n hay threads del sistema con
una prioridad mayor que "26", pero estos procesos suponen una carga menor para la CPU. Los
threads del sistema no se muestran en la figura.
Medici√≥n del tiempo de ejecuci√≥n del OB1 utilizando la instrucci√≥n "RT_INFO":
Caso 2: 20 ms - 8 ms - System Threads = <12 ms. Tiempo de ciclo de emisi√≥n: ~20 ms.
Caso 3: 20 ms - 11 ms - System Threads - <9 ms. Tiempo de ciclo de emisi√≥n: ~20 ms.
Caso 4: 20 ms - 15 ms - System Threads - <7 ms. Tiempo de ciclo de emisi√≥n: ~22 ms.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

RUNTIME: Medir tiempo de ejecuci√≥n
Descripci√≥n
La instrucci√≥n "Medir tiempo de ejecuci√≥n" permite medir el tiempo de ejecuci√≥n de todo el
programa, bloques individuales o secuencias de comandos.
Si desea medir el tiempo de ejecuci√≥n de todo el programa, efect√∫e la llamada de la instrucci√≥n
"Medir tiempo de ejecuci√≥n" en el OB1. El punto inicial para medir el tiempo de ejecuci√≥n se
determina con la primera llamada y la salida RET_VAL devuelve el tiempo de ejecuci√≥n del
programa tras la segunda llamada. El tiempo de ejecuci√≥n medido incluye toda clase de
procesos de la CPU que se hayan producido durante la ejecuci√≥n del programa, como, p. ej.,
interrupciones a causa de eventos o comunicaciones de mayor prioridad. La instrucci√≥n "Medir
tiempo de ejecuci√≥n" lee un contador interno de la CPU y escribe su valor en el par√°metro de
entrada/salida. La instrucci√≥n calcula el tiempo de ejecuci√≥n actual del programa seg√∫n la
frecuencia interna del contador, y la escribe en la salida RET_VAL.
Si desea medir el tiempo de ejecuci√≥n de bloques o secuencias de comandos individuales,
necesita tres segmentos diferentes. Efect√∫e la llamada de la instrucci√≥n "Medir tiempo de
ejecuci√≥n" en un segmento individual dentro del programa. Al efectuar esta primera llamada de
la instrucci√≥n se establece el punto inicial para medir el tiempo de ejecuci√≥n. A continuaci√≥n,
llame el bloque de programa o la secuencia de comando que desee en el siguiente segmento.
Efect√∫e la llamada de la instrucci√≥n "Medir tiempo de ejecuci√≥n" por segunda vez en otro
segmento diferente y asigne al par√°metro de entrada/salida la misma memoria que en la
primera llamada de la instrucci√≥n. En el tercer segmento, la instrucci√≥n "Medir tiempo de
ejecuci√≥n" lee un contador interno de la CPU, calcula el tiempo de ejecuci√≥n actual del bloque

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1989

Instrucciones
4.1 Instrucciones
de programa o secuencia de comando seg√∫n la frecuencia interna del contador y lo escribe en
la salida RET_VAL.
La instrucci√≥n "Medir tiempo de ejecuci√≥n" utiliza un contador interno de alta frecuencia para
calcular el tiempo. Cuando el contador se desborda, la instrucci√≥n devuelve valores <= 0.0. En
las CPU S7-1200 con versi√≥n de firmware < V4.2, esto puede suceder hasta una vez por
minuto. Estos valores de runtime deben ignorarse.
Nota
Puesto que el orden de las instrucciones de una secuencia de comandos se modifica mediante
la compilaci√≥n optimizada del programa, no es posible determinar el tiempo de ejecuci√≥n de
una secuencia de comandos con exactitud.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

InOut

LREAL

I, Q, M, D, L

El contenido est√° previsto
√∫nicamente para fines inter‚Äê
nos.

LREAL

I, Q, M, D, L

Devuelve el tiempo de ejecu‚Äê
ci√≥n medido en segundos

Valor de funci√≥n

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n mediante el c√°lculo del tiempo
de ejecuci√≥n de un bloque de programa:
SCL
"Tag_Result" := RUNTIME("Tag_Memory");
"Best_before_date_DB" ();
"Tag_Result" := RUNTIME("Tag_Memory");

Con la primera llamada de la instrucci√≥n se determina el punto inicial para la medici√≥n del
tiempo de ejecuci√≥n, y se guarda como referencia en una memora intermedia del operando
"TagMemory" para la segunda llamada de la instrucci√≥n.
A continuaci√≥n se llama el bloque de programa FB1 "Best_before_date".
Una vez se ha procesado el bloque de programa FB1, la instrucci√≥n se ejecuta por segunda
vez. La segunda llamada de la instrucci√≥n calcula el tiempo de ejecuci√≥n del bloque de
programa y escribe el resultado en la salida "Tag_Result".
Encontrar√° un ejemplo detallado de c√≥mo medir el tiempo de ciclo total de un programa en el
Siemens Industry Online Support, en la ID de art√≠culo: 87668055 (https://
support.industry.siemens.com/cs/ww/es/view/87668055)

1990

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Operaciones l√≥gicas con palabras
DECO: Descodificar
Descripci√≥n
La instrucci√≥n "Descodificar" activa un bit predeterminado por el valor de entrada en el valor de
salida.
La instrucci√≥n "Descodificar" lee el valor del par√°metro IN y activa el bit en el valor de salida
cuya posici√≥n equivale al valor le√≠do. Los dem√°s bits del valor de salida se rellenan con ceros.
Si el valor del par√°metro IN es mayor que 31, se ejecuta una instrucci√≥n modulo 32.
Para modificar el tipo de datos de la instrucci√≥n, utilice la sintaxis siguiente:
DECO_<Tipo de datos>();

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

UINT

I, Q, M, D, L, P

Posici√≥n del bit que se activa en
el valor de salida.

Secuencias de
bits
Valor predeter‚Äê
minado:
DWORD

-

Tipo de datos del valor de fun‚Äê
ci√≥n:

_<tipo de datos>

1. El tipo de datos de la
instrucci√≥n se puede indicar
expl√≠citamente con "_".
2. Si el tipo de datos no se
indica expl√≠citamente, se
determinar√° a partir de las
variables utilizadas o de las
constantes con tipos.
3. Si el tipo de datos no se
indica expl√≠citamente ni se
indican variables definidas
ni constantes con tipo, se
utilizar√° el tipo de datos
predeterminado.

Valor de funci√≥n

Secuencias de
bits

I, Q, M, D, L, P

Valor de salida actual

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1991

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := DECO(IN := "Tag_Value");
"Tag_Result2" := DECO_BYTE(IN := "Tag_Value2");

La figura siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
‡≤Ø7DJB9DOXH‡≤Ø




‡≤Ø7DJB5HVXOW‡≤Ø

 



 

La instrucci√≥n lee el n√∫mero "3" del valor del operando "Tag_Value" y activa el tercer bit del
valor del operando "Tag_Result".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

ENCO: Codificar
Descripci√≥n
La instrucci√≥n "Codificar" permite leer el n√∫mero del bit menos significativo que est√° activado
en el valor de entrada y devolverlo como resultado.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

Secuencias de
bits

I, Q, M, D, L, P

Valor de entrada

INT

I, Q, M, D, L, P

N√∫mero del bit que
se lee en el valor de
entrada.

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := ENCO(IN := "Tag_Value");

1992

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La figura siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:

‡≤Ø7DJB9DOXH‡≤Ø
‡≤Ø7DJB5HVXOW‡≤Ø

 



 


La instrucci√≥n lee el bit menos significativo que est√° activado en el operando "Tag_Value" y
escribe la posici√≥n de bit "3" en el operando "Tag_Result".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

SEL: Seleccionar
Descripci√≥n
La instrucci√≥n "Seleccionar" selecciona, en funci√≥n de un interruptor (par√°metro G), uno de los
par√°metros IN0 o IN1 y devuelve su contenido como resultado. Si el par√°metro G tiene el
estado l√≥gico "0", se copia el valor del par√°metro IN0. Si el par√°metro G tiene el estado l√≥gico
"1", se copia el valor del par√°metro IN1 y se devuelve como valor de funci√≥n.
Para poder ejecutar la instrucci√≥n, es imprescindible que las variables de todos los par√°metros
del tipo de datos sean de la misma clase.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metros Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de me‚Äê
moria
I, Q, M, D, L

G

Input

BOOL

BOOL

IN0

Input

N√∫meros bina‚Äê
rios, enteros, n√∫‚Äê
meros en coma
flotante, tempori‚Äê
zadores, secuen‚Äê
cias de caracte‚Äê
res, TOD, DATE,
DT

N√∫meros bina‚Äê I, Q, M, D, L,
P
rios, enteros,
n√∫meros en co‚Äê
ma flotante,
temporizado‚Äê
res, secuencias
de caracteres,
DATE, TOD,
LTOD, DT, LDT

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Descripci√≥n
Interruptor
Primer valor de
entrada

1993

Instrucciones
4.1 Instrucciones
Par√°metros Declaraci√≥n
IN1

Input

Valor de funci√≥n

Tipo de datos

√Årea de me‚Äê
moria

Descripci√≥n

S7-1200

S7-1500

N√∫meros bina‚Äê
rios, enteros, n√∫‚Äê
meros en coma
flotante, tempori‚Äê
zadores, secuen‚Äê
cias de caracte‚Äê
res, TOD, DATE,
DT

N√∫meros bina‚Äê I, Q, M, D, L,
P
rios, enteros,
n√∫meros en co‚Äê
ma flotante,
temporizado‚Äê
res, secuencias
de caracteres,
DATE, TOD,
LTOD, DT, LDT

Segundo valor de
entrada

N√∫meros bina‚Äê
rios, enteros, n√∫‚Äê
meros en coma
flotante, tempori‚Äê
zadores, secuen‚Äê
cias de caracte‚Äê
res, TOD, DATE,
DT

N√∫meros bina‚Äê I, Q, M, D, L,
rios, enteros,
P
n√∫meros en co‚Äê
ma flotante,
temporizado‚Äê
res, secuencias
de caracteres,
DATE, TOD,
LTOD, DT, LDT

Resultado de la
instrucci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := SEL(G := "Tag_Value",
IN0 := "Tag_0",
IN1 := "Tag_1");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Value

0

1

Tag_0

W#16#0000

W#16#4C

Tag_1

W#16#FFFF

D#16#5E

Tag_Result

W#16#0000

D#16#5E

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

1994

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

MUX: Multiplexar
Descripci√≥n
La instrucci√≥n "Multiplexar" copia el valor de un par√°metro de entrada seleccionado y lo
devuelve. Con el par√°metro K se especifica el n√∫mero del par√°metro de entrada cuyo n√∫mero
se copiar√°. La numeraci√≥n comienza por IN0 y contin√∫a en orden ascendente con cada nueva
entrada. Se puede declarar un m√°ximo de 32 entradas.
En las entradas se permiten tipos de datos num√©ricos y tipos de datos de tiempo. Todas las
variables parametrizadas deben ser del mismo tipo de datos.
El valor de funci√≥n no es v√°lido si se cumple una de las siguientes condiciones:
‚óè Se producen errores al ejecutar la instrucci√≥n.
‚óè Si la entrada del par√°metro K est√° fuera del rango de entradas disponibles y la entrada
INELSE no se usa, el valor de funci√≥n no es v√°lido.
Nota
El par√°metro K tiene un entero negativo
Si en los par√°metros de entrada se indica una variable con un tipo de datos v√°lido y el
par√°metro K tiene un entero negativo, el valor de la variable se modificar√°.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

K

Input

Tipo de datos
S7-1200

S7-1500

Enteros

Enteros

√Årea de me‚Äê Descripci√≥n
moria
I, Q, M, D, L,
P

Indica el par√°metro
cuyo contenido se
transfiere.
‚óè Si K = 0 =>
par√°metro IN0
‚óè Si K = 1 =>
par√°metro IN1,
etc.

IN0

Input

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

N√∫meros bi‚Äê
narios, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, tempo‚Äê
rizadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

N√∫meros bina‚Äê I, Q, M, D, L,
rios, enteros,
P
n√∫meros en co‚Äê
ma flotante, se‚Äê
cuencias de ca‚Äê
racteres, TOD,
LTOD, DATE,
temporizado‚Äê
res, DT, LDT

Primer valor de entra‚Äê
da

1995

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de me‚Äê Descripci√≥n
moria

IN1

Input

N√∫meros bi‚Äê
narios, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, tempo‚Äê
rizadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

N√∫meros bina‚Äê I, Q, M, D, L,
rios, enteros,
P
n√∫meros en co‚Äê
ma flotante, se‚Äê
cuencias de ca‚Äê
racteres, TOD,
LTOD, DATE,
temporizado‚Äê
res, DT, LDT

Segundo valor de en‚Äê
trada

INn

Input

N√∫meros bi‚Äê
narios, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, tempo‚Äê
rizadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

N√∫meros bina‚Äê I, Q, M, D, L,
rios, enteros,
P
n√∫meros en co‚Äê
ma flotante, se‚Äê
cuencias de ca‚Äê
racteres, TOD,
LTOD, DATE,
temporizado‚Äê
res, DT, LDT

Valores de entrada op‚Äê
cionales

INELSE

Input

N√∫meros bi‚Äê
narios, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, tempo‚Äê
rizadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

N√∫meros bina‚Äê I, Q, M, D, L,
rios, enteros,
P
n√∫meros en co‚Äê
ma flotante, se‚Äê
cuencias de ca‚Äê
racteres, TOD,
LTOD, DATE,
temporizado‚Äê
res, DT, LDT

Indica el valor que se
copia si K <> n.

N√∫meros bi‚Äê
narios, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, tempo‚Äê
rizadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

N√∫meros bina‚Äê I, Q, M, D, L,
rios, enteros,
P
n√∫meros en co‚Äê
ma flotante, se‚Äê
cuencias de ca‚Äê
racteres, TOD,
LTOD, DATE,
temporizado‚Äê
res, DT, LDT

Resultado de la ins‚Äê
trucci√≥n

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

1996

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := MUX(K := "Tag_Number",
IN0 := "Tag_1",
IN1 := "Tag_2",
INELSE := "Tag_3");

El resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_Number

1

4

Tag_1

DW#16#00000000

DW#16#00000000

Tag_2

DW#16#003E4A7D

DW#16#003E4A7D

Tag_3

DW#16#FFFF0000

DW#16#FFFF0000

Tag_Result

DW#16#003E4A7D

DW#16#FFFF0000

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

DEMUX: Desmultiplexar
Descripci√≥n
La instrucci√≥n "Desmultiplexar" permite transferir el valor del par√°metro de entrada IN a un
par√°metro de salida seleccionado. La selecci√≥n del par√°metro de salida se efect√∫a en funci√≥n
del valor del par√°metro K. El par√°metro K indica el n√∫mero del par√°metro de salida al que se
transfiere el valor del par√°metro de entrada IN. Los dem√°s par√°metros de salida no cambian.
La numeraci√≥n comienza por OUT0 y contin√∫a en orden ascendente con cada nueva salida.
Se puede declarar un m√°ximo de 32 par√°metros de salida.
Si el valor del par√°metro K es mayor que el n√∫mero de par√°metros de salida, se copia el
contenido del par√°metro de entrada IN en el par√°metro de salida OUTELSE y se asigna a la
salida de habilitaci√≥n ENO el estado l√≥gico "0".
El valor de funci√≥n no es v√°lido si se cumple una de las siguientes condiciones:
‚óè El valor del par√°metro K es mayor que el n√∫mero de salidas disponibles.
‚óè Se producen errores al ejecutar la instrucci√≥n.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1997

Instrucciones
4.1 Instrucciones

Nota
El par√°metro K < 0 o K > las salidas disponibles
Si indica un valor en el par√°metro K que est√© fuera de las salidas disponibles (K < 0 o K >
salidas disponibles), en el par√°metro de salida OUTELSE se emitir√° el valor del par√°metro de
entrada IN.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

K

Input

Tipo de datos
S7-1200

S7-1500

Enteros

Enteros

√Årea de me‚Äê
moria

Descripci√≥n

I, Q, M, D, L, P Indica la salida en la
que se copia el valor
de entrada (IN).
‚óè Si K = 0 =>
par√°metro OUT0
‚óè Si K = 1 =>
par√°metro
OUT1, etc.

1998

IN

Input

N√∫meros bi‚Äê
narios, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, tempori‚Äê
zadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

N√∫meros bina‚Äê I, Q, M, D, L, P Valor de entrada
rios, enteros,
n√∫meros en
coma flotante,
secuencias de
caracteres,
temporizado‚Äê
res, TOD,
LTOD, DATE,
DT, LDT

OUT0

Output

N√∫meros bi‚Äê
narios, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, tempori‚Äê
zadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

N√∫meros bina‚Äê I, Q, M, D, L, P Primera salida
rios, enteros,
n√∫meros en
coma flotante,
secuencias de
caracteres,
temporizado‚Äê
res, TOD,
LTOD, DATE,
DT, LDT

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de me‚Äê
moria

Descripci√≥n

OUT1

Output

N√∫meros bi‚Äê
narios, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, tempori‚Äê
zadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

N√∫meros bina‚Äê I, Q, M, D, L, P Segunda salida
rios, enteros,
n√∫meros en
coma flotante,
secuencias de
caracteres,
temporizado‚Äê
res, TOD,
LTOD, DATE,
DT, LDT

OUTn

Output

N√∫meros bi‚Äê
narios, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, tempori‚Äê
zadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

N√∫meros bina‚Äê I, Q, M, D, L, P Salidas opcionales
rios, enteros,
n√∫meros en
coma flotante,
secuencias de
caracteres,
temporizado‚Äê
res, TOD,
LTOD, DATE,
DT, LDT

OUTELSE

Output

N√∫meros bi‚Äê
narios, ente‚Äê
ros, n√∫meros
en coma flo‚Äê
tante, tempori‚Äê
zadores,
STRING,
CHAR,
WCHAR,
TOD, DATE,
DT

N√∫meros bina‚Äê I, Q, M, D, L, P Salida a la que se co‚Äê
pia el valor de la en‚Äê
rios, enteros,
trada IN con K > n.
n√∫meros en
coma flotante,
secuencias de
caracteres,
temporizado‚Äê
res, TOD,
LTOD, DATE,
DT, LDT

Encontrar√° m√°s informaci√≥n sobre los tipos de datos disponibles en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
DEMUX(K := "Tag_Number",
IN := "Tag_Value",
OUT0 := "Tag_1",
OUT1 := "Tag_2",
OUTELSE := "Tag_3");

Las tablas siguientes muestran el funcionamiento de la instrucci√≥n con valores de operandos
concretos:

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

1999

Instrucciones
4.1 Instrucciones
Valores de entrada de la instrucci√≥n "Desmultiplexar" antes de ejecutar el segmento
Par√°metro

Operando

Valores

K

Tag_Number

2

4

IN

Tag_Value

DW#16#FFFFFFFF

DW#16#003E4A7D

Valores de salida de la instrucci√≥n "Desmultiplexar" tras ejecutar el segmento
Par√°metro

Operando

OUT0

Tag_1

sin cambios

Valores
sin cambios

OUT1

Tag_2

DW#16#FFFFFFFF

sin cambios

OUTELSE

Tag_3

sin cambios

DW#16#003E4A7D

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Desplazamiento y rotaci√≥n
SHR: Desplazar a la derecha
Descripci√≥n
Con la instrucci√≥n "Desplazar a la derecha" se desplaza el contenido del par√°metro IN de bit
en bit hacia la derecha y se devuelve como valor de funci√≥n. El par√°metro N determina el
n√∫mero de bits que debe desplazarse el valor indicado.
Si el valor del par√°metro N es "0", se devuelve como resultado el valor del par√°metro IN.
Si el valor del par√°metro N es mayor que el n√∫mero de bits disponibles, el valor del par√°metro
IN se desplaza hacia la derecha las posiciones de bit disponibles.
En los valores sin signo, se rellenan con ceros los bits que quedan libres en el √°rea izquierda
del operando al realizar el desplazamiento. Si el valor indicado lleva signo, las posiciones libres
se ocupan con el estado l√≥gico del bit de signo.
La figura siguiente muestra c√≥mo el contenido de un operando del tipo de datos Integer se
desplaza cuatro posiciones de bit hacia la derecha:

2000

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones


,1



 










1

5HVXOWDGR!




































SRVLFLRQHV



























(VWRVFXDWURELWV
VHSLHUGHQ

/DVSRVLFLRQHVGHELWTXHTXHGDQOLEUHV
VHUHOOHQDQFRQFHURV

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memo‚Äê
ria

Descripci√≥n

IN

Input

Secuencias Secuencias I, Q, M, D, L
de bits, ente‚Äê de bits, ente‚Äê
ros
ros

Valor que se
desplaza

N

Input

USINT,
UINT,
UDINT

I, Q, M, D, L

N√∫mero de bits
que se desplaza
el valor (IN)

Secuencias Secuencias I, Q, M, D, L
de bits, ente‚Äê de bits, ente‚Äê
ros
ros

Resultado de la
instrucci√≥n

Valor de funci√≥n

USINT,
UINT,
UDINT,
ULINT

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := SHR(IN := "Tag_Value",
N := "Tag_Number");

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2001

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

Tag_Value

0011 1111 1010 1111

N

Tag_Number

3

Valor de funci√≥n

Tag_Result

0000 0111 1111 0101

El valor del operando "Tag_Value" se desplaza tres posiciones de bit hacia la derecha. El
resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

SHL: Desplazar a la izquierda
Descripci√≥n
Con la instrucci√≥n "Desplazar a la izquierda" se desplaza el contenido del par√°metro IN de bit
en bit hacia la izquierda y se devuelve como valor de funci√≥n. El par√°metro N determina el
n√∫mero de bits que debe desplazarse el valor indicado.
Si el valor del par√°metro N es "0", se devuelve como resultado el valor del par√°metro IN.
Si el valor del par√°metro N es mayor que el n√∫mero de bits disponibles, el valor del par√°metro
IN se desplaza hacia la izquierda las posiciones de bit disponibles.
Las posiciones que quedan libres al desplazar se rellenan con ceros.
La figura siguiente muestra c√≥mo el contenido de un operando del tipo de datos WORD se
desplaza seis posiciones de bit hacia la izquierda:

2002

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones


,1



 




1




























SRVLFLRQHV

5HVXOWDGR!      

































/DVSRVLFLRQHVGHELW
TXHKDQTXHGDGROLEUHV
VHUHOOHQDQFRQFHURV

(VWRVVHLVELWV
VHSLHUGHQ

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memo‚Äê
ria

Descripci√≥n

IN

Input

Secuencias Secuencias I, Q, M, D, L
de bits, ente‚Äê de bits, ente‚Äê
ros
ros

Valor que se
desplaza

N

Input

USINT,
UINT,
UDINT

I, Q, M, D, L

N√∫mero de bits
que se desplaza
el valor (IN)

Secuencias Secuencias I, Q, M, D, L
de bits, ente‚Äê de bits, ente‚Äê
ros
ros

Resultado de la
instrucci√≥n

Valor de funci√≥n

USINT,
UINT,
UDINT,
ULINT

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := SHL(IN := "Tag_Value",
N := "Tag_Number");

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2003

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

Tag_Value

0011 1111 1010 1111

N

Tag_Number

4

Valor de funci√≥n

Tag_Result

1111 1010 1111 0000

El valor del operando "Tag_Value" se desplaza cuatro posiciones de bit hacia la izquierda. El
resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

ROR: Rotar a la derecha
Descripci√≥n
La instrucci√≥n "Rotar a la derecha" permite rotar el contenido del par√°metro IN de bit en bit
hacia la derecha y asignar el resultado al operando indicado. El par√°metro N determina el
n√∫mero de bits que debe rotarse el valor indicado. Los bits que quedan libres al realizar la
rotaci√≥n se rellenan con los bits desplazados hacia fuera.
Si el valor del par√°metro N es "0", se devuelve como resultado el valor de la entrada IN.
Si el valor del par√°metro N es mayor que el n√∫mero de bits disponibles, el valor del operando
en la entrada IN rota de todos modos el n√∫mero indicado de posiciones de bit.
La figura siguiente muestra c√≥mo el contenido de un operando del tipo de datos DWORD rota
tres posiciones hacia la derecha:

2004

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones


,1

 



       

1

SRVLFLRQHV

        

5HVXOWDGR!

(OHVWDGRO¬µJLFRGHORVWUHV
ELWVGHVSOD]DGRVVHLQWURGXFHHQODV
SRVLFLRQHVTXHKDQTXHGDGROLEUHV

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memo‚Äê
ria

Descripci√≥n

IN

Input

Secuencias Secuencias I, Q, M, D, L
de bits, ente‚Äê de bits, ente‚Äê
ros
ros

Valor que se rota

N

Input

USINT,
UINT,
UDINT

I, Q, M, D, L

N√∫mero de bits
que rota el valor
(IN)

Secuencias Secuencias I, Q, M, D, L
de bits, ente‚Äê de bits, ente‚Äê
ros
ros

Resultado de la
instrucci√≥n

Valor de funci√≥n

USINT,
UINT,
UDINT,
ULINT

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := ROR(IN := "Tag_Value",
N := "Tag_Number");

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2005

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

Tag_Value

0000 1111 1001 0101

N

Tag_Number

5

Valor de funci√≥n

Tag_Result

1010 1000 0111 1100

El contenido del operando "Tag_Value" se rota cinco posiciones de bit hacia la derecha. El
resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

ROL: Rotar a la izquierda
Descripci√≥n
Con la instrucci√≥n "Rotar a la izquierda", el contenido del par√°metro IN rota de bit en bit hacia
la izquierda y se devuelve como valor de funci√≥n. El par√°metro N determina el n√∫mero de bits
que debe rotarse el valor indicado. Los bits que quedan libres al realizar la rotaci√≥n se rellenan
con los bits desplazados hacia fuera.
Si el valor del par√°metro N es "0", se devuelve como resultado el valor de la entrada IN.
Si el valor del par√°metro N es mayor que el n√∫mero de bits disponibles, el valor del operando
en la entrada IN rota de todos modos el n√∫mero indicado de posiciones de bit.
La figura siguiente muestra c√≥mo el contenido de un operando del tipo de datos DWORD rota
tres posiciones hacia la izquierda:

2006

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones


,1

 

       

1

5HVXOWDGR!



SRVLFLRQHV

        
(OHVWDGRO¬µJLFRGHORVWUHV
ELWVGHVSOD]DGRVVHLQVHUWD
HQODVSRVLFLRQHVTXHKDQTXHGDGR
OLEUHV

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memo‚Äê
ria

Descripci√≥n

IN

Input

Secuencias Secuencias I, Q, M, D, L
de bits, ente‚Äê de bits, ente‚Äê
ros
ros

Valor que se rota

N

Input

USINT,
UINT,
UDINT

I, Q, M, D, L

N√∫mero de bits
que rota el valor
(IN)

Secuencias Secuencias I, Q, M, D, L
de bits, ente‚Äê de bits, ente‚Äê
ros
ros

Resultado de la
instrucci√≥n

Valor de funci√≥n

USINT,
UINT,
UDINT,
ULINT

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := ROL(IN := "Tag_Value",
N := "Tag_Number");

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2007

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

Tag_Value

1010 1000 1111 0110

N

Tag_Number

5

Valor de funci√≥n

Tag_Result

0001 1110 1101 0101

El contenido del operando "Tag_Value" se rota cinco posiciones de bit hacia la izquierda. El
resultado de la instrucci√≥n se devuelve en el operando "Tag_Result" como valor de funci√≥n.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Legacy
DRUM: Materializar circuito secuencial sucesivo
Descripci√≥n
La instrucci√≥n "Materializar circuito secuencial sucesivo" ocupa los bits de salida programados
(OUT1 a OUT16) y la palabra de salida (OUT_WORD) con los valores programados del
par√°metro OUT_VAL del paso respectivo. El paso en cuesti√≥n debe cumplir las condiciones de
la m√°scara de habilitaci√≥n programada en el par√°metro S_MASK mientras la instrucci√≥n
permanece en dicho paso. La instrucci√≥n pasa al paso siguiente cuando el evento de √©ste es
verdadero y una vez transcurrido el tiempo programado para el paso actual, o bien cuando el
valor del par√°metro JOG cambia de "0" a "1". La instrucci√≥n se desactiva cuando el estado
l√≥gico del par√°metro RESET cambia a "1". Con ello, el paso actual se iguala al paso
predeterminado (DSP).
El tiempo de permanencia en un paso se calcula multiplicando la base de tiempo
predeterminada (DTBP) por el valor de contaje predeterminado (S_PRESET) para cada paso.
Al comienzo de un nuevo paso, este valor calculado se carga en el par√°metro DCC, que
contiene el tiempo restante para el paso actual. Por ejemplo, si el valor del par√°metro DTBP es
"2" y el valor predeterminado para el primer paso es "100" (100 ms), el par√°metro DCC
devolver√° el valor "200" (200 ms).
Un paso puede programarse con un valor de tiempo, con un evento o con ambos. Los pasos
programados con un bit de evento y el valor de tiempo "0" pasan al siguiente paso en cuanto
el estado l√≥gico del bit de evento es "1". Los pasos programados solo con un valor de tiempo
empiezan a contar el tiempo inmediatamente. Los pasos programados con un bit de evento y
un valor de tiempo mayor que "0" empiezan a contar el tiempo en cuanto el estado l√≥gico del
bit de evento es "1". Los bits de evento se inicializan con el estado l√≥gico "1".
Si el circuito secuencial sucesivo se encuentra en el √∫ltimo paso programado (LST_STEP) y ha
transcurrido el tiempo para dicho paso, el estado l√≥gico del par√°metro Q se pone a "1". De lo
contrario, se pone a "0". Si est√° activado el par√°metro Q, la instrucci√≥n permanece en el paso
hasta la desactivaci√≥n.

2008

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En la m√°scara configurable (S_MASK) es posible seleccionar los distintos bits de la palabra de
salida (OUT_WORD) y activar o desactivar los bits de salida (OUT1 a OUT16) mediante los
valores de salida (OUT_VAL). Si un bit de la m√°scara configurable tiene el estado l√≥gico "1",
el valor OUT_VAL activa o desactiva el bit correspondiente. Si el estado l√≥gico de un bit de la
m√°scara configurable es "0", no cambia el bit respectivo. Todos los bits de la m√°scara
configurable de todos los 16 pasos se inicializan con el estado l√≥gico "1".
El bit de salida del par√°metro OUT1 equivale al bit menos significativo de la palabra de salida
(OUT_WORD). El bit de salida del par√°metro OUT16 equivale al bit m√°s significativo de la
palabra de salida (OUT_WORD).

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

RESET

Input

BOOL

I, Q, M, D, L

El estado l√≥gico "1" indica
una condici√≥n de desactiva‚Äê
ci√≥n.

JOG

Input

BOOL

I, Q, M, D, L

Si el estado l√≥gico cambia de
"0" a "1", la instrucci√≥n pasa
al siguiente paso.

DRUM_EN

Input

BOOL

I, Q, M, D, L

El estado l√≥gico "1" permite
que el circuito secuencial su‚Äê
cesivo siga contando seg√∫n
el evento y los criterios de
tiempo.

LST_STEP

Input

BYTE

I, Q, M, D, L

N√∫mero m√°ximo de etapas
(p. ej.: LST_STEP = 16#08;
son posibles 8 etapas como
m√°ximo.)

EVENT(i),

Input

BOOL

I, Q, M, D, L

OUT(j),

Bit de evento (i);
El estado l√≥gico inicial es "1".

1 ‚â§ i ‚â§ 16
Output

BOOL

I, Q, M, D, L

Bit de salida (j)

Q

Output

BOOL

I, Q, M, D, L

El estado l√≥gico "1" indica
que ha transcurrido el tiempo
del √∫ltimo paso.

OUT_WORD

Output

WORD

I, Q, M, D, L, P

Direcci√≥n de palabra en la
que el circuito secuencial su‚Äê
cesivo escribe los valores de
salida.

ERR_CODE

Output

WORD

I, Q, M, D, L, P

Informaci√≥n de error

JOG_HIS

Static

BOOL

I, Q, M, D, L

Bit de evoluci√≥n del par√°me‚Äê
tro JOG

EOD

Static

BOOL

I, Q, M, D, L

El estado l√≥gico "1" indica
que ha transcurrido el tiempo
del √∫ltimo paso.

DSP

Static

BYTE

I, Q, M, D, L, P

Paso predeterminado del cir‚Äê
cuito secuencial sucesivo

1 ‚â§ j ‚â§ 16

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2009

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

DSC

Static

BYTE

I, Q, M, D, L, P

Paso actual del circuito se‚Äê
cuencial sucesivo

DCC

Static

DWORD

I, Q, M, D, L, P

Valor de contaje actual del
circuito secuencial sucesivo

DTBP

Static

WORD

I, Q, M, D, L, P

Base de tiempo predetermi‚Äê
nada del circuito secuencial
sucesivo

PrevTime

Static

TIME

I, Q, M, D, L

Hora de sistema anterior

S_PRESET

Static

ARRAY[1..16] of
WORD

I, Q, M, D, L

Valor de contaje predetermi‚Äê
nado para cada paso [1 a 16];
1 ciclo de reloj = 1 ms.

OUT_VAL

Static

ARRAY[1..16,
0..15] of BOOL

I, Q, M, D, L

Valores de salida para cada
etapa [1 a 16, 0 a 15].

S_MASK

Static

ARRAY[1..16,
0..15] of BOOL

I, Q, M, D, L

M√°scara configurable para
cada etapa [1 a 16, 0 a 15].
Los estados l√≥gicos iniciales
son "1".

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro ERR_CODE
La tabla siguiente muestra el significado de los valores del par√°metro ERR_CODE:
ERR_CO‚Äê
DE*

Explicaci√≥n

W#16#000
0

Ning√∫n error

W#16#000
B

El valor del par√°metro LST_STEP es menor que 1 o mayor que 16.

W#16#000
C

El valor del par√°metro DSC es menor que 1 o mayor que el valor del par√°metro
LST_STEP.

W#16#000
D

El valor del par√°metro DSP es menor que 1 o mayor que el valor de LST_STEP.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
En el ejemplo siguiente, la instrucci√≥n pasa del paso 1 al paso 2. Los bits de salida (OUT1 a
OUT16) y la palabra de salida (OUT_WORD) se activan seg√∫n la m√°scara configurada para el
paso 2 y los valores del par√°metro OUT_VAL.
Nota
Los par√°metros est√°ticos pueden inicializarse en el bloque de datos.

2010

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

SCL
"DRUM_DB"(RESET := "Tag_Reset"
JOG := "Tag_Input_Jog"
DRUM_EN := "Tag_Input_DrumEN"
LST_STEP := "Tag_Number_LastStep"
EVENT1 := "MyTag_Event_1"
EVENT2 := "MyTag_Event_2"
EVENT3 := "MyTag_Event_3"
EVENT4 := "MyTag_Event_4"
EVENT5 := "MyTag_Event_5"
EVENT6 := "MyTag_Event_6"
EVENT7 := "MyTag_Event_7"
EVENT8 := "MyTag_Event_8"
EVENT9 := "MyTag_Event_9"
EVENT10 := "MyTag_Event_10"
EVENT11 := "MyTag_Event_11"
EVENT12 := "MyTag_Event_12"
EVENT13 := "MyTag_Event_13"
EVENT14 := "MyTag_Event_14"
EVENT15 := "MyTag_Event_15"
EVENT16 := "MyTag_Event_16"
OUT1 => "MyTag_Output_1"
OUT2 => "MyTag_Output_2"
OUT3 => "MyTag_Output_3"
OUT4 => "MyTag_Output_4"
OUT5 => "MyTag_Output_5"
OUT6 => "MyTag_Output_6"
OUT7 => "MyTag_Output_7"
OUT8 => "MyTag_Output_8"
OUT9 => "MyTag_Output_9"
OUT10 => "MyTag_Output_10"
OUT11 => "MyTag_Output_11"
OUT12 => "MyTag_Output_12"
OUT13 => "MyTag_Output_13"
OUT14 => "MyTag_Output_14"
OUT15 => "MyTag_Output_15"
OUT16 => "MyTag_Output_16"
Q => "Tag_Output_Q"
OUT_WORD => "Tag_OutputWord"
ERR_CODE => "Tag_ErrorCode");

Las tablas siguientes muestran el funcionamiento de la instrucci√≥n con valores concretos.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2011

Instrucciones
4.1 Instrucciones

Antes de la ejecuci√≥n
En este ejemplo se utilizan los siguientes valores para asignar valores a los par√°metros de
entrada:
Par√°metro

Operando

Direcci√≥n

Valor

RESET

Tag_Reset

M0.0

FALSE

JOG

Tag_Input_JOG

M0.1

FALSE

DRUM_EN

Tag_Input_DrumEN

M0.2

TRUE

LST_STEP

Tag_Number_LastStep

MB1

B#16#08

EVENT2

MyTag_Event_2

M20.0

FALSE

EVENT4

MyTag_Event_4

M20.1

FALSE

EVENT6

MyTag_Event_6

M20.2

FALSE

EVENT8

MyTag_Event_8

M20.3

FALSE

EVENT10

MyTag_Event_10

M20.4

FALSE

EVENT12

MyTag_Event_12

M20.5

FALSE

EVENT14

MyTag_Event_14

M20.6

FALSE

EVENT16

MyTag_Event_16

M20.7

FALSE

En el bloque de datos de instancia "DRUM_DB" de la instrucci√≥n se guardan los siguientes
valores:
Par√°metro

2012

Direcci√≥n

Valor

JOG_HIS

DBX12.0

FALSE

EOD

DBX12.1

FALSE

DSP

DBB13

W#16#0001

DSC

DBB14

W#16#0001

DCC

DBD16

DW#16#0000000A

DTBP

DBW20

W#16#0001

S_PRESET[1]

DBW26

W#16#0064

S_PRESET[2]

DBW28

W#16#00C8

OUT_VAL[1,0]

DBX58.0

TRUE

OUT_VAL[1,1]

DBX58.1

TRUE

OUT_VAL[1,2]

DBX58.2

TRUE

OUT_VAL[1,3]

DBX58.3

TRUE

OUT_VAL[1,4]

DBX58.4

TRUE

OUT_VAL[1,5]

DBX58.5

TRUE

OUT_VAL[1,6]

DBX58.6

TRUE

OUT_VAL[1,7]

DBX58.7

TRUE

OUT_VAL[1,8]

DBX59.0

TRUE

OUT_VAL[1,9]

DBX59.1

TRUE

OUT_VAL[1,10]

DBX59.2

TRUE

OUT_VAL[1,11]

DBX59.3

TRUE

OUT_VAL[1,12]

DBX59.4

TRUE

OUT_VAL[1,13]

DBX59.5

TRUE

OUT_VAL[1,14]

DBX59.6

TRUE

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Direcci√≥n

Valor

OUT_VAL[1,15]

DBX59.7

TRUE

OUT_VAL[2,0]

DBX60.0

FALSE

OUT_VAL[2,1]

DBX60.1

FALSE

OUT_VAL[2,2]

DBX60.2

FALSE

OUT_VAL[2,3]

DBX60.3

FALSE

OUT_VAL[2,4]

DBX60.4

FALSE

OUT_VAL[2,5]

DBX60.5

FALSE

OUT_VAL[2,6]

DBX60.6

FALSE

OUT_VAL[2,7]

DBX60.7

FALSE

OUT_VAL[2,8]

DBX61.0

FALSE

OUT_VAL[2,9]

DBX61.1

FALSE

OUT_VAL[2,10]

DBX61.2

FALSE

OUT_VAL[2,11]

DBX61.3

FALSE

OUT_VAL[2,12]

DBX61.4

FALSE

OUT_VAL[2,13]

DBX61.5

FALSE

OUT_VAL[2,14]

DBX61.6

FALSE

OUT_VAL[2,15]

DBX61.7

FALSE

S_MASK[2,0]

DBX92.0

FALSE

S_MASK[2,1]

DBX92.1

TRUE

S_MASK[2,2]

DBX92.2

TRUE

S_MASK[2,3]

DBX92.3

TRUE

S_MASK[2,4]

DBX92.4

TRUE

S_MASK[2,5]

DBX92.5

FALSE

S_MASK[2,6]

DBX92.6

TRUE

S_MASK[2,7]

DBX92.7

TRUE

S_MASK[2,8]

DBX93.0

FALSE

S_MASK[2,9]

DBX93.1

FALSE

S_MASK[2,10]

DBX93.2

TRUE

S_MASK[2,11]

DBX93.3

TRUE

S_MASK[2,12]

DBX93.4

TRUE

S_MASK[2,13]

DBX93.5

TRUE

S_MASK[2,14]

DBX93.6

FALSE

S_MASK[2,15]

DBX93.7

TRUE

Los par√°metros de salida tienen los valores siguientes antes de ejecutarse la instrucci√≥n:
Par√°metro

Operando

Direcci√≥n

Valor

Q

Tag_Output_Q

M6.0

FALSE

OUTWORD

Tag_OutputWord

MW8

W#16#FFFF

OUT1

MyTag_Output_1

M4.0

TRUE

OUT2

MyTag_Output_2

M4.1

TRUE

OUT3

MyTag_Output_3

M4.2

TRUE

OUT4

MyTag_Output_4

M4.3

TRUE

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2013

Instrucciones
4.1 Instrucciones
Par√°metro

Operando

Direcci√≥n

Valor

OUT5

MyTag_Output_5

M4.4

TRUE

OUT6

MyTag_Output_6

M4.5

TRUE

OUT7

MyTag_Output_7

M4.6

TRUE

OUT8

MyTag_Output_8

M4.7

TRUE

OUT9

MyTag_Output_9

M5.0

TRUE

OUT10

MyTag_Output_10

M5.1

TRUE

OUT11

MyTag_Output_11

M5.2

TRUE

OUT12

MyTag_Output_12

M5.3

TRUE

OUT13

MyTag_Output_13

M5.4

TRUE

OUT14

MyTag_Output_14

M5.5

TRUE

OUT15

MyTag_Output_15

M5.6

TRUE

OUT16

MyTag_Output_16

M5.7

TRUE

Despu√©s de la ejecuci√≥n
Una vez ejecutada la instrucci√≥n, los valores siguientes se escriben en los par√°metros de
salida:

2014

Par√°metro

Operando

Direcci√≥n

Valor

OUT1

MyTag_Output_1

M4.0

TRUE

OUT2

MyTag_Output_2

M4.1

FALSE

OUT3

MyTag_Output_3

M4.2

FALSE

OUT4

MyTag_Output_4

M4.3

FALSE

OUT5

MyTag_Output_5

M4.4

FALSE

OUT6

MyTag_Output_6

M4.5

TRUE

OUT7

MyTag_Output_7

M4.6

FALSE

OUT8

MyTag_Output_8

M4.7

FALSE

OUT9

MyTag_Output_9

M5.0

TRUE

OUT10

MyTag_Output_10

M5.1

TRUE

OUT11

MyTag_Output_11

M5.2

FALSE

OUT12

MyTag_Output_12

M5.3

FALSE

OUT13

MyTag_Output_13

M5.4

FALSE

OUT14

MyTag_Output_14

M5.5

FALSE

OUT15

MyTag_Output_15

M5.6

TRUE

OUT16

MyTag_Output_16

M5.7

FALSE

Q

Tag_Output_Q

M6.0

FALSE

OUTWORD

Tag_OutputWord

MW8

W#16#4321

ERR_CODE

Tag_ErrorCode

MW10

W#16#0000

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los siguientes valores se modifican en el bloque de datos de instancia "DRUM_DB" de la
instrucci√≥n despu√©s de su ejecuci√≥n:
Par√°metro

Direcci√≥n

Valor

JOG_HIS

DBX12.0

FALSE

EOD

DBX12.1

FALSE

DSC

DBB14

W#16#0002

DCC

DBD16

DW#16#000000C8

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de SCL (P√°gina 8115)

DCAT: Alarma de tiempo para control discreto
Descripci√≥n
La instrucci√≥n "Alarma de tiempo para control discreto" acumula el tiempo desde el instante en
el que el par√°metro CMD da la orden de abrir o cerrar. El tiempo se acumula hasta excederse
el tiempo predeterminado (PT) o hasta recibir la notificaci√≥n de que el dispositivo se ha cerrado
o abierto dentro del tiempo prescrito (O_FB o C_FB). Si se excede el tiempo predeterminado
antes de recibirse la notificaci√≥n de que se ha abierto o cerrado el dispositivo, se activa la
alarma correspondiente. Si el estado l√≥gico de la entrada de la orden cambia antes del tiempo
predeterminado, se reinicia el tiempo.
La instrucci√≥n "Alarma de tiempo para control discreto" tiene las reacciones siguientes en las
condiciones de entrada:
‚óè Si el estado l√≥gico del par√°metro CMD cambia de "0" a "1", esto tiene los efectos siguientes
en los estados l√≥gicos de los par√°metros Q, CMD_HIS, ET (solo si ET < PT), OA y CA:
‚Äì Los par√°metros Q y CMD_HIS se ponen a "1"
‚Äì Los par√°metros ET, OA y CA se ponen a "0"
‚óè Si el estado l√≥gico del par√°metro CMD cambia de "1" a "0", los par√°metros Q, ET (solo si
ET < PT), OA, CA y CMD_HIS se ponen a "0".
‚óè Si los par√°metros CMD y CMD_HIS tienen el estado l√≥gico "1" y el par√°metro O_FB se pone
a "0", la diferencia de tiempo (ms) desde la √∫ltima ejecuci√≥n de la instrucci√≥n se suma al
valor del par√°metro ET. Si el valor del par√°metro ET excede el del par√°metro PT, el estado
l√≥gico del par√°metro OA se pone a "1". Si el valor del par√°metro ET no excede el del
par√°metro PT, el estado l√≥gico del par√°metro OA se pone a "0". El valor del par√°metro
CMD_HIS se pone al del par√°metro CMD.
‚óè Si los estados l√≥gicos de los par√°metros CMD, CMD_HIS y O_FB est√°n a "1" y el par√°metro
C_FB devuelve el valor "0", el estado l√≥gico del par√°metro OA se pone a "0". El valor del
par√°metro ET se pone al del par√°metro PT. Si el estado l√≥gico del par√°metro O_FB cambia
a "0", se activa la alarma en la siguiente ejecuci√≥n de la instrucci√≥n. El valor del par√°metro
CMD_HIS se pone al del par√°metro CMD.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2015

Instrucciones
4.1 Instrucciones
‚óè Si los par√°metros CMD, CMD_HIS y C_FB devuelven "0", la diferencia de tiempo (ms)
desde la √∫ltima ejecuci√≥n de la instrucci√≥n se suma al valor del par√°metro ET. Si el valor del
par√°metro ET excede el del par√°metro PT, el estado l√≥gico del par√°metro CA se pone a "1".
Si no se excede el valor del par√°metro PT, el par√°metro CA devuelve el estado l√≥gico "0".
El valor del par√°metro CMD_HIS se pone al del par√°metro CMD.
‚óè Si los par√°metros CMD, CMD_HIS y O_FB devuelven el estado l√≥gico "0" y el par√°metro
C_FB est√° a "1", el par√°metro CA se pone a "0". El valor del par√°metro ET se pone al del
par√°metro PT. Si el estado l√≥gico del par√°metro C_FB cambia a "0", se activa la alarma en
la siguiente ejecuci√≥n de la instrucci√≥n. El valor del par√°metro CMD_HIS se pone al del
par√°metro CMD.
‚óè Si los par√°metros O_FB y C_FB devuelven simult√°neamente el estado l√≥gico "1", los
estados l√≥gicos de ambas salidas de alarma se ponen a "1".
La instrucci√≥n "Alarma de tiempo para control discreto" no devuelve informaci√≥n de error.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de da‚Äê √Årea de memoria Descripci√≥n
tos

CMD

Input

BOOL

I, Q, M, D, L

El estado l√≥gico "0" da la orden de
"Cerrar".
El estado l√≥gico "1" da la orden de
"Abrir".

O_FB

Input

BOOL

I, Q, M, D, L

Entrada de realimentaci√≥n al abrir

C_FB

Input

BOOL

I, Q, M, D, L

Entrada de realimentaci√≥n al ce‚Äê
rrar

Q

Output

BOOL

I, Q, M, D, L

Indica el estado del par√°metro
CMD

OA

Output

BOOL

I, Q, M, D, L

Salida de alarma al abrir

CA

Output

BOOL

I, Q, M, D, L

Salida de alarma al cerrar

ET

Static

DINT

D, L

Tiempo actual transcurrido; un ci‚Äê
clo de reloj = 1 ms.

PT

Static

DINT

D, L

Valor de tiempo predeterminado;
un ciclo de reloj = 1 ms.

PREV_TIME

Static

DWORD

D, L

Hora de sistema anterior

CMD_HIS

Static

BOOL

D, L

Bit de evoluci√≥n de CMD

Los par√°metros est√°ticos no son visibles al efectuar la llamada de la instrucci√≥n en el
programa. Estos se almacenan en la instancia de la instrucci√≥n.

2016

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
En el ejemplo siguiente, el par√°metro CMD cambia de "0" a "1". Una vez ejecutada la
instrucci√≥n, el par√°metro Q se pone a "1" y las dos salidas de alarma OA y CA se ponen a "0".
El par√°metro CMD_HIS del bloque de datos de instancia se pone a "1" y el par√°metro ET se
pone a "0".
Nota
Los par√°metros est√°ticos pueden inicializarse en el bloque de datos.

SCL
"DCAT_DB"(CMD := "Tag_Input_CMD",
O_FB := "Tag_Input_O_FB",
C_FB := "Tag_Input_C_FB",
Q => "Tag_Output_Q",
OA => "Tag_Output_OA",
CA => "Tag_Output_CA");

Las tablas siguientes muestran el funcionamiento de la instrucci√≥n con valores concretos.
Antes de la ejecuci√≥n
En este ejemplo se utilizan los siguientes valores para los par√°metros de entrada y salida:
Par√°metro

Operando

Valor

CMD

Tag_Input_CMD

TRUE

O_FB

Tag_Input_O_FB

FALSE

C_FB

Tag_Input_C_FB

FALSE

Q

Tag_Output_Q

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Los siguientes valores se almacenan en el bloque de datos de instancia "DCAT_DB" de la
instrucci√≥n:
Par√°metro

Direcci√≥n

Valor

ET

DBD4

L#12

PT

DBD8

L#222

CMD_HIS

DBX16.0

FALSE

Despu√©s de la ejecuci√≥n
Una vez ejecutada la instrucci√≥n, los valores siguientes se escriben en los par√°metros de
salida:
Par√°metro

Operando

Valor

Q

Tag_Output_Q

TRUE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2017

Instrucciones
4.1 Instrucciones
Los siguientes valores se almacenan en el bloque de datos de instancia "DCAT_DB" de la
instrucci√≥n:
Par√°metro

Direcci√≥n

Valor

ET

DBD4

L#0

CMD_HIS

DBX16.0

TRUE

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

MCAT: Alarma de tiempo para control del motor
Descripci√≥n
La instrucci√≥n "Alarma de tiempo para control del motor" acumula el tiempo desde el instante
en el que se activa una de las entradas de comando (abrir o cerrar). El tiempo se acumula hasta
que se excede el tiempo predeterminado o hasta que la entrada de realimentaci√≥n
correspondiente indica que el dispositivo ha ejecutado la operaci√≥n solicitada dentro del
tiempo prescrito. Si se excede el tiempo predeterminado antes de recibir respuesta, se dispara
la alarma correspondiente.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:

2018

Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

O_CMD

Input

BOOL

I, Q, M, D, L

Entrada del comando "Abrir"

C_CMD

Input

BOOL

I, Q, M, D, L

Entrada del comando "Ce‚Äê
rrar"

S_CMD

Input

BOOL

I, Q, M, D, L

Entrada del comando "Parar"

O_FB

Input

BOOL

I, Q, M, D, L

Entrada de respuesta al abrir

C_FB

Input

BOOL

I, Q, M, D, L

Entrada de respuesta al ce‚Äê
rrar

OO

Output

BOOL

I, Q, M, D, L

Salida "Abrir"

CO

Output

BOOL

I, Q, M, D, L

Salida "Cerrar"

OA

Output

BOOL

I, Q, M, D, L

Salida de alarma al abrir

CA

Output

BOOL

I, Q, M, D, L

Salida de alarma al cerrar

Q

Output

BOOL

I, Q, M, D, L

El estado l√≥gico "0" indica
una condici√≥n de error.

ET

Static

DINT

D, L

Tiempo actual transcurrido;
un ciclo de reloj = 1 ms

PT

Static

DINT

D, L

Valor de tiempo predetermi‚Äê
nado; un ciclo de reloj = 1 ms

PREV_TIME

Static

DWORD

D, L

Hora de sistema anterior

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

O_HIS

Static

BOOL

D, L

Bit de evoluci√≥n "Abrir"

C_HIS

Static

BOOL

D, L

Bit de evoluci√≥n "Cerrar"

Los par√°metros est√°ticos no son visibles al llamar la instrucci√≥n en el programa. Estos se
almacenan en la instancia de la instrucci√≥n.

Ejecuci√≥n de la instrucci√≥n "Alarma de tiempo para control del motor"
La tabla siguiente muestra las reacciones de la instrucci√≥n "Alarma de tiempo para control del
motor" a las distintas condiciones de entrada:
Par√°metros de entrada
O_C
MD

Par√°metros de salida

ET

O_H
IS

C_H
IS

C_C
MD

S_C
MD

X

1

1

X

X

X

X

X

X

X

X

X

X

X

X

X

X

1

X

X

X

1

1

X

X

0

X

1

0

<PT

1

0

X

0

O_F
B

C_F
B

OO

CO

OA

CA

ET

O_H
IS

C_HI Q
S

Estado

X

X

0

0

1

1

PT

0

0

0

Alarma

1

1

0

0

1

1

PT

0

0

0

Alarma

X

X

0

0

0

0

X

0

0

1

Stop

X

X

0

0

0

0

X

0

0

1

Stop

0

X

X

1

0

0

0

0

1

0

1

Empezar a
abrir

0

0

X

1

0

0

0

INC

1

0

1

Abrir

X

1

0

X

0

0

1

0

0

0

0

0

PT

1

0

1

Abierto

>=
PT

1

0

X

0

0

0

X

0

0

1

0

PT

1

0

0

Abrir alarma

X

X

0

0

1

0

X

X

0

1

0

0

0

0

1

1

Empezar a
cerrar

< PT 0

1

0

X

0

X

0

0

1

0

0

INC

0

1

1

Cerrar

X

0

1

0

X

0

0

1

0

0

0

0

PT

0

1

1

Cerrado

>=
PT

0

1

0

X

0

X

0

0

0

0

1

PT

0

1

0

Cerrar alar‚Äê
ma

X

0

0

0

0

0

X

X

0

0

0

0

X

0

0

1

Parado

Leyenda:
INC

Sumar a ET la diferencia de tiempo (en ms) desde la √∫ltima ejecuci√≥n del FB

PT

PT se pone al mismo valor que ET

X

No aplicable

< PT

ET < PT

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2019

Instrucciones
4.1 Instrucciones
Par√°metros de entrada
>= PT

Par√°metros de salida

ET >= PT

Si los par√°metros de entrada O_HIS y C_HIS tienen el estado l√≥gico "1", se ponen inmediatamente al estado l√≥gico "0". En
este caso se aplica la √∫ltima fila de la tabla mencionada m√°s arriba (X). Puesto que por este motivo no es posible comprobar
si los par√°metros de entrada O_HIS y C_HIS tienen el estado l√≥gico "1", en este caso se asigna el siguiente valor a los
par√°metros de salida:
OO = FALSE
CO = FALSE
OA = FALSE
CA = FALSE
ET = PT
Q = TRUE

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
Nota
Los par√°metros est√°ticos pueden inicializarse en el bloque de datos.

SCL
"MCAT_DB"(O_CMD := "Tag_Iput_O_CMD",
C_CMD := "Tag_Input_C_CMD",
S_CMD := "Tag_Input_S_CMD",
O_FB := "Tag_Input_O_FB",
C_FB := "Tag_Input_C_FB",
OO => "Tag_OutputOpen",
CO => "Tag_OutputClosed",
OA => "Tag_Output_OA",
CA => "Tag_Output_CA",
Q => "Tag_Output_Q");

Las tablas siguientes muestran el funcionamiento de la instrucci√≥n con valores concretos.
Antes de la ejecuci√≥n
En este ejemplo se utilizan los siguientes valores para los par√°metros de entrada y salida:

2020

Par√°metro

Operando

Valor

O_CMD

Tag_Input_O_CMD

TRUE

C_CMD

Tag_Input_C_CMD

FALSE

S_CMD

Tag_Input_S_CMD

FALSE

O_FB

Tag_Input_O_FB

FALSE

C_FB

Tag_Input_C_FB

FALSE

OO

Tag_OutputOpen

FALSE

CO

Tag_OutputClosed

FALSE

OA

Tag_Output_OA

FALSE

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Operando

Valor

CA

Tag_Output_CA

FALSE

Q

Tag_Output_Q

FALSE

En el bloque de datos de instancia "MCAT_DB" de la instrucci√≥n se guardan los siguientes
valores:
Par√°metro

Direcci√≥n

Valor

ET

DBD4

L#2

PT

DBD8

L#22

O_HIS

DBX16.0

TRUE

C_HIS

DBX16.1

FALSE

Despu√©s de la ejecuci√≥n
Una vez ejecutada la instrucci√≥n, los valores siguientes se escriben en los par√°metros de
salida:
Par√°metro

Operando

Valor

OO

Tag_OutputOpen

TRUE

CO

Tag_OutputClosed

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Q

Tag_Output_Q

TRUE

En el bloque de datos de instancia "MCAT_DB" de la instrucci√≥n se guardan los siguientes
valores:
Par√°metro

Direcci√≥n

Valor

ET

DBD4

L#0

O_HIS

DBX16.0

TRUE

CMD_HIS

DBX16.1

FALSE

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2021

Instrucciones
4.1 Instrucciones

IMC: Comparar bits de entrada con bits de una m√°scara
Descripci√≥n
La instrucci√≥n "Comparar bits de entrada con bits de una m√°scara" compara el estado l√≥gico
de hasta 16 bits de entrada programados (IN_BIT0 a IN_BIT15) con el bit correspondiente de
una m√°scara. Es posible programar como m√°ximo 16 pasos con m√°scaras. El valor del
par√°metro IN_BIT0 se compara con el valor de la m√°scara CMP_VAL[x,0], siendo "x" el
n√∫mero del paso. El n√∫mero del paso de la m√°scara utilizada para la comparaci√≥n se define en
el par√°metro CMP_STEP. De esta misma manera se comparan todos los valores
programados. Los bits de entrada no programados o los bits no programados de la m√°scara
tienen el estado l√≥gico predeterminado FALSE.
Si se encuentra una correspondencia al realizar la comparaci√≥n, el estado l√≥gico del par√°metro
OUT se pone a "1". De lo contrario, el par√°metro OUT se pone a "0".
Si el valor del par√°metro CMP_STEP es mayor que 15, no se ejecuta la instrucci√≥n. En el
par√°metro ERR_CODE se emite un mensaje de error.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:

2022

Par√°metro

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN_BIT0

Input

BOOL

I, Q, M, D, L

El bit de entrada 0 se compara con el
bit 0 de la m√°scara.

IN_BIT1

Input

BOOL

I, Q, M, D, L

El bit de entrada 1 se compara con el
bit 1 de la m√°scara.

IN_BIT2

Input

BOOL

I, Q, M, D, L

El bit de entrada 2 se compara con el
bit 2 de la m√°scara.

IN_BIT3

Input

BOOL

I, Q, M, D, L

El bit de entrada 3 se compara con el
bit 3 de la m√°scara.

IN_BIT4

Input

BOOL

I, Q, M, D, L

El bit de entrada 4 se compara con el
bit 4 de la m√°scara.

IN_BIT5

Input

BOOL

I, Q, M, D, L

El bit de entrada 5 se compara con el
bit 5 de la m√°scara.

IN_BIT6

Input

BOOL

I, Q, M, D, L

El bit de entrada 6 se compara con el
bit 6 de la m√°scara.

IN_BIT7

Input

BOOL

I, Q, M, D, L

El bit de entrada 7 se compara con el
bit 7 de la m√°scara.

IN_BIT8

Input

BOOL

I, Q, M, D, L

El bit de entrada 8 se compara con el
bit 8 de la m√°scara.

IN_BIT9

Input

BOOL

I, Q, M, D, L

El bit de entrada 9 se compara con el
bit 9 de la m√°scara.

IN_BIT10

Input

BOOL

I, Q, M, D, L

El bit de entrada 10 se compara con
el bit 10 de la m√°scara.

IN_BIT11

Input

BOOL

I, Q, M, D, L

El bit de entrada 11 se compara con
el bit 11 de la m√°scara.

IN_BIT12

Input

BOOL

I, Q, M, D, L

El bit de entrada 12 se compara con
el bit 12 de la m√°scara.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN_BIT13

Input

BOOL

I, Q, M, D, L

El bit de entrada 13 se compara con
el bit 13 de la m√°scara.

IN_BIT14

Input

BOOL

I, Q, M, D, L

El bit de entrada 14 se compara con
el bit 14 de la m√°scara.

IN_BIT15

Input

BOOL

I, Q, M, D, L

El bit de entrada 15 se compara con
el bit 15 de la m√°scara.

CMP_STEP Input

BYTE

I, Q, M, D, L, P

N√∫mero de paso de la m√°scara con
la que se compara.

OUT

BOOL

I, Q, M, D, L

El estado l√≥gico "1" indica que se ha
encontrado una correspondencia.

Output

El estado l√≥gico "0" indica que no se
ha encontrado ninguna correspon‚Äê
dencia.
ERR_CO‚Äê
DE

Output

WORD

I, Q, M, D, L, P

Informaci√≥n de error

CMP_VAL

Static

ARRAY OF
WORD

I, Q, M, D, L

M√°scaras de comparaci√≥n [0 a 15, 0
a 15]: El primer n√∫mero del √≠ndice es
el n√∫mero del paso y, el segundo, el
n√∫mero de bit de la m√°scara.

Los par√°metros est√°ticos no son visibles al efectuar la llamada de la instrucci√≥n en el
programa. Estos se almacenan en la instancia de la instrucci√≥n.

Par√°metro ERR_CODE
La tabla siguiente muestra el significado de los valores del par√°metro ERR_CODE:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

000A

El valor del par√°metro CMP_STEP es mayor que 15.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2023

Instrucciones
4.1 Instrucciones

SMC: Barrido de matriz
Descripci√≥n
La instrucci√≥n "Barrido de matriz" compara el estado l√≥gico de hasta 16 bits de entrada
programados (IN_BIT0 a IN_BIT15) con los bits correspondientes de las m√°scaras de
comparaci√≥n de cada paso. La ejecuci√≥n empieza por el paso 1 y contin√∫a hasta el √∫ltimo paso
programado (LAST) o hasta que se encuentre una correspondencia. El bit de entrada del
par√°metro IN_BIT0 se compara con el valor de la m√°scara CMP_VAL[x,0], siendo "x" el
n√∫mero de paso. De esta misma manera se comparan todos los valores programados. Si se
encuentra una correspondencia, el estado l√≥gico del par√°metro OUT se pone a "1" y el n√∫mero
de paso se escribe con la m√°scara correspondiente en el par√°metro OUT_STEP. Los bits de
entrada no programados o los bits no programados de la m√°scara tienen el estado l√≥gico
predeterminado FALSE. Si varios pasos tienen una m√°scara equivalente, se indica solo la
primera correspondencia encontrada en el par√°metro OUT_STEP. Si no se encuentra ninguna
correspondencia, el estado l√≥gico del par√°metro OUT se pone a "0". En este caso, el valor del
par√°metro OUT_STEP excede en "1" el valor del par√°metro LAST.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:

2024

Par√°metros

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN_BIT0

Input

BOOL

I, Q, M, D, L

El bit de entrada 0 se compara con el
bit 0 de la m√°scara.

IN_BIT1

Input

BOOL

I, Q, M, D, L

El bit de entrada 1 se compara con el
bit 1 de la m√°scara.

IN_BIT2

Input

BOOL

I, Q, M, D, L

El bit de entrada 2 se compara con el
bit 2 de la m√°scara.

IN_BIT3

Input

BOOL

I, Q, M, D, L

El bit de entrada 3 se compara con el
bit 3 de la m√°scara.

IN_BIT4

Input

BOOL

I, Q, M, D, L

El bit de entrada 4 se compara con el
bit 4 de la m√°scara.

IN_BIT5

Input

BOOL

I, Q, M, D, L

El bit de entrada 5 se compara con el
bit 5 de la m√°scara.

IN_BIT6

Input

BOOL

I, Q, M, D, L

El bit de entrada 6 se compara con el
bit 6 de la m√°scara.

IN_BIT7

Input

BOOL

I, Q, M, D, L

El bit de entrada 7 se compara con el
bit 7 de la m√°scara.

IN_BIT8

Input

BOOL

I, Q, M, D, L

El bit de entrada 8 se compara con el
bit 8 de la m√°scara.

IN_BIT9

Input

BOOL

I, Q, M, D, L

El bit de entrada 9 se compara con el
bit 9 de la m√°scara.

IN_BIT10

Input

BOOL

I, Q, M, D, L

El bit de entrada 10 se compara con
el bit 10 de la m√°scara.

IN_BIT11

Input

BOOL

I, Q, M, D, L

El bit de entrada 11 se compara con
el bit 11 de la m√°scara.

IN_BIT12

Input

BOOL

I, Q, M, D, L

El bit de entrada 12 se compara con
el bit 12 de la m√°scara.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metros

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN_BIT13

Input

BOOL

I, Q, M, D, L

El bit de entrada 13 se compara con
el bit 13 de la m√°scara.

IN_BIT14

Input

BOOL

I, Q, M, D, L

El bit de entrada 14 se compara con
el bit 14 de la m√°scara.

IN_BIT15

Input

BOOL

I, Q, M, D, L

El bit de entrada 15 se compara con
el bit 15 de la m√°scara.

OUT

Output

BOOL

I, Q, M, D, L

El estado l√≥gico "1" indica que se ha
encontrado una correspondencia.
El estado l√≥gico "0" indica que no se
ha encontrado ninguna correspon‚Äê
dencia.

OUT_STEP

Output

BYTE

I, Q, M, D, L, P

Contiene el n√∫mero de paso con la
m√°scara correspondiente o el n√∫me‚Äê
ro de paso que excede en "1" el valor
del par√°metro LAST, si no se ha en‚Äê
contrado ninguna correspondencia.

ERR_CO‚Äê
DE

Output

WORD

I, Q, M, D, L, P

Informaci√≥n de error

LAST

Static

BYTE

I, Q, M, D, L, P

Indica el n√∫mero del √∫ltimo paso en
que se tiene que buscar una m√°scara
correspondiente.

CMP_VAL

Static

ARRAY OF
WORD

I, Q, M, D, L

M√°scaras de comparaci√≥n [0 a 15, 0
a 15]: El primer n√∫mero del √≠ndice es
el n√∫mero del paso y, el segundo, el
n√∫mero de bit de la m√°scara.

Los par√°metros est√°ticos no son visibles al efectuar la llamada de la instrucci√≥n en el
programa. Estos se almacenan en la instancia de la instrucci√≥n.

Par√°metro ERR_CODE
La tabla siguiente muestra el significado de los valores del par√°metro ERR_CODE:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

000E

El valor del par√°metro LAST es mayor que 15.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de SCL (P√°gina 8115)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2025

Instrucciones
4.1 Instrucciones

LEAD_LAG: Algoritmo Lead y Lag
Descripci√≥n
La instrucci√≥n "Algoritmo Lead y Lag" procesa se√±ales con una variable anal√≥gica. El valor de
la ganancia en el par√°metro GAIN debe ser mayor que cero. El resultado de la instrucci√≥n
"Algoritmo Lead y Lag" se calcula con la siguiente ecuaci√≥n:
287

/*B7,0(
/'B7,0(6$03/(B7
/'B7,0(
,1*$,1
35(9B287*$,1
/*B7,0(6$03/(B7
/*B7,0(6$03/(B7
/*B7,0(6$03/(B7

35(9B,1

La instrucci√≥n "Algoritmo Lead y Lag" solo devuelve resultados relevantes cuando se ejecuta
en ciclos de programa fijos. Deben indicarse las mismas unidades en los par√°metros
LD_TIME, LG_TIME y SAMPLE_T. Si LG_TIME > 4 + SAMPLE_T, la instrucci√≥n se aproxima
a la siguiente funci√≥n:
OUT = GAIN * ((1 + LD_TIME * s) / (1 + LG_TIME * s)) * IN
Si el valor del par√°metro GAIN es menor o igual a cero, no se realiza el c√°lculo y el par√°metro
ERR_CODE devuelve una informaci√≥n de error.
La instrucci√≥n "Algoritmo Lead y Lag" puede utilizarse junto con bucles para la compensaci√≥n
en el control anticipativo. La instrucci√≥n comprende dos operaciones. La operaci√≥n "Lead"
desplaza la fase de la salida OUT, anticip√°ndose la salida a la entrada. En cambio, la operaci√≥n
"Lag" desplaza la salida, de manera que la salida sigue a la entrada. Puesto que la operaci√≥n
"Lag" equivale a una integraci√≥n, puede utilizarse como supresor de perturbaciones o filtro de
paso bajo. La operaci√≥n "Lead" equivale a una acci√≥n diferencial, por lo que puede utilizarse
como un filtro de paso alto. La combinaci√≥n de ambas operaciones (Lead y Lag) hace que la
fase de salida siga a la entrada a bajas frecuencias y se le anticipe a altas frecuencias. Por este
motivo, la instrucci√≥n "Algoritmo Lead y Lag" puede utilizarse como si fuera un filtro de paso de
banda.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

REAL

I, Q, M, D, L, P

Valor de entrada
del tiempo de
muestreo actual
(tiempo de ciclo)
que se procesa.
En el par√°metro IN
tambi√©n se pueden
indicar constantes.

SAMPLE_T

Input

INT

I, Q, M, D, L, P

Tiempo de mues‚Äê
treo
En el par√°metro
SAMPLE_T tam‚Äê
bi√©n se pueden in‚Äê
dicar constantes.

OUT

2026

Output

REAL

I, Q, M, D, L

Resultado de la ins‚Äê
trucci√≥n

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

ERR_CODE

Output

WORD

I, Q, M, D, L

Informaci√≥n de
error

LD_TIME

Static

REAL

I, Q, M, D, L, P

Tiempo de anticipa‚Äê
ci√≥n en la misma
unidad que el tiem‚Äê
po de muestreo.

LG_TIME

Static

REAL

I, Q, M, D, L, P

Tiempo de segui‚Äê
miento en la misma
unidad que el tiem‚Äê
po de muestreo.

GAIN

Static

REAL

I, Q, M, D, L, P

Ganancia en % / %
(relaci√≥n del cam‚Äê
bio en la salida con
respecto al cambio
en la entrada como
estado constante).

PREV_IN

Static

REAL

I, Q, M, D, L, P

Entrada anterior

PREV_OUT

Static

REAL

I, Q, M, D, L, P

Salida anterior

Los par√°metros est√°ticos no son visibles al efectuar la llamada de la instrucci√≥n en el
programa. Estos se almacenan en la instancia de la instrucci√≥n.

Par√°metro ERR_CODE
La tabla siguiente muestra el significado de los valores del par√°metro ERR_CODE:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

0009

El valor del par√°metro GAIN es menor o igual a cero.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
Nota
Los par√°metros est√°ticos pueden inicializarse en el bloque de datos.

SCL
"LEAD_LAG_DB"(IN := "Tag_Input",
SAMPLE_T := "Tag_Input_SAMPLE_T",
OUT => "Tag_Output_Result",
ERR_CODE => "Tag_ErrorCode");

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2027

Instrucciones
4.1 Instrucciones
Las tablas siguientes muestran el funcionamiento de la instrucci√≥n con valores concretos.
Antes de la ejecuci√≥n
En este ejemplo se utilizan los siguientes valores para los par√°metros de entrada:
Par√°metro

Operando

Valor

IN

Tag_Input

2.0

SAMPLE_T

Tag_Input_SAMPLE_T

10

Los siguientes valores se almacenan en el bloque de datos de instancia "LEAD_LAG_DB" de
la instrucci√≥n:
Par√°metro

Direcci√≥n

Valor

LD_TIME

DBD12

2.0

LG_TIME

DBD16

2.0

GAIN

DBD20

1.0

PREV_IN

DBD24

6.0

PREV_OUT

DBD28

6.0

Despu√©s de la ejecuci√≥n
Una vez ejecutada la instrucci√≥n, los valores siguientes se escriben en los par√°metros de
salida:
Par√°metro

Operando

Valor

OUT

Tag_Output_Result

2.0

Los siguientes valores se guardan en el bloque de datos de instancia "LEAD_LAD_DB" de la
instrucci√≥n:
Par√°metro

Operando

Valor

PREV_IN

DBD24

2.0

PREV_OUT

DBD28

2.0

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de SCL (P√°gina 8115)

SEG: Generar patr√≥n de bits para el display de 7 segmentos
Descripci√≥n
La instrucci√≥n "Generar patr√≥n de bits para el display de 7 segmentos" convierte cada una de
las cuatro cifras hexadecimales de la palabra de origen indicada (IN) en un patr√≥n de bits
equivalente para un display de 7 segmentos. El resultado de la instrucci√≥n se deposita en la
palabra doble del par√°metro OUT.

2028

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Entre las cifras hexadecimales y la ocupaci√≥n de los 7 segmentos (a, b, c, d, e, f, g) existe la
siguiente relaci√≥n:
Cifra de en‚Äê
trada

Ocupaci√≥n de los
segmentos

Display

(binaria)

‚Äëgfedcba

0000

00111111

0

0001

00000110

1

0010

01011011

2

0011

01001111

3

0100

01100110

4

0101

01101101

5

0110

01111101

6

0111

00000111

7

1000

01111111

8

1001

01100111

9

1010

01110111

A

1011

01111100

B

1100

00111001

C

1101

01011110

D

1110

01111001

E

1111

01110001

F

Display de siete segmentos

(hexadecimal)
D
I

E
J

H

F
G

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

WORD

I, Q, M, D, L, P

Palabra de origen
con cuatro cifras
hexadecimales

OUT

Output

DWORD

I, Q, M, D, L, P

Patr√≥n de bits para
el display de 7 seg‚Äê
mentos

Valor de funci√≥n

VOID

Valor de funci√≥n va‚Äê
c√≠o

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
SEG(IN := "Tag_Input",
OUT => "Tag_Output");

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2029

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor
Hexadecimal

Binario

IN

Tag_Input

W#16#1234

0001 0010 0011 0100

OUT

Tag_Output

DW16#065B4F66

00000110 01011011 01001111
01100110
Visualizaci√≥n: 1234

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de SCL (P√°gina 8115)

BCDCPL: Generar complemento a diez
Descripci√≥n
La instrucci√≥n "Generar complemento a diez" crea el complemento a diez de un n√∫mero BCD
de siete d√≠gitos que se indica en el operando. La instrucci√≥n realiza el c√°lculo con la siguiente
f√≥rmula matem√°tica:
10000000 (como BCD)
‚Äì Valor BCD de 7 d√≠gitos
---------------------------------------Complemento a diez (como BCD)

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

Secuencias de
bits

I, Q, M, D, L, P

N√∫mero BCD de 7
d√≠gitos

DWORD

I, Q, M, D, L, P

Resultado de la ins‚Äê
trucci√≥n

Valor de funci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

2030

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := BCDCPL("Tag_Input");

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores concretos:
Operando

Valor*

Tag_Input

DW#16#01234567

Tag_Result

DW#16#08765433

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de SCL (P√°gina 8115)

BITSUM: Contar n√∫mero de bits activados
Descripci√≥n
La instrucci√≥n "Contar n√∫mero de bits activados" cuenta el n√∫mero de bits de un operando que
est√°n puestos al estado l√≥gico "1".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

DWORD

I, Q, M, D, L, P

Operando cuyos
bits activados se
cuentan

INT

I, Q, M, D, L, P

Resultado de la ins‚Äê
trucci√≥n

Valor de funci√≥n

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
SCL
"Tag_Result" := BITSUM("Tag_Input");

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2031

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores concretos:
Operando

Valor*

Tag_Input

DW#16#12345678

Tag_Result

W#16#000D (13 bits)

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de SCL (P√°gina 8115)

4.1.3.5

GRAPH

Cadena GRAPH
Etapa y transici√≥n
Descripci√≥n
El componente de estructura "Etapa y transici√≥n" permite insertar simult√°neamente una etapa
y una transici√≥n en la cadena secuencial.
Consulte tambi√©n:
Etapa (P√°gina 2033)
Transici√≥n (P√°gina 2033)

Consulte tambi√©n
Etapa (P√°gina 2033)
Transici√≥n (P√°gina 2033)
Fin de cadena (P√°gina 2034)
Salto a etapa (P√°gina 2034)
Rama alternativa (P√°gina 2035)
Rama simult√°nea (P√°gina 2035)
Cerrar rama (P√°gina 2036)
Etapas y transiciones (P√°gina 8198)

2032

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Etapa
Descripci√≥n
Las etapas sirven para dividir las tareas de automatizaci√≥n complejas en tareas m√°s peque√±as
y claras que, seguidamente, se llevan a cabo por medio de acciones. Las diferentes etapas se
organizan en cadenas secuenciales, de modo que al ejecutar el programa cada etapa se
procesa en el orden especificado. Cada etapa debe tener un nombre y un n√∫mero un√≠vocos.
Para que el procesamiento se lleve a cabo realmente, la etapa debe activarse con una de las
condiciones siguientes:
‚óè La etapa se ha definido como inicial.
‚óè Se cumple la transici√≥n de la etapa anterior.
‚óè La etapa es llamada por una acci√≥n controlada por evento.
Una vez se han procesado todas las acciones se vuelve a desactivar la etapa.
Las etapas en las que no hay ninguna acci√≥n programada se denominan etapas vac√≠as. Una
etapa vac√≠a tiene el mismo comportamiento que una etapa activa y la transici√≥n siguiente
siempre se cumple.

Consulte tambi√©n
Principios b√°sicos de las etapas (P√°gina 8198)
Etapa y transici√≥n (P√°gina 2032)
Transici√≥n (P√°gina 2033)
Fin de cadena (P√°gina 2034)
Salto a etapa (P√°gina 2034)
Rama alternativa (P√°gina 2035)
Rama simult√°nea (P√°gina 2035)
Cerrar rama (P√°gina 2036)

Transici√≥n
Descripci√≥n
Las transiciones se encuentran entre una etapa y otra y contienen las condiciones para pasar
de una etapa a la siguiente. Cuando se cumplen las condiciones de continuaci√≥n de una
transici√≥n, se activa la etapa siguiente y se procesan sus acciones. Las condiciones de una
transici√≥n se programan en KOP o FUP.

Consulte tambi√©n
Principios b√°sicos de las transiciones (P√°gina 8200)
Etapa y transici√≥n (P√°gina 2032)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2033

Instrucciones
4.1 Instrucciones
Etapa (P√°gina 2033)
Fin de cadena (P√°gina 2034)
Salto a etapa (P√°gina 2034)
Rama alternativa (P√°gina 2035)
Rama simult√°nea (P√°gina 2035)
Cerrar rama (P√°gina 2036)

Fin de cadena
Descripci√≥n
El componente de estructura "Fin de cadena" permite finalizar una cadena secuencial o una
rama. En una rama simult√°nea, sin embargo, el fin de cadena debe estar precedido de una
transici√≥n.
Nota
Si todas las ramas de una cadena secuencial se cierran con un fin de cadena, es posible volver
a iniciar la cadena secuencial con el par√°metro "INIT_SQ" o con el bot√≥n "Inicializar" de la Task
Card "Test" en la paleta "Control secuencial".

Consulte tambi√©n
Elementos de una cadena secuencial (P√°gina 8194)
Etapa y transici√≥n (P√°gina 2032)
Etapa (P√°gina 2033)
Transici√≥n (P√°gina 2033)
Salto a etapa (P√°gina 2034)
Rama alternativa (P√°gina 2035)
Rama simult√°nea (P√°gina 2035)
Cerrar rama (P√°gina 2036)

Salto a etapa
Descripci√≥n
Con un salto se prosigue la ejecuci√≥n del programa en una etapa cualquiera dentro del bloque
de funci√≥n GRAPH. Los saltos pueden insertarse al final de la rama principal o de una rama
alternativa, de modo que sea posible procesar la cadena secuencial c√≠clicamente. El salto y su
destino se representan en la cadena secuencial en forma de flecha, de modo que en el destino
del salto se indica la transici√≥n de origen.

2034

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Elementos de una cadena secuencial (P√°gina 8194)
Etapa y transici√≥n (P√°gina 2032)
Etapa (P√°gina 2033)
Transici√≥n (P√°gina 2033)
Fin de cadena (P√°gina 2034)
Rama alternativa (P√°gina 2035)
Rama simult√°nea (P√°gina 2035)
Cerrar rama (P√°gina 2036)

Rama alternativa
Descripci√≥n
Las ramas alternativas permiten programar ramas O. Esto significa que, despu√©s de una
etapa, se insertan ramas que empiezan con una transici√≥n. En funci√≥n de la transici√≥n que se
cumpla primero se ejecutar√° la rama correspondiente. Si se cumplen varias transiciones al
mismo tiempo, tendr√° prioridad la transici√≥n que est√© m√°s a la izquierda y se ejecutar√° la rama
correspondiente. Las ramas alternativas finalizan con otra transici√≥n.
Es posible programar un m√°ximo de 125 ramas alternativas en una cadena secuencial.

Consulte tambi√©n
Elementos de una cadena secuencial (P√°gina 8194)
Etapa y transici√≥n (P√°gina 2032)
Etapa (P√°gina 2033)
Transici√≥n (P√°gina 2033)
Fin de cadena (P√°gina 2034)
Salto a etapa (P√°gina 2034)
Rama simult√°nea (P√°gina 2035)
Cerrar rama (P√°gina 2036)

Rama simult√°nea
Descripci√≥n
Las ramas simult√°neas permiten programar ramas Y. Esto significa que con una transici√≥n se
activan varias etapas cuyas acciones se ejecutar√°n a continuaci√≥n. Por ese motivo, las ramas
simult√°neas empiezan y terminan siempre con una etapa.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2035

Instrucciones
4.1 Instrucciones
Las transiciones posteriores de las ramas simult√°neas se encuentran en la rama principal, de
modo que las diferentes ramas simult√°neas pueden cerrarse en diferentes puntos de la rama
principal. Tenga en cuenta que las ramas que se agrupan en una transici√≥n no conmutar√°n a
la etapa siguiente, hasta que no se hayan ejecutado por completo dichas ramas.
Es posible programar un m√°ximo de 249 ramas simult√°neas en una cadena secuencial.

Consulte tambi√©n
Elementos de una cadena secuencial (P√°gina 8194)
Etapa y transici√≥n (P√°gina 2032)
Etapa (P√°gina 2033)
Transici√≥n (P√°gina 2033)
Fin de cadena (P√°gina 2034)
Salto a etapa (P√°gina 2034)
Rama alternativa (P√°gina 2035)
Cerrar rama (P√°gina 2036)

Cerrar rama
Descripci√≥n
El elemento "Cerrar rama" permite cerrar ramas simult√°neas o alternativas y llevarlas a su
rama matriz. Esto debe hacerse cuando la rama no se cierra con un salto o un fin de cadena.
En una rama simult√°nea solo es posible insertar "Cerrar rama" despu√©s de una etapa.

Consulte tambi√©n
Elementos de una cadena secuencial (P√°gina 8194)
Etapa y transici√≥n (P√°gina 2032)
Etapa (P√°gina 2033)
Transici√≥n (P√°gina 2033)
Fin de cadena (P√°gina 2034)
Salto a etapa (P√°gina 2034)
Rama alternativa (P√°gina 2035)
Rama simult√°nea (P√°gina 2035)

2036

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Acciones GRAPH
Temporizadores
TP: Impulso
Descripci√≥n
La instrucci√≥n "Impulso" activa la salida Q por un tiempo programado. La instrucci√≥n se inicia
cuando el resultado l√≥gico (RLO) del par√°metro IN cambia de "0" a "1" (flanco de se√±al
ascendente). Cuando se inicia la instrucci√≥n, se empieza a contar el tiempo programado PT.
El par√°metro Q se activa por el tiempo PT, independientemente de c√≥mo evolucione la se√±al
de entrada. Durante el tiempo PT, la detecci√≥n de un nuevo flanco de se√±al ascendente en la
entrada IN no influye en el estado l√≥gico de la salida Q.
El valor actual de tiempo se puede consultar en el par√°metro ET. Este valor de tiempo empieza
a partir de T#0s y termina al alcanzarse el valor del tiempo PT. Si cuando se alcanza el tiempo
PT el estado l√≥gico del par√°metro IN es "0", se resetea el par√°metro ET. Si en el programa no
se llama la instrucci√≥n porque, p. ej., esta se omite, la salida ET devuelve un valor constante
en cuanto transcurre este tiempo.
La instrucci√≥n "Impulso" se puede colocar dentro o al final del segmento. Dicha instrucci√≥n
requiere una operaci√≥n l√≥gica precedente.
A cada llamada de la instrucci√≥n "Impulso" debe asign√°rsele un temporizador CEI, en el que
se guarden los datos de instancia. El temporizador CEI es una estructura del tipo de datos
IEC_TIMER, IEC_LTIMER, TP_TIME o TP_LTIME que se puede declarar como se indica a
continuaci√≥n:
‚óè Declaraci√≥n de un bloque de datos del tipo de datos de sistema IEC_TIMER o IEC_LTIMER
(p. ej., "MyIEC_TIMER")
‚óè Declaraci√≥n como variable local del tipo TP_TIME, TP_LTIME, IEC_TIMER o IEC_LTIMER
en la secci√≥n "Static" de un bloque (p. ej., #MyIEC_TIMER)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2037

Instrucciones
4.1 Instrucciones

Actualizaci√≥n de los valores actuales en los datos de instancia
Los datos de instancia de "Impulso" se actualizan siguiendo las reglas indicadas a
continuaci√≥n:
‚óè Entrada IN
La instrucci√≥n "Impulso" compara el RLO actual con el RLO de la consulta anterior, que est√°
almacenado en el par√°metro IN de los datos de instancia. Si la instrucci√≥n detecta un
cambio del RLO de "0" a "1", significa que hay un flanco de se√±al ascendente y se empieza
a medir el tiempo. Una vez procesada la instrucci√≥n "Impulso", el valor del par√°metro IN se
actualiza en los datos de instancia y se utiliza como marca de flancos para la siguiente
consulta.
Tenga en cuenta que la evaluaci√≥n de flancos falla cuando el valor actual del par√°metro IN
es escrito o inicializado por otras funciones.
‚óè Entrada PT
El valor de la entrada PT se escribe en el par√°metro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
‚óè Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
‚Äì Al llamar la instrucci√≥n, si las salidas ET o Q est√°n interconectadas.
O bien:
‚Äì Al acceder a Q o ET.
Si las salidas no est√°n interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucci√≥n se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan par√°metros internos de la
instrucci√≥n "Impulso". Tenga en cuenta que la medici√≥n de tiempo falla cuando los valores
actuales de la instrucci√≥n son escritos o inicializados por otras funciones.

2038

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se est√° midiendo el
tiempo, se interfiere en la funci√≥n del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse da√±os materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicializaci√≥n de los valores actuales:
‚óè Cargar el bloque con reinicializaci√≥n
‚óè Cargar instant√°neas como valores actuales
‚óè Forzar valores actuales de forma normal o permanente
‚óè La instrucci√≥n "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
‚óè Aseg√∫rese de que la instalaci√≥n se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
‚óè Aseg√∫rese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
‚óè Si los valores actuales se sobrescriben con una instant√°nea, aseg√∫rese de que la
instant√°nea se haya generado en un instante en que la instalaci√≥n estaba en un estado
seguro.
‚óè Aseg√∫rese de que el programa no est√° leyendo ni escribiendo los datos afectados durante
la transferencia.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de arranque

PT

Input

TIME, LTIME

I, Q, M, D, L, P o
constante

Duraci√≥n del impulso.
El valor del par√°metro PT de‚Äê
be ser positivo.

Q

Output

BOOL

I, Q, M, D, L, P

Salida de impulso

ET

Output

TIME, LTIME

I, Q, M, D, L, P

Valor de tiempo actual

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2039

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el cronograma de impulsos de la instrucci√≥n "Impulso" tras el
arranque:
,1

4

37

37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL TP TIME, "IEC_TP_DB"
(IN := "Tag_Start"
PT := "Tag_PresetTIME"
Q => "Tag_Status"
ET => "Tag_ElapsedTIME"
)

Cuando el estado l√≥gico del operando "Tag_Start" cambia de "0" a "1", el tiempo programado
en el par√°metro PT empieza a contar y el operando "Tag_Status" se pone a "1". El valor de
tiempo actual se guarda en el operando "Tag_ElapsedTIME".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

2040

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

TON: Retardo al conectar
Descripci√≥n
La instrucci√≥n "Retardo al conectar" retarda la activaci√≥n de la salida Q por el tiempo
programado PT. La instrucci√≥n se inicia cuando el resultado l√≥gico (RLO) del par√°metro IN
cambia de "0" a "1" (flanco de se√±al ascendente). Cuando se inicia la instrucci√≥n, se empieza
a contar el tiempo programado PT. Una vez transcurrido el tiempo PT, el par√°metro Q devuelve
el estado l√≥gico "1". El par√°metro Q permanecer√° activado mientras la entrada de arranque IN
est√© puesta a "1". Cuando el estado l√≥gico de la entrada de arranque cambia de "1" a "0", se
desactiva el par√°metro Q. La funci√≥n de temporizaci√≥n se reinicia al detectarse un nuevo
flanco de se√±al ascendente en la entrada de arranque.
El valor de tiempo actual se puede consultar en la salida ET. Este valor de tiempo empieza a
partir de T#0s y termina al alcanzarse el valor del tiempo PT. El par√°metro ET se inicializa en
cuanto el estado l√≥gico de la entrada IN cambia a "0". Si en el programa no se llama la
instrucci√≥n porque, p. ej., esta se omite, la salida ET devuelve un valor constante en cuanto ha
transcurrido el tiempo PT.
La instrucci√≥n "Retardo al conectar" se puede colocar dentro o al final del segmento. Dicha
instrucci√≥n requiere una operaci√≥n l√≥gica precedente.
A cada llamada de la instrucci√≥n "Retardo al conectar" debe asign√°rsele un temporizador CEI,
en el que se guarden los datos de instancia. El temporizador CEI es una estructura del tipo de
datos IEC_TIMER, IEC_LTIMER, TON_TIME o TON_LTIME que se puede declarar como se
indica a continuaci√≥n:
‚óè Declaraci√≥n de un bloque de datos del tipo de datos de sistema IEC_TIMER o IEC_LTIMER
(p. ej., "MyIEC_TIMER")
‚óè Declaraci√≥n como variable local del tipo TON_TIME, TON_LTIME, IEC_TIMER o
IEC_LTIMER en la secci√≥n "Static" de un bloque (p. ej., #MyIEC_TIMER)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2041

Instrucciones
4.1 Instrucciones

Actualizaci√≥n de los valores actuales en los datos de instancia
Los datos de instancia de "Retardo al conectar" se actualizan siguiendo las reglas indicadas a
continuaci√≥n:
‚óè Entrada IN
La instrucci√≥n "Retardo al conectar" compara el RLO actual con el RLO de la consulta
anterior, que est√° almacenado en el par√°metro IN de los datos de instancia. Si la instrucci√≥n
detecta un cambio del RLO de "0" a "1", significa que hay un flanco de se√±al ascendente y
se empieza a medir el tiempo. Una vez procesada la instrucci√≥n "Retardo al conectar", el
valor del par√°metro IN se actualiza en los datos de instancia y se utiliza como marca de
flancos para la siguiente consulta.
Tenga en cuenta que la evaluaci√≥n de flancos falla cuando el valor actual del par√°metro IN
es escrito o inicializado por otras funciones.
‚óè Entrada PT
El valor de la entrada PT se escribe en el par√°metro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
‚óè Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
‚Äì Al llamar la instrucci√≥n, si las salidas ET o Q est√°n interconectadas.
O bien:
‚Äì Al acceder a Q o ET.
Si las salidas no est√°n interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucci√≥n se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan par√°metros internos de la
instrucci√≥n "Retardo al conectar". Tenga en cuenta que la medici√≥n de tiempo falla cuando
los valores actuales de la instrucci√≥n son escritos o inicializados por otras funciones.

2042

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se est√° midiendo el
tiempo, se interfiere en la funci√≥n del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse da√±os materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicializaci√≥n de los valores actuales:
‚óè Cargar el bloque con reinicializaci√≥n
‚óè Cargar instant√°neas como valores actuales
‚óè Forzar valores actuales de forma normal o permanente
‚óè La instrucci√≥n "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
‚óè Aseg√∫rese de que la instalaci√≥n se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
‚óè Aseg√∫rese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
‚óè Si los valores actuales se sobrescriben con una instant√°nea, aseg√∫rese de que la
instant√°nea se haya generado en un instante en que la instalaci√≥n estaba en un estado
seguro.
‚óè Aseg√∫rese de que el programa no est√° leyendo ni escribiendo los datos afectados durante
la transferencia.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de arranque

PT

Input

TIME, LTIME

I, Q, M, D, L, P o
constante

Tiempo del retardo al conec‚Äê
tar
El valor del par√°metro PT de‚Äê
be ser positivo.

Q

Output

BOOL

I, Q, M, D, L, P

Estado l√≥gico que se retarda
por el tiempo PT.

ET

Output

TIME, LTIME

I, Q, M, D, L, P

Valor de tiempo actual

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2043

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el comportamiento de la instrucci√≥n "Retardo al conectar" tras el
arranque:
,1

4

37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL TON TIME, "IEC_TON_DB"
(IN := "Tag_Start"
PT := "Tag_PresetTIME"
Q => "Tag_Status"
ET => "Tag_ElapsedTIME"
)

Cuando el estado l√≥gico del operando "Tag_Start" cambia de "0" a "1", el tiempo programado
en el par√°metro PT empieza a contar. Una vez transcurrido el tiempo, el operando
"Tag_Status" se pone al estado l√≥gico "1". El operando "Tag_Status" permanece a "1" mientras
el operando "Tag_Start" tenga el estado l√≥gico "1". El valor de tiempo actual se guarda en el
operando "Tag_ElapsedTime". Cuando el estado l√≥gico del operando "Tag_Start" cambia de
"1" a "0", se resetea el operando "Tag_Status".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

2044

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

TOF: Retardo al desconectar
Descripci√≥n
La instrucci√≥n "Retardo al desconectar" retarda la desactivaci√≥n de la salida Q por el tiempo
programado PT. El par√°metro Q se activa cuando el resultado l√≥gico (RLO) del par√°metro IN
cambia de "1" a "0" (flanco de se√±al descendente). Cuando el estado l√≥gico del par√°metro IN
cambia nuevamente a "1", el tiempo programado PT deja de contar. El par√°metro Q
permanecer√° activado mientras transcurra el tiempo PT. Una vez transcurrido el tiempo PT se
inicializa el par√°metro Q. Si el estado l√≥gico del par√°metro IN cambia a "1" antes de que
transcurra el tiempo PT, se inicializa el temporizador. El estado l√≥gico del par√°metro Q
permanece a "1".
La instrucci√≥n "Retardo al desconectar" se puede colocar dentro o al final del segmento. Dicha
instrucci√≥n requiere una operaci√≥n l√≥gica precedente.
El valor de tiempo actual se puede consultar en el par√°metro ET. Este valor de tiempo empieza
a partir de T#0s y termina al alcanzarse el valor del tiempo PT. Una vez transcurrido el tiempo
PT, el par√°metro ET permanece al valor actual hasta que el par√°metro IN vuelva a cambiar a
"1". Si el estado l√≥gico de la entrada IN cambia a "1" antes de transcurrir el tiempo PT, la salida
ET adopta el valor T#0s. Si en el programa no se llama la instrucci√≥n porque, p. ej., esta se
omite, la salida ET devuelve un valor constante en cuanto transcurre este tiempo.
A cada llamada de la instrucci√≥n "Retardo al desconectar" debe asign√°rsele un temporizador
CEI, en el que se guarden los datos de instancia. El temporizador CEI es una estructura del tipo
de datos IEC_TIMER, IEC_LTIMER, TOF_TIME o TOF_LTIME que se puede declarar como se
indica a continuaci√≥n:
‚óè Declaraci√≥n de un bloque de datos del tipo de datos de sistema IEC_TIMER o IEC_LTIMER
(p. ej., "MyIEC_TIMER")
‚óè Declaraci√≥n como variable local del tipo TOF_TIME, TOF_LTIME, IEC_TIMER o
IEC_LTIMER en la secci√≥n "Static" de un bloque (p. ej., #MyIEC_TIMER)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2045

Instrucciones
4.1 Instrucciones

Actualizaci√≥n de los valores actuales en los datos de instancia
Los datos de instancia de "Retardo al desconectar" se actualizan siguiendo las reglas
indicadas a continuaci√≥n:
‚óè Entrada IN
La instrucci√≥n "Retardo al desconectar" compara el RLO actual con el RLO de la consulta
anterior, que est√° almacenado en el par√°metro IN de los datos de instancia. Si la instrucci√≥n
detecta un cambio del RLO de "1" a "0", significa que hay un flanco de se√±al descendente
y se empieza a contar el tiempo. Una vez procesada la instrucci√≥n "Retardo al
desconectar", el valor del par√°metro IN se actualiza en los datos de instancia y se utiliza
como marca de flancos para la siguiente consulta.
Tenga en cuenta que la evaluaci√≥n de flancos falla cuando el valor actual del par√°metro IN
es escrito o inicializado por otras funciones.
‚óè Entrada PT
El valor de la entrada PT se escribe en el par√°metro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
‚óè Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
‚Äì Al llamar la instrucci√≥n, si las salidas ET o Q est√°n interconectadas.
O bien:
‚Äì Al acceder a Q o ET.
Si las salidas no est√°n interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucci√≥n se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan par√°metros internos de la
instrucci√≥n "Retardo al desconectar". Tenga en cuenta que la medici√≥n de tiempo falla
cuando los valores actuales de la instrucci√≥n son escritos o inicializados por otras
funciones.

2046

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se est√° midiendo el
tiempo, se interfiere en la funci√≥n del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse da√±os materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicializaci√≥n de los valores actuales:
‚óè Cargar el bloque con reinicializaci√≥n
‚óè Cargar instant√°neas como valores actuales
‚óè Forzar valores actuales de forma normal o permanente
‚óè La instrucci√≥n "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
‚óè Aseg√∫rese de que la instalaci√≥n se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
‚óè Aseg√∫rese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
‚óè Si los valores actuales se sobrescriben con una instant√°nea, aseg√∫rese de que la
instant√°nea se haya generado en un instante en que la instalaci√≥n estaba en un estado
seguro.
‚óè Aseg√∫rese de que el programa no est√° leyendo ni escribiendo los datos afectados durante
la transferencia.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de arranque

PT

Input

TIME, LTIME

I, Q, M, D, L, P o
constante

Tiempo del retardo al desco‚Äê
nectar
El valor del par√°metro PT de‚Äê
be ser positivo.

Q

Output

BOOL

I, Q, M, D, L, P

Estado l√≥gico que se retarda
por el tiempo PT.

ET

Output

TIME, LTIME

I, Q, M, D, L, P

Valor de tiempo actual

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2047

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el comportamiento de la instrucci√≥n "Retardo al desconectar" tras
el arranque:
,1

4
37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL TOF TIME, "IEC_TOF_DB"
(IN := "Tag_Start"
PT := "Tag_PresetTIME"
Q => "Tag_Status"
ET => "Tag_ElapsedTIME"
)

Si se produce un cambio del estado l√≥gico del operando "Tag_Start" de "0" a "1", el operando
se pone a "Tag_Status". Cuando el estado l√≥gico del operando "Tag_Start" cambia de "1" a "0",
el tiempo programado en el par√°metro PT empieza a contar. Mientras transcurra el tiempo,
permanecer√° activado el operando "Tag_Status". Una vez transcurrido el tiempo, el operando
"Tag_Status" se desactiva. El valor de tiempo actual se guarda en el operando
"Tag_ElapsedTIME".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

2048

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

TONR: Acumulador de tiempo
Descripci√≥n
La instrucci√≥n "Acumulador de tiempo" acumula valores de tiempo dentro de un periodo
definido por el par√°metro PT. Cuando el estado l√≥gico de la entrada IN cambia de "0" a "1"
(flanco de se√±al ascendente), se inicia la medici√≥n de tiempo y se empieza a contar el tiempo
PT. Mientras transcurre el tiempo PT se van acumulando los valores de tiempo que se leen
cuando el estado l√≥gico de la entrada IN es "1". El tiempo acumulado se deposita en la salida
ET y se puede consultar all√≠. Una vez se ha alcanzado el tiempo PT, la salida Q devuelve el
estado l√≥gico "1". El par√°metro Q permanece a "1" aunque el estado l√≥gico del par√°metro IN
cambie de "1" a "0" (flanco de se√±al descendente).
La instrucci√≥n "Acumulador de tiempo" se puede colocar dentro o al final del segmento. Dicha
instrucci√≥n requiere una operaci√≥n l√≥gica precedente.
La entrada R desactiva las salidas ET y Q independientemente del estado l√≥gico de la entrada
de arranque.
A cada llamada de la instrucci√≥n "Acumulador de tiempo" debe asign√°rsele un temporizador
CEI, en el que se guarden los datos de instancia. El temporizador CEI es una estructura del tipo
de datos IEC_TIMER, IEC_LTIMER, TONR_TIME o TONR_LTIME que se puede declarar
como se indica a continuaci√≥n:
‚óè Declaraci√≥n de un bloque de datos del tipo de datos de sistema IEC_TIMER o IEC_LTIMER
(p. ej., "MyIEC_TIMER")
‚óè Declaraci√≥n como variable local del tipo TONR_TIME, TONR_LTIME, IEC_TIMER o
IEC_LTIMER en la secci√≥n "Static" de un bloque (p. ej., #MyIEC_TIMER)

Actualizaci√≥n de los valores actuales en los datos de instancia
Los datos de instancia de "Acumulador de tiempo" se actualizan siguiendo las reglas indicadas
a continuaci√≥n:
‚óè Entrada IN
La instrucci√≥n "Acumulador de tiempo" compara el RLO actual con el RLO de la consulta
anterior, que est√° almacenado en el par√°metro IN de los datos de instancia. Si la instrucci√≥n
detecta un cambio del RLO de "0" a "1", significa que hay un flanco de se√±al ascendente y
se reanuda la medici√≥n de tiempo. Si la instrucci√≥n detecta un cambio de "1" a "0" en el
RLO, significa que hay un flanco de se√±al descendente y la medici√≥n de tiempo se
interrumpe. Una vez procesada la instrucci√≥n "Acumulador de tiempo", el valor del
par√°metro IN se actualiza en los datos de instancia y se utiliza como marca de flancos para
la siguiente consulta.
Tenga en cuenta que la evaluaci√≥n de flancos falla cuando el valor actual del par√°metro IN
es escrito o inicializado por otras funciones.
‚óè Entrada PT
El valor de la entrada PT se escribe en el par√°metro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2049

Instrucciones
4.1 Instrucciones
‚óè Entrada R
La se√±al "1" en la entrada R inicializa la medici√≥n de tiempo y la bloquea. Los flancos en la
entrada IN se ignoran. La se√±al "0" en la entrada R habilita de nuevo la medici√≥n de tiempo.
‚óè Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
‚Äì Al llamar la instrucci√≥n, si las salidas ET o Q est√°n interconectadas.
O bien:
‚Äì Al acceder a Q o ET.
Si las salidas no est√°n interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucci√≥n se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan par√°metros internos de la
instrucci√≥n "Acumulador de tiempo". Tenga en cuenta que la medici√≥n de tiempo falla
cuando los valores actuales de la instrucci√≥n son escritos o inicializados por otras
funciones.
PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se est√° midiendo el
tiempo, se interfiere en la funci√≥n del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse da√±os materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicializaci√≥n de los valores actuales:
‚óè Cargar el bloque con reinicializaci√≥n
‚óè Cargar instant√°neas como valores actuales
‚óè Forzar valores actuales de forma normal o permanente
‚óè La instrucci√≥n "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
‚óè Aseg√∫rese de que la instalaci√≥n se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
‚óè Aseg√∫rese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
‚óè Si los valores actuales se sobrescriben con una instant√°nea, aseg√∫rese de que la
instant√°nea se haya generado en un instante en que la instalaci√≥n estaba en un estado
seguro.
‚óè Aseg√∫rese de que el programa no est√° leyendo ni escribiendo los datos afectados durante
la transferencia.

2050

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de arranque

R

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de reset

PT

Input

TIME, LTIME

I, Q, M, D, L, P o
constante

Tiempo m√°ximo de lectura
del tiempo
El valor del par√°metro PT de‚Äê
be ser positivo.

Q

Output

BOOL

I, Q, M, D, L, P

Salida que se activa una vez
transcurrido el tiempo PT.

ET

Output

TIME, LTIME

I, Q, M, D, L, P

Tiempo acumulado

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.

Cronograma de impulsos
La figura siguiente muestra el cronograma de impulsos de la instrucci√≥n "Acumulador de
tiempo":
,1

5

4

37

(7

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2051

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL TONR TIME, "IEC_TONR_DB"
(IN := "Tag_Start"
R := "Tag_Reset"
PT := "Tag_PresetTIME"
Q => "Tag_Status"
ET => "Tag_ElapsedTIME"
)

Cuando el estado l√≥gico del operando "Tag_Start" cambia de "0" a "1", el tiempo programado
en el par√°metro PT empieza a contar. Mientras transcurre el tiempo, se van acumulando los
valores de tiempo que se leen cuando el estado l√≥gico del operando "Tag_Start" es "1". El
tiempo acumulado se almacena en el operando "Tag_ElapsedTIME". Una vez alcanzado el
valor de tiempo indicado en el par√°metro PT, el operando "Tag_Status" adopta el estado l√≥gico
"1". El valor de tiempo actual se guarda en el operando "Tag_ElapsedTIME".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

Contadores
CTU: Contador ascendente
Descripci√≥n
La instrucci√≥n "Contador ascendente" incrementa el valor del par√°metro CV. Cuando el estado
l√≥gico del par√°metro CU cambia de "0" a "1" (flanco de se√±al ascendente), se ejecuta la
instrucci√≥n y el valor de contaje actual del par√°metro CV se incrementa en uno. El valor de
contaje se incrementa cada vez que se detecta un flanco de se√±al ascendente, hasta alcanzar
el valor l√≠mite superior del tipo de datos indicado en la salida CV. Cuando se alcanza el valor
l√≠mite superior, el estado l√≥gico del par√°metro CU deja de tener efecto en la instrucci√≥n.
El estado del contador se puede consultar en el par√°metro Q. El estado l√≥gico del par√°metro
Q es determinado por el par√°metro PV. Si el valor de contaje actual es mayor o igual al valor
del par√°metro PV, el par√°metro Q adopta el estado l√≥gico "1". En los restantes casos, el estado
l√≥gico del par√°metro Q es "0".

2052

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El valor del par√°metro CV se pone a cero cuando el estado l√≥gico del par√°metro R cambia a
"1". Mientras el par√°metro R tenga el estado l√≥gico "1", el estado l√≥gico del par√°metro CU no
tendr√° efecto alguno en la instrucci√≥n.
Nota
Utilice el contador en una sola posici√≥n del programa para evitar fallos de contaje.
A cada llamada de la instrucci√≥n "Contador ascendente" debe asign√°rsele un contador CEI, en
el que se guarden los datos de la instrucci√≥n. Un contador CEI es una estructura con uno de
los tipos de datos siguientes:

Bloque de datos del tipo de datos de sistema IEC_<Contador> (Shared DB)
‚óè IEC_SCOUNTER / IEC_USCOUNTER
‚óè IEC_COUNTER / IEC_UCOUNTER
‚óè IEC_DCOUNTER / IEC_UDCOUNTER
‚óè IEC_LCOUNTER / IEC_ULCOUNTER

Variable local
‚óè CTU_SINT / CTU_USINT
‚óè CTU_INT / CTU_UINT
‚óè CTU_DINT / CTU_UDINT
‚óè CTU_LINT / CTU_ULINT
‚óè IEC_SCOUNTER / IEC_USCOUNTER
‚óè IEC_COUNTER / IEC_UCOUNTER
‚óè IEC_DCOUNTER / IEC_UDCOUNTER
‚óè IEC_LCOUNTER / IEC_ULCOUNTER
Un contador CEI se puede declarar del modo siguiente:
‚óè Declaraci√≥n de un bloque de datos del tipo de datos de sistema IEC_<Contador> (p. ej.
"MyIEC_COUNTER")
‚óè Declaraci√≥n como variable local del tipo CTU_<tipo de datos> o IEC_<contador> en la
secci√≥n "Static" de un bloque (p. ej., #MyCTU_COUNTER)
Si el contador CEI se crea en un bloque de datos propio (instancia individual), el bloque de
datos de instancia se crea de forma est√°ndar con "acceso optimizado al bloque" y las distintas
variables se declaran remanentes. Encontrar√° m√°s informaci√≥n sobre la configuraci√≥n de la
remanencia en un bloque de datos de instancia en "Consulte tambi√©n".
Si el contador CEI se crea como variable local (multiinstancia) en un bloque de funci√≥n con
"acceso optimizado al bloque", esta se declara remanente en la interfaz del bloque.
Para poder ejecutar la instrucci√≥n "Contador ascendente" se requiere una operaci√≥n l√≥gica
precedente. Se puede colocar dentro o al final del segmento.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2053

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

CU

Input

BOOL

I, Q, M, D, L o
constante

Entrada de contaje

R

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de reset

PV

Input

Enteros

I, Q, M, D, L, P o
constante

Valor con el que se activa la
salida Q.

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL CTU INT, "IEC_CTU_DB"
(CU := "Tag_Start"
R := "Tag_ResetCOUNTER"
PV := "Tag_PresetValue"
Q => "Tag_Status"
CV => "Tag_CounterValue"
)

Cuando el estado l√≥gico del operando "Tag_Start" cambia de "0" a "1", se ejecuta la instrucci√≥n
"Contador ascendente" y el valor de contaje actual del operando "Tag_CounterValue" se
incrementa en uno. Con cada flanco de se√±al ascendente posterior, el valor de contaje ir√°
incrementando hasta alcanzar el valor l√≠mite superior del tipo de datos (INT = 32767).
El valor del par√°metro PV se utiliza como l√≠mite para determinar la salida "Tag_Status". La
salida "Tag_Status" devuelve el estado l√≥gico "1" mientras el valor de contaje actual sea mayor
o igual que el valor del operando "Tag_PresetValue". En todos los dem√°s casos, la salida
"Tag_Status" devuelve el estado l√≥gico "0".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Ajustar la remanencia en un bloque de datos de instancia (P√°gina 7855)
Remanencia de las variables locales (P√°gina 7789)
Principios b√°sicos de GRAPH (P√°gina 8191)

2054

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CTD: Contador descendente
Descripci√≥n
La instrucci√≥n "Contador descendente" decrementa el valor del par√°metro CV. Cuando el
estado l√≥gico del par√°metro CD cambia de "0" a "1" (flanco de se√±al ascendente), se ejecuta
la instrucci√≥n y el valor de contaje actual del par√°metro CV se decrementa en uno. Cada vez
que se detecta un flanco de se√±al ascendente, el valor de contaje se decrementa hasta
alcanzar el valor l√≠mite inferior del tipo de datos indicado. Cuando se alcanza el valor l√≠mite
inferior, el estado l√≥gico del par√°metro CD deja de tener efecto en la instrucci√≥n.
El estado del contador se puede consultar en el par√°metro Q. Si el valor de contaje actual es
menor o igual a cero, el par√°metro Q adopta el estado l√≥gico "1". En los restantes casos, el
estado l√≥gico del par√°metro Q es "0".
El valor del par√°metro CV se pone al valor del par√°metro PV cuando el estado l√≥gico del
par√°metro LD cambia a "1". Mientras el par√°metro LD tenga el estado l√≥gico "1", el estado
l√≥gico del par√°metro CD no tendr√° efecto alguno en la instrucci√≥n.
Nota
Utilice el contador en una sola posici√≥n del programa para evitar fallos de contaje.
A cada llamada de la instrucci√≥n "Contador descendente" debe asign√°rsele un contador CEI,
en el que se guarden los datos de la instrucci√≥n. Un contador CEI es una estructura con uno
de los tipos de datos siguientes:

Bloque de datos del tipo de datos de sistema IEC_<Contador> (Shared DB)
‚óè IEC_SCOUNTER / IEC_USCOUNTER
‚óè IEC_COUNTER / IEC_UCOUNTER
‚óè IEC_DCOUNTER / IEC_UDCOUNTER
‚óè IEC_LCOUNTER / IEC_ULCOUNTER

Variable local
‚óè CTD_SINT / CTD_USINT
‚óè CTD_INT / CTD_UINT
‚óè CTD_DINT / CTD_UDINT
‚óè CTD_LINT / CTD_ULINT
‚óè IEC_SCOUNTER / IEC_USCOUNTER
‚óè IEC_COUNTER / IEC_UCOUNTER
‚óè IEC_DCOUNTER / IEC_UDCOUNTER
‚óè IEC_LCOUNTER / IEC_ULCOUNTER

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2055

Instrucciones
4.1 Instrucciones
Un contador CEI se puede declarar del modo siguiente:
‚óè Declaraci√≥n de un bloque de datos del tipo de datos de sistema IEC_<Contador> (p. ej.
"MyIEC_COUNTER")
‚óè Declaraci√≥n como variable local del tipo CTD_<Tipo de datos> o IEC_<Contador> en la
secci√≥n "Static" de un bloque (p. ej. #MyCTD_COUNTER)
Si el contador CEI se crea en un bloque de datos propio (instancia individual), el bloque de
datos de instancia se crea de forma est√°ndar con "acceso optimizado al bloque" y las distintas
variables se declaran remanentes. Encontrar√° m√°s informaci√≥n sobre la configuraci√≥n de la
remanencia en un bloque de datos de instancia en "Consulte tambi√©n".
Si el contador CEI se crea como variable local (multiinstancia) en un bloque de funci√≥n con
"acceso optimizado al bloque", esta se declara remanente en la interfaz del bloque.
Para poder ejecutar la instrucci√≥n "Contador descendente" se requiere una operaci√≥n l√≥gica
precedente. Se puede colocar dentro o al final del segmento.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

CD

Input

BOOL

I, Q, M, D, L o
constante

Entrada de contaje

LD

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de carga

PV

Input

Enteros

I, Q, M, D, L, P o
constante

Valor al que se pone la salida
CV cuando LD = 1.

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL CTD INT, "IEC_CTD_DB"
(CD := "Tag_Start"
LD := "Tag_LoadPV"
PV := "Tag_PresetValue"
Q => "Tag_Status"
CV => "Tag_CounterValue"
)

Cuando el estado l√≥gico del operando "Tag_Start" cambia de "0" a "1", se ejecuta la instrucci√≥n
"Contador descendente" y el valor de la salida "Tag_CounterValue" se decrementa en uno.
Con cada flanco de se√±al ascendente posterior, el valor de contaje ir√° decrementando hasta
alcanzar el valor l√≠mite inferior del tipo de datos indicado (INT = -32768).

2056

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La salida "Tag_Status" devuelve el estado l√≥gico "1" mientras el valor de contaje actual sea
menor o igual a cero. En todos los dem√°s casos, la salida "Tag_Status" devuelve el estado
l√≥gico "0".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Ajustar la remanencia en un bloque de datos de instancia (P√°gina 7855)
Remanencia de las variables locales (P√°gina 7789)
Principios b√°sicos de GRAPH (P√°gina 8191)

CTUD: Contador ascendente - descendente
Descripci√≥n
La instrucci√≥n "Contador ascendente - descendente" incrementa y decrementa el valor del
par√°metro CV. Cuando el estado l√≥gico del par√°metro CU cambia de "0" a "1" (flanco de se√±al
ascendente), el valor de contaje actual del par√°metro CV se incrementa en uno. Cuando el
estado l√≥gico del par√°metro CD cambia de "0" a "1" (flanco de se√±al ascendente), el valor de
contaje actual del par√°metro CV se decrementa en uno. Si en un ciclo del programa se detecta
un flanco de se√±al ascendente en las entradas CU y CD, el valor de contaje actual no cambia
en el par√°metro CV.
El valor de contaje se puede seguir incrementando hasta alcanzar el valor l√≠mite superior del
tipo de datos indicado en el par√°metro CV. Una vez alcanzado el valor l√≠mite superior, el valor
de contaje no se incrementa m√°s aunque se detecte un flanco de se√±al ascendente. Cuando
se alcanza el valor l√≠mite inferior del tipo de datos indicado, ya no se decrementa el valor de
contaje.
Cuando el estado l√≥gico del par√°metro LD cambia a "1", el valor de contaje del par√°metro CV
se pone al valor del par√°metro PV. Mientras el par√°metro LD tenga el estado l√≥gico "1", el
estado l√≥gico de las entradas CU y CD no tendr√° efecto alguno en la instrucci√≥n.
El valor de contaje se pone a cero cuando el estado l√≥gico del par√°metro R cambia a "1".
Mientras el estado l√≥gico del par√°metro R sea "1", un cambio del estado l√≥gico de los
par√°metros CU, CD y LD no tendr√° efecto alguno en la instrucci√≥n "Contador ascendente descendente".
El estado del contador ascendente se puede consultar en el par√°metro QU. Si el valor de
contaje actual es mayor o igual al valor del par√°metro PV, el par√°metro QU adopta el estado
l√≥gico "1". En los restantes casos, el estado l√≥gico del par√°metro QU es "0".
El estado del contador descendente se puede consultar en el par√°metro QD. Si el valor de
contaje actual es menor o igual a cero, el par√°metro QD adopta el estado l√≥gico "1". En los
restantes casos, el estado l√≥gico del par√°metro QD es "0".
Nota
Utilice el contador en una sola posici√≥n del programa para evitar fallos de contaje.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2057

Instrucciones
4.1 Instrucciones
A cada llamada de la instrucci√≥n "Contador ascendente - descendente" debe asign√°rsele un
contador CEI en el que se guarden los datos de la instrucci√≥n. Un contador CEI es una
estructura con uno de los tipos de datos siguientes:

Bloque de datos del tipo de datos de sistema IEC_<Contador> (Shared DB)
‚óè IEC_SCOUNTER / IEC_USCOUNTER
‚óè IEC_COUNTER / IEC_UCOUNTER
‚óè IEC_DCOUNTER / IEC_UDCOUNTER
‚óè IEC_LCOUNTER / IEC_ULCOUNTER

Variable local
‚óè CTUD_SINT / CTUD_USINT
‚óè CTUD_INT / CTUD_UINT
‚óè CTUD_DINT / CTUD_UDINT
‚óè CTUD_LINT / CTUD_ULINT
‚óè IEC_SCOUNTER / IEC_USCOUNTER
‚óè IEC_COUNTER / IEC_UCOUNTER
‚óè IEC_DCOUNTER / IEC_UDCOUNTER
‚óè IEC_LCOUNTER / IEC_ULCOUNTER
Un contador CEI se puede declarar del modo siguiente:
‚óè Declaraci√≥n de un bloque de datos del tipo de datos de sistema IEC_<Contador> (p. ej.
"MyIEC_COUNTER")
‚óè Declaraci√≥n como variable local del tipo CTUD_<tipo de datos> o IEC_<contador> en la
secci√≥n "Static" de un bloque (p. ej., #MyCTUD_COUNTER)
Si el contador CEI se crea en un bloque de datos propio (instancia individual), el bloque de
datos de instancia se crea de forma est√°ndar con "acceso optimizado al bloque" y las distintas
variables se declaran remanentes. Encontrar√° m√°s informaci√≥n sobre la configuraci√≥n de la
remanencia en un bloque de datos de instancia en "Consulte tambi√©n".
Si el contador CEI se crea como variable local (multiinstancia) en un bloque de funci√≥n con
"acceso optimizado al bloque", esta se declara remanente en la interfaz del bloque.
Para poder ejecutar la instrucci√≥n "Contador ascendente - descendente" se requiere una
operaci√≥n l√≥gica precedente. Se puede colocar dentro o al final del segmento.

2058

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

CU

Input

BOOL

I, Q, M, D, L o
constante

Entrada de contaje ascen‚Äê
dente

CD

Input

BOOL

I, Q, M, D, L o
constante

Entrada de contaje descen‚Äê
dente

R

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de reset

LD

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de carga

PV

Input

Enteros

I, Q, M, D, L, P o
constante

Valor con el que se activa la
salida QU. / Valor al que se
ajusta la salida CV si LD = 1.

QU

Output

BOOL

I, Q, M, D, L

Estado del contador ascen‚Äê
dente

QD

Output

BOOL

I, Q, M, D, L

Estado del contador descen‚Äê
dente

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL CTUD INT, "IEC_CTUD_DB"
(CU := "Tag_StartCTU"
CD := "Tag_StartCTD"
R := "Tag_ResetCOUNTER"
LD := "Tag_LoadPV"
PV := "Tag_PresetValue"
QU => "Tag_CounterStatusUP"
QD => "Tag_CounterStatusDOWN"
CV => "Tag_CounterValue"
)

Si el estado l√≥gico de la entrada "Tag_StartCTU" o "Tag_StartCTD" cambia de "0" a "1" (flanco
de se√±al ascendente), se ejecuta la instrucci√≥n "Contador ascendente - descendente". Cuando
se detecta un flanco de se√±al ascendente en la entrada "Tag_StartCTU", el valor de contaje
actual se incrementa en uno y se deposita en la salida "Tag_CounterValue". Si se detecta un
flanco de se√±al ascendente en la entrada "Tag_StartCTD", el valor de contaje se decrementa
en uno y se deposita en la salida "Tag_CounterValue". Si se detecta un flanco de se√±al
ascendente en la entrada CU, el valor de contaje se sigue incrementando hasta alcanzar el
valor l√≠mite superior (32767). Cuando se detecta un flanco de se√±al ascendente en la entrada
CD, el valor de contaje se decrementa hasta alcanzar el valor l√≠mite inferior INT = -32768.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2059

Instrucciones
4.1 Instrucciones
La salida "Tag_CounterStatusUP" devuelve el estado l√≥gico "1" mientras el valor de contaje
actual sea mayor o igual que el valor de la entrada "Tag_PresetValue". En todos los dem√°s
casos, la salida "Tag_CounterStatusUP" devuelve el estado l√≥gico "0".
La salida "Tag_CounterStatusDOWN" devuelve el estado l√≥gico "1" mientras el valor de
contaje actual sea menor o igual a cero. En todos los dem√°s casos, la salida
"Tag_CounterStatusDOWN" devuelve el estado l√≥gico "0".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Ajustar la remanencia en un bloque de datos de instancia (P√°gina 7855)
Remanencia de las variables locales (P√°gina 7789)
Principios b√°sicos de GRAPH (P√°gina 8191)

Funciones matem√°ticas
NEG: Generar complemento a dos
Descripci√≥n
Con la instrucci√≥n "Generar complemento a dos" se cambia el signo del valor del operando.
Por ejemplo, si tiene un valor positivo, se deposita el equivalente negativo de este valor.
El valor de la salida OUT no es v√°lido si el resultado de la instrucci√≥n est√° fuera del rango
permitido para el tipo de datos indicado en la salida OUT (solo v√°lido para n√∫meros enteros).

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

SINT, INT, DINT,
LINT, n√∫meros en
coma flotante

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

SINT, INT, DINT,
LINT, n√∫meros en
coma flotante

I, Q, M, D, L, P

Complemento a dos del valor
de entrada

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

2060

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := NEG_REAL("Tag_InValue")

La instrucci√≥n cambia el signo del valor en el operando "Tag_InValue" e indica el resultado en
el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

ABS: Calcular valor absoluto
Descripci√≥n
Con la instrucci√≥n "Calcular valor absoluto" se calcula el valor absoluto del valor del operando.
El valor del resultado no es v√°lido si un n√∫mero en coma flotante presenta un valor no v√°lido.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

SINT, INT, DINT,
LINT, n√∫meros en
coma flotante

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

SINT, INT, DINT,
LINT, n√∫meros en
coma flotante

I, Q, M, D, L, P

Valor absoluto del valor de
entrada

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := ABS("Tag_InValue")

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2061

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

-6.234

Tag_OutValue

6.234

La instrucci√≥n calcula el valor absoluto del valor del operando "Tag_InValue" e indica el
resultado en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

MIN: Determinar m√≠nimo
Descripci√≥n
La instrucci√≥n "Determinar m√≠nimo" compara los valores de las entradas disponibles IN1 e IN2
y escribe el valor m√°s peque√±o en la salida OUT.
El valor de la salida OUT no es v√°lido si se cumple una de las siguientes condiciones:
‚óè La conversi√≥n impl√≠cita de los tipos de datos falla durante la ejecuci√≥n de la instrucci√≥n.
‚óè Un n√∫mero en coma flotante tiene un valor no v√°lido.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:

2062

Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN1

Input

Enteros, n√∫meros
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‚Äê
TE, LDT

I, Q, M, D, L, P o
constante

Primer valor de entrada

IN2

Input

Enteros, n√∫meros
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‚Äê
TE, LDT

I, Q, M, D, L, P o
constante

Segundo valor de entrada

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

OUT

Output

Enteros, n√∫meros
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‚Äê
TE, LDT

I, Q, M, D, L, P

Resultado

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar si la verificaci√≥n CEI est√° desac‚Äê
tivada.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL MIN INT
(IN1 := "TagIn_Value1"
IN2 := "TagIn_Value2"
OUT => "Tag_Minimum"
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN1

TagIn_Value1

12222

IN2

TagIn_Value2

14444

OUT

Tag_Minimum

12222

La instrucci√≥n compara los valores de los operandos indicados y copia el valor menor
("TagIn_Value1") en la salida "Tag_Minimum".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

MAX: Determinar m√°ximo
Descripci√≥n
La instrucci√≥n "Determinar m√°ximo" compara los valores de las entradas IN1 e IN2 y escribe
el valor mayor en la salida OUT.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2063

Instrucciones
4.1 Instrucciones
El valor de la salida OUT no es v√°lido si se cumple una de las siguientes condiciones:
‚óè La conversi√≥n impl√≠cita de los tipos de datos falla durante la ejecuci√≥n de la instrucci√≥n.
‚óè Un n√∫mero en coma flotante tiene un valor no v√°lido.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN1

Input

Enteros, n√∫meros
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‚Äê
TE, LDT

I, Q, M, D, L, P o
constante

Primer valor de entrada

IN2

Input

Enteros, n√∫meros
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‚Äê
TE, LDT

I, Q, M, D, L, P o
constante

Segundo valor de entrada

OUT

Output

Enteros, n√∫meros
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‚Äê
TE, LDT

I, Q, M, D, L, P

Resultado

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar si la verificaci√≥n CEI est√° desac‚Äê
tivada.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL MAX INT
(IN1 := "TagIn_Value1"
IN2 := "TagIn_Value2"
OUT => "Tag_Maximum"
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

2064

Operando

Valor

IN1

TagIn_Value1

12222

IN2

TagIn_Value2

14444

OUT

Tag_Maximum

14444

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucci√≥n compara los valores de los operandos indicados y copia el valor mayor
("TagIn_Value2") en la salida "Tag_Maximum".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

LIMIT: Ajustar valor l√≠mite
Descripci√≥n
La instrucci√≥n "Ajustar valor l√≠mite" limita el valor de la entrada IN a los valores de las entradas
MN y MX. Si el valor de la entrada IN cumple la condici√≥n MN <= IN <= MX, se copia en la salida
OUT. Si no se cumple la condici√≥n y el valor de entrada IN es menor que el l√≠mite inferior MN,
la salida OUT adopta el valor de la entrada MN. Si el l√≠mite superior MX se rebasa por exceso,
la salida OUT adopta el valor de la entrada MX.
Si el valor de la entrada MN es mayor que el de la entrada MX, el resultado ser√° el valor
indicado en el par√°metro IN. Para poder ejecutar la instrucci√≥n, es imprescindible que las
variables de todas las entradas sean del mismo tipo de datos.
El valor de la salida OUT no es v√°lido si se cumple una de las siguientes condiciones:
‚óè Las variables indicadas no son del mismo tipo de datos.
‚óè Un operando tiene un valor no v√°lido.
‚óè El valor del par√°metro MN es mayor que el valor del par√°metro MX.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

MN

Input

Enteros, n√∫meros
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‚Äê
TE, LDT

I, Q, M, D, L, P o
constante

L√≠mite inferior

IN

Input

Enteros, n√∫meros
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‚Äê
TE, LDT

I, Q, M, D, L, P o
constante

Valor de entrada

MX

Input

Enteros, n√∫meros
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‚Äê
TE, LDT

I, Q, M, D, L, P o
constante

L√≠mite superior

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2065

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

OUT

Output

Enteros, n√∫meros
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‚Äê
TE, LDT

I, Q, M, D, L, P

Resultado

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar cuando la verificaci√≥n CEI est√°
desactivada.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL LIMIT INT
(MN := "Tag_LowLimit"
IN := "Tag_InputValue"
MX := "Tag_HighLimit"
OUT => "Tag_Result"
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

MN

Tag_LowLimit

12000

IN

Tag_InputValue

8000

MX

Tag_HighLimit

16000

OUT

Tag_Result

12000

El valor del operando "Tag_InputValue" se compara con los valores de los operandos
"Tag_LowLimit" y "Tag_HighLimit". Puesto que el valor del operando "Tag_InputValue" es
menor que el valor l√≠mite inferior, el valor del operando "Tag_LowLimit" se copia en la salida
"Tag_Result".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

2066

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

SQR: Calcular cuadrado
Descripci√≥n
La instrucci√≥n "Calcular cuadrado" permite elevar al cuadrado el valor del n√∫mero en coma
flotante del operando y escribir el resultado en la salida.
Si el operando contiene un n√∫mero en coma flotante no v√°lido, el valor del resultado tampoco
ser√° v√°lido.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

N√∫meros en coma
flotante

I, Q, M, D, L, P

Cuadrado del valor de entra‚Äê
da

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := SQR("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

5.0

Tag_OutValue

25.0

La instrucci√≥n eleva al cuadrado el valor del operando "Tag_InValue" e indica el resultado en
el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2067

Instrucciones
4.1 Instrucciones

SQRT: Calcular ra√≠z cuadrada
Descripci√≥n
La instrucci√≥n "Calcular ra√≠z cuadrada" permite extraer la ra√≠z cuadrada del valor de entrada y
guardar el resultado en el operando indicado. La instrucci√≥n da un resultado positivo si el valor
de entrada es mayor que cero. En los valores de entrada menores que cero, la instrucci√≥n
devuelve un n√∫mero en coma flotante no v√°lido. Si el valor del operando es "0", el resultado
tambi√©n es "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

N√∫meros en coma
flotante

I, Q, M, D, L

Ra√≠z cuadrada del valor de
entrada

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := SQRT("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

25.0

Tag_OutValue

5.0

La instrucci√≥n extrae la ra√≠z cuadrada del valor del operando "Tag_InValue" e indica el
resultado en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
N√∫meros en coma flotante no v√°lidos (P√°gina 263)
Principios b√°sicos de GRAPH (P√°gina 8191)

2068

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

LN: Calcular logaritmo natural
Descripci√≥n
La instrucci√≥n "Calcular logaritmo natural" permite calcular el logaritmo natural en base e (e =
2,718282) a partir del valor de entrada. La instrucci√≥n da un resultado positivo si el valor de
entrada es mayor que cero. En los valores de entrada menores que cero, la instrucci√≥n
devuelve un n√∫mero en coma flotante no v√°lido.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

N√∫meros en coma
flotante

I, Q, M, D, L, P

Logaritmo natural del valor
de entrada

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := LN("Tag_InValue")

La instrucci√≥n calcula el logaritmo natural del valor del operando "Tag_InValue" e indica el
resultado en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
N√∫meros en coma flotante no v√°lidos (P√°gina 263)
Principios b√°sicos de GRAPH (P√°gina 8191)

EXP: Calcular valor exponencial
Descripci√≥n
La instrucci√≥n "Calcular valor exponencial" permite calcular la potencia en base e (e =
2,718282) del valor del operando.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2069

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

N√∫meros en coma
flotante

I, Q, M, D, L, P

Valor exponencial del valor
de entrada

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := EXP("Tag_InValue")

La instrucci√≥n calcula la potencia en base e del valor del operando "Tag_InValue" e indica el
resultado (eIN) en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
N√∫meros en coma flotante no v√°lidos (P√°gina 263)
Principios b√°sicos de GRAPH (P√°gina 8191)

SIN: Calcular valor de seno
Descripci√≥n
La instrucci√≥n "Calcular valor de seno" permite calcular el seno de un √°ngulo. El tama√±o del
√°ngulo se indica en radianes en el operando.
El valor del resultado no es v√°lido si el valor del operando no es un n√∫mero en coma flotante
v√°lido.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:

2070

Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Tama√±o del √°ngulo en radia‚Äê
nes

<Resultado>

Output

N√∫meros en coma
flotante

I, Q, M, D, L, P

Seno del √°ngulo indicado

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := SIN("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

+1.570796 (œÄ/2)

Tag_OutValue

1.0

La instrucci√≥n calcula el seno del √°ngulo indicado en el operando "Tag_InValue" e indica el
resultado en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

COS: Calcular valor de coseno
Descripci√≥n
La instrucci√≥n "Calcular valor de coseno" permite calcular el coseno de un √°ngulo. El tama√±o
del √°ngulo se indica en radianes en el operando.
El valor del resultado no es v√°lido si el valor del operando no es un n√∫mero en coma flotante
v√°lido.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Tama√±o del √°ngulo en radia‚Äê
nes

<Resultado>

Output

N√∫meros en coma
flotante

I, Q, M, D, L, P

Coseno del √°ngulo indicado

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2071

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := COS("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

+1.570796 (œÄ/2)

Tag_OutValue

0

La instrucci√≥n calcula el coseno del √°ngulo indicado en el operando "Tag_InValue" e indica el
resultado en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

TAN: Calcular valor de tangente
Descripci√≥n
La instrucci√≥n "Calcular valor de tangente" permite calcular la tangente de un √°ngulo. El
tama√±o del √°ngulo se indica en radianes en el operando.
El valor del resultado no es v√°lido si el valor del operando no es un n√∫mero en coma flotante
v√°lido.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Tama√±o del √°ngulo en radia‚Äê
nes

<Resultado>

Output

N√∫meros en coma
flotante

I, Q, M, D, L, P

Tangente del √°ngulo indicado

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

2072

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := TAN("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

+3.141593 (œÄ)

Tag_OutValue

0

La instrucci√≥n calcula la tangente del √°ngulo indicado en el operando "Tag_InValue" e indica
el resultado en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

ASIN: Calcular valor de arcoseno
Descripci√≥n
La instrucci√≥n "Calcular valor de arcoseno" permite calcular a partir del valor de seno indicado
en el operando el tama√±o del √°ngulo que corresponde a este valor. En el operando solo se
pueden indicar n√∫meros en coma flotante v√°lidos, comprendidos en un rango de valores entre
-1 y +1. El tama√±o del √°ngulo calculado puede estar comprendido entre -œÄ/2 y +œÄ/2.
El valor del resultado no es v√°lido si se cumple una de las siguientes condiciones:
‚óè El valor del operando no es un n√∫mero en coma flotante v√°lido.
‚óè El valor del operando est√° fuera del rango de valores permitido (-1 hasta +1).

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Valor de seno

<Resultado>

Output

N√∫meros en coma
flotante

I, Q, M, D, L, P

Tama√±o del √°ngulo en radia‚Äê
nes

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2073

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := ASIN("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1.0

Tag_OutValue

+1.570796 (œÄ/2)

La instrucci√≥n calcula el tama√±o del √°ngulo que corresponde al valor de seno del operando
"Tag_InValue". El resultado de la instrucci√≥n se deposita en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

ACOS: Calcular valor de arcocoseno
Descripci√≥n
La instrucci√≥n "Calcular valor de arcocoseno" permite calcular a partir del valor de coseno
indicado en el operando el tama√±o del √°ngulo que corresponde a este valor. En el operando
solo se pueden indicar n√∫meros en coma flotante v√°lidos, comprendidos en un rango de
valores entre -1 y +1. El tama√±o del √°ngulo calculado puede estar comprendido entre 0 y +œÄ.
El valor del resultado no es v√°lido si se cumple una de las siguientes condiciones:
‚óè El valor del operando no es un n√∫mero en coma flotante v√°lido.
‚óè El valor del operando est√° fuera del rango de valores permitido (-1 hasta +1).

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Valor de coseno

<Resultado>

Output

N√∫meros en coma
flotante

I, Q, M, D, L, P

Tama√±o del √°ngu‚Äê
lo en radianes

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

2074

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := ACOS("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

0

Tag_OutValue

+1.570796 (œÄ/2)

La instrucci√≥n calcula el tama√±o del √°ngulo que corresponde al valor de coseno del operando
"Tag_InValue". El resultado de la instrucci√≥n se deposita en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

ATAN: Calcular valor de arcotangente
Descripci√≥n
La instrucci√≥n "Calcular valor de arcotangente" permite calcular a partir del valor de tangente
indicado en el operando el tama√±o del √°ngulo que corresponde a este valor. En el operando
solo se pueden indicar n√∫meros en coma flotante v√°lidos (o -NaN/+NaN). El tama√±o del √°ngulo
calculado puede estar comprendido entre -œÄ/2 y +œÄ/2.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Valor de tangente

<Resultado>

Output

N√∫meros en coma
flotante

I, Q, M, D, L, P

Tama√±o del √°ngulo en radia‚Äê
nes

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2075

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := ATAN("Tag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1.0

Tag_OutValue

+0,785398 (œÄ/4)

La instrucci√≥n calcula el tama√±o del √°ngulo que equivale al valor de tangente del operando
"Tag_InValue". El resultado de la instrucci√≥n se deposita en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
N√∫meros en coma flotante no v√°lidos (P√°gina 263)
Principios b√°sicos de GRAPH (P√°gina 8191)

FRAC: Determinar decimales
Descripci√≥n
La instrucci√≥n "Determinar decimales" permite determinar los decimales del valor del
operando. Por ejemplo, si el valor del operando es 123,4567, el resultado devuelve el valor
0,4567.
El valor del resultado no es v√°lido si el valor del operando no es un n√∫mero en coma flotante
v√°lido.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada cuyos deci‚Äê
males se determinan

RET_VAL

Output

N√∫meros en coma
flotante

I, Q, M, D, L, P

Decimales del valor de entra‚Äê
da

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

2076

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL FRAC REAL
(IN := "Tag_InValue"
RET_VAL => "Tag_OutValue"
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

2.555

Tag_OutValue

0.555

La instrucci√≥n copia los decimales del valor del operando "Tag_InValue" en el operando
"Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

Transferencia
Deserialize: Deserializar
Descripci√≥n
La instrucci√≥n "Deserializar" reconvierte la forma de representaci√≥n secuencial de un tipo de
datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> y rellena todo su contenido.
El √°rea de memoria en la que se encuentra la forma de representaci√≥n secuencial de un tipo
de datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> debe ser del tipo de datos ARRAY
of BYTE o ARRAY of CHAR y tener declarado el acceso est√°ndar en la versi√≥n 1.0. A partir de
la versi√≥n 2.0 se permiten tambi√©n √°reas de memoria optimizadas. La capacidad del √°rea de
memoria est√°ndar es de 64 KB. Antes de la conversi√≥n aseg√∫rese de que hay suficiente
memoria disponible. Si el √°rea de memoria se ha rellenado utilizando la instrucci√≥n "Serializar"
y se han insertado bytes de relleno, estos no se tendr√°n en cuenta en la conversi√≥n.
Se recomienda definir a "0" el l√≠mite inferior del ARRAY, ya que entonces el √≠ndice dentro del
ARRAY se corresponde con el valor del par√°metro POS, p. ej. ARRAY[0] = POS 0. La
descripci√≥n y el ejemplo que sigue m√°s abajo se basan en estos fundamentos.
Esta instrucci√≥n reconvierte paso a paso a su estado original varias formas de representaci√≥n
secuenciales de datos convertidos.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2077

Instrucciones
4.1 Instrucciones
Para reconvertir una sola forma de representaci√≥n secuencial de un tipo de datos PLC (UDT),
STRUCT o ARRAY of <tipo de datos> tambi√©n se puede utilizar directamente la instrucci√≥n
"TRCV: Recibir datos a trav√©s de la conexi√≥n".

Tama√±o del √°rea de memoria
Debido a las reglas de alineaci√≥n, no se insertan bytes de relleno en las estructuras sencillas
del √°rea de memoria optimizada. Por consiguiente, una estructura del √°rea de memoria
optimizada es m√°s peque√±a que en el √°rea de memoria est√°ndar. Los ARRAY de estructuras
y las estructuras anidadas tienen bytes de relleno. Por lo general no es posible saber de
antemano en qu√© √°rea de memoria requiere m√°s espacio una estructura compuesta.
V√°lido para las CPU de la serie S7-1500:
En un bloque con la propiedad "Acceso optimizado al bloque", el BOOL tiene una longitud de
1 byte. Esto hace que una estructura, que b√°sicamente est√° formada por el tipo de datos
BOOL, sea mayor en el √°rea de memoria optimizada que en el √°rea de memoria est√°ndar. Las
estructuras compuestas con un porcentaje reducido de tipos de datos BOOL son menores en
el √°rea de memoria optimizada que en el √°rea de memoria est√°ndar.

√Årea de memoria optimizada
Para deserializar estructuras de mayor tama√±o, el √°rea de memoria para la representaci√≥n
secuencial puede declararse tambi√©n con acceso optimizado a partir de la versi√≥n de firmware
>= 4.2 de las CPU de la serie S7-1200 y a partir de la versi√≥n de firmware >= 2.0 de las CPU
de la serie S7-1500. El contenido de la representaci√≥n secuencial no cambia, igual que en un
√°rea de memoria est√°ndar. El acceso a los bytes del ARRAY solo es posible simb√≥licamente.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

SRC_ARRA
Y

Input

ARRAY[*] of
BYTE 1)

I, Q, D, interfaz de
bloque de un FB
(son posibles las
secciones Input,
Output, Static y
Temp).

ARRAY of BYTE o ARRAY of
CHAR, en el que se guarda el
flujo de datos que debe dese‚Äê
rializarse.

o bien
ARRAY of CHAR

S7-1500:

Para obtener el m√°ximo ren‚Äê
ning√∫n dato de pe‚Äê dimiento, no transfiera valo‚Äê
riferia
res a este par√°metro con un
puntero VARIANT.

DEST_VA‚Äê
RIABLE

InOut

Todos los tipos de
datos

I, Q, D, interfaz de
bloque de un FB,

Variable, en la que se escri‚Äê
bir√°n los datos deserializa‚Äê
ning√∫n dato de pe‚Äê dos.
riferia
S7-1500:
Para obtener el m√°ximo ren‚Äê
dimiento, no transfiera valo‚Äê
res a este par√°metro con un
puntero VARIANT.

2078

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

POS

InOut

DINT

I, Q, M, D, L

El operando del par√°metro
POS almacena el √≠ndice del
primer byte tras el n√∫mero de
bytes que ocupan los datos
de cliente convertidos. El pa‚Äê
r√°metro POS se calcula ba‚Äê
sado en cero.

RET_VAL

Output

INT

I, Q, M, D, L

Informaci√≥n de error

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

80B0

Las √°reas de memoria de los par√°metros SRC_ARRAY y DEST_VARIABLE se solapan.

8136

La variable del par√°metro SRC_ARRAY no est√° en un bloque con acceso est√°ndar.

8150

El tipo de datos VARIANT del par√°metro SRC_ARRAY contiene un puntero IGUAL A
CERO.

8151

El par√°metro SRC_ARRAY no tiene una referencia v√°lida.

8153

En el par√°metro SRC_ARRAY no hay suficiente espacio de memoria disponible.

8154

Tipo de datos no v√°lido en el par√°metro SRC_ARRAY

8250

En el par√°metro DEST_ARRAY se ha transferido un puntero CERO.

8251

El par√°metro DEST_VARIABLE no tiene una referencia v√°lida.

8382

El valor del par√°metro POS se encuentra fuera de los valores l√≠mite del array.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Particularidades a partir de la versi√≥n de firmware 4.2 (S7-1200) y 2.0 (S7-1500):
El c√≥digo de error siguiente tiene un significado distinto:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

8136

El acceso al √°rea de memoria en el par√°metro SRC_ARRAY no es v√°lido.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Particularidades a partir de la versi√≥n de firmware 2.8 (S7-1500):
El rendimiento de la instrucci√≥n "Deserializar" (versi√≥n 2.1) mejora si no se transfieren valores
a los par√°metros SRC_ARRAY y DEST_VARIABLE con un puntero VARIANT, sino con un tipo
de datos concreto.
Tenga en cuenta que el comportamiento err√≥neo de la instrucci√≥n cambia en este caso. En
determinados escenarios de error, la CPU no devuelve c√≥digos de error, sino que pasa a

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2079

Instrucciones
4.1 Instrucciones
STOP con un error de acceso. Para evitar que esto ocurra, utilice el tratamiento de errores local
con las instrucciones "GET_ERROR" y "GET_ERR_ID".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL Deserialize VARIANT
(SRC_ARRAY := "Buffer".Field
DEST_VARIABLE => "Target".Client
POS := #BufferPos
RET_VAL => #Error
)

La instrucci√≥n deserializa la forma de representaci√≥n secuencial de los datos de cliente de la
variable "Buffer" y los escribe en la variable "Target". El operando #BufferPos almacena el
√≠ndice del primer byte tras el n√∫mero de bytes que ocupan los datos de cliente convertidos.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Principios b√°sicos de VARIANT (P√°gina 335)
Principios b√°sicos de los tipos de datos PLC (UDT) (P√°gina 283)
Estructura de una variable ARRAY (P√°gina 298)
Estructura de una variable STRUCT (P√°gina 290)
Estructura de una variable STRING (P√°gina 277)
Bytes de relleno cuando se usan tipos de datos estructurados (P√°gina 143)
Principios b√°sicos de GRAPH (P√°gina 8191)

Serialize: Serializar
Descripci√≥n
Mediante la instrucci√≥n "Serializar" se convierten varios tipos de datos PLC (UDT), STRUCT
o ARRAY of <tipo de datos> a una forma de representaci√≥n secuencial sin que se pierdan
partes de su estructura.
La instrucci√≥n permite guardar temporalmente varios datos estructurados del programa en un
b√∫fer, ubicado preferentemente en un bloque de datos global, y enviarlos a otra CPU. El √°rea
de memoria en la que se depositen los datos convertidos debe ser del tipo de datos ARRAY of
BYTE o ARRAY of CHAR y tener declarado el acceso est√°ndar en la versi√≥n 1.0. A partir de
la versi√≥n 2.0 se permiten tambi√©n datos optimizados. Los datos de relleno del √°rea de datos

2080

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
del origen no est√°n definidos en el ARRAY de destino. Pueden ser tanto bytes o bits de relleno
de un √°rea de datos (p. ej., ARRAY, STRUCT o tipo de datos PLC (UDT)) como los caracteres
de una cadena que no se utilicen en ese momento.
La capacidad del √°rea de memoria est√°ndar es de 64 KB. Las estructuras mayores que 64 KB
seg√∫n las reglas para √°reas de memoria est√°ndar no pueden serializarse si el operando del
par√°metro DEST_ARRAY est√° en un √°rea de memoria est√°ndar.
Se recomienda definir a "0" el l√≠mite inferior del ARRAY, ya que entonces el √≠ndice dentro del
ARRAY se corresponde con el valor del par√°metro POS, p. ej. ARRAY[0] = POS 0. La
descripci√≥n y el ejemplo que sigue m√°s abajo se basan en estos fundamentos.
El operando del par√°metro POS contiene la informaci√≥n sobre el n√∫mero de bytes que ocupan
los datos convertidos.
Para enviar un solo tipo de datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> se puede
llamar directamente la instrucci√≥n "TSEND: Enviar datos a trav√©s de la conexi√≥n".

Tama√±o del √°rea de memoria
Debido a las reglas de alineaci√≥n, no se insertan bytes de relleno en las estructuras sencillas
del √°rea de memoria optimizada. Por consiguiente, una estructura del √°rea de memoria
optimizada es m√°s peque√±a que en el √°rea de memoria est√°ndar. Los ARRAY de estructuras
y las estructuras anidadas tienen bytes de relleno. Por lo general no es posible saber de
antemano en qu√© √°rea de memoria requiere m√°s espacio una estructura compuesta.
V√°lido para las CPU de la serie S7-1500:
En un bloque con la propiedad "Acceso optimizado al bloque", la longitud del BOOL depende
del tipo de datos que sigue. Por ejemplo, si lo que sigue es un BYTE, el BOOL tiene una
longitud de 1 byte. Si lo que sigue es WORD, el BOOL tiene una longitud de 2 bytes. Esto hace
que una estructura, que b√°sicamente est√° formada por el tipo de datos BOOL, sea mayor en
el √°rea de memoria optimizada que en el √°rea de memoria est√°ndar. Las estructuras
compuestas con un porcentaje reducido de tipos de datos BOOL son menores en el √°rea de
memoria optimizada que en el √°rea de memoria est√°ndar.
Por eso se recomienda que el √°rea de datos de origen para la serializaci√≥n empiece con tipos
de datos grandes y termine con elementos booleanos. De este modo se reduce
considerablemente el relleno con bits de relleno.

√Årea de memoria optimizada
Para serializar estructuras de mayor tama√±o, el √°rea de memoria puede declararse tambi√©n
con acceso optimizado a partir de la versi√≥n de firmware >= 4.2 de las CPU de la serie S7-1200
y a partir de la versi√≥n de firmware >= 2.0 de las CPU de la serie S7-1500. La representaci√≥n
secuencial no cambia, igual que en un √°rea de memoria est√°ndar.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2081

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

SRC_VARIA‚Äê Input
BLE

Todos los tipos de
datos

I, Q, D, interfaz de
bloque de un FB,

Variable que se serializar√°.

DEST_ARRA InOut
Y

ARRAY of BYTE o
ARRAY of CHAR

I, Q, D, interfaz de
bloque de un FB
(son posibles las
secciones Input,
Output, Static y
Temp),

Array en el que se guarda el
flujo de datos generado.

S7-1500:
ning√∫n dato de pe‚Äê Para obtener el m√°ximo ren‚Äê
riferia
dimiento, no transfiera valo‚Äê
res a este par√°metro con un
puntero VARIANT.

S7-1500:

Para obtener el m√°ximo ren‚Äê
dimiento, no transfiera valo‚Äê
res a este par√°metro con un
ning√∫n dato de pe‚Äê puntero VARIANT.
riferia

POS

InOut

DINT

I, Q, M, D, L

El operando del par√°metro
POS almacena el √≠ndice del
primer byte tras el n√∫mero to‚Äê
tal de bytes que han ocupado
los datos de cliente converti‚Äê
dos. El par√°metro POS se
calcula basado en cero.

RET_VAL

Output

INT

I, Q, M, D, L

Informaci√≥n de error

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:

2082

C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

80B0

Las √°reas de memoria de los par√°metros SRC_VARIABLE y DEST_ARRAY se solapan.

8150

El tipo de datos VARIANT del par√°metro SRC_VARIABLE contiene un puntero IGUAL A
CERO.

8151

El par√°metro SRC_VARIABLE no tiene una referencia v√°lida.

8236

La variable del par√°metro SRC_ARRAY no est√° en un bloque con acceso est√°ndar.

8250

En el par√°metro DEST_ARRAY se ha transferido un puntero CERO.

8251

El par√°metro DEST_ARRAY no tiene una referencia v√°lida.

8253

La variable del par√°metro DEST_ARRAY no ofrece suficiente espacio de memoria para
el contenido de la variable del par√°metro SRC_VARIABLE. El valor de entrada de la
variable del par√°metro POS reduce el espacio de memoria disponible. El valor de entrada
del par√°metro POS determina en qu√© posici√≥n de la variable se comienza en el par√°metro
DEST_ARRAY.

8254

Tipo de datos no v√°lido en el par√°metro DEST_ARRAY

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

8382

El valor del par√°metro POS se encuentra fuera de los valores l√≠mite del array.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Particularidades a partir de la versi√≥n de firmware 4.2 (S7-1200) y 2.0 (S7-1500):
El c√≥digo de error siguiente tiene un significado distinto:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

8236

El acceso al √°rea de memoria en el par√°metro DEST_ARRAY no es v√°lido.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Particularidades a partir de la versi√≥n de firmware 2.8 (S7-1500):
El rendimiento de la instrucci√≥n "Serializar" (versi√≥n 2.1) mejora si no se transfieren valores a
los par√°metros SRC_VARIABLE y DEST_ARRAY con un puntero VARIANT, sino con un tipo
de datos concreto.
Tenga en cuenta que el comportamiento err√≥neo de la instrucci√≥n cambia en este caso. En
determinados escenarios de error, la CPU no devuelve c√≥digos de error, sino que pasa a
STOP con un error de acceso. Para evitar que esto ocurra, utilice el tratamiento de errores local
con las instrucciones "GET_ERROR" y "GET_ERR_ID".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL Serialize VARIANT
(SRC_VARIABLE := "Source".Client
DEST_ARRAY => "Buffer".Field
POS := #BufferPos
RET_VAL => #Error
)

La instrucci√≥n serializa los datos de cliente de la variable "Source" y los escribe, en
representaci√≥n secuencial, en la variable "Buffer". El √≠ndice del siguiente byte no escrito del
operando "Buffer".Field se almacena en el operando #BufferPos.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2083

Instrucciones
4.1 Instrucciones
Principios b√°sicos de VARIANT (P√°gina 335)
Principios b√°sicos de los tipos de datos PLC (UDT) (P√°gina 283)
Estructura de una variable ARRAY (P√°gina 298)
Estructura de una variable STRUCT (P√°gina 290)
Estructura de una variable STRING (P√°gina 277)
Bytes de relleno cuando se usan tipos de datos estructurados (P√°gina 143)
Principios b√°sicos de GRAPH (P√°gina 8191)

MOVE_BLK: Copiar √°rea
Descripci√≥n
La instrucci√≥n "Copiar √°rea" copia los contenidos de un √°rea de memoria (√°rea de origen) en
un √°rea de memoria diferente (√°rea de destino). El n√∫mero de elementos que se copian en el
√°rea de destino se determina con el par√°metro COUNT. El ancho del elemento del par√°metro
IN define el ancho de los elementos que deben copiarse.
Para poder ejecutar la instrucci√≥n, el √°rea de origen y el √°rea de destino deben ser del mismo
tipo de datos.
El valor de la salida OUT no es v√°lido si se copian m√°s datos de los que se pone a disposici√≥n
en la entrada IN o en la salida OUT.
Nota
Uso de ARRAYs
La instrucci√≥n copia el contenido a partir del elemento definido n elementos (n = depende del
valor del par√°metro COUNT) desde el √°rea de origen al √°rea de destino, comenzando por el
√≠ndice especificado.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:

2084

Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN 1)

Input

N√∫meros binarios,
enteros, n√∫meros
en coma flotante,
temporizadores,
TOD, LTOD, DA‚Äê
TE, CHAR,
WCHAR

D, L

Primer elemento del √°rea de
origen que se copia

COUNT

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P o
constante

N√∫mero de elementos que
se copian del √°rea de origen
al √°rea de destino

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

OUT 1)

Output

N√∫meros binarios,
enteros, n√∫meros
en coma flotante,
temporizadores,
TOD, LTOD, DA‚Äê
TE, CHAR,
WCHAR

D, L

Primer elemento del √°rea de
destino en la que se copian
los contenidos del √°rea de
origen

1)

Los tipos de datos indicados solamente pueden utilizarse como elementos de una estructura ARRAY.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL MOVE_BLK INT_UINT
(IN := #a_array[2]
COUNT := "Tag_Count"
OUT => #b_array[1]
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

a_array[2]

El operando "a_array" es del tipo
de datos ARRAY[0..5] of INT.
Consta de 6 elementos del tipo
de datos INT.

COUNT

Tag_Count

3

OUT

b_array[1]

El operando "b_array" es del tipo
de datos ARRAY[0..6] of INT.
Consta de 7 elementos del tipo
de datos INT.

La instrucci√≥n selecciona a partir del tercer elemento tres elementos INT de la variable
#a_array y copia su contenido en la variable de salida #b_array, comenzando por el segundo
elemento.
Nota
Encontrar√° m√°s informaci√≥n sobre la instrucci√≥n MOVE_BLK en el Siemens Industry Online
Support, en el art√≠culo siguiente:
¬øC√≥mo se copian √°reas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2085

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

MOVE_BLK_VARIANT: Copiar √°rea
Descripci√≥n
La instrucci√≥n "Copiar √°rea" copia los contenidos de un √°rea de memoria (√°rea de origen) en
un √°rea de memoria diferente (√°rea de destino). Se pueden copiar elementos de un ARRAY o
un ARRAY completo en otro ARRAY del mismo tipo de datos. El tama√±o (n√∫mero de
elementos) de los ARRAY de origen y de destino puede diferir. Se pueden copiar varios
elementos dentro de un mismo ARRAY o bien copiar elementos individuales.
El n√∫mero de elementos que deben copiarse no puede rebasar el √°rea de origen o destino
seleccionado.
Cuando se utiliza la instrucci√≥n no es necesario conocer el ARRAY en el momento de crear el
bloque, puesto que el origen y el destino se transfieren v√≠a VARIANT.
El recuento en los par√°metros SRC_INDEX y DEST_INDEX comienza siempre por el l√≠mite
inferior "0", independientemente de la declaraci√≥n posterior del ARRAY.
La instrucci√≥n no se ejecuta si se copian m√°s datos de los que est√°n disponibles.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

SRC

Input

VARIANT (que
apunta a un
ARRAY o a un ele‚Äê
mento individual
del ARRAY),
ARRAY of <tipo de
datos>

L (puede declarar‚Äê El √°rea de origen de la que se
se en las seccio‚Äê
copia
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

COUNT

Input

UDINT

I, Q, M, D, L o
constante

2)

Descripci√≥n

N√∫mero de elementos que
se copian
Asigne al par√°metro COUNT
el valor "1" si en el par√°metro
SRC o en el par√°metro DEST
no hay indicado ning√∫n
ARRAY.

2086

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

SRC_INDEX

Input

DINT

I, Q, M, D, L o
constante

Define el primer elemento
que se copia:
‚óè El par√°metro
SRC_INDEX se calcula
basado en cero. Si en el
par√°metro SRC hay
indicado un ARRAY, el
entero del par√°metro
SRC_INDEX indica el
primer elemento del √°rea
de origen de la que debe
copiarse. Esto es as√≠
independientemente de
los l√≠mites declarados del
ARRAY.
‚óè Si en el par√°metro SRC
no hay indicado ning√∫n
Array o solo un elemento
individual de un ARRAY,
asigne el valor "0" al
par√°metro SRC_INDEX.

DEST_IN‚Äê
DEX

Input

DINT

I, Q, M, D, L o
constante

Define el inicio del √°rea de
memoria de destino:
‚óè El par√°metro
DEST_INDEX se calcula
basado en cero. Si en el
par√°metro DEST hay
indicado un ARRAY, el
entero del par√°metro
DEST_INDEX indica el
primer elemento del √°rea
de destino en la que debe
copiarse. Esto es as√≠
independientemente de
los l√≠mites declarados del
ARRAY.
‚óè Si en el par√°metro DEST
no hay indicado ning√∫n
ARRAY, asigne el valor
"0" al par√°metro
DEST_INDEX.

DEST

Output 1)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

VARIANT

L (puede declarar‚Äê √Årea de destino a la que se
se en las seccio‚Äê
copia el contenido del √°rea
nes "Input",
de origen.
"InOut" y "Temp"
de la interfaz del
bloque.)

2087

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

RET_VAL

Output

INT

I, Q, M, D, L

Informaci√≥n de error:
El par√°metro RET_VAL de‚Äê
vuelve un c√≥digo de error
cuando ocurre un error du‚Äê
rante la ejecuci√≥n de la ins‚Äê
trucci√≥n.

1) El par√°metro DEST est√° declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.
2) En el par√°metro SRC, los tipos de datos BOOL y ARRAY of BOOL no est√°n permitidos.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
0000

Ning√∫n error

80B4

Los tipos de datos no coinciden. En lugar de un ARRAY of Struct utilice un ARRAY of tipo
de datos PLC (UDT).

8151

No es posible acceder al par√°metro SRC.

8152

El operando del par√°metro SRC no est√° tipificado.

8153

Error de creaci√≥n de c√≥digo en el par√°metro SRC

8154

El operando del par√°metro SRC es del tipo de datos BOOL.

8281

Valor no v√°lido en el par√°metro COUNT

8382

El valor del par√°metro SRC_INDEX es menor que CERO.

8383

El valor del par√°metro SRC_INDEX se encuentra fuera del l√≠mite superior del ARRAY.

8482

El valor del par√°metro DEST_INDEX se encuentra fuera de los l√≠mites del ARRAY.

8483

El ARRAY al que se√±ala el par√°metro DEST es demasiado peque√±o para los datos que
deben copiarse.

8534

El par√°metro DEST est√° protegido contra escritura

8551

No es posible acceder al par√°metro DEST.

8552

El operando del par√°metro DEST no est√° tipificado.

8553

Error de creaci√≥n de c√≥digo en el par√°metro DEST

8554

El operando del par√°metro DEST es del tipo de datos BOOL.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL MOVE_BLK_VARIANT

2088

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
GRAPH
(SRC := #SrcField
COUNT := "Tag_Count"
SRC_INDEX := "Tag_Src_Index"
DEST_INDEX := "Tag_Dest_Index"
DEST => #DestField
RET_VAL := "Tag_Result"
)

La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Declaraci√≥n en la inter‚Äê
faz del bloque

Operando

Valor

SRC

Input

#SrcField

El operando local
#SrcField utiliza un tipo
de datos PLC todav√≠a
desconocido en el mo‚Äê
mento de programar el
bloque. (ARRAY[0..10]
of "MOVE_UDT"

COUNT

Input

Tag_Count

2

SRC_INDEX

Input

Tag_Src_Index

3

DEST_INDEX

Input

Tag_Dest_Index

3

DEST

InOut

#DestField

El operando local
#DestField utiliza un ti‚Äê
po de datos PLC toda‚Äê
v√≠a desconocido en el
momento de programar
el bloque.
(ARRAY[10..20] of "MO‚Äê
VE_UDT"

En el √°rea de destino se copian dos elementos del √°rea de origen, empezando por el cuarto
elemento del ARRAY[0..10] of MOVE_UDT. Las copias se insertan en el ARRAY[10..20] of
MOVE_UDT a partir del cuarto elemento.
Nota
Encontrar√° m√°s informaci√≥n sobre la instrucci√≥n MOVE_BLK_VARIANT en el Siemens
Industry Online Support, en el art√≠culo siguiente:
¬øC√≥mo se copian √°reas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2089

Instrucciones
4.1 Instrucciones
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Ejemplo de movimiento de datos (P√°gina 344)
Principios b√°sicos de VARIANT (P√°gina 335)
Principios b√°sicos de GRAPH (P√°gina 8191)

UMOVE_BLK: Copiar √°rea sin interrupciones
Descripci√≥n
La instrucci√≥n "Copiar √°rea sin interrupciones" copia sin interrupciones los contenidos de un
√°rea de memoria (√°rea de origen) en un √°rea de memoria diferente (√°rea de destino). El
n√∫mero de elementos que se copian en el √°rea de destino se determina con el par√°metro
COUNT. El ancho del elemento del par√°metro IN define el ancho de los elementos que deben
copiarse.
Para poder ejecutar la instrucci√≥n, el √°rea de origen y el √°rea de destino deben ser del mismo
tipo de datos.
Nota
Copiar sin interrupciones
La operaci√≥n de copia no debe ser interrumpida por otras actividades del sistema operativo.
Por este motivo, los tiempos de reacci√≥n a alarmas de la CPU podr√≠an aumentar al ejecutar la
instrucci√≥n "Copiar √°rea sin interrupciones".
El valor de la salida OUT no es v√°lido si se copian m√°s datos de los que se pone a disposici√≥n
en la entrada IN o en la salida OUT.
La instrucci√≥n "Copiar √°rea sin interrupciones" permite copiar 16 KB como m√°ximo. A este
respecto deben tenerse en cuenta las limitaciones espec√≠ficas de la CPU.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

N√∫meros binarios,
enteros, n√∫meros
en coma flotante,
temporizadores,
TOD, LTOD, DA‚Äê
TE, CHAR,
WCHAR

D, L

Primer elemento del √°rea de
origen que se copia

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P o
constante

N√∫mero de elementos que
se copian del √°rea de origen
al √°rea de destino

1)

COUNT

2090

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

OUT 1)

Output

N√∫meros binarios,
enteros, n√∫meros
en coma flotante,
temporizadores,
TOD, LTOD, DA‚Äê
TE, CHAR,
WCHAR

D, L

Primer elemento del √°rea de
destino en la que se copian
los contenidos del √°rea de
origen

1)

Los tipos de datos indicados solamente pueden utilizarse como elementos de una estructura ARRAY.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL UMOVE_BLK INT_UINT
(IN := #a_array[2]
COUNT := "Tag_Count"
OUT => #b_array[1]
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

a_array[2]

El operando "a_array" es del tipo
de datos ARRAY[0..5] of INT.
Consta de 6 elementos del tipo
de datos INT.

COUNT

Tag_Count

3

OUT

b_array[1]

El operando "b_array" es del tipo
de datos ARRAY[0..6] of INT.
Consta de 7 elementos del tipo
de datos INT.

La instrucci√≥n selecciona a partir del tercer elemento tres elementos INT de la variable
#a_array y copia su contenido en la variable de salida #b_array, comenzando por el segundo

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2091

Instrucciones
4.1 Instrucciones
elemento. La operaci√≥n de copia no debe ser interrumpida por otras actividades del sistema
operativo.
Nota
Encontrar√° m√°s informaci√≥n sobre la instrucci√≥n UMOVE_BLK en el Siemens Industry Online
Support, en el art√≠culo siguiente:
¬øC√≥mo se copian √°reas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

FILL_BLK: Rellenar √°rea
Descripci√≥n
La instrucci√≥n "Rellenar √°rea" permite rellenar un √°rea de memoria (√°rea de destino) con el
valor de la entrada IN. El √°rea de destino se rellena a partir de la direcci√≥n indicada en la salida
OUT. El n√∫mero de repeticiones de copia se determina mediante el par√°metro COUNT. Al
ejecutar la instrucci√≥n, el valor de la entrada IN se copia en el √°rea de destino el n√∫mero de
veces especificado por el valor del par√°metro COUNT.
Para poder ejecutar la instrucci√≥n, el √°rea de origen y el √°rea de destino deben ser del mismo
tipo de datos.
Como m√°ximo se modifican tantos elementos como tiene el ARRAY o la estructura. Si se
copian m√°s datos que los elementos disponibles en la salida OUT, el resultado no ser√° el
deseado.
Nota
Uso de ARRAYs
La instrucci√≥n lee en el √°rea de origen el contenido del elemento seleccionado y lo copia n
veces (n = depende del valor del par√°metro COUNT) en el √°rea de destino, comenzado a partir
del √≠ndice especificado.

2092

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Rellenar estructuras
Adem√°s de los elementos de un ARRAY, tambi√©n es posible rellenar varios elementos de una
estructura (STRUCT, tipo de datos PLC) con el mismo valor. La estructura cuyos elementos
deben rellenarse puede contener √∫nicamente elementos individuales del mismo tipo de datos
elemental. No obstante, la estructura propiamente dicha puede estar incrustada en otra
estructura.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

N√∫meros binarios,
enteros, n√∫meros
en coma flotante,
temporizadores,
TOD, LTOD, DA‚Äê
TE, CHAR,
WCHAR

I, Q, M, D, L, P o
constante

Elemento con el que se relle‚Äê
na el √°rea de destino

COUNT

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P o
constante

N√∫mero de repeticiones de
copia

OUT

Output

N√∫meros binarios,
enteros, n√∫meros
en coma flotante,
temporizadores,
TOD, LTOD, DA‚Äê
TE, CHAR,
WCHAR

D, L

Direcci√≥n del √°rea de destino
a partir de la cual se rellena

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo con un ARRAY
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n cuando debe rellenarse un
ARRAY:
GRAPH
CALL FILL_BLK INT_UINT
(IN := #FillValue
COUNT := "Tag_Count"
OUT => #TargetArea[1]
)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2093

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

FillValue

El operando es del tipo de datos
INT.

COUNT

Tag_Count

3

OUT

TargetArea

El operando TargetArea es del
tipo de datos ARRAY[1..5] of
INT. Consta de 5 elementos del
tipo de datos INT.

La instrucci√≥n copia tres veces el valor del operando #FillValue en la variable de salida
#TargetArea, empezando por el primer elemento.

Ejemplos con una estructura
Los siguientes ejemplos muestran el funcionamiento de la instrucci√≥n cuando debe rellenarse
una estructura.
Cree un bloque de datos global con los elementos siguientes:
Data_block_1

Tipo de datos

MyStruct1

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

MyStruct2

STRUCT

SubArray

ARRAY[1..2] of STRUCT

SubArray[1]

STRUCT

NestedStruct

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

SubArray[2]

STRUCT

Nes‚Äê
tedStruct

STRUCT
Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

Cree el c√≥digo de programa siguiente para direccionar la variable MyStruct1:
GRAPH
CALL FILL_BLK INT_UINT
(IN := 10

2094

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
GRAPH
COUNT := 2
OUT => "Data_block_1".MyStruct1.Member_2
)

Cree el c√≥digo de programa siguiente para direccionar la variable MyStruct2:
GRAPH
CALL FILL_BLK INT_UINT
(IN := 10
COUNT := 2
OUT => "Data_block_1".MyStruct2.SubArray[1].NestedStruct.Member_2
)

En ambos ejemplos, el valor 10 del par√°metro IN se copia dos veces en el operando del
par√°metro OUT, empezando por el elemento Member_2. Esto significa que el valor 10 se copia
tanto en el elemento Member_2 como en el Member_3. Los otros dos elementos, Member_1
y Member_4, no cambian.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

UFILL_BLK: Rellenar √°rea sin interrupciones
Descripci√≥n
La instrucci√≥n "Rellenar √°rea sin interrupciones" rellena sin interrupciones un √°rea de memoria
(√°rea de destino) con el valor de la entrada IN. El √°rea de destino se rellena a partir de la
direcci√≥n indicada en la salida OUT. El n√∫mero de repeticiones de copia se determina
mediante el par√°metro COUNT. Al ejecutar la instrucci√≥n, el valor de la entrada IN se copia en
el √°rea de destino el n√∫mero de veces especificado por el valor del par√°metro COUNT.
Para poder ejecutar la instrucci√≥n, el √°rea de origen y el √°rea de destino deben ser del mismo
tipo de datos.
Nota
La operaci√≥n de copia no debe ser interrumpida por otras actividades del sistema operativo.
Por este motivo, los tiempos de reacci√≥n a alarmas de la CPU podr√≠an aumentar al ejecutar la
instrucci√≥n "Rellenar √°rea sin interrupciones".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2095

Instrucciones
4.1 Instrucciones
Como m√°ximo se modifican tantos elementos como tiene el ARRAY o la estructura. Si se
copian m√°s datos que los elementos disponibles en la salida OUT, el resultado no ser√° el
deseado.
Nota
Uso de ARRAYs
La instrucci√≥n lee en el √°rea de origen el contenido del elemento seleccionado y lo copia n
veces (n = depende del valor del par√°metro COUNT) en el √°rea de destino, comenzado a partir
del √≠ndice especificado.
La instrucci√≥n "Rellenar √°rea sin interrupciones" permite copiar 16 KB como m√°ximo. A este
respecto deben tenerse en cuenta las limitaciones espec√≠ficas de la CPU.

Rellenar estructuras
Adem√°s de los elementos de un ARRAY, tambi√©n es posible rellenar varios elementos de una
estructura (STRUCT, tipo de datos PLC) con el mismo valor. La estructura cuyos elementos
deben rellenarse puede contener √∫nicamente elementos individuales del mismo tipo de datos
elemental. No obstante, la estructura propiamente dicha puede estar incrustada en otra
estructura.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

N√∫meros binarios,
enteros, n√∫meros
en coma flotante,
temporizadores,
TOD, LTOD, DA‚Äê
TE, CHAR,
WCHAR

I, Q, M, D, L, P o
constante

Elemento con el que se relle‚Äê
na el √°rea de destino

COUNT

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P o
constante

N√∫mero de repeticiones de
copia

OUT

Output

N√∫meros binarios,
enteros, n√∫meros
en coma flotante,
temporizadores,
TOD, LTOD, DA‚Äê
TE, CHAR,
WCHAR

D, L

Direcci√≥n del √°rea de destino
a partir de la cual se rellena

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

2096

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo con un ARRAY
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n cuando debe rellenarse un
ARRAY:
GRAPH
CALL UFILL_BLK INT_UINT
(IN := #FillValue
COUNT := "Tag_Count"
OUT => #TargetArea[1]
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

IN

FillValue

El operando es del tipo de datos
INT.

COUNT

Tag_Count

3

OUT

TargetArea

El operando TargetArea es del
tipo de datos ARRAY[1..5] of
INT. Consta de 5 elementos del
tipo de datos INT.

La instrucci√≥n copia tres veces el valor del operando #FillValue en la variable de salida
#TargetArea, empezando por el primer elemento. La operaci√≥n de copia no debe ser
interrumpida por otras actividades del sistema operativo.

Ejemplos con una estructura
Los siguientes ejemplos muestran el funcionamiento de la instrucci√≥n cuando debe rellenarse
una estructura.
Cree un bloque de datos global con los elementos siguientes:
Data_block_1

Tipo de datos

MyStruct1

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

MyStruct2

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

STRUCT

2097

Instrucciones
4.1 Instrucciones
Data_block_1

Tipo de datos

SubArray

ARRAY[1..2] of STRUCT

SubArray[1]

STRUCT

NestedStruct

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

SubArray[2]

STRUCT

Nes‚Äê
tedStruct

STRUCT
Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

Cree el c√≥digo de programa siguiente para direccionar la variable MyStruct1:
GRAPH
CALL UFILL_BLK INT_UINT
(IN := 10
COUNT := 2
OUT => "Data_block_1".MyStruct1.Member_2
)

Cree el c√≥digo de programa siguiente para direccionar la variable MyStruct2:
GRAPH
CALL UFILL_BLK INT_UINT
(IN := 10
COUNT := 2
OUT => "Data_block_1".MyStruct2.SubArray[1].NestedStruct.Member_2
)

En ambos ejemplos, el valor 10 del par√°metro IN se copia dos veces en el operando del
par√°metro OUT, empezando por el elemento Member_2. Esto significa que el valor 10 se copia
tanto en el elemento Member_2 como en el Member_3. Los otros dos elementos, Member_1
y Member_4, no cambian.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

2098

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

SCATTER: Dispersi√≥n de una secuencia de bits en bits individuales
Descripci√≥n
La instrucci√≥n "Dispersi√≥n de una secuencia de bits en bits individuales" descompone una
variable del tipo de datos BYTE, WORD, DWORD o LWORD en bits individuales y los guarda
en un ARRAY of BOOL, un STRUCT an√≥nimo o un tipo de datos PLC con elementos
booleanos exclusivamente.
Nota
ARRAY of BOOL multidimensional
En la instrucci√≥n "Dispersi√≥n de una secuencia de bits en bits individuales" no est√° permitido
utilizar un ARRAY of BOOL multidimensional.
Nota
Longitud del ARRAY, del STRUCT o del tipo de datos PLC
El ARRAY, el STRUCT an√≥nimo o el tipo de datos PLC deben tener tantos elementos como se
especifique en la secuencia de bits.
Es decir, en el tipo de datos BYTE, p. ej., el ARRAY, el STRUCT o el tipo de datos PLC deben
tener exactamente 8 elementos (WORD = 16, DWORD = 32 y LWORD = 64).
Nota
Disponibilidad de la instrucci√≥n
La instrucci√≥n puede utilizarse en las CPU de la serie S7-1500 a partir de la versi√≥n de firmware
2.1.
De este modo es posible, p. ej., descomponer una palabra de estado y leer y modificar por
√≠ndice el estado de los bits individuales. Mediante GATHER pueden juntarse nuevamente los
bits en una secuencia de bits.
La salida de habilitaci√≥n ENO devuelve el estado l√≥gico "0" si el ARRAY no proporciona
suficientes elementos BOOL.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2099

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

IN

Input

Tipo de datos

√Årea de memoria

BYTE, WORD,
I, Q, M, D, L
DWORD, LWORD

Descripci√≥n
Secuencia de bits
que se descompo‚Äê
ne.
Los valores no
pueden encontrar‚Äê
se en el √°rea de
periferia o en el
DB de un objeto
tecnol√≥gico.

OUT

Output

ARRAY[*] of
BOOL, STRUCT o
tipo de datos PLC

I, Q, M, D, L

*: 8, 16, 32 o 64
elementos

ARRAY, STRUCT
o tipo de datos
PLC en el/los que
se guardan los bits
individuales

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo con un ARRAY
Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceWord

Input

WORD

DestinationArray

Output

ARRAY[0..15] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL SCATTER
(IN := #SourceWord
OUT => #DestinationArray
)

La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceWord

WORD (16 bits)

OUT

DestinationArray

El operando "DestinationArray"
es del tipo de datos
ARRAY[0..15] of BOOL. Consta
de 16 elementos y, por tanto, tie‚Äê
ne el mismo tama√±o que la
WORD que se debe descompo‚Äê
ner.

El operando #SourceWord del tipo de datos WORD se descompone en sus bits individuales
(16) y se asigna a los distintos elementos del operando #DestinationArray.

2100

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo con un tipo de datos PLC (UDT)
Cree el siguiente tipo de datos PLC "myBits":

Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceWord

Input

WORD

DestinationUDT

Output

"myBits"

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL SCATTER
(IN := #SourceWord
OUT => #DestinationUDT
)

La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceWord

WORD (16 bits)

OUT

DestinationUDT

El operando "DestinationUDT"
es del tipo de datos PLC (UDT).
Consta de 16 elementos y, por
tanto, tiene el mismo tama√±o
que la WORD que se debe des‚Äê
componer.

El operando #SourceWord del tipo de datos WORD se descompone en sus bits individuales
(16) y se asigna a los distintos elementos del operando #DestinationUDT.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2101

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

SCATTER_BLK: Dispersi√≥n de elementos de un ARRAY of secuencia de bits en bits individuales
Descripci√≥n
La instrucci√≥n "Dispersi√≥n de elementos de un ARRAY of secuencia de bits en bits
individuales" descompone uno o varios elementos de un ARRAY of BYTE, WORD, DWORD
o LWORD en bits individuales y los guarda en un ARRAY of BOOL, un STRUCT an√≥nimo o un
tipo de datos PLC con elementos booleanos exclusivamente. En el par√°metro COUNT_IN se
introduce el n√∫mero de elementos del ARRAY de origen que deben dispersarse. El ARRAY de
origen en el par√°metro IN puede tener m√°s elementos que los indicados en el par√°metro
COUNT_IN. El ARRAY of BOOL, el STRUCT an√≥nimo o el tipo de datos PLC deben tener
suficientes elementos para poder guardar los bits de la secuencia de bits descompuesta. El
√°rea de memoria de destino tambi√©n puede ser mayor.
Nota
ARRAY of BOOL multidimensional
Si el ARRAY es un ARRAY of BOOL multidimensional, se cuentan tambi√©n los bits de relleno
de las dimensiones contenidas, aunque no se hayan declarado expl√≠citamente.
Ejemplo 1: un ARRAY[1..10,0..4,1..2] of BOOL recibe el mismo tratamiento que un
ARRAY[1..10,0..4,1..8] of BOOL o que un ARRAY[0..399] of BOOL.
Ejemplo 2: En el par√°metro IN hay un ARRAY[0..5] of WORD (sourceArrayWord[2])
interconectado. El par√°metro COUNT_IN tiene el valor "3". En el par√°metro OUT hay un
ARRAY[0..1,0..5,0..7] of BOOL (destinationArrayBool[0,0,0]) interconectado. Tanto el array
del par√°metro IN como el del par√°metro OUT tienen 96 bits de tama√±o. El ARRAY of WORD
se descompone en 48 bits individuales.
Nota
Si el l√≠mite inferior del ARRAY de destino no es "0", cabe considerar lo siguiente:
Por motivos de rendimiento, el √≠ndice debe comenzar siempre en un l√≠mite de BYTE, WORD,
DWORD o LWORD. Esto significa que debe calcularse el √≠ndice partiendo del l√≠mite inferior del
ARRAY. Como base para el c√°lculo se utiliza la siguiente f√≥rmula:
√çndice v√°lido = l√≠mite inferior del ARRAY + n(n√∫mero de secuencias de bits) * n√∫mero de bits
de la secuencia de bits deseada
Para un ARRAY[-2..45] of BOOL y la secuencia de bits WORD, el c√°lculo es el siguiente:
‚óè √çndice v√°lido (-2) = -2 + 0 * 16
‚óè √çndice v√°lido (14) = -2 + 1 * 16
‚óè √çndice v√°lido (30) = -2 + 2 * 16
Ver un ejemplo m√°s adelante.

2102

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Nota
Disponibilidad de la instrucci√≥n
La instrucci√≥n puede utilizarse en las CPU de la serie S7-1500 a partir de la versi√≥n de firmware
2.1.
De este modo es posible, p. ej., descomponer palabras de estado y leer y modificar por √≠ndice
el estado de los bits individuales. Mediante GATHER pueden juntarse nuevamente los bits en
una secuencia de bits.
La salida de habilitaci√≥n ENO devuelve el estado l√≥gico "0" si se cumple una de las siguientes
condiciones:
‚óè El ARRAY de origen tiene menos elementos que los que se especifican en el par√°metro
COUNT_IN.
‚óè El √≠ndice del ARRAY de destino no empieza en un l√≠mite de BYTE, WORD, DWORD o
LWORD. En este caso no se escribe ning√∫n resultado en el ARRAY of BOOL.
‚óè El ARRAY[*] of BOOL, el STRUCT o el tipo de datos PLC no proporcionan el n√∫mero
necesario de elementos. en este caso se descomponen tantas secuencias de bits como
sea posible y se escriben en el ARRAY of BOOL, STRUCT an√≥nimo o tipo de datos PLC.
El resto de secuencias de bits no se tiene en cuenta.
Nota
CPU S7-1200: Salida de habilitaci√≥n ENO = 0
Si la salida de habilitaci√≥n ENO devuelve el estado l√≥gico "0", no se escribir√°n datos en el
par√°metro de salida OUT.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2103

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

IN

Input

Tipo de datos
Elemento de un
ARRAY[*] of <se‚Äê
cuencia de bits>

√Årea de memoria

Descripci√≥n

I, Q, M, D, L

ARRAY of <se‚Äê
cuencia de bits>
que se descompo‚Äê
ne.
Los valores no
pueden encontrar‚Äê
se en el √°rea de
periferia o en el
DB de un objeto
tecnol√≥gico.

COUNT_IN

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L

Contador del n√∫‚Äê
mero de elemen‚Äê
tos del ARRAY de
origen que deben
descomponerse.
El valor no puede
encontrarse en el
√°rea de periferia o
en el DB de un ob‚Äê
jeto tecnol√≥gico.

OUT

Output

Elemento de un
ARRAY[*] of
BOOL, STRUCT o
tipo de datos PLC

I, Q, M, D, L

ARRAY, STRUCT
o tipo de datos
PLC en el/los que
se guardan los bits
individuales

En la lista desplegable "???" del cuadro de la instrucci√≥n se puede seleccionar la secuencia de
bits deseada.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo de un ARRAY de destino con el l√≠mite inferior de "0"
Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceArrayWord

Input

ARRAY[0..5] of WORD

CounterInput
DestinationArrayBool

UDINT
Output

ARRAY[0..95] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL SCATTER_BLK
(IN := #SourceArrayWord[2]
COUNT_IN := #CounterInput
OUT => #DestinationArrayBool[0]
)

2104

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceArrayWord[2]

ARRAY[0..5] of WORD (Pueden
dispersarse 96 bits.)

COUNT_IN

CounterInput = 3

UDINT3 (deben descomponerse
3 WORD o 48 bits. Esto significa
que en el ARRAY de destino de‚Äê
be haber al menos 48 bits).

OUT

DestinationArrayBool[0]

El operando "DestinationArray‚Äê
Bool" es del tipo de datos
ARRAY[0..95] of BOOL. Hay por
tanto 96 elementos BOOL dispo‚Äê
nibles.

La 3.¬™, 4.¬™ y 5.¬™ WORD del operando #SourceArrayWord se descomponen en sus bits
individuales (48) y se asignan a los distintos elementos del operando #DestinationArrayBool a
partir del 1.er elemento.

Ejemplo de ARRAY de destino con el l√≠mite inferior de "-2"
Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceArrayWord

Input

ARRAY[0..5] of WORD

CounterInput
DestinationArrayBool

UDINT
Output

ARRAY[-2..93] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL SCATTER_BLK
(IN := #SourceArrayWord[2]
COUNT_IN := #CounterInput
OUT => #DestinationArrayBool[14]
)

La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceArrayWord[2]

ARRAY[0..5] of WORD (Pueden
dispersarse 96 bits.)

COUNT_IN

CounterInput = 3

UDINT3 (deben descomponerse
3 WORD o 48 bits. Esto significa
que en el ARRAY de destino de‚Äê
be haber al menos 48 bits).

OUT

DestinationArrayBool[14]

El operando "DestinationArray‚Äê
Bool" es del tipo de datos
ARRAY[-2..93] of BOOL. Hay
por tanto 96 elementos BOOL
disponibles.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2105

Instrucciones
4.1 Instrucciones
La 3.¬™, 4.¬™ y 5.¬™ WORD del operando #SourceArrayWord se descomponen en sus bits
individuales (48) y a partir del 16.¬∫ elemento se asignan a los distintos elementos del operando
#DestinationArrayBool. Los 32 bits restantes no se escriben.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

GATHER: Recopilaci√≥n de bits individuales en una secuencia de bits
Descripci√≥n
La instrucci√≥n "Recopilaci√≥n de bits individuales en una secuencia de bits" recompone los bits
de un ARRAY of BOOL, un STRUCT an√≥nimo o un tipo de datos PLC en una secuencia de bits
con elementos booleanos exclusivamente. La secuencia de bits se guarda en una variable del
tipo de datos BYTE, WORD, DWORD o LWORD.
Nota
ARRAY of BOOL multidimensional
En la instrucci√≥n "Recopilaci√≥n de bits individuales en una secuencia de bits" no est√° permitido
utilizar un ARRAY of BOOL multidimensional.
Nota
Longitud del ARRAY, del STRUCT o del tipo de datos PLC
El ARRAY, el STRUCT o el tipo de datos PLC deben tener tantos elementos como se
especifique en la secuencia de bits.
Es decir, en el tipo de datos BYTE, p. ej., el ARRAY, el STRUCT an√≥nimo o el tipo de datos PLC
deben tener exactamente 8 elementos (WORD = 16, DWORD = 32 y LWORD = 64).
Nota
Disponibilidad de la instrucci√≥n
La instrucci√≥n puede utilizarse en las CPU de la serie S7-1500 a partir de la versi√≥n de firmware
2.1.
La salida de habilitaci√≥n ENO devuelve el estado l√≥gico "0" si el ARRAY, el STRUCT an√≥nimo
o el tipo de datos PLC tienen m√°s o menos elementos BOOL que los especificados en la
secuencia de bits. En este caso no se transfieren los elementos BOOL. ENO tambi√©n es "0"
cuando hay menos bits de los necesarios.

2106

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

IN

Input

Tipo de datos
ARRAY[*] of
BOOL, STRUCT o
tipo de datos PLC

√Årea de memoria

Descripci√≥n

I, Q, M, D, L

ARRAY, STRUCT
o tipo de datos
PLC cuyos bits se
recomponen en
una secuencia de
bits.

*: 8, 16, 32 o 64
elementos

Los valores no
pueden encontrar‚Äê
se en el √°rea de
periferia o en el
DB de un objeto
tecnol√≥gico.
OUT

Output

BYTE, WORD,
I, Q, M, D, L
DWORD, LWORD

Secuencia de bits
recopilada que es‚Äê
t√° guardada en
una variable

En la lista desplegable "???" del cuadro de la instrucci√≥n se puede seleccionar la secuencia de
bits deseada.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo con un ARRAY
Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceArray

Input

ARRAY[0..15] of BOOL

DestinationWord

Output

WORD

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL GATHER
(IN := #SourceArray
OUT => #DestinationWord
)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2107

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operando
concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceArray

El operando "SourceArray" es
del tipo de datos ARRAY[0..15]
of BOOL. Consta de 16 elemen‚Äê
tos y, por tanto, tiene el mismo
tama√±o que la WORD en la que
se deben recomponer los bits.

OUT

DestinationWord

WORD (16 bits)

Los bits del operando #SourceArray se recopilan en una WORD.

Ejemplo con un tipo de datos PLC (UDT)
Cree el siguiente tipo de datos PLC "myBits":

Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceUDT

Input

"myBits"

DestinationWord

Output

WORD

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL GATHER
(IN := #SourceUDT
OUT => #DestinationWord
)

2108

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operando
concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceUDT

El operando "SourceUDT" es del
tipo de datos PLC (UDT). Consta
de 16 elementos y, por tanto, tie‚Äê
ne el mismo tama√±o que la
WORD en la que se deben re‚Äê
componer los bits.

OUT

DestinationWord

WORD (16 bits)

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

GATHER_BLK: Recopilaci√≥n de bits individuales en varios elementos de un ARRAY of secuencia de bits
Descripci√≥n
La instrucci√≥n "Recopilaci√≥n de bits individuales en varios elementos de un ARRAY of
secuencia de bits" recompone los bits de un ARRAY of BOOL, un STRUCT an√≥nimo o un tipo
de datos PLC con elementos booleanos exclusivamente en uno o varios elementos de un
ARRAY of <secuencia de bits>. En el par√°metro COUNT_OUT se introduce el n√∫mero de
elementos del ARRAY de destino que deben escribirse. Al hacerlo se especifica
impl√≠citamente cu√°ntos elementos del ARRAY of BOOL, del STRUCT an√≥nimo o del tipo de
datos PLC se necesitan. El ARRAY de destino en el par√°metro OUT puede tener m√°s
elementos que los indicados en el par√°metro COUNT_OUT. El ARRAY of <secuencia de bits>
debe tener suficientes elementos para poder guardar los bits que deben recopilarse. El
ARRAY de destino tambi√©n puede ser mayor.
Nota
ARRAY of BOOL multidimensional
Si el ARRAY es un ARRAY of BOOL multidimensional, se cuentan tambi√©n los bits de relleno
de las dimensiones contenidas, aunque no se hayan declarado expl√≠citamente.
Ejemplo 1: un ARRAY[1..10,0..4,1..2] of BOOL recibe el mismo tratamiento que un
ARRAY[1..10,0..4,1..8] of BOOL o que un ARRAY[0..399] of BOOL.
Ejemplo 2: En el par√°metro OUT hay un ARRAY[0..5] of WORD (sourceArrayWord[2])
interconectado. El par√°metro COUNT_IN tiene el valor "3". En el par√°metro IN hay un
ARRAY[0..1,0..5,0..7] of BOOL (destinationArrayBool[0,0,0]) interconectado. Tanto el array
del par√°metro IN como el del par√°metro OUT tienen 96 bits de tama√±o. A partir del ARRAY of
BOOL se recomponen 48 bits individuales.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2109

Instrucciones
4.1 Instrucciones
Nota
Si el l√≠mite inferior del ARRAY de origen no es "0", cabe considerar lo siguiente:
Por motivos de rendimiento, el √≠ndice debe comenzar siempre en un l√≠mite de BYTE, WORD,
DWORD o LWORD. Esto significa que debe calcularse el √≠ndice partiendo del l√≠mite inferior del
ARRAY. Como base para el c√°lculo se utiliza la siguiente f√≥rmula:
√çndice v√°lido = l√≠mite inferior del ARRAY + n(n√∫mero de secuencias de bits) * n√∫mero de bits
de la secuencia de bits deseada
Para un ARRAY[-2..45] of BOOL y la secuencia de bits WORD, el c√°lculo es el siguiente:
‚óè √çndice v√°lido (-2) = -2 + 0 * 16
‚óè √çndice v√°lido (14) = -2 + 1 * 16
‚óè √çndice v√°lido (30) = -2 + 2 * 16
Ver un ejemplo m√°s adelante.
Nota
Disponibilidad de la instrucci√≥n
La instrucci√≥n puede utilizarse en las CPU de la serie S7-1500 a partir de la versi√≥n de firmware
2.1.
La salida de habilitaci√≥n ENO devuelve el estado l√≥gico "0" si se cumple una de las siguientes
condiciones:
‚óè El √≠ndice del ARRAY de origen no empieza en un l√≠mite de BYTE, WORD, DWORD o
LWORD. En este caso no se escribe ning√∫n resultado en el ARRAY of <secuencia de bits>.
‚óè El ARRAY[*] of <secuencia de bits> no proporciona el n√∫mero necesario de elementos. en
este caso se juntan tantas secuencias de bits como sea posible y se escriben en el ARRAY
of <secuencia de bits>. El resto de los bits no se tiene en cuenta.
Nota
CPU S7-1200: Salida de habilitaci√≥n ENO = 0
Si la salida de habilitaci√≥n ENO devuelve el estado l√≥gico "0", no se escribir√°n datos en el
par√°metro de salida OUT.

2110

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

IN

Input

Tipo de datos
Elemento de un
ARRAY[*] of
BOOL, STRUCT o
tipo de datos PLC

√Årea de memoria

Descripci√≥n

I, Q, M, D, L

ARRAY of BOOL,
STRUCT o tipo de
datos PLC cuyos
bits se recompo‚Äê
nen (ARRAY de
origen).
Los valores no
pueden encontrar‚Äê
se en el √°rea de
periferia o en el
DB de un objeto
tecnol√≥gico.

COUNT_OUT

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L

Contador del n√∫‚Äê
mero de elemen‚Äê
tos del ARRAY de
destino que deben
escribirse.
El valor no puede
encontrarse en el
√°rea de periferia o
en el DB de un ob‚Äê
jeto tecnol√≥gico.

OUT

Output

Elemento de un
ARRAY[*] of <se‚Äê
cuencia de bits>

I, Q, M, D, L

ARRAY de <se‚Äê
cuencia de bits>
en el que se guar‚Äê
dan los bits
(ARRAY de desti‚Äê
no)

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo de ARRAY de origen con el l√≠mite inferior de "0"
Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceArrayBool

Input

ARRAY[0..95] of BOOL

CounterOutput
DestinationArrayWord

UDINT
Output

ARRAY[0..5] of WORD

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL GATHER_BLK
(IN := #SourceArrayBool[0]
COUNT_OUT := #CounterOutput
OUT => #DestinationArrayWord[2]

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2111

Instrucciones
4.1 Instrucciones
GRAPH
)

La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceArrayBool[0]

El operando "SourceArrayBool"
es del tipo de datos
ARRAY[0..95] of BOOL. Hay por
tanto 96 elementos BOOL dispo‚Äê
nibles que pueden volver a reco‚Äê
pilarse en palabras.

COUNT_OUT

CounterOutput = 3

UDINT3 (deben escribirse 3 pa‚Äê
labras. Esto significa que en el
ARRAY de origen debe haber 48
bits).

OUT

DestinationArrayWord[2]

El operando "DestinationArray‚Äê
Word" es del tipo de datos
ARRAY[0..5] of WORD. Hay 6
elementos WORD disponibles.

A partir del 1.er elemento del operando #SourceArrayBool se recomponen 48 bits en el
operando #DestinationArrayWord. En el ARRAY de destino se empieza a partir del 3.er
elemento. Esto significa que los primeros 16 bits se escriben en la 3.¬™ palabra, los segundos
16 bits en la 4.¬™ palabra y los terceros 16 bits en la 5.¬™ palabra del ARRAY de destino.

Ejemplo de ARRAY de origen con el l√≠mite inferior de "-2"
Cree las siguientes variables en la interfaz del bloque:
Variable

Secci√≥n

Tipo de datos

SourceArrayBool

Input

ARRAY[-2..93] of BOOL

CounterOutput
DestinationArrayWord

UDINT
Output

ARRAY[0..5] of WORD

El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL GATHER_BLK
(IN := #SourceArrayBool[14]
COUNT_OUT := #CounterOutput
OUT => #DestinationArrayWord[2]
)

2112

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra c√≥mo funciona la instrucci√≥n con valores de operandos concretos:
Par√°metro

Operando

Tipo de datos

IN

SourceArrayBool[14]

El operando "SourceArrayBool"
es del tipo de datos
ARRAY[-2..93] of BOOL. Dado
que se empieza a partir del 16.¬∫
elemento, hay solo 80 elemen‚Äê
tos BOOL disponibles que pue‚Äê
dan volver a recopilarse en pala‚Äê
bras.

COUNT_OUT

CounterOutput = 3

UDINT3 (deben escribirse 3 pa‚Äê
labras. Esto significa que en el
ARRAY de origen debe haber 48
bits).

OUT

DestinationArrayWord[2]

El operando "DestinationArray‚Äê
Word" es del tipo de datos
ARRAY[0..5] of WORD. Hay 6
elementos WORD disponibles.

A partir del 16.¬∫ elemento del operando #SourceArrayBool se recopilan 48 bits en el operando
#DestinationArrayWord. En el ARRAY de destino se empieza a partir del 3.er elemento. Esto
significa que los primeros 16 bits del ARRAY de origen no se tienen en cuenta. Los segundos
16 bits se escriben en la 3.¬™ palabra, los terceros 16 bits en la 4.¬™ palabra y los cuartos 16 bits
en la 5.¬™ palabra del ARRAY de destino. Los 64 bits restantes del ARRAY de origen tampoco
se tienen en cuenta.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

SWAP: Cambiar disposici√≥n
Descripci√≥n
Con la instrucci√≥n "Cambiar disposici√≥n" se modifica la disposici√≥n de los bytes del operando.
Dependiendo del tipo de datos utilizado, se puede cambiar el orden de los bytes en todo el
acumulador 1 o solamente en la palabra derecha del acumulador 1.
La siguiente figura muestra c√≥mo se cambian las posiciones de los bytes del operando del tipo
de datos DWORD:

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2113

Instrucciones
4.1 Instrucciones


,1

 

 
 

 

 



 

 



 

 

 

 

 



 

 



 

 


 


 



 
 

 






287

 



 

 




 

 




 

 

 

 


 


 

 

 





Disposici√≥n de los bytes en la palabra derecha del acumulador 1
Para el tipo de datos WORD se cambia la disposici√≥n de los bytes en la palabra derecha del
acumulador 1.
La tabla siguiente muestra el contenido del acumulador 1 antes y despu√©s de ejecutar la
instrucci√≥n:
Estado

Bytes del acumulador 1

Antes de la ejecuci√≥n

Valor A

Valor B

Valor C

Valor D

Despu√©s de la ejecuci√≥n

Valor A

Valor B

Valor D

Valor C

El resultado de la instrucci√≥n se guarda en la palabra derecha del acumulador 1. Los bytes de
la palabra izquierda del acumulador 1 no se ven influidos por la instrucci√≥n y no cambian.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

WORD, DWORD,
LWORD

I, Q, M, D, L o
constante

Operando cuyas
posiciones de
bytes se cambian

<Resultado>

Output

WORD, DWORD,
LWORD

I, Q, M, D, L

Resultado

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

2114

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := "SWAPTag_InValue")

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

0000

1111

0000

1111

Tag_OutValue

0000

1111

1111

0000

Cambiar la disposici√≥n de los bytes en todo el acumulador 1:
Para el tipo de datos DWORD se modifica la disposici√≥n de los bytes en todo el acumulador 1.
La tabla siguiente muestra el contenido del acumulador 1 antes y despu√©s de ejecutar la
instrucci√≥n:
Estado

Bytes del acumulador 1

Antes de la ejecuci√≥n

Valor A

Valor B

Valor C

Valor D

Despu√©s de la ejecuci√≥n

Valor D

Valor C

Valor B

Valor A

El resultado de la instrucci√≥n se guarda en el acumulador 1. El contenido del acumulador 2 no
cambia.
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1111

0000

0000

1111

0000

0000

1111

1111

Tag_OutValue

1111

1111

0000

0000

0000

1111

1111

0000

La disposici√≥n de los bytes en el operando "Tag_InValue" se guarda cambiada en el operando
"Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2115

Instrucciones
4.1 Instrucciones

DB ARRAY
ReadFromArrayDB: Leer en un bloque de datos ARRAY
Descripci√≥n
La instrucci√≥n "Leer en un bloque de datos ARRAY" lee datos de un bloque de datos del tipo
ARRAY-DB y los escribe en un √°rea de destino.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
[tipo de datos]. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier otro
tipo de datos simple. El contaje del ARRAY comienza siempre por el l√≠mite inferior "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

DB

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
lee

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB que se lee.
Puede ser una constante,
una variable global o un valor
indexado.

VALUE

Output 1)

VARIANT

L (puede declarar‚Äê Valor que se lee y se devuel‚Äê
se en las seccio‚Äê
ve
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

INT

I, Q, M, D, L, P

Resultado de la instrucci√≥n

1) El par√°metro VALUE est√° declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)

2116

0000

Ning√∫n error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

80B5

La operaci√≥n de copia se ha cancelado.

8132

El bloque de datos no existe, es demasiado corto, est√° protegido contra escritura o est√°
en la memoria de carga.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
8135

El bloque de datos de ARRAY contiene valores no v√°lidos.

8154

El bloque de datos es de un tipo incorrecto.

8282

El valor del par√°metro INDEX se encuentra fuera de los valores l√≠mite del ARRAY.

8450

El tipo de datos VARIANT del par√°metro VALUE devuelve el valor "0".

8452

Error de creaci√≥n de c√≥digo

8453

Hay dos posibles causas de error:
‚óè El tama√±o del par√°metro VALUE no coincide con la longitud del elemento en el bloque
de datos ARRAY.
‚óè Ninguna de las dos variables se encuentra en un √°rea de memoria con acceso
optimizado. Encontrar√° m√°s informaci√≥n sobre los tipos de acceso al √°rea de memoria
aqu√≠: Fundamentos del acceso a bloques (P√°gina 54)

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL ReadFromArrayDB
(DB := "ArrayDB"
INDEX := 2
VALUE => "TargetField"
RET_VAL => "TagResult"
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
Array [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

TargetField

El operando "TargetField" es
una variable global del tipo de
datos INT.

El elemento se lee en el "ArrayDB" y se escribe en el operando "TargetField".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2117

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Ejemplo de uso de bloques de datos ARRAY (P√°gina 43)
Principios b√°sicos de GRAPH (P√°gina 8191)

WriteToArrayDB: Escribir en un bloque de datos ARRAY
Descripci√≥n
La instrucci√≥n "Escribir en un bloque de datos ARRAY" escribe datos en un bloque de datos del
tipo ARRAY-DB.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
[tipo de datos]. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier otro
tipo de datos simple. El contaje del ARRAY comienza siempre por el l√≠mite inferior "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

DB

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
escribe

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB en el que se
escribe. Puede ser una cons‚Äê
tante, una variable global o
un valor indexado.

VALUE

Input

VARIANT

L (puede declarar‚Äê Valor que se escribe
se en las seccio‚Äê
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

INT

I, Q, M, D, L, P

Resultado de la instrucci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

2118

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
0000

Ning√∫n error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

80B5

La operaci√≥n de copia se ha cancelado.

8132

El bloque de datos no existe, es demasiado corto o est√° en la memoria de carga.

8134

El bloque de datos est√° protegido contra escritura.

8135

El bloque de datos no es un bloque de datos de ARRAY.

8154

El bloque de datos es de un tipo incorrecto.

8282

El valor del par√°metro INDEX se encuentra fuera de los valores l√≠mite del ARRAY.

8350

El tipo de datos VARIANT del par√°metro VALUE devuelve el valor "0".

8352

Error de creaci√≥n de c√≥digo

8353

Hay dos posibles causas de error:
‚óè El tama√±o del par√°metro VALUE no coincide con la longitud del elemento en el bloque
de datos ARRAY.
‚óè Ninguna de las dos variables se encuentra en un √°rea de memoria con acceso
optimizado. Encontrar√° m√°s informaci√≥n sobre los tipos de acceso al √°rea de memoria
aqu√≠: Fundamentos del acceso a bloques (P√°gina 54)

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL WriteToArrayDB
(DB := "ArrayDB"
INDEX := 2
VALUE := "SourceField"
RET_VAL => "TagResult"
)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2119

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
Array [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

SourceField

El operando "SourceField" es
una variable global del tipo de
datos INT.

El valor del operando "SourceField" se escribe en el segundo elemento del DB de ARRAY.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Ejemplo de uso de bloques de datos ARRAY (P√°gina 43)
Principios b√°sicos de GRAPH (P√°gina 8191)

ReadFromArrayDBL: Leer en un bloque de datos ARRAY de la memoria de carga
Descripci√≥n
Con la instrucci√≥n "Leer en un bloque de datos ARRAY de la memoria de carga" se leen los
datos de un bloque de datos del tipo de bloque ARRAY-DB en la memoria de carga y se
escriben en un √°rea de destino.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
[tipo de datos]. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier otro
tipo de datos simple. El contaje del ARRAY comienza siempre por el l√≠mite inferior "0".
Si el bloque de datos ARRAY se ha marcado con el atributo de bloque "Depositar s√≥lo en la
memoria de carga", se guarda √∫nicamente en la memoria de carga.
Si en el par√°metro REQ se detecta un flanco de se√±al ascendente, se ejecuta la instrucci√≥n.
El par√°metro BUSY devuelve el estado l√≥gico "1". Si en el par√°metro BUSY se detecta un
flanco de se√±al descendente, finaliza la instrucci√≥n. Durante un ciclo del programa, el
par√°metro DONE tiene el estado l√≥gico "1" y durante este ciclo se emite el valor le√≠do en el
par√°metro VALUE. En los dem√°s ciclos del programa, el valor del par√°metro VALUE no se
modifica.

2120

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

REQ

Input

BOOL

I, Q, M, D, L o
constante

REQ = "1": Comenzar la lec‚Äê
tura del DB de ARRAY

DB 1)

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
lee

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB que se lee.
Puede ser una constante,
una variable global o un valor
indexado.

VALUE 1)

InOut

VARIANT

D (elemento de un
bloque de datos
global)

Puntero al bloque de datos
de la memoria de trabajo que
se lee y cuyo valor se escribe.

L (puede declarar‚Äê No est√° permitido utilizar
constantes locales o varia‚Äê
se en las seccio‚Äê
bles de la secci√≥n TEMP.
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)
BUSY

Output

BOOL

I, Q, M, D, L

BUSY = "1": La lectura del
DB de ARRAY todav√≠a no ha
finalizado

DONE

Output

BOOL

I, Q, M, D, L

DONE = "1": La instrucci√≥n
se ha ejecutado correcta‚Äê
mente

ERROR

Output

INT

I, Q, M, D, L, P

Informaci√≥n de error:
El par√°metro ERROR devuel‚Äê
ve un c√≥digo de error cuando
ocurre un error durante la eje‚Äê
cuci√≥n de la instrucci√≥n.

1)

Los bloques de datos deben crearse con la propiedad de bloque "Optimizado".

Par√°metro ERROR
La tabla siguiente muestra el significado de los valores del par√°metro ERROR:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
0000

Ning√∫n error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8230

El n√∫mero del bloque de datos es incorrecto.

8231

El bloque de datos no existe.

8232

El bloque de datos es demasiado corto o no est√° en la memoria de carga.

8235

El bloque de datos no es un DB de ARRAY.

8254

El bloque de datos es de un tipo incorrecto.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2121

Instrucciones
4.1 Instrucciones
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
8382

El valor del par√°metro INDEX se encuentra fuera de los valores l√≠mite del ARRAY.

8750

El tipo de datos VARIANT del par√°metro VALUE devuelve el valor "0".

8751

Error de creaci√≥n de c√≥digo

8752

Error de creaci√≥n de c√≥digo

8753

El tama√±o del par√°metro VALUE no coincide con la longitud del elemento en el bloque de
datos ARRAY.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Encontrar√° la descripci√≥n de los c√≥digos de error activados por las instrucciones "READ_DBL"
y "WRIT_DBL" en las descripciones de las instrucciones correspondientes.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL ReadFromArrayDBL DB_ANY, "ReadFromArrayDBL_DB"
(REQ := "TagReg"
DB := "ArrayDB"
INDEX := 2
VALUE := "TargetField"
BUSY => "TagBusy"
DONE => "TagDone"
ERROR => "TagError"
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

REQ

TagReq

BOOL

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
ARRAY [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

TargetField

El operando "TargetField" es
una variable global del tipo de
datos INT.

BUSY

TagBusy

BOOL

DONE

TagDone

BOOL

Si en el operando "TagReq" se detecta un flanco de se√±al ascendente, se ejecuta la
instrucci√≥n. El segundo elemento se lee en el "ArrayDB" y se devuelve en el par√°metro
"VALUE". En cuanto se detecta un flanco de se√±al descendente en el operando "TagBusy",

2122

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
finaliza la instrucci√≥n y el valor del par√°metro VALUE ya no se modifica. Despu√©s de ejecutar
la instrucci√≥n, el operando "TagDone" tiene el estado l√≥gico TRUE.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Ejemplo de uso de bloques de datos ARRAY (P√°gina 43)
Diferencia entre las instrucciones que funcionan s√≠ncronamente y las que funcionan
as√≠ncronamente (P√°gina 618)
Principios b√°sicos de GRAPH (P√°gina 8191)

WriteToArrayDBL: Escribir en un bloque de datos ARRAY de la memoria de carga
Descripci√≥n
La instrucci√≥n "Escribir en un bloque de datos ARRAY de la memoria de carga" escribe datos
en un bloque de datos del tipo ARRAY-DB de la memoria de carga.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
[tipo de datos]. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier otro
tipo de datos simple. El contaje del ARRAY comienza siempre por el l√≠mite inferior "0".
Si el bloque de datos ARRAY se ha marcado con el atributo de bloque "Depositar s√≥lo en la
memoria de carga", se guarda √∫nicamente en la memoria de carga.
Si en el par√°metro REQ se detecta un flanco de se√±al ascendente, se ejecuta la instrucci√≥n.
El par√°metro BUSY devuelve el estado l√≥gico "1". Si en el par√°metro BUSY se detecta un
flanco de se√±al descendente, finaliza la instrucci√≥n y el valor del par√°metro VALUE se escribe
en el bloque de datos. Durante un ciclo del programa, el par√°metro DONE tiene el estado
l√≥gico "1".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

REQ

Input

BOOL

I, Q, M, D, L o
constante

REQ = "1": Comenzar a es‚Äê
cribir en el DB de array

DB 1)

Input

DB_ANY

I, Q, M, D, L

Bloque de datos ARRAY en
el que se escribe

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB en el que se
escribe. Puede ser una cons‚Äê
tante, una variable global o
un valor indexado.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2123

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

VALUE 1)

Input

VARIANT

D (elemento de un
bloque de datos
global)

Puntero al bloque de datos
de la memoria de trabajo que
se lee y cuyo valor se escribe.

L (puede declarar‚Äê No est√° permitido utilizar
constantes locales o varia‚Äê
se en las seccio‚Äê
bles de la secci√≥n TEMP.
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)
BUSY

Output

BOOL

I, Q, M, D, L

BUSY = "1": Todav√≠a no se
ha terminado de escribir en el
DB de array

DONE

Output

BOOL

I, Q, M, D, L

DONE = "1": La instrucci√≥n
se ha ejecutado correcta‚Äê
mente

ERROR

Output

INT

I, Q, M, D, L, P

Informaci√≥n de error:
El par√°metro ERROR devuel‚Äê
ve un c√≥digo de error cuando
ocurre un error durante la eje‚Äê
cuci√≥n de la instrucci√≥n.

1)

Los bloques de datos deben crearse con la propiedad de bloque "Optimizado".

Par√°metro ERROR
La tabla siguiente muestra el significado de los valores del par√°metro ERROR:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
0000

Ning√∫n error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8230

El n√∫mero del bloque de datos es incorrecto.

8231

El bloque de datos no existe.

8232

El bloque de datos es demasiado corto o no est√° en la memoria de carga.

8234

El bloque de datos est√° protegido contra escritura.

8235

El bloque de datos no es un DB de ARRAY.

8254

El bloque de datos es de un tipo incorrecto.

8382

El valor del par√°metro INDEX se encuentra fuera de los valores l√≠mite del ARRAY.

8450

El tipo de datos VARIANT del par√°metro VALUE devuelve el valor "0".

8751

Error de creaci√≥n de c√≥digo

8752

Error de creaci√≥n de c√≥digo

8753

El tama√±o del par√°metro VALUE no coincide con la longitud del elemento en el bloque de
datos ARRAY.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

2124

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrar√° la descripci√≥n de los c√≥digos de error activados por las instrucciones "READ_DBL"
y "WRIT_DBL" en las descripciones de las instrucciones correspondientes.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL WriteToArrayDBL DB_ANY, "WriteToArrayDBL_DB"
(REQ := "TagReg"
DB := "ArrayDB"
INDEX := 2
VALUE := "SourceField"
BUSY => "TagBusy"
DONE => "TagDone"
ERROR => "TagError"
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

REQ

TagReq

BOOL

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
ARRAY [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

SourceField

El operando "SourceField" es
una variable global del tipo de
datos INT.

BUSY

TagBusy

BOOL

DONE

TagDone

BOOL

Si en el operando "TagReq" se detecta un flanco de se√±al ascendente, se ejecuta la
instrucci√≥n. En cuanto se detecta un flanco descendente en el operando "TagBusy", la
instrucci√≥n finaliza y el valor del par√°metro VALUE se escribe en el segundo elemento del
"ArrayDB". Despu√©s de ejecutar la instrucci√≥n, el operando "TagDone" tiene el estado l√≥gico
TRUE.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Ejemplo de uso de bloques de datos ARRAY (P√°gina 43)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2125

Instrucciones
4.1 Instrucciones
Diferencia entre las instrucciones que funcionan s√≠ncronamente y las que funcionan
as√≠ncronamente (P√°gina 618)
Principios b√°sicos de GRAPH (P√°gina 8191)

Legacy
BLKMOV: Copiar √°rea
Descripci√≥n
La instrucci√≥n "Copiar √°rea" copia los contenidos de un √°rea de memoria (√°rea de origen) en
un √°rea de memoria diferente (√°rea de destino). La operaci√≥n de copia se realiza por orden
ascendente de direcciones. Las √°reas de origen y destino se definen mediante VARIANT.
Nota
Las variables de la instrucci√≥n solo se pueden usar en las √°reas de memoria en las que no est√©
activado el atributo "Acceso optimizado al bloque". Esto es v√°lido para bloques de datos (DB),
bloques de organizaci√≥n (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucci√≥n se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable tambi√©n se puede usar en √°reas de memoria "con acceso
optimizado al bloque".
La figura siguiente muestra el principio de la operaci√≥n de copia:

'%'%:

$

%

'%'%:

&

'

'%'%:

(

)

'%'%:

*

+

&RSLDU
/DFRSLDVHHIHFW¬ºDHQ
VHQWLGRDVFHQGHQWHGH
ODVGLUHFFLRQHV

0:

$

%

0:

&

'

0:

(

)

0:

*

+

¬ÉUHDGHPHPRULD

2126

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Coherencia de los datos de origen y destino
Tenga en cuenta que al ejecutar la instrucci√≥n "Copiar √°rea" no se modifican los datos de
origen. De lo contrario no est√° garantizada la coherencia de los datos de destino.

Posibilidad de interrupci√≥n
No hay limitaciones en cuanto a la profundidad de anidamiento.

√Åreas de memoria
La instrucci√≥n "Copiar √°rea" permite copiar las siguientes √°reas de memoria:
‚óè √Åreas de un bloque de datos
‚óè Marcas
‚óè Memoria imagen de proceso de las entradas
‚óè Memoria imagen de proceso de las salidas

Reglas generales para copiar
Las √°reas de origen y destino no deben solaparse. Si las √°reas de origen y destino son de
diferente longitud, se copia solo hasta la longitud del √°rea m√°s peque√±a.
Si el √°rea de origen es m√°s peque√±a que el √°rea de destino, el √°rea de origen se copiar√° por
completo en el √°rea de destino. Los restantes bytes del √°rea de destino permanecen
inalterados.
Si el √°rea de destino es m√°s peque√±a que el √°rea de origen, se escribir√° en toda el √°rea de
destino. Los restantes bytes del √°rea de origen se ignoran.
Al copiar un √°rea del tipo de datos BOOL, la variable debe direccionarse de forma absoluta y
la longitud indicada del √°rea debe ser un m√∫ltiplo de 8, pues de lo contrario no se ejecutar√° la
instrucci√≥n.

Reglas para copiar cadenas de caracteres
La instrucci√≥n "Copiar √°rea" permite copiar asimismo √°reas de origen y destino del tipo de
datos STRING. Si solo el √°rea de origen es del tipo de datos STRING, se copiar√°n los
caracteres realmente contenidos en la cadena de caracteres. La informaci√≥n sobre la longitud
real y m√°xima tambi√©n se escribe en el √°rea de destino. Si tanto el √°rea de origen como el √°rea
de destino son del tipo de datos STRING, la longitud actual de la cadena de caracteres en el
√°rea de destino se pone al n√∫mero de caracteres realmente copiados.
Si se desea copiar informaci√≥n sobre la longitud m√°xima y real de una cadena de caracteres,
las √°reas de los par√°metros SRCBLK y DSTBLK deben indicarse en bytes.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2127

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

SRCBLK

Input

VARIANT

I, Q, M, D, L, P

Indicaci√≥n del √°rea de memo‚Äê
ria que se copia (√°rea de ori‚Äê
gen).

RET_VAL

Output

INT

I, Q, M, D, L, P

Informaci√≥n de error:
El par√°metro RET_VAL de‚Äê
vuelve un c√≥digo de error
cuando se produce un error
durante la ejecuci√≥n de la ins‚Äê
trucci√≥n.

DSTBLK

Output

VARIANT 1)

I, Q, M, D, L, P

Indicaci√≥n del √°rea de memo‚Äê
ria en la que se copia (√°rea
de destino).

1) El par√°metro DSTBLK est√° declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse en la interfaz del bloque como InOut.

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

8092

El √°rea de origen o destino est√° solo en la memoria de carga.

8152

En el par√°metro SRCBLK no se soportan los tipos de datos WSTRING, WCHAR, BOOL
y ARRAY of STRING.

8352

En el par√°metro DSTBLK no se soportan los tipos de datos WSTRING, WCHAR, BOOL
y ARRAY of STRING.

Informaci√≥n
de error ge‚Äê
neral

Consulte tambi√©n: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL BLKMOV VARIANT
(SRCBLK := P#M100.0 BYTE 10
RET_VAL => "Tag_ErrorCode"
DSTBLK => P#DB1.DBX0.0 BYTE 10
)

2128

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucci√≥n copia 10 bytes a partir de MB100 y los escribe en el DB1. Si ocurre un error
durante la operaci√≥n de copia, el respectivo c√≥digo de error se indica en la variable
"Tag_ErrorCode".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
GET_ERR_ID: Consultar ID de error localmente (P√°gina 2159)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Principios b√°sicos de GRAPH (P√°gina 8191)

UBLKMOV: Copiar √°rea sin interrupciones
Descripci√≥n
La instrucci√≥n "Copiar √°rea sin interrupciones" copia los contenidos de un √°rea de memoria
(√°rea de origen) en un √°rea de memoria diferente (√°rea de destino). La operaci√≥n de copia se
realiza por orden ascendente de direcciones. Las √°reas de origen y destino se definen
mediante VARIANT.
La operaci√≥n de copia no debe ser interrumpida por otras actividades del sistema operativo.
Ello puede aumentar el tiempo de reacci√≥n a alarmas de la CPU durante la ejecuci√≥n de la
instrucci√≥n "Copiar √°rea sin interrupciones".
Nota
Las variables de la instrucci√≥n solo se pueden usar en las √°reas de memoria en las que no est√©
activado el atributo "Acceso optimizado al bloque". Esto es v√°lido para bloques de datos (DB),
bloques de organizaci√≥n (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucci√≥n se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable tambi√©n se puede usar en √°reas de memoria "con acceso
optimizado al bloque".

√Åreas de memoria
La instrucci√≥n "Copiar √°rea sin interrupciones" permite copiar las siguientes √°reas de memoria:
‚óè √Åreas de un bloque de datos
‚óè Marcas
‚óè Memoria imagen de proceso de las entradas
‚óè Memoria imagen de proceso de las salidas

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2129

Instrucciones
4.1 Instrucciones

Reglas generales para copiar
Al ejecutar la instrucci√≥n "Copiar √°rea sin interrupciones" no pueden solaparse las √°reas de
origen y destino. Si el √°rea de origen es m√°s peque√±a que el √°rea de destino, el √°rea de origen
se copiar√° por completo en el √°rea de destino. Los restantes bytes del √°rea de destino
permanecen inalterados.
Si el √°rea de destino es m√°s peque√±a que el √°rea de origen, se escribir√° en toda el √°rea de
destino. Los restantes bytes del √°rea de origen se ignoran.
Si un √°rea de origen o destino definida como par√°metro formal es menor que un √°rea de origen
o destino indicada en los par√°metros SRCBLK o DSTBLK, no se transferir√°n datos.
Al copiar un √°rea del tipo de datos BOOL, la variable debe direccionarse de forma absoluta y
la longitud indicada del √°rea debe ser un m√∫ltiplo de 8, pues de lo contrario no se ejecutar√° la
instrucci√≥n.
La instrucci√≥n "Copiar √°rea sin interrupciones" permite copiar 16 KB como m√°ximo. A este
respecto deben tenerse en cuenta las limitaciones espec√≠ficas de la CPU.

Reglas para copiar cadenas de caracteres
La instrucci√≥n "Copiar √°rea sin interrupciones" permite copiar asimismo √°reas de origen y
destino del tipo de datos STRING. Si solo el √°rea de origen es del tipo de datos STRING, se
copiar√°n los caracteres realmente contenidos en la cadena de caracteres. La informaci√≥n
sobre la longitud real y m√°xima no se escribe en el √°rea de destino. Si tanto el √°rea de origen
como el √°rea de destino son del tipo de datos STRING, la longitud actual de la cadena de
caracteres en el √°rea de destino se pone al n√∫mero de caracteres realmente copiados. Si se
copian √°reas del tipo de datos STRING, debe indicarse "1" como longitud del √°rea.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

SRCBLK

Input

VARIANT

I, Q, M, D, L, P

Indicaci√≥n del √°rea de memo‚Äê
ria que se copia (√°rea de ori‚Äê
gen).

RET_VAL

Output

INT

I, Q, M, D, L, P

Informaci√≥n de error:
El par√°metro RET_VAL de‚Äê
vuelve un c√≥digo de error
cuando se produce un error
durante la ejecuci√≥n de la ins‚Äê
trucci√≥n.

DSTBLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicaci√≥n del √°rea de memo‚Äê
ria en la que se copia (√°rea
de destino).

1) El par√°metro DSTBLK est√° declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse en la interfaz del bloque como InOut.

2130

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

8091

El √°rea de origen o destino est√° solo en la memoria de carga.

8152

En el par√°metro SRCBLK no se soportan los tipos de datos WSTRING, WCHAR, BOOL
y ARRAY of STRING.

8352

En el par√°metro DSTBLK no se soportan los tipos de datos WSTRING, WCHAR, BOOL
y ARRAY of STRING.

Informaci√≥n
de error ge‚Äê
neral

Consulte tambi√©n: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL UBLKMOV VARIANT
(SRCBLK := P#M100.0 BYTE 10
RET_VAL => "Tag_ErrorCode"
DSTBLK => P#DB1.DBX0.0 BYTE 10
)

La instrucci√≥n copia 10 bytes a partir de MB100 y los escribe en el DB1. Si ocurre un error
durante la operaci√≥n de copia, el respectivo c√≥digo de error se indica en la variable
"Tag_ErrorCode".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
GET_ERR_ID: Consultar ID de error localmente (P√°gina 2159)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Principios b√°sicos de GRAPH (P√°gina 8191)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2131

Instrucciones
4.1 Instrucciones

FILL: Rellenar √°rea
Descripci√≥n
La instrucci√≥n "Rellenar √°rea" rellena un √°rea de memoria (√°rea de destino) con el contenido
de un √°rea de memoria diferente (√°rea de origen). La instrucci√≥n "Rellenar √°rea" copia el
contenido del √°rea de origen en el √°rea de destino hasta que el √°rea de destino quede escrita
por completo. La operaci√≥n de copia se realiza por orden ascendente de direcciones.
Las √°reas de origen y destino se definen mediante VARIANT.
Nota
Las variables de la instrucci√≥n solo se pueden usar en las √°reas de memoria en las que no est√©
activado el atributo "Acceso optimizado al bloque". Esto es v√°lido para bloques de datos (DB),
bloques de organizaci√≥n (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucci√≥n se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable tambi√©n se puede usar en √°reas de memoria "con acceso
optimizado al bloque".
Para los bloques con el atributo "Acceso optimizado al bloque" puede utilizarse la instrucci√≥n
"FILL_BLK: Rellenar √°rea".
La figura siguiente muestra el principio de la operaci√≥n de copia:
),//

%9$/

$

%

0:

$

%

0:

&

'

0:

&

'

0:

(

)

0:

(

)

0:

*

+

0:

*

+

0:

$

%

0:

&

'

0:

(

)

0:

*

+

0:

$

%

0:

&

'

0:

%/.

Ejemplo: el contenido del √°rea MW100 a MW118 debe inicializarse con el contenido de las
palabras de marcas MW14 a MW20.

2132

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Coherencia de los datos de origen y destino
Tenga en cuenta que al ejecutar la instrucci√≥n "Rellenar √°rea" no se modifican los datos de
origen, pues de lo contrario no se podr√≠a garantizar la coherencia de los datos de destino.

√Åreas de memoria
La instrucci√≥n "Rellenar √°rea" permite copiar las siguientes √°reas de memoria:
‚óè √Åreas de un bloque de datos
‚óè Marcas
‚óè Memoria imagen de proceso de las entradas
‚óè Memoria imagen de proceso de las salidas

Reglas generales para copiar
Las √°reas de origen y destino no deben solaparse. Aunque el √°rea de destino que se debe
inicializar no sea m√∫ltiplo entero de la longitud del par√°metro de entrada BVAL, el √°rea de
destino se rellenar√° igualmente hasta el √∫ltimo byte.
Si el √°rea de destino que se debe preasignar es menor que el √°rea de origen, solo se copian
los datos que caben en el √°rea de destino.
Si el √°rea de destino o de origen disponible realmente es menor que el tama√±o del √°rea de
memoria parametrizada para el √°rea de origen o destino (par√°metros BVAL, BLK), los datos no
se transfieren.
Si el puntero ANY (origen o destino) es del tipo de datos BOOL, debe direccionarse de forma
absoluta y la longitud indicada del √°rea debe ser un m√∫ltiplo de 8, pues de lo contrario no se
ejecutar√° la instrucci√≥n.
Si el √°rea de destino es del tipo de datos STRING, la instrucci√≥n escribe la cadena de
caracteres completa, incluida la informaci√≥n de administraci√≥n.

Reglas para copiar estructuras
Al indicar una estructura a modo de par√°metro de entrada, tenga en cuenta que la longitud de
una estructura se rige siempre por un n√∫mero entero de bytes. Si se declara una estructura con
un n√∫mero impar de bytes, esta estructura necesita un byte adicional de espacio en memoria.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2133

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

BVAL

Input

VARIANT

I, Q, M, D, L, P

Indicaci√≥n del √°rea de memo‚Äê
ria (√°rea de origen) con cuyo
contenido se rellena el √°rea
de destino en el par√°metro
BLK.

RET_VAL

Output

INT

I, Q, M, D, L, P

Informaci√≥n de error:
El par√°metro RET_VAL de‚Äê
vuelve un c√≥digo de error
cuando se produce un error
durante la ejecuci√≥n de la ins‚Äê
trucci√≥n.

BLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicaci√≥n del √°rea de memo‚Äê
ria que se rellena con el con‚Äê
tenido del √°rea de origen.

1) El par√°metro BLK est√° declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse en la interfaz del bloque como InOut.

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

8092

El √°rea de origen o destino est√° solo en la memoria de carga.

8152

En el par√°metro BVAL no se soportan los tipos de datos WSTRING, WCHAR, BOOL
y ARRAY of STRING.

8352

En el par√°metro BLK no se soportan los tipos de datos WSTRING, WCHAR, BOOL y
ARRAY of STRING.

Informaci√≥n de
error general

Consulte tambi√©n: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL FILL VARIANT
(BVAL := P#M14.0 WORD 4
RET_VAL => "Tag_ErrorCode"
BLK => P#M100.0 WORD 10

2134

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
GRAPH
)

La instrucci√≥n copia el √°rea de origen de MW14 a MW20 y rellena el √°rea de destino de MW100
a MW118 con el contenido de las 4 palabras contenidas en el √°rea de memoria del par√°metro
BVAL.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
GET_ERR_ID: Consultar ID de error localmente (P√°gina 2159)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Principios b√°sicos de GRAPH (P√°gina 8191)

Conversi√≥n
CONVERT: Convertir valor
Descripci√≥n
La instrucci√≥n "Convertir valor" lee el contenido del operando y lo convierte seg√∫n los tipos de
datos parametrizados.
Encontrar√° informaci√≥n relacionada con las conversiones posibles en el apartado "Conversi√≥n
expl√≠cita" de "Consulte tambi√©n".
El valor del resultado no es v√°lido si se producen errores durante la ejecuci√≥n, p. ej. un
desbordamiento.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros binarios,
enteros, n√∫meros
en coma flotante,
CHAR, WCHAR,
BCD16, BCD32

I, Q, M, D, L, P o
constante

Valor que se convierte.

<Resultado>

Output

N√∫meros binarios,
enteros, n√∫meros
en coma flotante,
CHAR, WCHAR,
BCD16, BCD32

I, Q, M, D, L, P

Resultado de la conversi√≥n

En las listas desplegables "???" puede seleccionar los tipos de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2135

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := INT_TO_DINT("Tag_InValue")

El contenido del operando "Tag_InValue" se lee y se convierte en un entero (32 bits). El
resultado se deposita en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)
Conversiones expl√≠citas (P√°gina 422)

ROUND: Redondear n√∫mero
Descripci√≥n
La instrucci√≥n "Redondear n√∫mero" permite redondear el valor del operando al siguiente
n√∫mero entero. La instrucci√≥n interpreta el valor como n√∫mero en coma flotante y lo convierte
al n√∫mero entero m√°s pr√≥ximo. Si en el valor de entrada se encuentra entre un n√∫mero par y
uno impar, se selecciona el n√∫mero par.
El valor del resultado no es v√°lido si se producen errores durante la ejecuci√≥n, p. ej. un
desbordamiento.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada que se re‚Äê
dondea.

<Resultado>

Output

Enteros, n√∫meros
en coma flotante

I, Q, M, D, L, P

Resultado del redondeo

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := ROUND("Tag_InValue")

2136

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1.50000000

-1.50000000

Tag_OutValue

2

-2

El n√∫mero en coma flotante del operando "Tag_InValue" se redondea al n√∫mero entero par
m√°s pr√≥ximo y se indica en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

CEIL: Redondear un n√∫mero en coma flotante al siguiente entero superior
Descripci√≥n
La instrucci√≥n "Redondear un n√∫mero en coma flotante al siguiente entero superior" permite
redondear el valor del operando al siguiente n√∫mero entero superior. La instrucci√≥n interpreta
el valor como n√∫mero en coma flotante y lo convierte al siguiente n√∫mero entero superior. El
resultado puede ser mayor o igual que el valor de entrada.
El valor del resultado no es v√°lido si se producen errores durante la ejecuci√≥n, p. ej. un
desbordamiento.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada como n√∫me‚Äê
ro en coma flotante

<Resultado>

Output

Enteros, n√∫meros
en coma flotante

I, Q, M, D, L, P

Resultado con el siguiente
entero superior

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := CEIL("Tag_InValue")

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2137

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

0.50000000

-0.50000000

Tag_OutValue

1

0

El n√∫mero en coma flotante del operando "Tag_InValue" se redondea al siguiente n√∫mero
entero superior y se indica en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

FLOOR: Redondear un n√∫mero en coma flotante al siguiente entero inferior
Descripci√≥n
La instrucci√≥n "Redondear un n√∫mero en coma flotante al siguiente entero inferior" permite
redondear el valor del operando al siguiente n√∫mero entero inferior. La instrucci√≥n interpreta
el valor como n√∫mero en coma flotante y lo convierte al siguiente n√∫mero entero inferior. El
resultado puede ser menor o igual que el valor de entrada.
El valor del resultado no es v√°lido si se producen errores durante la ejecuci√≥n, p. ej. un
desbordamiento.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L, P o
constante

Valor de entrada como n√∫me‚Äê
ro en coma flotante

<Resultado>

Output

Enteros, n√∫meros
en coma flotante

I, Q, M, D, L, P

Resultado con el siguiente
entero inferior

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := FLOOR("Tag_InValue")

2138

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

0.50000000

-0.50000000

Tag_OutValue

0

-1

El n√∫mero en coma flotante del operando "Tag_InValue" se redondea al siguiente n√∫mero
entero inferior y se indica en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

TRUNC: Truncar a entero
Descripci√≥n
La instrucci√≥n "Truncar a entero" permite generar un n√∫mero entero a partir del valor del
operando. El valor se interpreta como n√∫mero en coma flotante. La instrucci√≥n selecciona solo
la parte entera del n√∫mero en coma flotante y la indica sin decimales como resultado.
El valor del resultado no es v√°lido si se producen errores durante la ejecuci√≥n, p. ej. un
desbordamiento.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

N√∫meros en coma
flotante

I, Q, M, D, L o
constante

Valor de entrada como n√∫me‚Äê
ro en coma flotante

<Resultado>

Output

Enteros, n√∫meros
en coma flotante

I, Q, M, D, L

Resultado con la parte ente‚Äê
ra del n√∫mero en coma flo‚Äê
tante

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := TRUNC("Tag_InValue")

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2139

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1.50000000

-1.50000000

Tag_OutValue

1

-1

La parte entera del n√∫mero en coma flotante del operando "Tag_InValue" se convierte en un
n√∫mero entero y se indica en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

SCALE_X: Escalar
Descripci√≥n
La instrucci√≥n "Escalar" escala el valor del par√°metro VALUE mape√°ndolo en un determinado
rango de valores. Al ejecutar la instrucci√≥n, el n√∫mero en coma flotante del par√°metro VALUE
se escala al rango de valores definido por los par√°metros MIN y MAX. El resultado de la escala
es un n√∫mero entero que se deposita en la salida OUT.
La figura siguiente muestra un ejemplo de c√≥mo pueden escalarse los valores:

0$;
287
0,1



9$/8(

La instrucci√≥n "Escalar" utiliza la siguiente ecuaci√≥n:
OUT = [VALUE ‚àó (MAX ‚Äì MIN)] + MIN

2140

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El valor del resultado no es v√°lido si se cumple una de las siguientes condiciones:
‚óè El valor del par√°metro MIN es mayor o igual que el valor del par√°metro MAX.
‚óè El valor de un n√∫mero en coma flotante indicado est√° fuera del rango de los n√∫meros
normalizados seg√∫n IEEE-754.
‚óè Ocurre un rebase por exceso.
‚óè El valor del par√°metro VALUE es NaN (Not a number = resultado de una operaci√≥n
aritm√©tica no v√°lida).
Nota
Encontrar√° m√°s informaci√≥n sobre la conversi√≥n de valores anal√≥gicos en el manual de
producto correspondiente.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

MIN

Input

Enteros, n√∫meros
en coma flotante

I, Q, M, D, L o
constante

L√≠mite inferior del rango de
valores

VALUE

Input

N√∫meros en coma
flotante

I, Q, M, D, L o
constante

Valor que se escala.
Si se indica una constante,
esta debe declararse.

MAX

Input

Enteros, n√∫meros
en coma flotante

I, Q, M, D, L o
constante

L√≠mite superior del rango de
valores

RET_VAL

Output

Enteros, n√∫meros
en coma flotante

I, Q, M, D, L

Resultado de la escala

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL SCALE_X INT_REAL
(MIN := "Tag_Minimum"
VALUE := "Tag_Value"
MAX := "Tag_Maximum"
RET_VAL => "Tag_OutputValue"
)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2141

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

MIN

Tag_Minimum

10

VALUE

Tag_Value

0.5

MAX

Tag_Maximum

30

RET_VAL

Tag_ReturnValue

20

El valor del par√°metro "Tag_Value" se escala al rango de valores definido por los valores de los
par√°metros "Tag_Minimum" y "Tag_Maximum". El resultado se deposita en el par√°metro
"Tag_ReturnValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de GRAPH (P√°gina 8191)

NORM_X: Normalizar
Descripci√≥n
La instrucci√≥n "Normalizar" permite normalizar el valor del par√°metro VALUE mape√°ndolo en
una escala lineal. Los par√°metros MIN y MAX sirven para definir los l√≠mites de un rango de
valores que se refleja en la escala. En funci√≥n de la posici√≥n del valor que se debe normalizar
en este rango de valores, el resultado se calcula y se deposita como n√∫mero en coma flotante
en el par√°metro OUT. Si el valor que se debe normalizar es igual al valor del par√°metro MIN,
el par√°metro OUT devuelve el valor "0.0". Si el valor que se debe normalizar es igual al valor
del par√°metro MAX, el par√°metro OUT devuelve el valor "1.0".
La figura siguiente muestra un ejemplo de c√≥mo pueden normalizarse los valores:

2142

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones


287

0,1

0$;
9$/8(

La instrucci√≥n "Normalizar" utiliza la siguiente ecuaci√≥n:
OUT = (VALUE ‚Äì MIN) / (MAX ‚Äì MIN)
El valor del resultado no es v√°lido si se cumple una de las siguientes condiciones:
‚óè El valor del par√°metro MIN es mayor o igual que el valor del par√°metro MAX.
‚óè El valor de un n√∫mero en coma flotante indicado est√° fuera del rango de los n√∫meros
normalizados seg√∫n IEEE-754.
‚óè Ocurre un rebase por exceso.
‚óè El valor del par√°metro VALUE es NaN (Not a number = resultado de una operaci√≥n
aritm√©tica no v√°lida).
Nota
Encontrar√° m√°s informaci√≥n sobre la conversi√≥n de valores anal√≥gicos en el manual de
producto correspondiente.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

MIN

Input

Enteros, n√∫meros
en coma flotante

I, Q, M, D, L o
constante

L√≠mite inferior del rango de
valores

VALUE 1)

Input

Enteros, n√∫meros
en coma flotante

I, Q, M, D, L o
constante

Valor que se normaliza

MAX 1)

Input

Enteros, n√∫meros
en coma flotante

I, Q, M, D, L o
constante

L√≠mite superior del rango de
valores

1)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2143

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

RET_VAL

Output

N√∫meros en coma
flotante

I, Q, M, D, L

Resultado de la normaliza‚Äê
ci√≥n

1)

Si se utilizan constantes en estos tres par√°metros, basta con declarar una de ellas.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".
Encontrar√° m√°s informaci√≥n sobre la declaraci√≥n de constantes en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL NORM_X INT_REAL
(MIN := "Tag_Minimum"
VALUE := "Tag_Value"
MAX := "Tag_Maximum"
RET_VAL => "Tag_OutputValue"
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

Valor

MIN

Tag_Minimum

10

VALUE

Tag_Value

20

MAX

Tag_Maximum

30

RET_VAL

Tag_ReturnValue

0.5

El valor del par√°metro "Tag_Value" se asigna al rango de valores definido por los valores de
los par√°metros "Tag_Minimum" y "Tag_Maximum". El valor de la variable del par√°metro
"Tag_Value" se normaliza conforme al rango de valores definido. El resultado se deposita
como n√∫mero en coma flotante en el par√°metro "Tag_ReturnValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de GRAPH (P√°gina 8191)

2144

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Legacy
SCALE: Escalar
Descripci√≥n
La instrucci√≥n "Escalar" convierte el entero del par√°metro IN en un n√∫mero en coma flotante
que se escala en unidades f√≠sicas entre un l√≠mite inferior y uno superior. Los l√≠mites inferior y
superior del rango de valores en el que se escala el valor de entrada se definen mediante los
par√°metros LO_LIM y HI_LIM. El resultado de la instrucci√≥n se devuelve en el par√°metro OUT.
La instrucci√≥n "Escalar" utiliza la siguiente ecuaci√≥n:
OUT = [((FLOAT (IN) ‚Äì K1)/(K2‚ÄìK1)) ‚àó (HI_LIM‚ÄìLO_LIM)] + LO_LIM
El estado l√≥gico del par√°metro BIPOLAR determina los valores de las constantes "K1" y "K2".
El par√°metro BIPOLAR puede tener los siguientes estados l√≥gicos:
‚óè Estado l√≥gico "1": Se presupone que el valor del par√°metro IN es bipolar y est√°
comprendido en un rango de valores entre -27 648 y 27 648. En este caso, la constante "K1"
tiene el valor "-27 648,0", y la constante "K2", el valor "+27 648,0".
‚óè Estado l√≥gico "0": Se presupone que el valor del par√°metro IN es unipolar y est√°
comprendido en un rango de valores entre 0 y 27 648. En este caso, la constante "K1" tiene
el valor "0,0", y la constante "K2", el valor "+27 648,0".
Si el valor del par√°metro IN es mayor que el de la constante "K2", el resultado de la instrucci√≥n
se pone al valor del l√≠mite superior (HI_LIM) y se emite un error.
Si el valor del par√°metro IN es menor que el de la constante "K1", el resultado de la instrucci√≥n
se pone al valor del l√≠mite inferior (LO_LIM) y se emite un error.
Si el l√≠mite inferior indicado es mayor que el l√≠mite superior (LO_LIM > HI_LIM), el resultado se
escala de forma inversamente proporcional al valor de entrada.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

INT

I, Q, M, D, L, P o
constante

Valor de entrada
que se escala.

HI_LIM

Input

REAL

I, Q, M, D, L, P o
constante

Valor l√≠mite supe‚Äê
rior

LO_LIM

Input

REAL

I, Q, M, D, L, P o
constante

Valor l√≠mite inferior

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2145

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

BIPOLAR

Input

BOOL

I, Q, M, D, L o
constante

Indica si el valor
del par√°metro IN
se interpreta como
bipolar o unipolar.
El par√°metro pue‚Äê
de adoptar los va‚Äê
lores siguientes:
1: Bipolar
0: Unipolar

RET_VAL

Output

WORD

I, Q, M, D, L, P

Informaci√≥n de
error

OUT

Output

REAL

I, Q, M, D, L, P

Resultado de la
instrucci√≥n

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

0008

El valor del par√°metro IN es mayor que el de la constante "K2" o menor que el de la
constante "K1".

Informaci√≥n
de error ge‚Äê
neral

Consulte tambi√©n: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL SCALE
(IN := "Tag_InputValue"
HI_LIM := "Tag_HighLimit"
LO_LIM := "Tag_LowLimit"
BIPOLAR := "Tag_Bipolar"
RET_VAL => "Tag_ErrorCode"
OUT => "Tag_OutputValue"
)

2146

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra los valores de los distintos operandos antes de ejecutar la
instrucci√≥n:
Par√°metro

Operando

Valor

IN

Tag_InputValue

22

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

RET_VAL

Tag_ErrorCode

W#16#0000

OUT

Tag_OutputValue

0.0

La tabla siguiente muestra los valores de los distintos operandos despu√©s de ejecutar la
instrucci√≥n:
Par√°metro

Operando

Valor

IN

Tag_InputValue

22

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

RET_VAL

Tag_ErrorCode

W#16#0000

OUT

Tag_OutputValue

50.03978588

En el operando "Tag_InputValue" se indica el valor que debe convertirse y escalarse. El valor
l√≠mite superior y el inferior se definen mediante los operandos "Tag_HighLimit" y
"Tag_LowLimit". Con ayuda del operando "Tag_Bipolar" = TRUE se indica que el valor del
par√°metro IN debe interpretarse como bipolar. En el operando "Tag_OutputValue" se indica el
resultado de la instrucci√≥n.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
GET_ERR_ID: Consultar ID de error localmente (P√°gina 2159)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de GRAPH (P√°gina 8191)

UNSCALE: Desescalar
Descripci√≥n
La instrucci√≥n "Desescalar" permite desescalar el n√∫mero en coma flotante del par√°metro IN
en unidades f√≠sicas comprendidas entre un l√≠mite inferior y uno superior y convertirlo en un
n√∫mero entero. Los l√≠mites inferior y superior del rango de valores en el que se desescala el
valor de entrada se definen mediante los par√°metros LO_LIM y HI_LIM. El resultado de la
instrucci√≥n se devuelve en el par√°metro OUT.
La instrucci√≥n "Desescalar" utiliza la siguiente ecuaci√≥n:

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2147

Instrucciones
4.1 Instrucciones
OUT = [((IN‚ÄìLO_LIM)/(HI_LIM‚ÄìLO_LIM)) ‚àó (K2‚ÄìK1) ] + K1
El estado l√≥gico del par√°metro BIPOLAR determina los valores de las constantes "K1" y "K2".
El par√°metro BIPOLAR puede tener los siguientes estados l√≥gicos:
‚óè Estado l√≥gico "1": Se presupone que el valor del par√°metro IN es bipolar y est√°
comprendido en un rango de valores entre -27 648 y 27 648. En este caso, la constante "K1"
tiene el valor "-27 648,0", y la constante "K2", el valor "+27 648,0".
‚óè Estado l√≥gico "0": Se presupone que el valor del par√°metro IN es unipolar y est√°
comprendido en un rango de valores entre 0 y 27 648. En este caso, la constante "K1" tiene
el valor "0,0", y la constante "K2", el valor "+27 648,0".
Si el valor del par√°metro IN no se encuentra dentro de los l√≠mites definidos por HI_LIM y
LO_LIM, se emite un error. El resultado se ajusta al l√≠mite m√°s pr√≥ximo.
Si el l√≠mite inferior indicado es mayor que el l√≠mite superior (LO_LIM > HI_LIM), el resultado se
escala de forma inversamente proporcional al valor de entrada.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

REAL

I, Q, M, D, L, P o
constante

Valor de entrada
que se desescala
en un valor entero.

HI_LIM

Input

REAL

I, Q, M, D, L, P o
constante

Valor l√≠mite supe‚Äê
rior

LO_LIM

Input

REAL

I, Q, M, D, L, P o
constante

Valor l√≠mite inferior

BIPOLAR

Input

BOOL

I, Q, M, D, L o
constante

Indica si el valor
del par√°metro IN
se interpreta como
bipolar o unipolar.
El par√°metro pue‚Äê
de adoptar los va‚Äê
lores siguientes:
1: Bipolar
0: Unipolar

2148

RET_VAL

Output

WORD

I, Q, M, D, L, P

Informaci√≥n de
error

OUT

Output

INT

I, Q, M, D, L, P

Resultado de la
instrucci√≥n

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error
(W#16#....)

Explicaci√≥n

0000

Ning√∫n error

0008

El valor del par√°metro IN es mayor que el del l√≠mite superior (HI_LIM) o menor que el del
l√≠mite inferior (LO_LIM).

Informaci√≥n
de error ge‚Äê
neral

Consulte tambi√©n: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n aqu√≠: Cambiar
formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL UNSCALE
(IN := "Tag_InputValue"
HI_LIM := "Tag_HighLimit"
LO_LIM := "Tag_LowLimit"
BIPOLAR := "Tag_Bipolar"
RET_VAL => "Tag_ErrorCode"
OUT => "Tag_OutputValue"
)

La tabla siguiente muestra los valores de los distintos operandos antes de ejecutar la
instrucci√≥n:
Par√°metro

Operando

Valor

IN

Tag_InputValue

50.03978588

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

RET_VAL

Tag_ErrorCode

W#16#0000

OUT

Tag_OutputValue

0.0

La tabla siguiente muestra los valores de los distintos operandos despu√©s de ejecutar la
instrucci√≥n:
Par√°metro

Operando

Valor

IN

Tag_InputValue

50.03978588

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2149

Instrucciones
4.1 Instrucciones
Par√°metro

Operando

Valor

BIPOLAR

Tag_Bipolar

1

RET_VAL

Tag_ErrorCode

W#16#0000

OUT

Tag_OutputValue

22

En el operando "Tag_InputValue" se indica el valor que debe convertirse y desescalarse. El
valor l√≠mite superior y el inferior se definen mediante los operandos "Tag_HighLimit" y
"Tag_LowLimit". Con ayuda del operando "Tag_Bipolar" = TRUE se indica que el valor del
par√°metro IN debe interpretarse como bipolar. En el operando "Tag_OutputValue" se indica el
resultado de la instrucci√≥n.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
GET_ERR_ID: Consultar ID de error localmente (P√°gina 2159)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Principios b√°sicos de GRAPH (P√°gina 8191)

Control del programa
Control del tiempo de ejecuci√≥n
ENDIS_PW: Limitar y habilitar legitimaci√≥n de la contrase√±a
Descripci√≥n
La instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a" permite definir si las
contrase√±as configuradas para la CPU est√°n legitimadas o no. Con ello, se pueden impedir
conexiones legitimadas, aun conociendo la contrase√±a correcta.
Si llama la instrucci√≥n y el par√°metro REQ tiene el estado l√≥gico "0", en los par√°metros de
salida se muestra el estado ajustado en ese momento. Si se han realizado cambios en los
par√°metros de entrada, estos no se transfieren a los par√°metros de salida.
Si se ejecuta la instrucci√≥n y el par√°metro REQ tiene el estado l√≥gico "1", se aplica el estado
l√≥gico de los par√°metros de entrada (F_PWD, FULL_PWD, R_PWD, HMI_PWD):
‚óè Si se tiene el estado l√≥gico "0", no est√° permitida la legitimaci√≥n por contrase√±a.
‚óè Si se tiene el estado l√≥gico "1", se puede utilizar la contrase√±a.
Es posible permitir o prohibir individualmente el bloqueo o la habilitaci√≥n de las contrase√±as.
Por ejemplo, pueden prohibirse todas las contrase√±as excepto la contrase√±a de seguridad.
Esto permite limitar las posibilidades de acceso a un reducido grupo de usuarios. Los
par√°metros de salida (F_PWD_ON, FULL_PWD_ON, R_PWD_ON, HMI_PWD_ON) siempre
muestran el estado actual del uso de contrase√±as, independientemente del par√°metro REQ.
Las contrase√±as no configuradas deben tener en la entrada el estado l√≥gico TRUE y devolver
el estado l√≥gico TRUE en la salida. La contrase√±a de seguridad positiva (fail-safe) solo se

2150

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
puede parametrizar para una CPU F y por eso en una CPU est√°ndar debe interconectarse
siempre con el estado l√≥gico TRUE. Si la instrucci√≥n devuelve un error, la llamada permanece
sin efecto, es decir, el bloqueo anterior sigue en vigor.
Las contrase√±as bloqueadas pueden volver a habilitarse en las condiciones siguientes:
‚óè Se ha restablecido la configuraci√≥n de f√°brica de la CPU.
‚óè El panel frontal de la CPU S7-1500 soporta un cuadro de di√°logo que permite navegar al
men√∫ adecuado y volver a habilitar las contrase√±as.
‚óè Cuando se llama la instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a", el
par√°metro de entrada de la contrase√±a deseada tiene el estado l√≥gico "1".
‚óè Ponga el selector de modo a STOP. La restricci√≥n de la legitimaci√≥n de contrase√±a se
activa de nuevo en cuanto se mueve el selector nuevamente a RUN.
‚óè La inserci√≥n de una tarjeta de memoria vac√≠a (tarjeta de transferencia o tarjeta de
programa) en una CPU S7-1200.
‚óè La transici√≥n de POWER OFF-POWER ON desactiva la protecci√≥n en la CPU S7-1200. La
instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a" debe volverse a llamar en el
programa (por ejemplo en el OB de arranque).
Nota
Si la contrase√±a HMI no est√° habilitada, la instrucci√≥n "Limitar y habilitar legitimaci√≥n de la
contrase√±a" bloquea el acceso de los sistemas HMI.
Nota
Las conexiones ya existentes y legitimadas conservan sus derechos de acceso y no pueden
limitarse con la instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a".

Impedir el bloqueo no intencionado en una CPU S7-1500
Los ajustes pueden realizarse en el panel frontal de la CPU, que guarda el √∫ltimo ajuste en
cada caso.
Para impedir un bloqueo no intencionado, en una CPU S7-1500 es posible desactivar la
protecci√≥n moviendo el selector de modo a STOP. La protecci√≥n se activa autom√°ticamente
despu√©s de mover el selector de modo a RUN sin que tenga que volver a llamarse la
instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a" o deban realizarse otras acciones
en el panel frontal.

Impedir el bloqueo no intencionado en una CPU S7-1200
Como la CPU S7-1200 no dispone de selector de modo, la protecci√≥n se desactiva con
POWER OFF-POWER ON. De este modo es posible y recomendable impedir el bloqueo no
intencionado con ayuda de determinadas secuencias en el programa.
Para ello, programe un control de tiempo, ya sea mediante un OB de alarma c√≠clica o un
temporizador en el Main OB (OB 1). De este modo, tras una transici√≥n de POWER OFFPOWER ON y la consiguiente desactivaci√≥n de la protecci√≥n, se puede volver a llamar
r√°pidamente la instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a" en el OB
Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2151

Instrucciones
4.1 Instrucciones
correspondiente (por ejemplo OB 1 u OB 35). Para que la ventana temporal en la que la
instrucci√≥n no est√° activa y en la que por tanto no existen limitaciones en la legitimaci√≥n de la
contrase√±a sea lo m√°s peque√±a posible, llame la instrucci√≥n en el OB de arranque (OB 100).
Este procedimiento ofrece la mayor protecci√≥n posible contra accesos no autorizados.
Si se ha producido un bloqueo no intencionado puede omitirse la llamada en el OB de arranque
(por ejemplo mediante la consulta de un par√°metro de entrada) y se dispondr√° del tiempo
configurado (por ejemplo de 10 segundos a 1 minuto) para establecer una conexi√≥n con la
CPU antes de que el bloqueo vuelva a activarse.
Si no se ha previsto ning√∫n temporizador en el c√≥digo del programa y se produce un bloqueo,
inserte en la CPU una tarjeta de transferencia o una tarjeta de programa vac√≠a. La tarjeta de
transferencia o la tarjeta de programa vac√≠a borra la memoria de carga interna de la CPU.
Despu√©s deber√° cargarse nuevamente el programa de usuario de STEP 7 en la CPU.

Procedimiento en caso de p√©rdida de contrase√±a en una CPU S7-1200
Si ha perdido la contrase√±a de una CPU S7-1200 protegida por contrase√±a, borre el programa
protegido por contrase√±a con una tarjeta de transferencia o una tarjeta de programa vac√≠a. La
tarjeta de transferencia o la tarjeta de programa vac√≠a borra la memoria de carga interna de la
CPU. A continuaci√≥n, puede transferir un nuevo programa de usuario de STEP 7 Basic a la
CPU.
ADVERTENCIA
Inserci√≥n de una tarjeta de transferencia vac√≠a
Cuando se inserta una tarjeta de transferencia en una CPU en funcionamiento, la CPU pasa
a STOP. En caso de estados operativos no seguros, los controladores pueden fallar y, con
ello, provocar un funcionamiento descontrolado de los dispositivos que se controlan. El
resultado es un funcionamiento impredecible del sistema de automatizaci√≥n, que puede
provocar lesiones mortales o graves, as√≠ como da√±os materiales.
El contenido de la tarjeta de transferencia se encuentra en la memoria de carga interna
despu√©s de su extracci√≥n. Compruebe aqu√≠ que la tarjeta no contenga ning√∫n programa.
ADVERTENCIA
Inserci√≥n de una tarjeta de programa vac√≠a
Cuando se inserta una tarjeta de programa en una CPU en funcionamiento, la CPU pasa a
STOP. En caso de estados operativos no seguros, los controladores pueden fallar y, con ello,
provocar un funcionamiento descontrolado de los dispositivos que se controlan. El resultado
es un funcionamiento impredecible del sistema de automatizaci√≥n, que puede provocar
lesiones mortales o graves, as√≠ como da√±os materiales.
Aseg√∫rese de que la tarjeta de programa est√© vac√≠a. La memoria de carga interna se copiar√°
en la tarjeta de programa vac√≠a. Despu√©s de retirar la tarjeta de programa previamente vac√≠a,
la memoria de carga interna quedar√° vac√≠a.
Debe retirarse la tarjeta de transferencia o la tarjeta de programa antes de poner la CPU en
RUN.

2152

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Efectos del uso de contrase√±as en los modos de operaci√≥n
La siguiente tabla muestra qu√© efectos tiene el uso de contrase√±as en los modos de operaci√≥n
y en las respectivas acciones del usuario mediante la instrucci√≥n "Limitar y habilitar
legitimaci√≥n de la contrase√±a".
Acci√≥n

Protecci√≥n por contrase√±a mediante la instruc‚Äê
ci√≥n

Estado b√°sico despu√©s de

No activado

‚óè Selector de modo en STOP

(sin limitaciones)

‚óè Restablecimiento manual de la memoria (PG,
interruptor, cambio de MC (Motion Control))
‚óè Restablecimiento de la configuraci√≥n de f√°brica
Estado b√°sico tras conexi√≥n (POWER ON)

‚óè CPU S7-1200:
El bloqueo est√° desactivado y la
instrucci√≥n tiene que volverse a ejecutar
en el programa (por ejemplo en el OB de
arranque).
‚óè CPU S7-1500:
Activada (si antes de la desconexi√≥n
(POWER OFF) hab√≠a un bloqueo activo)
La posibilidad de no permitir contrase√±as
es remanente.

Activado
Transici√≥n del estado operativo RUN/ARRANQUE/
PARADA -> STOP (mediante finalizaci√≥n de la ins‚Äê
Las contrase√±as siguen sin poder utilizarse.
trucci√≥n, un error o comunicaci√≥n) o STOP -> ARRAN‚Äê
QUE/RUN/PARADA

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

REQ

Input

BOOL

I, Q, M, D, L o
constante

Si el par√°metro REQ tiene el
estado l√≥gico "0", se consulta
el estado l√≥gico ajustado ac‚Äê
tualmente para las contrase‚Äê
√±as.

F_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura/escritura
incluido failsafe
‚óè F_PWD = "0": No permitir
contrase√±a
‚óè F_PWD = "1": Permitir
contrase√±a

FULL_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura/escritura
‚óè FULL_PWD = "0": No
permitir contrase√±a
‚óè FULL_PWD = "1":
Permitir contrase√±a

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2153

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

R_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura
‚óè R_PWD = "0": No permitir
contrase√±a
‚óè R_PWD = "1": Permitir
contrase√±a

HMI_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso a la HMI
‚óè HMI_PWD = "0": No
permitir contrase√±a
‚óè HMI_PWD = "1": Permitir
contrase√±a

F_PWD_ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura/
escritura incluido failsafe
‚óè F_PWD_ON = "0":
Contrase√±a no permitida
‚óè F_PWD_ON = "1":
Contrase√±a permitida

FULL_PWD_
ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura/
escritura
‚óè FULL_PWD_ON = "0":
Contrase√±a no permitida
‚óè FULL_PWD_ON = "1":
Contrase√±a permitida

R_PWD_ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura
‚óè R_PWD_ON = "0":
Contrase√±a no permitida
‚óè R_PWD_ON = "1":
Contrase√±a permitida

HMI_PWD_O Output
N

BOOL

I, Q, M, D, L

Estado del acceso a la HMI
‚óè HMI_PWD_ON = "0":
Contrase√±a no permitida
‚óè HMI_PWD_ON = "1":
Contrase√±a permitida

RET_VAL

Output

WORD

I, Q, M, D, L

Informaci√≥n de error

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de
error*

Explicaci√≥n

(W#16#...)

2154

0000

Ning√∫n error

8090

No se soporta la instrucci√≥n "Limitar y habilitar legitimaci√≥n de la contrase√±a".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
C√≥digo de
error*

Explicaci√≥n

(W#16#...)
80D0

La contrase√±a de seguridad (fail-safe) no est√° configurada. En las CPU est√°ndar, el
estado l√≥gico tiene que ser TRUE.

80D1

El acceso de lectura/escritura no est√° configurado

80D2

El acceso de lectura no est√° configurado

80D3

El acceso HMI no est√° configurado

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de GRAPH (P√°gina 8191)

RE_TRIGR: Reiniciar tiempo de vigilancia del ciclo
Descripci√≥n
La instrucci√≥n "Reiniciar tiempo de vigilancia del ciclo" reinicia el tiempo de vigilancia del ciclo
de la CPU. El tiempo de vigilancia del ciclo se reinicia entonces con la duraci√≥n ajustada en la
configuraci√≥n de la CPU.
La instrucci√≥n se ejecuta correctamente durante un intervalo de tiempo (10 veces el ciclo
m√°ximo del programa), independientemente del n√∫mero de llamadas. Transcurrido ese
tiempo, el ciclo del programa ya no puede prolongarse.

Llamada de la instrucci√≥n
La instrucci√≥n puede llamarse en todos los bloques de organizaci√≥n, independientemente de
la prioridad.

Par√°metros
La instrucci√≥n "Reiniciar tiempo de vigilancia del ciclo" no tiene par√°metros y no devuelve
informaci√≥n de error.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de GRAPH (P√°gina 8191)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2155

Instrucciones
4.1 Instrucciones

STP: Finalizar programa
Descripci√≥n
La instrucci√≥n "Finalizar programa" conmuta la CPU al estado operativo STOP, con lo que se
finaliza la ejecuci√≥n del programa. Los efectos al conmutar de RUN a STOP dependen de la
configuraci√≥n de la CPU.

Par√°metros
La instrucci√≥n "Finalizar programa" no tiene par√°metros y no devuelve informaci√≥n de error.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de GRAPH (P√°gina 8191)

GET_ERROR: Consultar error localmente
Descripci√≥n
La instrucci√≥n "Consultar error localmente" consulta si se han producido errores en un bloque
de programa. Suele tratarse de un error de programaci√≥n o de acceso. Si el sistema notifica
errores durante la ejecuci√≥n del bloque de programa, en el operando de la salida OUT se
guarda informaci√≥n detallada acerca del primer error de ejecuci√≥n ocurrido desde la √∫ltima vez
que se ejecut√≥ la instrucci√≥n.
En la salida OUT solo pueden especificarse operandos del tipo de datos de sistema
"ErrorStruct". El tipo de datos de sistema "ErrorStruct" especifica la estructura exacta con la
que debe guardarse la informaci√≥n acerca del error que ha ocurrido. Con ayuda de otras
instrucciones se puede evaluar esta estructura y programar la reacci√≥n correspondiente. Si se
producen varios errores en el bloque de programa, la instrucci√≥n emitir√° informaci√≥n sobre el
siguiente error ocurrido solo tras haberse solucionado el primer error.
Nota
Salida OUT
La salida OUT solo se modifica si hay una informaci√≥n de error. Para volver a poner la salida
a "0" tras tratar un error existen las siguientes posibilidades:
‚óè Declare la variable en la secci√≥n "Temp" de la interfaz de bloque.
‚óè Ponga la variable de nuevo a "0" antes de llamar la instrucci√≥n.
Nota
Activaci√≥n del tratamiento local de errores
En cuanto se inserta la instrucci√≥n en el c√≥digo de un bloque de programa, se activa el
tratamiento local de errores y se ignoran las reacciones preajustadas del sistema cuando se
producen errores.

2156

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Posibilidades del tratamiento de errores
Este apartado proporciona una visi√≥n general de las posibilidades del tratamiento de
errores: Sinopsis de los mecanismos para el tratamiento de errores (P√°gina 149)
Encontrar√° un ejemplo exhaustivo del tratamiento local de errores con varias posibilidades
aqu√≠: Ejemplo de tratamiento de errores de ejecuci√≥n del programa (P√°gina 180)

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

OUT

Output

ErrorStruct

D, L

Informaci√≥n de
error

Tipo de datos "ErrorStruct"
El tipo de datos "ErrorStruct" se puede insertar en un bloque de datos global o en la interfaz del
bloque. Tambi√©n se puede insertar el tipo de datos varias veces siempre que se asigne cada
vez un nombre distinto para la estructura de datos. La estructura de datos y el nombre de los
distintos elementos de la estructura no se pueden modificar. Si guarda la informaci√≥n del error
en un bloque de datos global, se podr√° leer desde otro bloque de programa.
La tabla siguiente muestra la estructura del tipo de datos "ErrorStruct":
Componente de estructura

Tipo de datos

Descripci√≥n

ERROR_ID

WORD

ID de error

FLAGS

BYTE

Muestra si el error se ha producido durante
la llamada de un bloque de programa.
16#01: error durante la llamada de un blo‚Äê
que de programa
16#00: no hay errores durante la llamada
de un bloque de programa

REACTION

BYTE

Reacci√≥n predeterminada:
0: ignorar (error de escritura)
1: continuar con el valor sustitutivo "0"
(error de lectura)
2: omitir instrucci√≥n (error de sistema)

CODE_ADDRESS
BLOCK_TYPE

CREF

Informaci√≥n sobre la direcci√≥n y el tipo del
bloque de programa

BYTE

Tipo de bloque de programa en el que se
ha producido el error:
1: bloque de organizaci√≥n (OB)
2: funci√≥n (FC)
3: bloque de funci√≥n (FB)

CB_NUMBER

UINT

N√∫mero del bloque l√≥gico

OFFSET

UDINT

Referencia a la memoria interna

BYTE

Informaci√≥n sobre la direcci√≥n de un ope‚Äê
rando

MODE

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2157

Instrucciones
4.1 Instrucciones
Componente de estructura

Tipo de datos

Descripci√≥n

OPERAND_NUMBER

UINT

N√∫mero de operando del comando de la
m√°quina

POINTER_NUMBER_LOCA‚Äê
TION

UINT

(A) Puntero interno

SLOT_NUMBER_SCOPE

UINT

(B) √Årea de almacenamiento en la memo‚Äê
ria interna

DATA_ADDRESS

NREF

Informaci√≥n sobre la direcci√≥n de un ope‚Äê
rando

BYTE

(C) √Årea de memoria:

AREA

L: 16#40...16#7F, 16#86, 16#87, 16#8E,
16#8F, 16#C0...16#FF
I: 16#81
Q: 16#82
M: 16#83
DB: 16#40, 16#84, 16#85, 16#8A, 16#8B
PI: 16#01
PQ: 16#02
Objetos tecnol√≥gicos: 16#04
DB_NUMBER

UINT

(D) N√∫mero del bloque de datos

OFFSET

UDINT

(E) Direcci√≥n relativa del operando

Componente de estructura "ERROR_ID"
La tabla siguiente muestra los valores que pueden devolverse en el componente de estructura
"ERROR_ID":

2158

ID*
(hexadecimal)

ID*
(decimal)

Descripci√≥n

0

0

Ning√∫n error

2503

9475

Puntero no v√°lido

2520

9504

STRING no v√°lido

2522

9506

Error de lectura: operando fuera del rango v√°lido

2523

9507

Error de escritura: operando fuera del rango v√°lido

2524

9508

Error de lectura: operando no v√°lido

2525

9509

Error de escritura: operando no v√°lido

2528

9512

Error de lectura: alineaci√≥n de datos

2529

9513

Error de escritura: alineaci√≥n de datos

252C

9516

Puntero no v√°lido

2530

9520

Error de escritura: bloque de datos

2533

9523

Referencia usada no v√°lida

2534

9524

Error de n√∫mero de bloque FC

2535

9525

Error de n√∫mero de bloque FB

2538

9528

Error de acceso: el DB no existe

2539

9529

Error de acceso: se ha utilizado un DB incorrecto

253A

9530

El bloque de datos global no existe

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
ID*
(hexadecimal)

ID*
(decimal)

Descripci√≥n

253C

9532

Indicaci√≥n err√≥nea o la funci√≥n no existe

253D

9533

La funci√≥n de sistema no existe

253E

9534

Indicaci√≥n err√≥nea o el bloque de funci√≥n no existe

253F

9535

El bloque de sistema no existe

2550

9552

Error de acceso: el DB no existe

2551

9553

Error de acceso: se ha utilizado un DB incorrecto

2575

9589

Error en la profundidad de anidamiento del programa

2576

9590

Error en la distribuci√≥n de datos locales

2577

9591

La propiedad de bloque "Alimentaci√≥n de par√°metros a trav√©s de
registros" no est√° activada.

25A0

9632

Error interno en TP

25A1

9633

Variable protegida contra escritura

25A2

9634

Valor num√©rico no v√°lido de la variable

2942

10562

Error de lectura: entrada

2943

10563

Error de escritura: salida

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Uso de las instrucciones GET_ERROR y GET_ERR_ID (P√°gina 178)
Principios b√°sicos de GRAPH (P√°gina 8191)

GET_ERR_ID: Consultar ID de error localmente
Descripci√≥n
La instrucci√≥n "Consultar ID de error localmente" consulta si se han producido errores en un
bloque. Suele tratarse de un error de acceso. Si al ejecutar el bloque el sistema notifica errores
de ejecuci√≥n desde que se ejecut√≥ la instrucci√≥n por √∫ltima vez, la ID de error del primer error
ocurrido se guarda en la variable de la salida RET_VAL.
En la salida RET_VAL solo pueden especificarse operandos del tipo de datos "WORD". Si se
producen varios errores en el bloque, la instrucci√≥n soluciona el primer error ocurrido, y solo
entonces la instrucci√≥n emite la ID de error del siguiente error ocurrido.
Nota
La salida RET_VAL solo se modifica si hay una informaci√≥n de error. Para volver a poner la
salida a "0" tras tratar un error existen las siguientes posibilidades:
‚óè Declare la variable en la secci√≥n "Temp" de la interfaz de bloque.
‚óè Ponga la variable de nuevo a "0" antes de llamar la instrucci√≥n.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2159

Instrucciones
4.1 Instrucciones
La salida de la instrucci√≥n "Consultar ID de error localmente" se activa √∫nicamente si existe
una informaci√≥n de error. Si no se cumple esta condici√≥n, el procesamiento ulterior del
programa no se ve afectado por la instrucci√≥n "Consultar ID de error localmente".
Encontrar√° un ejemplo sobre c√≥mo utilizar la instrucci√≥n en combinaci√≥n con otras
posibilidades de tratamiento de errores, en "Consulte tambi√©n".
Nota
La instrucci√≥n "Consultar ID de error localmente" activa el tratamiento local de errores dentro
del bloque. Si en la l√≥gica de un bloque se ha insertado la instrucci√≥n "Consultar ID de error
localmente", se ignoran las reacciones predeterminadas del sistema al ocurrir errores.

Posibilidades del tratamiento de errores
Este apartado proporciona una visi√≥n general de las posibilidades del tratamiento de
errores: Sinopsis de los mecanismos para el tratamiento de errores (P√°gina 149)
Encontrar√° un ejemplo exhaustivo del tratamiento local de errores con varias posibilidades
aqu√≠: Ejemplo de tratamiento de errores de ejecuci√≥n del programa (P√°gina 180)

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

RET_VAL

Output

WORD

I, Q, M, D, L

ID de error

Par√°metro RET_VAL
La tabla siguiente muestra los valores que pueden depositarse en el par√°metro RET_VAL:

2160

C√≥digo de error* C√≥digo de
(hexadecimal)
error*
(decimal)

Descripci√≥n

0

0

Ning√∫n error

2503

9475

Puntero no v√°lido

2520

9504

STRING no v√°lido

2522

9506

Error de lectura: operando fuera del rango v√°lido

2523

9507

Error de escritura: operando fuera del rango v√°lido

2524

9508

Error de lectura: operando no v√°lido

2525

9509

Error de escritura: operando no v√°lido

2528

9512

Error de lectura: alineaci√≥n de datos

2529

9513

Error de escritura: alineaci√≥n de datos

252C

9516

Puntero no v√°lido

2530

9520

Error de escritura: bloque de datos

2533

9523

Referencia usada no v√°lida

2534

9524

Error de n√∫mero de bloque FC

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
C√≥digo de error* C√≥digo de
(hexadecimal)
error*
(decimal)

Descripci√≥n

2535

9525

Error de n√∫mero de bloque FB

2538

9528

Error de acceso: el DB no existe

2539

9529

Error de acceso: se ha utilizado un DB incorrecto

253A

9530

El bloque de datos global no existe

253C

9532

Indicaci√≥n err√≥nea o la funci√≥n no existe

253D

9533

La funci√≥n de sistema no existe

253E

9534

Indicaci√≥n err√≥nea o el bloque de funci√≥n no existe

253F

9535

El bloque de sistema no existe

2550

9552

Error de acceso: el DB no existe

2551

9553

Error de acceso: se ha utilizado un DB incorrecto

2575

9589

Error en la profundidad de anidamiento del programa

2576

9590

Error en la distribuci√≥n de datos locales

2577

9591

La propiedad de bloque "Alimentaci√≥n de par√°metros a trav√©s de
registros" no est√° activada.

25A0

9632

Error interno en TP

25A1

9633

Variable protegida contra escritura

25A2

9634

Valor num√©rico no v√°lido de la variable

2942

10562

Error de lectura: entrada

2943

10563

Error de escritura: salida

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Uso de las instrucciones GET_ERROR y GET_ERR_ID (P√°gina 178)
Principios b√°sicos de GRAPH (P√°gina 8191)

INIT_RD: Inicializar todos los datos remanentes
Descripci√≥n
La instrucci√≥n "Inicializar todos los datos remanentes" permite inicializar todos los datos
remanentes de todos los bloques de datos, marcas y temporizadores y contadores SIMATIC
al mismo tiempo. La instrucci√≥n solo puede ejecutarse dentro de un OB de arranque, puesto
que su ejecuci√≥n exceder√≠a el tiempo de ciclo de programa.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2161

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

REQ

Input

BOOL

I, Q, M, D, L o
constante

Si la entrada REQ
devuelve el estado
l√≥gico "1", se ini‚Äê
cializan todos los
datos remanentes.

RET_VAL

Output

INT

I, Q, M, D, L

Informaci√≥n de
error:
El par√°metro
RET_VAL devuel‚Äê
ve un c√≥digo de
error cuando se
produce un error
durante la ejecu‚Äê
ci√≥n de la instruc‚Äê
ci√≥n.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Par√°metro RET_VAL
La tabla siguiente muestra el significado de los valores del par√°metro RET_VAL:
C√≥digo de error* Explicaci√≥n
(W#16#...)
0000

Ning√∫n error

80B5

No puede ejecutarse la instrucci√≥n porque no ha sido programada dentro de un OB de arranque.

Informaci√≥n de
error general

Consulte tambi√©n: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexadecimales. Encontrar√°
m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL INIT_RD
(REQ := "Tag_REQ"
RET_VAL => "Tag_RET_VAL"
)

Si el operando "Tag_REQ" devuelve el estado l√≥gico "1", se ejecuta la instrucci√≥n. Se
inicializan todos los datos remanentes de todos los bloques de datos, marcas y
temporizadores y contadores SIMATIC.

2162

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
GET_ERR_ID: Consultar ID de error localmente (P√°gina 2159)
Evaluaci√≥n de errores con el par√°metro de salida RET_VAL (P√°gina 174)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de GRAPH (P√°gina 8191)

WAIT: Programar retardo
Descripci√≥n
La instrucci√≥n "Programar retardo" detiene la ejecuci√≥n del programa durante un periodo
parametrizado. El periodo se indica en microsegundos en el par√°metro WT.
Es posible parametrizar tiempos de retardo de -32768 a 32767 microsegundos (Œºs). El tiempo
de retardo m√≠nimo depende de la CPU utilizada y equivale al tiempo de ejecuci√≥n de la
instrucci√≥n.
La ejecuci√≥n de la instrucci√≥n puede verse interrumpida por eventos de prioridad superior y no
arrojar√° informaci√≥n de error.
Nota
Tiempo de retardo negativo
Si indica un tiempo de retardo negativo en el par√°metro WT, la salida de habilitaci√≥n ENO, o
el RLO y el bit BR arrojan el estado l√≥gico FALSE. Un tiempo de retardo negativo no afecta a
la CPU. En KOP y FUP no se ejecutan las siguientes instrucciones vinculadas a la salida de
habilitaci√≥n ENO.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

WT

Input

INT

I, Q, M, D, L, P o
constante

Tiempo de retardo en micro‚Äê
segundos (Œºs)

Ejemplo de c√≥mo influir en el tiempo de retardo previsto
En el ejemplo siguiente se ve la influencia del tiempo de retardo de la instrucci√≥n "WAIT" en
diferentes escenarios.
La figura siguiente ilustra los escenarios esquem√°ticamente:

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2163

Instrucciones
4.1 Instrucciones
6HQG&ORFN

&DVR 
2%

PV

:$,7  PV
7'HOD\ PV

7&RGH PV

7'HOD\ PV

7&RGH PV

7'HOD\ PV

7&RGH PV

75H PV

&DVR
2%GHDODUPD

75H PV

&DVR
2%GHDODUPD

7&RGH PV

&DVR
2%GHDODUPD
72Y PV
6HQG&ORFN 7LHPSRGHFLFORGHHPLVL¬µQGHOD&38
7'HOD\ 7LHPSRGHUHWDUGRGHO2%GHDODUPD
7&RGH 7LHPSRGHHMHFXFL¬µQGHOSURJUDPD
75H 7LHPSRUHVWDQWH
72Y 7LHPSRHQHOTXHVHSURORQJDHOWLHPSRGHFLFORGHHPLVL¬µQ
(O2%FRQODLQVWUXFFL¬µQ:$,7WDPEL¬´QIRUPDSDUWHGHORVFDVRV\\GHEH
WHQHUVHHQFXHQWD

Tiempo restante = intervalo entre el final del tiempo de retardo previsto (mediante "WAIT") y la
finalizaci√≥n del OB de alarma
Tiempo de prolongaci√≥n = intervalo entre la finalizaci√≥n del OB de alarma y el final del tiempo
de retardo previsto (mediante "WAIT")
Caso 1:
La instrucci√≥n "WAIT" se llama en un OB1. La instrucci√≥n "WAIT" puede verse interrumpida por
OB o procesos de mayor prioridad (p. ej. System Threads). Sin embargo, el tiempo de retardo
de la instrucci√≥n "WAIT" no se ha modificado ni se ha aplazado.
Casos 2 y 3:
El procesamiento del programa en el OB1 prosigue tras un retardo de 20 ms. Este retardo se
calcula con la llamada de la instrucci√≥n "WAIT" en el OB1 (consulte OB1 con WAIT). En esos
20 ms, un OB de alarma puede ejecutar su propio c√≥digo de programa. El tiempo de ciclo de
emisi√≥n de la CPU no cambia.

2164

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Caso 4:
El procesamiento del programa en el OB1 prosigue tras finalizar el proceso de mayor prioridad.
Los 20 ms de retardo en el OB1 han transcurrido, pero el proceso de mayor prioridad todav√≠a
no ha finalizado. El tiempo de ciclo de emisi√≥n de la CPU aumenta.
Nota
Secuencia de ejecuci√≥n de procesos del sistema o de comunicaci√≥n (System Threads)
Los threads del sistema suelen utilizar la prioridad "15". Tambi√©n hay threads del sistema con
una prioridad mayor que "26", pero estos procesos suponen una carga menor para la CPU. Los
threads del sistema no se muestran en la figura.
Medici√≥n del tiempo de ejecuci√≥n del OB1 utilizando la instrucci√≥n "RT_INFO":
Caso 2: 20 ms - 8 ms - System Threads = <12 ms. Tiempo de ciclo de emisi√≥n: ~20 ms.
Caso 3: 20 ms - 11 ms - System Threads - <9 ms. Tiempo de ciclo de emisi√≥n: ~20 ms.
Caso 4: 20 ms - 15 ms - System Threads - <7 ms. Tiempo de ciclo de emisi√≥n: ~22 ms.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de GRAPH (P√°gina 8191)

Operaciones l√≥gicas con palabras
NOT (INV): Invertir
Descripci√≥n
La instrucci√≥n "Invertir" permite invertir el estado l√≥gico de los bits del operando. Al ejecutar la
instrucci√≥n, el valor del operando se combina con una operaci√≥n l√≥gica O-exclusiva utilizando
una plantilla hexadecimal (W#16#FFFF para n√∫meros de 16 bits o DW#16#FFFF FFFF para
n√∫meros de 32 bits). Esto invierte el estado l√≥gico de los distintos bits y lo devuelve como
resultado.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operando>

Input

Secuencias de
bits, enteros

I, Q, M, D, L, P o
constante

Valor de entrada

<Resultado>

Output

Secuencias de
bits, enteros

I, Q, M, D, L, P

Complemento a 1
del valor del ope‚Äê
rando

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2165

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"TagOut_Value" := NOT("TagIn_Value")

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

TagIn_Value

W#16#000F

TagOut_Value

W#16#FFF0

La instrucci√≥n invierte el estado l√≥gico de los distintos bits del operando "TagIn_Value" y
escribe el resultado en el operando "TagOut_Value".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

DECO: Descodificar
Descripci√≥n
La instrucci√≥n "Descodificar" activa un bit predeterminado por el valor de entrada en el valor de
salida.
La instrucci√≥n "Descodificar" lee el valor del par√°metro IN y activa el bit del par√°metro OUT
cuya posici√≥n de bit equivale al valor le√≠do. Los dem√°s bits del valor de salida se rellenan con
ceros. Si el valor del par√°metro IN es mayor que 31, se ejecuta una instrucci√≥n modulo 32.

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

UINT

I, Q, M, D, L, P o
constante

Posici√≥n del bit que se activa
en el valor de salida.

OUT

Output

Secuencias de bits I, Q, M, D, L, P

Valor de salida

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

2166

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL DECO UINT_DWORD
(IN := "Tag_Input"
OUT => "Tag_Output"
)

La figura siguiente muestra el funcionamiento de la instrucci√≥n con valores concretos:
7DJB,QSXW




7DJB2XWSXW

 



 

La instrucci√≥n lee el n√∫mero de bit "3" del valor del operando "Tag_Input" de la entrada y activa
el tercer bit del valor del operando "Tag_Output" de la salida.

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

ENCO: Codificar
Descripci√≥n
La instrucci√≥n "Codificar" lee el n√∫mero del bit menos significativo que est√° activado en el valor
de entrada y devolverlo en el par√°metro OUT.
La instrucci√≥n "Codificar" selecciona el bit menos significativo del valor del par√°metro IN y
escribe su n√∫mero de bit en el operando del par√°metro OUT. Si el par√°metro IN devuelve el
valor DW#16#00000001 o DW#16#00000000, en el par√°metro OUT se deposita el valor "0".

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

IN

Input

Secuencias de bits I, Q, M, D, L, P o
constante

√Årea de memoria

Valor de entrada

OUT

Output

INT

Valor de salida

I, Q, M, D, L, P

Descripci√≥n

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2167

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:

CALL ENCO DWORD
(IN := "Tag_Input"
OUT => "Tag_Output"
)

La figura siguiente muestra el funcionamiento de la instrucci√≥n con valores concretos:


 



‡≤Ø7DJB,QSXW‡≤Ø  
‡≤Ø7DJB2XWSXW‡≤Ø 

La instrucci√≥n selecciona el bit menos significativo que est√° activado en la variable "Tag_Input"
y escribe su bit "3" en la variable "Tag_Output".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

SEL: Seleccionar
Descripci√≥n
La instrucci√≥n "Seleccionar" permite elegir, en funci√≥n de un interruptor (entrada G), una de las
entradas IN0 o IN1 y copiar su contenido en la salida OUT. Si la entrada G tiene el estado l√≥gico
"0", se copia el valor de la entrada IN0. Si la entrada G tiene el estado l√≥gico "1", se copia el
valor de la entrada IN1 en la salida OUT.
Para poder procesar la instrucci√≥n, las variables de todos los par√°metros deben ser del mismo
tipo de datos.

2168

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

G

Input

BOOL

I, Q, M, D, L o
constante

Interruptor

IN0

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, n√∫‚Äê
meros en coma flo‚Äê
tante, temporiza‚Äê
dores, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Primer valor de entrada

IN1

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, n√∫‚Äê
meros en coma flo‚Äê
tante, temporiza‚Äê
dores, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Segundo valor de entrada

OUT

Output

I, Q, M, D, L, P
Secuencias de
bits, enteros, n√∫‚Äê
meros en coma flo‚Äê
tante, temporiza‚Äê
dores, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Resultado

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL SEL CHAR
(G := "Tag_Input_G"
IN0 := "Tag_Input0"
IN1 := "Tag_Input1"
OUT => "Tag_Output"
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores concretos:
Par√°metro

Operando

Valor

G

Tag_Input_G

1

IN0

Tag_Input0

W#16#0000

IN1

Tag_Input1

W#16#FFFF

OUT

Tag_Output

W#16#FFFF

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2169

Instrucciones
4.1 Instrucciones
Dependiendo del estado l√≥gico de la entrada "Tag_Input_G", se selecciona el valor de la
entrada "Tag_Input0" o "Tag_Input1" y se copia en la salida "Tag_Output".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

MUX: Multiplexar
Descripci√≥n
La instrucci√≥n "Multiplexar" permite copiar el contenido de una entrada seleccionada en la
salida RET_VAL. El n√∫mero de entradas seleccionables se puede ampliar hasta un m√°ximo de
32. La numeraci√≥n comienza por IN0 y contin√∫a en orden ascendente con cada nueva entrada.
El par√°metro K determina la entrada cuyo contenido se copia en la salida RET_VAL. Si el valor
del par√°metro K es mayor que el n√∫mero de entradas disponibles, el contenido del par√°metro
INELSE se copia en la salida RET_VAL.
La instrucci√≥n "Multiplexar" solo se puede ejecutar si las variables de todas las entradas y de
la salida RET_VAL tienen el mismo tipo de datos. El par√°metro K es una excepci√≥n, ya que
para √©ste s√≥lo pueden indicarse n√∫meros enteros.
El valor del par√°metro RET_VAL no es v√°lido si se cumple una de las siguientes condiciones:
‚óè La entrada del par√°metro K est√° fuera de las entradas disponibles. Esta reacci√≥n no
depende de que la entrada INELSE se utilice o no. El valor de la salida RET_VAL
permanece inalterado y la salida de habilitaci√≥n ENO se pone a "0".
‚óè Se producen errores al ejecutar la instrucci√≥n.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:

2170

Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

K

Input

Enteros

I, Q, M, D, L o
constante

Indica la entrada cuyo conte‚Äê
nido se copia.

IN0

Input

N√∫meros binarios, I, Q, M, D, L o
enteros, n√∫meros constante
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Primer valor de entrada

IN1

Input

N√∫meros binarios, I, Q, M, D, L o
enteros, n√∫meros constante
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Segundo valor de entrada

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

INn

Input

N√∫meros binarios, I, Q, M, D, L o
enteros, n√∫meros constante
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

√Årea de memoria

Descripci√≥n
Valores de entrada opciona‚Äê
les

INELSE

Input

N√∫meros binarios, I, Q, M, D, L o
enteros, n√∫meros constante
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Indica el valor que se copia si
K > n.

RET_VAL

Output

N√∫meros binarios, I, Q, M, D, L
enteros, n√∫meros
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Salida en la que se copia el
valor.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL MUX SINT_SINT
(K := "Tag_Number"
IN0 := "Tag_Value_1"
IN1 := "Tag_Value_2"
INELSE := "Tag_Value_3"
RET_VAL => "Tag_Result"
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Par√°metro

Operando

K

Tag_Number

1

Valor

IN0

Tag_Value_1

DW#16#00000000

IN1

Tag_Value_2

DW#16#3E4A7D

INELSE

Tag_Value_3

DW#16#FFFF0000

RET_VAL

Tag_Result

DW#16#3E4A7D

De acuerdo con el valor del operando "Tag_Number", se copia el valor de la entrada
"Tag_Value_1" y se indica en el operando de la salida "Tag_Result".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2171

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de GRAPH (P√°gina 8191)

DEMUX: Desmultiplexar
Descripci√≥n
La instrucci√≥n "Desmultiplexar" permite copiar el contenido de la entrada IN en una salida
seleccionada. El n√∫mero de salidas seleccionables se puede ampliar hasta un m√°ximo de 32.
La numeraci√≥n comienza por OUT0 y contin√∫a en orden ascendente con cada nueva salida.
El par√°metro K permite determinar la salida en la que se copia el contenido de la entrada IN.
Las dem√°s salidas no cambian. Si el valor del par√°metro K es mayor que el n√∫mero de salidas
disponibles, el contenido de la entrada IN se copia en el par√°metro OUTELSE.
La instrucci√≥n "Desmultiplexar" solo se puede ejecutar si las variables de la entrada IN y las de
todas las salidas tienen el mismo tipo de datos. El par√°metro K es una excepci√≥n, ya que en
el mismo s√≥lo pueden indicarse n√∫meros enteros.
El valor de la salida OUTELSE no es v√°lido si se cumple una de las siguientes condiciones:
‚óè El valor del par√°metro K es mayor que el n√∫mero de salidas disponibles.
‚óè Se producen errores al ejecutar la instrucci√≥n.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:

2172

Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

K

Input

Enteros

I, Q, M, D, L o
constante

Indica la salida en la que se
copia el valor de entrada (IN).

IN

Input

N√∫meros binarios, I, Q, M, D, L o
enteros, n√∫meros constante
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Valor de entrada

OUT0

Output

N√∫meros binarios, I, Q, M, D, L
enteros, n√∫meros
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Primera salida

OUT1

Output

N√∫meros binarios, I, Q, M, D, L
enteros, n√∫meros
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Segunda salida

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

OUTn

Output

N√∫meros binarios, I, Q, M, D, L
enteros, n√∫meros
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

√Årea de memoria

Descripci√≥n
Salidas opcionales

OUTELSE

Output

N√∫meros binarios, I, Q, M, D, L
enteros, n√∫meros
en coma flotante,
tiempos, CHAR,
WCHAR, TOD,
LTOD, DATE, LDT

Salida en la que se copia el
valor de entrada (IN) con K >
n.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos disponibles en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL DEMUX SINT_SINT
(K := "Tag_Number"
IN := "Tag_Value"
OUT0 => "Tag_Output_1"
OUT1 => "Tag_Output_2"
OUTELSE => "Tag_Output_3"
)

Las tablas siguientes muestran el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Tabla 4-5

Valores de entrada de la instrucci√≥n "Desmultiplexar" antes de ejecutar el segmento:

Par√°metro

Operando

K

Tag_Number

1

4

IN

Tag_Value

DW#16#FFFFFFFF

DW#16#3E4A7D

Tabla 4-6

Valores

Valores de salida de la instrucci√≥n "Desmultiplexar" tras ejecutar el segmento:

Par√°metro

Operando

Valores

OUT0

Tag_Output_1

Sin cambios

Sin cambios

OUT1

Tag_Output_2

DW#16#FFFFFFFF

Sin cambios

OUTELSE

Tag_Output_3

Sin cambios

DW#16#3E4A7D

Seg√∫n el valor del operando "Tag_Number", se copia el valor de la entrada IN en la salida
correspondiente.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2173

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

Desplazamiento y rotaci√≥n
SHR: Desplazar a la derecha
Descripci√≥n
Con la instrucci√≥n "Desplazar a la derecha", el contenido del operando 1 se mueve bit a bit
hacia la derecha. El operando 2 determina el n√∫mero de posiciones de bit que debe
desplazarse el valor indicado.
Cuando el valor del operando 2 es "0", se copia en valor del operando 1 en el resultado.
Si el valor del operando 2 es mayor que el n√∫mero de posiciones de bit disponibles, el valor del
operando 1 se desplaza hacia la derecha las posiciones de bit disponibles.
En los valores sin signo, se rellenan con ceros las posiciones de bits que quedan libres en el
√°rea izquierda del operando 1 al realizar el desplazamiento. Si el valor indicado lleva signo, las
posiciones libres se ocupan con el estado l√≥gico del bit de signo.
La figura siguiente muestra c√≥mo el contenido del operando 1 del tipo de datos INT se
desplaza cuatro posiciones de bit hacia la derecha:


2SHUDQGR















2SHUDQGR %LW
GHVLJQR

5HVXOWDGR






































G¬ØJLWRV











/DVSRVLFLRQHVGHELWOLEHUDGDV
VHUHOOHQDQFRQHOHVWDGRO¬µJLFR
GHOELWGHVLJQR

2174

















(VWRVFXDWUR
ELWVVHSLHUGHQ

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operan‚Äê
do1>

Input

Secuencias de
bits, enteros

I, Q, M, D, L o
constante

Valor que se desplaza

<Operan‚Äê
do2>

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L o
constante

N√∫mero de posiciones de bit
que se desplaza el valor

<Resultado>

Output

Secuencias de
bits, enteros

I, Q, M, D, L

Resultado de la instrucci√≥n

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := SHR_INT("Tag_InValue","Tag_Number")

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

0011 1111 1010 1111

Tag_Number

3

Tag_OutValue

0000 0111 1111 0101

El contenido del operando "Tag_InValue" se desplaza tres posiciones de bit hacia la derecha.
El resultado se deposita en la salida "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

SHL: Desplazar a la izquierda
Descripci√≥n
Con la instrucci√≥n "Desplazar a la izquierda", el contenido del operando 1 se mueve bit a bit
hacia la izquierda. El operando 2 determina el n√∫mero de posiciones de bit que debe
desplazarse el valor indicado.
Cuando el valor del operando 2 es "0", se copia en valor del operando 1 en el resultado.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2175

Instrucciones
4.1 Instrucciones
Si el valor del operando 2 es mayor que el n√∫mero de posiciones de bit disponibles, el valor del
operando 1 se desplaza hacia la izquierda las posiciones de bit disponibles.
Las posiciones de bit que quedan libres en el √°rea derecha del operando 1 al realizar el
desplazamiento se rellenan con ceros.
La figura siguiente muestra c√≥mo el contenido del operando 1 del tipo de datos WORD se
desplaza seis posiciones de bit hacia la izquierda:


2SHUDQG







2SHUDQGR

5HVXOWDGR
































G¬ØJLWRV

     

































/DVSRVLFLRQHV
GHELWOLEHUDGDVVH
UHOOHQDQFRQFHURV

(VWRVVHLV
ELWVVHSLHUGHQ

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operan‚Äê
do1>

Input

Secuencias de
bits, enteros

I, Q, M, D, L o
constante

Valor que se desplaza

<Operan‚Äê
do2>

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L o
constante

N√∫mero de posiciones de bit
que se desplaza el valor

<Resultado>

Output

Secuencias de
bits, enteros

I, Q, M, D, L

Resultado de la instrucci√≥n

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucci√≥n.
Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := SHL_WORD("Tag_InValue","Tag_Number")

2176

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

0011 1111 1010 1111

Tag_Number

4

Tag_OutValue

1111 1010 1111 0000

El contenido del operando "Tag_InValue" se desplaza cuatro posiciones de bit hacia la
izquierda y se indica como resultado en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

ROR: Rotar a la derecha
Descripci√≥n
Con la instrucci√≥n "Rotar a la derecha", el contenido del operando 1 se rota bit a bit hacia la
derecha. El operando 2 determina el n√∫mero de posiciones de bit que debe rotarse el valor
indicado.
Cuando el valor del operando 2 es "0", se copia en valor del operando 1 en el resultado.
Si el valor del operando 2 es mayor que el n√∫mero de posiciones de bit disponibles, el valor del
operando 1 se rota el n√∫mero indicado de posiciones de bit.
Los bits que quedan libres al realizar la rotaci√≥n se rellenan con los bits desplazados hacia
fuera.
La figura siguiente muestra c√≥mo el contenido de un operando del tipo de datos DWORD rota
tres posiciones hacia la derecha:

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2177

Instrucciones
4.1 Instrucciones


2SHUDQGR

 



       

2SHUDQGR

G¬ØJLWRV

5HVXOWDGR

       



(OHVWDGRO¬µJLFRGHORVWUHV
ELWVGHVSOD]DGRVVHLQWURGXFHHQODV
SRVLFLRQHVTXHKDQTXHGDGROLEUHV

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operan‚Äê
do1>

Input

Secuencias de
bits, enteros

I, Q, M, D, L o
constante

Valor que se rota

<Operan‚Äê
do2>

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L o
constante

N√∫mero de posiciones de bit
que rota el valor

<Resultado>

Output

Secuencias de
bits, enteros

I, Q, M, D, L

Resultado de la instrucci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := ROR("Tag_InValue","Tag_Number")

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1010 1010 0000 1111 0000 1111 0101 0101

Tag_Number

5

Tag_OutValue

1010 1101 0101 0000 0111 1000 0111 1010

El contenido del operando "Tag_InValue" se rota cinco posiciones de bit hacia la derecha y se
indica como resultado en el operando "Tag_OutValue".

2178

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

ROL: Rotar a la izquierda
Descripci√≥n
Con la instrucci√≥n "Rotar a la izquierda", el contenido del operando 1 se rota bit a bit hacia la
izquierda. El operando 2 determina el n√∫mero de posiciones de bit que debe rotarse el valor
indicado.
Cuando el valor del operando 2 es "0", se copia en valor del operando 1 en el resultado.
Si el valor del operando 2 es mayor que el n√∫mero de posiciones de bit disponibles, el valor del
operando 1 se rota el n√∫mero indicado de posiciones de bit.
Los bits que quedan libres al realizar la rotaci√≥n se rellenan con los bits desplazados hacia
fuera.
La figura siguiente muestra c√≥mo el contenido de un operando del tipo de datos DWORD rota
tres posiciones hacia la izquierda:


2SHUDQGR



       

2SHUDQGR

5HVXOWDGR

 

G¬ØJLWRV



       
(OHVWDGRO¬µJLFRGHORVWUHV
ELWVGHVSOD]DGRVVHLQWURGXFHHQODV
SRVLFLRQHVTXHKDQTXHGDGROLEUHV

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2179

Instrucciones
4.1 Instrucciones

Par√°metro
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operan‚Äê
do1>

Input

Secuencias de
bits, enteros

I, Q, M, D, L o
constante

Valor que se rota

<Operan‚Äê
do2>

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L o
constante

N√∫mero de posiciones de bit
que rota el valor

<Resultado>

Output

Secuencias de
bits, enteros

I, Q, M, D, L

Resultado de la instrucci√≥n

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Consulte tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
"Tag_OutValue" := ROL("Tag_InValue","Tag_Number")

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores de operandos
concretos:
Operando

Valor

Tag_InValue

1111 0000 1010 1010 0000 1111 0000 1111

Tag_Number

5

Tag_OutValue

0001 0101 0100 0001 1110 0001 1111 1110

El contenido del operando "Tag_InValue" se rota cinco posiciones de bit hacia la izquierda y se
indica como resultado en el operando "Tag_OutValue".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

2180

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Legacy
DRUM: Materializar circuito secuencial sucesivo
Descripci√≥n
La instrucci√≥n "Materializar circuito secuencial sucesivo" ocupa los bits de salida programados
(OUT1 a OUT16) y la palabra de salida (OUT_WORD) con los valores programados del
par√°metro OUT_VAL del paso respectivo. El paso en cuesti√≥n debe cumplir las condiciones de
la m√°scara de habilitaci√≥n programada en el par√°metro S_MASK mientras la instrucci√≥n
permanece en dicho paso. La instrucci√≥n pasa al paso siguiente cuando el evento de √©ste es
verdadero y una vez transcurrido el tiempo programado para el paso actual, o bien cuando el
valor del par√°metro JOG cambia de "0" a "1". La instrucci√≥n se desactiva cuando el estado
l√≥gico del par√°metro RESET cambia a "1". Con ello, el paso actual se iguala al paso
predeterminado (DSP).
El tiempo de permanencia en un paso se calcula multiplicando la base de tiempo
predeterminada (DTBP) por el valor de contaje predeterminado (S_PRESET) para cada paso.
Al comienzo de un nuevo paso, este valor calculado se carga en el par√°metro DCC, que
contiene el tiempo restante para el paso actual. Por ejemplo, si el valor del par√°metro DTBP es
"2" y el valor predeterminado para el primer paso es "100" (100 ms), el par√°metro DCC
devolver√° el valor "200" (200 ms).
Un paso puede programarse con un valor de tiempo, con un evento o con ambos. Los pasos
programados con un bit de evento y el valor de tiempo "0" pasan al siguiente paso en cuanto
el estado l√≥gico del bit de evento es "1". Los pasos programados solo con un valor de tiempo
empiezan a contar el tiempo inmediatamente. Los pasos programados con un bit de evento y
un valor de tiempo mayor que "0" empiezan a contar el tiempo en cuanto el estado l√≥gico del
bit de evento es "1". Los bits de evento se inicializan con el estado l√≥gico "1".
Si el circuito secuencial sucesivo se encuentra en el √∫ltimo paso programado (LST_STEP) y ha
transcurrido el tiempo para dicho paso, el estado l√≥gico del par√°metro Q se pone a "1". De lo
contrario, se pone a "0". Si est√° activado el par√°metro Q, la instrucci√≥n permanece en el paso
hasta la desactivaci√≥n.
En la m√°scara configurable (S_MASK) es posible seleccionar los distintos bits de la palabra de
salida (OUT_WORD) y activar o desactivar los bits de salida (OUT1 a OUT16) mediante los
valores de salida (OUT_VAL). Si un bit de la m√°scara configurable tiene el estado l√≥gico "1",
el valor OUT_VAL activa o desactiva el bit correspondiente. Si el estado l√≥gico de un bit de la
m√°scara configurable es "0", no cambia el bit respectivo. Todos los bits de la m√°scara
configurable de todos los 16 pasos se inicializan con el estado l√≥gico "1".
El bit de salida del par√°metro OUT1 equivale al bit menos significativo de la palabra de salida
(OUT_WORD). El bit de salida del par√°metro OUT16 equivale al bit m√°s significativo de la
palabra de salida (OUT_WORD).

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2181

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

RESET

Input

BOOL

I, Q, M, D, L o
constante

El estado l√≥gico "1" indica
una condici√≥n de desactiva‚Äê
ci√≥n.

JOG

Input

BOOL

I, Q, M, D, L o
constante

Si el estado l√≥gico cambia de
"0" a "1", la instrucci√≥n pasa
al siguiente paso.

DRUM_EN

Input

BOOL

I, Q, M, D, L o
constante

El estado l√≥gico "1" permite
que el circuito secuencial su‚Äê
cesivo siga contando seg√∫n
el evento y los criterios de
tiempo.

LST_STEP

Input

BYTE

I, Q, M, D, L o
constante

N√∫mero m√°ximo de etapas
(p. ej.: LST_STEP = 16#08;
son posibles 8 etapas como
m√°ximo.)

EVENT(i)

Input

BOOL

I, Q, M, D, L o
constante

Bit de evento (i);

Output

BOOL

I, Q, M, D, L

Bit de salida (j)

Q

Output

BOOL

I, Q, M, D, L

El estado l√≥gico "1" indica
que ha transcurrido el tiempo
del √∫ltimo paso.

OUT_WORD

Output

WORD

I, Q, M, D, L, P

Direcci√≥n de palabra en la
que el circuito secuencial su‚Äê
cesivo escribe los valores de
salida.

ERR_CODE

Output

WORD

I, Q, M, D, L, P

Informaci√≥n de error

JOG_HIS

Static

BOOL

I, Q, M, D, L o
constante

Bit de evoluci√≥n del par√°me‚Äê
tro JOG

EOD

Static

BOOL

I, Q, M, D, L o
constante

El estado l√≥gico "1" indica
que ha transcurrido el tiempo
del √∫ltimo paso.

DSP

Static

BYTE

I, Q, M, D, L, P o
constante

Primer paso predeterminado
del circuito secuencial suce‚Äê
sivo (1 a 16)

DSC

Static

BYTE

I, Q, M, D, L, P o
constante

Paso actual del circuito se‚Äê
cuencial sucesivo

DCC

Static

DWORD

I, Q, M, D, L, P o
constante

Tiempo de ejecuci√≥n restan‚Äê
te para el paso actual

DTBP

Static

WORD

I, Q, M, D, L, P o
constante

Base de tiempo predetermi‚Äê
nada del circuito secuencial
sucesivo

PrevTime

Static

TIME

I, Q, M, D, L o
constante

hora de sistema de la llama‚Äê
da anterior

1 ‚â§ i ‚â§ 16
OUT(j),

El estado l√≥gico inicial es "1".

1 ‚â§ j ‚â§ 16

2182

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

S_PRESET

Static

ARRAY[1..16] of
WORD

I, Q, M, D, L o
constante

Valor de contaje predetermi‚Äê
nado para cada paso [1 a 16];
1 ciclo de reloj = 1 ms.

OUT_VAL

Static

ARRAY[1..16,
0..15] of BOOL

I, Q, M, D, L o
constante

Valores de salida para cada
etapa [1 a 16, 0 a 15].

S_MASK

Static

ARRAY[1..16,
0..15] of BOOL

I, Q, M, D, L o
constante

M√°scara configurable para
cada etapa [1 a 16, 0 a 15].
Los estados l√≥gicos iniciales
son "1".

Par√°metro ERR_CODE
La tabla siguiente muestra el significado de los valores del par√°metro ERR_CODE:
ERR_CO‚Äê
DE*

Explicaci√≥n

W#16#000
0

Ning√∫n error

W#16#000
B

El valor del par√°metro LST_STEP es menor que 1 o mayor que 16.

W#16#000
C

El valor del par√°metro DSC es menor que 1 o mayor que el valor del par√°metro
LST_STEP.

W#16#000
D

El valor del par√°metro DSP es menor que 1 o mayor que el valor de LST_STEP.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
En el ejemplo siguiente, la instrucci√≥n pasa del paso 1 al paso 2. Los bits de salida (OUT1 a
OUT16) y la palabra de salida (OUT_WORD) se activan seg√∫n la m√°scara configurada para el
paso 2 y los valores del par√°metro OUT_VAL.
Nota
Los par√°metros est√°ticos pueden inicializarse en el bloque de datos.

GRAPH
CALL DRUM, "DRUM_DB"
(RESET := "Tag_Reset"
JOG := "Tag_Input_Jog"
DRUM_EN := "Tag_Input_Drum_EN"
LST_STEP := "Tag_Number_LastStep"
EVENTn := "MyTag_Event_n"
OUTn => "MyTag_Output_n"

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2183

Instrucciones
4.1 Instrucciones
GRAPH
Q => "Tag_Output_Q"
OUT_WORD => "Tag_OutputWord"
ERR_CODE => "Tag_ErrorCode"
)

Las tablas siguientes muestran el funcionamiento de la instrucci√≥n con valores concretos.

Antes de la ejecuci√≥n
En este ejemplo se utilizan los siguientes valores para asignar valores a los par√°metros de
entrada:
Par√°metro

Operando

Direcci√≥n

Valor

RESET

Tag_Reset

M0.0

FALSE

JOG

Tag_Input_JOG

M0.1

FALSE

DRUM_EN

Tag_Input_Drum_EN

M0.2

TRUE

LST_STEP

Tag_Number_LastStep

MB1

B#16#08

EVENT2

MyTag_Event_2

M20.0

FALSE

EVENT4

MyTag_Event_4

M20.1

FALSE

EVENT6

MyTag_Event_6

M20.2

FALSE

EVENT8

MyTag_Event_8

M20.3

FALSE

EVENT10

MyTag_Event_10

M20.4

FALSE

EVENT12

MyTag_Event_12

M20.5

FALSE

EVENT14

MyTag_Event_14

M20.6

FALSE

EVENT16

MyTag_Event_16

M20.7

FALSE

En el bloque de datos de instancia "DRUM_DB" de la instrucci√≥n se guardan los siguientes
valores:
Par√°metro

2184

Direcci√≥n

Valor

JOG_HIS

DBX12.0

FALSE

EOD

DBX12.1

FALSE

DSP

DBB13

W#16#0001

DSC

DBB14

W#16#0001

DCC

DBD16

DW#16#0000000A

DTBP

DBW20

W#16#0001

S_PRESET[1]

DBW26

W#16#0064

S_PRESET[2]

DBW28

W#16#00C8

OUT_VAL[1,0]

DBX58.0

TRUE

OUT_VAL[1,1]

DBX58.1

TRUE

OUT_VAL[1,2]

DBX58.2

TRUE

OUT_VAL[1,3]

DBX58.3

TRUE

OUT_VAL[1,4]

DBX58.4

TRUE

OUT_VAL[1,5]

DBX58.5

TRUE

OUT_VAL[1,6]

DBX58.6

TRUE

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Direcci√≥n

Valor

OUT_VAL[1,7]

DBX58.7

TRUE

OUT_VAL[1,8]

DBX59.0

TRUE

OUT_VAL[1,9]

DBX59.1

TRUE

OUT_VAL[1,10]

DBX59.2

TRUE

OUT_VAL[1,11]

DBX59.3

TRUE

OUT_VAL[1,12]

DBX59.4

TRUE

OUT_VAL[1,13]

DBX59.5

TRUE

OUT_VAL[1,14]

DBX59.6

TRUE

OUT_VAL[1,15]

DBX59.7

TRUE

OUT_VAL[2,0]

DBX60.0

FALSE

OUT_VAL[2,1]

DBX60.1

FALSE

OUT_VAL[2,2]

DBX60.2

FALSE

OUT_VAL[2,3]

DBX60.3

FALSE

OUT_VAL[2,4]

DBX60.4

FALSE

OUT_VAL[2,5]

DBX60.5

FALSE

OUT_VAL[2,6]

DBX60.6

FALSE

OUT_VAL[2,7]

DBX60.7

FALSE

OUT_VAL[2,8]

DBX61.0

FALSE

OUT_VAL[2,9]

DBX61.1

FALSE

OUT_VAL[2,10]

DBX61.2

FALSE

OUT_VAL[2,11]

DBX61.3

FALSE

OUT_VAL[2,12]

DBX61.4

FALSE

OUT_VAL[2,13]

DBX61.5

FALSE

OUT_VAL[2,14]

DBX61.6

FALSE

OUT_VAL[2,15]

DBX61.7

FALSE

S_MASK[2,0]

DBX92.0

FALSE

S_MASK[2,1]

DBX92.1

TRUE

S_MASK[2,2]

DBX92.2

TRUE

S_MASK[2,3]

DBX92.3

TRUE

S_MASK[2,4]

DBX92.4

TRUE

S_MASK[2,5]

DBX92.5

FALSE

S_MASK[2,6]

DBX92.6

TRUE

S_MASK[2,7]

DBX92.7

TRUE

S_MASK[2,8]

DBX93.0

FALSE

S_MASK[2,9]

DBX93.1

FALSE

S_MASK[2,10]

DBX93.2

TRUE

S_MASK[2,11]

DBX93.3

TRUE

S_MASK[2,12]

DBX93.4

TRUE

S_MASK[2,13]

DBX93.5

TRUE

S_MASK[2,14]

DBX93.6

FALSE

S_MASK[2,15]

DBX93.7

TRUE

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2185

Instrucciones
4.1 Instrucciones
Los par√°metros de salida tienen los valores siguientes antes de ejecutarse la instrucci√≥n:
Par√°metro

Operando

Direcci√≥n

Valor

Q

Tag_Output_Q

M6.0

FALSE

OUTWORD

Tag_OutputWord

MW8

W#16#FFFF

OUT1

MyTag_Output_1

M4.0

TRUE

OUT2

MyTag_Output_2

M4.1

TRUE

OUT3

MyTag_Output_3

M4.2

TRUE

OUT4

MyTag_Output_4

M4.3

TRUE

OUT5

MyTag_Output_5

M4.4

TRUE

OUT6

MyTag_Output_6

M4.5

TRUE

OUT7

MyTag_Output_7

M4.6

TRUE

OUT8

MyTag_Output_8

M4.7

TRUE

OUT9

MyTag_Output_9

M5.0

TRUE

OUT10

MyTag_Output_10

M5.1

TRUE

OUT11

MyTag_Output_11

M5.2

TRUE

OUT12

MyTag_Output_12

M5.3

TRUE

OUT13

MyTag_Output_13

M5.4

TRUE

OUT14

MyTag_Output_14

M5.5

TRUE

OUT15

MyTag_Output_15

M5.6

TRUE

OUT16

MyTag_Output_16

M5.7

TRUE

Despu√©s de la ejecuci√≥n
Una vez ejecutada la instrucci√≥n, los valores siguientes se escriben en los par√°metros de
salida:

2186

Par√°metro

Operando

Direcci√≥n

Valor

OUT1

MyTag_Output_1

M4.0

TRUE

OUT2

MyTag_Output_2

M4.1

FALSE

OUT3

MyTag_Output_3

M4.2

FALSE

OUT4

MyTag_Output_4

M4.3

FALSE

OUT5

MyTag_Output_5

M4.4

FALSE

OUT6

MyTag_Output_6

M4.5

TRUE

OUT7

MyTag_Output_7

M4.6

FALSE

OUT8

MyTag_Output_8

M4.7

FALSE

OUT9

MyTag_Output_9

M5.0

TRUE

OUT10

MyTag_Output_10

M5.1

TRUE

OUT11

MyTag_Output_11

M5.2

FALSE

OUT12

MyTag_Output_12

M5.3

FALSE

OUT13

MyTag_Output_13

M5.4

FALSE

OUT14

MyTag_Output_14

M5.5

FALSE

OUT15

MyTag_Output_15

M5.6

TRUE

OUT16

MyTag_Output_16

M5.7

FALSE

Q

Tag_Output_Q

M6.0

FALSE

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Operando

Direcci√≥n

Valor

OUTWORD

Tag_OutputWord

MW8

W#16#4321

ERR_CODE

Tag_ErrorCode

MW10

W#16#0000

En el bloque de datos de instancia "DRUM_DB" de la instrucci√≥n se guardan los siguientes
valores:
Par√°metro

Direcci√≥n

Valor

JOG_HIS

DBX12.0

FALSE

EOD

DBX12.1

FALSE

DSC

DBB14

W#16#0002

DCC

DBD16

DW#16#000000C8

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

DCAT: Alarma de tiempo para control discreto
Descripci√≥n
La instrucci√≥n "Alarma de tiempo para control discreto" acumula el tiempo desde el instante en
el que el par√°metro CMD da la orden de abrir o cerrar. El tiempo se acumula hasta excederse
el tiempo predeterminado (PT) o hasta recibir la notificaci√≥n de que el dispositivo se ha cerrado
o abierto dentro del tiempo prescrito (O_FB o C_FB). Si se excede el tiempo predeterminado
antes de recibirse la notificaci√≥n de que se ha abierto o cerrado el dispositivo, se activa la
alarma correspondiente. Si el estado l√≥gico de la entrada de la orden cambia antes del tiempo
predeterminado, se reinicia el tiempo.
La instrucci√≥n "Alarma de tiempo para control discreto" tiene las reacciones siguientes en las
condiciones de entrada:
‚óè Si el estado l√≥gico del par√°metro CMD cambia de "0" a "1", esto tiene los efectos siguientes
en los estados l√≥gicos de los par√°metros Q, CMD_HIS, ET (solo si ET < PT), OA y CA:
‚Äì Los par√°metros Q y CMD_HIS se ponen a "1"
‚Äì Los par√°metros ET, OA y CA se ponen a "0"
‚óè Si el estado l√≥gico del par√°metro CMD cambia de "1" a "0", los par√°metros Q, ET (solo si
ET < PT), OA, CA y CMD_HIS se ponen a "0".
‚óè Si los par√°metros CMD y CMD_HIS tienen el estado l√≥gico "1" y el par√°metro O_FB se pone
a "0", la diferencia de tiempo (ms) desde la √∫ltima ejecuci√≥n de la instrucci√≥n se suma al
valor del par√°metro ET. Si el valor del par√°metro ET excede el del par√°metro PT, el estado
l√≥gico del par√°metro OA se pone a "1". Si el valor del par√°metro ET no excede el del
par√°metro PT, el estado l√≥gico del par√°metro OA se pone a "0". El valor del par√°metro
CMD_HIS se pone al del par√°metro CMD.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2187

Instrucciones
4.1 Instrucciones
‚óè Si los estados l√≥gicos de los par√°metros CMD, CMD_HIS y O_FB est√°n a "1" y el par√°metro
C_FB devuelve el valor "0", el estado l√≥gico del par√°metro OA se pone a "0". El valor del
par√°metro ET se pone al del par√°metro PT. Si el estado l√≥gico del par√°metro O_FB cambia
a "0", se activa la alarma en la siguiente ejecuci√≥n de la instrucci√≥n. El valor del par√°metro
CMD_HIS se pone al del par√°metro CMD.
‚óè Si los par√°metros CMD, CMD_HIS y C_FB devuelven "0", la diferencia de tiempo (ms)
desde la √∫ltima ejecuci√≥n de la instrucci√≥n se suma al valor del par√°metro ET. Si el valor del
par√°metro ET excede el del par√°metro PT, el estado l√≥gico del par√°metro CA se pone a "1".
Si no se excede el valor del par√°metro PT, el par√°metro CA devuelve el estado l√≥gico "0".
El valor del par√°metro CMD_HIS se pone al del par√°metro CMD.
‚óè Si los par√°metros CMD, CMD_HIS y O_FB devuelven el estado l√≥gico "0" y el par√°metro
C_FB est√° a "1", el par√°metro CA se pone a "0". El valor del par√°metro ET se pone al del
par√°metro PT. Si el estado l√≥gico del par√°metro C_FB cambia a "0", se activa la alarma en
la siguiente ejecuci√≥n de la instrucci√≥n. El valor del par√°metro CMD_HIS se pone al del
par√°metro CMD.
‚óè Si los par√°metros O_FB y C_FB devuelven simult√°neamente el estado l√≥gico "1", los
estados l√≥gicos de ambas salidas de alarma se ponen a "1".
La instrucci√≥n "Alarma de tiempo para control discreto" no devuelve informaci√≥n de error.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n Tipo de da‚Äê √Årea de memoria
tos

Descripci√≥n

CMD

Input

El estado l√≥gico "0" da la or‚Äê
den de "Cerrar".

BOOL

I, Q, M, D, L o constante

El estado l√≥gico "1" da la or‚Äê
den de "Abrir".

2188

O_FB

Input

BOOL

I, Q, M, D, L o constante

Entrada de realimentaci√≥n
al abrir

C_FB

Input

BOOL

I, Q, M, D, L o constante

Entrada de realimentaci√≥n
al cerrar

Q

Output

BOOL

I, Q, M, D, L

Indica el estado del par√°me‚Äê
tro CMD

OA

Output

BOOL

I, Q, M, D, L

Salida de alarma al abrir

CA

Output

BOOL

I, Q, M, D, L

Salida de alarma al cerrar

ET

Static

DINT

D, L o constante

Tiempo actual transcurrido;
un ciclo de reloj = 1 ms.

PT

Static

DINT

D, L o constante

Valor de tiempo predetermi‚Äê
nado; un ciclo de reloj = 1
ms.

PREV_TIME

Static

DWORD

D, L o constante

Hora de sistema anterior

CMD_HIS

Static

BOOL

D, L o constante

Bit de evoluci√≥n de CMD

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
En el ejemplo siguiente, el par√°metro CMD cambia de "0" a "1". Una vez ejecutada la
instrucci√≥n, el par√°metro Q se pone a "1" y las dos salidas de alarma OA y CA se ponen a "0".
El par√°metro CMD_HIS del bloque de datos de instancia se pone a "1" y el par√°metro ET se
pone a "0".
Nota
Los par√°metros est√°ticos pueden inicializarse en el bloque de datos.

GRAPH
CALL DCAT, "DCAT_DB"
(CMD := "Tag_Input_CMD"
O_FB := "Tag_Input_O_FB"
C_FB := "Tag_Input_C_FB"
Q => "Tag_Output_Q"
OA => "Tag_Output_OA"
CA => "Tag_Output_CA"
)

Las tablas siguientes muestran el funcionamiento de la instrucci√≥n con valores concretos.

Antes de la ejecuci√≥n
En este ejemplo se utilizan los siguientes valores para los par√°metros de entrada y salida:
Par√°metro

Operando

Valor

CMD

Tag_Input_CMD

TRUE

O_FB

Tag_Input_O_FB

FALSE

C_FB

Tag_Input_C_FB

FALSE

Q

Tag_Output_Q

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

En el bloque de datos de instancia "DCAT_DB" de la instrucci√≥n se guardan los siguientes
valores:
Par√°metro

Direcci√≥n

Valor

ET

DBD4

L#12

PT

DBD8

L#222

CMD_HIS

DBX16.0

FALSE

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2189

Instrucciones
4.1 Instrucciones

Despu√©s de la ejecuci√≥n
Una vez ejecutada la instrucci√≥n, los valores siguientes se escriben en los par√°metros de
salida:
Par√°metro

Operando

Valor

Q

Tag_Output_Q

TRUE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

En el bloque de datos de instancia "DCAT_DB" de la instrucci√≥n se guardan los siguientes
valores:
Par√°metro

Direcci√≥n

Valor

ET

DBD4

L#0

CMD_HIS

DBX16.0

TRUE

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

MCAT: Alarma de tiempo para control del motor
Descripci√≥n
La instrucci√≥n "Alarma de tiempo para control del motor" acumula el tiempo desde el instante
en el que se activa una de las entradas de comando (abrir o cerrar). El tiempo se acumula hasta
que se excede el tiempo predeterminado o hasta que la entrada de realimentaci√≥n
correspondiente indica que el dispositivo ha ejecutado la operaci√≥n solicitada dentro del
tiempo prescrito. Si se excede el tiempo predeterminado antes de recibir respuesta, se dispara
la alarma correspondiente.

Ejecuci√≥n de la instrucci√≥n "Alarma de tiempo para control del motor"
La tabla siguiente muestra las reacciones de la instrucci√≥n "Alarma de tiempo para control del
motor" a las distintas condiciones de entrada:
Par√°metros de entrada

Par√°metros de salida

ET

O_H
IS

C_H
IS

O_C
MD

C_C
MD

S_C
MD

O_F
B

C_F
B

OO

CO

OA

CA

ET

O_H
IS

C_HI Q
S

Estado

X

1

1

X

X

X

X

X

0

0

1

1

PT

0

0

Alarma

X

X

X

X

X

X

1

1

0

0

1

1

PT

0

0

0

Alarma

X

X

X

X

X

1

X

X

0

0

0

0

X

0

0

1

Stop

X

X

X

1

1

X

X

X

0

0

0

0

X

0

0

1

Stop

2190

0

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metros de entrada

Par√°metros de salida

X

0

X

1

0

0

X

X

1

0

0

0

0

1

0

1

Empezar a
abrir

<PT

1

0

X

0

0

0

X

1

0

0

0

INC

1

0

1

Abrir

X

1

0

X

0

0

1

0

0

0

0

0

PT

1

0

1

Abierto

>=
PT

1

0

X

0

0

0

X

0

0

1

0

PT

1

0

0

Abrir alarma

X

X

0

0

1

0

X

X

0

1

0

0

0

0

1

1

Empezar a
cerrar

< PT 0

1

0

X

0

X

0

0

1

0

0

INC

0

1

1

Cerrar

X

0

1

0

X

0

0

1

0

0

0

0

PT

0

1

1

Cerrado

>=
PT

0

1

0

X

0

X

0

0

0

0

1

PT

0

1

0

Cerrar alar‚Äê
ma

X

0

0

0

0

0

X

X

0

0

0

0

X

0

0

1

Parado

Leyenda:
INC

Sumar a ET la diferencia de tiempo (en ms) desde la √∫ltima ejecuci√≥n del FB

PT

PT se pone al mismo valor que ET

X

No aplicable

< PT

ET < PT

>= PT

ET >= PT

Si los par√°metros de entrada O_HIS y C_HIS tienen el estado l√≥gico "1", se ponen inmediatamente al estado l√≥gico "0". En
este caso se aplica la √∫ltima fila de la tabla mencionada m√°s arriba (X). Puesto que por este motivo no es posible comprobar
si los par√°metros de entrada O_HIS y C_HIS tienen el estado l√≥gico "1", en este caso se asigna el siguiente valor a los
par√°metros de salida:
OO = FALSE
CO = FALSE
OA = FALSE
CA = FALSE
ET = PT
Q = TRUE

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

O_CMD

Input

BOOL

I, Q, M, D, L o
constante

Entrada de la orden "Abrir"

C_CMD

Input

BOOL

I, Q, M, D, L o
constante

Entrada de la orden "Cerrar"

S_CMD

Input

BOOL

I, Q, M, D, L o
constante

Entrada de la orden "Parar"

O_FB

Input

BOOL

I, Q, M, D, L o
constante

Entrada de realimentaci√≥n al
abrir

C_FB

Input

BOOL

I, Q, M, D, L o
constante

Entrada de realimentaci√≥n al
cerrar

OO

Output

BOOL

I, Q, M, D, L

Salida "Abrir"

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2191

Instrucciones
4.1 Instrucciones
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

CO

Output

BOOL

I, Q, M, D, L

Salida "Cerrar"

OA

Output

BOOL

I, Q, M, D, L

Salida de alarma al abrir

CA

Output

BOOL

I, Q, M, D, L

Salida de alarma al cerrar

Q

Output

BOOL

I, Q, M, D, L

El estado l√≥gico "0" indica
una condici√≥n de error

ET

Static

DINT

D, L o constante

Tiempo actual transcurrido;
un ciclo de reloj = 1 ms

PT

Static

DINT

D, L o constante

Valor de tiempo predetermi‚Äê
nado; un ciclo de reloj = 1 ms

PREV_TIME

Static

DWORD

D, L o constante

Hora de sistema anterior

O_HIS

Static

BOOL

D, L o constante

Bit de evoluci√≥n "Abrir"

C_HIS

Static

BOOL

D, L o constante

Bit de evoluci√≥n "Cerrar"

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
Nota
Los par√°metros est√°ticos pueden inicializarse en el bloque de datos.

GRAPH
CALL MCAT, "MCAT_DB"
(O_CMD := "Tag_Input_O_CMD"
C_CMD := "Tag_Input_C_CMD"
S_CMD := "Tag_Input_S_CMD"
O_FB := "Tag_Input_O_FB"
C_FB := "Tag_Input_C_FB"
OO => "Tag_OutputOpen"
CO => "Tag_OutputClosed"
OA => "Tag_Output_OA"
CA => "Tag_Output_CA"
Q => "Tag_Output_Q"
)

Las tablas siguientes muestran el funcionamiento de la instrucci√≥n con valores concretos.

Antes de la ejecuci√≥n
En este ejemplo se utilizan los siguientes valores para los par√°metros de entrada y salida:

2192

Par√°metro

Operando

Valor

O_CMD

Tag_Input_O_CMD

TRUE

C_CMD

Tag_Input_C_CMD

FALSE

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Operando

Valor

S_CMD

Tag_Input_S_CMD

FALSE

O_FB

Tag_Input_O_FB

FALSE

C_FB

Tag_Input_C_FB

FALSE

OO

Tag_OutputOpen

FALSE

CO

Tag_OutputClosed

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Q

Tag_Output_Q

FALSE

En el bloque de datos de instancia "MCAT_DB" de la instrucci√≥n se guardan los siguientes
valores:
Par√°metro

Direcci√≥n

Valor

ET

DBD4

L#2

PT

DBD8

L#22

O_HIS

DBX16.0

TRUE

C_HIS

DBX16.1

FALSE

Despu√©s de la ejecuci√≥n
Una vez ejecutada la instrucci√≥n, los valores siguientes se escriben en los par√°metros de
salida:
Par√°metro

Operando

Valor

OO

Tag_OutputOpen

TRUE

CO

Tag_OutputClosed

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Q

Tag_Output_Q

TRUE

En el bloque de datos de instancia "MCAT_DB" de la instrucci√≥n se guardan los siguientes
valores:
Par√°metro

Direcci√≥n

Valor

ET

DBD4

L#0

O_HIS

DBX16.0

TRUE

CMD_HIS

DBX16.1

FALSE

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2193

Instrucciones
4.1 Instrucciones

IMC: Comparar bits de entrada con bits de una m√°scara
Descripci√≥n
La instrucci√≥n "Comparar bits de entrada con bits de una m√°scara" compara el estado l√≥gico
de hasta 16 bits de entrada programados (IN_BIT0 a IN_BIT15) con el bit correspondiente de
una m√°scara. Es posible programar como m√°ximo 16 pasos con m√°scaras. El valor del
par√°metro IN_BIT0 se compara con el valor de la m√°scara CMP_VAL[x,0], siendo "x" el
n√∫mero del paso. El n√∫mero del paso de la m√°scara utilizada para la comparaci√≥n se define en
el par√°metro CMP_STEP. De esta misma manera se comparan todos los valores
programados. Los bits de entrada no programados o los bits no programados de la m√°scara
tienen el estado l√≥gico predeterminado FALSE.
Si se encuentra una correspondencia al realizar la comparaci√≥n, el estado l√≥gico del par√°metro
OUT se pone a "1". De lo contrario, el par√°metro OUT se pone a "0".
Si el valor del par√°metro CMP_STEP es mayor que 15, no se ejecuta la instrucci√≥n. En el
par√°metro ERR_CODE se emite un mensaje de error.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:

2194

Par√°me‚Äê
tro

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN_BIT0

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 0 se compara
con el bit 0 de la m√°scara.

IN_BIT1

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 1 se compara
con el bit 1 de la m√°scara.

IN_BIT2

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 2 se compara
con el bit 2 de la m√°scara.

IN_BIT3

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 3 se compara
con el bit 3 de la m√°scara.

IN_BIT4

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 4 se compara
con el bit 4 de la m√°scara.

IN_BIT5

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 5 se compara
con el bit 5 de la m√°scara.

IN_BIT6

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 6 se compara
con el bit 6 de la m√°scara.

IN_BIT7

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 7 se compara
con el bit 7 de la m√°scara.

IN_BIT8

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 8 se compara
con el bit 8 de la m√°scara.

IN_BIT9

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 9 se compara
con el bit 9 de la m√°scara.

IN_BIT10

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 10 se compa‚Äê
ra con el bit 10 de la m√°scara.

IN_BIT11

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 11 se compa‚Äê
ra con el bit 11 de la m√°scara.

IN_BIT12

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 12 se compa‚Äê
ra con el bit 12 de la m√°scara.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°me‚Äê
tro

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN_BIT13

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 13 se compa‚Äê
ra con el bit 13 de la m√°scara.

IN_BIT14

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 14 se compa‚Äê
ra con el bit 14 de la m√°scara.

IN_BIT15

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 15 se compa‚Äê
ra con el bit 15 de la m√°scara.

CMP_ST
EP

Input

BYTE

I, Q, M, D, L, P o constante

N√∫mero de paso de la m√°sca‚Äê
ra con la que se compara.

OUT

Output

BOOL

I, Q, M, D, L

El estado l√≥gico "1" indica que
se ha encontrado una corres‚Äê
pondencia.
El estado l√≥gico "0" indica que
no se ha encontrado ninguna
correspondencia.

ERR_CO
DE

Output

WORD

I, Q, M, D, L, P

Informaci√≥n de error

CMP_VA
L

Static

ARRAY OF
WORD

I, Q, M, D, L o constante

M√°scaras de comparaci√≥n [0
a 15, 0 a 15]: El primer n√∫mero
del √≠ndice es el n√∫mero de la
etapa y, el segundo, el n√∫me‚Äê
ro de bit de la m√°scara.

Par√°metro ERR_CODE
La tabla siguiente muestra el significado de los valores del par√°metro ERR_CODE:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

000A

El valor del par√°metro CMP_STEP es mayor que 15.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
En el ejemplo siguiente se comparan todos los 16 bits de entrada con la m√°scara para el paso
2. El estado l√≥gico del par√°metro OUT se pone a TRUE porque los bits de entrada concuerdan
con la m√°scara para el paso 2.
Nota
Los par√°metros est√°ticos pueden inicializarse en el bloque de datos.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2195

Instrucciones
4.1 Instrucciones

GRAPH
CALL IMC, "IMC_DB"
(IN_BIT0 - 15 := "Tag_Input_BITn"
CMP_STEP := "Tag_CMP_STEP"
OUT => "Tag_Output"
ERR_CODE => "Tag_ErrorCode"
)

Las tablas siguientes muestran el funcionamiento de la instrucci√≥n con valores concretos.

Antes de la ejecuci√≥n
En este ejemplo se utilizan los siguientes valores para los par√°metros de entrada y salida:
Par√°metro

Operando

Valor

IN_BIT0

Tag_Input_BIT0

TRUE

IN_BIT1

Tag_Input_BIT1

TRUE

IN_BIT2

Tag_Input_BIT2

FALSE

IN_BIT3

Tag_Input_BIT3

TRUE

IN_BIT4

Tag_Input_BIT4

TRUE

IN_BIT5

Tag_Input_BIT5

FALSE

IN_BIT6

Tag_Input_BIT6

TRUE

IN_BIT7

Tag_Input_BIT7

TRUE

IN_BIT8

Tag_Input_BIT8

FALSE

IN_BIT9

Tag_Input_BIT9

TRUE

IN_BIT10

Tag_Input_BIT10

TRUE

IN_BIT11

Tag_Input_BIT11

FALSE

IN_BIT12

Tag_Input_BIT12

TRUE

IN_BIT13

Tag_Input_BIT13

TRUE

IN_BIT14

Tag_Input_BIT14

FALSE

IN_BIT15

Tag_Input_BIT15

TRUE

CMP_STEP

Tag_CMP_STEP

B#16#02

OUT

Tag_Output

FALSE

ERR_CODE

Tag_ErrorCode

W#16#0000

En el bloque de datos de instancia "IMC_DB" de la instrucci√≥n est√°n almacenados los
siguientes valores para la m√°scara del paso 2:

2196

Par√°metro

Direcci√≥n

Valor

CMP_VAL [2,0]

DBX12.0

TRUE

CMP_VAL [2,1]

DBX12.1

TRUE

CMP_VAL [2,2]

DBX12.2

FALSE

CMP_VAL [2,3]

DBX12.3

TRUE

CMP_VAL [2,4]

DBX12.4

TRUE

CMP_VAL [2,5]

DBX12.5

FALSE

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Direcci√≥n

Valor

CMP_VAL [2,6]

DBX12.6

TRUE

CMP_VAL [2,7]

DBX12.7

TRUE

CMP_VAL [2,8]

DBX13.0

FALSE

CMP_VAL [2,0]

DBX13.1

TRUE

CMP_VAL [2,10]

DBX13.2

TRUE

CMP_VAL [2,11]

DBX13.3

FALSE

CMP_VAL [2,12]

DBX13.4

TRUE

CMP_VAL [2,13]

DBX13.5

TRUE

CMP_VAL [2,14]

DBX13.6

FALSE

CMP_VAL [2,15]

DBX13.7

TRUE

Despu√©s de la ejecuci√≥n
Una vez ejecutada la instrucci√≥n, los valores siguientes se escriben en los par√°metros de
salida:
Par√°metro

Operando

Valor

OUT

Tag_Output

TRUE

ERR_CODE

Tag_ErrorCode

W#16#0000

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

SMC: Barrido de matriz
Descripci√≥n
La instrucci√≥n "Barrido de matriz" compara el estado l√≥gico de hasta 16 bits de entrada
programados (IN_BIT0 a IN_BIT15) con los bits correspondientes de las m√°scaras de
comparaci√≥n de cada paso. La ejecuci√≥n empieza por el paso 1 y contin√∫a hasta el √∫ltimo paso
programado (LAST) o hasta que se encuentre una correspondencia. El bit de entrada del
par√°metro IN_BIT0 se compara con el valor de la m√°scara CMP_VAL[x,0], siendo "x" el
n√∫mero de paso. De esta misma manera se comparan todos los valores programados. Si se
encuentra una correspondencia, el estado l√≥gico del par√°metro OUT se pone a "1" y el n√∫mero
de paso se escribe con la m√°scara correspondiente en el par√°metro OUT_STEP. Los bits de
entrada no programados o los bits no programados de la m√°scara tienen el estado l√≥gico
predeterminado FALSE. Si varios pasos tienen una m√°scara equivalente, se indica solo la
primera correspondencia encontrada en el par√°metro OUT_STEP. Si no se encuentra ninguna
correspondencia, el estado l√≥gico del par√°metro OUT se pone a "0". En este caso, el valor del
par√°metro OUT_STEP excede en "1" el valor del par√°metro LAST.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2197

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°me‚Äê
tro

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN_BIT0

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 0 se compara
con el bit 0 de la m√°scara.

IN_BIT1

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 1 se compara
con el bit 1 de la m√°scara.

IN_BIT2

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 2 se compara
con el bit 2 de la m√°scara.

IN_BIT3

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 3 se compara
con el bit 3 de la m√°scara.

IN_BIT4

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 4 se compara
con el bit 4 de la m√°scara.

IN_BIT5

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 5 se compara
con el bit 5 de la m√°scara.

IN_BIT6

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 6 se compara
con el bit 6 de la m√°scara.

IN_BIT7

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 7 se compara
con el bit 7 de la m√°scara.

IN_BIT8

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 8 se compara
con el bit 8 de la m√°scara.

IN_BIT9

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 9 se compara
con el bit 9 de la m√°scara.

IN_BIT10

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 10 se compa‚Äê
ra con el bit 10 de la m√°scara.

IN_BIT11

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 11 se compa‚Äê
ra con el bit 11 de la m√°scara.

IN_BIT12

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 12 se compa‚Äê
ra con el bit 12 de la m√°scara.

IN_BIT13

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 13 se compa‚Äê
ra con el bit 13 de la m√°scara.

IN_BIT14

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 14 se compa‚Äê
ra con el bit 14 de la m√°scara.

IN_BIT15

Input

BOOL

I, Q, M, D, L o constante

El bit de entrada 15 se compa‚Äê
ra con el bit 15 de la m√°scara.

OUT

Output

BOOL

I, Q, M, D, L

El estado l√≥gico "1" indica que
se ha encontrado una corres‚Äê
pondencia.
El estado l√≥gico "0" indica que
no se ha encontrado ninguna
correspondencia.

ERR_CO
DE

2198

Output

WORD

I, Q, M, D, L, P

Informaci√≥n de error

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°me‚Äê
tro

Declara‚Äê
ci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

OUT_ST
EP

Output

BYTE

I, Q, M, D, L, P

Contiene el n√∫mero de paso
con la m√°scara correspon‚Äê
diente o el n√∫mero de paso
que excede en "1" el valor del
par√°metro LAST, si no se ha
encontrado ninguna corres‚Äê
pondencia.

LAST

Static

BYTE

I, Q, M, D, L, P o constante

Indica el n√∫mero del √∫ltimo pa‚Äê
so en que se tiene que buscar
una m√°scara correspondiente.

CMP_VA
L

Static

ARRAY OF
WORD

I, Q, M, D, L o constante

M√°scaras de comparaci√≥n [0
a 15, 0 a 15]: El primer n√∫mero
del √≠ndice es el n√∫mero de la
etapa y, el segundo, el n√∫me‚Äê
ro de bit de la m√°scara.

Par√°metro ERR_CODE
La tabla siguiente muestra el significado de los valores del par√°metro ERR_CODE:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

000E

El valor del par√°metro LAST es mayor que 15.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
En el ejemplo siguiente, todos los 16 bits de entrada se comparan con la m√°scara para los
pasos 0 a 5 hasta que se encuentre una correspondencia. Se consultan √∫nicamente las
m√°scaras para los pasos 0 a 2, ya que la m√°scara para el paso 2 se corresponde con el bit de
entrada.
Nota
Los par√°metros est√°ticos pueden inicializarse en el bloque.

GRAPH
CALL SMC, "SMC_DB"
(IN_BIT0 - 15 := "Tag_Input_BITn"
OUT => "Tag_Output"
OUT_STEP => "Tag_Output_STEP"
ERR_CODE => "Tag_ErrorCode"

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2199

Instrucciones
4.1 Instrucciones
GRAPH
)

Las tablas siguientes muestran el funcionamiento de la instrucci√≥n con valores concretos.

Antes de la ejecuci√≥n
En este ejemplo se utilizan los siguientes valores para los par√°metros de entrada y salida:
Par√°metro

Operando

Valor

IN_BIT0

Tag_Input_BIT0

TRUE

IN_BIT1

Tag_Input_BIT1

TRUE

IN_BIT2

Tag_Input_BIT2

FALSE

IN_BIT3

Tag_Input_BIT3

TRUE

IN_BIT4

Tag_Input_BIT4

TRUE

IN_BIT5

Tag_Input_BIT5

FALSE

IN_BIT6

Tag_Input_BIT6

TRUE

IN_BIT7

Tag_Input_BIT7

TRUE

IN_BIT8

Tag_Input_BIT8

FALSE

IN_BIT9

Tag_Input_BIT9

TRUE

IN_BIT10

Tag_Input_BIT10

TRUE

IN_BIT11

Tag_Input_BIT11

FALSE

IN_BIT12

Tag_Input_BIT12

TRUE

IN_BIT13

Tag_Input_BIT13

TRUE

IN_BIT14

Tag_Input_BIT14

FALSE

IN_BIT15

Tag_Input_BIT15

TRUE

OUT

Tag_Output

FALSE

OUT_STEP

Tag_Output_STEP

B#16#00

ERR_CODE

Tag_ErrorCode

W#16#0000

En el bloque de datos de instancia "SMC_DB" de la instrucci√≥n est√°n almacenados los
siguientes valores para la m√°scara del paso 2:

2200

Par√°metro

Direcci√≥n

Valor

CMP_VAL [2,0]

DBX12.0

TRUE

CMP_VAL [2,1]

DBX12.1

TRUE

CMP_VAL [2,2]

DBX12.2

FALSE

CMP_VAL [2,3]

DBX12.3

TRUE

CMP_VAL [2,4]

DBX12.4

TRUE

CMP_VAL [2,5]

DBX12.5

FALSE

CMP_VAL [2,6]

DBX12.6

TRUE

CMP_VAL [2,7]

DBX12.7

TRUE

CMP_VAL [2,8]

DBX13.0

FALSE

CMP_VAL [2,0]

DBX13.1

TRUE

CMP_VAL [2,10]

DBX13.2

TRUE

CMP_VAL [2,11]

DBX13.3

FALSE

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Par√°metro

Direcci√≥n

Valor

CMP_VAL [2,12]

DBX13.4

TRUE

CMP_VAL [2,13]

DBX13.5

TRUE

CMP_VAL [2,14]

DBX13.6

FALSE

CMP_VAL [2,15]

DBX13.7

TRUE

LAST

DB84

B#16#05

Despu√©s de la ejecuci√≥n
Una vez ejecutada la instrucci√≥n, los valores siguientes se escriben en los par√°metros de
salida:
Par√°metro

Operando

Valor

OUT

Tag_Output

TRUE

OUT_STEP

Tag_Output_STEP

B#16#02

ERR_CODE

Tag_ErrorCode

W#16#0000

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

LEAD_LAG: Algoritmo Lead y Lag
Descripci√≥n
La instrucci√≥n "Algoritmo Lead y Lag" procesa se√±ales con una variable anal√≥gica. El valor de
la ganancia del par√°metro GAIN debe ser mayor que cero. El resultado de la instrucci√≥n
"Algoritmo Lead y Lag" se calcula con la siguiente ecuaci√≥n:
287

/*B7,0(
/'B7,0(6$03/(B7
/'B7,0(
,1*$,1
35(9B287*$,1
/*B7,0(6$03/(B7
/*B7,0(6$03/(B7
/*B7,0(6$03/(B7

35(9B,1

La instrucci√≥n "Algoritmo Lead y Lag" s√≥lo devuelve resultados relevantes cuando se ejecuta
en ciclos de programa fijos. Deben indicarse las mismas unidades en los par√°metros
LD_TIME, LG_TIME y SAMPLE_T. Si LG_TIME > 4 + SAMPLE_T, la instrucci√≥n se aproxima
a la siguiente funci√≥n:
OUT = GAIN * ((1 + LD_TIME * s) / (1 + LG_TIME * s)) * IN
Si el valor del par√°metro GAIN es menor o igual a cero, no se realiza el c√°lculo y el par√°metro
ERR_CODE devuelve una informaci√≥n de error.
La instrucci√≥n "Algoritmo Lead y Lag" puede utilizarse junto con bucles para la compensaci√≥n
en el control anticipativo. La instrucci√≥n comprende dos operaciones. La operaci√≥n "Lead"
desplaza la fase de la salida OUT, anticip√°ndose la salida a la entrada. En cambio, la operaci√≥n
"Lag" desplaza la salida, de manera que la salida sigue a la entrada. Puesto que la operaci√≥n

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2201

Instrucciones
4.1 Instrucciones
"Lag" equivale a una integraci√≥n, puede utilizarse para suprimir perturbaciones o como filtro
pasa bajo. La operaci√≥n "Lead" equivale a una acci√≥n diferencial, por lo que puede utilizarse
como un filtro de paso alto. La combinaci√≥n de ambas operaciones (Lead y Lag) hace que la
fase de salida siga a la entrada a bajas frecuencias y se le anticipe a altas frecuencias. Por este
motivo, la instrucci√≥n "Algoritmo Lead y Lag" puede utilizarse como si fuera un filtro de paso de
banda.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:

2202

Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

REAL

I, Q, M, D, L, P o
constante

Valor de entrada
del tiempo de
muestreo actual
(tiempo de ciclo)
que se procesa.

SAMPLE_T

Input

INT

I, Q, M, D, L, P o
constante

Tiempo de mues‚Äê
treo

OUT

Output

REAL

I, Q, M, D, L, P

Resultado de la
instrucci√≥n

ERR_CODE

Output

WORD

I, Q, M, D, L, P

Informaci√≥n de
error

LD_TIME

Static

REAL

I, Q, M, D, L, P o
constante

Tiempo de antici‚Äê
paci√≥n en la mis‚Äê
ma unidad que el
tiempo de mues‚Äê
treo.

LG_TIME

Static

REAL

I, Q, M, D, L, P o
constante

Tiempo de segui‚Äê
miento en la mis‚Äê
ma unidad que el
tiempo de mues‚Äê
treo.

GAIN

Static

REAL

I, Q, M, D, L, P o
constante

Ganancia en % /
% (relaci√≥n del
cambio en la sali‚Äê
da con respecto al
cambio en la entra‚Äê
da como estado
constante).

PREV_IN

Static

REAL

I, Q, M, D, L, P o
constante

Entrada anterior

PREV_OUT

Static

REAL

I, Q, M, D, L, P o
constante

Salida anterior

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metro ERR_CODE
La tabla siguiente muestra el significado de los valores del par√°metro ERR_CODE:
C√≥digo de
error*
(W#16#...)

Explicaci√≥n

0000

Ning√∫n error

0009

El valor del par√°metro GAIN es menor o igual a cero.

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
Nota
Los par√°metros est√°ticos pueden inicializarse en el bloque de datos.

GRAPH
CALL LEAD_LAG, "LEAD_LAG_DB"
(IN := "Tag_Input"
SAMPLE_T := "Tag_Input_SAMPLE_T"
OUT => "Tag_Output_Result"
ERR_CODE => "Tag_ErrorCode"
)

Las tablas siguientes muestran el funcionamiento de la instrucci√≥n con valores concretos.

Antes de la ejecuci√≥n
En este ejemplo se utilizan los siguientes valores para los par√°metros de entrada:
Par√°metro

Operando

Valor

IN

Tag_Input

2.0

SAMPLE_T

Tag_Input_SAMPLE_T

10

En el bloque de datos de instancia "LEAD_LAG_DB" de la instrucci√≥n se guardan los
siguientes valores:
Par√°metro

Direcci√≥n

Valor

LD_TIME

DBD12

2.0

LG_TIME

DBD16

2.0

GAIN

DBD20

1.0

PREV_IN

DBD24

6.0

PREV_OUT

DBD28

6.0

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2203

Instrucciones
4.1 Instrucciones

Despu√©s de la ejecuci√≥n
Una vez ejecutada la instrucci√≥n, los valores siguientes se escriben en los par√°metros de
salida:
Par√°metro

Operando

Valor

OUT

Tag_Output_Result

2.0

En el bloque de datos de instancia "LEAD_LAD_DB" de la instrucci√≥n se guardan los
siguientes valores:
Par√°metro

Operando

Valor

PREV_IN

DBD24

2.0

PREV_OUT

DBD28

2.0

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

SEG: Generar patr√≥n de bits para el display de 7 segmentos
Descripci√≥n
La instrucci√≥n "Generar patr√≥n de bits para el display de 7 segmentos" convierte cada una de
las cuatro cifras hexadecimales de la palabra de origen indicada (IN) en cuatro c√≥digos
equivalentes para un display de 7 segmentos y los escribe en la palabra doble de la salida
(OUT).
La instrucci√≥n no detecta condiciones de error.

2204

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Entre los valores de entrada hexadecimales y los patrones de bits de la salida existe la relaci√≥n
siguiente:
Cifra

-gfedcba

Display

0000

00111111

0

0001

00000110

1

0010

01011011

2

0011

01001111

3

0100

01100110

4

0101

01101101

5

0110

01111101

6

0111

00000111

7

1000

01111111

8

1001

01100111

9

1010

01110111

A

1011

01111100

B

1100

00111001

C

1101

01011110

D

1110

01111001

E

1111

01110001

F

Display de siete segmentos
D
I

E
J

H

F
G

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

WORD

I, Q, M, D, L, P o
constante

Palabra de origen
con cuatro cifras
hexadecimales

OUT

Output

DWORD

I, Q, M, D, L, P

Patr√≥n de bits del
destino con cuatro
bytes

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL SEG
(IN := "Tag_Input"
OUT => "Tag_Output"
)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2205

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores concretos:
Par√°metro

Operando

Valor

Hexadecimal

Binario

IN

Tag_Input

W#16#1234

0001 0010 0011 0100

OUT

Tag_Output

DW#16065B4F66

000 00110 0101 1011 0100
1111 0110 0110
Visualizaci√≥n: 1234

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

BCDCPL: Generar complemento a diez
Descripci√≥n
La instrucci√≥n "Generar complemento a diez" crea el complemento a diez de un n√∫mero BCD
de siete d√≠gitos que se indica en el par√°metro IN. La instrucci√≥n realiza el c√°lculo con la
siguiente f√≥rmula matem√°tica:
10000000 (como BCD)
‚Äì Valor BCD de 7 d√≠gitos
---------------------------------------Complemento a diez (como BCD)

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

IN

Input

Secuencias de bits I, Q, M, D, L, P o
constante

N√∫mero BCD de 7
d√≠gitos

ERR_CODE

Output

DWORD

Resultado de la
instrucci√≥n

I, Q, M, D, L, P

Descripci√≥n

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL BCDCPL
(IN := "Tag_Input"

2206

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
GRAPH
ERR_CODE => "Tag_Output"
)

La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores concretos:
Par√°metro

Operando

Valor*

IN

Tag_Input

DW#16#01234567

ERR_CODE

Tag_Output

DW#16#08765433

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)
Principios b√°sicos de GRAPH (P√°gina 8191)

BITSUM: Contar n√∫mero de bits activados
Descripci√≥n
La instrucci√≥n "Contar n√∫mero de bits activados" cuenta el n√∫mero de bits de un operando que
est√°n puestos al estado l√≥gico "1". El operando cuyos bits se cuentan se especifica en el
par√°metro IN. El resultado de la instrucci√≥n se devuelve en el par√°metro RET_VAL.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n:
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN

Input

DWORD

I, Q, M, D, L, P o
constante

Operando cuyos bits activa‚Äê
dos se cuentan

RET_VAL

Output

INT

I, Q, M, D, L, P

N√∫mero de bits activados

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucci√≥n:
GRAPH
CALL BITSUM
(IN := "Tag_Input"
RET_VAL => "Tag_Output"
)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2207

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucci√≥n con valores concretos:
Par√°metro

Operando

Valor*

IN

Tag_Input

DW#16#12345678

RET_VAL

Tag_Output

W#16#000D (13 bits)

*En el editor de programas, los c√≥digos de error se pueden representar como valores enteros o hexa‚Äê
decimales. Encontrar√° m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte
tambi√©n".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de GRAPH (P√°gina 8191)

Instrucciones KOP en GRAPH
Instrucciones KOP generales en GRAPH
Descripci√≥n
Para la programaci√≥n en GRAPH se dispone de diferentes instrucciones KOP.
La tabla siguiente ofrece una vista general de las instrucciones y su disponibilidad:
Instrucciones KOP

Instruc‚Äê Transici√≥n /
ci√≥n per‚Äê Supervisi√≥n /
manente Interlock

General
Insertar segmento

x

Cuadro vac√≠o

x

x

Abrir rama

x

x

Cerrar rama

x

x

-|: Insertar entrada

x

Operaciones l√≥gicas con bits

2208

---| |---: Contacto normalmente abierto (P√°gina 621)

x

x

---| / |---: Contacto normalmente cerrado (P√°gina 623)

x

x

--| NOT |--: Invertir RLO (P√°gina 624)

x

x

---( )---: Asignaci√≥n (P√°gina 625)

x

---( / )---: Negar asignaci√≥n (P√°gina 626)

x

---( R )---: Desactivar salida (P√°gina 626)

x

---( S )---: Activar salida (P√°gina 627)

x

SET_BF: Activar mapa de bits (P√°gina 628)

x

RESET_BF: Desactivar mapa de bits (P√°gina 630)

x

SR: Flipflop de activaci√≥n/desactivaci√≥n (P√°gina 631)

x

RS: Flipflop de desactivaci√≥n/activaci√≥n (P√°gina 632)

x

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instrucciones KOP

Instruc‚Äê Transici√≥n /
ci√≥n per‚Äê Supervisi√≥n /
manente Interlock

--|P|--: Consultar flanco de se√±al ascendente de un operando (P√°gina 634)

x

--|N|--: Consultar flanco de se√±al descendente de un operando (P√°gina 635) x
--(P)--: Activar operando con flanco de se√±al ascendente (P√°gina 637)

x

--(N)--: Activar operando con flanco de se√±al descendente (P√°gina 638)

x

P_TRIG: Consultar flanco de se√±al ascendente del RLO (P√°gina 639)

x

N_TRIG: Consultar flanco de se√±al descendente del RLO (P√°gina 641)

x

R_TRIG: Detectar flanco de se√±al ascendente (P√°gina 642)

x

F_TRIG: Detectar flanco de se√±al descendente (P√°gina 643)

x

Temporizadores
Temporizadores CEI
TP: Impulso (P√°gina 644)

x

TON: Retardo al conectar (P√°gina 649)

x

TOF: Retardo al desconectar (P√°gina 653)

x

TONR: Acumulador de tiempo (P√°gina 657)

x

---(TP)---: Arrancar temporizador como impulso (P√°gina 662)

x

---(TON)---: Arrancar temporizador como retardo a la conexi√≥n (P√°gina 666) x
---(TOF)---: Arrancar temporizador como retardo a la desconexi√≥n (P√°gi‚Äê
na 670)

x

---(TONR)---: Acumulador de tiempo (P√°gina 674)

x

---(RT)---: Inicializar temporizador (P√°gina 678)

x

---(PT)---: Cargar tiempo (P√°gina 680)

x

Temporizadores SIMATIC (S7-1500)
S_PULSE: Parametrizar y arrancar temporizador como impulso (P√°gina 683) x
S_PEXT: Parametrizar y arrancar temporizador como impulso prolongado
(P√°gina 686)

x

S_ODT: Parametrizar y arrancar temporizador como retardo a la conexi√≥n
(P√°gina 689)

x

S_ODTS: Parametrizar y arrancar temporizador como retardo a la conexi√≥n
con memoria (P√°gina 692)

x

S_OFFDT: Parametrizar y arrancar temporizador como retardo a la desco‚Äê
nexi√≥n (P√°gina 694)

x

Contadores
Contadores CEI
CTU: Contador ascendente (P√°gina 707)

x

CTD: Contador descendente (P√°gina 710)

x

CTUD: Contador ascendente - descendente (P√°gina 712)

x

Contadores SIMATIC (S7-1500)
S_CU: Parametrizar e incrementar contador (P√°gina 716)

x

S_CD: Parametrizar y decrementar contador (P√°gina 718)

x

S_CUD: Parametrizar e incrementar/decrementar contador (P√°gina 720)

x

Comparaci√≥n
CMP ==: Igual (P√°gina 725)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

x

x

2209

Instrucciones
4.1 Instrucciones
Instrucciones KOP

Instruc‚Äê Transici√≥n /
ci√≥n per‚Äê Supervisi√≥n /
manente Interlock

CMP <>: Diferente (P√°gina 730)

x

x

CMP >=: Mayor o igual (P√°gina 735)

x

x

CMP <=: Menor o igual (P√°gina 738)

x

x

CMP >: Mayor (P√°gina 741)

x

x

CMP <: Menor (P√°gina 744)

x

x

IN_RANGE: Valor dentro del rango (P√°gina 747)

x

OUT_RANGE: Valor fuera del rango (P√°gina 748)

x

---| OK |---: Comprobar validez (P√°gina 749)

x

---| NOT_OK |---: Comprobar invalidez (P√°gina 750)

x

EQ_Type: Comparar si el tipo de datos es IGUAL al tipo de datos de una
variable (P√°gina 751)

x

NE_Type: Comparar si el tipo de datos es DIFERENTE del tipo de datos de
una variable (P√°gina 754)

x

EQ_ElemType: Comparar si el tipo de datos de un elemento del ARRAY es
IGUAL al tipo de datos de una variable (P√°gina 756)

x

NE_ElemType: Comprar si el tipo de datos de un elemento del ARRAY es
DIFERENTE al tipo de datos de una variable (P√°gina 758)

x

IS_NULL: Consultar si es un puntero IGUAL A CERO (P√°gina 759)

x

NOT_NULL: Consultar si es un puntero DIFERENTE DE CERO (P√°gina 761) x
IS_ARRAY: Consultar si es un ARRAY (P√°gina 762)

x

EQ_TypeOfDB: Comparar si el tipo de datos DB_ANY es IGUAL al tipo de
datos de una variable (P√°gina 763)

x

NE_TypeOfDB: Comparar si el tipo de datos DB_ANY es DIFERENTE del
tipo de datos de una variable (P√°gina 764)

x

CMP>T: Superior al tiempo de activaci√≥n de la etapa (P√°gina 2213)

x

CMP>U: Superior al tiempo de activaci√≥n ininterrumpido de la etapa (P√°gi‚Äê
na 2214)

x

Funciones matem√°ticas

2210

CALCULATE: Calcular (P√°gina 766)

x

ADD: Sumar (P√°gina 769)

x

SUB: Restar (P√°gina 771)

x

MUL: Multiplicar (P√°gina 772)

x

DIV: Dividir (P√°gina 773)

x

MOD: Obtener resto de divisi√≥n (P√°gina 775)

x

NEG: Generar complemento a dos (P√°gina 776)

x

INC: Incrementar (P√°gina 777)

x

DEC: Decrementar (P√°gina 778)

x

ABS: Calcular valor absoluto (P√°gina 780)

x

MIN: Determinar m√≠nimo (P√°gina 781)

x

MAX: Determinar m√°ximo (P√°gina 783)

x

LIMIT: Ajustar valor l√≠mite (P√°gina 784)

x

SQR: Calcular cuadrado (P√°gina 787)

x

SQRT: Calcular ra√≠z cuadrada (P√°gina 788)

x

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instrucciones KOP

Instruc‚Äê Transici√≥n /
ci√≥n per‚Äê Supervisi√≥n /
manente Interlock

LN: Calcular logaritmo natural (P√°gina 790)

x

EXP: Calcular valor exponencial (P√°gina 791)

x

SIN: Calcular valor de seno (P√°gina 792)

x

COS: Calcular valor de coseno (P√°gina 793)

x

TAN: Calcular valor de tangente (P√°gina 795)

x

ASIN: Calcular valor de arcoseno (P√°gina 796)

x

ACOS: Calcular valor de arcocoseno (P√°gina 798)

x

ATAN: Calcular valor de arcotangente (P√°gina 799)

x

FRAC: Determinar decimales (P√°gina 800)
EXPT: Elevar a potencia (P√°gina 802)

x

Transferencia
MOVE: Copiar valor (P√°gina 803)

x

Deserialize: Deserializar (P√°gina 809)

x

Serialize: Serializar (P√°gina 814)

x

FieldRead: Leer campo (P√°gina 879)

x

FieldWrite: Escribir campo (P√°gina 881)

x

MOVE_BLK: Copiar √°rea (P√°gina 820)

x

SCATTER: Dispersi√≥n de una secuencia de bits en bits individuales (P√°gi‚Äê
na 836)

x

SCATTER_BLK: Dispersi√≥n de elementos de un ARRAY of secuencia de
bits en bits individuales (P√°gina 841)

x

GATHER: Recopilaci√≥n de bits individuales en una secuencia de bits (P√°gi‚Äê x
na 845)
GATHER_BLK: Recopilaci√≥n de bits individuales en varios elementos de un
ARRAY of secuencia de bits (P√°gina 850)

x

MOVE_BLK_VARIANT: Copiar √°rea (P√°gina 822)

x

UMOVE_BLK: Copiar √°rea sin interrupciones (P√°gina 827)

x

FILL_BLK: Rellenar √°rea (P√°gina 829)

x

UFILL_BLK: Rellenar √°rea sin interrupciones (P√°gina 833)

x

?=: Intento de asignaci√≥n (P√°gina 854)

x

SWAP: Cambiar disposici√≥n (P√°gina 857)

x

ReadFromArrayDB: Leer desde bloque de datos de array (P√°gina 859)

x

WriteToArrayDB: Escribir en bloque de datos de array (P√°gina 861)

x

ReadFromArrayDBL: Leer de bloque de datos de array de la memoria de
carga (P√°gina 864)

x

WriteToArrayDBL: Escribir en bloque de datos de array de la memoria de
carga (P√°gina 867)

x

VariantGet: Leer valor de una variable VARIANT (P√°gina 870)

x

VariantPut: Escribir valor en una variable VARIANT (P√°gina 872)

x

CountOfElements: Consultar n√∫mero de elementos de ARRAY (P√°gina 874) x
LOWER_BOUND: Leer l√≠mite inferior del ARRAY (P√°gina 876)

x

UPPER_BOUND: Leer l√≠mite superior del ARRAY (P√°gina 877)

x

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2211

Instrucciones
4.1 Instrucciones
Instrucciones KOP

Instruc‚Äê Transici√≥n /
ci√≥n per‚Äê Supervisi√≥n /
manente Interlock

BLKMOV: Copiar √°rea (S7-1500) (P√°gina 883)

x

UBLKMOV: Copiar √°rea sin interrupciones (S7-1500) (P√°gina 887)

x

FILL: Rellenar √°rea (S7-1500) (P√°gina 890)

x

Conversi√≥n
CONVERT: Convertir valor (P√°gina 893)

x

ROUND: Redondear n√∫mero (P√°gina 896)

x

CEIL: Redondear n√∫mero en coma flotante al siguiente entero superior (P√°‚Äê x
gina 897)
FLOOR: Redondear n√∫mero en coma flotante al siguiente entero inferior
(P√°gina 898)

x

TRUNC: Truncar a entero (P√°gina 900)

x

SCALE_X: Escalar (P√°gina 901)

x

NORM_X: Normalizar (P√°gina 904)

x

SCALE: Escalar (S7-1500) (P√°gina 906)

x

UNSCALE: Desescalar (S7-1500) (P√°gina 908)

x

Control del programa
Control en runtime
ENDIS_PW: Limitar y habilitar legitimaci√≥n de la contrase√±a (P√°gina 920)

x

RE_TRIGR: Reiniciar tiempo de vigilancia del ciclo (P√°gina 927)

x

STP: Finalizar programa (P√°gina 928)

x

GET_ERROR: Consultar error localmente (P√°gina 928)

x

GET_ERR_ID: Consultar ID de error localmente (P√°gina 933)

x

INIT_RD: Inicializar todos los datos remanentes (P√°gina 936)

x

WAIT: Programar retardo (P√°gina 937)

x

RUNTIME: Medir tiempo de ejecuci√≥n (P√°gina 940)

x

Operaciones l√≥gicas con palabras
AND: Operaci√≥n l√≥gica Y (P√°gina 942)

x

OR: Operaci√≥n l√≥gica O (P√°gina 944)

x

XOR: Operaci√≥n l√≥gica O-exclusiva (P√°gina 945)

x

INV: Generar complemento a 1 (P√°gina 947)

x

DECO: Descodificar (P√°gina 948)

x

ENCO: Codificar (P√°gina 949)

x

SEL: Seleccionar (P√°gina 951)

x

MUX: Multiplexar (P√°gina 953)

x

DEMUX: Desmultiplexar (P√°gina 956)

x

Desplazamiento y rotaci√≥n
SHR: Desplazar a la derecha (P√°gina 959)

x

SHL: Desplazar a la izquierda (P√°gina 961)

x

ROR: Rotar a la derecha (P√°gina 963)

x

ROL: Rotar a la izquierda (P√°gina 965)

x

Otras instrucciones
DRUM: Materializar circuito secuencial sucesivo (P√°gina 967)

2212

x

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instrucciones KOP

Instruc‚Äê Transici√≥n /
ci√≥n per‚Äê Supervisi√≥n /
manente Interlock

DCAT: Alarma de tiempo para control discreto (P√°gina 974)

x

MCAT: Alarma de tiempo para control del motor (P√°gina 977)

x

IMC: Comparar los bits de entrada con los bits de la m√°scara (P√°gina 981)

x

SMC: Barrido de matriz (P√°gina 983)

x

LEAD_LAG: Algoritmo Lead y Lag (P√°gina 985)

x

SEG: Generar patr√≥n de bits para el display de 7 segmentos (P√°gina 988)

x

BCDCPL: Generar complemento a diez (P√°gina 990)

x

BITSUM: Contar n√∫mero de bits activados (P√°gina 992)

x

CMP>T: Superior al tiempo de activaci√≥n de la etapa
Descripci√≥n
Con la instrucci√≥n "Superior al tiempo de activaci√≥n de la etapa" se vigila la duraci√≥n total de
una etapa en condiciones de supervisi√≥n. De esta manera se registra el tiempo de los posibles
eventos o errores.
En la condici√≥n programada se compara el tiempo de activaci√≥n en curso o el √∫ltimo de una
etapa (operando1) con un tiempo definido (operando2) en milisegundos. Si se cumple la
condici√≥n de la comparaci√≥n, la instrucci√≥n devuelve el resultado l√≥gico (RLO) "1". Si la
condici√≥n de la comparaci√≥n no se cumple, la instrucci√≥n devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucci√≥n est√° "inactiva"
En las condiciones citadas a continuaci√≥n se aplica lo siguiente:
‚óè Antes de la instrucci√≥n "CMP >T: Superior al tiempo de activaci√≥n de la etapa" (con tipo de
datos STRING, WSTRING) se consulta una condici√≥n (p. ej. un contacto normalmente
abierto) en el segmento.
‚óè "Activar observaci√≥n" est√° activado.
‚óè Un nuevo resultado de la condici√≥n vuelve a poner el segmento a FALSE. De este modo,
la instrucci√≥n "CMP >T: Superior al tiempo de activaci√≥n de la etapa" est√° inactiva.
Resultado:
Para la instrucci√≥n "CMP >T: Superior al tiempo de activaci√≥n de la etapa" (tipo de datos
STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observaci√≥n" o se desplaza a otro segmento, se mostrar√°
de nuevo el estado correcto de la instrucci√≥n "CMP >T: Superior al tiempo de activaci√≥n de la
etapa" (tipo de datos STRING, WSTRING). La instrucci√≥n "CMP >T: Superior al tiempo de
activaci√≥n de la etapa" se muestra atenuada en el segmento cuando est√° inactiva.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2213

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Superior al tiempo de activaci√≥n
de la etapa":
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operan‚Äê
do1>

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activaci√≥n actual
o √∫ltimo de la etapa

<Operan‚Äê
do2>

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‚Äê
ra

Ejemplo
El siguiente ejemplo muestra la instrucci√≥n en el segmento:
67(37
!
7,0(
706

Mientras el tiempo de activaci√≥n de #STEP1.T est√© por debajo de 100 ms, el RLO ser√° "0". En
cuanto el tiempo de activaci√≥n sobrepasa 100 ms, el RLO cambia a "1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

CMP>U: Superior al tiempo de activaci√≥n ininterrumpido de la etapa
Descripci√≥n
Con la instrucci√≥n "Superior al tiempo de activaci√≥n ininterrumpido de la etapa", se vigila la
duraci√≥n de una etapa, sin tener en cuenta las posibles aver√≠as, en condiciones de supervisi√≥n.
No se registra el tiempo de posibles eventos o fallos sino que se supervisa la duraci√≥n de la
mera etapa.

2214

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En la condici√≥n programada se compara todo el tiempo de activaci√≥n de la etapa (operando1)
con un tiempo definido (operando2) en milisegundos. Si se cumple la condici√≥n de la
comparaci√≥n, la instrucci√≥n devuelve el resultado l√≥gico (RLO) "1". Si la condici√≥n de la
comparaci√≥n no se cumple, la instrucci√≥n devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucci√≥n est√° "inactiva"
En las condiciones citadas a continuaci√≥n se aplica lo siguiente:
‚óè Antes de la instrucci√≥n "CMP >U: Superior al tiempo de activaci√≥n ininterrumpido de la
etapa" (con tipo de datos STRING, WSTRING) se consulta una condici√≥n (p. ej. un contacto
normalmente abierto) en el segmento.
‚óè "Activar observaci√≥n" est√° activado.
‚óè Un nuevo resultado de la condici√≥n vuelve a poner el segmento a FALSE. De este modo,
la instrucci√≥n "CMP >U: Superior al tiempo de activaci√≥n ininterrumpido de la etapa" est√°
inactiva.
Resultado:
Para la instrucci√≥n "CMP >U: Superior al tiempo de activaci√≥n ininterrumpido de la etapa" (tipo
de datos STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observaci√≥n" o se desplaza a otro segmento, se mostrar√°
de nuevo el estado correcto de la instrucci√≥n "CMP >U: Superior al tiempo de activaci√≥n
ininterrumpido de la etapa" (tipo de datos STRING, WSTRING). La instrucci√≥n "CMP >U:
Superior al tiempo de activaci√≥n ininterrumpido de la etapa" se muestra atenuada en el
segmento cuando est√° inactiva.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Superior al tiempo de activaci√≥n
ininterrumpido de la etapa":
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operan‚Äê
do1>

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activaci√≥n actual
o √∫ltimo de la etapa sin con‚Äê
tar aver√≠as

<Operan‚Äê
do2>

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‚Äê
ra

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2215

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucci√≥n en el segmento:
67(38
!
7,0(
706

Mientras el tiempo de activaci√≥n de #STEP1.U, sin tener en cuenta las posibles aver√≠as, est√©
por debajo de 100 ms, el RLO ser√° igual a "0". En cuanto el tiempo de activaci√≥n sobrepasa
100 ms, el RLO cambia a "1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

CMP>T_MAX: Superior al tiempo m√°ximo de activaci√≥n de etapa
Descripci√≥n
Con la instrucci√≥n "Superior al tiempo m√°ximo de activaci√≥n de etapa" se vigila la duraci√≥n total
m√°xima de una etapa en condiciones de supervisi√≥n. De esta manera se registra el tiempo de
los posibles eventos o errores.
En la condici√≥n programada se compara el tiempo de activaci√≥n en curso o el √∫ltimo de una
etapa (operando1) con la duraci√≥n m√°xima (operando2) en milisegundos. Si se cumple la

2216

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
condici√≥n de la comparaci√≥n, la instrucci√≥n devuelve el resultado l√≥gico (RLO) "1". Si la
condici√≥n de la comparaci√≥n no se cumple, la instrucci√≥n devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucci√≥n est√° "inactiva"
En las condiciones citadas a continuaci√≥n se aplica lo siguiente:
‚óè Antes de la instrucci√≥n "CMP >T_MAX: Superior al tiempo m√°ximo de activaci√≥n de etapa"
(con tipo de datos STRING, WSTRING) se consulta una condici√≥n (p. ej. un contacto
normalmente abierto) en el segmento.
‚óè "Activar observaci√≥n" est√° activado.
‚óè Un nuevo resultado de la condici√≥n vuelve a poner el segmento a FALSE. De este modo,
la instrucci√≥n "CMP >T_MAX: Superior al tiempo m√°ximo de activaci√≥n de etapa" est√°
inactiva.
Resultado:
Para la instrucci√≥n "CMP >T_MAX: Superior al tiempo m√°ximo de activaci√≥n de etapa" (tipo de
datos STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observaci√≥n" o se desplaza a otro segmento, se mostrar√°
de nuevo el estado correcto de la instrucci√≥n "CMP >T_MAX: Superior al tiempo m√°ximo de
activaci√≥n de etapa" (tipo de datos STRING, WSTRING). La instrucci√≥n "CMP >T_MAX:
Superior al tiempo m√°ximo de activaci√≥n de etapa" se muestra atenuada en el segmento
cuando est√° inactiva.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Superior al tiempo m√°ximo de
activaci√≥n de etapa":
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operan‚Äê
do1>

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activaci√≥n actual
o √∫ltimo de la etapa

<Operan‚Äê
do2>

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‚Äê
ra

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2217

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucci√≥n en el segmento:
6WHS7
!
7,0(
6WHS7B0$;

Mientras el tiempo de activaci√≥n de #STEP1.T est√© por debajo del tiempo m√°ximo de
activaci√≥n de etapa de #Step1.T_MAX, el RLO ser√° "0". En cuanto el tiempo de activaci√≥n
sobrepasa el tiempo m√°ximo de activaci√≥n de etapa, el RLO cambia a "1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de la vigilancia del tiempo de etapa (P√°gina 8289)
Programar la vigilancia del tiempo de etapa (P√°gina 8290)
Principios b√°sicos de GRAPH (P√°gina 8191)

CMP>T_WARN: Superior al tiempo de advertencia
Descripci√≥n
Con la instrucci√≥n "Superior al tiempo de advertencia" se vigila la duraci√≥n de una etapa en
condiciones de supervisi√≥n y, si se excede el tiempo, se emite una alarma. De esta manera se
registra el tiempo de los posibles eventos o errores.
En la condici√≥n programada se compara el tiempo de activaci√≥n en curso o el √∫ltimo de una
etapa (operando1) con un tiempo definido (operando2) en milisegundos. Si se cumple la

2218

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
condici√≥n de la comparaci√≥n, la instrucci√≥n devuelve el resultado l√≥gico (RLO) "1" y se emite
una alarma. Si la condici√≥n de la comparaci√≥n no se cumple, la instrucci√≥n devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucci√≥n est√° "inactiva"
En las condiciones citadas a continuaci√≥n se aplica lo siguiente:
‚óè Antes de la instrucci√≥n "CMP >T_WARN: Superior al tiempo de advertencia" (con tipo de
datos STRING, WSTRING) se consulta una condici√≥n (p. ej. un contacto normalmente
abierto) en el segmento.
‚óè "Activar observaci√≥n" est√° activado.
‚óè Un nuevo resultado de la condici√≥n vuelve a poner el segmento a FALSE. De este modo,
la instrucci√≥n "CMP >T_WARN: Superior al tiempo de advertencia" est√° inactiva.
Resultado:
Para la instrucci√≥n "CMP >T_WARN: Superior al tiempo de advertencia" (tipo de datos
STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observaci√≥n" o se desplaza a otro segmento, se mostrar√°
de nuevo el estado correcto de la instrucci√≥n "CMP >T_WARN: Superior al tiempo de
advertencia" (tipo de datos STRING, WSTRING). La instrucci√≥n "CMP >T_WARN: Superior al
tiempo de advertencia" se muestra atenuada en el segmento cuando est√° inactiva.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Superior al tiempo de advertencia":
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

<Operan‚Äê
do1>

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activaci√≥n actual
o √∫ltimo de la etapa

<Operan‚Äê
do2>

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‚Äê
ra

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2219

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucci√≥n en el segmento:
6WHS7
!
7,0(
6WHS7B:$51

Mientras el tiempo de activaci√≥n de #Step1.T no haya excedido el tiempo de advertencia de
#Step1.T_WARN, el RLO ser√° "0". En cuanto se sobrepasa el tiempo de advertencia, el RLO
cambia a "1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de la vigilancia del tiempo de etapa (P√°gina 8289)
Programar la vigilancia del tiempo de etapa (P√°gina 8290)
Principios b√°sicos de GRAPH (P√°gina 8191)

Instrucciones FUP en GRAPH
Instrucciones FUP generales en GRAPH
Descripci√≥n
Para la programaci√≥n en GRAPH se dispone de diferentes instrucciones FUP.
La tabla siguiente ofrece una vista general de las instrucciones y su disponibilidad:
Instrucci√≥n FUP

Operaci√≥n
permanen‚Äê
te

Transici√≥n/
Supervi‚Äê
si√≥n/ Inter‚Äê
lock

General
Nuevo segmento

x

Cuadro vac√≠o

x

x

Derivaci√≥n: Abrir rama

x

x

-|: Insertar entrada (P√°gina 1000)

x

x

-o|: Invertir RLO (P√°gina 1001)

x

x

&: Operaci√≥n l√≥gica Y (P√°gina 993)

x

x

>=1: Operaci√≥n l√≥gica O (P√°gina 995)

x

x

X: Operaci√≥n l√≥gica O-exclusiva (P√°gina 998)

x

=: Asignaci√≥n (P√°gina 1002)

x

Operaciones l√≥gicas con bits

2220

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instrucci√≥n FUP

Operaci√≥n
permanen‚Äê
te

/=: Negar asignaci√≥n (P√°gina 1003)

x

R: Desactivar salida (P√°gina 1003)

x

S: Activar salida (P√°gina 1004)

x

SET_BF: Activar mapa de bits (P√°gina 1005)

x

RESET_BF: Desactivar mapa de bits (P√°gina 1007)

x

SR: Flipflop de activaci√≥n/desactivaci√≥n (P√°gina 1008)

x

RS: Flipflop de desactivaci√≥n/activaci√≥n (P√°gina 1010)

x

P: Consultar flanco de se√±al ascendente de un operando (P√°gina 1011)

x

Transici√≥n/
Supervi‚Äê
si√≥n/ Inter‚Äê
lock

N: Consultar flanco de se√±al descendente de un operando (P√°gina 1013) x
P=: Activar operando con flanco de se√±al ascendente (P√°gina 1014)

x

N=: Activar operando con flanco de se√±al descendente (P√°gina 1016)

x

P_TRIG: Consultar flanco de se√±al ascendente del RLO (P√°gina 1017)

x

N_TRIG: Consultar flanco de se√±al descendente del RLO (P√°gina 1018)

x

R_TRIG: Detectar flanco de se√±al ascendente (P√°gina 1019)

x

F_TRIG: Detectar flanco de se√±al descendente (P√°gina 1021)

x

Temporizadores
Temporizadores CEI
TP: Impulso (P√°gina 1022)

x

TON: Retardo al conectar (P√°gina 1026)

x

TOF: Retardo al desconectar (P√°gina 1030)

x

TONR: Acumulador de tiempo (P√°gina 1034)

x

TP: Arrancar temporizador como impulso (P√°gina 1039)

x

TON: Arrancar temporizador como retardo a la conexi√≥n (P√°gina 1044)

x

TOF: Arrancar temporizador como retardo a la desconexi√≥n (P√°gina 1048) x
TONR: Acumulador de tiempo (P√°gina 1052)

x

RT: Inicializar temporizador (P√°gina 1056)

x

PT: Cargar tiempo (P√°gina 1058)

x

Temporizadores SIMATIC
S_PULSE: Parametrizar y arrancar temporizador como impulso (P√°gi‚Äê
na 1061)

x

S_PEXT: Parametrizar y arrancar temporizador como impulso prolongado
(P√°gina 1064)

x

S_ODT: Parametrizar y arrancar temporizador como retardo a la conexi√≥n
(P√°gina 1067)

x

S_ODTS: Parametrizar y arrancar temporizador como retardo a la cone‚Äê
xi√≥n con memoria (P√°gina 1070)

x

S_OFFDT: Parametrizar y arrancar temporizador como retardo a la des‚Äê
conexi√≥n (P√°gina 1072)

x

Contadores
Contadores CEI
CTU: Contador ascendente (P√°gina 1085)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

x

2221

Instrucciones
4.1 Instrucciones
Instrucci√≥n FUP

Operaci√≥n
permanen‚Äê
te

CTD: Contador descendente (P√°gina 1087)

x

CTUD: Contador ascendente - descendente (P√°gina 1090)

x

Transici√≥n/
Supervi‚Äê
si√≥n/ Inter‚Äê
lock

Contadores SIMATIC
S_CU: Parametrizar e incrementar contador (P√°gina 1093)

x

S_CD: Parametrizar y decrementar contador (P√°gina 1095)

x

S_CUD: Parametrizar e incrementar/decrementar contador (P√°gina 1097) x
Comparaci√≥n
CMP ==: Igual (P√°gina 1103)

x

x

CMP <>: Diferente (P√°gina 1108)

x

x

CMP >=: Mayor o igual (P√°gina 1113)

x

x

CMP <=: Menor o igual (P√°gina 1116)

x

x

CMP >: Mayor (P√°gina 1118)

x

x

CMP <: Menor (P√°gina 1121)

x

x

IN_RANGE: Valor dentro del rango (P√°gina 1124)

x

OUT_RANGE: Valor fuera del rango (P√°gina 1125)

x

---| OK |---: Comprobar validez (P√°gina 1126)

x

---| NOT_OK |---: Comprobar invalidez (P√°gina 1127)

x

EQ_Type: Comparar si el tipo de datos es IGUAL al tipo de datos de una
variable (P√°gina 1128)

x

NE_Type: Comparar si el tipo de datos es DIFERENTE del tipo de datos de x
una variable (P√°gina 1130)
EQ_ElemType: Comparar si el tipo de datos de un elemento del ARRAY es
IGUAL al tipo de datos de una variable (P√°gina 1132)

x

NE_ElemType: Comprar si el tipo de datos de un elemento del ARRAY es
DIFERENTE al tipo de datos de una variable (P√°gina 1134)

x

IS_NULL: Consultar si es un puntero IGUAL A CERO (P√°gina 1135)

x

NOT_NULL: Consultar si es un puntero DIFERENTE DE CERO (P√°gi‚Äê
na 1137)

x

IS_ARRAY: Consultar si es un ARRAY (P√°gina 1138)

x

EQ_TypeOfDB: Comparar si el tipo de datos DB_ANY es IGUAL al tipo de
datos de una variable (P√°gina 1139)

x

NE_TypeOfDB: Comparar si el tipo de datos DB_ANY es DIFERENTE del
tipo de datos de una variable (P√°gina 1140)

x

CMP>T: Superior al tiempo de activaci√≥n de la etapa (P√°gina 2225)

x

CMP>U: Superior al tiempo de activaci√≥n ininterrumpido de la etapa (P√°‚Äê
gina 2227)

x

Funciones matem√°ticas

2222

CALCULATE: Calcular (P√°gina 1142)

x

ADD: Sumar (P√°gina 1145)

x

SUB: Restar (P√°gina 1146)

x

MUL: Multiplicar (P√°gina 1148)

x

DIV: Dividir (P√°gina 1149)

x

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instrucci√≥n FUP

Operaci√≥n
permanen‚Äê
te

MOD: Obtener resto de divisi√≥n (P√°gina 1151)

x

NEG: Generar complemento a dos (P√°gina 1152)

x

INC: Incrementar (P√°gina 1154)

x

DEC: Decrementar (P√°gina 1155)

x

ABS: Calcular valor absoluto (P√°gina 1156)

x

MIN: Determinar m√≠nimo (P√°gina 1157)

x

MAX: Determinar m√°ximo (P√°gina 1159)

x

LIMIT: Ajustar valor l√≠mite (P√°gina 1161)

x

SQR: Calcular cuadrado (P√°gina 1163)

x

SQRT: Calcular ra√≠z cuadrada (P√°gina 1164)

x

LN: Calcular logaritmo natural (P√°gina 1166)

x

EXP: Calcular valor exponencial (P√°gina 1167)

x

SIN: Calcular valor de seno (P√°gina 1168)

x

COS: Calcular valor de coseno (P√°gina 1170)

x

TAN: Calcular valor de tangente (P√°gina 1171)

x

ASIN: Calcular valor de arcoseno (P√°gina 1172)

x

ACOS: Calcular valor de arcocoseno (P√°gina 1174)

x

ATAN: Calcular valor de arcotangente (P√°gina 1175)

x

FRAC: Determinar decimales (P√°gina 1176)

x

EXPT: Elevar a potencia (P√°gina 1178)

x

Transici√≥n/
Supervi‚Äê
si√≥n/ Inter‚Äê
lock

Transferencia
MOVE: Copiar valor (P√°gina 1179)

x

Deserialize: Deserializar (P√°gina 1185)

x

Serialize: Serializar (P√°gina 1191)

x

FieldRead: Leer campo (P√°gina 1254)

x

FieldWrite: Escribir campo (P√°gina 1256)

x

MOVE_BLK: Copiar √°rea (P√°gina 1196)

x

SCATTER: Dispersi√≥n de una secuencia de bits en bits individuales (P√°‚Äê
gina 1212)

x

SCATTER_BLK: Dispersi√≥n de elementos de un ARRAY of secuencia de
bits en bits individuales (P√°gina 1217)

x

GATHER: Recopilaci√≥n de bits individuales en una secuencia de bits (P√°‚Äê x
gina 1221)
GATHER_BLK: Recopilaci√≥n de bits individuales en varios elementos de
un ARRAY of secuencia de bits (P√°gina 1226)

x

MOVE_BLK_VARIANT: Copiar √°rea (P√°gina 1198)

x

UMOVE_BLK: Copiar √°rea sin interrupciones (P√°gina 1202)

x

FILL_BLK: Rellenar √°rea (P√°gina 1205)

x

UFILL_BLK: Rellenar √°rea sin interrupciones (P√°gina 1209)

x

?=: Intento de asignaci√≥n (P√°gina 1230)

x

SWAP: Cambiar disposici√≥n (P√°gina 1233)

x

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2223

Instrucciones
4.1 Instrucciones
Instrucci√≥n FUP

Operaci√≥n
permanen‚Äê
te

ReadFromArrayDB: Leer desde bloque de datos de array (P√°gina 1235)

x

WriteToArrayDB: Escribir en bloque de datos de array (P√°gina 1237)

x

ReadFromArrayDBL: Leer de bloque de datos de array de la memoria de
carga (P√°gina 1240)

x

WriteToArrayDBL: Escribir en bloque de datos de array de la memoria de
carga (P√°gina 1243)

x

VariantGet: Leer valor de una variable VARIANT (P√°gina 1246)

x

VariantPut: Escribir valor en una variable VARIANT (P√°gina 1247)

x

CountOfElements: Consultar n√∫mero de elementos de ARRAY (P√°gi‚Äê
na 1249)

x

LOWER_BOUND: Leer l√≠mite inferior del ARRAY (P√°gina 1251)

x

UPPER_BOUND: Leer l√≠mite superior del ARRAY (P√°gina 1252)

x

BLKMOV: Copiar √°rea (S7-1500) (P√°gina 1258)

x

UBLKMOV: Copiar √°rea sin interrupciones (S7-1500) (P√°gina 1262)

x

FILL: Rellenar √°rea (S7-1500) (P√°gina 1264)

x

Transici√≥n/
Supervi‚Äê
si√≥n/ Inter‚Äê
lock

Conversi√≥n
CONVERT: Convertir valor (P√°gina 1268)

x

ROUND: Redondear n√∫mero (P√°gina 1270)

x

CEIL: Redondear n√∫mero en coma flotante al siguiente entero superior
(P√°gina 1271)

x

FLOOR: Redondear n√∫mero en coma flotante al siguiente entero inferior
(P√°gina 1273)

x

TRUNC: Truncar a entero (P√°gina 1274)

x

SCALE_X: Escalar (P√°gina 1276)

x

NORM_X: Normalizar (P√°gina 1278)

x

VARIANT_TO_DB_ANY: Convertir VARIANT en DB_ANY

x

DB_ANY_TO_VARIANT: Convertir DB_ANY en VARIANT

x

SCALE: Escalar (S7-1500) (P√°gina 1281)

x

UNSCALE: Desescalar (S7-1500) (P√°gina 1283)

x

Control del programa
Control en runtime
ENDIS_PW: Limitar y habilitar legitimaci√≥n de la contrase√±a (P√°gina 1295) x
RE_TRIGR: Reiniciar tiempo de vigilancia del ciclo (P√°gina 1301)

x

STP: Finalizar programa (P√°gina 1302)

x

GET_ERROR: Consultar error localmente (P√°gina 1303)

x

GET_ERR_ID: Consultar ID de error localmente (P√°gina 1307)

x

INIT_RD: Inicializar todos los datos remanentes (P√°gina 1310)

x

WAIT: Programar retardo (P√°gina 1312)

x

RUNTIME: Medir tiempo de ejecuci√≥n (P√°gina 1314)

x

Operaciones l√≥gicas con palabras
AND: Operaci√≥n l√≥gica Y (P√°gina 1316)

2224

x

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Instrucci√≥n FUP

Operaci√≥n
permanen‚Äê
te

OR: Operaci√≥n l√≥gica O (P√°gina 1318)

x

XOR: Operaci√≥n l√≥gica O-exclusiva (P√°gina 1320)

x

INV: Generar complemento a 1 (P√°gina 1321)

x

DECO: Descodificar (P√°gina 1323)

x

ENCO: Codificar (P√°gina 1324)

x

SEL: Seleccionar (P√°gina 1325)

x

MUX: Multiplexar (P√°gina 1327)

x

DEMUX: Desmultiplexar (P√°gina 1330)

x

Transici√≥n/
Supervi‚Äê
si√≥n/ Inter‚Äê
lock

Desplazamiento y rotaci√≥n
SHR: Desplazar a la derecha (P√°gina 1333)

x

SHL: Desplazar a la izquierda (P√°gina 1335)

x

ROR: Rotar a la derecha (P√°gina 1337)

x

ROL: Rotar a la izquierda (P√°gina 1339)

x

Otras instrucciones
DRUM: Materializar circuito secuencial sucesivo (P√°gina 1341)

x

DCAT: Alarma de tiempo para control discreto (P√°gina 1348)

x

MCAT: Alarma de tiempo para control del motor (P√°gina 1351)

x

IMC: Comparar los bits de entrada con los bits de la m√°scara (P√°gi‚Äê
na 1354)

x

SMC: Barrido de matriz (P√°gina 1357)

x

LEAD_LAG: Algoritmo Lead y Lag (P√°gina 1359)

x

SEG: Generar patr√≥n de bits para el display de 7 segmentos (P√°gina 1362) x
BCDCPL: Generar complemento a diez (P√°gina 1364)

x

BITSUM: Contar n√∫mero de bits activados (P√°gina 1365)

x

CMP>T: Superior al tiempo de activaci√≥n de la etapa
Descripci√≥n
Con la instrucci√≥n "Superior al tiempo de activaci√≥n de la etapa" se puede vigilar la duraci√≥n
total de una etapa en condiciones de supervisi√≥n. De esta manera se registra el tiempo de los
posibles eventos o errores.
En la condici√≥n programada se compara el tiempo de activaci√≥n en curso o el √∫ltimo de una
etapa (operando1) con un tiempo definido (operando2) en milisegundos. Si se cumple la

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2225

Instrucciones
4.1 Instrucciones
condici√≥n de la comparaci√≥n, la instrucci√≥n devuelve el resultado l√≥gico (RLO) "1". Si la
condici√≥n de la comparaci√≥n no se cumple, la instrucci√≥n devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucci√≥n est√° "inactiva"
En las condiciones citadas a continuaci√≥n se aplica lo siguiente:
‚óè Antes de la instrucci√≥n "CMP >T: Superior al tiempo de activaci√≥n de la etapa" (con tipo de
datos STRING, WSTRING) se consulta una condici√≥n (p. ej. un contacto normalmente
abierto) en el segmento.
‚óè "Activar observaci√≥n" est√° activado.
‚óè Un nuevo resultado de la condici√≥n vuelve a poner el segmento a FALSE. De este modo,
la instrucci√≥n "CMP >T: Superior al tiempo de activaci√≥n de la etapa" est√° inactiva.
Resultado:
Para la instrucci√≥n "CMP >T: Superior al tiempo de activaci√≥n de la etapa" (tipo de datos
STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observaci√≥n" o se desplaza a otro segmento, se mostrar√°
de nuevo el estado correcto de la instrucci√≥n "CMP >T: Superior al tiempo de activaci√≥n de la
etapa" (tipo de datos STRING, WSTRING). La instrucci√≥n "CMP >T: Superior al tiempo de
activaci√≥n de la etapa" se muestra atenuada en el segmento cuando est√° inactiva.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Superior al tiempo de activaci√≥n
de la etapa":

2226

Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN1

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activaci√≥n actual
o √∫ltimo de la etapa

IN2

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‚Äê
ra

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucci√≥n en el segmento:
!
7LPH
67(37
706

,1
,1

Mientras el tiempo de activaci√≥n de #STEP1.T est√© por debajo de 100 ms, el RLO ser√° "0". En
cuanto el tiempo de activaci√≥n sobrepasa 100 ms, el RLO cambia a "1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

CMP>U: Superior al tiempo de activaci√≥n ininterrumpido de la etapa
Descripci√≥n
Con la instrucci√≥n "Superior al tiempo de activaci√≥n ininterrumpido de la etapa", se puede
vigilar la duraci√≥n de una etapa, sin tener en cuenta las posibles aver√≠as, en condiciones de
supervisi√≥n. No se registra el tiempo de posibles eventos o fallos sino que se supervisa la
duraci√≥n de la mera etapa.
En la condici√≥n programada se compara todo el tiempo de activaci√≥n de una etapa
(operando1) con un tiempo definido (operando2) en milisegundos. Si se cumple la condici√≥n

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2227

Instrucciones
4.1 Instrucciones
de la comparaci√≥n, la instrucci√≥n devuelve el resultado l√≥gico (RLO) "1". Si la condici√≥n de la
comparaci√≥n no se cumple, la instrucci√≥n devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucci√≥n est√° "inactiva"
En las condiciones citadas a continuaci√≥n se aplica lo siguiente:
‚óè Antes de la instrucci√≥n "CMP >U: Superior al tiempo de activaci√≥n ininterrumpido de la
etapa" (con tipo de datos STRING, WSTRING) se consulta una condici√≥n (p. ej. un contacto
normalmente abierto) en el segmento.
‚óè "Activar observaci√≥n" est√° activado.
‚óè Un nuevo resultado de la condici√≥n vuelve a poner el segmento a FALSE. De este modo,
la instrucci√≥n "CMP >U: Superior al tiempo de activaci√≥n ininterrumpido de la etapa" est√°
inactiva.
Resultado:
Para la instrucci√≥n "CMP >U: Superior al tiempo de activaci√≥n ininterrumpido de la etapa" (tipo
de datos STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observaci√≥n" o se desplaza a otro segmento, se mostrar√°
de nuevo el estado correcto de la instrucci√≥n "CMP >U: Superior al tiempo de activaci√≥n
ininterrumpido de la etapa" (tipo de datos STRING, WSTRING). La instrucci√≥n "CMP >U:
Superior al tiempo de activaci√≥n ininterrumpido de la etapa" se muestra atenuada en el
segmento cuando est√° inactiva.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Superior al tiempo de activaci√≥n
ininterrumpido de la etapa":

2228

Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN1

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activaci√≥n actual
o √∫ltimo de la etapa sin con‚Äê
tar aver√≠as

IN2

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‚Äê
ra

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucci√≥n en el segmento:
!
7LPH
67(38
706

,1
,1

Mientras el tiempo de activaci√≥n de #STEP1.U, sin tener en cuenta las posibles aver√≠as, est√©
por debajo de 100 ms, el RLO ser√° igual a "0". En cuanto el tiempo de activaci√≥n sobrepasa
100 ms, el RLO cambia a "1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de GRAPH (P√°gina 8191)

CMP>T_MAX: Superior al tiempo m√°ximo de activaci√≥n de etapa
Descripci√≥n
Con la instrucci√≥n "Superior al tiempo m√°ximo de activaci√≥n de etapa" se vigila la duraci√≥n total
m√°xima de una etapa en condiciones de supervisi√≥n. De esta manera se registra el tiempo de
los posibles eventos o errores.
En la condici√≥n programada se compara el tiempo de activaci√≥n en curso o el √∫ltimo de una
etapa (operando1) con la duraci√≥n m√°xima (operando2) en milisegundos. Si se cumple la

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2229

Instrucciones
4.1 Instrucciones
condici√≥n de la comparaci√≥n, la instrucci√≥n devuelve el resultado l√≥gico (RLO) "1". Si la
condici√≥n de la comparaci√≥n no se cumple, la instrucci√≥n devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucci√≥n est√° "inactiva"
En las condiciones citadas a continuaci√≥n se aplica lo siguiente:
‚óè Antes de la instrucci√≥n "CMP >T_MAX: Superior al tiempo m√°ximo de activaci√≥n de etapa"
(con tipo de datos STRING, WSTRING) se consulta una condici√≥n (p. ej. un contacto
normalmente abierto) en el segmento.
‚óè "Activar observaci√≥n" est√° activado.
‚óè Un nuevo resultado de la condici√≥n vuelve a poner el segmento a FALSE. De este modo,
la instrucci√≥n "CMP >T_MAX: Superior al tiempo m√°ximo de activaci√≥n de etapa" est√°
inactiva.
Resultado:
Para la instrucci√≥n "CMP >T_MAX: Superior al tiempo m√°ximo de activaci√≥n de etapa" (tipo de
datos STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observaci√≥n" o se desplaza a otro segmento, se mostrar√°
de nuevo el estado correcto de la instrucci√≥n "CMP >T_MAX: Superior al tiempo m√°ximo de
activaci√≥n de etapa" (tipo de datos STRING, WSTRING). La instrucci√≥n "CMP >T_MAX:
Superior al tiempo m√°ximo de activaci√≥n de etapa" se muestra atenuada en el segmento
cuando est√° inactiva.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Superior al tiempo m√°ximo de
activaci√≥n de etapa":

2230

Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN1

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activaci√≥n actual
o √∫ltimo de la etapa

IN2

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‚Äê
ra

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucci√≥n en el segmento:
!
7LPH
6WHS7
6WHS7B0$;

,1
,1

Mientras el tiempo de activaci√≥n de #STEP1.T est√© por debajo del tiempo m√°ximo de
activaci√≥n de etapa de #Step1.T_MAX, el RLO ser√° "0". En cuanto el tiempo de activaci√≥n
sobrepasa el tiempo m√°ximo de activaci√≥n de etapa, el RLO cambia a "1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de la vigilancia del tiempo de etapa (P√°gina 8289)
Programar la vigilancia del tiempo de etapa (P√°gina 8290)
Principios b√°sicos de GRAPH (P√°gina 8191)

CMP>T_WARN: Superior al tiempo de advertencia
Descripci√≥n
Con la instrucci√≥n "Superior al tiempo de advertencia" se vigila la duraci√≥n de una etapa en
condiciones de supervisi√≥n y, si se excede el tiempo, se emite una alarma. De esta manera se
registra el tiempo de los posibles eventos o errores.
En la condici√≥n programada se compara el tiempo de activaci√≥n en curso o el √∫ltimo de una
etapa (operando1) con un tiempo definido (operando2) en milisegundos. Si se cumple la

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2231

Instrucciones
4.1 Instrucciones
condici√≥n de la comparaci√≥n, la instrucci√≥n devuelve el resultado l√≥gico (RLO) "1" y se emite
una alarma. Si la condici√≥n de la comparaci√≥n no se cumple, la instrucci√≥n devuelve el RLO "0".
Nota
El estado se sigue mostrando a pesar de que la instrucci√≥n est√° "inactiva"
En las condiciones citadas a continuaci√≥n se aplica lo siguiente:
‚óè Antes de la instrucci√≥n "CMP >T_WARN: Superior al tiempo de advertencia" (con tipo de
datos STRING, WSTRING) se consulta una condici√≥n (p. ej. un contacto normalmente
abierto) en el segmento.
‚óè "Activar observaci√≥n" est√° activado.
‚óè Un nuevo resultado de la condici√≥n vuelve a poner el segmento a FALSE. De este modo,
la instrucci√≥n "CMP >T_WARN: Superior al tiempo de advertencia" est√° inactiva.
Resultado:
Para la instrucci√≥n "CMP >T_WARN: Superior al tiempo de advertencia" (tipo de datos
STRING, WSTRING) se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observaci√≥n" o se desplaza a otro segmento, se mostrar√°
de nuevo el estado correcto de la instrucci√≥n "CMP >T_WARN: Superior al tiempo de
advertencia" (tipo de datos STRING, WSTRING). La instrucci√≥n "CMP >T_WARN: Superior al
tiempo de advertencia" se muestra atenuada en el segmento cuando est√° inactiva.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "Superior al tiempo de advertencia":

2232

Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN1

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo de activaci√≥n actual
o √∫ltimo de la etapa

IN2

Input

Enteros, n√∫meros
en coma flotante,
temporizadores,
secuencias de ca‚Äê
racteres, DATE,
DT, DTL, TOD,
LTOD, LDT

I, Q, M, D, L o
constante

Tiempo con el que se compa‚Äê
ra

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra la instrucci√≥n en el segmento:
!
7LPH
6WHS7
6WHS7B:$51

,1
,1

Mientras el tiempo de activaci√≥n de #Step1.T no haya excedido el tiempo de advertencia de
#Step1.T_WARN, el RLO ser√° "0". En cuanto se sobrepasa el tiempo de advertencia, el RLO
cambia a "1".

Consulte tambi√©n
Vista general de los tipos de datos v√°lidos (P√°gina 241)
Principios b√°sicos de la palabra de estado (P√°gina 198)
Principios b√°sicos de la vigilancia del tiempo de etapa (P√°gina 8289)
Programar la vigilancia del tiempo de etapa (P√°gina 8290)
Principios b√°sicos de GRAPH (P√°gina 8191)

4.1.4

Instrucciones avanzadas

4.1.4.1

Indicaciones generales sobre las instrucciones avanzadas

Par√°metro de entrada LADDR en instrucciones con acceso a la periferia
Selecci√≥n del par√°metro de entrada LADDR
Muchas instrucciones avanzadas que acceden a la periferia disponen del par√°metro de
entrada LADDR. Es del tipo de datos HW_IO y contiene el identificador de hardware del objeto
de hardware que debe procesar la instrucci√≥n.
El identificador de hardware debe tomarse de las propiedades del objeto de hardware en la
vista de redes o de la ficha "Constantes de sistema" de la tabla de variables est√°ndar.
Si selecciona otro valor para el identificador de hardware, generalmente obtendr√° un c√≥digo de
error diferente a 0, p. ej.
‚óè 8090: la direcci√≥n indicada en el par√°metro LADDR no es v√°lida (WR_REC, RD_REC).
‚óè 8091: el componente de hardware direccionado con el par√°metro LADDR no existe (LED).
‚óè 8093: esta instrucci√≥n no es v√°lida para el ID de hardware indicado en LADDR (WR_REC,
RD_REC).
No obstante, existen objetos internos de la CPU, cuyos identificadores de hardware no se
muestran p. ej. en la ficha "Constantes de sistema" de la tabla de variables est√°ndar. Si por

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2233

Instrucciones
4.1 Instrucciones
casualidad selecciona un identificador de hardware de este tipo y lo indica en el par√°metro
LADDR, no se puede garantizar que se devuelva un c√≥digo de error diferente a 0, ni que la
instrucci√≥n se ejecute correctamente.
Por eso se recomienda encarecidamente asignar al par√°metro LADDR √∫nicamente los valores
que se muestren en las propiedades del objeto de hardware en la vista de redes o en la ficha
"Constantes de sistema" de la tabla de variables est√°ndar.

4.1.4.2

Fecha y hora

T_COMP: Comparar variables de tiempo
Descripci√≥n
Con esta instrucci√≥n se comparan los contenidos de dos variables de los tipos de datos
"Temporizadores" o "Fecha y hora".
La instrucci√≥n soporta la comparaci√≥n de los tipos de datos siguientes: DATE, TIME, LTIME,
TOD (TIME_OF_DAY), LTOD (LTIME_OF_DAY), DT (DATE_AND_TIME), LDT
(DATE_AND_LTIME), DTL, S5Time.
Para realizar la comparaci√≥n, los tipos de datos deben coincidir en longitud y formato.
El resultado de la comparaci√≥n se muestra como valor de retorno en el par√°metro OUT. Una
vez que se ha cumplido la condici√≥n de comparaci√≥n utilizada, el par√°metro OUT se pone a "1".
Existen las siguientes posibilidades de comparaci√≥n:
S√≠mbolo

Descripci√≥n

EQ

Si los momentos son id√©nticos en el par√°metro IN1 y en el par√°metro IN2, el valor de retorno tiene el estado
l√≥gico "1".

NE

Si los momentos no son id√©nticos en el par√°metro IN1 y en el par√°metro IN2, el valor de retorno tiene el
estado l√≥gico "1".

GE

Si el momento del par√°metro IN1 es mayor (m√°s reciente) o igual al del par√°metro IN2 , el valor de retorno
tiene el estado l√≥gico "1".

LE

Si el momento del par√°metro IN1 es menor (m√°s antiguo) o igual al del par√°metro IN2, el valor de retorno
tiene el estado l√≥gico "1".

GT

Si el momento del par√°metro IN1 es mayor (m√°s reciente) que el del par√°metro IN2, el valor de retorno tiene
el estado l√≥gico "1".

LT

Si el momento del par√°metro IN1 es menor (m√°s antiguo) que el del par√°metro IN2 , el valor de retorno tiene
el estado l√≥gico "1".

2234

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "T_COMP":
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN1

Input

DATE, TIME, LTIME,
TOD, LTOD, DT,
LDT, DTL, S5Time

I, Q, M, D, L, P o cons‚Äê
tante

Primer valor que se va a comparar

IN2

Input

DATE, TIME, LTIME,
TOD, LTOD, DT,
LDT, DTL, S5Time

I, Q, M, D, L, P o cons‚Äê
tante

Segundo valor que se va a comparar

OUT

Output

BOOL

I, Q, M, D, L, P

Valor de retorno

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Vista general de los tipos de
datos v√°lidos (P√°gina 241)".

Ejemplo
En el ejemplo siguiente se comparan dos tiempos del tipo de datos LTIME utilizando la opci√≥n
de comparaci√≥n "Mayor o igual".
Para almacenar los datos se crean tres variables en un bloque de datos global.

Los par√°metros de la instrucci√≥n se interconectan del siguiente modo. Seleccione la opci√≥n de
comparaci√≥n "GE".

Puesto que el tiempo del primer valor de comparaci√≥n ("timeValue1") es mayor o igual al
segundo valor ("timeValue2"), el valor de retorno ("value1GEvalue2") muestra el estado l√≥gico
"TRUE".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2235

Instrucciones
4.1 Instrucciones

Encontrar√° informaci√≥n adicional y el c√≥digo de programa para el ejemplo mencionado m√°s
arriba aqu√≠: Sample Library for Instructions (P√°gina 615)

T_CONV: Convertir y extraer tiempos
Descripci√≥n
Con la instrucci√≥n "T_CONV" se convierte el tipo de datos del par√°metro de entrada IN en el
tipo de datos de la salida OUT. Con los cuadros de instrucciones de la entrada y la salida se
pueden seleccionar los formatos de datos para la conversi√≥n.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "T_CONV". Si en el par√°metro de
entrada y de salida se utiliza el mismo tipo de datos, la instrucci√≥n copia el correspondiente
valor.
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

S7-1200

S7-1500

IN

Input

Enteros, TIME,
fecha y hora*

WORD, ente‚Äê
ros, tempori‚Äê
zadores, fe‚Äê
cha y hora*

I, Q, M, D, L, P o
constante

Valor que se va a convertir

OUT

Return

Enteros, TIME,
fecha y hora*

WORD, ente‚Äê
ros, tempori‚Äê
zadores, fe‚Äê
cha y hora*

I, Q, M, D, L, P

Resultado de la conversi√≥n

* El volumen de tipos de datos soportados depende de la CPU. Consulte en el resumen de los correspondientes tipos de
datos v√°lidos los tipos de datos que soportan los m√≥dulos S7-1200 y S7-1500.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Vista general de los tipos de
datos v√°lidos (P√°gina 241)".

Ejemplo
En el ejemplo siguiente se convierte un tiempo del tipo de datos DATE AND TIME en un tiempo
del tipo de datos LTIME OF DAY.

2236

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para almacenar los datos se crean dos variables en un bloque de datos global.

Los par√°metros de la instrucci√≥n se interconectan del siguiente modo y se seleccionan los
tipos de datos.

El valor que debe convertirse ("inputTime") se emite en el par√°metro de salida como nuevo
valor de tiempo ("returnTime"). La informaci√≥n de fecha se pierde.

Encontrar√° informaci√≥n adicional y el c√≥digo de programa para el ejemplo mencionado m√°s
arriba aqu√≠: Sample Library for Instructions (P√°gina 615)

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2237

Instrucciones
4.1 Instrucciones

T_ADD: Sumar tiempos
Descripci√≥n
Con esta instrucci√≥n se suma la indicaci√≥n horaria del par√°metro de entrada IN1 a la indicaci√≥n
horaria del par√°metro de entrada IN2. El resultado se puede consultar en el par√°metro de
salida OUT. Es posible sumar los formatos siguientes:
‚óè Suma de un tiempo a otro tiempo.
Ejemplo: Suma de un tipo de datos TIME a otro tipo de datos TIME.
‚óè Suma de un tiempo a un momento.
Ejemplo: suma de un tipo de datos TIME al tipo de datos DTL.
El tipo de datos para los valores del par√°metro de entrada IN1 y el par√°metro de salida OUT
se determinan seleccion√°ndolos en los cuadros de instrucciones de la entrada y de la salida.
En el par√°metro de entrada IN2 especifique √∫nicamente indicaciones horarias en formato
TIME (en m√≥dulos S7-1500 tambi√©n LTIME).
Nota
Rebase por exceso/por defecto
A la hora de realizar el c√°lculo es posible que se produzca un rebase por exceso del valor
m√°ximo posible o un rebase por defecto del valor m√≠nimo posible del par√°metro de salida OUT.
Seleccione la salida de habilitaci√≥n ENO para comprobarlo.

Par√°metros
Las tablas siguientes muestran los par√°metros de la instrucci√≥n "T_ADD" correspondientes a
las posibles conversiones:
Tabla 4-7

Suma de un tiempo a otro tiempo

Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

IN1

Input

TIME

TIME, LTIME

I, Q, M, D, L, P o
constante

Primer sumando

IN2

Input

TIME

TIME, LTIME

I, Q, M, D, L, P o
constante

Segundo sumando

OUT

Return

DINT,
DWORD, TI‚Äê
ME, TOD

TIME, LTIME,

I, Q, M, D, L, P

Resultado de la suma

S7-1200

2238

S7-1500

La selecci√≥n de los tipos de datos
depende de los tipos de datos se‚Äê
leccionados para los par√°metros de
entrada IN1 e IN2.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-8
Par√°metro

Suma de un tiempo a un momento
Declaraci√≥n

Tipo de datos
S7-1200

IN1

Input

DTL, TOD

√Årea de memoria

Descripci√≥n

DT, TOD,
LTOD, LDT,
DTL

I, Q, M, D, L, P o
constante

Primer sumando

I, Q, M, D, L, P o
constante

Segundo sumando

S7-1500

IN2

Input

TIME

TIME, LTIME

OUT

Return

DINT,
DWORD, TI‚Äê
ME, TOD,
UDINT, DTL

DT, DTL, LDT, I, Q, M, D, L, P
TOD, LTOD

Con LTIME en el par√°metro IN2 so‚Äê
lo puede utilizarse LTOD, LDT o
DTL.

Resultado de la suma
La selecci√≥n de los tipos de datos
depende de los tipos de datos se‚Äê
leccionados para los par√°metros de
entrada IN1 e IN2.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Vista general de los tipos de
datos v√°lidos (P√°gina 241)".

Ejemplo
En el ejemplo siguiente se suma un tiempo del tipo de datos TIME a una hora del tipo de datos
TOD.
Para almacenar los datos se crean tres variables en un bloque de datos global.

Los par√°metros de la instrucci√≥n se interconectan del siguiente modo. Se seleccionan los tipos
de datos para la hora ("timeValTOD") y el tiempo ("timeValTIME").

La hora ("timeValTOD") y el tiempo ("timeValTIME") se suman y el resultado se muestra como
hora en el par√°metro de salida OUT ("valueTimeResult").

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2239

Instrucciones
4.1 Instrucciones

Encontrar√° informaci√≥n adicional y el c√≥digo de programa para el ejemplo mencionado m√°s
arriba aqu√≠: Sample Library for Instructions (P√°gina 615)

T_SUB: Restar tiempos
Descripci√≥n
Con esta instrucci√≥n se resta la indicaci√≥n horaria del par√°metro de entrada IN2 de la
indicaci√≥n horaria del par√°metro de entrada IN1. Consulte la diferencia en el par√°metro de
salida OUT. Es posible restar los formatos siguientes:
‚óè Restar un tiempo a otro tiempo
Ejemplo: restar un tiempo del tipo de datos TIME a otro tiempo del tipo de datos TIME. El
resultado puede emitirse en una variable del tipo de datos TIME.
‚óè Restar un tiempo a un momento
Ejemplo: restar un tiempo del tipo de datos TIME a un momento del tipo de datos DTL. El
resultado puede emitirse en una variable del tipo de datos DTL.
Los formatos de los valores del par√°metro de entrada IN1y del par√°metro de salida OUT se
determinan seleccionando los tipos de datos para el par√°metro de entrada y el par√°metro de
salida de la instrucci√≥n.
Nota
Rebase por exceso/por defecto
A la hora de realizar el c√°lculo es posible que se produzca un rebase por exceso del valor
m√°ximo posible o un rebase por defecto del valor m√≠nimo posible del par√°metro de salida OUT.
Seleccione la salida de habilitaci√≥n ENO para comprobarlo.

2240

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
Las tablas siguientes muestran los par√°metros de la instrucci√≥n "T_SUB" correspondientes a
las posibles conversiones:
Tabla 4-9
Par√°metro

Restar un tiempo a otro tiempo
Declaraci√≥n

Tipo de datos

√Årea de memoria Descripci√≥n

S7-1200

S7-1500

IN1

Input

TIME

TIME, LTIME

I, Q, M, D, L, P o
constante

Minuendo

IN2

Input

TIME

TIME, LTIME

I, Q, M, D, L, P o
constante

Sustraendo

OUT

Return

DINT, DWORD,
TIME, TOD,
UDINT

TIME, LTIME

I, Q, M, D, L, P

Resultado de la resta

Tabla 4-10
Par√°metro
IN1

Restar un tiempo a un momento
Declaraci√≥n
Input

Tipo de datos

√Årea de memoria Descripci√≥n

S7-1200

S7-1500

DTL, TOD

TOD, LTOD, DTL,
DT, LDT

I, Q, M, D, L, P o
constante

Minuendo
Con LTIME en el par√°metro
IN2 solo se utiliza LTOD, LDT o
DTL.

IN2

Input

TIME

TIME, LTIME

I, Q, M, D, L, P o
constante

Sustraendo

OUT

Return

DTL, DINT,
DWORD, TIME,
TOD, UDINT

TOD, LTOD, DTL,
DT, LDT

I, Q, M, D, L, P

Resultado de la resta

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Vista general de los tipos de
datos v√°lidos (P√°gina 241)".

Ejemplo
En el ejemplo siguiente se resta un tiempo del tipo de datos TIME de una hora del tipo de datos
TOD.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los par√°metros de la instrucci√≥n se interconectan del siguiente modo. Se seleccionan el tipo
de datos de la hora ("value1TOD") y el tipo de datos del tiempo ("value2Time").

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2241

Instrucciones
4.1 Instrucciones

La hora ("value1TOD") y el tiempo ("value2Time") se restan y el resultado se muestra como
hora en el par√°metro de salida OUT ("value1MINvalue2").

Encontrar√° informaci√≥n adicional y el c√≥digo del programa para el ejemplo anterior aqu√≠:
Sample Library for Instructions (P√°gina 615).

T_DIFF: Diferencia de tiempo
Descripci√≥n
Con esta instrucci√≥n se resta la indicaci√≥n horaria del par√°metro de entrada IN2 de la
indicaci√≥n horaria del par√°metro de entrada IN1. El resultado se devuelve en el par√°metro de
salida OUT.
‚óè Si la indicaci√≥n horaria en el par√°metro de entrada IN2es mayor que la indicaci√≥n horaria
en el par√°metro de entrada IN1, se emite un valor negativo en el par√°metro de salida OUT.
‚óè Si el resultado de la resta se encuentra fuera del rango num√©rico TIME, la salida de
habilitaci√≥n ENO = "0". Dependiendo del tipo de datos utilizado se obtiene un resultado
truncado o "0" (0:00).
‚Äì Si como minuendo y sustraendo se seleccionan par√°metros del tipo de datos DTL, el
resultado es del tipo de datos TIME. No puede ser mayor que 24 d√≠as; en caso contrario,
la salida de habilitaci√≥n ENO = "0" y el resultado es "0".
‚Äì Dicha restricci√≥n no existe si como minuendo y sustraendo se seleccionan par√°metros
del tipo de datos LDT.

2242

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "T_DIFF":
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memoria

Descripci√≥n

IN1

Input

DTL, DATE,
TOD

DTL, DATE, DT,
TOD, LTOD,
LDT

I, Q, M, D, L, P o
constante

Minuendo

IN2

Input

DTL, DATE,
TOD

DTL, DATE, DT,
TOD, LTOD,
LDT

I, Q, M, D, L, P o
constante

Sustraendo

OUT

Return

TIME, INT

TIME, LTIME,
INT

I, Q, M, D, L, P

Diferencia de los par√°metros
de entrada

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Vista general de los tipos de
datos v√°lidos (P√°gina 241)".
Nota
Uso de la instrucci√≥n "T_DIFF" in SCL
En SCL est√° predeterminado el tipo de datos TIME para el par√°metro OUT (consulte
tambi√©n: Principios b√°sicos de los tipos de datos de instrucciones SCL (P√°gina 8161)). Si
quiere usar el tipo de datos INT para OUT deber√° completar el nombre de la instrucci√≥n T_DIFF
con "_INT" (consulte tambi√©n: Modificar el tipo de datos de una instrucci√≥n SCL (P√°gina 8162)).

Ejemplo
En el ejemplo siguiente se calcula la diferencia entre dos horas del tipo de datos TOD. La
diferencia se indica en el tipo de datos TIME.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los par√°metros de la instrucci√≥n se interconectan del siguiente modo y se seleccionan los
tipos de datos. En la primera posibilidad de selecci√≥n se indica el tipo de datos de los instantes.
En la segunda posibilidad de selecci√≥n se indica el tipo de datos de la diferencia.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2243

Instrucciones
4.1 Instrucciones

La primera hora ("todvalue1") y la segunda hora ("todvalue2") se restan y la diferencia se
muestra como tiempo en el par√°metro de salida OUT ("timevalueDIFF").

Encontrar√° informaci√≥n adicional y el c√≥digo del programa para el ejemplo anterior aqu√≠:
Sample Library for Instructions (P√°gina 615)

T_COMBINE: Combinar tiempos
Descripci√≥n
La instrucci√≥n combina el valor de una fecha con el de una indicaci√≥n horaria. El resultado es
una indicaci√≥n horaria combinada de fecha y hora.
‚óè En el par√°metro de entrada IN1 se introduce la indicaci√≥n de fecha. En el tipo de datos
DATE emplee un valor comprendido entre 1990-01-01 y 2089-12-31 (no se comprueba).
‚óè En el valor de entrada IN2 se introduce la indicaci√≥n horaria (tipo de datos TOD/LTOD).
‚óè En el valor de salida OUT se emite el tipo de datos combinado para indicaci√≥n de fecha y
hora.

2244

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "T_COMBINE":
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

S7-1200

S7-1500

Descripci√≥n

IN1

Input

DATE

DATE

I, Q, M, D, L, P o cons‚Äê Variable de entrada de la fecha
tante

IN2

Input

TOD

TOD, LTOD

I, Q, M, D, L, P o cons‚Äê Variable de entrada de la hora
tante

OUT

Return

DTL

DT, DTL, LDT I, Q, M, D, L, P

Valor de retorno de fecha y hora

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Vista general de los tipos de
datos v√°lidos (P√°gina 241)".
Nota
Uso de T_COMBINE en programas SCL
Si se arrastra la instrucci√≥n T_COMBINE desde la Task Card "Instrucciones" hasta la ventana
de programaci√≥n SCL se muestra la instrucci√≥n interna CONCAT_DATE_TOD o
CONCAT_DATE_LTOD.

Ejemplo
En el ejemplo siguiente se combinan una hora del tipo de datos TOD y una fecha del tipo de
datos DATE. El valor de retorno se indica en el tipo de datos DT.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los par√°metros de la instrucci√≥n se interconectan del siguiente modo y se seleccionan los
tipos de datos. En la primera posibilidad de selecci√≥n se indica el tipo de datos de la hora del
d√≠a ("valueTOD"). En la segunda posibilidad de selecci√≥n se indica el tipo de datos del valor de
retorno ("combTIME").

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2245

Instrucciones
4.1 Instrucciones
La fecha ("valueDATE") se ampl√≠a con la indicaci√≥n de la hora ("valueTOD") y el valor de
retorno se muestra en el par√°metro de salida OUT ("combTIME").

Encontrar√° informaci√≥n adicional y el c√≥digo del programa para el ejemplo anterior aqu√≠:
Sample Library for Instructions (P√°gina 615)

Funciones de reloj
WR_SYS_T: Ajustar la hora
Descripci√≥n
La instrucci√≥n ajusta la fecha y hora (hora del m√≥dulo) del reloj de la CPU. La indicaci√≥n de
fecha y hora se especifica en el par√°metro de entrada IN . El valor debe estar dentro del rango
siguiente:
‚óè Con DT: m√≠n. DT#1990-01-01-0:0:0, m√°x. DT#2089-12-31-23:59:59.999
‚óè Con LDT: m√≠n. LDT#1970-01-01-0:0:0.000000000, m√°x.
LDT#2200-12-31-23:59:59.999999999
‚óè Con DTL: m√≠n. DTL#1970-01-01-00:00:00.0, m√°x. DTL#2200-12-31-23:59:59.999999999
En el par√°metro de salida RET_VAL se puede consultar si han ocurrido errores durante la
ejecuci√≥n de la instrucci√≥n.
La informaci√≥n de zona horaria local u horario de verano no se transfiere con la instrucci√≥n
"WR_SYS_T".
Nota
Hora de m√≥dulo del reloj de la CPU
El reloj de la CPU interpreta la hora del m√≥dulo como el tiempo universal coordinado (UTC). En
consecuencia, la hora del m√≥dulo se guarda siempre en el reloj de la CPU sin los factores
"zona horaria local" u "horario de verano". El reloj de la CPU calcula su hora local bas√°ndose
en la hora del m√≥dulo.
La hora de m√≥dulo del reloj de la CPU sirve de base para todos los procesos de tiempo que
parten de la CPU. Ejemplos de uso:
‚óè C√°lculo de la hora local del reloj de la CPU bas√°ndose en la hora del m√≥dulo
‚óè Representaci√≥n de la hora del m√≥dulo en "Online y diagn√≥stico" en hora local
‚óè Propiedades de bloques
‚óè Entradas del b√∫fer de diagn√≥stico de la CPU

2246

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "WR_SYS_T":
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

S7-1200

S7-1500

Descripci√≥n

IN

Input

DTL

DT **, DTL, LDT I, Q, M, D, L, P o
constante *

Fecha y hora

RET_VAL

Return

INT

INT

Estado de la instrucci√≥n

I, Q, M, D, L, P

* Los tipos de datos DT y DTL no se utilizan para las √°reas de memoria Entrada, Salida y Marca.
** Si se utiliza el tipo de datos DT, los milisegundos no se transfieren a la CPU.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Vista general de los tipos de
datos v√°lidos (P√°gina 241)".

Par√°metro RET_VAL
C√≥digo de error*

Descripci√≥n

(W#16#....)
0000

Ning√∫n error

8080

Error en la fecha

8081

Error en la hora

8082**

Valor no v√°lido para indicar el mes (byte 2 en formato DTL)

8083**

Valor no v√°lido para indicar el d√≠a (byte 3 en formato DTL)

8084**

Valor no v√°lido para indicar la hora (byte 5 en formato DTL)

8085**

Valor no v√°lido para indicar el minuto (byte 6 en formato DTL)

8086**

Valor no v√°lido para indicar el segundo (byte 7 en formato DTL)

8087**

Valor no v√°lido para indicar el nanosegundo (bytes 8 a 11 en formato DTL)

80B0

Fallo del reloj en tiempo real

* Los c√≥digos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrar√°
m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte tambi√©n".
** Solo si la fecha y hora se indican en el par√°metro IN en formato DTL

Ejemplo
En el siguiente ejemplo se ajusta la fecha y hora del reloj de la CPU. El tipo de datos utilizado
es DATE AND TIME.
Para almacenar los datos es preciso crear tres variables en un bloque de datos global.

Los par√°metros de la instrucci√≥n se interconectan del siguiente modo. Seleccione el tipo de
datos DATE AND TIME.

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2247

Instrucciones
4.1 Instrucciones

Si el contacto NA ("execute") devuelve el estado l√≥gico "TRUE", se ejecuta la instrucci√≥n
"WR_SYS_T". La hora del m√≥dulo del reloj de la CPU se sobrescribe con la hora que debe
ajustarse ("inputTIME"). En el par√°metro de salida RET_VAL ("returnValueT") se indica que la
ejecuci√≥n se ha realizado sin errores.

Existen varias opciones para saber si el reloj de la CPU ha adoptado correctamente la nueva
hora del m√≥dulo ("inputTIME"):
‚óè Desde el display de una CPU S7-1500: Para ello, navegue por el display de la CPU hasta
"Ajustes > Fecha y hora > General".
‚óè Desde el TIA Portal: Utilice la instrucci√≥n "RD_SYS_T (P√°gina 2249)" para leer la hora del
m√≥dulo del reloj de la CPU.
‚óè Desde el TIA Portal: Navegue hasta la opci√≥n "Online y diagn√≥stico" de la CPU y abra la
ficha "Funciones > Ajustar hora".
En el reloj de la CPU la hora del m√≥dulo est√° ajustada como tiempo universal coordinado
(UTC). Para este ejemplo, en el TIA Portal est√° ajustada como hora local la hora central
europea. En consecuencia, en el TIA Portal, en el apartado "Online y diagn√≥stico", se suma
una hora a la hora que se desea ajustar ("inputTIME"). Si se utiliza la hora de verano se
suma una hora adicional. La hora local calculada se muestra en formato de 12 horas.

Encontrar√° informaci√≥n adicional y el c√≥digo del programa para el ejemplo anterior aqu√≠:
Sample Library for Instructions (P√°gina 615)

Consulte tambi√©n
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)

2248

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones

RD_SYS_T: Leer la hora
Descripci√≥n
La instrucci√≥n lee la fecha y hora actuales (hora del m√≥dulo) del reloj de la CPU.
Los datos le√≠dos se devuelven en el par√°metro de salida OUT de la instrucci√≥n. El valor emitido
no contiene indicaciones respecto a la zona horaria local ni al horario de verano.
Nota
Hora de m√≥dulo del reloj de la CPU
El reloj de la CPU interpreta la hora del m√≥dulo como el tiempo universal coordinado (UTC). En
consecuencia, la hora del m√≥dulo se guarda siempre en el reloj de la CPU sin los factores
"zona horaria local" u "horario de verano". El reloj de la CPU calcula su hora local bas√°ndose
en la hora del m√≥dulo.
La hora de m√≥dulo del reloj de la CPU sirve de base para todos los procesos de tiempo que
parten de la CPU. Ejemplos de uso:
‚óè C√°lculo de la hora local del reloj de la CPU bas√°ndose en la hora del m√≥dulo
‚óè Representaci√≥n de la hora del m√≥dulo en "Online y diagn√≥stico" en hora local
‚óè Propiedades de bloques
‚óè Entradas del b√∫fer de diagn√≥stico de la CPU
En la salida RET_VAL se puede consultar si se han producido errores durante la ejecuci√≥n de
la instrucci√≥n.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "RD_SYS_T":
Par√°metro

Declaraci√≥n

Tipo de datos

√Årea de memoria

Descripci√≥n

S7-1200

S7-1500

RET_VAL

Return

INT

INT

I, Q, M, D, L, P

Estado de la instrucci√≥n

OUT

Output

DTL

DT, DTL, LDT

I, Q, M, D, L, P *

Fecha y hora de la CPU

* Los tipos de datos DT y DTL no pueden utilizarse para las √°reas de memoria Entrada, Salida y Marca.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Vista general de los tipos de
datos v√°lidos (P√°gina 241)".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2249

Instrucciones
4.1 Instrucciones

Par√°metro RET_VAL
C√≥digo de error* Descripci√≥n
(W#16#....)
0000

Ning√∫n error

8081

No es posible guardar los datos le√≠dos, porque est√°n fuera del rango admisible para el tipo de datos
seleccionado del par√°metro OUT.
‚óè Con DT: m√≠n. DT#1990-01-01-0:0:0, m√°x. DT#2089-12-31-23:59:59.999
‚óè Con LDT: m√≠n. LDT#1970-01-01-0:0:0.000000000, m√°x. LDT#2262-04-11-23:47:16.854775807
‚óè Con DTL: m√≠n. DTL#1970-01-01-00:00:00.0, m√°x. DTL#2262-04-11-23:47:16.854775807

* Los c√≥digos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrar√°
m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte tambi√©n".

Ejemplo
En el ejemplo siguiente se lee la hora del m√≥dulo del reloj de la CPU. El tipo de datos utilizado
es DATE AND TIME.
Para almacenar los datos se crean dos variables en un bloque de datos global.

Los par√°metros de la instrucci√≥n se interconectan del siguiente modo. Seleccione el tipo de
datos DATE AND TIME.

La hora del m√≥dulo del reloj de la CPU se lee y se indica en el par√°metro de salida OUT
("outputTIME"). En el par√°metro de salida RET_VAL ("returnValue") se indica que la ejecuci√≥n
se ha realizado sin errores.

2250

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrar√° informaci√≥n adicional y el c√≥digo del programa para el ejemplo anterior aqu√≠:
Sample Library for Instructions (P√°gina 615)

Consulte tambi√©n
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)

RD_LOC_T: Leer hora local
Descripci√≥n
La instrucci√≥n lee la hora local actual del reloj de la CPU y emite esta hora en la salida OUT.
Para emitir la hora local se utilizan las indicaciones relativas a la zona horaria y al comienzo de
los horarios de verano e invierno, que se han ajustado al configurar el reloj de la CPU.

Par√°metros
La tabla siguiente muestra los par√°metros de la instrucci√≥n "RD_LOC_T":
Par√°metro

Declaraci√≥n

Tipo de datos
S7-1200

S7-1500

√Årea de memoria

Descripci√≥n

RET_VAL

Return

INT

INT

I, Q, M, D, L, P

Estado de la instrucci√≥n

OUT

Output

DTL

DT, LDT, DTL

I, Q, M, D, L, P *

Hora local

* Los tipos de datos DT y DTL no pueden utilizarse para las √°reas de memoria Entrada, Salida y Marca.

Encontrar√° m√°s informaci√≥n sobre los tipos de datos v√°lidos en "Vista general de los tipos de
datos v√°lidos (P√°gina 241)".

Par√°metro RET_VAL
C√≥digo de error* Descripci√≥n
(W#16#....)
0000

Ning√∫n error

0001

Ning√∫n error. La hora local se devuelve como horario de verano.

8080

No se puede leer la hora local.

8081

No es posible guardar la hora local actual, porque est√° fuera del rango admisible para el tipo de datos
seleccionado del par√°metro OUT.
‚óè Con DT: m√≠n. DT#1990-01-01-0:0:0, m√°x. DT#2089-12-31-23:59:59.999
‚óè Con LDT: m√≠n. LDT#1970-01-01-0:0:0.000000000, m√°x. LDT#2262-04-11-23:47:16.854775807
‚óè Con DTL: m√≠n. DTL#1970-01-01-00:00:00.0, m√°x. DTL#2262-04-11-23:47:16.854775807

* Los c√≥digos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrar√°
m√°s informaci√≥n sobre el cambio de los formatos de visualizaci√≥n en "Consulte tambi√©n".

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

2251

Instrucciones
4.1 Instrucciones

Ejemplo
En el siguiente ejemplo se lee la hora local del reloj de la CPU. El tipo de datos utilizado es
DATE AND TIME.
Para almacenar los datos se crean dos variables en un bloque de datos global.

Los par√°metros de la instrucci√≥n se interconectan del siguiente modo. Seleccione el tipo de
datos DATE AND TIME.

La hora local del reloj de la CPU se lee y se indica en el par√°metro de salida OUT
("outputLocTIME"). En el par√°metro de salida RET_VAL ("returnValue") se indica que la
ejecuci√≥n se ha realizado sin errores y que la hora local se emite como horario de verano con
esta llamada.

Encontrar√° informaci√≥n adicional y el c√≥digo del programa para el ejemplo anterior aqu√≠:
Sample Library for Instructions (P√°gina 615)

Consulte tambi√©n
Cambiar formatos de visualizaci√≥n en el estado del programa (P√°gina 8529)

WR_LOC_T: escribir hora local
Descripci√≥n
La instrucci√≥n "WR_LOC_T" ajusta la fecha y hora del reloj de la CPU. La indicaci√≥n de fecha
y hora se especifica como hora local en el par√°metro de entrada LOCTIME.

2252

Programaci√≥n del PLC
Manual de programaci√≥n y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El valor debe estar dentro del rango siguiente:
‚óè Con DTL: m√≠n. DTL#1970-01-01-00:00:00.0, m√°x. DTL#2200-12-31 23:59:59.999999999
‚óè Con LDT: m√≠n. LDT#1970-01-01-0:0:0.000000000, m√°x. LDT#2200-12-31
23:59:59.999999999
La granularidad en la indicaci√≥n de la hora local y la hora del sistema es espec√≠fica del producto
y es como m√≠nimo de un milisegundo. Al calcul