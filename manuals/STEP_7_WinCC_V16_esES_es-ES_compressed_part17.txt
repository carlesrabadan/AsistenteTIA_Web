datos. Puesto que los
valores de los parámetros de salida solo se muestran en el momento en que son válidos, el
estado correcto debe guardarse en la variable "TSEND.done".
En el parámetro de salida ERROR ("TSEND.error") o en la variable "TSEND.memErrStatus"
se indica que la ejecución se ha realizado sin errores en el ejemplo.

Programación del PLC
Manual de programación y manejo, 11/2019

4085

Instrucciones
4.1 Instrucciones
Segmento 4 (TSEND):
Si TSEND notifica un error ("TSEND.error" es "TRUE"), el estado notificado ("TSEND.status")
se guarda de forma permanente ("TSEND.memErrStatus").
Segmento 5 (TDISCON):
Si el parámetro de entrada REQ ("TDISCON.start") devuelve el estado lógico "TRUE", se inicia
la instrucción "TDISCON". Durante varias llamadas, la instrucción "TDISCON" deshace la
conexión de comunicación. Para ello se consulta la conexión de comunicación utilizada en el
parámetro de entrada ID ("connectionID").
Con el estado lógico "TRUE" en el parámetro de salida DONE ("#doneDISC") y con el valor
"0000" en el parámetro de salida STATUS ("TDISCON.status") se indica que la conexión se ha
establecido correctamente. Puesto que los valores de los parámetros de salida solo se
muestran en el momento en que son válidos, el estado correcto debe guardarse en la variable
"TDISCON.done". Los avisos sobre el establecimiento correcto de la conexión ("TCON.done")
y la transferencia correcta de datos ("TSEND.done") se restablecen.
En el parámetro de salida ERROR ("TDISCON.error") o en la variable
"TDISCON.memErrStatus" se indica que la ejecución se ha realizado sin errores en el ejemplo.

Segmento 6 (TDISCON):
Si TDISCON notifica un error ("TDISCON.error" es "TRUE"), el estado notificado
("TDISCON.status") se guarda de forma permanente ("TDISCON.memErrStatus").

Comportamiento de la CPU 2
Con TCON y TDISCON, el comportamiento es el mismo que en la CPU 1.

4086

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Segmento 3 (TRCV):
De acuerdo con el parámetro de entrada ID ("connectionID"), la instrucción "TRCV" conoce la
conexión de comunicación que debe utilizarse.
Si el parámetro de entrada EN_R ("TRCV.start") devuelve el estado lógico "TRUE", se inicia la
instrucción "TRCV". Durante varias llamadas, la instrucción "TRCV" recibe el juego de datos
transmitido. En el parámetro de entrada DATA ("SLI_plcDB_rcvData_TRCV") se lee el juego
de datos.

La longitud en BYTE del juego de datos realmente transferido se obtiene en el parámetro de
salida LEN ("#length"). Su valor solo se muestra durante el estado correcto. A continuación se
lee "0". Con el parámetro de salida DONE ("#doneRCV") a "TRUE" y el parámetro de salida
STATUS ("TRCV.status") a "0000" se indica la recepción correcta del juego de datos.
Puesto que los valores de los parámetros de salida solo se muestran mientras son válidos,
haga lo siguiente:
● Guarde el estado correcto en la variable "TRCV.done".
● Guarde la longitud en BYTE en la variable "TRCV.readLength".
En el parámetro de salida ERROR ("TRCV.error") o en la variable "TRCV.memErrStatus" se
indica que la ejecución se ha realizado sin errores en el ejemplo.

Segmento 4 (TRCV):
Si TRCV notifica un error ("TRCV.error" es "TRUE"), el estado notificado ("TRCV.status") se
guarda de forma permanente ("TRCV.memErrStatus").

Código del programa
Encontrará información adicional y el código del programa para el ejemplo anterior
aquí: Sample Library for Instructions (Página 615).

Consulte también
TCON: Establecer una conexión (Página 4048)
TDISCON: Desconectar comunicación (Página 4056)

Programación del PLC
Manual de programación y manejo, 11/2019

4087

Instrucciones
4.1 Instrucciones
TSEND: Enviar datos a través de la conexión (Página 4061)
TRCV: Recibir datos a través de la conexión (Página 4069)

Enviar y recibir datos vía Ethernet (UDP) o FDL
TUSEND: Enviar datos
Descripción
TUSEND soporta la transferencia de datos a través de UDP (en las CPU S7-1500 de versión
de firmware V2.0 o superior, a través de las interfaces PROFINET integradas) y conexiones
FDL del S7‑1500 con CM 1542‑5 a partir de V2.0 con el tipo de datos de sistema TCON_FDL.
La instrucción "TUSEND" envía datos al interlocutor de comunicación direccionado con el
parámetro ADDR.
ADVERTENCIA
Transmisión de datos a través de UDP
En la transmisión de datos a través de UDP según RFC 768, los datos se transmiten al
interlocutor sin confirmar y, por lo tanto, sin seguridad. Ello significa que es posible que se
pierdan datos, sin que ello se indique en el bloque.
El riesgo de que se produzcan errores de transferencia no reconocibles aumenta
considerablemente si se van a transferir más de 1472 bytes.
Nota
En procesos de transmisión consecutivos a diferentes interlocutores, en las llamadas de
"TUSEND" solo es necesario adaptar el parámetro ADDR. Sin embargo, se prescinde de la
nueva llamada de las instrucciones "TCON (Página 4045)" y "TDISCON (Página 4056)". Para
que el interlocutor en cuestión pueda recibir datos, deberá tener configurado el puerto UDP
direccionado.

Transmisión de más de 1472 bytes
A partir de la versión V2.5 del firmware de las CPU S7-1500, en la transferencia de datos
mediante UDP no solo es posible enviar como máximo 1472 bytes, sino 2048 bytes si se utiliza
Unicast o Multicast.
Al enviar más de 1472 bytes hay que asegurarse de que el destinatario soporte más de 1472
bytes. Si no es así, el remitente no recibirá comunicación del error de recepción.

Funcionamiento
"TUSEND" es una instrucción asíncrona, de modo que la ejecución de la petición se extiende
a lo largo de varias llamadas. Para iniciar el proceso de transmisión, genere un flanco
ascendente en el parámetro REQ.

4088

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El estado de la petición se indica a través de los parámetros de salida BUSY, DONE, ERROR
y STATUS .
Consulte también: Diferencia entre las instrucciones que funcionan síncronamente y las que
funcionan asíncronamente (Página 618).
En la tabla siguiente se muestra la correspondencia entre BUSY, DONE y ERROR. Permite
determinar en qué estado se encuentra "TUSEND" actualmente o cuándo finalizó la
transmisión.
BUSY

DONE

ERROR

Descripción

TRUE

FALSE

FALSE

La petición está en proceso.

FALSE

TRUE

FALSE

La petición ha finalizado correctamente.

FALSE

FALSE

TRUE

La petición se ha finalizado con un error. La causa del error se puede consultar
en el parámetro STATUS.

FALSE

FALSE

FALSE

No se ha asignado ninguna (nueva) petición a la instrucción.

Nota
Debido al funcionamiento asíncrono de "TUSEND", los datos del área de transmisión deben
mantenerse coherentes hasta que el parámetro DONE o el parámetro ERROR adopten el
valor TRUE.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "TUSEND":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

El parámetro de control REQUEST activa la petición
de transmisión con un flanco ascendente.
Los datos se transmiten desde el área indicada con
DATA y LEN.

ID

Input

CONN_OU
C

I, Q, M, D, L o cons‐
tante

LEN

Input

UDINT

I, Q, M, D, L o cons‐
tante

Referencia a la respectiva conexión entre el progra‐
ma de usuario y la capa de comunicación del siste‐
ma operativo. ID debe coincidir con el parámetro ID
correspondiente en la descripción local de la cone‐
xión en la instrucción "TCON".
Rango de valores: W#16#0001 a W#16#0FFF
Número de bytes que deben enviarse con la petición
Rango de valores en Ethernet/UDP: 1 a 1472 (a
partir de la versión de firmware V2.5 de las CPU
S7-1500 con Unicast o Multicast: 1 a 2048)
En conexiones FDL del CM 1542‑5 la longitud má‐
xima es de 240 bytes. Tenga en cuenta las longitu‐
des máximas que se pueden procesar en los inter‐
locutores.

Programación del PLC
Manual de programación y manejo, 11/2019

4089

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

DONE

Output

BOOL

I, Q, M, D, L

Parámetro de estado DONE:
● 0: la petición aún no se ha iniciado o todavía se
está ejecutando.
● 1: petición finalizada sin errores. El valor solo se
muestra durante un ciclo.

BUSY

Output

BOOL

I, Q, M, D, L

● BUSY = 1: la petición no ha finalizado todavía.
No es posible iniciar otra petición.
● BUSY = 0: la petición ha finalizado.

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado ERROR:
● ERROR = 1: durante la ejecución se ha
producido un error. STATUS devuelve
información detallada sobre el tipo de error.

STATUS

Output

WORD

I, Q, M, D, L

Parámetro de estado STATUS: Información de error

DATA

InOut

VARIANT

I, Q, M, D

Área de transmisión, contiene la dirección y la lon‐
gitud
La dirección remite a:
● La memoria imagen de proceso de las entradas
● La memoria imagen de proceso de las salidas
● Una marca
● Un bloque de datos
Para transferir estructuras, estas deben ser idénti‐
cas tanto en el lado de transmisión como en el de
recepción.

ADDR

InOut

VARIANT

D

Información de dirección del interlocutor
Consulte también: Direccionamiento del interlocutor
remoto a través de TADDR_Param. (Página 4096)
y Direccionamiento del interlocutor remoto a través
de TADDR_SEND_QDN y TADDR_RCV_IP (Pági‐
na 4098)
y AUTOHOTSPOT

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetros ERROR y STATUS
ERROR

STATUS* Explicación
(W#16#...)

0

0000

La petición de transmisión ha finalizado sin errores

0

7000

No se está procesando ninguna petición

0

7001

Inicio de la ejecución de la petición, enviando los datos.
Nota: En esta fase de la ejecución, el sistema operativo accede a los datos del área de transmisión
DATA.

4090

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
ERROR

STATUS* Explicación
(W#16#...)

0

7002

Llamada intermedia (REQ irrelevante), la petición se está ejecutando
Nota: En esta fase de la ejecución, el sistema operativo accede a los datos del área de transmisión
DATA.

1

8085

El parámetro LEN tiene el valor "0" o excede el valor máximo admisible.

1

8086

El parámetro ID se encuentra en un rango de valores no válido.

0

8088

El parámetro LEN es mayor que el área de memoria indicada en DATA.

1

8089

El parámetro ADDR no apunta a un bloque de datos con la estructura TADDR_Param o
TADDR_SEND_QDN.

1

80A1

Error de comunicación:
● Todavía no se ha establecido la conexión indicada entre el programa de usuario y la capa de
comunicación del sistema operativo.
● Se está estableciendo la conexión indicada entre el programa de usuario y la capa de
comunicación del sistema operativo. No es posible transmitir a través de esta conexión.
● La interfaz se está reinicializando.

1

80B1

El parámetro DATA se ha modificado antes de finalizar la petición en curso.

1

80A4

La dirección IP (en el parámetro ADDR) del punto final de la conexión no es válida o coincide con
la dirección IP propia.

1

80B3

● La variante de protocolo parametrizada (parámetro connection_type en la descripción de la
conexión) no es UDP. Utilice "TSEND (Página 4061)".

1

80B7

La longitud de la estructura referenciada por el parámetro ADDR no es 8 bytes.

1

80C3

● Ya se está ejecutando un bloque con esta ID en otra clase de prioridad.

● Parámetro ADDR: Indicación no válida para n.º de puerto.

● Falta de recursos internos
1

80C4

Error de comunicación temporal:
● El interlocutor remoto no es accesible.
● En este momento no es posible establecer la conexión entre el programa de usuario y la capa
de comunicación del sistema operativo.
● La interfaz se está reparametrizando.
● Solo con FDL / PROFIBUS: temporalmente no se dispone de recursos de recepción en el
interlocutor. El interlocutor no está preparado para la recepción.
● El sistema R/H está en el estado del sistema SYNCUP o se produce una conmutación primariareserva. La conexión se cierra. El procesamiento de TUSEND se detiene.

1

80C5

● El interlocutor ha finalizado la conexión.
● LSAP del interlocutor remoto no habilitado

1

80C6

Error de red:
● No es posible acceder al interlocutor remoto.
● Interrupción física en PROFIBUS

1

80C7

Rebase de tiempo de la ejecución.

Programación del PLC
Manual de programación y manejo, 11/2019

4091

Instrucciones
4.1 Instrucciones
ERROR

STATUS* Explicación
(W#16#...)

1

80D3

No se ha podido resolver el nombre de dominio completo. Causas posibles:
● El servidor DNS no está accesible, p. ej. porque está apagado o porque no se puede acceder
al puerto remoto.
● Se ha producido un error durante la comunicación con el servidor DNS.
● El servidor DNS ha devuelto una respuesta DNS válida, pero la respuesta no contenía ninguna
dirección IPv4.

1

80EA

No se soporta el protocolo DTLS (UDP)

1

xxyy, xx >
80

Información de error general, consulte Evaluación de errores con el parámetro de salida RET_VAL
(Página 174)

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa con TUSEND y TURCV (Página 4099).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
GET_ERR_ID: Consultar ID de error localmente (Página 933)

TURCV: Recibir datos
Descripción
La instrucción "TURCV" recibe datos a través de UDP (en las CPU S7-1500 con firmware de
la versión V2.0 o superior, a través de las interfaces PROFINET también como comunicación
multicast) y conexiones FDL del S7‑1500 con CM 1542‑5 a partir de V2.0. Tras la finalización
correcta de "TURCV" en el parámetro ADDR se pone a disposición la dirección del interlocutor
remoto, es decir, del transmisor.
ADVERTENCIA
Transmisión de datos sin seguridad
En la transmisión de datos a través de UDP según RFC 768, los datos se transmiten al
interlocutor remoto sin confirmar y, por lo tanto, sin seguridad. Ello significa que es posible
que se pierdan datos, sin que ello se indique en el bloque.

Recepción de más de 1472 bytes
A partir de la versión V2.5 del firmware de las CPU S7-1500, en la transferencia de datos
mediante UDP ya no es posible recibir como máximo 1472 bytes, sino 2048 bytes.

4092

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En cualquier caso, si el módulo destinatario soporta como máximo 1472 bytes y el módulo
remitente transfiere más de 1472 bytes, TURCV devuelve en el parámetro STATUS el valor
W#16#8085 o W#16#80C9

Funcionamiento
"TURCV" es una instrucción asíncrona, de modo que la ejecución de la petición se extiende a
lo largo de varias llamadas. Para iniciar la petición de recepción, llame la instrucción "TURCV"
con EN_R = 1.
El estado de la petición se indica a través de los parámetros de salida BUSY, DONE, ERROR
y STATUS .
Consulte también: Diferencia entre las instrucciones que funcionan síncronamente y las que
funcionan asíncronamente (Página 618).
En la tabla siguiente se muestra la correspondencia entre BUSY, NDR y ERROR. Permite
determinar en qué estado se encuentra TURCV actualmente o cuándo finalizó la recepción.
BUSY

NDR

ERROR

Descripción

TRUE

FALSE

FALSE

La petición está en proceso.

FALSE

TRUE

FALSE

La petición ha finalizado correctamente. Nuevos datos recibidos.

FALSE

FALSE

TRUE

La petición se ha finalizado con un error. La causa del error se puede consultar
en el parámetro STATUS.

FALSE

FALSE

FALSE

No se ha asignado ninguna (nueva) petición a la instrucción.

Nota
Debido al funcionamiento asíncrono de "TURCV", los datos no son coherentes en el área de
recepción hasta que el parámetro NDR no adopta el valor TRUE.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "TURCV":
Parámetro

Declaración

Tipo de da‐ Área de memoria
tos

Descripción

EN_R

Input

BOOL

Parámetro de control enabled to receive

I, Q, M, D, L o
constante

Si EN_R = 1 "TURCV" pasa a disponibilidad de recepción.
La petición de recepción se está ejecutando.

ID

Input

CONN_OU
C

I, Q, M, D, L o
constante

Referencia a la conexión correspondiente entre el progra‐
ma de usuario y la capa de comunicación del sistema ope‐
rativo. ID debe coincidir con el parámetro ID correspon‐
diente en la descripción local de la conexión.
Rango de valores: W#16#0001 a W#16#0FFF

LEN

Input

UDINT

I, Q, M, D, L o
constante

Longitud del área de recepción en bytes: 0 (recomendado)
o bien 1 a 1472 (a partir de la versión de firmware V2.5 de
las CPU S7-1500 con Unicast o Multicast: 1 a 2048)
Valor máximo en el CM 1542‑5 (FDL): 240

Programación del PLC
Manual de programación y manejo, 11/2019

4093

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐ Área de memoria
tos

Descripción

NDR

Output

BOOL

Parámetro de estado NDR:

I, Q, M, D, L

● NDR = 0: la petición aún no se ha iniciado o todavía
está en curso.
● NDR = 1: la petición ha finalizado correctamente.
ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado ERROR:
● ERROR=1: durante la ejecución se ha producido un
error. STATUS devuelve información detallada sobre
el tipo de error.

Output

BUSY

BOOL

I, Q, M, D, L

● BUSY = 1: la petición no ha finalizado todavía. No es
posible iniciar otra petición.
● BUSY = 0: la petición ha finalizado.

Output

STATUS

WORD

I, Q, M, D, L

Parámetro de estado STATUS: Información de error

RCVD_LEN

Output

UDINT

I, Q, M, D, L

Número de datos recibidos realmente en bytes.

DATA

InOut

VARIANT

I, Q, M, D, L

Área de recepción
La dirección hace referencia a:
● La memoria imagen de proceso de las entradas
● La memoria imagen de proceso de las salidas
● Una marca
● Un bloque de datos
Para transferir estructuras, estas deben ser idénticas tanto
en el lado de transmisión como en el de recepción.

ADDR

InOut

VARIANT

D

Información de dirección del interlocutor remoto
Consulte también: Direccionamiento del interlocutor remo‐
to a través de TADDR_Param. (Página 4096) y Direccio‐
namiento del interlocutor remoto a través de
TADDR_SEND_QDN y TADDR_RCV_IP (Página 4098) y
AUTOHOTSPOT

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetros ERROR y STATUS
ERROR

STATUS*
(W#16#...)

Explicación

0

0000

Se han aplicado nuevos datos. La longitud actual de los datos recibidos se indica en RCVD_LEN.

0

7000

El bloque no está preparado para la recepción

0

7001

El bloque está preparado para la recepción, la petición de recepción se ha activado

0

7002

Llamada intermedia, la petición de recepción está en proceso
Nota: En esta fase de ejecución, "TURCV" escribe datos en el área de recepción. Por ello, en caso
de error es posible que haya datos incoherentes en el área de recepción.

1

8085

El parámetro LEN es mayor que el valor máximo permitido, o ha modificado uno de los parámetros
LEN o DATA respecto a la primera llamada

1

8086

El parámetro ID se encuentra en un rango de valores no válido

4094

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
ERROR

STATUS*
(W#16#...)

Explicación

1

8088

● El área de recepción es demasiado pequeña
● El valor de LEN es mayor que el área de recepción especificada por DATA

1

8089

El parámetro ADDR no apunta a un bloque de datos con la estructura TADDR_Param o
TADDR_RCV_IP.

1

80A1

Error de comunicación:
● Todavía no se ha establecido la conexión indicada entre el programa de usuario y la capa de
comunicación del sistema operativo.
● Se está estableciendo la conexión indicada entre el programa de usuario y la capa de
comunicación del sistema operativo. No es posible ejecutar una petición de recepción a través
de esta conexión.
● La interfaz se está reparametrizando.

1

80B1

El parámetro DATA se ha modificado antes de finalizar la petición en curso.

1

80B3

La variante de protocolo parametrizada (parámetro connection_type en la descripción de la cone‐
xión) no es UDP. Utilice "TRCV (Página 4065)".

1

80B7

la longitud del parámetro ADDR no equivale a 8 bytes.

1

80C3

● Ya se está ejecutando un bloque con esta ID en otra clase de prioridad.
● Falta de recursos internos

1

80C4

Error de comunicación temporal:
● La interfaz se está reparametrizando.
● El sistema R/H está en el estado del sistema SYNCUP o se produce una conmutación primariareserva. La conexión se cierra. El procesamiento de TURCV se detiene.

1

80C5

El interlocutor remoto ha finalizado la conexión.

1

80C7

Rebase de tiempo de la ejecución.

1

80C9

Con RFC1006/UDP: los datos recibidos tienen una longitud mayor de lo esperado (superan el
tamaño del búfer de recepción).

1

80EA

No se soporta el protocolo DTLS (UDP)

1

xxyy, xx >
80

Información de error general, consulte Evaluación de errores con el parámetro de salida RET_VAL
(Página 174)

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa con TUSEND y TURCV (Página 4099).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
TCON: Establecer una conexión (Página 4045)
TDISCON: Desconectar comunicación (Página 4056)
GET_ERR_ID: Consultar ID de error localmente (Página 933)

Programación del PLC
Manual de programación y manejo, 11/2019

4095

Instrucciones
4.1 Instrucciones

Direccionamiento del interlocutor remoto a través de TADDR_Param.
Vista general
Si se utiliza una conexión UDP, la información de dirección del interlocutor remoto se puede
guardar en el tipo de datos de sistema TADDR_Param:
● En el caso de la instrucción "TUSEND (Página 4088)", a través de TADDR_Param se
transfiere la información de dirección del receptor en el parámetro ADDR.
A partir del tipo de datos de sistema la instrucción lee la información de dirección guardada
que está asociada al interlocutor remoto.
Nota
Soporte de un Limited Broadcast
Para las CPU S7-1500 con versión de firmware V2.0 o superior se aplica lo siguiente para
la instrucción TUSEND: Cuando se direcciona el interlocutor remoto mediante el tipo de
datos de sistema TADDR_Param se soporta un Limited Broadcast (255.255.255.255 como
dirección IP del interlocutor remoto) siempre que se cumplan de forma consecuente las
reglas de routing IP. Como consecuencia, los Limited Broadcasts solo se envían por la
interfaz desde la que se accede a un router predeterminado según la configuración.
Se recomienda utilizar direcciones Directed Broadcast, pues estas no están sometidas a
dicha restricción, tal como prescriben las normas IP.
● En el caso de la instrucción "TURCV (Página 4092)", a través de TADDR_Param se recibe
la dirección del remitente en el parámetro ADDR.
La instrucción escribe la información de dirección en el tipo de datos de sistema.

Estructura de la información de dirección conforme a TADDR_Param
El tipo de datos de sistema TADDR_Param contiene la información de dirección del
interlocutor remoto, la cual está compuesta por la dirección IP y el número de puerto.

4096

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El tipo de datos de sistema TADDR_Param tiene la estructura siguiente:
Byte

Parámetro

de 0 a 3 rem_ip_addr

Tipo de datos

Valor de arran‐ Descripción
que

ARRAY [1..4] of
USINT

B#16#00 ...

● Dirección IP del interlocutor remoto, p. ej.
192.168.002.003:
–

rem_ip_addr[1] = B#16#C0 (192)

–

rem_ip_addr[2] = B#16#A8 (168)

–

rem_ip_addr[3] = B#16#02 (002)

–

rem_ip_addr[4] = B#16#03 (003)

Consulte la dirección IP en las propiedades de la interfaz
del interlocutor remoto en la vista Dispositivos y redes.
Alternativamente, esta también se visualiza en las
propiedades de la conexión UDP en Detalles de dirección.
● Dirección Multicast de un grupo IPv4-Multicast (para la
instrucción "TUSEND" con las CPU S7-1500 de versión
de firmware V2.0 o superior. Nota: Para la instrucción
"TURCV" es necesario indicar la dirección IP del emisor
también con comunicación Multicast).
4a5

rem_port_nr

UINT

B#16#00 ...

Número de puerto remoto (para valores posibles véase: AU‐
TOHOTSPOT):
● rem_port_nr[1] = high byte del n.º de puerto en
representación hexadecimal
● rem_port_nr[2] = byte bajo del n.º de puerto en
representación hexadecimal
Consulte el número de puerto en las propiedades de la cone‐
xión UDP en la vista Dispositivos y redes. En Detalles de di‐
rección se visualiza el número de puerto como valor decimal.
Ejemplo: número de puerto = 2000 (decimal) / W#16#07D0
(hexadecimal)
● rem_port_nr[1] = 07 (high byte)
● rem_port_nr[2] = D0 (low byte)

6a7

reserved

WORD

B#16#00 ...

No se utiliza. No cambie el valor "0" en este parámetro.

Crear TADDR_Param en un bloque de datos
Para crear TADDR_Param, se dispone de las siguientes posibilidades:
● Cree un nuevo bloque de datos y seleccione como tipo TADDR_Param en el cuadro de
diálogo "Agregar nuevo bloque".
● Abra un bloque de datos existente, cree una nueva variable e introduzca TADDR_Param en
la columna Tipo de datos.
Un bloque de datos puede contener varios tipos de datos de sistema TADDR_Param.

Programación del PLC
Manual de programación y manejo, 11/2019

4097

Instrucciones
4.1 Instrucciones

Direccionamiento del interlocutor remoto a través de TADDR_SEND_QDN y TADDR_RCV_IP
Descripción general
Al enviar datos a través de UDP, para las CPU S7-1500 con versión de firmware V2.0 o
superior el receptor se puede direccionar con su nombre de dominio completo. Para ello, en la
instrucción TUSEND, parámetro ADDR, remita a una estructura del tipo TADDR_SEND_QDN.
El receptor puede devolver una dirección IPv4 o una dirección IPv6. Para ello, en la instrucción
TURCV, parámetro ADDR, remita a una estructura del tipo TADDR_RCV_IP. Es la única que
puede acoger ambos tipos de direcciones IP.

Estructura de la información de dirección conforme a TADDR_SEND_QDN
El tipo de datos de sistema TADDR_SEND_QDN contiene la información de dirección del
interlocutor remoto (del receptor), la cual está compuesta por el nombre de dominio completo
y el número de puerto.
Tiene la estructura siguiente:
Byte

Parámetro

Tipo de datos

Valor de arran‐ Descripción
que

de 0 a
255

RemoteQDN

ARRAY of
STRING[1..254]

-

Fully qualified domain name del punto final del interlocutor,
que debe terminar con ".".
Tenga en cuenta que en un entorno SIMATIC el nombre, in‐
cluido el punto final, no puede tener más de 254 caracteres de
longitud.

de 256
a 257

RemotePort

UINT

B#16#00 ...

Número de puerto remoto (para valores posibles véase: AU‐
TOHOTSPOT):
● RemotePort[1] = high byte del n.º de puerto en
representación hexadecimal
● RemotePort[2] = low byte del n.º de puerto en
representación hexadecimal
Ejemplo: número de puerto = 2000 (decimal) / W#16#07D0
(hexadecimal)
● RemotePort[1] = 07 (high byte)
● RemotePort[2] = D0 (low byte)

de 258
a 259

reserved

WORD

W#16#00

No se utiliza. No cambie el valor "0" en este parámetro.

Nota
Tiempo de ejecución de la instrucción TUSEND
En cada llamada de TUSEND, el nombre de dominio completo se resuelve en la dirección IP.
Como consecuencia, el tiempo de ejecución de TUSEND es mayor que si se llama al receptor
directamente a través de su dirección IPv4.

4098

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Estructura de la información de dirección conforme a TADDR_RCV_IP
El tipo de datos de sistema TADDR_RCV_IP contiene la información de dirección del
interlocutor remoto (del emisor), compuesta por la dirección IP, el número de puerto y la
información sobre si la dirección IP es una dirección IPv4 o IPv6.
Tiene la estructura siguiente:
Byte

Parámetro

Tipo de datos

Valor de arran‐ Descripción
que

de 0 a
15

RemoteAd‐
dress

ARRAY [1..16] of
BYTE

B#16#00 ...

Dirección IP del interlocutor remoto, p. ej. 192.168.002.003
para la dirección IPv4:
● RemoteAddress[1] = B#16#C0 (192)
● RemoteAddress[2] = B#16#A8 (168)
● RemoteAddress[3] = B#16#02 (002)
● RemoteAddress[4] = B#16#03 (003)
Para una dirección IPv6 se aplica análogamente.

de 16 a
17

RemotePort

UINT

B#16#00 ...

Número de puerto remoto (para valores posibles véase: AU‐
TOHOTSPOT):
● RemotePort[1] = high byte del n.º de puerto en
representación hexadecimal
● RemotePort[2] = low byte del n.º de puerto en
representación hexadecimal
Ejemplo: número de puerto = 2000 (decimal) / W#16#07D0
(hexadecimal)
● RemotePort[1] = 07 (high byte)
● RemotePort[2] = D0 (low byte)

18

RemAddrTy‐
pe

BYTE

reserved

BYTE

B#16#00

Tipo de dirección remota:
● B#16#03: IPv4
● B#16#04: IPv6

19

B#16#00

No se utiliza. No cambie el valor "0" en este parámetro.

Ejemplo de programa con TUSEND y TURCV
Introducción
En el ejemplo siguiente se utiliza una conexión UDP configurada entre dos CPU de la serie
S7-1500. Por medio de las instrucciones "TUSEND" y "TURCV" se envía un juego de datos de
la CPU 1 a la CPU 2.

Programación del PLC
Manual de programación y manejo, 11/2019

4099

Instrucciones
4.1 Instrucciones

Requisitos
● Se han creado dos CPU de la serie S7-1500 y se han conectado entre sí vía PROFINET.
Hay una conexión UDP configurada.

● En "<CPU> > Propiedades > Protección" se ha ajustado para las CPU un nivel de
protección bajo para garantizar que se permitan accesos de lectura y escritura.

Programa de la CPU 1
Para el juego de datos se crea el tipo de datos PLC "TUSEND_User".

Para la transferencia de datos se crea el siguiente bloque de datos
("SLI_plcDB_sendData_TUSEND") sobre la base del tipo de datos PLC "TUSEND_User".

Para el direccionamiento del interlocutor se crea el siguiente bloque de datos
("SLI_plcDB_taddr_param_TUSEND") sobre la base del tipo de datos de sistema
"TADDR_Param".

4100

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará los datos de dirección en la "Vista de redes" bajo "Conexiones > Propiedades >
Detalles de direcciones". En "Local" de los detalles de direcciones se indican los datos de la
CPU que se ha seleccionado previamente. En la siguiente figura está seleccionada la CPU 1
("TUsend").

Para almacenar los datos debe crearse un bloque de datos global ("SLI_gDB_TUSEND") con
las estructuras y variables siguientes.

Se crea el FB "SLI_FB_TUSEND". En él se crean las siguientes variables locales.

Segmento 1: Los parámetros de la instrucción "TUSEND" se interconectan del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

4101

Instrucciones
4.1 Instrucciones

Segmento 2: En caso de fallo de TUSEND, guarde el estado del siguiente modo.

Programa de la CPU 2
Para el juego de datos se crea el tipo de datos PLC "TUSEND_User" siguiendo el ejemplo de
la CPU 1.
Para la recepción de datos se crea el siguiente bloque de datos
("SLI_plcDB_rcvData_TURCV") sobre la base del tipo de datos PLC "TUSEND_User".

4102

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Para el direccionamiento del interlocutor se crea el siguiente bloque de datos
("SLI_plcDB_taddr_param_TURCV") sobre la base del tipo de datos de sistema
"TADDR_Param".

Para almacenar los datos debe crearse un bloque de datos global ("SLI_gDB_TURCV") con las
estructuras y variables siguientes.

Se crea el FB "SLI_FB_TURCV". En él se crean las siguientes variables locales.

Segmento 1: Los parámetros de la instrucción "TURCV" se interconectan del siguiente modo.

Programación del PLC
Manual de programación y manejo, 11/2019

4103

Instrucciones
4.1 Instrucciones

Segmento 2: En caso de fallo de TURCV, guarde el estado del siguiente modo.

Asignar una conexión de comunicación
Los parámetros de direccionamiento para conectar las dos CPU deben ser unitarios.
● En cada parámetro de entrada ID ("connectionID") debe almacenarse el valor hexadecimal
del identificador de hardware de la conexión UDP configurada.
Encontrará el identificador de hardware en la "Vista de redes" bajo "Conexiones".

Resultado de la CPU 1
Segmento 1 (TUSEND):
De acuerdo con el parámetro de entrada ID ("connectionID"), la instrucción "TUSEND" conoce
la conexión de comunicación que debe utilizarse. Mediante el parámetro de entrada ADDR

4104

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
("SLI_plcDB_taddr_param_TUSEND") es posible direccionar el interlocutor de la
comunicación (CPU 2).
Si el parámetro de entrada REQ ("TUSEND.start") devuelve el estado lógico "TRUE", se inicia
la instrucción "TUSEND". Durante varias llamadas, la instrucción "TUSEND" transfiere el juego
de datos leído en el parámetro de entrada DATA ("SLI_plcDB_sendData_TUSEND"). De
acuerdo con el valor del parámetro de entrada LEN ("TUSEND.maxLength"), el tamaño del
juego de datos que debe transmitirse es ilimitado.
Con el parámetro de salida DONE ("#doneSEND") a "TRUE" y el parámetro de salida STATUS
("TUSEND.status") a "0000" se indica la transmisión correcta del juego de datos. Puesto que
los valores de los parámetros de salida solo se muestran en el momento en que son válidos,
el estado correcto debe guardarse en la variable "TUSEND.done".
En el parámetro de salida ERROR ("TUSEND.error") o en la variable
"TUSEND.memErrStatus" se indica que la ejecución se ha realizado sin errores en el ejemplo.

Segmento 2 (TUSEND):
Si TUSEND notifica un error ("TUSEND.error" es "TRUE"), el estado notificado
("TUSEND.status") se guarda de forma permanente ("TUSEND.memErrStatus").

Resultado de la CPU 2:
Segmento 1 (TURCV):
De acuerdo con el parámetro de entrada ID ("connectionID"), la instrucción "TURCV" conoce
la conexión de comunicación que debe utilizarse. El parámetro de entrada ADDR
("SLI_plcDB_taddr_param_TURCV") se puede direccionar el interlocutor de la comunicación
(CPU 1).
Si el parámetro de entrada EN_R ("TURCV.start") devuelve el estado lógico "TRUE", se inicia
la instrucción "TURCV". Durante varias llamadas, la instrucción "TURCV" recibe el juego de
datos transmitido. En el parámetro de entrada DATA ("SLI_plcDB_rcvData_TURCV") se lee el
juego de datos.

Programación del PLC
Manual de programación y manejo, 11/2019

4105

Instrucciones
4.1 Instrucciones
La longitud en BYTE del juego de datos realmente transferido se ôbtiene mediante el
parámetro de salida LEN ("#length"). Su valor solo se muestra durante el estado correcto. A
continuación se lee "0". Con el parámetro de salida DONE ("#doneRCV") a "TRUE" y el
parámetro de salida STATUS ("TURCV.status") a "0000" se indica la recepción correcta del
juego de datos.
Puesto que los valores de los parámetros de salida solo se muestran mientras son válidos,
haga lo siguiente:
● Guarde el estado correcto en la variable "TURCV.done".
● Guarde la longitud en BYTE en la variable "TURCV.readLength".
En el parámetro de salida ERROR ("TURCV.error") o en la variable "TURCV.memErrStatus"
se indica que la ejecución se ha realizado sin errores en el ejemplo.

Segmento 2 (TURCV):
Si TURCV notifica un error ("TURCV.error" es "TRUE"), el estado notificado ("TURCV.status")
se guarda de forma permanente ("TURCV.memErrStatus").

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
TUSEND: Enviar datos (Página 4088)
TURCV: Recibir datos (Página 4092)

T_RESET: Reiniciar conexión
Descripción
La instrucción "T_RESET" deshace y vuelve a establecer una conexión existente.

4106

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los puntos finales locales de la conexión se conservan. Se generan de forma automática:
● Si se ha configurado una conexión y se ha cargado en la CPU.
● Si se ha creado una conexión a través del programa de usuario, por ejemplo llamando la
instrucción "TCON (Página 4045)".
La instrucción "T_RESET" se puede ejecutar con todos los tipos de conexión (TCP, UDP, ISO
on TCP, etc.). A este respecto es indistinto si se ha utilizado la interfaz local de la CPU o la
interfaz de un CM/CP para la conexión.
Tras llamar la instrucción "T_RESET" a través del parámetro REQ, se deshace la conexión
especificada mediante el parámetro ID y, en caso necesario, se vacía el búfer para enviar y
recibir datos. Al interrumpirse la conexión, se interrumpen también las transmisiones de datos
que estén en curso. Con ello se corre el peligro de que se puedan perder datos de una
transmisión en curso. Después, la CPU definida como interlocutor activo intenta restablecer
automáticamente la conexión interrumpida. Por ello, no es necesario llamar la instrucción
"TCON (Página 4045)" para restablecer la conexión.
El estado de la petición se indica a través de los parámetros de salida DONE, BUSY y STATUS.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "T_RESET":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Parámetro de control REQUEST, inicia la pe‐
tición para deshacer la conexión dada por ID.
La petición se inicia con un flanco ascendente.

ID

Input

CONN_OUC

I, Q, M, D, L o cons‐
tante

Referencia a la conexión con el interlocutor
pasivo que se debe deshacer. ID debe coinci‐
dir con el parámetro ID correspondiente en la
descripción local de la conexión.
Rango de valores: W#16#0001 a W#16#0FFF

DONE

Output

BOOL

I, Q, M, D, L

Parámetro de estado DONE
● 0: la petición aún no se ha iniciado o
todavía se está ejecutando.
● 1: petición finalizada sin errores

BUSY

Output

BOOL

I, Q, M, D, L

Parámetro de estado BUSY
● 0: la petición ha finalizado.
● 1: la petición todavía no ha finalizado.

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado ERROR
● 0: no se ha producido ningún error.
● 1: se ha producido un error durante la
ejecución. El parámetro STATUS devuelve
información detallada sobre el tipo de error

STATUS

Output

WORD

I, Q, M, D, L

Parámetro de estado STATUS
Información de error (véase tabla "Parámetro
STATUS")

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

4107

Instrucciones
4.1 Instrucciones

Parámetro STATUS
STATUS*
(W#16#...)

Explicación

0000

Ningún error.

0001

La conexión no se ha establecido.

7000

No se está procesando ninguna petición.

7001

Se ha iniciado la interrupción de la conexión.

7002

Se está realizando la interrupción de la conexión.

8081

La conexión indicada en el parámetro ID no se conoce.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa con T_RESET (Página 4108).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

Ejemplo de programa con T_RESET
Introducción
En el ejemplo siguiente se utiliza una conexión configurada (p. ej. UDP) entre dos CPU
(S7-1500). Con la instrucción "T_RESET" se restablece la conexión.

4108

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Requisitos
● Se han creado dos CPU de la serie S7-1500 y se han conectado entre sí vía PROFINET.
Hay una conexión UDP configurada.

● En "<CPU> > Propiedades > Protección" se ha ajustado para las CPU un nivel de
protección bajo para garantizar que se permitan accesos de lectura y escritura.

Crear variables e interconectar parámetros (programa de la CPU 1)
Para almacenar los datos debe crearse un bloque de datos global ("SLI_gDB_T_RESET") con
las estructuras y variables siguientes.

Se crea el FB "SLI_FB_T_RESET". En él se crean las siguientes variables locales.

Segmento 1: Los parámetros de la instrucción "T_RESET" se interconectan del siguiente
modo.

Programación del PLC
Manual de programación y manejo, 11/2019

4109

Instrucciones
4.1 Instrucciones

Segmento 2: En caso de fallo de T_RESET, guarde el estado del siguiente modo.

Segmento 3: Para restablecer el parámetro "REQ" se crean las interconexiones siguientes.

Asignar una conexión de comunicación
El parámetro de direccionamiento de la conexión debe modificarse.
● En el parámetro de entrada ID ("connectionID") debe almacenarse el valor hexadecimal del
identificador de hardware de la conexión UDP configurada.
Encontrará el identificador de hardware en la "Vista de redes" bajo "Conexiones".

4110

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Resultado
Segmento 1:
De acuerdo con el parámetro de entrada ID ("connectionID"), la instrucción "T_RESET" conoce
la conexión de comunicación que debe utilizarse.
Si el parámetro de entrada REQ ("T_RESET.start") devuelve el estado lógico "TRUE", se inicia
la instrucción "T_RESET". La instrucción "T_RESET" deshace la conexión de comunicación
indicada. Se cancelan todas las peticiones que utilizan dicha conexión. A continuación, el
interlocutor activo (CPU 1) restablece automáticamente la conexión.
Con el parámetro de salida DONE ("#done") a "TRUE" y el parámetro de salida STATUS
("T_RESET.status") a "0000" se indica la transmisión correcta del juego de datos.
Puesto que los valores de los parámetros de salida solo se muestran en el momento en que
son válidos, el estado correcto debe guardarse en la variable "T_RESET.done".
En el parámetro de salida ERROR ("T_RESET.error") o en la variable
"T_RESET.memErrStatus" se indica que la ejecución se ha realizado sin errores en el ejemplo.

Segmento 2:
Si T_RESET notifica un error ("T_RESET.error" es "TRUE"), el estado notificado
("T_RESET.status") se guarda de forma permanente ("T_RESET.memErrStatus").
Segmento 3:
Una vez ejecutada correctamente T_RESET ("T_RESET.done") se detiene T_RESET.

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
T_RESET: Reiniciar conexión (Página 4106)

Programación del PLC
Manual de programación y manejo, 11/2019

4111

Instrucciones
4.1 Instrucciones

T_DIAG: Comprobar conexión
Descripción
La instrucción "T_DIAG" sirve para comprobar el estado de una conexión y leer información
adicional sobre el punto final local de dicha conexión.
● La conexión se referencia a través del parámetro ID. Pueden leerse puntos finales de la
conexión tanto configurados en el editor de conexiones como programados (p. ej., con la
instrucción "TCON").
Los puntos finales temporales de la conexión (originados, p. ej., al conectar una estación de
ingeniería) no pueden diagnosticarse porque en este caso tampoco se crea un ID de
conexión.
● La información leída sobre la conexión se guarda en una estructura referenciada a través
del parámetro RESULT.
● El parámetro de salida STATUS indica si ha sido posible leer la información sobre la
conexión. Únicamente si la instrucción "T_DIAG" ha finalizado con STATUS = W#16#0000
y ERROR = FALSE, es válida la información sobre la conexión en la estructura del
parámetro RESULT.
En caso de error, no puede evaluarse la información sobre la conexión.

Posible información sobre la conexión
Para leer la información sobre la conexión, en el parámetro RESULT pueden utilizarse dos
estructuras diferentes:
● La estructura "TDiag_Status" solo contiene la principal información sobre un punto final de
la conexión, como puede ser el protocolo utilizado, el estado de la conexión o la cantidad
de datos enviados o recibidos.
● La estructura "TDiag_StatusExt" suministra, además de la información más relevante, el
número de intentos de conexión, la causa de una posible interrupción de la conexión, etc.
(solo para las CPU S7-1500).
El formato y los parámetros de ambas estructuras se describen más adelante (véase la tabla
"Estructuras TDIAG_Status y TDIAG_StatusExt").

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "T_DIAG":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Con un flanco positivo, inicia la instrucción pa‐
ra comprobar la conexión especificada en el
parámetro ID.

ID

Input

CONN_OUC
(WORD)

I, Q, M, D, L o cons‐
tante

Referencia a la conexión asignada.

4112

Rango de valores: W#16#0001 hasta
W#16#0FFF

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RESULT

InOut

VARIANT

D

Puntero hacia la estructura en la que se depo‐
sita la información sobre la conexión. En el pa‐
rámetro RESULT pueden utilizarse las estruc‐
turas TDiag_Status o TDiag_StatusExt (solo
en las CPU S7-1500); encontrará una descrip‐
ción en la tabla "Estructuras TDIAG_Status y
TDIAG_StatusExt".

DONE

Output

BOOL

I, Q, M, D, L

Parámetros de estado:
● 0: Instrucción no iniciada aún o en
ejecución.
● 1: Instrucción ejecutada sin errores.

BUSY

Output

BOOL

I, Q, M, D, L

Parámetros de estado:
● 0: Instrucción no iniciada aún o ya
finalizada.
● 1: Instrucción no finalizada aún. No es
posible iniciar una nueva petición.

ERROR

Output

BOOL

I, Q, M, D, L

Parámetros de estado:
● 0: ningún error.
● 1: se han producido errores.

STATUS

Output

WORD

I, Q, M, D, L

Estado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetros BUSY, DONE y ERROR
El estado de ejecución de la instrucción "T_DIAG" se controla con los parámetros BUSY,
DONE, ERROR y STATUS. El parámetro BUSY indica el estado de ejecución. El parámetro
DONE permite comprobar si una instrucción se ha ejecutado correctamente. El parámetro
ERROR se activa si ocurren errores durante la ejecución de "T_DIAG".
La tabla siguiente muestra la relación entre los parámetros BUSY, DONE y ERROR:
BUSY

DONE

ERRO Descripción
R

1

-

-

La instrucción se está ejecutando.

0

1

0

La instrucción se ha ejecutado correctamente. Solo en este caso son válidos los datos en la
estructura referenciada con RESULT.

0

0

1

La instrucción se ha finalizado con un error. La causa del error se indica en el parámetro STATUS.

0

0

0

No se ha asignado ninguna instrucción nueva.

Programación del PLC
Manual de programación y manejo, 11/2019

4113

Instrucciones
4.1 Instrucciones

Parámetro STATUS
La tabla siguiente muestra el significado de los valores en el parámetro STATUS:
STA‐
Explicación
TUS*
(W#16#.
..)
0000

La instrucción "T_DIAG" se ha ejecutado correctamente. Los datos pertenecientes a la estructura referenciada en
el parámetro RESULT pueden evaluarse.

7000

No se está ejecutando ninguna instrucción.

7001

Se ha iniciado la ejecución de la instrucción.

7002

Se está leyendo la información sobre la conexión (parámetro REQ irrelevante).

8086

El valor del parámetro ID está fuera del rango permitido (W#16#0001 ... W#16#0FFF).

8089

El parámetro RESULT señala a un tipo de datos no válido (solo se permiten estructuras TDIAG_Status y
TDIAG_StatusExt).

80A3

El parámetro ID crea una referencia a un punto final de la conexión que no existe. Este error se produce con
conexiones programadas también después de llamar la instrucción "TDISCON".

80B1

Se ha cambiado el parámetro RESULT antes de que haya terminado la ejecución de T_DIAG. No está permitido
modificar RESULT mientras se ejecuta T_DIAG.

80C4

Error interno. En estos momentos no es posible acceder al punto final de la conexión.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Estructuras TDIAG_Status y TDIAG_StatusExt
Nota
Estructura TDIAG_StatusExt
La estructura TDIAG_StatusExt solo existe en las CPU S7-1500.
La tabla siguiente describe el formato de las estructuras TDIAG_Status y TDIAG_StatusExt:
● La estructura TDIAG_StatusExt es idéntica a la estructura TDIAG_Status desde el
parámetro InterfaceID hasta el parámetro ReceivedBytes.
● La estructura TDIAG_StatusExt contiene además los parámetros ConnTrials hasta
LastDisconnTimeStamp.
Todos los elementos tienen un valor válido únicamente si la instrucción ha podido ejecutarse
sin errores. En caso de error, el contenido de los parámetros no se modifica.
Nombre

Tipo de da‐ Descripción
tos

Los parámetros siguientes existen tanto en la estructura TDIAG_Status como en la estructura TDIAG_StatusExt:
InterfaceID

HW_ANY

ID

CONN_OU ID de la conexión que ha sido diagnosticada. Tras realizar la llamada con éxito, el valor de
C
este elemento es idéntico al parámetro ID de la instrucción "T_DIAG".

4114

ID de interfaz (LADDR) de la CPU o del CM/CP.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Nombre

Tipo de da‐ Descripción
tos

ConnectionType

BYTE

Tipo de protocolo empleado para la conexión:
● 0x01: No se utiliza.
● ...
● 0x0B: protocolo TCP (IP_v4)
● 0x0C: protocolo ISO on TCP (RFC1006)
● 0x0D: protocolo TCP (DNS)
● 0x0E: protocolo Dial in
● 0x0F: protocolo WDC
● 0x10: protocolo SMTP
● 0x11: protocolo TCP
● 0x12: protocolos TCP e ISO on TCP (RFC1006)
● 0x13: protocolo UDP
● 0x14: Reservado
● 0x15: protocolo de acceso al bus PROFIBUS (FDL)
● 0x16: protocolo de transporte ISO 8073 (ISO native)
● ...
● 0x20: protocolo SMTP o SMTPS, basado en IPv4
● 0x21: protocolo SMTP o SMTPS, basado en IPv6
● 0x22: protocolo SMTP o SMTPS, basado en FQDN (Fully Qualified Domain Name)
● ...
● 0x70: Conexión S7
● Otros: Reservado

ActiveEstablished

BOOL

● FALSE: a nivel local, el punto final pasivo de la conexión
● TRUE: a nivel local, el punto final activo de la conexión

State

BYTE

Estado actual del punto final de la conexión:
● 0x00: No se utiliza.
● 0x01: conexión finalizada. Estado temporal adoptado, p. ej., tras llamar la instrucción
"T_RESET". A continuación, el sistema trata de restablecer automáticamente la
conexión.
● 0x02: el punto final activo de la conexión trata de establecer la conexión con el
interlocutor remoto.
● 0x03: el punto final pasivo de la conexión espera a que se establezca la conexión con
el interlocutor remoto.
● 0x04: conexión establecida.
● 0x05: la conexión acaba de deshacerse. La causa de que se haya deshecho puede ser
la llamada de la instrucción "T_RESET" o "T_DISCON". Otras causas posibles pueden
ser un error de protocolo o una rotura de hilo.
● 0x06..0xFF: No se utiliza.

Programación del PLC
Manual de programación y manejo, 11/2019

4115

Instrucciones
4.1 Instrucciones
Nombre

Tipo de da‐ Descripción
tos

Kind

BYTE

Modo de operación del punto final de la conexión:
● 0x00: No se utiliza.
● 0x01: conexión estática configurada y cargada después en la CPU.
● 0x02: conexión dinámica configurada y cargada a continuación en la CPU
(actualmente no se soporta).
● 0x03: conexión programada, generada desde el programa de usuario con la
instrucción "TCON". El punto final de la conexión ha vuelto a destruirse al llamar la
instrucción "TDISCON" o al pasar la CPU al estado STOP.
● 0x04: conexión dinámica temporal creada, p. ej., por la estación de ingeniería (ES) o
la estación de operador (OS) (este tipo de conexión no puede diagnosticarse
actualmente porque falta la ID).
● 0x05..0xFF: No se utiliza.

SentBytes

UDINT

Cantidad de datos enviados.

ReceivedBytes

UDINT

Cantidad de datos recibidos.

Los siguientes parámetros existen solo con la estructura TDiag_StatusExt:
ConnTrials

UDINT

Número de intentos de conexión. Tras establecer correctamente una conexión, ConnTrials
contiene el valor 0. Si el elemento no es 0, significa que puede haber problemas de co‐
nexión.
Nota: con un punto final de la conexión pasivo, este valor nunca es mayor que 1.

ConnTrialsSuc‐
cess

UDINT

LastConnErrRea‐
son

UDINT

Número de intentos de conexión satisfactorios. Este elemento no se restablece nunca
durante el ciclo de vida de un punto final de la conexión y, después de alcanzar el valor
0xFFFF FFFF, retorna a 0.
Nota: si nunca ha habido problemas con esta conexión, este parámetro tiene el valor 1.
Identificación de error producida durante el último intento incorrecto de establecer una
conexión (los mensajes de error son idénticos a los del parámetro LastDisconnReason):
● 0x4F01: punto final remoto de la conexión no accesible (este error suele producirse
durante la fase de establecimiento de la conexión).
● 0x4F02: la conexión se ha deshecho a nivel local.
● 0x4F03: la conexión se ha deshecho debido al interlocutor remoto.
● 0x4F04: la conexión se ha deshecho debido a un error de protocolo.
● 0x4F05: la conexión se ha deshecho debido a un problema de red de detección local.
● 0x4F06: la conexión se ha deshecho debido a un problema de red de detección remota.
● 0x4F07: la conexión se ha deshecho debido a un rebase de tiempo en el protocolo.
● 0x4F08: parametrización errónea: la conexión debe establecerse con la dirección
propia.
● 0x4F09: la conexión se ha reiniciado temporalmente mediante la llamada de la
instrucción "T_RESET".
● 0x4F0A: insuficientes recursos de conexión disponibles (capacidad excedida)
● 0x4F0B: Error interno: parámetros de direccionamiento incorrectos
● 0x4F0C: error de comunicación interno de la CPU
● 0x4F0D: error de comunicación interno del AS entre CPU y CM/CP
● 0x4F0E: el puerto TCP/UDP local especificado (o el selector T RFC1006) ya se está
utilizando.

4116

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Nombre

Tipo de da‐ Descripción
tos

LastConnErrTi‐
meStamp

LDT

Instante del último intento de conexión incorrecto.

LastDisconnRea‐
son

UDINT

Identificación de error que ha provocado la última desconexión (los mensajes de error son
idénticos a los del parámetro LastConnErrReason):
● 0x4F01: punto final remoto de la conexión no accesible (este error suele producirse
durante la fase de establecimiento de la conexión).
● 0x4F02: la conexión se ha deshecho a nivel local.
● 0x4F03: la conexión se ha deshecho debido al interlocutor remoto.
● 0x4F04: la conexión se ha deshecho debido a un error de protocolo.
● 0x4F05: la conexión se ha deshecho debido a un problema de red de detección local.
● 0x4F06: la conexión se ha deshecho debido a un problema de red de detección remota.
● 0x4F07: la conexión se ha deshecho debido a un rebase de tiempo en el protocolo.
● 0x4F08: parametrización errónea: la conexión debe establecerse con la dirección
propia.
● 0x4F09: la conexión se ha reiniciado temporalmente mediante la llamada de la
instrucción "T_RESET".
● 0x4F0A: insuficientes recursos de conexión disponibles (capacidad excedida)
● 0x4F0B: Error interno: parámetros de direccionamiento incorrectos
● 0x4F0C: error de comunicación interno de la CPU
● 0x4F0D: error de comunicación interno del AS entre CPU y CM/CP
● 0x4F0E: el puerto TCP/UDP local especificado (o el selector T RFC1006) ya se está
utilizando.

LastDisconnTi‐
meStamp

LDT

Fecha y hora de la última desconexión.

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa con T_DIAG (Página 4118).
Encontrará información adicional y el código del programa para el ejemplo aquí: Sample
Library for Instructions (Página 615).

Consulte también
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

Programación del PLC
Manual de programación y manejo, 11/2019

4117

Instrucciones
4.1 Instrucciones

Ejemplo de programa con T_DIAG
Introducción
En el ejemplo siguiente se utiliza una conexión configurada (p. ej. UDP) entre dos CPU
(S7-1500). Con la instrucción "T_DIAG" se diagnostica la conexión y se lee información sobre
el punto final local de la misma.

Requisitos
● Se han creado dos CPU de la serie S7-1500 y se han conectado entre sí vía PROFINET.
Hay una conexión UDP configurada.

● En "<CPU> > Propiedades > Protección" se ha ajustado para las CPU un nivel de
protección bajo para garantizar que se permitan accesos de lectura y escritura.

Crear variables e interconectar parámetros (programa de la CPU 1)
Para almacenar los datos debe crearse un bloque de datos global ("SLI_gDB_T_DIAG") con
las estructuras y variables siguientes.
Nota: "TDiag_StatusExt" es un tipo de datos de sistema para leer los datos de diagnóstico.

Se crea el FB "SLI_FB_T_DIAG". En él se crean las siguientes variables locales.

4118

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Segmento 1: Los parámetros de la instrucción "T_DIAG" se interconectan del siguiente modo.

Segmento 2: En caso de fallo de T_DIAG, guarde el estado del siguiente modo.

Asignar una conexión de comunicación
El parámetro de direccionamiento de la conexión debe modificarse.
● En el parámetro de entrada ID ("connectionID") debe almacenarse el valor hexadecimal del
identificador de hardware de la conexión UDP configurada.
Encontrará el identificador de hardware en la "Vista de redes" bajo "Conexiones".

Resultado
Segmento 1:
De acuerdo con el parámetro de entrada ID ("connectionID"), la instrucción "T_DIAG" conoce
la conexión de comunicación que debe utilizarse.

Programación del PLC
Manual de programación y manejo, 11/2019

4119

Instrucciones
4.1 Instrucciones
Si el parámetro de entrada REQ ("T_DIAG.start") devuelve el estado lógico "TRUE", se inicia
la instrucción "T_DIAG". La instrucción "T_DIAG" lee el estado de la conexión y el estado del
punto final local de la misma.
Con el parámetro de salida DONE ("#done") a "TRUE" y el parámetro de salida STATUS
("T_DIAG.status") a "0000" se indica la transmisión correcta del juego de datos. Puesto que los
valores de los parámetros de salida solo se muestran en el momento en que son válidos, el
estado correcto debe guardarse en la variable "T_DIAG.done".
En el parámetro de salida ERROR ("T_DIAG.error") o en la variable "T_DIAG.memErrStatus"
se indica que la ejecución se ha realizado sin errores en el ejemplo.

En el parámetro RESULT ("TDiag_StatusExt") se capturan los datos de diagnóstico.

Segmento 2:
Si T_DIAG notifica un error ("T_DIAG.error" es "TRUE"), el estado notificado ("T_DIAG.status")
se guarda de forma permanente ("T_DIAG.memErrStatus").

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

4120

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
T_DIAG: Comprobar conexión (Página 4112)

T_CONFIG: Configurar interfaz
Descripción de T_CONFIG
Descripción
La instrucción "T_CONFIG" sirve para realizar la configuración controlada por el programa de
las interfaces PROFINET integradas en la CPU o de la interfaz Ethernet de un CP/CM.

Configuración de las interfaces PROFINET integradas en la CPU
La instrucción "T_CONFIG" permite modificar la dirección Ethernet, el nombre de dispositivo
PROFINET o las direcciones IP de los servidores NTP para la sincronización horaria desde el
programa de usuario. Los datos de configuración válidos hasta ahora se sobrescriben.
Se pueden efectuar los siguientes cambios:
● Configuración del protocolo IP
– Dirección IP
– Máscara de subred
– Dirección del router
● Configuración de PROFINET
– Asignación del nombre de dispositivo PROFINET
Nota
Dependencia entre nombre de dispositivo y protocolo IP
Cuando se asigna un nuevo nombre de dispositivo debe ajustarse también el protocolo
IP.
● Ajustes de la sincronización horaria
– Asignación de las direcciones IP de los servidores NTP para la sincronización horaria
(solo con S7-1500 y, allí, solo para la interfaz PROFINET [X1] de una CPU modular)
Los ajustes se corresponden con las opciones de configuración en "Protocolo IP" y
"PROFINET" del cuadro de diálogo "Direcciones Ethernet" o bien en "Procedimiento NTP" del

Programación del PLC
Manual de programación y manejo, 11/2019

4121

Instrucciones
4.1 Instrucciones
cuadro de diálogo "Sincronización horaria". Este se visualiza en la vista "Dispositivos y redes"
en las propiedades de la interfaz PROFINET.
ADVERTENCIA
Rearranque de la CPU tras ejecutar la instrucción "T_CONFIG" (solo CPU S7-1200 con las
versiones de firmware de V2.0 a V4.1.2)
Tras ejecutar la instrucción para modificar un parámetro IP, la CPU realiza un rearranque. La
CPU pasa al estado operativo STOP, se ejecuta un rearranque en caliente y la CPU arranca
de nuevo (estado operativo RUN).
Asegúrese de que el proceso controlado se encuentra en un estado operativo seguro
después del rearranque de la CPU tras ejecutar la instrucción. Un funcionamiento
incontrolado, provocado por ejemplo por fallos de funcionamiento o errores del programa,
puede causar daños materiales y personales graves. Es posible que se pierdan datos no
remanentes.

Configuración de la interfaz Ethernet de un CP 154x‑1
La instrucción "T_CONFIG" permite modificar la dirección IPv6, la dirección MAC o las
direcciones IP de hasta dos servidores DNS de la interfaz Ethernet de un CP desde el
programa de usuario. Además es posible configurar los servidores NTP en el CP. Los datos de
configuración válidos hasta ahora se sobrescriben.

4122

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Requisitos
● Para utilizar la instrucción hay que ajustar determinadas propiedades de la interfaz
PROFINET. Para ello, abra las propiedades de la interfaz PROFINET en la Vista de
dispositivos. Active las opciones siguientes en el cuadro de diálogo "Direcciones Ethernet"
o "Sincronización horaria":
– Para modificar los parámetros de dirección IP con "T_CONFIG": Seleccione en
"Protocolo IP" la opción "Permitir ajustar la dirección IP directamente en el dispositivo".
– Para modificar el nombre de dispositivo PROFINET con "T_CONFIG":
Seleccione en "PROFINET" la opción "Ajustar nombre de dispositivo PROFINET en el
dispositivo".
Seleccione además la opción "Permitir ajustar la dirección IP directamente en el
dispositivo" en "Protocolo IP".
– Para modificar las direcciones IP de los servidores NTP con "T_CONFIG":
Seleccione en "Protocolo IP" la opción "Permitir ajustar la dirección IP directamente en
el dispositivo".
seleccione "Activar sincronización horaria mediante servidor NTP" e introduzca la
dirección IP de al menos un servidor NTP.
● Los datos de configuración deben guardarse en los siguientes tipos de datos de sistema y
aplicarse en el parámetro CONF_DATA (Página 4125):
– La dirección IP, la máscara de subred y la dirección del router se guardan en el tipo de
datos de sistema IF_CONF_V4.
– El nombre de dispositivo se guarda en el tipo de datos de sistema IF_CONF_NOS.
Tenga en cuenta las restricciones que rigen para la asignación del nombre de
dispositivo (ver parámetro CONF_DATA (Página 4125)).
– Las direcciones IP para la sincronización horaria NTP se almacenan en el tipo de datos
de sistema IF_CONF_NTP.
– La dirección IPv6 de la interfaz PROFINET de un CP 1543-1 se guarda en el tipo de
datos de sistema IF_CONF_IPV6.
– La dirección MAC de la interfaz PROFINET de un CP 1543-1 se guarda en el tipo de
datos de sistema IF_CONF_MAC.
– Las direcciones IP de hasta dos servidores DNS para la interfaz PROFINET de un CP
1543-1 se guardan en el tipo de datos de sistema IF_CONF_DNS.

Funcionamiento
La instrucción "T_CONFIG" es una instrucción asíncrona, de modo que la ejecución se
prolonga a lo largo de varias llamadas. Para iniciar el procedimiento de configuración, llame la
instrucción "T_CONFIG" con REQ = 1. Solo puede haber una orden activa en cada caso.
El bloque se ha disparado por flanco, lo cual significa que después de BUSY= FALSE el bloque
debe volver a llamarse con REQ=FALSE para que se habilite la instancia.

Programación del PLC
Manual de programación y manejo, 11/2019

4123

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "T_CONFIG":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o
constante

La ejecución de la instrucción comienza al llamar la
instrucción con REQ = 1.

INTERFACE

Input

HW_INTERFA‐
CE

I, Q, M, D, L o
constante

ID de hardware de la interfaz

VARIANT

D, L

Puntero hacia la estructura superior, que contiene
los tipos de datos de sistema IF_CONF_HEADER,
IF_CONF_V4, IF_CONF_NOS, IF_CONF_NTP,
IF_CONF_V6, IF_CONF_MAC y IF_CONF_DNS
(véase la descripción del parámetro CONF_DATA).

BOOL

I, Q, M, D, L

Parámetros de estado:

CONF_DATA Input
(Página 4125)

DONE (Pági‐
na 4131)

Output

La ID de hardware se visualiza en las propiedades
de la interfaz en la vista de dispositivos y en las
constantes de sistema de las variables PLC.

● 0: el procesamiento todavía no ha finalizado
● 1: procesamiento de la instrucción finalizado
correctamente.

BUSY (Pági‐
na 4131)

Output

ERROR (Pá‐
gina 4131)

Output

STATUS (Pá‐
gina 4131)

Output

BOOL

I, Q, M, D, L

Parámetros de estado:
● 0: el procesamiento de la instrucción aún no ha
comenzado, aún no ha terminado o aún no se ha
interrumpido
● 1: la instrucción se está procesando

BOOL

I, Q, M, D, L

Parámetros de estado:
● 0: ningún error
● 1: Error

DWORD

I, Q, M, D, L

Información de estado detallada:
En el parámetro STATUS se visualiza información
de estado y error detallada a través de un código de
error.

ERR_LOC
Output
(Página 4131)

DWORD

I, Q, M, D, L

Ubicación del error:
● 0: error al ejecutar la instrucción o la
parametrización.
● > 0: error en la estructura o el contenido de los
datos de configuración en el parámetro
CONF_DATA.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa con T_CONFIG (Página 4133).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

4124

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

Parámetro CONF_DATA
Estructura de los datos de configuración
Los datos de configuración en el parámetro CONF_DATA se pueden guardar en un bloque de
datos global o en la sección "Static" de la interfaz del bloque.
Los datos de configuración deben guardarse de acuerdo con la estructura siguiente:
Nombre

Tipo de datos

Descripción

ConfData

Struct

Estructura superior que se aplica en el parámetro "CONF_DATA".

Header

IF_CONF_HEA‐
DER

Mediante el encabezado se define el número de los siguientes tipos de datos de sistema.
El tipo de datos de sistema IF_CONF_HEADER siempre debe estar incluido.

IPData

IF_CONF_V4

En este tipo de datos de sistema se guardan la dirección IP, la máscara de subred y la
dirección del router.

NoS

IF_CONF_NOS

En este tipo de datos de sistema se guarda el nombre de dispositivo PROFINET. Cree
IF_CONF_NOS únicamente si a través de "T_CONFIG" también desea modificar el nom‐
bre de dispositivo.

NTP

IF_CONF_NTP

En este tipo de datos de sistema se guardan las direcciones IP de los servidores NTP para
la sincronización horaria.

IP_V6

IF_CONF_V6

En este tipo de datos de sistema se guarda la dirección IPv6 de un CP 154x‑1.

MAC

IF_CONF_MAC

En este tipo de datos de sistema se guarda la dirección MAC de un CP 154x‑1.

DNS

IF_CONF_DNS

En este tipo de datos de sistema se guardan las direcciones IP de hasta dos servidores
DNS para un CP 154x‑1.

Los tipos de datos de sistema IF_CONF_HEADER, IF_CONF_V4, IF_CONF_NOS,
IF_CONF_NTP, IF_CONF_V6, IF_CONF_MAC y IF_CONF_DNS se crean introduciendo el
nombre del tipo de datos de sistema en la columna "Tipo de datos" del bloque de datos o de
la interfaz del bloque. Los nombres para los tipos de datos de sistema se pueden asignar
libremente. Los tipos de datos de sistema pueden combinarse en el orden que se quiera.

Tipo de datos de sistema IF_CONF_Header
Con el tipo de datos de sistema IF_CONF_Header se indica cuántos tipos de datos de sistema
IF_CONF_V4, IF_CONF_NOS, IF_CONF_NTP, IF_CONF_V6, IF_CONF_MAC y
IF_CONF_DNS se utilizan en la ejecución de "T_CONFIG".
Byte

Parámetro

Tipo de datos Valor de arranque

Descripción

0…1

FieldType

UINT

0

Tipo de campo: debe tener siempre el valor "0".

2…3

FieldId

UINT

0

ID de campo: debe tener siempre el valor "0".

4…5

SubfieldCount

UINT

0

Número de tipos de datos de sistema IF_CONF_V4,
IF_CONF_NOS, IF_CONF_NTP, IF_CONF_V6,
IF_CONF_MAC y IF_CONF_DNS utilizados

Programación del PLC
Manual de programación y manejo, 11/2019

4125

Instrucciones
4.1 Instrucciones

Tipo de datos de sistema IF_CONF_V4
Con el tipo de datos de sistema IF_CONF_V4 se definen la dirección IP, la máscara de subred
y la dirección del router.
Byte

Parámetro

Tipo de datos Valor de arranque

Descripción

0…1

Id

UINT

30

Identificación del tipo de datos de sistema. No está
permitido modificar el valor de arranque de este pa‐
rámetro.

2…3

Length

UINT

18

Longitud del tipo de datos de sistema IF_CONF_V4
Dado que los parámetros de IF_CONF_V4 tienen
una longitud y estructura fijas, para indicar la longi‐
tud debe utilizarse el valor de arranque.

4…5

Mode

UINT

0

Validez del direccionamiento:
● 1: validez permanente de los datos de
configuración
● 2: validez temporal de los datos de
configuración, incluido el borrado de los datos
de configuración permanentes existentes

6…9

InterfaceAddress

IP_V4 *

0.0.0.0

Dirección IP

10 ... 12

SubnetMask

IP_V4 *

0.0.0.0

Máscara de subred

14 ... 16

DefaultRouter

IP_V4 *

0.0.0.0

Dirección del router

* El tipo de datos IP_V4 es una estructura de 4 BYTE que contiene la dirección del parámetro correspondiente (p. ej., en el
parámetro SubnetMask, la dirección de cuatro dígitos de la máscara de subred del protocolo IP).

4126

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Tipo de datos de sistema IF_CONF_NOS
Con el tipo de datos de sistema IF_CONF_NOS se determina el nombre de estación que se
debe asignar al ejecutar la instrucción "T_CONFIG".
Byte

Parámetro

Tipo de datos Valor de arranque

Descripción

0…1

Id

UINT

40

Identificación del tipo de datos de sistema. No está
permitido modificar el valor de arranque de este pa‐
rámetro.

2…3

Length

UINT

246

Longitud del tipo de datos de sistema
IF_CONF_NOS en bytes.
● Para una longitud absoluta, el valor para el
parámetro Lenght resulta de:
–

6 bytes para los parámetros Id, Length y
Mode.

–

Hasta 240 bytes para el nombre de
dispositivo (parámetro NOS).

Ejemplo: para el nombre de dispositivo "plc1"
con una longitud de 4 caracteres (= 4 bytes)
resulta una longitud total de 10.
● Para una longitud dinámica utilice el valor de
arranque predeterminado 246 en el parámetro
Lenght.
Asegúrese de introducir el valor "0" tras el
nombre (consulte la descripción del parámetro
NOS).

Programación del PLC
Manual de programación y manejo, 11/2019

4127

Instrucciones
4.1 Instrucciones
Byte

Parámetro

Tipo de datos Valor de arranque

Descripción

4…5

Mode

UINT

Validez del cambio de nombre de dispositivo:

0

● 1: validez permanente del nombre de dispositivo.
● 2: validez temporal del nombre de dispositivo.
6 ... 244

NOS

ARRAY
[1...240] of
Byte

0

Nombre de dispositivo (Name of Station)
● ARRAY debe ocuparse desde el primer byte. Si
se ocupa el primer byte con "0", se borra el
nombre de estación.
● La longitud mínima del nombre es 1 byte. La
longitud máxima para el nombre es de 240 bytes.
● Si el nombre de dispositivo es más corto que el
especificado en el parámetro Length, se debe
introducir un byte cero (16#0 hex) después del
nombre de estación (de acuerdo con IEC
61185-6-10). De lo contrario, NOS es rechazado
y la instrucción "T_CONFIG" visualiza el código
de error DW#16#C0809400 en el parámetro
STATUS.
● Si el nombre de dispositivo es más largo que el
especificado en el parámetro Length, el nombre
de dispositivo se escribe solo hasta la longitud
especificada.
Para el nombre de dispositivo rigen las siguientes
restricciones:
● El nombre debe introducirse en código ASCII.
● Para el nombre solo está permitido utilizar letras
minúsculas, cifras, guiones o puntos.
–

El nombre no puede empezar ni acabar con
un guión.

–

El nombre no puede tener el formato n.n.n.n
(n = 0... 999).

–

El nombre no puede empezar con la cadena
de caracteres "port-xyz" o "port-xyz-abcde"
(a, b, c, d, e, x, y, z = 0...9).

● Una parte integrante del nombre entre dos
puntos puede tener máximo 63 caracteres.
● No se admiten caracteres especiales como
vocales acentuadas o con diéresis, paréntesis,
caracteres de subrayado, barras, espacios en
blanco, etc.
Si se utiliza un carácter no válido, el parámetro STA‐
TUS devuelve el código de error C080_9400.

4128

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Tipo de datos de sistema IF_CONF_NTP
Con el tipo de datos de sistema IF_CONF_NTP se definen las direcciones IP de los servidores
NTP para la sincronización horaria.
Byte

Parámetro

Tipo de datos Valor de arranque

Descripción

0…1

Id

UINT

17

Identificación del tipo de datos de sistema. No está
permitido modificar el valor de arranque de este pa‐
rámetro.

2…3

Length

UINT

22

Longitud del tipo de datos de sistema
IF_CONF_NTP en bytes
Dado que los parámetros de IF_CONF_NTP tienen
una longitud y estructura fijas, para indicar la longi‐
tud debe utilizarse el valor de arranque.

4…5

Mode

UINT

2

Validez:
● 1: validez permanente (no admisible)
● 2: validez temporal

6…9

NTP_IP[1]

...

...

18 ... 21

NTP_IP[4]

ARRAY
[1...4] of
IP_V4

Dirección IP del servidor NTP 1

Dirección IP del servidor NTP 2 ... 3
ARRAY
[1...4] of
IP_V4

Dirección IP del servidor NTP 4

Tipo de datos de sistema IF_CONF_V6 (solo si se utiliza un CP 154x‑1)
A través del tipo de datos de sistema IF_CONF_V6 se asigna una dirección IPv6 para la
interfaz seleccionada mediante INTERFACE.
Byte

Parámetro

Tipo de datos Valor de arranque

Descripción

0…1

Id

UINT

22

Identificación del tipo de datos de sistema. No está
permitido modificar el valor de arranque de este pa‐
rámetro.

2…3

Length

UINT

22

Longitud del tipo de datos de sistema IF_CONF_V6
en bytes
Dado que los parámetros de IF_CONF_V6 tienen
una longitud y estructura fijas, para indicar la longi‐
tud debe utilizarse el valor de arranque.

4…5

Mode

UINT

0

Validez de la dirección IPv6:
● 1: validez permanente
● 2: validez temporal

6 ... 21

InterfaceAddress

IP_V6 *

Dirección IPv6:

* El tipo de datos IP_V6 es una estructura de 16 bytes.

Programación del PLC
Manual de programación y manejo, 11/2019

4129

Instrucciones
4.1 Instrucciones

Tipo de datos de sistema IF_CONF_MAC (solo si se utiliza un CP 154x‑1)
A través del tipo de datos de sistema IF_CONF_MAC se asigna la dirección MAC para la
interfaz seleccionada mediante INTERFACE.
Byte

Parámetro

Tipo de datos Valor de arranque

Descripción

0…1

Id

UINT

3

Identificación del tipo de datos de sistema. No está
permitido modificar el valor de arranque de este pa‐
rámetro.

2…3

Length

UINT

12

Longitud del tipo de datos de sistema
IF_CONF_MAC en bytes
Dado que los parámetros de IF_CONF_MAC tienen
una longitud y estructura fijas, para indicar la longi‐
tud debe utilizarse el valor de arranque.

4…5

Mode

UINT

0

Validez de la dirección MAC:
● 1: validez permanente
● 2: validez temporal

6 ... 11

Mac

ARRAY
[1...6] of Byte

Dirección MAC
Recuerde que al modificar la dirección MAC se pue‐
de interrumpir alguna conexión.

Tipo de datos de sistema IF_CONF_DNS (solo si se utiliza un CP 154x‑1)
Con el tipo de datos de sistema IF_CONF_DNS se definen las direcciones IP de hasta dos
servidores DNS para la interfaz seleccionada mediante INTERFACE.
Byte

Parámetro

Tipo de datos Valor de arranque

Descripción

0…1

Id

UINT

16

Identificación del tipo de datos de sistema. No está
permitido modificar el valor de arranque de este pa‐
rámetro.

2…3

Length

UINT

14

Longitud del tipo de datos de sistema
IF_CONF_DNS en bytes
Dado que los parámetros de IF_CONF_DNS tienen
una longitud y estructura fijas, para indicar la longi‐
tud debe utilizarse el valor de arranque.

4…5

Mode

UINT

0

Validez:
● 1: validez permanente
● 2: validez temporal

6…9

DNS_IP1

IP_V4

Dirección IP del servidor DNS 1

10 ... 13

DNS_IP2

IP_V4

Dirección IP del servidor DNS 2
Si solo debe especificarse una dirección, al servidor
DNS 2 se le debe asignar la dirección IP 0.0.0.0.

4130

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros DONE, BUSY y ERROR
Descripción
En la tabla siguiente se muestra la correspondencia entre BUSY, DONE y ERROR. Permite
determinar en qué estado se encuentra la instrucción actualmente o cuándo se completó la
transferencia de los datos de configuración.
BUSY

DONE

ERROR

Descripción

TRUE

FALSE

FALSE

La petición está en proceso.

FALSE

TRUE

FALSE

La petición ha finalizado correctamente.

FALSE

FALSE

TRUE

La petición se ha finalizado con un error. La causa del error se puede con‐
sultar en el parámetro STATUS (Página 4131).

FALSE

FALSE

FALSE

No se ha asignado ninguna (nueva) petición a la instrucción.

Parámetros STATUS y ERR_LOC
Descripción
En los parámetros STATUS y ERR_LOC se visualizan los mensajes de estado y error de la
instrucción "T_CONFIG":
● En el parámetro STATUS se visualiza la causa del error.
● El parámetro ERR_LOC indica dónde se ha producido el error. Para ello se dispone de las
siguientes posibilidades:
– 16#0000_0000: error al llamar la instrucción (p. ej. error al parametrizar la instrucción o
en la comunicación con la interfaz PROFINET).
– 16#0001_0000: error en los datos de configuración en los parámetros del tipo de datos
de sistema IF_CONF_HEADER.
– 16#0001_000x: Error en los datos de configuración en los parámetros del tipo de datos
de sistema IF_CONF_V4 o IF_CONF_NOS o IF_CONF_NTP o IF_CONF_V6 o
IF_CONF_MAC o IF_CONF_DNS (x indica la posición del bloque erróneo en la
estructura T_CONFIG. Si la estructura de T_CONFIG contiene un subbloque para la
dirección IP y otro para el nombre de estación, por ejemplo, y el error está en el
subbloque para el nombre de estación, ERR_LOC tiene el valor 0001_0002.)
La tabla siguiente muestra los valores posibles de los parámetros STATUS y ERR_LOC:
STATUS*

ERR_LOC*

Explicación

0000_0000

0000_0000

Procesamiento de la petición finalizado sin errores.

0070_0000

0000_0000

No se está procesando ninguna petición.

0070_0100

0000_0000

Inicio del procesamiento de la petición.

0070_0200

0000_0000

Llamada intermedia (REQ irrelevante).

C0xx_yy00,
xx>80

0000_0000

Información de error general. Consulte también: GET_ERR_ID: Consultar ID de error local‐
mente (Página 933)

C080_8000

0000_0000

Error al llamar la instrucción:
El identificador de hardware del parámetro Interface no es válido.

Programación del PLC
Manual de programación y manejo, 11/2019

4131

Instrucciones
4.1 Instrucciones
STATUS*

ERR_LOC*

Explicación

C080_8100

0000_0000

Error al llamar la instrucción:
El identificador de hardware del parámetro Interface no direcciona ninguna interfaz PROFI‐
NET.

C080_8700

0000_0000

C080_8800

0001_0000

C080_8900

0001_0000

Error al llamar la instrucción:
Longitud incorrecta del bloque de datos en el parámetro CONF_DATA.
Error en el tipo de datos de sistema IF_CONF_HEADER:
El parámetro FieldType tiene un valor no admisible. Utilice el valor "0" para FieldType.
Error en el tipo de datos de sistema IF_CONF_HEADER:
El parámetro FieldId tiene un valor no admisible. Utilice el valor "0" para FieldId.

C080_8A00

0001_0000

Error en el tipo de datos de sistema IF_CONF_HEADER:
Número incorrecto en el parámetro SubfieldCount. Indique el número correcto de tipos de
datos de sistema IF_CONF_V4, IF_CONF_NOS, IF_CONF_NTP, IF_CONF_V6,
IF_CONF_MAC o IF_CONF_DNS utilizados.

C080_8B00

0001_000x

Error en el tipo de datos de sistema IF_CONF_V4, IF_CONF_NOS, IF_CONF_NTP,
IF_CONF_V6, IF_CONF_MAC o IF_CONF_DNS:
El parámetro Id tiene un valor no admisible. Utilice para IF_CONF_V4 "30", para
IF_CONF_NOS "40", para IF_CONF_NTP "17", para IF_CONF_V6 "22", para IF_CONF_MAC
"3", para IF_CONF_DNS "16".
Nota: IF_CONF_NTP solo se admite cuando se aplica T_CONFIG a la primera interfaz [X1] de
una CPU modular S7-1500.

C080_8C00

0001_000x

Error en el tipo de datos de sistema IF_CONF_V4, IF_CONF_NOS, IF_CONF_NTP,
IF_CONF_V6, IF_CONF_MAC o IF_CONF_DNS:
Tipo de datos de sistema erróneo, orden erróneo o utilización repetida de un tipo de datos de
sistema.

C080_8D00

0001_000x

C080_8E00

0001_000x

Error en el tipo de datos de sistema IF_CONF_V4, IF_CONF_NOS, IF_CONF_NTP,
IF_CONF_V6, IF_CONF_MAC o IF_CONF_DNS:
El parámetro Length tiene un valor erróneo o no admisible.
Error en el tipo de datos de sistema IF_CONF_V4, IF_CONF_NOS, IF_CONF_NTP,
IF_CONF_V6, IF_CONF_MAC o IF_CONF_DNS:
El parámetro Mode tiene un valor erróneo o no admisible.
●

Para IF_CONF_V4 y IF_CONF_NOS solo son válidos los valores "1" (permanente) o "2"
(temporal).

● Para IF_CONF_NTP solo se admite el valor "2" (temporal).
C080_9000

0001_000x

Error en el tipo de datos de sistema IF_CONF_V4, IF_CONF_NOS, IF_CONF_NTP,
IF_CONF_V6, IF_CONF_MAC o IF_CONF_DNS:
Los datos de configuración no se pueden aplicar. Causa posible:
● Con IF_CONF_V4: En la configuración hardware no se ha seleccionado el ajuste "Ajustar
dirección IP en el dispositivo".
● Con IF_CONF_NOS: En la configuración hardware no se ha seleccionado el ajuste
"Ajustar nombre de dispositivo PROFINET en el dispositivo".
● Con IF_CONF_NTP: en la configuración hardware no se ha seleccionado el ajuste "Activar
sincronización horaria vía servidor NTP" y no se ha especificado ninguna dirección IP para
el servidor NTP.

C080_9400

0001_000x

Error en el tipo de datos de sistema IF_CONF_V4, IF_CONF_NOS, IF_CONF_NTP,
IF_CONF_V6, IF_CONF_MAC o IF_CONF_DNS:
Un valor de parámetro no está definido o no es admisible.

4132

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
STATUS*

ERR_LOC*

Explicación

C080_9500

0001_000x

Error en el tipo de datos de sistema IF_CONF_V4, IF_CONF_NOS, IF_CONF_NTP,
IF_CONF_V6, IF_CONF_MAC o IF_CONF_DNS:

C080_C200

0000_0000

Los valores de dos parámetros son incoherentes.
Error al llamar la instrucción:
La transferencia de los datos de configuración no puede ejecutarse. Causa posible: la interfaz
PROFINET no es accesible.
C080_C300

0000_0000

C080_C400

0000_0000

C080_D200

0000_0000

Error al llamar la instrucción:
Recursos insuficientes (p. ej. llamada múltiple de "T_CONFIG" con parámetros diferentes).
Error al llamar la instrucción:
Error de comunicación temporal. Intente llamar la instrucción más tarde.
Error al llamar la instrucción:
La llamada no es posible. La interfaz PROFINET seleccionada no soporta la instrucción.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Ejemplo de programa con T_CONFIG
Introducción
En el ejemplo siguiente se utiliza una conexión configurada (p. ej. UDP) entre dos CPU. Con
la instrucción "T_CONFIG" se configuran la dirección IP y el nombre de dispositivo PROFINET
de la CPU 1.

Requisitos
Establecer conexión:
● Se han creado dos CPU (p. ej. S7-1513-1 PN) y se han conectado entre sí a través de
PROFINET.
● No se requiere una conexión configurada.
Configurar PROFINET de la CPU 1:
1. Abra la vista de dispositivos de la CPU 1 "> Propiedades > Interfaz PROFINET >
Direcciones Ethernet > PROFINET".
2. Para ajustar el nombre de dispositivo se pueden utilizar las opciones siguientes:
– "Permitir ajustar la dirección IP directamente en el dispositivo".
– "Permitir ajustar el nombre de dispositivo PROFINET directamente en el dispositivo".

Programación del PLC
Manual de programación y manejo, 11/2019

4133

Instrucciones
4.1 Instrucciones
Modificar el valor de "hwid":
● Modifique el valor de "hwid" de acuerdo con el identificador de hardware de la interfaz
PROFINET del dispositivo local (CPU 1).
Nota
Abra "Variables PLC > Mostrar todas las variables > Constantes de sistema". Busque la
entrada "<Local~PROFINET_interface_1>" con el tipo de datos "Hw_Interface". La celda
"Valor" contiene el identificador de hardware.

Crear variables e interconectar parámetros (programa de la CPU 1)
Para almacenar los datos debe crearse un bloque de datos global ("SLI_gDB_T_CONFIG")
con las estructuras y variables siguientes.

En la estructura "configData": parametrice el tipo de datos de sistema "IF_CONF_Header" para
indicar el tamaño de los datos PROFINET del siguiente modo:

En la estructura "configData": parametrice el tipo de datos de sistema "IF_CONF_v4" para
definir la dirección IP del siguiente modo:

4134

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

En la estructura "configData": parametrice el tipo de datos de sistema "IF_CONF_NOS" para
definir el nombre de dispositivo PROFINET del siguiente modo:

Programación del PLC
Manual de programación y manejo, 11/2019

4135

Instrucciones
4.1 Instrucciones

Nota
Estructura de "configData"
La información de la estructura "configData" se interpreta del siguiente modo:
● En Header (IF_CONF_Header):
SubfieldCount = 2. El valor significa lo siguiente: En adelante se utilizarán dos estructuras
más ("deviceIP", "deviceName") (*).
* Asegúrese de mantener el orden de ambas estructuras.
● P. ej. en la estructura "deviceName" (tipo de datos de sistema IF_CONF_NOS):
– Lenght = 11 (*). El valor equivale a la longitud total de la estructura NOS (5 bytes para
el nombre de dispositivo "myplc" + 6 bytes para los parámetros Id, Length y Mode).
* En lugar de indicar la longitud absoluta, también se puede utilizar el valor de arranque
predeterminado (Lenght = 0) para una longitud dinámica.
– Mode = 1. El valor provoca un cambio permanente del nombre de dispositivo en "myplc".
– NOS[1] ... NOS[5]. La matriz NOS contiene el nuevo nombre de dispositivo (1 carácter /
byte).
Se crea el FB "SLI_FB_T_CONFIG". En él se crean las siguientes variables locales.

Segmento 1: Los parámetros de la instrucción "T_CONFIG" se interconectan del siguiente
modo.

Segmento 2: En caso de fallo de T_CONFIG, guarde el estado del siguiente modo.

4136

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Segmento 3: Para finalizar T_CONFIG se crean las interconexiones siguientes.

Resultado
Segmento 1:
Si el parámetro de entrada REQ ("T_CONFIG.start") devuelve el estado lógico "TRUE", se
inicia la instrucción "T_CONFIG". Durante varias llamadas, la instrucción "T_CONFIG"
configura la interfaz PROFINET integrada de la CPU. De acuerdo con el parámetro de entrada
INTERFACE ("T_CONFIG.hwid"), la instrucción "T_CONFIG" conoce la interfaz que debe
utilizarse.
Con el parámetro de salida DONE ("#done") a "TRUE" se indica la transmisión correcta del
juego de datos. Al mismo tiempo, en el parámetro de salida STATUS ("T_CONFIG.status") se
deposita el valor "0000_0000". Puesto que los valores de los parámetros de salida solo se
muestran en el momento en que son válidos, el aviso del éxito debe guardarse en la variable
"T_CONFIG.done".
En el parámetro de salida ERROR ("T_CONFIG.error") o en la variable
"T_CONFIG.memErrStat" se indica que la ejecución se ha realizado sin errores en el ejemplo.

Programación del PLC
Manual de programación y manejo, 11/2019

4137

Instrucciones
4.1 Instrucciones

Segmento 2:
Si T_CONFIG notifica un error ("T_CONFIG.error" es "TRUE"), guarde el aviso del siguiente
modo:
● Guarde el estado ("T_CONFIG.status") en la variable "T_CONFIG.memErrStat".
● Guarde la ubicación del error que se obtiene en el parámetro de salida ERR_LOC
("#errorLocation") de T_CONFIG en la variable "T_CONFIG.errorLocation".
Online y diagnóstico
Para comprobar si los datos PROFINET han cambiado, abra la ruta "Online y diagnóstico >
Funciones > Asignar nombre" en el árbol de proyectos de la CPU.

Código del programa
Encontrará información adicional y el código del programa del ejemplo anterior aquí: Sample
Library for Instructions (Página 615).

Consulte también
Descripción de T_CONFIG (Página 4121)

4138

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cambios en las instrucciones de comunicación
Diferencias entre las versiones <= V3.x y >= V4.1 de las librería OUC
Introducción
La CPU S7-1200 soporta nuevas versiones de instrucciones para la Open User
Communication (OUC) a partir de la versión de firmware 4.1. Las nuevas instrucciones están
incluidas en la librería con la versión 4.1.
Si desea utilizar esta librería tendrá que realizar cambios en el programa de usuario, pues las
nuevas instrucciones para la Open User Communication tienen un comportamiento distinto en
parte.
En el presente capítulo se describen con detalle las diferencias, especialmente en el
comportamiento de llamada de las instrucciones.
Nota
Descripción solo relevante en caso de cambiar de la CPU S7-1200 ≤ V4.0 a S7-1200 ≥ V4.1
Si se utiliza una CPU S7-1500, los cambios entre versiones de librerías no son relevantes. Lo
mismo sucede si se emplea un S7-1200 ≥ versión 4.1 y no se cambia la librería para Open User
Communication a la versión <4.1.

Diferencias entre las versiones <= V3.x y >= V4.1 de la librería Open User Communication
La tabla siguiente muestra las instrucciones de la librería Open User Communication en las
que hay diferencias entre las versiones <= V3.x y >= V4.1. Haga clic en el nombre de la
instrucción para obtener información detallada.
Instrucción

Versión en la librería <= V3.x

Versión en la librería >= V4.1

(FW CPU ≤ V4.0)

(FW CPU ≥ V4.1)

TSEND_C (Página 4140)

V2.1

V3.0

TRCV_C (Página 4141)

V2.1

V3.0

TMAIL_C *

V2.1

V3.0

TCON (Página 4143)

V3.0

V4.0

TDISCON

V2.1

V2.1 (idéntica a la librería <= V3.x)

TSEND (Página 4145)

V3.0

V4.0

TRCV (Página 4147)

V3.0

V4.0

TUSEND (Página 4145)

V3.0

V4.0

TURCV (Página 4147)

V3.0

V4.0

T_RESET *

V1.1

V1.2

T_DIAG *

V1.1

V1.2

T_CONFIG

V1.0

V1.0 (idéntica a la librería <= V3.x)

* Las diferencias entre las versiones no afectan al programa de usuario.

Programación del PLC
Manual de programación y manejo, 11/2019

4139

Instrucciones
4.1 Instrucciones

Nota
Cambio de la librería Open User Communication de una versión <= V3.x a una versión >= V4.1
En caso de cambiar la librería Open User Communication de una versión <= V3.x a una versión
>= V4.1 debe cambiar también la librería Modbus TCP. A continuación, compruebe todas las
instrucciones relevantes para el programa.

Consulte también
Diferencias entre las versiones <= V3.x y >= V4.0 de la librería Modbus TCP (Página 4645)

Cambios en la instrucción TSEND_C
Comportamiento de llamada de TSEND_C (V<3.0)
Hasta la versión 2.1 de la instrucción TSEND_C, el parámetro de salida DONE se activa dos
veces: una vez tras establecer la conexión por medio de la instrucción interna TCON y,
después, tras finalizar un proceso de envío por medio de la instrucción interna TSEND.
El gráfico siguiente muestra el establecimiento de la conexión y el envío de datos con
TSEND_C V2.1:
5(4
&217
&20B567
'21(
%86<
(5525
67$786

[ [ [ [ [ [ [ [ [ [ [ [ [

&RQH[LµQ

1RFRQHFWDGR

(VWDGR
76(1'B&

1RDFWLYR &RQHFWD &RQHFWD &RQHFWD

(VWDEOHFLGR

7&21'21(
7',$*'21(

(QY¯D

(QY¯D

76(1''21(

(QYLDGR &RQHFWDGR&RQHFWDGR

(QY¯D

(QY¯D

(QYLDGR &RQHFWDGR

76(1''21(

Ajustando el parámetro COM_RST a "1", se puede resetear el establecimiento de la conexión
o una transferencia de datos en curso en cualquier momento. Con ello, la conexión existente
se deshace y se establece una nueva.

4140

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Comportamiento de llamada de TSEND_C (V≥3.0)
A partir de esta versión de TSEND_C, el parámetro DONE solo se activa cuando ha finalizado
una transferencia de datos por medio de la instrucción interna TSEND (STATUS = 0000).
5(4
&217
&20B567
'21(
%86<
(5525
67$786

[ [ [ [ [ [ [ [ [ [ [ [ [

&RQH[LµQ

1RFRQHFWDGR

(VWDGR
76(1'B&

1RDFWLYR &RQHFWD &RQHFWD &RQHFWD

(VWDEOHFLGR

7&21'21(
7',$*'21(

(QY¯D

(QY¯D

(QYLDGR &RQHFWDGR&RQHFWDGR

76(1''21(

(QY¯D

(QY¯D

(QYLDGR &RQHFWDGR

76(1''21(

Al poner el parámetro COM_RST a "1" se interrumpe brevemente y se resetea la conexión
existente. Al contrario que con TSEND_C V2.1, el punto final de la conexión se conserva.

Nota
Protocolos adicionales con TSEND_C a partir de la versión 3.0
En la versión 3.0, la instrucción TSEND_C también soporta UDP y UDP Broadcast por medio
de la interfaz de la CPU y de CM/CP.

Consulte también
TSEND_C: Enviar datos a través de Ethernet (Página 3979)
TSEND_C: Establecer conexión y enviar datos (Página 3984)

Cambios en la instrucción TRCV_C
Comportamiento de llamada de TRCV_C (V<3.0)
Hasta la versión 2.1 de la instrucción TRCV_C, el parámetro de salida DONE se activa
después de establecer la conexión. En el parámetro de salida STATUS no se distingue si ha
concluido el establecimiento de la conexión o la transferencia de datos.
El gráfico siguiente muestra el establecimiento de la conexión y el envío de datos con TRCV_C
V2.1:

Programación del PLC
Manual de programación y manejo, 11/2019

4141

Instrucciones
4.1 Instrucciones
(1B5
&217
&20B567
'21(
%86<
(5525
67$786

[ [ [ [ [ [ [ [ [ [

&RQH[LµQ

1RFRQHFWDGR

(VWDEOHFLGR

(VWDGR75&9B&

1RDFWLYR &RQHFWD &RQHFWD &RQHFWD

5HFLEH

7&21'21(
7',$*'21(

5HFLEH

5HFLEH

75&9'21(

5HFLEH

5HFLEH

5HFLEH

75&9'21(

Ajustando el parámetro COM_RST a "1", se puede resetear el establecimiento de la conexión
o una transferencia de datos en curso en cualquier momento. Con ello, la conexión existente
se deshace y se establece una nueva.

Comportamiento de llamada de TRCV_C (V≥3.0)
A partir de esta versión de TRCV_C, el parámetro DONE solo se activa cuando ha finalizado
una transferencia de datos por medio de la instrucción interna TRCV (STATUS = 0000). La
conclusión del establecimiento de conexión mediante la instrucción interna TCON se indica en
el parámetro STATUS con el valor de salida 0x0001.
(1B5
&217
&20B567
'21(
%86<
(5525
67$786

[ [ [ [ [ [ [ [ [ [

&RQH[LµQ

1RFRQHFWDGR

(VWDEOHFLGR

(VWDGR75&9B&

1RDFWLYR &RQHFWD &RQHFWD &RQHFWD

5HFLEH

7&21'21(
7',$*'21(

5HFLEH

5HFLEH

75&9'21(

5HFLEH

5HFLEH

5HFLEH

75&9'21(

Al poner el parámetro COM_RST a "1" se interrumpe brevemente y se resetea la conexión
existente. Al contrario que con TSEND_C V2.1, el punto final de la conexión se conserva.
Nota
Protocolos adicionales con TRCV_C a partir de la versión 3.0
En la versión 3.0, la instrucción TRCV_C también soporta UDP y UDP Broadcast por medio de
la interfaz de la CPU y de CM/CP.

4142

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Nota
Modo ADHOC en la variante de protocolo TCP
De acuerdo con la instrucción TRCV, en TRCV_C hasta la versión 2.1 el modo ADHOC se
activa asignando el valor "0" al parámetro LEN. A partir de la versión 3.0 de la instrucción, se
utiliza para ello el parámetro ADHOC. Para más información al respecto consulte las
descripciones de las instrucciones.

Consulte también
Cambios en las instrucciones TRCV / TURCV (Página 4147)
TRCV_C: Recibir datos a través de Ethernet (Página 3993)
TRCV_C: Establecer conexión y recibir datos (Página 3999)

Cambios en la instrucción TCON
Cambio en el comportamiento de llamada en caso de error de conexión
Comportamiento de llamada actual de TCON (V<4.0)
● La instrucción TCON que había hasta ahora (V<4.0) se activa con un flanco ascendente en
el parámetro de entrada REQ.
● Si el interlocutor remoto no está accesible, la instrucción activa el parámetro de salida
BUSY.
● No se emite ningún mensaje de error.
El gráfico siguiente muestra el comportamiento de TCON por parte del interlocutor activo. Si no
se produce la conexión, la instrucción no vuelve a llamarse.
/ODPDGD













[

[ [ [

5(4
'21(
%86<
(5525
67$786
,QWHUORFXWRUUHPRWR

[ [

1RGLVSRQLEOH

&RQHFWDGR
(VWDGR7&21

Programación del PLC
Manual de programación y manejo, 11/2019

1RDFWLYR &RQHFWD

&RQHFWD

&RQHFWD

&RQHFWD

&RQHFWD

4143

Instrucciones
4.1 Instrucciones
Nuevo comportamiento de llamada de TCON (V≥4.0)
● La nueva instrucción TCON también se activa con un flanco ascendente en el parámetro de
entrada REQ.
● Al contrario que hasta ahora, se emite un mensaje de error cuando el interlocutor remoto no
está accesible. El error puede consultarse y la llamada puede volver a iniciarse con otro
flanco en el parámetro REQ.
● Para el programa de usuario se dan los cambios siguientes:
– Mensajes de error adicionales de TCON, que pueden evaluarse (véase la
descripción TCON (Página 4048)).
– El establecimiento de la conexión puede reinicializarse mediante un nuevo flanco
ascendente. Para ello, evalúe también los parámetros DONE y ERROR para
asegurarse de que hay un error.
El gráfico siguiente muestra el comportamiento de TCON por parte del interlocutor activo. Tras
un error de red (código de error 80C6) se llama de nuevo la instrucción.
/ODPDGD

















[

[ [& [ [ [



5(4
'21(
%86<
(5525
67$786

[ [

[

1RGLVSRQLEOH

,QWHUORFXWRUUHPRWR
&RQHFWDGR
(VWDGR7&21

1RDFWLYR &RQHFWD

&RQHFWD

&RQHFWD

(UURU

1RDFWLYR &RQHFWD

&RQHFWD

&RQHFWD

Comportamiento de llamada sin error de conexión
Si no hay ningún error de conexión, las diferentes versiones de TCON tienen el mismo
comportamiento.
El gráfico siguiente muestra el comportamiento de TCON por parte del interlocutor activo.

4144

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
/ODPDGD













[

[ [ [

5(4
'21(
%86<
(5525
67$786
,QWHUORFXWRUUHPRWR

[ [
1RGLVSRQLEOH

'LVSRQLEOH

&RQHFWDGR
(VWDGR7&21

1RDFWLYR &RQHFWD

&RQHFWD

&RQHFWD &RQHFWDGR &RQHFWDGR

Consulte también
TCON: Establecer una conexión (Página 4045)

Cambios en las instrucciones TSEND / TUSEND
Proceso de transmisión cuando hay conexión
Si durante el proceso de transmisión no se produce ningún retardo o interrupción, el
comportamiento de las instrucciones TSEND / TUSEND es el mismo en las versiones 3.0 y 4.0:
● La instrucción se llama con un flanco ascendente en el parámetro REQ. La instrucción se
procesa de forma asíncrona, es decir, debe llamarse tantas veces como sea necesario
hasta que el parámetro DONE indique que la ejecución ha finalizado.
● Con TSEND es posible transferir como máximo 8 KB de datos. Con TUSEND máximo 1472
bytes (a partir de la versión V2.5 del firmware de las CPU S7-1500 con Unicast o Multicast:
2048 bytes). Las indicaciones hacen referencia en cada caso al procesamiento completo
de la instrucción, es decir, todas las llamadas necesarias hasta que se activa el parámetro
DONE.
● La transferencia de datos se lleva a cabo en tres pasos:
– Los datos se escriben del área de operandos a un búfer interno (se muestra con
STATUS=7001).
– A continuación se lleva a cabo la transmisión al interlocutor remoto.
– Si la transmisión es correcta, DONE se pone a "1" y STATUS se vuelve a poner a "0"
(véase la llamada 5 en el gráfico siguiente).

Programación del PLC
Manual de programación y manejo, 11/2019

4145

Instrucciones
4.1 Instrucciones
/ODPDGD













[

[ [ [

5(4
'21(
%86<
(5525
67$786

[ [

/(1 P£[

.%

.%

,QWHUQR

1RDFWLYR

(QY¯D

(QY¯D

&RQHFWDGR
(VWDGR76(1'

(QY¯D

(QYLDGR

1RDFWLYR

Proceso de transmisión con llamada retardada
Si el proceso de transmisión no se lleva a cabo a través de un módulo de comunicación (CM)
o un procesador de comunicaciones (CP), el comportamiento de las instrucciones TSEND /
TUSEND es el mismo en las versiones 3.0 y 4.0:
● En el ejemplo siguiente se llama TSEND o TUSEND solo una vez con un flanco ascendente
en el parámetro REQ (véase la llamada 2 en el gráfico siguiente).
● Si el retardo de tiempo es lo suficientemente largo y ha sido posible transmitir los datos, en
la próxima llamada (en este caso la llamada 3) el parámetro DONE se pone directamente
a "1".
/ODPDGD





5HWDUGRGHWLHPSR
6LQOODPDGD





5(4
'21(
%86<
(5525
67$786
/(1 P£[

[ [

[ [

.%

.%

,QWHUQR

1RDFWLYR

(QY¯D

(QY¯D

&RQHFWDGR
(VWDGR76(1'

(QY¯D

(QYLDGR

1RDFWLYR

Si el proceso de transmisión se lleva a cabo a través de un CM/CP, el comportamiento de las
instrucciones TSEND / TUSEND es distinto en la versión 4.0. En este caso hay que llamar
varias veces la instrucción hasta que el parámetro NDR de las instrucciones TRCV / TURCV
confirma la recepción de los datos.

4146

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Proceso de transmisión en caso de interrupción de la conexión
Si la conexión se interrumpe durante el proceso de transmisión, los parámetros ERROR y
STATUS indican el error y su causa. En el ejemplo siguiente se ha interrumpido la conexión
durante la llamada n.º 5, lo que se señaliza con el parámetro STATUS.
A partir de la versión 4.0 de las instrucciones TSEND / TUSEND hay más avisos STATUS
disponibles que deben evaluarse en correspondencia (véase la descripción de TSEND
(Página 4061) / TUSEND (Página 4088)).
/ODPDGD















[

[ [& [





5(4
'21(
%86<
(5525
67$786
/(1 P£[

[ [
.%

&RQH[LµQ
(VWDGR76(1'

.%

.%

,QWHUQR

(QY¯D

.%

,QWHUUXPSLGR

(VWDEOHFLGR
1RDFWLYR

[ [

(QY¯D

(QY¯D

(UURU

1RDFWLYR

[

,QWHUQR
(VWDEOHFLGR

(QY¯D

(QY¯D

(QY¯D

Consulte también
TSEND: Enviar datos a través de la conexión (Página 4058)

Cambios en las instrucciones TRCV / TURCV
Proceso de recepción cuando hay conexión
Si durante el proceso de transmisión no se produce ningún retardo o interrupción, el
comportamiento de las instrucciones TRCV / TURCV es el mismo en las versiones 3.0 y 4.0:
● Con TRCV es posible transferir como máximo 8 KB de datos. Con TURCV máximo 1472
bytes (a partir de la versión V2.5 del firmware de las CPU S7-1500 con Unicast o Multicast:
2048 bytes). Las indicaciones hacen referencia en cada caso al procesamiento completo
de la instrucción, es decir, todas las llamadas necesarias hasta que se activa el parámetro
DONE.
● La instrucción recibe datos cuando el parámetro EN_R está puesto a "1".
● La recepción de datos no finaliza hasta que se haya recibido la longitud de datos definida
en el parámetro LEN. La longitud de los datos recibidos se emite en el parámetro de salida
RCVD_LEN. Solo entonces los datos están disponibles en el área definida en el parámetro
DATA.

Programación del PLC
Manual de programación y manejo, 11/2019

4147

Instrucciones
4.1 Instrucciones
/ODPDGD













(1B5
/(1 P£[
1'5
%86<

.%

.%

,QWHUQR

[

[

[

[

[

[









0£[.%



(5525
67$786
5&9'B/(1
&RQH[LµQ
(VWDGR75&9

(VWDEOHFLGR
1RDFWLYR

5HFLEH

5HFLEH

5HFLEH

5HFLEH

1RDFWLYR

Proceso de recepción con llamada retardada
Si el proceso de transmisión no se lleva a cabo a través de un módulo de comunicación (CM)
o un procesador de comunicaciones (CP), el comportamiento de las instrucciones TRCV /
TURCV es el mismo en las versiones 3.0 y 4.0:
● En el ejemplo siguiente se llama TRCV o TURCV solo una vez con un flanco ascendente
en el parámetro EN_R (véase la llamada 2 en el gráfico siguiente).
● Si el retardo de tiempo es lo suficientemente largo y ha sido posible transmitir los datos, en
la próxima llamada (en este caso la llamada 3) el parámetro NDR se pone directamente a
"1".
/ODPDGD



5HWDUGR
6LQOODPDGD







(1B5
/(1 P£[
1'5
%86<

.%

.%

,QWHUQR

(5525
67$786
5&9'B/(1

[

[







&RQH[LµQ
(VWDGR75&9



[

[

0£[.%



(VWDEOHFLGR
1RDFWLYR

5HFLEH

5HFLEH

5HFLEH

5HFLEH

1RDFWLYR

Si el proceso de transmisión se lleva a cabo a través de un CM/CP, el comportamiento de las
instrucciones TSEND / TUSEND es distinto en la versión 4.0. En este caso hay que llamar
varias veces la instrucción hasta que el parámetro NDR confirma la recepción de los datos.

4148

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Proceso de recepción en caso de interrupción de la conexión
Si la conexión se interrumpe durante el proceso de recepción, los parámetros ERROR y
STATUS indican el error y su causa. En el ejemplo siguiente se ha producido un error de
comunicación durante la llamada n.º 5, lo que se señaliza con el parámetro STATUS.
/ODPDGD















[

[ [& [





(1B5
/(1
1'5
%86<
(5525
67$786

[ [
.%

.%

,QWHUQR

.%

[ [
.%

5&9'B/(1

,QWHUQR
(VWDEOHFLGR

&RQH[LµQ
(VWDGR75&9

[

(VWDEOHFLGR
1RDFWLYR

(QY¯D

(QY¯D

(QY¯D

(UURU

1RDFWLYR

(QY¯D

(QY¯D

(QY¯D

A partir de la versión 4.0 de las instrucciones TRCV / TURCV hay más avisos STATUS
disponibles que deben evaluarse en correspondencia (consulte la descripción de TRCV
(Página 4069) / TURCV (Página 4092)).

Proceso de recepción cuando se usa el modo ADHOC
El modo ADHOC solo está disponible en la variante de protocolo TCP. El modo ADHOC se
utiliza para recibir datos de longitud variable con las instrucciones TRCV / TURCV. Si el modo
ADHOC está activo, la recepción de datos se confirma en el parámetro NDR en cuanto se ha
transmitido un byte como mínimo.
Recepción de datos en modo ADHOC con TRCV < 3.0 (S7-1200 < V4.0)
En la versión anterior de TRCV (Página 4065), el modo ADHOC se activa poniendo a "0" el
parámetro LEN. En el ejemplo siguiente se transmiten 10 bytes de datos en la 5.ª llamada.

Programación del PLC
Manual de programación y manejo, 11/2019

4149

Instrucciones
4.1 Instrucciones
/ODPDGD













(1B5
/(1 P£[
1'5
%86<

 DFWLYDFLµQGHOPRGR$'+2&

(5525
67$786

[

[

[

[

[

[









E\WHV



5HFLEH

1RDFWLYR

5&9'B/(1
&RQH[LµQ
(VWDGR75&9

(VWDEOHFLGR
1RDFWLYR

5HFLEH

5HFLEH

5HFLEH

Recepción de datos en modo ADHOC con TRCV ≥ 3.0 (S7-1200 ≥ V4.0 o S7-1500)
A partir de la versión 3.0 de la instrucción TRCV, el modo ADHOC se activa mediante un
parámetro propio (ADHOC).
/ODPDGD













(1B5
/(1

0£[.% 0£[.%

,QWHUQR

$'+2&
1'5
%86<
(5525
67$786
5&9'B/(1

[

[

[

[

[

[









E\WHV



5HFLEH

1RDFWLYR

&RQH[LµQ
(VWDGR75&9

(VWDEOHFLGR
1RDFWLYR

5HFLEH

5HFLEH

5HFLEH

Si durante el procesamiento se produce un error, a partir de la versión 4.0 de la instrucción
TRCV hay más avisos STATUS disponibles, que deben evaluarse en correspondencia.
Si el proceso de transmisión se lleva a cabo a través de un CM/CP, el comportamiento de las
instrucciones TRCV / TURCV es distinto en la versión 4.0. En este caso hay que llamar varias
veces la instrucción hasta que el parámetro NDR confirma la recepción de los datos.

4150

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

4.1.6.3

OPC UA

Instrucciones del cliente
Instrucciones OPC UA para programas de cliente
Introducción
En los siguientes capítulos se muestra el uso de las instrucciones OPC UA para programas de
cliente a partir de ejemplos de programas.
Los ejemplos se basan en una instalación con una CPU S7-1500 como servidor y otra CPU
S7-1500 como cliente:
● El servidor proporciona variables PLC para leer y escribir, así como un método de servidor.
● El cliente accede a los valores proporcionados y llama el método de servidor.
STEP 7 le ayudará a asignar valores a los parámetros de las instrucciones si crea una interfaz
de cliente y utiliza los parámetros de conexión para OPC UA. Gracias a ello, no es necesario
crear manualmente muchas variables para asignar valores a los parámetros. Encontrará un
ejemplo de trabajo manual en el capítulo sobre la instrucción "OPC_UA_TranslatePathList
(Página 4186)".
En los capítulos siguientes relacionados con las instrucciones OPC UA se describe la forma de
utilizar la cómoda parametrización para OPC UA.

Ejemplos de programas en SCL
Los ejemplos de programas emplean el lenguaje de programación Structured Control
Language (SCL).
Para cada ejemplo de programa está disponible el código fuente completo.

Instrucciones estandarizadas según PLCopen
Las instrucciones OPC UA para clientes se han implementado mayoritariamente de acuerdo
con la especificación "PLCopen OPC-UA-Client for IEC 61131-3".
La estandarización facilita la exportación de un programa de usuario a un controlador de otro
fabricante que también ofrezca las instrucciones OPC UA según PLCopen.
Por ello, si ya conoce las estructuras y procesos básicos en clientes OPC UA, le resultará más
fácil.

Muchas instrucciones de cliente trabajan con listas
Muchas instrucciones de cliente OPC UA no procesan un solo valor, sino listas.
Por ejemplo, la instrucción "OPC_UA_NamespaceGetIndexList" recibe una lista de espacios
de nombres y devuelve una lista de índices de dichos espacios.

Programación del PLC
Manual de programación y manejo, 11/2019

4151

Instrucciones
4.1 Instrucciones

Capacidad de un servidor OPC UA
Los propios servidores OPC UA proporcionan información sobre su capacidad.
La figura siguiente muestra el espacio de direcciones de una CPU S7 de tipo 1516-3 PN/DP.
En el nodo "MaxNodesPerRead" se indica cuántas variables PLC se pueden leer
simultáneamente con una llamada de la instrucción "OPC_UA_ReadList", por ejemplo.
El límite superior del array con el que puede alimentarse el parámetro "NodeHdls" se limita
mediante las propiedades del cliente OPC UA utilizado (consulte los datos técnicos del
cliente).
Para todas las interfaces de cliente (es decir, de todas las listas) rigen los siguientes límites:
● 1000 nodos para CPU 1510SP (F), CPU 1511 (C/F/T/TF), CPU 1512C, CPU 1512SP (F),
CPU 1513 (F)
● 2000 nodos para CPU 1505 (S/SP/SP F/SP T/SP TF), CPU 1515 (F/T/TF),
CPU 1515 SP PC (F/T/TF), CPU 1516 (F/T/TF)
● 5000 nodos para CPU 1507S (F), CPU 1517 (F/T/TF), CPU 1518 (F)

La figura muestra un fragmento del área de direcciones de un servidor OPC UA, representado
con el programa "UaExpert" de Unified Automation.

4152

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Números de error
Los números de error de las instrucciones se dividen del siguiente modo:
● Si el número de error empieza por "16#B0" o "16#C0", lo habrá asignado Siemens;
consulte Códigos de error de Siemens (Página 4289).
Ejemplo: Los siguiente números de error son generales y en principio pueden aparecer en
todas las instrucciones del cliente:
B080_C400

ClientNotEnabled

Cliente desactivado.
Active el cliente en TIA Portal.

B080_C500

ClientNotAvailable

Error al inicializar el cliente

C080_C300

Simatic_OutOfResources

Error en la asignación de me‐
moria o demasiadas instancias
de la instrucción

● Si el número de error empieza por "16#80", lo habrá asignado la OPC Foundation;
consulte Códigos de error de la OPC Foundation (Página 4291).
● Si el número de error empieza por "16#A0", lo ha asignado PLCopen; ver Códigos de error
de PLCopen (Página 4300).
En el capítulo 4 de la especificación "PLCopen OPC UA Client for IEC 61131-3" encontrará
también una lista de números de error de PLCopen. La especificación está disponible en
PLCopen.

Preparar intercambio de datos
OPC_UA_Connect: crear una conexión
Validez
La siguiente descripción de la instrucción "OPC_UA_Connect" se aplica a las CPU S7-1500
con versión de firmware V2.6 y superior.

Descripción
La instrucción "OPC_UA_Connect" establece una conexión a un servidor OPC UA.
La figura siguiente muestra el símbolo de la instrucción en el editor (FUP).

Programación del PLC
Manual de programación y manejo, 11/2019

4153

Instrucciones
4.1 Instrucciones

En la figura superior, los parámetros de la instrucción todavía no reciben valores.
La instrucción sirve para preparar el intercambio de datos entre un servidor y un cliente OPC
UA; consulte la explicación ① en el siguiente gráfico:
La instrucción devuelve un controlador o "handle" de conexión (una referencia numérica) que
utilizan las instrucciones siguientes para remitir a la conexión.





23&B8$B'LVFRQQHFW

23&B8$B&RQQHFW
23&B8$B1DPHVSDFH*HW,QGH[/LVW
23&B8$B1RGH*HW+DQGOH/LVW

23&B8$B5HDG/LVW
23&B8$B:ULWH/LVW

①
②
③

23&B8$B1RGH5HOHDVH+DQGOH/LVW

Instrucciones para preparar las operaciones de lectura y escritura
Instrucciones de lectura y escritura (según aplicación, las instrucciones se llaman de forma
repetida)
Instrucciones para liberar recursos una vez ejecutadas las operaciones de lectura o escritura

Parámetros de "OPC_UA_Connect"

4154

Parámetro

Declaración en el
área

Tipo de
datos

Significado

REQ

Input

BOOL

Un flanco ascendente 0 → 1 en el pará‐
metro dispara la ejecución de la instruc‐
ción.

ServerEndpointUrl

InOut

VARIANT

Puntero hacia una variable de tipo
STRING o WSTRING con la dirección
(URL) del servidor OPC UA. Se admiten
direcciones IPv4, además de FQDN (Fully
Qualified Domain Names), siempre que
se haya configurado un servidor DNS en
las propiedades de la CPU.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración en el
área

Tipo de
datos

Significado

SessionConnectInfo

InOut

VARIANT

Puntero a la descripción de la conexión en
una variable del tipo de datos de sistema
"OPC_UA_SessionConnectInfo (Pági‐
na 4280)".

Timeout

Input

TIME

Intervalo de tiempo máximo en milisegun‐
dos para establecer la conexión.
El parámetro "Timeout" define el tiempo
de servicio excedido para órdenes de ser‐
vicio OPC UA subordinadas que el cliente
envía al servidor.
Los valores de timeout inferiores a 100 ms
y los valores negativos se ajustan a 100
ms, pues no es aconsejable utilizar valo‐
res menores.

Done

Output

BOOL

Parámetro sobre el estado de la ejecu‐
ción:
● 0: Ejecución de la instrucción
interrumpida, no finalizada o no
iniciada.
● 1: Ejecución de la instrucción
finalizada sin errores

Busy

Output

BOOL

Parámetro sobre el estado de la ejecu‐
ción:
● 0: La instrucción no se está ejecutando
● 1: Instrucción ejecutándose en estos
momentos

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error. Consulte
el parámetro "Status".

Status

Output

DWORD

Causa del error, consulte más abajo "Nú‐
meros de error de Status".

ConnectionHdl

Output

DWORD

Identificación unívoca de una conexión
establecida.
Este controlador (handle) lo necesitan
otras instrucciones OPC UA como pará‐
metro de entrada.

Números de error de Status
El parámetro "Status" informa sobre errores que pueden producirse durante la ejecución de la
instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

4155

Instrucciones
4.1 Instrucciones
La tabla siguiente explica los códigos de error:
Código de error

Nombre del error

Explicación

0000_0000

OpcUa_Good

Instrucción finalizada correcta‐
mente

8003_0000

OpcUa_BadOutOfMemory

No hay memoria disponible pa‐
ra el cliente OPC UA.

(valores hexadecima‐
les)

Como el cliente OPC UA y el
servidor OPC UA comparten
un área de memoria es nece‐
sario reducir la memoria nece‐
saria del servidor.
Para ello, existen las siguientes
posibilidades:
● Liberar menos variables
PLC para OPC UA.
● Reducir el número de
clientes OPC UA
conectados actualmente
con el servidor.
● Crear menos suscripciones.
● General: Reduzca el
número de elementos que
inician sesión mediante
OPC UA. Utilice una
herramienta de diagnóstico
del servidor OPC UA (p. ej.
UaExpert de Unified
Automation) para
asegurarse de que no hay
sesiones ni suscripciones
inactivas. Para
contrarrestar el problema
puede elegir timeouts
adecuados (Subscription
Timeout <= Session
Timeout) en el cliente.

4156

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

OpcUa_BadCommunicationError

Error al establecer la conexión.

(valores hexadecima‐
les)
8005_0000

Causas posibles:
● La dirección de servidor
(ServerEndpointURL) es
incorrecta o incompleta.
● El servidor no acepta el
tamaño del búfer enviado
por el cliente al establecer
la conexión.
Soluciones:
● Compruebe y corrija la
ServerEndpointURL
● Compruebe el tamaño de
búfer permitido: El cliente
de la CPU S7-1500
proporciona 8192 bytes. El
servidor debe aceptar este
valor.
800A_0000

OpcUa_BadTimeout

Se ha producido un timeout de
red.
Causas posibles:
● La conexión al servidor
OPC UA es demasiado
lenta.
● La red está sobrecargada.
● El servidor OPC UA no está
disponible.
● Es posible que el servidor
no acepte el tamaño del
búfer enviado por el cliente
al establecer la conexión.
Soluciones:
● Compruebe la URL del
servidor OPC UA.
● Aumente el valor de
timeout de la instrucción
OPC_UA_Connect.
● Compruebe el tamaño de
búfer permitido: El cliente
de la CPU S7-1500
proporciona 8192 bytes. El
servidor debe soportar este
valor.

Programación del PLC
Manual de programación y manejo, 11/2019

4157

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

OpcUa_BadNotSupported

Causas posibles:

(valores hexadecima‐
les)
803D_0000

● La dirección de servidor
(ServerEndpointURL) es
incorrecta o incompleta.
● El servidor no admite la
operación solicitada.
8054_0000

OpcUa_BadSecurityModeInsufficient

El servidor exige mayores re‐
quisitos de seguridad (Security
Policy).
Posibles soluciones:
● utilice una configuración
más segura para
conectarse al servidor.

8055_0000

OpcUa_BadSecurityPolicyRejected

El servidor no soporta la Secu‐
rity Policy o el Transport Profile

8056_0000

BadTooManySessions

El servidor ha alcanzado el nú‐
mero máximo de sesiones.

8081_0000

BadTcpNotEnoughResources

Se han agotado los recursos de
conexión del cliente que se ne‐
cesitan para establecer la co‐
nexión.
Posibles soluciones:
● Si la conexión se establece
y deshace rápidamente
debe reducirse la
frecuencia.

B080_0100

Simatic_BadType_VariantInput1

Tipo de datos incorrecto para el
parámetro "ServerEndpoin‐
tUrl".

B080_0200

Simatic_BadType_VariantInput2

Tipo de datos incorrecto para el
parámetro "SessionConnectIn‐
fo".

B080_2200

Simatic_BadValue_VariantInput2

Valor incorrecto de las varia‐
bles "SessionConnectInfo".

B080_C400

Simatic_ClientNotEnabled

El cliente OPC UA está desac‐
tivado.
Solución: active el cliente OPC
UA en las propiedades de la
CPU (sección OPC UA > Clien‐
te).

4158

B080_C500

Simatic_NothingToDo

Error al inicializar el cliente.

B080_C600

Simatic_ClientNotAvailable

Error al inicializar el cliente.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

Simatic_OutOfResources

Se ha excedido el número má‐
ximo de instrucciones de clien‐
te que pueden utilizarse simul‐
táneamente.

(valores hexadecima‐
les)
C080_C300

Posibles soluciones:
● Reduzca el número de
instrucciones de cliente
paralelas de este tipo;
consulte:
AUTOHOTSPOT
Encontrará más códigos de error en AUTOHOTSPOT

Descripción del establecimiento de la conexión y de la desconexión
Si un mensaje de error hace referencia a una escasez de recursos, es posible determinar los
recurso de conexión ocupados en ese momento para el servicio "Comunicación cliente/
servidor OPC UA" con ayuda del diagnóstico de conexión para ver cuántos recursos siguen
libres.
La comunicación cliente/servidor OPC UA se basa en el protocolo TCP. Tenga en cuenta que
el protocolo TCP hace que al deshacer la conexión algunos recursos de conexión
permanezcan ocupados durante un tiempo de espera determinado aunque la conexión ya se
haya deshecho. Antes de establecer una conexión productiva, en OPC UA se establece una
conexión para determinar el punto final de la conexión con el interlocutor deseado (proceso
Discovery).
Recomendación: si se mueve en el límite de recursos de conexión disponibles para el número
de conexiones necesarias, conviene establecer las conexiones OPC UA dilatadas en el
tiempo. Si la CPU establece las conexiones OPC UA en intervalos cortos, existe riesgo de
sufrir escasez de recursos.
Las figuras siguientes muestran la secuencia de establecimiento de la conexión y de
desconexión con los tiempos de espera correspondientes y la asignación de recursos
resultante.
Consulte también: AUTOHOTSPOT

Cómo utilizar esta instrucción
Los apartados siguientes muestran cómo se emplea la instrucción "OPC_UA_Connect" en un
programa que intercambia datos con un servidor OPC UA.

Requisitos
En la siguiente descripción se presupone lo siguiente:
● Se ha creado una interfaz de cliente; consulte "AUTOHOTSPOT".
● Se ha parametrizado una conexión a un servidor OPC UA en las propiedades de esta
interfaz de cliente.

Programación del PLC
Manual de programación y manejo, 11/2019

4159

Instrucciones
4.1 Instrucciones

Parametrizar conexiones seguras
Con la instrucción "OPC_UA_Connect" es posible establecer una conexión no segura con un
servidor OPC UA. No obstante, debería utilizarse siempre una conexión segura.

Cómo utilizar una interfaz de cliente
1. En el área "Árbol del proyecto", seleccione la CPU que actúa como cliente.
2. Agregue un bloque de función nuevo a la carpeta "Bloques de programa".
En el ejemplo, el bloque de función se denomina "ReadFromProductionline".
Lenguaje utilizado: SCL.
3. Arrastre la instrucción "OPC_UA_Connect" desde la carpeta "Instrucciones >
Comunicación > OPC UA > Cliente OPC UA" hasta el editor con la función de arrastrar y
colocar.
4. Seleccione la llamada como multiinstancia.
STEP 7 crea una instancia de esta instrucción y la denomina
"OPC_UA_Connect_Instance".
5. Haga clic en el símbolo de "Iniciar configuración" junto a la instrucción
"OPC_UA_Connect_Instance".

STEP 7 abre la ficha "Configuración" de la ventana de inspección.
6. En "Seleccionar interfaz del cliente para la conexión OPC UA", elija la interfaz de cliente que
desee emplear para la instrucción.
En el ejemplo, la interfaz de cliente se denomina "Productionline".

STEP 7 asigna automáticamente los valores configurados en la interfaz de cliente a los
parámetros de la instrucción.
7. Haga clic en "Parámetros del bloque" y asigne variables manualmente a los demás
parámetros (REQ, Busy, Done, Error, Status).
STEP 7 inserta las variables elegidas en la llamada de la función.

Llamada de la instrucción
El código fuente siguiente muestra cómo emplear la instrucción "OPC_UA_Connect" para
establecer una conexión a un servidor OPC UA.
Encontrará el programa completo en el capítulo "AUTOHOTSPOT".

4160

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El programa de ejemplo se divide en varias secciones (Cases) mediante una instrucción
CASE. La variable #State controla qué sección del programa se ejecutará.
En la 1.ª sección del programa se establece una conexión:
SCL
1: // case 1, connect to server
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Connect_Instance(REQ := #Req,
ServerEndpointUrl := "Productionline_Configuration".Connection.ServerEndpointUrl,
SessionConnectInfo := "Productionline_Configuration".Connection.ConnectInfo,
Timeout := "Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
ConnectionHdl => "Productionline_Configuration".Connection.ConnectionHdl,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
// Did we get a connection handle?
IF "Productionline_Configuration".Connection.ConnectionHdl <> 0 THEN
// We have to release all resources in the server and disconnect
#State := 100;
//In case 100, to set REG of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
ELSE
#State := 99;
END_IF;
#Mem_Status := #Status;
// set parameter REQ of OPC_UA_Connect to FALSE
#OPC_UA_Connect_Instance(ServerEndpointUrl :=
"Productionline_Configuration".Connection.ServerEndpointUrl,
SessionConnectInfo := "Productionline_Configuration".Connection.ConnectInfo,
REQ := FALSE,
ConnectionHdl => "Productionline_Configuration".Connection.ConnectionHdl,
Timeout := "Productionline_Configuration".Connection.ConnectInfo.SessionTimeout);
END_IF;

El programa de ejemplo llama la instrucción "OPC_UA_Connect" por los siguientes motivos:
● para establecer la conexión con un servidor OPC UA.
● para poner el parámetro REQ al valor "FALSE" en caso de error.
Ejecución asíncrona
La instrucción "OPC_UA_Connect" se ejecuta asíncronamente respecto al programa de
usuario y necesita varios ciclos de programa.
El estado actual de la ejecución se controla con los parámetros "Busy", "Done", "Error" y
"Status".

Programación del PLC
Manual de programación y manejo, 11/2019

4161

Instrucciones
4.1 Instrucciones
La ejecución asíncrona del programa se describe en el capítulo "Diferencia entre las
instrucciones que funcionan síncronamente y las que funcionan asíncronamente
(Página 618)".

Explicación de la llamada de la instrucción
Esta sección del programa establece una conexión al servidor OPC UA que se ha registrado
al parametrizar la interfaz de cliente.
La variable "#State" contiene el valor "1" al iniciar el programa.
Si la instrucción "OPC_UA_Connect" aún no se ejecuta, #Busy es igual a FALSE, con lo que
#Req se pone a TRUE. Con ello se inicia la instrucción. En el siguiente ciclo, #Req tiene el valor
FALSE.
Si el parámetro de salida "Done" tiene el valor TRUE, se ha podido establecer una conexión.
Si el proceso ha concluido correctamente, el valor de la variable #State aumenta en uno. De
este modo, en el siguiente ciclo se ejecuta la siguiente sección del programa (2:); consulte
OPC_UA_NamespaceGetIndexList: leer índices de los espacios de nombres (Página 4163).
Si se ejecuta correctamente, en el parámetro "ConnectionHdl" se muestra además la
referencia numérica de la conexión establecida.
Si se ha producido un error, el parámetro de salida "Error" tiene el valor TRUE.
● Si en caso de error se devuelve un controlador (handle) de la conexión, deben liberarse
recursos en el servidor. Para ello se asigna el valor 100 a la variable #State.
● Si en caso de error no se devuelve ningún controlador (handle) de la conexión, se asigna
el valor 99 a la variable #State.
Las secciones del programa 99 y 100 están previstas para el tratamiento de errores.

Consulte también
Programa de ejemplo para leer variables PLC (Página 4307)
OPC_UA_TranslatePathList: Determinar los ID de nodo actuales (Página 4186)
Códigos de error de Siemens (Página 4289)
Instrucciones OPC UA para programas de cliente (Página 4151)

Recomendación de programación: Vigilar conexiones
Recomendaciones para la vigilancia de conexiones
Se recomienda vigilar de forma cíclica las conexiones establecidas con la instrucción
"OPC_UA_Connect" a fin de reaccionar selectivamente a interrupciones de la conexión y, en
caso de fallo, establecer inmediatamente una nueva conexión.
En la siguiente descripción del bloque de usuario S7 para el cliente OPC UA de una CPU
S7-1500 se explica la integración de una vigilancia de conexiones, entre otras cuestiones.
Bloque de usuario S7 para el cliente OPC UA de un SIMATIC S7-1500 (https://
support.industry.siemens.com/cs/ww/es/view/109762770)

4162

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Modificaciones a partir de la versión de firmware V2.8 de la CPU
Los controladores (handles) de la conexión referencian una conexión en OPC UA. A partir de
la versión de firmware 2.8, en caso de conexión interrumpida o con fallos, se debe liberar
explícitamente el controlador (handle) de la conexión afectada llamando la instrucción
"OPC_UA_Disconnect". Mientras el controlador (handle) de la conexión no se haya liberado,
no será válido y no se podrá utilizar.
Tras liberar el controlador (handle) de la conexión, la CPU puede reutilizarlo para una nueva
conexión (OPC_UA_Connect).

Consulte también
OPC_UA_ConnectionGetStatus: leer estado de la conexión (Página 4249)

OPC_UA_NamespaceGetIndexList: leer índices de los espacios de nombres
Validez
La siguiente descripción de la instrucción "OPC_UA_NamespaceGetIndexList" se aplica a las
CPU S7-1500 con versión de firmware V2.6 y superior.

Descripción
Con la instrucción "OPC_UA_NamespaceGetIndexList" se consultan los índices actuales de
los espacios de nombres en un servidor OPC UA.
La figura siguiente muestra el símbolo de la instrucción en el editor (FUP).

En la figura superior, los parámetros de la instrucción todavía no reciben valores.
La instrucción "OPC_UA_NamespaceGetIndexList" sirve para preparar el intercambio de
datos con un servidor OPC UA; véase ① en el siguiente gráfico.

Programación del PLC
Manual de programación y manejo, 11/2019

4163

Instrucciones
4.1 Instrucciones
Para leer o escribir una variable PLC o para llamar un método, se debe conocer el índice del
espacio de nombres en el que se encuentra la variable PLC. El índice es una parte de la
dirección (NodeId) de esa variable PLC en el espacio de direcciones del servidor OPC UA.
La instrucción devuelve una lista de índices de los espacios de nombres del servidor OPC UA.
La lista se necesita para consultar mediante la instrucción "OPC_UA_NodeGetHandleList" los
ID de nodo con los que pueden darse órdenes de lectura y escritura.





23&B8$B'LVFRQQHFW

23&B8$B&RQQHFW
23&B8$B1DPHVSDFH*HW,QGH[/LVW
23&B8$B1RGH*HW+DQGOH/LVW

23&B8$B5HDG/LVW
23&B8$B:ULWH/LVW

①
②
③

23&B8$B1RGH5HOHDVH+DQGOH/LVW

Instrucciones para preparar las operaciones de lectura y escritura
Instrucciones de lectura y escritura
Instrucciones para liberar recursos una vez ejecutadas las operaciones de lectura o escritura

Parámetros de "OPC_UA_NamespaceGetIndexList"
Tabla 4-73

Los parámetros de la instrucción "OPC_UA_NamespaceGetIndexList"

Parámetro

Declaración en
el área

Tipo de
datos

Significado

REQ

Input

BOOL

Un flanco ascendente 0 → 1 en el parámetro
dispara la ejecución de la instrucción.

ConnectionHdl

Input

DWORD

Identificación unívoca de una conexión esta‐
blecida.
El controlador (handle) se obtiene con la ins‐
trucción OPC_UA_Connect: crear una cone‐
xión (Página 4153).

NamespaceUrisCount

Input

UINT

Número de espacios de nombres en el pará‐
metro NamespaceUris

NamespaceUris

InOut

VARIANT

Puntero a un array del tipo STRING o
WSTRING.
El array contiene las URIs de los distintos es‐
pacios de nombres cuyos índices deben con‐
sultarse.

Timeout

Input

TIME

Intervalo de tiempo máximo en milisegundos
para la ejecución de la instrucción.
Consulte también la explicación de este pará‐
metro en OPC_UA_Connect: crear una cone‐
xión (Página 4153).

4164

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración en
el área

Tipo de
datos

Significado

StatusList

InOut

VARIANT

Puntero a un array del tipo DWORD (opcional).
El array contiene los códigos de error para los
diferentes espacios de nombres.
Para cada espacio de nombres se indica si se
le ha podido asignar un índice.

NamespaceIndexes

InOut

VARIANT

Puntero a un array del tipo UINT.
El array contiene los índices de los distintos
espacios de nombres que han sido consulta‐
dos por el servidor OPC UA.

Done

Output

BOOL

Estado de ejecución:
● 0: Ejecución de la instrucción interrumpida,
no finalizada o no iniciada.
● 1: Ejecución de la instrucción finalizada sin
errores

Busy

Output

BOOL

Parámetro sobre el estado de la ejecución:
● 0: La instrucción no se está ejecutando
● 1: Instrucción ejecutándose en estos
momentos

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error. Consulte el
parámetro "Status".

Status

Output

DWORD

Causa del error, consulte más abajo "Números
de error de Status"

Números de error de Status
El parámetro "Status" informa sobre errores que pueden producirse durante la ejecución de la
instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

4165

Instrucciones
4.1 Instrucciones
En la tabla siguiente encontrará una relación de códigos de error para esta instrucción:
Código de error

Nombre del error

Explicación

0000_0000

OpcUa_Good

Instrucción finalizada correcta‐
mente

8003_0000

OpcUa_BadOutOfMemory

No hay memoria disponible pa‐
ra el cliente OPC UA.

(valores hexadecima‐
les)

Como el cliente OPC UA y el
servidor OPC UA comparten un
área de memoria es necesario
reducir la memoria necesaria
del servidor.
Para ello, existen las siguientes
posibilidades:
● Liberar menos variables
PLC para OPC UA.
● Reducir el número de
clientes OPC UA
conectados actualmente
con el servidor.
● Crear menos suscripciones.
8009_0000

OpcUa_BadUnknownResponse

El servidor no responde con el
número esperado de elemen‐
tos del array Namespace.

800A_0000

OpcUa_BadTimeout

Se ha producido un timeout de
red.
Posibles causas:
● La conexión al servidor
OPC UA es demasiado
lenta (muy poca capacidad).
● La red está sobrecargada.
● El servidor OPC UA no está
disponible
Posibles soluciones:
● Compruebe la URL del
servidor OPC UA
● Aumente el intervalo de
tiempo de timeout (mayor
valor para el parámetro
Timeout del bloque de
función
OPC_UA_Connect).

4166

800D_0000

OpcUa_BadServerNotConnected

El servidor no está conectado o
el controlador (handle) de la co‐
nexión es incorrecto o no es vá‐
lido.

800F_0000

OpcUa_BadNothingToDo

NamespaceUrisCount es 0

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

OpcUa_BadTooManyOperations

Se ha excedido el número de
instrucciones "OPC_UA_Na‐
mespaceGetIndexList" que
pueden llamarse simultánea‐
mente por conexión (> 1); con‐
sulte:

(valores hexadecima‐
les)
8010_0000

AUTOHOTSPOT
809E_0000

OpcUa_BadDataUnavailable

Los índices de los espacios de
nombres no están disponibles
actualmente.

80AE_0000

BadConnectionClosed

La conexión con el Connec‐
tionHdl correspondiente está
en el estado "ShutDown" (des‐
conectada). La conexión/
sesión no se ha podido "reacti‐
var" automáticamente. Causa
posible: sesión en el servidor
borrada (p. ej., por reinicio o ti‐
meout).
En este caso, la conexión se
debe cerrar explícitamente con
la instrucción "OPC_UA_Dis‐
connect" para volver a liberar
los recursos de conexión. El
ConnectionHdl para esta cone‐
xión que ha dejado de ser váli‐
da debe restablecerse en el
programa de usuario.
Finalmente, debe establecerse
una nueva conexión con el ser‐
vidor (ver instrucción
"OPC_UA_Connect").

80AF_0000

Programación del PLC
Manual de programación y manejo, 11/2019

BadInvalidState

La conexión con el Connec‐
tionHdl correspondiente está
en el estado "ConnectinError"
(error temporal de conexión, co‐
nexión interrumpida). La CPU
intenta "reactivar" la conexión.
Si esto no se logra durante el
intervalo de timeout ajustado
(OPC UA Session Timeout), la
conexión pasa al estado "Shut‐
down". Requisitos para el cam‐
bio de estado: La CPU ha podi‐
do acceder al servidor OPC UA
para comprobar si la sesión to‐
davía está presente o no.

4167

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

PLCopenUA_Bad_ConnectionInvalidHdl

Controlador (handle) de la co‐
nexión (ConnectionHdl) no váli‐
do/desconocido.

(valores hexadecima‐
les)
A000_0105

Ver OPC_UA_Connection‐
GetStatus: leer estado de la co‐
nexión (Página 4249)
B080_0100

Simatic_BadType_VariantInput1

Tipo de datos incorrecto para el
parámetro "NamenspaceUris".

B080_0200

Simatic_BadType_VariantInput2

Tipo de datos incorrecto para el
parámetro "StatusList".

B080_0300

Simatic_BadType_VariantInput3

Tipo de datos incorrecto para el
parámetro "NamenspaceInde‐
xes".

B080_1100

Simatic_ArrayElements_TooMany

NamespaceUrisCount >
MAX_ELEMENTS_NAMESPA‐
CES

B080_3100

BadNumElements_VariantInput1

NamespaceUrisCount > núme‐
ro de elementos del array del
parámetro "NamespaceUris".

B080_3200

BadNumElements_VariantInput2

NamespaceUrisCount > núme‐
ro de elementos del array del
parámetro "StatusList".

B080_3300

BadNumElements_VariantInput3

NamespaceUrisCount > núme‐
ro de elementos del array del
parámetro "NamespaceInde‐
xes".

B080_C500

Simatic_NothingToDo

No hay que hacer nada: La ins‐
trucción utiliza una lista que no
contiene ningún elemento (es‐
pacios de nombres).

C080_C300

Simatic_InsufficientResources

Se ha excedido el número má‐
ximo de instrucciones de clien‐
te que pueden utilizarse simul‐
táneamente.
Posibles soluciones:
● Reduzca el número de
instrucciones de cliente
paralelas de este tipo;
consulte: AUTOHOTSPOT

Encontrará más códigos de error en AUTOHOTSPOT

Números de error de "StatusList"
El parámetro contiene un código de error para cada espacio de nombres.

4168

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente explica los códigos de error:
Código de error

Nombre del error

Explicación

OpcUa_Good

El espacio de nombres es encontrado.

(valores hexadecima‐
les)
0000_0000

El índice del espacio de nombres se registra en el
array al que señala el parámetro "NamespaceIn‐
dexes".
806F_0000

OpcUA_BadNoMatch

El espacio de nombres no es encontrado.

Encontrará más códigos de error en AUTOHOTSPOT

Cómo utilizar esta instrucción
En este capítulo se explica, a partir de un ejemplo, cómo se emplea la instrucción
"OPC_UA_NamespaceGetIndexList" en un programa que intercambia datos con un servidor
OPC UA.

Requisitos
En la siguiente descripción se presupone lo siguiente:
● Se ha creado una interfaz de cliente; consulte "AUTOHOTSPOT".
● Se ha parametrizado una conexión a un servidor OPC UA en las propiedades de esta
interfaz de cliente; consulte "AUTOHOTSPOT".
Asimismo, para la instrucción "OPC_UA_NamespaceGetIndexList" debe cumplirse lo
siguiente:
● Existe un controlador (handle) para una conexión a un servidor OPC UA.
El controlador (handle) de la conexión se obtiene llamando la
instrucción OPC_UA_Connect: crear una conexión (Página 4153).

Función de la instrucción
Para el intercambio de datos se necesitan los índices de los espacios de nombres en los que
se encuentran las variables que se desea leer o escribir mediante el programa.
Para llamar métodos, se necesitan también los índices actuales de los espacios de nombres
en los que se encuentran los métodos.
Según la especificación OPC UA, en un servidor OPC UA la asignación entre el espacio de
nombres y el índice correspondiente no está fijada y puede cambiar, p. ej. si se agregan
nuevos espacios de nombres o si se prescinde de alguno.
Por esta razón es necesario solicitar siempre los índices actuales al servidor OPC UA antes de
registrar controladores de nodos con la instrucción OPC_UA_NodeGetHandleList. Para ello se
utiliza la instrucción "OPC_UA_NamespaceGetIndexList".

Programación del PLC
Manual de programación y manejo, 11/2019

4169

Instrucciones
4.1 Instrucciones
¿Qué información devuelve la instrucción?
La instrucción proporciona los datos siguientes:
● Una lista con los índices de cada uno de los espacios de nombres (parámetro
"NamespaceIndexes"). El orden de los índices se corresponde con el orden de los espacios
de nombres en el parámetro "NamespaceUris".
● Una lista de mensajes de error (parámetro "StatusList").
Cada mensaje de error de esta lista hace referencia al correspondiente espacio de nombres
en el parámetro "NamespaceUris".
Para cada espacio de nombres hay que comprobar si se puede devolver el índice de dicho
espacio de nombres.

Determinar los espacios reservados para nombres y sus índices con UaExpert
Para poder utilizar la instrucción debe conocerse el URI (Uniform Resource Indentifier) del
espacio de nombres. Los URI del espacio de nombres y sus índices (Namespace URI y Node
Namespace Index) pueden averiguarse con UaExpert, tal como muestra el ejemplo siguiente:

Cómo utilizar una interfaz de cliente
1. En el área "Árbol del proyecto", seleccione la CPU que actúa como cliente.
2. En la carpeta "Bloques de programa", seleccione el bloque de función que debe contener
la instrucción del cliente.
En el ejemplo, el bloque de función se denomina "ReadFromProductionline".
Lenguaje seleccionado: SCL
3. Arrastre la instrucción "OPC_UA_NamespaceGetIndexList" desde la carpeta
"Instrucciones > Comunicación > OPC UA > Cliente OPC UA" hasta el editor con la función
Drag & Drop.
4. Seleccione la llamada como multiinstancia.
STEP 7 crea una instancia de esta instrucción y la denomina
"OPC_UA_NamespaceGetIndexList_Instance".
5. Haga clic en el símbolo de "Iniciar configuración" junto a la instrucción
"OPC_UA_NamespaceGetIndexList_Instance".
STEP 7 abre la ficha "Configuración" de la ventana de inspección.

4170

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
6. En "Seleccionar interfaz del cliente para la interfaz OPC UA", elija la interfaz de cliente que
desee emplear con la instrucción.
En el ejemplo, la interfaz de cliente se denomina "Productionline"; ver "AUTOHOTSPOT".
STEP 7 asigna entonces automáticamente los valores configurados en la interfaz de cliente
a los parámetros de la instrucción.
7. Haga clic en "Parámetros del bloque" y asigne variables manualmente a los parámetros
REQ, Busy, Done, Error, Status.
STEP 7 inserta la variable elegida en la llamada de la función.

Llamada de la instrucción
El código fuente siguiente muestra cómo emplear la instrucción
"OPC_UA_NamespaceGetIndexList" para consultar los índices de los espacios de nombres
que está utilizando actualmente el servidor OPC UA conectado.
Encontrará el programa completo en el capítulo "Programa de ejemplo para leer variables PLC
(Página 4307)".
El programa de ejemplo se divide en varias secciones (Cases) mediante una instrucción
CASE.

Programación del PLC
Manual de programación y manejo, 11/2019

4171

Instrucciones
4.1 Instrucciones
En la 2.ª sección del programa se consultan los índices de los espacios de nombres:
SCL
2: // case 2, get index for namespace
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_NamespaceGetIndexList_Instance(NamespaceUris :=
"Productionline_Configuration".Namespaces.NamespaceURIs,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
StatusList := "Productionline_Configuration".Namespaces.NamespaceStatusList,
NamespaceUrisCount := "Productionline_Configuration".Namespaces.NamespaceCount,
Timeout := "Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
REQ := #Req,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
IF "Productionline_Configuration".Namespaces.NamespaceStatusList[0] = 0 THEN
#State := #State + 1;
ELSE
#State := 100;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at NamespaceGetIndexList';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REG of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_NamespaceGetIndexList_Instance(NamespaceUris :=
"Productionline_Configuration".Namespaces.NamespaceURIs,
StatusList := "Productionline_Configuration".Namespaces.NamespaceStatusList,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
REQ := FALSE);
END_IF;

El programa de ejemplo llama la instrucción "OPC_UA_NamespaceGetIndexList" por los
siguientes motivos:
● Para consultar el índice de un espacio de nombres.
● Para poner el parámetro REQ al valor "FALSE" en caso de error.
Ejecución asíncrona
La instrucción "OPC_UA_NamespaceGetIndexList" se ejecuta asíncronamente respecto al
programa de usuario y necesita varios ciclos de programa.

4172

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El estado actual de la ejecución se controla con los parámetros "Busy", "Done", "Error" y
"Status".
La ejecución asíncrona del programa se describe en el capítulo "Diferencia entre las
instrucciones que funcionan síncronamente y las que funcionan asíncronamente
(Página 618)".

Explicación de la llamada de la instrucción
En la figura superior se ilustra el caso 2. Esta sección del programa consulta los índices de los
espacios de nombres.
Si la variable #State tiene el valor 2, se ejecutará el caso 2.
Si la instrucción "OPC_UA_NamespaceGetIndexList" aún no se ejecuta, #Busy es igual a
FALSE y la variable "#Req" se pone a TRUE. Con ello se inicia la instrucción. En el siguiente
ciclo, #Req tiene el valor FALSE.
Si el parámetro de salida "Error" tiene el valor TRUE, se ha producido un error al ejecutar la
instrucción. Entonces la variable #State adopta el valor 100. Este caso está previsto para el
tratamiento de errores.
Si el parámetro de salida "Done" tiene el valor TRUE, la instrucción se ha ejecutado
correctamente. Si el proceso ha concluido correctamente, el valor de la variable "#State"
aumenta en uno. De este modo, en el siguiente ciclo se ejecuta la siguiente sección del
programa (caso 3: recoger controladores (handles) para accesos de lectura y escritura).
El caso 3 se describe en OPC_UA_NodeGetHandleList: recoger controladores para accesos
de lectura y escritura (Página 4173).
Nota
Ejecución de la instrucción
Es posible que la instrucción se ejecute correctamente (parámetro "Error" desactivado,
parámetro "Done" activado), pero que no se pueda devolver ningún índice para un espacio de
nombres determinado.
Por eso, en el ejemplo se comprueba además si se ha encontrado un índice para el espacio de
nombres consultado. Si se ha encontrado un índice, el primer elemento del array al que señala
el parámetro "StatusList" tiene el valor 0.

Consulte también
OPC_UA_TranslatePathList: Determinar los ID de nodo actuales (Página 4186)

OPC_UA_NodeGetHandleList: recoger controladores para accesos de lectura y escritura
Validez
La siguiente descripción de la instrucción "OPC_UA_NodeGetHandleList" se aplica a las CPU
S7-1500 con versión de firmware V2.6 y superior.

Programación del PLC
Manual de programación y manejo, 11/2019

4173

Instrucciones
4.1 Instrucciones

Descripción
Con la instrucción "OPC_UA_NodeGetHandleList" se registran variables PLC en un servidor
OPC UA.
La figura siguiente muestra el símbolo de la instrucción en el editor (FUP).

En la figura superior, los parámetros de la instrucción todavía no reciben valores.
La instrucción "OPC_UA_NodeGetHandleList" sirve para preparar el intercambio de datos con
un servidor OPC UA; véase ① en el siguiente gráfico:
Con esta instrucción se registran en el servidor las variables PLC que se desee leer o escribir.
De este modo se optimiza el acceso posterior con las instrucciones "OPC_UA_ReadList" y
"OPC_UA_WriteList".
La instrucción devuelve una lista de referencias numéricas (controladores) para las variables
PLC registradas.





23&B8$B'LVFRQQHFW

23&B8$B&RQQHFW
23&B8$B1DPHVSDFH*HW,QGH[/LVW
23&B8$B1RGH*HW+DQGOH/LVW

23&B8$B5HDG/LVW
23&B8$B:ULWH/LVW

①
②
③

4174

23&B8$B1RGH5HOHDVH+DQGOH/LVW

Instrucciones para preparar las operaciones de lectura y escritura
Instrucciones de lectura y escritura
Instrucciones para liberar recursos una vez ejecutadas las operaciones de lectura o escritura

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros de "OPC_UA_NodeGetHandleList"
Tabla 4-74

Los parámetros de la instrucción "OPC_UA_NodeGetHandleList"

Parámetro

Declara‐
ción en el
área

Tipo de
datos

Significado

REQ

Input

BOOL

Un flanco ascendente 0 → 1 en el parámetro
dispara la ejecución de la instrucción.

ConnectionHdl

Input

DWORD

Identificación unívoca de una conexión esta‐
blecida.
El controlador (handle) se obtiene con la ins‐
trucción AUTOHOTSPOT.

NodeIDCount

Input

UINT

Número de elementos en el parámetro No‐
deIDs

NodeIDs

InOut

VARIANT

Puntero hacia un array con elementos de tipo
AUTOHOTSPOT.
El array contiene los NodeIds de las variables
para las que el servidor OPC UA debe propor‐
cionar referencias numéricas (controladores o
handles) (consulte más arriba Función del blo‐
que).

Timeout

Input

TIME

Intervalo de tiempo máximo en milisegundos
para la ejecución de la instrucción.
Consulte también la explicación de este pará‐
metro enAUTOHOTSPOT.

NamespaceIndexCount

Input

UINT

Número de elementos en el parámetro "Na‐
mespaceIndexes".

NamespaceIndexes

InOut

VARIANT

Puntero a un array del tipo UINT.
Este parámetro no es necesario si no hay nin‐
gún elemento en el parámetro NamespaceIn‐
dexCount (NamespaceIndexCount = 0)..
El array se utiliza para que en el parámetro No‐
deIDs se asignen índices nuevos a los índices
del espacio de nombres.
Ejemplo:
Si en NamespaceIndexes[4] figura el valor 10,
a todos los ID de nodo del parámetro "No‐
deIDs" que hasta entonces tenían el índice de
espacio de nombres 4 se les asignará el índice
de espacio de nombres 10.

Programación del PLC
Manual de programación y manejo, 11/2019

4175

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción en el
área

Tipo de
datos

Significado

NodeStatusList

InOut

VARIANT

Puntero a un array del tipo DWORD.
El array contiene los códigos de error de los
NodeIds de las diferentes variables; consulte
más abajo "Números de error de NodeStatus‐
List".
Para cada NodeId se indica si se le ha podido
asignar un controlador (handle).
Puede ocurrir que el bloque de función se haya
ejecutado correctamente (parámetro Error de‐
sactivado), pero que no se haya podido encon‐
trar ningún controlador (handle) para un No‐
deId (variable) determinado.
Un NodeId consta de un índice de espacio de
nombres, un nombre de variable (identificador)
y un tipo de identificador. Consulte
OPC_UA_NodeID.

NodeHdls

InOut

VARIANT

Puntero a un array del tipo DWORD.
El array contiene los controladores (handles)
de cada uno de los NodeIds que han sido so‐
licitados por el servidor OPC UA (consulte más
arriba Función del bloque).

Done

Output

BOOL

Estado de ejecución:
● 0: Ejecución de la instrucción interrumpida,
no finalizada o no iniciada.
● 1: Ejecución de la instrucción finalizada sin
errores

Busy

Output

BOOL

Parámetro sobre el estado de la ejecución:
● 0: La instrucción no se está ejecutando
● 1: Instrucción ejecutándose en estos
momentos

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error. Consulte el
parámetro "Status".

Status

Output

DWORD

Causa del error, consulte más abajo "Números
de error de Status"

Números de error de Status
El parámetro "Status" informa sobre errores que pueden producirse durante la ejecución de la
instrucción.

4176

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En la tabla siguiente encontrará una relación de códigos de error para esta instrucción:
Código de error

Nombre del error

Explicación

0000_0000

OpcUa_Good

Instrucción finalizada correctamente

8003_0000

OpcUa_BadOutOfMemory

No hay memoria disponible para el cliente
OPC UA.

(valores hexadeci‐
males)

Como el cliente OPC UA y el servidor OPC
UA comparten un área de memoria es nece‐
sario reducir la memoria necesaria del servi‐
dor.
Para ello, existen las siguientes posibilidades:
● Liberar menos variables PLC para OPC
UA.
● Reducir el número de clientes OPC UA
conectados actualmente con el servidor.
● Crear menos suscripciones.
8009_0000

OpcUa_BadUnknownResponse

El servidor ha enviado una respuesta que no
se ha podido detectar.

800A_0000

OpcUa_BadTimeout

Se ha producido un timeout de red.
Posibles causas:
● La conexión al servidor OPC UA es
demasiado lenta (muy poca capacidad).
● La red está sobrecargada.
● El servidor OPC UA no está disponible
Posibles soluciones:
● Compruebe la URL del servidor OPC UA
● Aumente el intervalo de tiempo de timeout
(mayor valor para el parámetro Timeout
del bloque de función
OPC_UA_Connect).

800D_0000

OpcUa_BadServerNotConnec‐
ted

El servidor no está conectado o el controlador
(handle) de la conexión es incorrecto o no es
válido.

8010_0000

OpcUa_BadTooManyOpera‐
tions

Se ha excedido el número de instrucciones
"OPC_UA_NodeGetHandleList" que pueden
llamarse simultáneamente por conexión (>
1); consulte: AUTOHOTSPOT

8033_0000

OpcUa_BadNodeIdInvalid

La sintaxis del nodo no es válida.

8034_0000

OpcUa_BadNodeIdUnknown

El ID de nodo (NodeId) hace referencia a un
nodo no existente en el espacio de direccio‐
nes del servidor.

Programación del PLC
Manual de programación y manejo, 11/2019

4177

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

BadConnectionClosed

La conexión con el ConnectionHdl correspon‐
diente está en el estado "ShutDown" (desco‐
nectada). La conexión/sesión no se ha podi‐
do "reactivar" automáticamente. Causa posi‐
ble: sesión en el servidor borrada (p. ej., por
reinicio o timeout).

(valores hexadeci‐
males)
80AE_0000

En este caso, la conexión se debe cerrar ex‐
plícitamente con la instrucción
"OPC_UA_Disconnect" para volver a liberar
los recursos de conexión. El ConnectionHdl
para esta conexión que ha dejado de ser vá‐
lida debe restablecerse en el programa de
usuario.
Finalmente, debe establecerse una nueva co‐
nexión con el servidor (ver instrucción
"OPC_UA_Connect").

4178

80AF_0000

BadInvalidState

La conexión con el ConnectionHdl correspon‐
diente está en el estado "ConnectinError"
(error temporal de conexión, conexión inte‐
rrumpida). La CPU intenta "reactivar" la co‐
nexión. Si esto no se logra durante el interva‐
lo de timeout ajustado (OPC UA Session Ti‐
meout), la conexión pasa al estado "Shut‐
down". Requisitos para el cambio de estado:
La CPU ha podido acceder al servidor OPC
UA para comprobar si la sesión todavía está
presente o no.

B080_0100

Simatic_BadType_VariantInput1 Tipo de datos incorrecto para el parámetro
"NodeIDs".

B080_0200

Simatic_BadType_VariantInput2 Tipo de datos incorrecto para el parámetro
"NamenspaceIndexes".

B080_0300

Simatic_BadType_VariantInput3 Tipo de datos incorrecto para el parámetro
"NodeStatusList".

B080_0400

Simatic_BadType_VariantInput4 Tipo de datos incorrecto para el parámetro
"NodeHdls".

B080_1100

Simatic_ArrayElements_Too‐
Many

NodeIDCount > MAX_ELEMENTS_NODE‐
LIST

B080_3100

BadNumElements_VariantIn‐
put1

NodeIDCount > número de elementos del
array del parámetro "NodeIDs".

B080_3200

BadNumElements_VariantIn‐
put2

NamespaceIndexCount > número de elemen‐
tos del array del parámetro "NamespaceInde‐
xes".

B080_3300

BadNumElements_VariantIn‐
put3

NodeIDCount > número de elementos del
array del parámetro "NodeStatusList".

B080_3400

BadNumElements_VariantIn‐
put4

NodeIDCount > número de elementos del
array del parámetro "NodeHdls".

B080_C400

Simatic_ClientNotEnabled

El cliente OPC UA está desactivado.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

B080_C500

Simatic_NothingToDo

No hay que hacer nada: La instrucción utiliza
una lista que no contiene ningún elemento.

C080_C300

Simatic_OutOfResources

Se ha excedido el número máximo de instruc‐
ciones de cliente que pueden utilizarse simul‐
táneamente.

(valores hexadeci‐
males)

Posibles soluciones:
● Reduzca el número de instrucciones de
cliente paralelas de este tipo; consulte:
AUTOHOTSPOT
Encontrará más códigos de error en AUTOHOTSPOT

Números de error de "NodeStatusList"
El parámetro "NodeStatusList" contiene un código de error para cada NodeId (variable).
La tabla siguiente explica los códigos de error:
Código de error

Nombre del error

Explicación

OpcUa_Good

Se ha encontrado la variable PLC (No‐
deId).

(valores hexadeci‐
males)
0000_0000

El Handle de la variable se ha registrado en
el Array al que señala el parámetro "No‐
deHdls".
8033_0000

OpcUa_BadNodeIdInvalid

La sintaxis del NodeId no es correcta.

8034_0000

OpcUa_BadNodeIdUnknown

El NodeId hace referencia a un nodo (una
variable) que no existe en el servidor OPC
UA.

A000_0309

PLCopenUA_Bad_OutOfHandles

El NodeId no se ha registrado porque se ha
alcanzado el número máximo de nodos
(PLCOPEN_MAXREGISTEREDNODES).

Encontrará más códigos de error en AUTOHOTSPOT

Cómo utilizar esta instrucción
En este capítulo se explica, a partir de un ejemplo, cómo se emplea la instrucción
"OPC_UA_NodeGetHandleList" en un programa que intercambia datos con un servidor OPC
UA.

Programación del PLC
Manual de programación y manejo, 11/2019

4179

Instrucciones
4.1 Instrucciones

Requisitos
En la siguiente descripción se presupone lo siguiente:
● Se ha creado una interfaz de cliente; consulte "AUTOHOTSPOT".
● Se ha parametrizado una conexión a un servidor OPC UA en las propiedades de esta
interfaz de cliente; consulte "AUTOHOTSPOT".
Asimismo, para la instrucción "OPC_UA_NodeGetHandleList" deben cumplirse los siguientes
requisitos:
● Existe un controlador para una conexión a un servidor OPC UA.
El controlador (handle) de la conexión se obtiene con la instrucción AUTOHOTSPOT.
● Índices de los espacios de nombres en los que se encuentran las variables que se desea
leer o escribir con el cliente.
Los índices se obtienen con la instrucción AUTOHOTSPOT

Función de la instrucción
Para optimizar los accesos a variables, OPC UA proporciona el servicio "RegisterNodes" para
accesos repetidos.
Ese servicio permite preparar servidores para el acceso optimizado a variables. La instrucción
"OPC_UA_NodeGetHandleList" llama este servicio implícitamente para preparar el servidor
para los accesos optimizados (en el lenguaje de OPC UA "Registered Read/Write").
Por eso, con la llamada de la instrucción "OPC_UA_NodeGetHandleList" se obtienen
referencias numéricas (controladores) del servidor OPC UA. Estos controladores o handles se
utilizan en las instrucciones "OPC_UA_ReadList" o "OPC_UA_WriteList", lo que equivale a un
acceso optimizado con "Registered Read/Write".
¿Qué información es necesaria?
Para solicitar las referencias numéricas (controladores o "handles"), la instrucción necesita los
datos siguientes:
● Una lista con las variables que van a leerse o activarse (parámetro "NodeIDs"; consulte el
tipo de datos de sistema "AUTOHOTSPOT").
Esta lista contiene los datos siguientes de cada variable:
– Índice del espacio de nombres en el que se encuentra la variable
– Identificador de la variable (nombre de la variable)
– Tipo de identificador

4180

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
¿Qué información devuelve la instrucción?
La instrucción proporciona los datos siguientes:
● Una lista de controladores para las variables ("NodeHdls").
El orden de los controladores (handles) se corresponde con el orden de las variables en el
parámetro NodeIDs.
● Una lista de mensajes de error (parámetro "NodeStatusList").
Cada mensaje de error de esta lista hace referencia a la correspondiente variable del
parámetro NodeIDs.
Para cada variable hay que comprobar si el servidor OPC UA ha podido devolver un
controlador para dicha variable.

Cómo utilizar una interfaz de cliente
1. En el área "Árbol del proyecto", seleccione la CPU que actúa como cliente.
2. En la carpeta "Bloques de programa", seleccione el bloque de función que debe contener
la instrucción del cliente.
En el ejemplo, el bloque de función se denomina "ReadFromProductionline".
Lenguaje seleccionado: SCL.
3. Arrastre la instrucción "OPC_UA_NodeGetHandleList" desde la carpeta "Instrucciones >
Comunicación > OPC UA > Cliente OPC UA" hasta el editor con la función Drag & Drop.
4. Seleccione la llamada como multiinstancia.
STEP 7 crea una instancia de esta instrucción y la denomina
"OPC_UA_NodeGetHandleList_Instance".
5. Haga clic en el símbolo de "Iniciar configuración" junto a la instrucción
"OPC_UA_NodeGetHandleList_Instance".
STEP 7 abre la ficha "Configuración" de la ventana de inspección.
6. En "Seleccionar interfaz del cliente para la interfaz OPC UA", elija la interfaz de cliente que
desee emplear con la instrucción.
En el ejemplo se selecciona la interfaz de cliente "Productionline" que se ha creado para la
instalación de ejemplo.
7. Haga clic en "Acceso a datos" y elija una lista de lectura.
En el ejemplo: lista de lectura "ReadListProduct".
STEP 7 asigna entonces automáticamente los valores configurados en la interfaz de cliente
a los parámetros de la instrucción.
8. Haga clic en "Parámetros del bloque" y asigne variables manualmente a los parámetros
REQ, Busy, Done, Error, Status.
STEP 7 inserta la variable seleccionada en la llamada de la función.

Llamada de la instrucción (primera llamada)
Encontrará el programa completo en el capítulo "AUTOHOTSPOT".
El programa de ejemplo utiliza la lista de lectura "ReadListProduct" que contiene las siguientes
variables PLC:
● NewProduct
● ProductNumber

Programación del PLC
Manual de programación y manejo, 11/2019

4181

Instrucciones
4.1 Instrucciones
Para estas variables, el programa recibe referencias numéricas (controladores) del servidor.
El programa de ejemplo se divide en varias secciones (Cases) mediante una instrucción
CASE.
En la 3.ª sección del programa se consultan los controladores (handles) para los nodos que
deben leerse o escribirse (variables PLC):
SCL
3: // case 3, get handles for nodes
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_NodeGetHandleList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeIDCount :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeCount,
NodeIDs := "Productionline_Configuration".ReadLists."ReadListProduct".Nodes,
Timeout := "Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NamespaceIndexCount := "Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
NodeStatusList := "Productionline_Data"."ReadListProduct".NodeStatusList,
NodeHdls := "Productionline_Configuration".ReadLists."ReadListProduct".NodeHdls,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);

Ejecución asíncrona
La instrucción "OPC_UA_NodeGetHandleList" se ejecuta asíncronamente respecto al
programa de usuario y necesita varios ciclos de programa.
El estado actual de la ejecución se controla con los parámetros "Busy", "Done", "Error" y
"Status".
La ejecución asíncrona del programa se describe en el capítulo "Diferencia entre las
instrucciones que funcionan síncronamente y las que funcionan asíncronamente
(Página 618)".

Explicación de la llamada de la instrucción (primera llamada)
La sección del programa que se muestra en la figura superior llama la instrucción
"OPC_UA_NodeGetHandleList" para consultar controladores (handles) para variables PLC.
Si la instrucción aún no se ejecuta, #Busy es igual a FALSE, de modo que la variable "#Req"
adopta el valor TRUE. Con ello se inicia la instrucción. En el siguiente ciclo, #Req tiene el valor
FALSE.

4182

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Llamada de la instrucción (tratamiento de errores)
La figura siguiente ilustra la evaluación de los parámetros "Done" y "Error".
SCL
IF #Done = TRUE THEN
IF "Productionline_Data"."ReadListProduct".NodeStatusList[0] = 0 AND
"Productionline_Data"."ReadListProduct".NodeStatusList[1] = 0
THEN
#State := #State + 1;
ELSE
#State := 100;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at NodeGetHandleList';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#OPC_UA_NodeGetHandleList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeIDCount :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeCount,
NodeIDs := "Productionline_Configuration".ReadLists."ReadListProduct".Nodes,
Timeout := "Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NamespaceIndexCount := "Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
NodeStatusList := "Productionline_Data"."ReadListProduct".NodeStatusList,
NodeHdls := "Productionline_Configuration".ReadLists."ReadListProduct".NodeHdls);
END_IF;

Explicación de la llamada de la instrucción (tratamiento de errores)
En caso de error, el valor del parámetro de salida "Error" adopta el valor TRUE. Con ello, el
valor de la variable "#State" adopta el valor 100. Este caso está previsto para el tratamiento de
errores. Además, el programa de ejemplo llama la instrucción "OPC_UA_NodeGetHandleList"
para poner el parámetro REQ a FALSE.
Si el parámetro de salida "Done" tiene el valor TRUE, la instrucción se ha ejecutado
correctamente.
Atención: Es posible que la instrucción se haya ejecutado correctamente (parámetro "Error"
desactivado, parámetro "Done" activado), pero que no se haya podido devolver ningún
controlador (handle) para una variable PLC determinada.
Por este motivo, en el programa de ejemplo se comprueba si se devuelve un controlador
(handle) para cada variable PLC.
● Si se recibe un controlador (handle) para la primera variable, el primer elemento del array
al que señala el parámetro "NodeStatusList" tiene el valor 0.
● Si se recibe un controlador (handle) para la segunda variable, el segundo elemento del
array al que señala el parámetro "NodeStatusList" tiene el valor 0.

Programación del PLC
Manual de programación y manejo, 11/2019

4183

Instrucciones
4.1 Instrucciones
Si se cumplen ambas condiciones, el parámetro de salida "NodeHdls" señala a una lista válida
con los controladores (handles) para las variables PLC registradas.
El valor de la variable "#State" aumenta en uno. De este modo, en el siguiente ciclo se ejecuta
la siguiente sección del programa (caso 4).
El caso 4 se describe en OPC_UA_ReadList (Página 4201).
Nota
Si se registran muchas variables con OPC_UA_NodeGetHandleList en la aplicación, puede
ser conveniente incrementar siempre #State en uno cuando #Done = TRUE. Al utilizar los
valores consultados, compruebe si son válidos.

Sugerencia: Implementar la programación general del tratamiento de errores
Para que el programa de ejemplo (llamada de la instrucción (tratamiento de errores)) sea más
clara y fácil de comprender, solo se consultan los handles (controladores) de dos variables
PLC y se controla si se ha devuelto un handle para cada variable. Este tipo de consulta es
realmente poco flexible.
Si desea consultar los handles de más de dos variables PLC en su programa o si desea que
su programa sea independiente del número de variables PLC, debería utilizar el código de
programa siguiente en un bucle para evaluar "NodeStatusList":
IF #Done = TRUE THEN
FOR #i := 0 TO
UINT_TO_INT("Productionline_Configuration".ReadLists."ReadListProduc
t".NodeCount) - 1 DO
IF NOT
("Productionline_Data"."ReadListProduct".NodeStatusList[#i] = 0)
THEN
#Output_Error_Message := CONCAT_WSTRING(IN1 :=
WSTRING#'Error at NodeGetHandleList, Index: ',
IN2 := INT_TO_WSTRING(#i));
END_IF;
END_FOR;
#State := #State + 1;
END_IF;

¿Para qué sirve el parámetro "NamespacesIndexes"?
El parámetro "NamespaceIndexes" sirve para convertir los índices de los espacios de
nombres.
La conversión de los índices es necesaria, por ejemplo, cuando en el programa de usuario se
leen los identificadores (identifier) de nodos de una lista externa, por ejemplo, de un archivo
XML OPC UA exportado.
En este caso, es necesario agregar a todos los identificadores de la lista el índice que utiliza
actualmente el servidor OPC UA para el espacio de nombres.
Además, los índices de los espacios de nombres pueden cambiar, de forma que la lista debe
adaptarse en cada ocasión.

4184

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Modificación automática de los índices
Puede hacer que los índices de los espacios de nombres se conviertan automáticamente: Para
ello, utilice los parámetros "NamespaceIndexes" y "NamespacesIndexCount" de la instrucción
"OPC_UA_NodeGetHandleList".
Proceda del siguiente modo:
1. Compruebe el espacio de nombres que está asignado a los NodeIds que se leen de una
lista.
En el ejemplo se asigna el índice de espacio de nombres 0 a los NodeIds.
En el ejemplo, los NodeIds se encuentran en el espacio de nombres Siemens "http://
www.siemens.com/simatic-s7-opcua".
2. Cree un array del tipo "WString".
En el ejemplo, el array se denomina "myNamespaces".
3. Introduzca el espacio de nombres de Siemens "http://www.siemens.com/simatic-s7opcua" en "myNamespaces[0]" (es decir, en el elemento de array 0).
4. Asigne los valores del nuevo array "myNamespaces" al parámetro "NamespaceUris".
La instrucción devuelve el resultado (el índice actual) en el parámetro
"NamespaceIndexes".
5. Cree un array del tipo "UInt" para el resultado.
En el ejemplo, el array se denomina "myNamespaceIndexes".
6. Asigne los valores del nuevo array "myNamespaceIndexes" al parámetro
"NamespaceIndexes".
7. Asigne también este array "myNamespaceIndexes" al parámetro "NamespacesIndexes"
de la instrucción "OPC_UA_NodeGetIndexList".
A continuación, esta instrucción lee en "myNamespaceIndexes[0]" el índice actual del
espacio de nombres de Siemens y lo utiliza (en lugar del índice original 0 del espacio de
nombres). Con ello se ha convertido el índice.
8. Asigne el valor 1 al parámetro "NamespacesIndexCount" de la instrucción
"OPC_UA_NodeGetIndexList" (en el ejemplo se utiliza un solo espacio de nombres).
El siguiente código de programa muestra cómo se ha realizado el ejemplo:
SCL
#OPC_UA_NodeGetHandleList_Instance(REQ := #Req,
ConnectionHdl := #ConnectionHdl,
NodeIDCount := 2,
NodeIDs := #TargetNodeIds,
Timeout := T#6S,
NamespaceIndexCount := 1,
NamespaceIndexes := #myNamespaceIndexes,
NodeStatusList := #NodeStatusList,
NodeHdls := #NodeHdls,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);

Programación del PLC
Manual de programación y manejo, 11/2019

4185

Instrucciones
4.1 Instrucciones
Los parámetros "NamespaceIndexes" y "NamespaceIndexCount" son opcionales
Si no es necesario convertir el índice, no se tienen que asignar valores a los parámetros
"NamespaceIndexes" y "NamespaceIndexCount".
La conversión del índice no es necesaria cuando las NodeIds se indican directamente con el
espacio de nombres correcto, p. ej. cuando las NodeIds se determinan con la instrucción
"OPC_UA_TranslatePathList".

Consulte también
OPC_UA_TranslatePathList: Determinar los ID de nodo actuales (Página 4186)
Instrucciones OPC UA para programas de cliente (Página 4151)
OPC_UA_ConnectionGetStatus: leer estado de la conexión (Página 4249)

OPC_UA_TranslatePathList: Determinar los ID de nodo actuales
Validez
La siguiente descripción de la instrucción "OPC_UA_TranslatePathList" se aplica a las CPU
S7-1500 con versión de firmware V2.6 y superior.

Descripción
La instrucción "OPC_UA_TranslatePathList" permite navegar por el espacio de direcciones de
un servidor OPC UA y determinar los ID de nodo (NodeId) que utiliza el servidor OPC UA para
dicho nodo.
La instrucción se utiliza en casos en los que se conocen los BrowseNames y las rutas de los
nodos, pero no los NodeIds, por lo que pueden ser distintos entre servidor y servidor.
Básicamente se aplica lo siguiente: se inicia la navegación en un nodo cuyo NodeId se conoce.
Son conocidos, p. ej., los nodos del espacio de nombres "http:\\opcfoundation.org/UA/" de la
OPC Foundation.
Ejemplo de un nodo de inicio: "Objects". Otros posibles nodos de inicio son "DeviceSet" o un
nodo raíz inferior del modelo de información que se utiliza en el espacio de direcciones del
servidor, cuyo NodeId se ha determinado.
El nodo "Objekts" se utiliza en el ejemplo inferior. Partiendo de este nodo de inicio, se navega
de nodo a nodo utilizando los BrowseNames existentes hasta que se llega finalmente al nodo
de destino. En el nodo de destino se lee el NodeId que se estaba buscando (atributo "NodeID").
Ejemplo
Un servidor OPC UA de un dispositivo publica una interfaz de servidor que cumple la
Companion Specification AutoID. La Companion Specification define los BrowseNames de
nodos OPC UA. De este modo se conocen los BrowseNames de estos nodos. Sin embargo,
no se sabe qué NodeIds utiliza para esos nodos el servidor OPC UA que debe consultarse. En
este caso se utiliza la instrucción "OPC_UA_TranslatePathList".

4186

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Alternativa
STEP 7 (TIA Portal) ofrece una alternativa al uso de la instrucción
"OPC_UA_TranslatePathList". En STEP 7, en "Árbol del proyecto > [Nombre de CPU] >
Comunicación OPC UA", se puede crear una interfaz de cliente y configurar listas de escritura,
lectura o de métodos. STEP 7 determina entonces automáticamente los NodeIds de los nodos.
Sin embargo, esta alternativa requiere acceso online al servidor OPC UA del dispositivo o el
uso del archivo XML OPC UA del dispositivo.
Símbolo de la instrucción
La figura siguiente muestra el símbolo de la instrucción en el editor (FUP).

En la figura superior, los parámetros de la instrucción todavía no reciben valores.
OPC_UA_TranslatePathList sirve para preparar el intercambio de datos; véase ① en el
siguiente gráfico.
Para ello, deben proporcionarse las rutas de navegación a la instrucción; la instrucción
devuelve los NodeIds de los nodos buscados.
23&B8$B&RQQHFW






23&B8$B'LVFRQQHFW

23&B8$B1DPHVSDFH*HW,QGH[/LVW
23&B8$B7UDQVODWH3DWK/LVW
23&B8$B1RGH*HW+DQGOH/LVW

①
②
③

23&B8$B5HDG/LVW
23&B8$B:ULWH/LVW

23&B8$B1RGH5HOHDVH+DQGOH/LVW

Instrucciones para preparar las operaciones de lectura y escritura
Instrucciones de lectura y escritura
Instrucciones para liberar recursos una vez ejecutadas las operaciones de lectura o escritura

Programación del PLC
Manual de programación y manejo, 11/2019

4187

Instrucciones
4.1 Instrucciones

Parámetros de "OPC_UA_TranslatePathList"
Tabla 4-75

Los parámetros de la instrucción "OPC_UA_TranslatePathList"

Parámetro

Declara‐
ción en el
área

Tipo de
datos

Significado

REQ

Input

BOOL

Un flanco ascendente 0 → 1 en el parámetro dispara
la ejecución de la instrucción.

ConnectionHdl

Input

DWORD

Identificación unívoca de una conexión establecida.
El controlador (handle) se obtiene con la instrucción
AUTOHOTSPOT.

BrowsePathsCount

Input

UINT

Número de elementos en BrowsePaths (máx. 10).

BrowsePaths

InOut

VARIANT

Puntero a un array del tipo AUTOHOTSPOT.
El array contiene las distintas rutas de navegación
que deben seguirse.

Timeout

Input

TIME

Intervalo de tiempo máximo en milisegundos para la
ejecución de la instrucción.
Consulte también la explicación de este parámetro
en AUTOHOTSPOT.

NamespaceIndex‐
Count

Input

UINT

Número de elementos en NamespaceIndexes

NamespaceIndexes

InOut

VARIANT

Puntero a un array del tipo UINT.
Este parámetro se ignora cuando NamespaceIndex‐
Count es 0.
El array sirve para convertir los índices de los espa‐
cios de nombres que se transfieren en el parámetro
BrowsePaths.
Ejemplo:
Si en NamespaceIndexes[4] figura el valor 10, a to‐
dos los NodeIds del parámetro "BrowsePaths" que
hasta entonces tenían el índice de espacio de nom‐
bres 4 se les asignará el índice de espacio de nom‐
bres 10.

TargetNodeIDs

InOut

VARIANT

Puntero a un array del tipo AUTOHOTSPOT
El array contiene los ID de nodo (NodeIds) determi‐
nados.

TargetStatusList

InOut

VARIANT

Puntero a un array del tipo DWORD.
El array contiene los números de error de las dife‐
rentes rutas de navegación.
El primer elemento del array hace referencia al pri‐
mer elemento del parámetro BrowsePaths, y así su‐
cesivamente; consulte más abajo "Números de error
de TargetStatusList".

Done

Output

BOOL

Estado de ejecución:
● 0: Ejecución de la instrucción interrumpida, no
finalizada o no iniciada.
● 1: Ejecución de la instrucción finalizada sin
errores

4188

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción en el
área

Tipo de
datos

Significado

Busy

Output

BOOL

Parámetro sobre el estado de la ejecución:
● 0: La instrucción no se está ejecutando
● 1: Instrucción ejecutándose en estos momentos

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error. Consulte el
parámetro "Status".

Status

Output

DWORD

Causa del error, consulte más abajo "Números de
error de Status"

Parámetro "NamespacesIndexes"
El parámetro "NamespaceIndexes" para convertir el índice del espacio de nombres es
opcional.
● Si se utiliza este parámetro ("NamespaceIndexCount" > 0), se convierten los índices del
espacio de nombres del parámetro "BrowsePaths" (en referencias, BrowseNames y nodos
de inicio).
● Si este parámetro no se utiliza como en el ejemplo inferior ("NamespaceIndexCount" = 0),
los índices del espacio de nombres del parámetro "BrowsePaths" deben estar ajustados
correctamente desde el principio. De esta forma, la instrucción
"OPC_UA_TranslatePathList" no evalúa el parámetro "NamespaceIndexes". Si en el
próximo paso se llama la instrucción "OPC_UA_NodeGetHandleList", tampoco podrán
convertirse los índices de espacios de nombres, pues ya están actualizados. Por
consiguiente, ajuste el parámetro "NamespaceIndexCount" de la instrucción
"OPC_UA_NodeGetHandleList" a 0. De este modo no será necesario suministrar valores al
parámetro "NamespaceIndexes".

Números de error de Status
El parámetro "Status" informa sobre errores que pueden producirse durante la ejecución de la
instrucción.
En la tabla siguiente encontrará una relación de códigos de error para esta instrucción:
Código de error

Nombre del error

Explicación

0000_0000

OpcUa_Good

Instrucción finalizada correctamente

8002_0000

OpcUa_BadInternalError

Se ha producido un error debido a un
error de programación interno del
bloque de función.

(valores hexadecima‐
les)

Diríjase al soporte técnico.

Programación del PLC
Manual de programación y manejo, 11/2019

4189

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

OpcUa_BadOutOfMemory

No hay memoria disponible para el
cliente OPC UA.

(valores hexadecima‐
les)
8003_0000

Como el cliente OPC UA y el servi‐
dor OPC UA comparten un área de
memoria conviene reducir la memo‐
ria necesaria del servidor.
Para ello, existen las siguientes po‐
sibilidades:
● Liberar menos variables PLC
para OPC UA
● Reducir el número de clientes
OPC UA conectados
actualmente al servidor
● Crear menos suscripciones
8009_0000

OpcUa_BadUnknownResponse

El servidor no ha respondido con el
número esperado de resultados

800A_0000

OpcUa_BadTimeout

Se ha producido un timeout de red.
Posibles causas:
● La conexión al servidor OPC UA
es demasiado lenta (muy poca
capacidad).
● La red está sobrecargada.
● El servidor OPC UA no está
disponible
Posibles soluciones:
● Compruebe la URL del servidor
OPC UA
● Aumente el intervalo de tiempo
de timeout (mayor valor para el
parámetro Timeout del bloque
de función OPC_UA_Connect).

4190

800D_0000

OpcUa_BadServerNotConnected

El servidor no está conectado o el
controlador (handle) de la conexión
es incorrecto o no es válido.

800F_0000

OpcUa_BadNothingToDo

No hay que hacer nada: el servidor
OPC UA recibe una lista vacía sin
instrucciones del cliente OPC UA.

8010_0000

OpcUa_BadTooManyOperations

Se ha excedido el número de ins‐
trucciones "OPC_UA_Translate‐
PathList" que pueden llamarse si‐
multáneamente por conexión
(> 1); consulte: AUTOHOTSPOT

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

BadConnectionClosed

La conexión con el ConnectionHdl
correspondiente está en el estado
"ShutDown" (desconectada). La co‐
nexión/sesión no se ha podido "reac‐
tivar" automáticamente. Causa posi‐
ble: sesión en el servidor borrada
(p. ej., por reinicio o timeout).

(valores hexadecima‐
les)
80AE_0000

En este caso, la conexión se debe
cerrar explícitamente con la instruc‐
ción "OPC_UA_Disconnect" para
volver a liberar los recursos de co‐
nexión. El ConnectionHdl para esta
conexión que ha dejado de ser váli‐
da debe restablecerse en el progra‐
ma de usuario.
Finalmente, debe establecerse una
nueva conexión con el servidor (ver
instrucción "OPC_UA_Connect").
80AF_0000

BadInvalidState

La conexión con el ConnectionHdl
correspondiente está en el estado
"ConnectinError" (error temporal de
conexión, conexión interrumpida).
La CPU intenta "reactivar" la cone‐
xión. Si esto no se logra durante el
intervalo de timeout ajustado (OPC
UA Session Timeout), la conexión
pasa al estado "Shutdown". Requisi‐
tos para el cambio de estado: La
CPU ha podido acceder al servidor
OPC UA para comprobar si la sesión
todavía está presente o no.

B080_0100

Simatic_BadType_VariantInput1

Tipo de datos incorrecto para el pa‐
rámetro "BrowsePaths".

B080_0200

Simatic_BadType_VariantInput2

Tipo de datos incorrecto para el pa‐
rámetro "NamespaceIndexes".

B080_0300

Simatic_BadType_VariantInput3

Tipo de datos incorrecto para el pa‐
rámetro "TargetNodeIDs".

B080_0400

Simatic_BadType_VariantInput4

Tipo de datos incorrecto para el pa‐
rámetro "TargetStatusList".

B080_1100

Simatic_ArrayElements_TooMany

BrowsePathscount > MAX_ELE‐
MENTS_RELATIVEPATH

B080_3100

BadNumElements_VariantInput1

BrowsePathsCount > número de ele‐
mentos del array del parámetro
"BrowsePaths".

B080_3200

BadNumElements_VariantInput2

NamespaceIndexCount > número
de elementos del array del paráme‐
tro "NamspaceIndexes".

B080_3300

BadNumElements_VariantInput3

BrowsePathsCount > número de ele‐
mentos del array del parámetro "Tar‐
getNodeIDs".

Programación del PLC
Manual de programación y manejo, 11/2019

4191

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

B080_3400

BadNumElements_VariantInput4

BrowsePathsCount > número de ele‐
mentos del array del parámetro "Tar‐
getStatusList".

B080_C400

Simatic_ClientNotEnabled

El cliente OPC UA está desactivado.

B080_C500

Simatic_NothingToDo

No hay que hacer nada: no se han
asignado valores al parámetro
"BrowsePathsCount" o "Browse‐
PathsCount" = 0.

B080_C600

Simatic_ClientNotAvailable

Error al inicializar el cliente

C080_C300

Simatic_OutOfResources

Se ha excedido el número máximo
de instrucciones de cliente que pue‐
den utilizarse simultáneamente.

(valores hexadecima‐
les)

Posibles soluciones:
● Reduzca el número de llamadas
de cliente paralelas de este tipo;
consulte:AUTOHOTSPOT
Encontrará más códigos de error en AUTOHOTSPOT

Números de error de "TargetStatusList"
El parámetro "TargetStatusList" contiene un código de error para cada NodeId (variable).
La tabla siguiente explica los códigos de error:
Código de
error

Nombre del error

Explicación

0000_0000

OpcUa_Good

Valor leído correctamente

8033_0000

OpcUa_BadNodeIdInvalid

La sintaxis del NodeId no es correcta.

8034_0000

OpcUa_BadNodeUnknown

El controlador de nodo transferido se des‐
conoce.

8035_0000

OpcUa_BadAttributeInvalid

El atributo solicitado no se permite con el
nodo indicado.

8037_0000

OpcUa_BadIndexRangeNoD

No hay datos en el área del índice.

8039_0000

OpcUa_BadDataEncodingUnsupported

El servidor OPC UA no soporta la desco‐
dificación de datos solicitada para este
nodo.

803A_0000

OpcUa_BadNotReadable

Faltan derechos de lectura o de suscrip‐
ción (Subscribing) de este nodo.

803C_0000

OpcUa_BadOutOfRange

El valor del índice, indicado en el paráme‐
tro NodeAddInfos, está fuera del rango
admisible.

803D_0000

OpcUa_BadNotSupported

El servidor OPC UA no soporta una de las
funciones solicitadas. Algunos servidores
OPC UA no permiten acceder a áreas de
índices de un array.

(valores hexa‐
decimales)

4192

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error

Nombre del error

Explicación

8060_0000

OpcUa_BadBrowseNameInvalid

El NamespaceIndex del QualifiedName
no existe

806F_0000

OpcUa_BadNoMatch

La ruta indicada no conduce a ningún no‐
do.

(valores hexa‐
decimales)

Encontrará más códigos de error en AUTOHOTSPOT

Cómo utilizar esta instrucción
En este capítulo se explica, a partir de un ejemplo, cómo se emplea la instrucción
"OPC_UA_TranslatePathList" en un programa.
Ejemplo
Supongamos una instalación que emplea lectores RFID para detectar la mercancía que sale
por las puertas.
En el ejemplo, el primer lector se denomina "RfidReader_Door_1".
Los lectores RFID son servidores OPC UA que proporcionan sus datos y métodos a clientes
OPC UA.
Especificación AutoID
Los lectores RFID están dotados de una interfaz estandarizada de acuerdo con la Companion
Specification "AutoID".
La estandarización establece los nombres de las propiedades y los métodos de los lectores
RFID.
La figura siguiente muestra un fragmento del espacio de direcciones del lector
"FfidReaderDoor_1" en UAExpert, una herramienta de Unified Automation.
Dentro de "DeviceSet" se encuentra el nodo "RfidReader_Door_1".
A su vez, en dicho nodo se encuentran las propiedades y los métodos del lector habilitados
según AutoId:

Programación del PLC
Manual de programación y manejo, 11/2019

4193

Instrucciones
4.1 Instrucciones

Las propiedades y los métodos del lector son conocidos porque el lector cumple la
especificación AutoID.
No se conocen los siguientes elementos:
● el nombre "RfidReader_Door_1". El nombre puede elegirse libremente o estar especificado
en la instalación respectiva.
● El NodeId del nodo "RfidReader_Door_1" en el espacio de direcciones del lector
● Los NodeIds de las propiedades y los métodos del lector, es decir, de todos los nodos
ubicados bajo "RfidReader_Door_1"; ver la figura superior.

4194

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Procedimiento para determinar NodeIds
● Trabajar con una interfaz de cliente y configurar una lista de lectura, de escritura o de
métodos mediante la función de Arrastrar y colocar.
Para ello se accede online al servidor OPC UA o se utiliza el archivo XML OPC UA del
servidor, que contiene los NodeIds de las variables buscadas. STEP 7 (TIA Portal)
determina entonces automáticamente los ID de nodo de la variable.
No es necesario llamar la instrucción "OPC_UA_TranslatePathList".
● Utilizar una herramienta como UAExpert:
– Lea el NodeId de "RfidReader_Door_1".
– Lea los NodeIds de todas las propiedades y métodos contenidos en este lector que
desee utilizar en el programa de usuario.
El siguiente paso en el programa será la llamada de "OPC_UA_NodeGetHandleList".
● Uso de la instrucción "OPC_UA_TranslatePathList".
Para esta instrucción se define en primer lugar la ruta de navegación (BrowsePath). La ruta
puede comenzar en el nodo "Objects", pero también en cualquier otro nodo cuyo NodeId
sea conocido.
El nodo "Objects" siempre tiene asignado el NodeId "i=85" (según la especificación OPC
UA). El siguiente ejemplo utiliza una BrowsePath (ruta de búsqueda) que parte del nodo
"Objects". Una vez se han determinado los NodeIds de las variables buscadas con
"OPC_UA_TranslatePathList", utilice los NodeIds en el paso siguiente, en la llamada de la
instrucción "OPC_UA_NodeGetHandleList".

Introducción al ejemplo de programa
El ejemplo de programa siguiente muestra cómo determinar los NodeIds de dos variables con
la instrucción "OPC_UA_TranslatePathList".
Las variables buscadas en el ejemplo son "DeviceInfo" y "DeviceStatus", la ruta utilizada
(BrowsePath) comienza en el nodo "Objects" (NodeId: i=85) y conduce a las variables
buscadas pasando por "productionline", "DataBlocksGlobal" y "RfidReader_Door_1"; véase la
figura siguiente.

Programación del PLC
Manual de programación y manejo, 11/2019

4195

Instrucciones
4.1 Instrucciones

Requisitos
Para la instrucción "OPC_UA_TranslatePathList" deben cumplirse los siguientes requisitos:
● Existe un controlador para una conexión a un servidor OPC UA.
El controlador (handle) de la conexión se obtiene con la instrucción AUTOHOTSPOT.
Para configurar una conexión con un servidor OPC UA se puede utilizar la configuración de
conexiones para OPC UA del TIA Portal.
Si no utiliza esta configuración de conexiones, tendrá que definir los parámetros de
conexión en el programa de usuario. El procedimiento se describe en el apartado
"Establecer una conexión con un servidor OPC UA" que figura más adelante en esta
descripción.

Llamada de la instrucción (primera llamada)
Este capítulo describe el bloque de función "Read_from_RfidReader_Door_1". El bloque de
función muestra cómo utilizar la instrucción "OPC_UA_TranslatePathList".
Encontrará el ejemplo completo en el capítulo "AUTOHOTSPOT".
Declaración de las variables
Declare una instancia de la instrucción "OPC_UA_TranslatePathList" y las variables con las
que se suministren valores a los parámetros de la instrucción.
El ejemplo de programa utiliza la declaración siguiente:

Programa de usuario
El fragmento siguiente del programa de usuario define la ruta de navegación de la variable PLC
"DeviceInfo". No se representa la definición de "DeviceStatus".
Primero se define el nodo de inicio (StartingNode) desde el cual la ruta conduce al nodo
buscado. A continuación se especifica la ruta al nodo buscado (RelativePath).
La primera ruta de navegación (BrowsePaths[0]) empieza en el nodo "Objects" (NodeId i=85)
y conduce hasta la variable buscada "DeviceInfo" pasando por "productionline",
"DataBlocksGlobal" y "RfidReader_Door_1".
Definir nodos de inicio
El siguiente programa de usuario pone el nodo de inicio en "Objects".
El nodo "Objects" ha sido definido por la OPC Foundation en el espacio de nombres "http://
opcfoundation.org/UA/". Este espacio de nombres tiene asignado siempre el índice 0 en el
array Namespace de un servidor OPC UA.
Los servidores OPC UA publican este array Namespace en su espacio de direcciones para
que los clientes OPC UA puedan utilizar el índice en lugar del espacio de direcciones para
direccionar un nodo.
El nodo "Objects" tiene el NodeId "i=85" con el índice de espacio de nombres 0 (el índice de
espacio de nombres 0 no se indica con el fin de simplificar el NodeId).

4196

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El NodeId "i=85" también indica el tipo de identificador: este NodeId es un identificador
numérico (un entero).
Las siguientes líneas del programa transfieren el identificador "85", determinan el tipo de
identificador y establecen el índice de espacio de nombres:
#BrowsePaths[0].StartingNode.Identifier := WString#'85';
#BrowsePaths[0].StartingNode.IdentifierType := 0;
#BrowsePaths[0].StartingNode.NamespaceIndex := 0;
Definir RelativePath
En el siguiente ejemplo de programa, la primera etapa de la navegación lleva hasta el nodo con
el BrowseName "productionline".
La navegación prosigue hasta los nodos con los BrowseNames "DataBlocksGlobal",
"RfidReader_Door_1" y, finalmente, hasta "DeviceInfo".
En el ejemplo de programa, todos estos nodos están en el espacio de nombres "http://
www.siemens.com/simatic-s7-opcua". El índice de este espacio de nombres está depositado
en la variable local "#NamespaceIndexes[0]" y se activa directamente en el código del
programa.
Referencias en OPC UA
El espacio de direcciones de un servidor OPC UA consta de nodos OPC UA que remiten unos
a otros. Estas relaciones de un nodo con otros nodos se denominan referencias. OPC UA
define varios tipos de referencias.
El siguiente ejemplo de programa utiliza la referencia jerárquica para determinar los NodeIds
de nodos OPC UA que están situados debajo de otro nodo OPC UA.

Programación del PLC
Manual de programación y manejo, 11/2019

4197

Instrucciones
4.1 Instrucciones
Referencia utilizada en el ejemplo: el nodo con el BrowseName "DeviceInfo" está situado
debajo de "RfidReader_Door_1". Esto significa que ambos nodos están relacionados entre sí
jerárquicamente.
SCL
//Sets the first BrowsePath, BrowsePath[0]
//This BrowsePath starts at node "Objects" and leads to node "DeviceInfo"
//First, we assign "Objects" to "StartingNode".
//"Objects" has always NodeId i=85. It is a numerical NodeId with namespaceindex 0.
#BrowsePaths[0].StartingNode.Identifier := WString#'85';
#BrowsePaths[0].StartingNode.IdentifierType := 0;
#BrowsePaths[0].StartingNode.NamespaceIndex := 0;
//Second, we set "RelativePath".
//Our BrowsePath goes to "productionline", "DataBlocksGlobal", "RfidReader_Door_1",
//and finally to "DeviceInfo".
//Therefore, we set "NoOfElements" to four elements.
#BrowsePaths[0].RelativePath.NoOfElements := 4;
//The first element of our RelativePath is "productionline'.
//Therefore, we set "TargetName.Name" to "productionline'
//In our example code, the namespaceindex of "productionline' is stored
//in our local variable "#NamespaceIndexes[0]";
//The node "productionline' is conntected to our starting node
//"Objects" via a HierarchicalReference.
//This reference always has the numerical NodeId i=33 assigned to it, with namespaceindex 0.
//This reference is set by default.
//Therefore, you can skip the following three lines of code.
#BrowsePaths[0].RelativePath.Elements[1].ReferenceTypeId.Identifier := WString#'33';
#BrowsePaths[0].RelativePath.Elements[1].ReferenceTypeId.IdentifierType := 0;
#BrowsePaths[0].RelativePath.Elements[1].ReferenceTypeId.NamespaceIndex := 0;
#BrowsePaths[0].RelativePath.Elements[1].TargetName.Name := WString#'productionline';
#BrowsePaths[0].RelativePath.Elements[1].TargetName.NamespaceIndex :=
#NamespaceIndexes[0];
//The second element of our RelativePath is "DataBlocksGlobal'.
#BrowsePaths[0].RelativePath.Elements[2].TargetName.Name := WString#'DataBlocksGlobal';
#BrowsePaths[0].RelativePath.Elements[2].TargetName.NamespaceIndex :=
#NamespaceIndexes[0];
//The third element of our RelativePath is "RfidReader_Door_1'.
#BrowsePaths[0].RelativePath.Elements[3].TargetName.Name := WString#'RfidReader_Door_1';
#BrowsePaths[0].RelativePath.Elements[3].TargetName.NamespaceIndex :=
#NamespaceIndexes[0];
//The fourth element of our RelativePath is "DeviceInfo'.
#BrowsePaths[0].RelativePath.Elements[4].TargetName.Name := WString#'DeviceInfo';
#BrowsePaths[0].RelativePath.Elements[4].TargetName.NamespaceIndex :=
#NamespaceIndexes[0];

Establecer una conexión con un servidor OPC UA
El siguiente extracto del programa de ejemplo muestra cómo configurar manualmente (en el
programa) una conexión con un servidor OPC UA sin utilizar la configuración de la conexión
disponible en STEP 7 (TIA Portal).

4198

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para ello, el programa SCL asigna los valores correspondientes a los parámetros.
El ejemplo de programa define en primer lugar el ServerEndpoint "opc.tcp://192.168.1.1:4840"
porque el protocolo "opc.tcp" se utiliza en OPC UA y el servidor tiene la dirección IP
"192.168.1.1".
El modo de seguridad "2" (SecurityMsgMode) se activa, de forma que los mensajes se envían
firmados. Como procedimiento para la firma (SecurityPolicy) se activa el valor
"Basic128Rsa15". También se indica el número del certificado de cliente (CerificateID). En el
ejemplo se utiliza el número 6.
SCL
CASE #State OF
1: // case 1, connect to server
IF #FirstCall = TRUE THEN
#FirstCall := FALSE;
//set ServerEndPointUrl of the server we want to connect to
#SeverEndpointUrl := WString#'opc.tcp://192.168.1.1:4840';
//set Securtiy Message Mode
// 1 = None, 2 = Sign, 3 = Sign & Encrypt
#SessionConnectInfo.SecurityMsgMode := 1;
//set Security Policy
// 1 = None, 2 = Basic128Rsa15,, 3 = Basic256, 4 = Basic256Sha256
#SessionConnectInfo.SecurityPolicy := 2;
//set the number of the client certificate you are using
//in our case, this is 6
//#SessionConnectInfo.CertificateID := 6;
END_IF;
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Connect_Instance(REQ:=#Req,
ConnectionHdl=>#ConnectionHdl,
ServerEndpointUrl:=#SeverEndpointUrl,
SessionConnectInfo:=#SessionConnectInfo,
Timeout:=T#8S,
Done=>#Done,
Busy=>#Busy,
Error=>#Error,
Status=>#Status);

Determinar los NodeIds de los nodos DeviceInfo y DeviceStatus
El fragmento siguiente del programa de ejemplo "Read_From_RfidReader_Door_1" consulta
al servidor OPC UA los NodeIds de los nodos con BrowseName "DeviceInfo" y "DeviceStatus".

Programación del PLC
Manual de programación y manejo, 11/2019

4199

Instrucciones
4.1 Instrucciones
Encontrará el ejemplo completo en el capítulo "AUTOHOTSPOT".
SCL
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_TranslatePathList_Instance(REQ := #Req,
ConnectionHdl := #ConnectionHdl),
BrowsePathsCount := 2,
BrowsePaths := #BrowsePaths,
Timeout := T#6S,
NamespaceIndexCount := 0,
TargetNodeIDs := #TagetNodeIds,
TargetStatusList := #TargetStatusList,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
IF #TargetStatusList[0] = 0 AND #TargetStatusList[1] = 0 THEN
#State := #State + 1;
ELSE
#State := 100;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at TranslatePathList';
END_IF;
#FirstCall := TRUE;
END_IF;
IF #Error = TRUE THEN
//In case 100, to set REQ of instruction "OPC_UA_TranslatePathList" to FALSE
#Set_REQ_To_FALSE := TRUE;
#State := 100;
#Mem_Status := #Status;
#OPC_UA_TranslatePathList_Instance(REQ := FALSE,
ConnectionHdl := #ConnectionHdl,
BrowsePathsCount := 2,
BrowsePaths := #BrowsePaths,
TargetNodeIDs := #TagetNodeIds,
TargetStatusList := #TargetStatusList);
#FirstCall := TRUE;
END_IF;

El programa de ejemplo llama la instrucción "OPC_UA_TranslatePathList" por los siguientes
motivos:
● Para consultar el NodeId de los nodos con BrowseName "DeviceInfo" y "DeviceStatus".
● para ajustar el parámetro REQ a FALSE si se ha producido un error.
Ejecución asíncrona
La instrucción "OPC_UA_TranslatePathList" se ejecuta asíncronamente respecto al programa
de usuario y necesita varios ciclos de programa.
El estado actual de la ejecución se controla con los parámetros "Busy", "Done", "Error" y
"Status".

4200

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La ejecución asíncrona del programa se describe en el capítulo "Diferencia entre las
instrucciones que funcionan síncronamente y las que funcionan asíncronamente
(Página 618)".

Explicación sobre la determinación de los NodeIds
Si la instrucción "OPC_UA_TranslatePathList" no se está ejecutando todavía, #Busy es igual
a FALSE, de modo que la variable "#Req " toma el valor TRUE. Con ello se inicia la instrucción.
En el siguiente ciclo, #Req tiene el valor FALSE.
Si el parámetro de salida "Error" tiene el valor TRUE, se ha producido un error al ejecutar la
instrucción. Entonces la variable "#State" adopta el valor 100. Este caso está previsto para el
tratamiento de errores.
Si el parámetro de salida "Done" tiene el valor TRUE, la instrucción se ha ejecutado
correctamente.
Atención: Es posible que la instrucción se haya ejecutado correctamente (parámetro "Error"
desactivado, parámetro "Done" activado), pero que no se haya podido devolver ningún NodeId
para una variable PLC.
Por este motivo, en el ejemplo se comprueba si el programa ha recibido un NodeId para cada
variable PLC:
● Si se recibe un NodeId para la primera variable, el primer elemento del array al que señala
el parámetro "TargetStatusList" tiene el valor 0.
● Si se recibe un NodeId para la segunda variable, el segundo elemento del array al que
señala el parámetro "TargetStatusList" tiene el valor 0.
Si se cumplen ambas condiciones, el parámetro de salida "TargetNodeHdls" señala a una lista
válida con los NodeIds. Con ello el valor de la variable "#State" aumenta en uno. A
continuación, en el siguiente ciclo se ejecuta la siguiente sección del programa (caso 4).
El caso 4 se describe en AUTOHOTSPOT.

Consulte también
OPC_UA_ConnectionGetStatus: leer estado de la conexión (Página 4249)

Intercambio de datos
OPC_UA_ReadList: leer variables
Validez
La siguiente descripción de la instrucción "OPC_UA_ReadList" se aplica a las CPU S7-1500
con versión de firmware V2.6 y superior.

Descripción
La instrucción "OPC_UA_ReadList" permite leer los valores de las variables PLC.

Programación del PLC
Manual de programación y manejo, 11/2019

4201

Instrucciones
4.1 Instrucciones
La figura siguiente muestra el símbolo de la instrucción en el editor (FUP).

En la figura superior, los parámetros de la instrucción todavía no reciben valores.
La instrucción "OPC_UA_ReadList" sirve para leer variables de un servidor OPC UA; véase ②
en el siguiente gráfico.
La instrucción devuelve una lista con los valores de variables.
Además de los valores de variables pueden leerse también otros atributos de las variables.
Esto se especifica mediante el AttributeID; consulte AUTOHOTSPOT.





23&B8$B'LVFRQQHFW

23&B8$B&RQQHFW
23&B8$B1DPHVSDFH*HW,QGH[/LVW
23&B8$B1RGH*HW+DQGOH/LVW

23&B8$B5HDG/LVW
23&B8$B:ULWH/LVW

①
②
③

4202

23&B8$B1RGH5HOHDVH+DQGOH/LVW

Instrucciones para preparar las operaciones de lectura y escritura
Instrucciones de lectura y escritura
Instrucciones para liberar recursos una vez ejecutadas las operaciones de lectura o escritura

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros de "OPC_UA_ReadList"
Tabla 4-76

Los parámetros de la instrucción "OPC_UA_ReadList"

Parámetro

Declaración

Tipo de datos

Significado

REQ

Input

BOOL

Un flanco ascendente 0 → 1 en el pará‐
metro dispara la ejecución de la instruc‐
ción.

ConnectionHdl

Input

DWORD

Identificación unívoca de una conexión
establecida.
El controlador (handle) se obtiene con la
instrucción AUTOHOTSPOT.

NodeHdlCount

Input

UINT

Número de elementos en el array al que
apunta el parámetro NodeHdls.

NodeHdls

InOut

VARIANT

Puntero a un array del tipo DWORD.
El array contiene los controladores de no‐
dos (Node-Handles) de las variables cu‐
yos valores se quieren leer.

NodeAddInfos

InOut

VARIANT

Puntero a un array del tipo AUTOHOTS‐
POT o AUTOHOTSPOT.
El array determina cuál es el atributo que
va a leerse en el nodo (en una variable).
El primer elemento de dicho array hace
referencia al primer elemento del array al
que apunta el parámetro "NodeHdls".
Este parámetro es opcional. Si no existe,
se leerá el valor de todos los nodos (va‐
riables).
Al leer arrays existe la posibilidad de res‐
tringir los elementos del array que deben
leerse, consulte Lectura del área de array
con OPC_UA_ReadList (Página 4212).

Timeout

Input

TIME

Intervalo de tiempo máximo en milisegun‐
dos para la ejecución de la instrucción.
Consulte también la explicación de este
parámetro enAUTOHOTSPOT.

NodeStatusList

InOut

VARIANT

Puntero a un array del tipo DWORD.
El array contiene los códigos de error de
las diferentes variables (consulte más
abajo "Números de error de NodeStatus‐
List").
Para cada variable se indica si ha sido
posible leer su valor.
Puede ocurrir que la instrucción se haya
ejecutado correctamente (parámetro
Error no activado), pero que no se haya
podido leer ningún valor para un NodeId
(variable) determinado.

Programación del PLC
Manual de programación y manejo, 11/2019

4203

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Significado

TimeStamps

InOut

VARIANT

Puntero a un array del tipo LDT.
El primer elemento de este array hace re‐
ferencia al primer elemento del array al
que apunta el parámetro NodeHdls.
El parámetro es opcional. Si no existe, el
servidor OPC no devuelve ningún sello de
tiempo.

Variable

InOut

VARIANT

Puntero hacia una variable que contiene
los valores que deben leerse.
Para esta variable hay que crear un tipo
de datos PLC (UDT) o una estructura
(STRUCT).

Done

Output

BOOL

Estado de ejecución:
● 0: Ejecución de la instrucción
interrumpida, no finalizada o no
iniciada.
● 1: Ejecución de la instrucción
finalizada sin errores

Busy

Output

BOOL

Parámetro sobre el estado de la ejecu‐
ción:
● 0: La instrucción no se está ejecutando
● 1: Instrucción ejecutándose en estos
momentos

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error. Consulte
el parámetro "Status".

Status

Output

DWORD

Causa del error, consulte más abajo "Nú‐
meros de error de Status"

Números de error de Status
El parámetro "Status" informa sobre errores producidos durante la ejecución de la instrucción.

4204

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En la tabla siguiente encontrará una relación de códigos de error para esta instrucción:
Código de error

Nombre del error

Explicación

0000_0000

OpcUa_Good

Bloque de función ejecutado correcta‐
mente

8003_0000

OpcUa_BadOutOfMemory

No hay memoria disponible para el clien‐
te OPC UA.

(valores hexa‐
decimales)

Como el cliente OPC UA y el servidor
OPC UA comparten un área de memoria
es necesario reducir la memoria nece‐
saria del servidor.
Para ello, existen las siguientes posibili‐
dades:
● Liberar menos variables PLC para
OPC UA.
● Reducir el número de clientes OPC
UA conectados actualmente con el
servidor.
● Crear menos suscripciones.
8009_0000

OpcUa_BadUnknownResponse

El servidor no ha respondido con el nú‐
mero esperado de resultados

800A_0000

OpcUa_BadTimeout

Se ha producido un timeout de red.
Posibles causas:
● La conexión al servidor OPC UA es
demasiado lenta (muy poca
capacidad).
● La red está sobrecargada.
● El servidor OPC UA no está
disponible
Posibles soluciones:
● Compruebe la URL del servidor OPC
UA
● Aumente el intervalo de tiempo de
timeout (mayor valor para el
parámetro Timeout del bloque de
función OPC_UA_Connect).

800D_0000

OpcUa_BadServerNotConnected

El servidor no está conectado o el con‐
trolador (handle) de la conexión es inco‐
rrecto o no es válido.

800F_0000

OpcUa_BadNothingToDo

No hay que hacer nada: el servidor OPC
UA recibe una lista vacía sin instruccio‐
nes del cliente OPC UA.

8010_0000

OpcUa_BadTooManyOperations

Se ha excedido el número de instruccio‐
nes "OPC_UA_ReadList" que pueden
llamarse simultáneamente por conexión
(> 5); consulte: AUTOHOTSPOT

Programación del PLC
Manual de programación y manejo, 11/2019

4205

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

8074_0000

OpcUa_BadTypeMismatch

Se utiliza un tipo de datos que no con‐
cuerda con el tipo de datos en el servi‐
dor.

80AE_0000

BadConnectionClosed

La conexión con el ConnectionHdl co‐
rrespondiente está en el estado "Shut‐
Down" (desconectada). La conexión/
sesión no se ha podido "reactivar" auto‐
máticamente. Causa posible: sesión en
el servidor borrada (p. ej., por reinicio o
timeout).

(valores hexa‐
decimales)

En este caso, la conexión se debe cerrar
explícitamente con la instrucción
"OPC_UA_Disconnect" para volver a li‐
berar los recursos de conexión. El Con‐
nectionHdl para esta conexión que ha
dejado de ser válida debe restablecerse
en el programa de usuario.
Finalmente, debe establecerse una nue‐
va conexión con el servidor (ver instruc‐
ción "OPC_UA_Connect").
80AF_0000

BadInvalidState

La conexión con el ConnectionHdl co‐
rrespondiente está en el estado "Con‐
nectinError" (error temporal de cone‐
xión, conexión interrumpida). La CPU in‐
tenta "reactivar" la conexión. Si esto no
se logra durante el intervalo de timeout
ajustado (OPC UA Session Timeout), la
conexión pasa al estado "Shutdown".
Requisitos para el cambio de estado: La
CPU ha podido acceder al servidor OPC
UA para comprobar si la sesión todavía
está presente o no.

B080_0100

Simatic_BadType_VariantInput1

Tipo de datos incorrecto para el paráme‐
tro "NodeHdls".

B080_0200

Simatic_BadType_VariantInput2

Tipo de datos incorrecto para el paráme‐
tro "NodeAddInfos".

B080_0300

Simatic_BadType_VariantInput3

Tipo de datos incorrecto para el paráme‐
tro "NodeStatusList".

B080_0400

Simatic_BadType_VariantInput4

Tipo de datos incorrecto para el paráme‐
tro "TimeStamps".

B080_0500

Simatic_BadType_VariantInput5

Tipo de datos incorrecto para el paráme‐
tro "Variable" (no UDT).

B080_1100

Simatic_ArrayElements_TooMany

NodeHdlCount > MAX_ELE‐
MENTS_NODELIST
NamespaceIndexCount > MAX_ELE‐
MENTS_NAMESPACES

B080_3100

4206

BadNumElements_VariantInput1

El parámetro "NodeHdlCount" es mayor
que el número de elementos del array en
el parámetro "NodeHdls".

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

B080_3200

BadNumElements_VariantInput2

El parámetro "NodeHdlCount" es mayor
que el número de elementos del array en
el parámetro "NodeAddInfos".

B080_3300

BadNumElements_VariantInput3

El parámetro "NodeHdlCount" es mayor
que el número de elementos del array en
el parámetro "NodeStatusList".

B080_3400

BadNumElements_VariantInput4

El parámetro "NodeHdlCount" es mayor
que el número de elementos del array en
el parámetro "TimeStamps".

B080_C400

Simatic_ClientNotEnabled

El cliente OPC UA está desactivado.

B080_C500

Simatic_NothingToDo

No hay que hacer nada: La instrucción
utiliza una lista que no contiene ningún
elemento.

C080_C300

Simatic_OutOfResources

Se ha excedido el número máximo de
instrucciones de cliente que pueden uti‐
lizarse simultáneamente.

(valores hexa‐
decimales)

Posibles soluciones:
● Reduzca el número de instrucciones
de cliente paralelas de este tipo;
consulte:
AUTOHOTSPOT
Encontrará más códigos de error en AUTOHOTSPOT.

Números de error de "NodeStatusList"
El parámetro "NodeStatusList" contiene un código de error para cada controlador de nodo
(variable).
La tabla siguiente explica los códigos de error:
Código de
error

Nombre del error

Explicación

0000_0000

OpcUa_Good

Valor leído correctamente

8034_0000

OpcUa_BadNodeIdUnknown

El controlador de nodo transferi‐
do se desconoce.

8035_0000

OpcUa_BadAttributeInvalid

El atributo solicitado no se per‐
mite con el nodo indicado.

8037_0000

OpcUa_BadIndexRangeNoD

No hay datos en el rango de ín‐
dices.

8039_0000

OpcUa_BadDataEncodingUnsupported

El servidor OPC UA no soporta
la descodificación de datos soli‐
citada para este nodo.

(valores hexa‐
decimales)

Programación del PLC
Manual de programación y manejo, 11/2019

4207

Instrucciones
4.1 Instrucciones
Código de
error

Nombre del error

Explicación

OpcUa_BadTypeMismatch

El valor Double/Float en Rea‐
dResponse es NaN

(valores hexa‐
decimales)
8074_0000

El tipo de la variable UDT Mem‐
ber es incorrecto
803A_0000

OpcUa_BadNotReadable

Faltan derechos de lectura o de
suscripción (Subscribing) de es‐
te nodo.

803C_0000

OpcUa_BadOutOfRange

El valor del índice, indicado en el
parámetro NodeAddInfos, está
fuera del rango admisible.

803D_0000

OpcUa_BadNotSupported

El servidor OPC UA no soporta
una de las funciones solicitadas.
Algunos servidores OPC UA no
permiten acceder a áreas de ín‐
dices de un array.

80AB_0000

OpcUa_BadInvalidArgument

StartIndex > EndIndex

Encontrará más códigos de error en AUTOHOTSPOT

Cómo utilizar esta instrucción
En este capítulo se explica, a partir de un ejemplo de programa, cómo se emplea la instrucción
"OPC_UA_ReadList" en un programa de usuario que lee valores de variables PLC.

Requisitos
En la siguiente descripción se presupone lo siguiente:
● Se ha creado una interfaz de cliente; consulte "AUTOHOTSPOT".
● Se ha creado y parametrizado una conexión a un servidor OPC UA; consulte
"AUTOHOTSPOT".
Asimismo, para la instrucción "OPC_UA_ReadList" deben cumplirse los siguientes requisitos:
● Existe un controlador para una conexión a un servidor OPC UA.
El controlador de la conexión se obtiene con la instrucción: AUTOHOTSPOT.
● Una lista de los controladores para cada una de las variables cuyos valores se desee leer
desde el servidor OPC UA.
Esta lista de controladores se obtiene con la instrucción: AUTOHOTSPOT.

Función de la instrucción
La instrucción "OPC_UA_ReadList" se utiliza p. ej. para leer los valores de variables desde un
servidor OPC UA (ver arriba).

4208

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
¿Qué información es necesaria?
La instrucción necesita los datos siguientes:
● Los controladores para las variables cuyos valores desea leer (parámetro "NodeHdls").
¿Qué información devuelve la instrucción?
La instrucción proporciona los datos siguientes:
● Los valores actuales de las variables (parámetro "Variable").
El orden de los valores se corresponde con el orden de los controladores en el parámetro
"NodeHdls".
Tenga en cuenta para ello los siguientes casos:
– Si utiliza una interfaz de cliente con una lista de lectura, STEP 7 creará automáticamente
un tipo de datos de sistema con las variables que se van a leer.
– Si no utiliza ninguna interfaz de cliente, deberá crear un tipo de datos PLC (UDT) o una
estructura (STRUCT) para el parámetro "Variable".
Los componentes de este UDT se definen de acuerdo con las variables que se van a
leer.
Utilice el tipo de datos SIMATIC compatible con el tipo de datos OPC UA
correspondiente; ver AUTOHOTSPOT.
● Una lista de mensajes de error (parámetro "NodeStatusList").
Cada mensaje de error de esta lista hace referencia al controlador (handle)
correspondiente en el parámetro "NodeHdls", el ejemplo NodeStatusList[0] se refiere a
NodeHdls[0].
Para cada variable (cada "NodeHdl") hay que comprobar si el servidor OPC UA ha podido
devolver un valor válido.

Cómo utilizar una conexión parametrizada
1. En el área "Árbol del proyecto", seleccione la CPU que actúa como cliente.
2. En la carpeta "Bloques de programa", seleccione el bloque de función que debe contener
la instrucción del cliente.
En el ejemplo, el bloque de función se denomina "ReadFromProductionline".
Lenguaje seleccionado: SCL.
3. Arrastre la instrucción "OPC_UA_ReadList" desde la carpeta "Instrucciones >
Comunicación > OPC UA > Cliente OPC UA" hasta el editor con la función Drag & Drop.
4. Seleccione la llamada como multiinstancia.
STEP 7 crea una instancia de esta instrucción: "OPC_UA_ReadList_Instance".
5. Haga clic en el símbolo de "Iniciar configuración" junto a la instrucción
"OPC_UA_ReadList_Instance".
STEP 7 abre la ficha "Configuración" de la ventana de inspección.
6. En "Seleccionar interfaz del cliente para la interfaz OPC UA", elija la interfaz de cliente que
desee emplear con la instrucción.
En el ejemplo, la interfaz de cliente se denomina "Productionline".

Programación del PLC
Manual de programación y manejo, 11/2019

4209

Instrucciones
4.1 Instrucciones
7. Haga clic en "Acceso a datos" y elija una lista de lectura.
En el ejemplo, la lista de lectura se denomina "ReadListProduct".
STEP 7 asigna entonces automáticamente los valores configurados en la interfaz de cliente
a los parámetros de la instrucción.
8. Haga clic en "Parámetros del bloque" y asigne variables manualmente a los parámetros
REQ, Busy, Done, Error, Status.
STEP 7 inserta la variable seleccionada en la llamada de la función.

Llamada de la instrucción (primera llamada)
Encontrará el programa completo en el capítulo "AUTOHOTSPOT".
El programa de ejemplo utiliza la lista de lectura "ReadListProduct" que contiene las siguientes
variables PLC:
● NewProduct
● ProductNumber
El programa lee los valores de estas variables del servidor.
En el capítulo AUTOHOTSPOT se explica cómo crear una interfaz de cliente y agregarle una
lista de lectura con variables PLC.
El programa de ejemplo se divide en varias secciones (Cases) mediante una instrucción
CASE.
En la 4.ª sección del programa se leen los valores de variables:
SCL
4: // case 4, read from nodes
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
OPC_UA_ReadList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeCount,
NodeHdls := "Productionline_Configuration".ReadLists."ReadListProduct".NodeHdls,
Timeout := "Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList := "Productionline_Data"."ReadListProduct".NodeStatusList,
TimeStamps := "Productionline_Data"."ReadListProduct".TimeStamps,
Variable := "Productionline_Data"."ReadListProduct".Variable,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);

Ejecución asíncrona
La instrucción "OPC_UA_ReadList" se ejecuta asíncronamente respecto al programa de
usuario y necesita varios ciclos de programa.
El estado actual de la ejecución se controla con los parámetros "Busy", "Done", "Error" y
"Status".

4210

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La ejecución asíncrona del programa se describe en el capítulo "Diferencia entre las
instrucciones que funcionan síncronamente y las que funcionan asíncronamente
(Página 618)".

Explicación de la llamada de la instrucción (primera llamada)
En la figura superior se ilustra el caso 4.
Esta sección del programa llama la instrucción "OPC_UA_ReadList" para leer los valores de
las variables PLC.
Si la instrucción aún no se ejecuta, #Busy es igual a FALSE, de modo que la variable "#Req"
adopta el valor TRUE. Con ello se inicia la instrucción. En el siguiente ciclo, #Req tiene el valor
FALSE.

Llamada de la instrucción (tratamiento de errores)
La figura siguiente ilustra la evaluación de los parámetros "Done" y "Error".
SCL
IF #Done = TRUE THEN
FOR #i := 0 TO
UINT_TO_INT("Productionline_Configuration".ReadLists."ReadListProduct".NodeCount) - 1 DO
IF NOT ("Productionline_Data"."ReadListProduct".NodeStatusList[#i] = 0) THEN
#Output_Error_Message := CONCAT_WSTRING(IN1 := WSTRING#'Error at Readlist
"ReadListProduct", Index: ',
IN2 := INT_TO_WSTRING(#i));
END_IF;
END_FOR;
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REG of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_ReadList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeCount,
NodeHdls :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeHdls,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList := "Productionline_Data"."ReadListProduct".NodeStatusList,
TimeStamps := "Productionline_Data"."ReadListProduct".TimeStamps,
Variable := "Productionline_Data"."ReadListProduct".Variable);
END_IF;

Programación del PLC
Manual de programación y manejo, 11/2019

4211

Instrucciones
4.1 Instrucciones

Explicación de la llamada de la instrucción (tratamiento de errores)
En caso de error, el parámetro de salida "Error" adopta el valor TRUE. Con ello, el valor de la
variable "#State" adopta el valor 100. Este caso está previsto para el tratamiento de errores.
Además, el programa de ejemplo llama la instrucción "OPC_UA_ReadList" para ajustar el
parámetro REQ a FALSE.
Si el parámetro de salida "Done" tiene el valor TRUE, la instrucción se ha ejecutado
correctamente.
Atención: Es posible que la instrucción se haya ejecutado correctamente (parámetro "Error" no
activado, parámetro "Done" activado), pero que no se haya podido leer una variable PLC.
Por este motivo, en el ejemplo se comprueba para cada variable si el programa ha recibido un
valor válido:
● Si el servidor envía un valor válido para la primera variable PLC, el primer elemento del
array al que señala el parámetro "NodeStatusList" tiene el valor 0.
En el ejemplo, el código de estado figura en
"Productionline_Data"."ReadListProduct".NodeStatusList[0].
● Si el servidor envía un valor válido para la segunda variable PLC, el segundo elemento del
array al que señala el parámetro "NodeStatusList" tiene el valor 0.
En el ejemplo, el código de estado figura en
"Productionline_Data"."ReadListProduct".NodeStatusList[1].
El programa emite un mensaje de error si se ha detectado un valor no válido.
Aunque se han detectado uno o dos valores no válidos, el valor de la variable "#State" aumenta
en uno. De este modo, en el siguiente ciclo se ejecuta la siguiente sección del programa (caso
5).
El caso 5 se describe en OPC_UA_NodeReleaseHandleList: habilitar controladores para
accesos de lectura y escritura (Página 4234).

Consulte también
OPC_UA_TranslatePathList: Determinar los ID de nodo actuales (Página 4186)
Instrucciones OPC UA para programas de cliente (Página 4151)

Lectura del área de array con OPC_UA_ReadList
Introducción
Este capítulo se basa en el capítulo "OPC_UA_ReadList", ver OPC_UA_ReadList: leer
variables (Página 4201).
El capítulo describe cómo leer una sección de un array con la instrucción "OPC_UA_ReadList".
Básicamente, la lectura de una sección de un array de un servidor OPC UA funciona del
siguiente modo:

4212

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
23&8$6HUYHU

23&8$&OLHQW
>@

>@

>@

>@

>@

>@

>@
>@



>@

>@
>@
>@
>@
>@

①

La lectura de una sección de un array de un servidor OPC UA

Requisitos
En la siguiente descripción se presupone lo siguiente:
● Ha configurado una CPU como servidor OPC UA.
El servidor proporciona un array que pueden leer los clientes OPC UA.
En el ejemplo, la CPU que proporciona el bloque de datos "Data_for_OPC_UA_Clients"
para los clientes OPC_UA se denomina "Productionline":

● Ha configurado una CPU como cliente OPC UA.
Ha creado una interfaz de cliente en el cliente.
La interfaz de cliente contiene una lista de lectura con un array que se quiere leer
parcialmente.
En el ejemplo, la interfaz de cliente con la lista de lectura "ReadListProduct" se denomina
"Productionline":

En el array "Temperature" del servidor se leen los valores de "Temperature[5]" hasta
"Temperature[9]" .

Programación del PLC
Manual de programación y manejo, 11/2019

4213

Instrucciones
4.1 Instrucciones

Suministro de información adicional
El capítulo "OPC_UA_ReadList" explica cómo se leen escalares (variables con un valor) o
arrays (variables con varios valores) completos con la instrucción "OPC_UA_ReadList".
En la siguiente sección se amplían aspectos del capítulo "OPC_UA_ReadList" que son
necesarios para leer una sección de un array con "OPC_UA_ReadList".
OPC_UA_NodeAdditionalInfo
En primer lugar, cree una variable local del tipo "OPC_UA_NodeAdditionalInfo"; consulte
"OPC_UA_NodeAdditionalInfo (Página 4285)".
Esta variable sirve para comunicar a la instrucción "OPC_UA_ReadList" la sección del array
que se lee.

4214

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Proceda del siguiente modo:
1. Cree una variable de array del tipo "OPC_UA_NodeAdditionalInfo".
En el ejemplo se crea la variable en la sección de declaración del bloque de función que
llama la instrucción "OPC_UA_ReadList".
La nueva variable local se denomina "NodeAdditionalInformation":

La nueva variable local "NodeAdditionalInformation" incluye tres componentes del tipo
OPC_UA_AdditionalInfo, porque la lista de lectura "ReadListProduct" contiene tres nodos.
NodeAdditionalInformation[0] proporciona información adicional para la primera variable
que se va a leer (en el ejemplo, "NewProduct")
NodeAdditionalInformation[1] proporciona información adicional para la segunda variable
que se va a leer (en el ejemplo, "ProductNumber")
NodeAdditionalInformation[2] proporciona información adicional para la tercera variable
que se va a leer (en el ejemplo, "Temperature")
2. Asigne valores a las nuevas variables (en la columna "Valores predeterminados" de la
sección de declaración).
En el ejemplo se lee parte de la tercera variable (Temperature).
Por eso se asigna el valor 13 a NodeAdditionalInformation[2].AttributeId (es decir, se leen
los valores del array).
NodeAdditionalInformation[2].StartIndex recibe el valor 5, ya que se lee a partir del índice
5 (incluido).
NodeAdditionalInformation[2].EndIndex recibe el valor 9, ya que se lee hasta el índice 9
(incluido).
Para NodeAdditionalInformation[0] y NodeAdditionalInformation[1] se aplican valores
estándar.
La constante "#ignore" contiene el valor 4_294_967_295. El servidor ignora este valor para
StartIndex y EndIndex y lee por completo escalares y arrays.

Programación del PLC
Manual de programación y manejo, 11/2019

4215

Instrucciones
4.1 Instrucciones

Alternativa:
También es posible establecer los valores de NodeAdditionalInformation en el programa de
usuario:
// set additonal information to Array-Index 0
// we set default values here
#NodeAdditionalInformation[0].AttributeID := 13;
#NodeAdditionalInformation[0].StartIndex :=
4_294_967_295;
#NodeAdditionalInformation[0].EndIndex :=
4_294_967_295;
// set additonal information to Array-Index 1
// we set default values here
#NodeAdditonalInformation[1].AttributeID := 13;
#NodeAdditonalInformation[1].StartIndex :=
4_294_967_295;
#NodeAdditonalInformation[1].EndIndex := 4_294_967_295;
// set additonal information to Array-Index 2
// because we want to read only five values from an
array in the OPC UA server
#NodeAdditonalInformation[2].AttributeID := 13;
#NodeAdditonalInformation[2].StartIndex := 5;
#NodeAdditonalInformation[2].EndIndex := 9;
Nota:
El array NodeAdditionalInformation del tipo "OPC_UA_NodeAdditionalInfo" debe tener
tantos componentes como la lista de lectura (en el ejemplo 3).
3. Asigne NodeAdditionalInformation al parámetro "NodeAddInfos" de la instrucción
"OPC_UA_ReadList".
La figura siguiente muestra la llamada de OPC_UA_ReadList con los nuevos valores que
recibe el parámetro "NodeAddInfos":
#OPC_UA_ReadList_Instance(REQ := #Req,
NodeHdls :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeHdl
s,
NodeStatusList :=
"myProductionline_Data"."ReadListProduct".NodeStatusList,

4216

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Variable :=
"myProductionline_Data"."ReadListProduct".Variable,
ConnectionHdl :=
"Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeo
ut,
NodeHdlCount :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeCou
nt,
NodeAddInfos := #NodeAddtionalInformation,
TimeStamps :=
"myProductionline_Data".ReadListProduct.TimeStamps,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);

Resultado en el cliente
La instrucción "OP_UA_ReadList" ahora solo lee una sección del array "Temperature" del
servidor OPC UA.
La figura siguiente muestra el array "Temperature". El cliente asigna los valores leídos a partir
del índice 0:

Nota
Utilice el tipo de datos "OPC_UA_NodeAdditionalInfoExt" para leer una sección de un array
multidimensional (hasta seis dimensiones).

OPC_UA_WriteList: Escribir variables
Validez
La siguiente descripción de la instrucción "OPC_UA_WriteList" se aplica a las CPU S7-1500
con versión de firmware V2.6 y superior.

Programación del PLC
Manual de programación y manejo, 11/2019

4217

Instrucciones
4.1 Instrucciones

Descripción
Con la instrucción "OPC_UA_WriteList" se escriben valores nuevos en variables PLC.
La figura siguiente muestra el símbolo de la instrucción en el editor (FUP).

En la figura superior, los parámetros de la instrucción todavía no reciben valores.
La instrucción "OPC_UA_WriteList" sirve para asignar valores nuevos a variables PLC; véase

② en el siguiente gráfico:

La instrucción devuelve una lista de indicaciones de estado para cada variable PLC.





23&B8$B'LVFRQQHFW

23&B8$B&RQQHFW
23&B8$B1DPHVSDFH*HW,QGH[/LVW
23&B8$B1RGH*HW+DQGOH/LVW

23&B8$B5HDG/LVW
23&B8$B:ULWH/LVW

①
②
③

4218

23&B8$B1RGH5HOHDVH+DQGOH/LVW

Instrucciones para preparar las operaciones de lectura y escritura
Instrucciones de lectura y escritura
Instrucciones para liberar recursos una vez ejecutadas las operaciones de lectura o escritura

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros de OPC_UA_WriteList
Tabla 4-77

Los parámetros de la instrucción OPC_UA_WriteList

Parámetro

Declara‐
ción en el
área

Tipo de
datos

Significado

REQ

Input

BOOL

Un flanco ascendente 0 → 1 en el parámetro dispara la
ejecución de la instrucción.

ConnectionHdl

Input

DWORD

Identificación unívoca de una conexión establecida.
El controlador (handle) se obtiene con la instrucción AU‐
TOHOTSPOT.

NodeHdlCount

Input

UINT

Número de elementos en el array al que apunta el pará‐
metro NodeHdls.

NodeHdls

InOut

VARIANT

Puntero a un array del tipo DWORD.
El array contiene los controladores (handles) de nodos
(node handles) de las variables cuyos valores se desea
escribir.

NodeAddInfos

InOut

VARIANT

Puntero a un array del tipo AUTOHOTSPOT o AUTO‐
HOTSPOT.
El array determina cuál es el atributo que va a activarse en
un nodo (en una variable).
El primer elemento de dicho array hace referencia al pri‐
mer elemento del array al que apunta el parámetro No‐
deHdls .
Este parámetro es opcional. Si no existe, se activará el
valor en todos los nodos (variables).
Al escribir arrays existe la posibilidad de restringir los ele‐
mentos del array que deben escribirse, consulte Escritura
de una sección del array con OPC_UA_WriteList (Pági‐
na 4228).

Timeout

Input

TIME

Intervalo de tiempo máximo en milisegundos para la eje‐
cución de la instrucción.
Consulte también la explicación de este parámetro en
AUTOHOTSPOT.

NodeStatusList

InOut

VARIANT

Puntero a un array del tipo DWORD.
El array contiene los códigos de error de las diferentes
variables (consulte más abajo "Números de error de No‐
deStatusList").
Para cada variable se indica si ha sido posible activar su
valor.
Puede ocurrir que la instrucción se haya ejecutado co‐
rrectamente (parámetro Error no activado), pero que no
se haya podido asignar ningún valor a una variable deter‐
minada.
NodeStatusList[0] hace referencia a NodeHdls[0], etc.

Variable

InOut

VARIANT

Puntero hacia una variable que contiene los valores que
deben escribirse.
Para esta variable es necesario crear un tipo de datos
PLC (UDT).

Programación del PLC
Manual de programación y manejo, 11/2019

4219

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción en el
área

Tipo de
datos

Significado

Done

Output

BOOL

Estado de ejecución:
● 0: Ejecución de la instrucción interrumpida, no
finalizada o no iniciada.
● 1: Ejecución de la instrucción finalizada sin errores

Busy

Output

BOOL

Parámetro sobre el estado de la ejecución:
● 0: La instrucción no se está ejecutando
● 1: Instrucción ejecutándose en estos momentos

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error. Consulte el parámetro
"Status".

Status

Output

DWORD

Causa del error, consulte más abajo "Números de error de
Status"

Números de error de Status
El parámetro "Status" informa sobre errores que pueden producirse durante la ejecución de la
instrucción.
En la tabla siguiente encontrará una relación de códigos de error para esta instrucción:
Código de error

Nombre del error

Explicación

0000_0000

OpcUa_Good

Bloque de función ejecutado correctamente

8003_0000

OpcUa_BadOutOfMemory

No hay memoria disponible para el cliente
OPC UA.

(valores hexade‐
cimales)

Como el cliente OPC UA y el servidor OPC
UA comparten un área de memoria es nece‐
sario reducir la memoria necesaria del servi‐
dor.
Para ello, existen las siguientes posibilida‐
des:
● Liberar menos variables PLC para OPC
UA.
● Reducir el número de clientes OPC UA
conectados actualmente con el servidor.
● Crear menos suscripciones.
8009_0000

4220

OpcUa_BadUnknownResponse

El servidor envía una respuesta que no se
reconoce.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

OpcUa_BadTimeout

Se ha producido un timeout de red.

(valores hexade‐
cimales)
800A_0000

Posibles causas:
● La conexión al servidor OPC UA es
demasiado lenta (muy poca capacidad).
● La red está sobrecargada.
● El servidor OPC UA no está disponible
Posibles soluciones:
● Compruebe la URL del servidor OPC UA
● Aumente el intervalo de tiempo de
timeout (mayor valor para el parámetro
Timeout del bloque de función
OPC_UA_Connect).
800D_0000

OpcUa_BadServerNotConnected

El servidor no está conectado o el controla‐
dor (handle) de la conexión es incorrecto o
no es válido.

800F_0000

OpcUa_BadNothingToDo

No hay que hacer nada: el servidor OPC UA
recibe una lista vacía sin instrucciones del
cliente OPC UA.

8010_0000

OpcUa_BadTooManyOperations

Se ha excedido el número de instrucciones
"OPC_UA_WriteList" que pueden llamarse
simultáneamente por conexión (> 5); consul‐
te AUTOHOTSPOT

80AE_0000

BadConnectionClosed

La conexión con el ConnectionHdl corres‐
pondiente está en el estado "ShutDown"
(desconectada). La conexión/sesión no se
ha podido "reactivar" automáticamente. Cau‐
sa posible: sesión en el servidor borrada
(p. ej., por reinicio o timeout).
En este caso, la conexión se debe cerrar ex‐
plícitamente con la instrucción
"OPC_UA_Disconnect" para volver a liberar
los recursos de conexión. El ConnectionHdl
para esta conexión que ha dejado de ser vá‐
lida debe restablecerse en el programa de
usuario.
Finalmente, debe establecerse una nueva
conexión con el servidor (ver instrucción
"OPC_UA_Connect").

Programación del PLC
Manual de programación y manejo, 11/2019

4221

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

80AF_0000

BadInvalidState

La conexión con el ConnectionHdl corres‐
pondiente está en el estado "ConnectinE‐
rror" (error temporal de conexión, conexión
interrumpida). La CPU intenta "reactivar" la
conexión. Si esto no se logra durante el in‐
tervalo de timeout ajustado (OPC UA Ses‐
sion Timeout), la conexión pasa al estado
"Shutdown". Requisitos para el cambio de
estado: La CPU ha podido acceder al servi‐
dor OPC UA para comprobar si la sesión to‐
davía está presente o no.

B080_0100

Simatic_BadType_VariantInput1

Tipo de datos incorrecto para el parámetro
"NodeHdls".

B080_0200

Simatic_BadType_VariantInput2

Tipo de datos incorrecto para el parámetro
"NodeAddInfos".

B080_0300

Simatic_BadType_VariantInput3

Tipo de datos incorrecto para el parámetro
"NodeStatusList".

B080_0400

Simatic_BadType_VariantInput4

Tipo de datos incorrecto para el parámetro
"Variable" (no UDT).

B080_1100

Simatic_ArrayElements_TooMany

Código de error general. Ocurre cuando un
array tiene demasiados elementos.

B080_3100

BadNumElements_VariantInput1

El parámetro "NodeHdlCount" es mayor que
el número de elementos del array en el pa‐
rámetro "NodeHdls".

B080_3200

BadNumElements_VariantInput2

El parámetro "NodeHdlCount" es mayor que
el número de elementos del array en el pa‐
rámetro "NodeAddInfos".

B080_3300

BadNumElements_VariantInput3

El parámetro "NodeHdlCount" es mayor que
el número de elementos del array en el pa‐
rámetro "NodeStatusList".

B080_C400

Simatic_ClientNotEnabled

El cliente OPC UA está desactivado.

B080_C500

Simatic_NothingToDo

No hay que hacer nada: La instrucción utiliza
una lista que no contiene ningún elemento.

C080_C300

Simatic_OutOfResources

Se ha excedido el número máximo de ins‐
trucciones de cliente que pueden utilizarse
simultáneamente.

(valores hexade‐
cimales)

Posibles soluciones:
● Reduzca el número de instrucciones de
cliente paralelas de este tipo; consulte:
AUTOHOTSPOT
Encontrará más códigos de error en AUTOHOTSPOT

Números de error de "NodeStatusList"
El parámetro "NodeStatusList" contiene un código de error para cada controlador de nodo
(variable).

4222

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente explica los códigos de error:
Código de error

Nombre del error

Explicación

0000_0000

OpcUa_Good

Valor leído correctamente

8034_0000

OpcUa_BadNodeUnknown

El controlador de nodo transferido
se desconoce.

8035_0000

OpcUa_BadAttributeInvalid

El atributo solicitado no se permite
con el nodo indicado.

8037_0000

OpcUa_BadIndexRangeNoD

No hay datos en el área del índice.

8039_0000

OpcUa_BadDataEncodingUnsupported

El servidor OPC UA no soporta la
descodificación de datos solicitada
para este nodo.

803B_0000

OpcUa_BadNotWritable

Faltan derechos de escritura para
este nodo.

803C_0000

OpcUa_BadOutOfRange

El valor del índice, indicado en el pa‐
rámetro NodeAddInfos, está fuera
del rango admisible.

803D_0000

OpcUa_BadNotSupported

El servidor OPC UA no soporta una
de las funciones solicitadas.

(valores hexa‐
decimales)

Algunos servidores OPC UA no per‐
miten acceder a áreas de índices de
un array.
80AB_0000

OpcUa_BadInvalidArgument

Uno o varios argumentos no son vá‐
lidos.

Encontrará más códigos de error enAUTOHOTSPOT

Cómo utilizar esta instrucción
En este capítulo se explica, a partir de un ejemplo de programa, cómo se emplea la instrucción
"OPC_UA_WriteList" en un programa de usuario que ajusta valores nuevos en variables PLC.

Requisitos
En la siguiente descripción se presupone lo siguiente:
● Se ha creado una interfaz de cliente; consulte "AUTOHOTSPOT".
● Se ha creado y parametrizado una conexión a un servidor OPC UA; consulte
"AUTOHOTSPOT".

Programación del PLC
Manual de programación y manejo, 11/2019

4223

Instrucciones
4.1 Instrucciones
Asimismo, para la instrucción "OPC_UA_WriteList" deben cumplirse los siguientes requisitos:
● Existe un controlador para una conexión a un servidor OPC UA.
El controlador (handle) de la conexión se obtiene con la instrucción AUTOHOTSPOT.
● Índices de los espacios de nombres en los que se encuentran las variables que se desean
escribir con el cliente.
Los índices se obtienen con la instrucción AUTOHOTSPOT
● Una lista de los controladores para cada una de las variables cuyos valores se desee
activar en el servidor OPC UA.
Esta lista de controladores (handles) se obtiene con la instrucción AUTOHOTSPOT
En el ejemplo de programa de más adelante se llama una vez a la instrucción para transferir
una señal de liberación al servidor OPC UA.

Función del bloque
La instrucción "OPC_UA_WriteList" se utiliza para escribir los valores de variables en un
servidor OPC UA.
¿Qué información es necesaria?
La función necesita los datos siguientes:
● Los controladores para las variables cuyos valores se desee escribir (parámetro
"NodeHdls").
● Los valores que se desean transferir para cada variable (parámetro "Variable").
Tenga en cuenta para ello los siguientes casos:
– Si utiliza una interfaz de cliente con una lista de escritura, STEP 7 creará
automáticamente un tipo de datos de sistema con las variables que se van a transferir.
– Si no utiliza ninguna interfaz de cliente, deberá crear un tipo de datos PLC (UDT) o una
estructura (STRUCT) para el parámetro "Variable".
Los componentes de este UDT se definen de acuerdo con las variables que se van a
transferir.
Utilice el tipo de datos SIMATIC compatible con el tipo de datos OPC UA
correspondiente; ver AUTOHOTSPOT.
¿Qué información devuelve la instrucción?
La instrucción proporciona los datos siguientes:
● Una lista de mensajes de error (parámetro "NodeStatusList").
Cada mensaje de error de esta lista hace referencia al controlador (handle)
correspondiente en el parámetro "NodeHdls".
Para cada variable ("NodeHdl") hay que comprobar si el servidor OPC UA ha podido tomar
el valor nuevo.

4224

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cómo utilizar una conexión parametrizada
1. En el área "Árbol del proyecto", seleccione la CPU que actúa como cliente.
2. En la carpeta "Bloques de programa", seleccione el bloque de función que deba ejecutar la
instrucción del cliente.
En el ejemplo, el bloque de función se denomina "WriteToProductionline".
Lenguaje seleccionado: SCL.
3. Arrastre la instrucción "OPC_UA_WriteList" desde la carpeta "Instrucciones >
Comunicación > OPC UA > Cliente OPC UA" hasta el editor con la función Drag & Drop.
4. Seleccione la llamada como multiinstancia.
STEP 7 crea una instancia de esta instrucción y la denomina
"OPC_UA_WriteList_Instance".
5. Haga clic en "OPC_UA_WriteList_Instance".
STEP 7 abre la "Configuración".
6. En "Seleccionar interfaz del cliente para la interfaz OPC UA", elija la interfaz de cliente que
desee emplear con la instrucción.
En el ejemplo, la interfaz de cliente se denomina "Productionline".
(Ver AUTOHOTSPOT y "AUTOHOTSPOT")
7. Haga clic en "Acceso a datos" y elija una lista de escritura.
En el ejemplo, la lista de lectura se denomina "WriteListStatus".
STEP 7 asigna entonces automáticamente los valores configurados en la interfaz de cliente
a los parámetros de la instrucción.
8. Haga clic en "Parámetros del bloque" y asigne variables manualmente a los parámetros
REQ, Busy, Done, Error, Status.
STEP 7 inserta la variable seleccionada en la llamada de la función.

Llamada de la instrucción (primera llamada)
Encontrará el programa completo en el capítulo AUTOHOTSPOT.
El programa de ejemplo utiliza la lista de escritura "WriteListStatus" que contiene la siguiente
variable PLC:
● ProductionEnabled
El programa escribe el valor nuevo de esta variable en el servidor.
En el capítulo AUTOHOTSPOT se explica cómo crear una interfaz de cliente y agregarle una
lista de escritura con variables PLC.
El programa de ejemplo se divide en varias secciones (Cases) mediante una instrucción
CASE.

Programación del PLC
Manual de programación y manejo, 11/2019

4225

Instrucciones
4.1 Instrucciones
En la 4.ª sección del programa se escriben los valores de variables:
SCL
4: // case 4; write value to PLC variable "ProductionEnabled"
IF #SetProductionEnabled = TRUE THEN
#SetProductionEnabled := FALSE;
//set new value to true
"Productionline_Data"."WriteListStatus".Variable.ProductionEnabled := TRUE;
END_IF;
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
OPC_UA_WriteList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeCount,
NodeHdls :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeHdls,
Timeout := "Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList := "Productionline_Data"."WriteListStatus".NodeStatusList,
Variable := "Productionline_Data"."WriteListStatus".Variable,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);

Ejecución asíncrona
La instrucción "OPC_UA_WriteList" se ejecuta asíncronamente respecto al programa de
usuario y necesita varios ciclos de programa.
El estado actual de la ejecución se controla con los parámetros "Busy", "Done", "Error" y
"Status".
La ejecución asíncrona del programa se describe en el capítulo "Diferencia entre las
instrucciones que funcionan síncronamente y las que funcionan asíncronamente
(Página 618)".

Explicación de la llamada de la instrucción (primera llamada)
En el ejemplo superior se ilustra el caso 4.
En el programa de ejemplo, este caso solo asigna un nuevo valor a una variable PLC. En su
aplicación, puede asignar nuevos valores a un gran número de variables PLC.
El nuevo valor se ajusta a TRUE si la variable "#SetProductionEnabled" tiene el valor "TRUE".
A continuación, se ajusta "#SetProductionEnabled" a FALSE porque la inicialización solo debe
producirse una vez (en el primer ciclo).
La instrucción "OPC_UA_WriteList" escribe el nuevo valor en la variable PLC
"ProductionEnabled" en el servidor OPC UA.

4226

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si la instrucción aún no se ejecuta, #Busy es igual a FALSE, de modo que la variable "#Req"
adopta el valor TRUE. Con ello se inicia la instrucción. En el siguiente ciclo, #Req tiene el valor
FALSE.

Llamada de la instrucción (tratamiento de errores)
La figura siguiente ilustra la evaluación de los parámetros "Done" y "Error".
SCL
IF #Done = TRUE THEN
FOR #i := 0 TO
UINT_TO_INT("Productionline_Configuration".WriteLists.WriteListStatus.NodeCount) - 1 DO
IF NOT ("Productionline_Data"."WriteListStatus".NodeStatusList[#i] = 0) THEN
#Output_Error_Message := CONCAT_WSTRING(IN1 := WSTRING#'Error at Writelist
"WriteListStauts", Index: ',
IN2 := INT_TO_WSTRING(#i));
END_IF;
END_FOR;
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REG of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_WriteList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeCount,
NodeHdls :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeHdls,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList := "Productionline_Data"."WriteListStatus".NodeStatusList,
Variable := "Productionline_Data"."WriteListStatus".Variable);
END_IF;

Explicación de la llamada de la instrucción (tratamiento de errores)
En caso de error, el parámetro de salida "Error" adopta el valor TRUE. Entonces la variable
"#State" adopta el valor 100. Este caso está previsto para el tratamiento de errores. Además,
el programa de ejemplo llama la instrucción "OPC_UA_WriteList" para ajustar el parámetro
REQ a FALSE.
Si el parámetro de salida "Done" tiene el valor TRUE, la instrucción se ha ejecutado
correctamente.
Atención: Es posible que la instrucción se haya ejecutado correctamente (parámetro "Error" no
activado, parámetro "Done" activado), pero que no se haya podido ajustar una variable PLC.

Programación del PLC
Manual de programación y manejo, 11/2019

4227

Instrucciones
4.1 Instrucciones
Por este motivo, en el ejemplo se comprueba para la variable PLC si el programa ha podido
aplicar un valor válido:
● Si el servidor ha podido asignar el nuevo valor a la primera variable PLC, el primer elemento
del array al que señala el parámetro "NodeStatusList" tendrá el valor 0.
En el ejemplo solo se utiliza una variable. Su código de estado figura en
"Productionline_Data"."WriteListStatus".NodeStatusList[0]".
El programa emite un mensaje de error si no ha podido ajustarse una variable PLC.
El valor de la variable "#State" aumenta en 1. De este modo, en el siguiente ciclo se ejecuta la
siguiente sección del programa (caso 5: Release Handle List).

Consulte también
Instrucciones OPC UA para programas de cliente (Página 4151)
OPC_UA_NodeReleaseHandleList: habilitar controladores para accesos de lectura y escritura
(Página 4234)

Escritura de una sección del array con OPC_UA_WriteList
Introducción
Este capítulo se basa en el capítulo "OPC_UA_WriteList", ver OPC_UA_WriteList: Escribir
variables (Página 4217).
El capítulo describe cómo asignar nuevos valores (escribir) a una sección de un array con la
instrucción "OPC_UA_WriteList".
Básicamente, la escritura de una sección de un array de un servidor OPC UA funciona del
siguiente modo:
23&8$6HUYHU

23&8$&OLHQW

>@

>@
>@
>@
>@



>@
>@
>@
>@
>@
>@
>@

①

4228

Escritura de elementos de array en una sección de array de un servidor OPC UA

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Requisitos
En la siguiente descripción se presupone lo siguiente:
● Ha configurado una CPU como servidor OPC UA.
El servidor proporciona un array que pueden escribir los clientes OPC UA.
En el ejemplo se utiliza la CPU "Productionline", que proporciona el bloque de datos
"Data_from_OPC_UA_Clients" para los clientes OPC UA:

● Ha configurado una CPU como cliente OPC UA.
Ha creado una interfaz de cliente en el cliente; consulte "AUTOHOTSPOT".
La interfaz de cliente contiene una lista de escritura con un array.
Para escribir el array en el servidor solo debe emplearse una sección de dicho array.
El ejemplo utiliza la interfaz de cliente "Productionline" con la lista de escritura
"WriteListStatus":

En el array "Serial_Number" del servidor deben escribirse nuevos valores en
"Serial_Number[5]" a "Serial_Number[9]".

Adaptar el tipo de datos de la lista de escritura y el DB de la lista de escritura
El capítulo "OPC_UA_WriteList" explica cómo se escriben valores nuevos en escalares
(variables con un valor) o arrays (variables con varios valores) enteros con la instrucción
"OPC_UA_WriteList".
En la siguiente sección se amplían aspectos del capítulo "OPC_UA_WriteList" que son
necesarios para escribir valores nuevos en una sección de un array con OPC_UA_WriteList.
Paso 1: copiar y adaptar el tipo de datos de la lista de escritura
En primer lugar se cambia el tipo de datos de la variable que proporciona los valores que se
escriben en el servidor OPC UA.
El cambio es necesario porque el tipo de datos generado por STEP 7 es demasiado largo.
El tipo de datos es demasiado largo porque solo deben asignarse nuevos valores a una
sección del array (no a todo el array).
En el ejemplo se accede al array "Serial_Number", que contiene diez elementos.
Por este motivo, STEP 7 crea un tipo de datos con diez elementos.

Programación del PLC
Manual de programación y manejo, 11/2019

4229

Instrucciones
4.1 Instrucciones
Para acortar este tipo de datos, haga lo siguiente:
1. Abra la carpeta "Tipos de datos PLC" del área "Árbol del proyecto".
2. Abra la carpeta "Tipos de datos de sistema".
3. Copie el tipo de datos "<interfaz de cliente>.<lista de escritura>".
En el ejemplo, el tipo de datos se denomina "Productionline.WriteListStatus".
4. Pegue el tipo de datos copiado en la carpeta "Tipos de datos PLC".
5. Cambie el nombre del tipo de datos pegado para que sea descriptivo en el proyecto.
En el ejemplo, hemos cambiado el nombre a "myUDTProductionline.WriteListStatus".
6. Cambie el tipo de datos del array.
En el ejemplo queremos escribir los valores de Serial_Number[5] a Serial_Number[9] en el
servidor OPC UA.
Por eso acortamos el tipo de datos de "Array[0..9] of Lint" a "Array[0..4] of Lintl".
En el ejemplo:

Paso 2: copiar DB de la lista de escritura y aplicarle un nuevo tipo de datos de la lista de
escritura
En este paso se utiliza el nuevo tipo de datos en un nuevo bloque de datos.
Este paso es necesario porque el bloque de datos generado por STEP 7 contiene el tipo de
datos original del array.
No es posible cambiar el tipo de datos: cada vez que el bloque de datos se compila, se restaura
el tipo de datos original. Los cambios se pierden en el proceso.
Para crear un nuevo bloque de datos, haga lo siguiente:
1. En el área "Árbol del proyecto", seleccione la CPU que actúa como cliente.
2. Abra la carpeta "Bloques de programa".
3. Copie el bloque de datos <interfaz de cliente>_Data.
En el ejemplo, el bloque de datos se denomina "Productionline_Data".
4. Pegue el bloque de datos copiado en la carpeta "Bloques de programa".
5. Cambie el nombre del bloque de datos pegado para que sea descriptivo en el proyecto.
En el ejemplo, hemos cambiado el nombre a "myProductionline_Data".

4230

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
6. Utilice ahora el nuevo tipo de datos que se ha creado en el paso 1.
En el ejemplo, se asigna el nuevo tipo de datos a la variable "Variable" en la lista de escritura
"WriteListStatus":

7. Proporcione el nuevo bloque de datos (en el ejemplo, "myProductionline_Data") al
parámetro "Variable" de la instrucción "OPC_UA_WriteList".
Variable := "myProductionline_Data"."WriteListStatus".Variable,
Paso 3: crear una variable para el parámetro "NodeAddInfos" de OPC_UA_ReadList
En este paso, cree una variable local del tipo "OPC_UA_NodeAdditionalInfo".
Esta variable sirve para comunicar a la instrucción "OPC_UA_WriteList" las áreas de array a
las que se asignan nuevos valores.

Programación del PLC
Manual de programación y manejo, 11/2019

4231

Instrucciones
4.1 Instrucciones
Proceda del siguiente modo:
1. Cree una variable de array del tipo "OPC_UA_NodeAdditionalInfo".
En el ejemplo se crea la variable en la sección de declaración del bloque de función que
llama la instrucción "OPC_UA_WriteList".
A la nueva variable local se le pone el nombre "NodeAdditionalInformation":

La nueva variable local "NodeAdditionalInformation" incluye dos elementos del tipo
"OPC_UA_AdditonalInfo".
NodeAdditionalInformation[0] proporciona información adicional para la primera variable
que se va a escribir (en el ejemplo, "ProductionEnabled")
NodeAdditionalInformation[1] proporciona información adicional para la segunda variable
que se va a escribir (en el ejemplo, "Serial_Number")
2. Asigne valores a las nuevas variables (en la columna "Valores predeterminados" de la
sección de declaración).
En el ejemplo no se escriben todos los elementos de la segunda variable (Serial_Number).
Por eso se asigna el valor 13 a NodeAdditionalInformation[1].AttributeId (es decir, se
escriben los valores del array).
NodeAdditionalInformation[1].StartIndex recibe el valor 5, ya que se escribe a partir del
índice 5 (incluido).
NodeAdditionalInformation[1].EndIndex recibe el valor 9, ya que se escribe hasta el índice
9 (incluido).
Para NodeAdditionalInformation[0] se establecen los valores siguientes, que indican al
servidor que el primer elemento de la lista de escritura no es una sección de un array, sino
un escalar o un array que debe escribirse entero.
La constante "#ignore" contiene el valor 4_294_967_295. El servidor ignora este valor para
StartIndex y EndIndex y escribe por completo escalares y arrays.

Alternativa:
También es posible establecer los valores de NodeAdditionalInformation en el programa de
usuario:
// set additonal information to Array-Index 0
// we set default values here
#NodeAdditonalInformation[0].AttributeID := 13;

4232

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
#NodeAdditonalInformation[0].StartIndex :=
4_294_967_295;
#NodeAdditonalInformation[0].EndIndex :=
4_294_967_295;
// set additonal information to Array-Index 1
// because we want to write only five values to the
array in the OPC UA server
#NodeAdditonalInformation[1].AttributeID := 13;
#NodeAdditonalInformation[1].StartIndex := 5;
#NodeAdditonalInformation[1].EndIndex := 9;
Nota:
El array NodeAdditionalInformation del tipo "OPC_UA_NodeAdditionalInfo" debe tener
tantos elementos como la lista de escritura (en el ejemplo 2).
3. Asigne la variable local NodeAdditionalInformation al parámetro "NodeAddInfos" de la
instrucción "OPC_UA_WriteList".
La figura siguiente muestra la llamada de OPC_UA_WriteList con los nuevos valores
suministrados de los parámetros "Variable" y "NodeAddInfos":
#OPC_UA_WriteList_Instance(REQ := #Req,
NodeHdls :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeHd
ls,
NodeStatusList :=
"myProductionline_Data"."WriteListStatus".NodeStatusList,
Variable :=
"myProductionline_Data"."WriteListStatus".Variable,
ConnectionHdl :=
"Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeo
ut,
NodeHdlCount :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeCo
unt,
NodeAddInfos := #NodeAdditonalInformation,
Busy => #Busy,
Error => #Error,
Status => #Status,
Done => #Done);

Resultado en el servidor
La instrucción "OP_UA_WriteList" ahora solo escribe una sección del array "Serial_Number"
en el servidor OPC UA.
La figura siguiente muestra el array "Serial_Number". El servidor asigna los valores escritos a
partir del índice especificado mediante NodeAdditionalInformation (en el ejemplo a partir del
índice 5):

Programación del PLC
Manual de programación y manejo, 11/2019

4233

Instrucciones
4.1 Instrucciones

Nota
Utilice el tipo de datos "OPC_UA_NodeAdditionalInfoExt" para escribir en una sección de un
array multidimensional (hasta seis dimensiones).

Finalizar intercambio de datos
OPC_UA_NodeReleaseHandleList: habilitar controladores para accesos de lectura y escritura
Validez
La siguiente descripción de la instrucción "OPC_UA_NodeReleaseHandleList" se aplica a las
CPU S7-1500 con versión de firmware V2.6 y superior.

Descripción
La instrucción "OPC_UA_NodeReleaseHandleList" permite habilitar controladores.
La figura siguiente muestra el símbolo de la instrucción en el editor (FUP).

En la figura superior, los parámetros de la instrucción todavía no reciben valores.

4234

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucción "OPC_UA_NodeReleaseHandleList" sirve para habilitar controladores
(handles) para variables PLC que se han registrado previamente con la instrucción
"OPC_UA_NodeGetHandleList"; véase ③ en el siguiente gráfico.
La instrucción "OPC_UA_NodeReleaseHandleList" no es necesaria si se desea deshacer la
conexión al servidor OPC UA. En tal caso, llame inmediatamente la instrucción
AUTOHOTSPOT. Esta instrucción habilita automáticamente todos los controladores.





23&B8$B'LVFRQQHFW

23&B8$B&RQQHFW
23&B8$B1DPHVSDFH*HW,QGH[/LVW
23&B8$B1RGH*HW+DQGOH/LVW

23&B8$B5HDG/LVW
23&B8$B:ULWH/LVW

①
②
③

23&B8$B1RGH5HOHDVH+DQGOH/LVW

Instrucciones para preparar las operaciones de lectura y escritura
Instrucciones de lectura y escritura
Instrucciones para liberar recursos una vez ejecutadas las operaciones de lectura o escritura

Parámetros de "OPC_UA_NodeReleaseHandleList"
Tabla 4-78

Los parámetros del bloque de función "OPC_UA_NodeReleaseHandleList"

Parámetro

Declara‐
ción en el
área

Tipo de
datos S7

Significado

REQ

Input

BOOL

Un flanco ascendente 0 → 1 en el parámetro dispara la
ejecución del bloque.

ConnectionHdl

Input

DWORD

Identificación unívoca de una conexión establecida: con‐
trolador (handle) de la conexión.
El controlador de la conexión se obtiene llamando el blo‐
que de función OPC_UA_Connect.

NodeHdlCount

Input

UINT

Número de elementos en el parámetro NodeHdls

NodeHdls

InOut

VARIANT

Puntero a un array del tipo DWORD.
El array contiene los controladores (handles) de las va‐
riables que ya no se deseen leer o activar más en el pro‐
grama.

Timeout

Input

TIME

Intervalo de tiempo máximo para ejecutar el bloque de
función.
Consulte también la explicación de este parámetro en
AUTOHOTSPOT.

NodeStatusList

InOut

VARIANT

Puntero a un array del tipo DWORD.
El array contiene los códigos de error de los diferentes
controladores de nodo (variables); consulte "Números de
error del parámetro NodeStatusList".
Para cada controlador de nodo se indica si se ha podido
habilitar.

Programación del PLC
Manual de programación y manejo, 11/2019

4235

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción en el
área

Tipo de
datos S7

Significado

Done

Output

BOOL

Parámetro del estado de ejecución del bloque
● 0: Ejecución del bloque interrumpida, no finalizada o
no iniciada.
● 1: Ejecución del bloque finalizada sin errores.

Busy

Output

BOOL

Parámetro del estado de ejecución del bloque
● 0: El bloque no se está ejecutando
● 1: El bloque se está ejecutando en estos momentos

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error. Consulte el parámetro
"Status".

Status

Output

DWORD

Consulte más adelante "Números de error en el paráme‐
tro Status"

Números de error de Status
En la tabla siguiente encontrará una relación de códigos de error para esta instrucción:
Código de error

Nombre del error

Explicación

0000_0000

OpcUa_Good

Bloque de función ejecutado correcta‐
mente

8003_0000

OpcUa_BadOutOfMemory

No hay memoria disponible para el cliente
OPC UA.

(valores hexadecima‐
les)

Como el cliente OPC UA y el servidor
OPC UA comparten un área de memoria
es necesario reducir la memoria necesa‐
ria del servidor.
Para ello, existen las siguientes posibili‐
dades:
● Liberar menos variables PLC para
OPC UA.
● Reducir el número de clientes OPC
UA conectados actualmente con el
servidor.
● Crear menos suscripciones.

4236

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

OpcUa_BadTimeout

Se ha producido un timeout de red.

(valores hexadecima‐
les)
800A_0000

Posibles causas:
● La conexión al servidor OPC UA es
demasiado lenta (muy poca
capacidad).
● La red está sobrecargada.
● El servidor OPC UA no está disponible
Posibles soluciones:
● Compruebe la URL del servidor OPC
UA
● Aumente el intervalo de tiempo de
timeout (mayor valor para el
parámetro Timeout del bloque de
función OPC_UA_Connect).
800D_0000

OpcUa_BadServerNotConnected El servidor no está conectado o el contro‐
lador (handle) de la conexión es incorrec‐
to o no es válido.

800F_0000

OpcUa_BadNothingToDo

No hay que hacer nada: el servidor OPC
UA recibe una lista vacía sin instruccio‐
nes del cliente OPC UA.

8010_0000

OpcUa_BadTooManyOperations

Se ha excedido el número de instruccio‐
nes "OPC_UA_NodeReleaseHandleList"
que pueden llamarse simultáneamente
por conexión (> 1); consulte: AUTO‐
HOTSPOT

80AE_0000

BadConnectionClosed

La conexión con el ConnectionHdl corres‐
pondiente está en el estado "ShutDown"
(desconectada). La conexión/sesión no
se ha podido "reactivar" automáticamen‐
te. Causa posible: sesión en el servidor
borrada (p. ej., por reinicio o timeout).
En este caso, la conexión se debe cerrar
explícitamente con la instrucción
"OPC_UA_Disconnect" para volver a libe‐
rar los recursos de conexión. El Connec‐
tionHdl para esta conexión que ha dejado
de ser válida debe restablecerse en el
programa de usuario.
Finalmente, debe establecerse una nue‐
va conexión con el servidor (ver instruc‐
ción "OPC_UA_Connect").

Programación del PLC
Manual de programación y manejo, 11/2019

4237

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

80AF_0000

BadInvalidState

La conexión con el ConnectionHdl corres‐
pondiente está en el estado "ConnectinE‐
rror" (error temporal de conexión, cone‐
xión interrumpida). La CPU intenta "reac‐
tivar" la conexión. Si esto no se logra du‐
rante el intervalo de timeout ajustado
(OPC UA Session Timeout), la conexión
pasa al estado "Shutdown". Requisitos
para el cambio de estado: La CPU ha po‐
dido acceder al servidor OPC UA para
comprobar si la sesión todavía está pre‐
sente o no.

B080_0100

Simatic_BadType_VariantInput1

Tipo de datos incorrecto para el paráme‐
tro "NodeHdls".

B080_1100

Simatic_ArrayElements_Too‐
Many

NodeHdlCount > MAX_ELEMENTS_NO‐
DELIST

B080_0200

Simatic_BadType_VariantInput2

Tipo de datos incorrecto para el paráme‐
tro "NodeStatusList".

B080_3100

BadNumElements_VariantInput1

NodeHdlCount > número de elementos
del array del parámetro "NodeHdls".

B080_3200

BadNumElements_VariantInput2

NodeHdlCount > número de elementos
del array del parámetro "NodeStatusList".

B080_C400

Simatic_ClientNotEnabled

El cliente OPC UA está desactivado.

B080_C500

Simatic_NothingToDo

No hay que hacer nada: La instrucción
utiliza una lista que no contiene ningún
elemento.

C080_C300

Simatic_OutOfResources

Se ha excedido el número máximo de
instrucciones de cliente que pueden utili‐
zarse simultáneamente.

(valores hexadecima‐
les)

Posibles soluciones:
● Reduzca el número de instrucciones
de cliente paralelas de este tipo;
consulte:
AUTOHOTSPOT
Encontrará más códigos de error en AUTOHOTSPOT

Números de error de "NodeStatusList"
El parámetro "NodeStatusList" contiene un código de error para cada controlador de nodo
(variable).

4238

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente explica los códigos de error:
Código de error

Nombre del error

Explicación

0000_0000

OpcUa_Good

Controlador liberado correctamente.

8034_0000

OpcUa_BadNodeUnknown

El controlador de nodo transferido
se desconoce.

(valores hexa‐
decimales)

Encontrará más códigos de error en AUTOHOTSPOT

Cómo utilizar esta instrucción
En este capítulo se explica, a partir de un ejemplo, cómo se emplea la instrucción
"OPC_UA_NodeReleaseHandleList" en un programa que intercambia datos con un servidor
OPC UA.

Requisitos
En la siguiente descripción se presupone lo siguiente:
● Se ha creado una interfaz de cliente.
● Se ha creado y parametrizado una conexión a un servidor OPC UA; consulte
"AUTOHOTSPOT".
Asimismo, para la instrucción "OPC_UA_NodeReleaseHandleList" deben cumplirse los
siguientes requisitos:
● Existe un controlador (handle) para una conexión a un servidor OPC UA.
El controlador (handle) de la conexión se obtiene llamando el bloque de función; consulte
"AUTOHOTSPOT".
● Una lista de los controladores (handles) para cada una de las variables cuyos valores ya no
se deseen leer o escribir más en el programa.
La lista de controladores (handles) se obtiene llamando el bloque de función; consulte
"AUTOHOTSPOT".

Función de la instrucción
La instrucción "OPC_UA_NodeReleaseHandleList" se llama para liberar controladores de
nodo cuando ya no se requieren en el programa.
Los controladores de nodo son referencias numéricas a nodos (por ejemplo, variables PLC) en
el servidor OPC UA.
¿Qué información se necesita para el bloque de función?
El bloque de función necesita los datos siguientes:
● Una lista de los controladores (handles) para las variables (u otros nodos) cuyos valores ya
no se desean leer o escribir (en el parámetro "NodeHdls").

Programación del PLC
Manual de programación y manejo, 11/2019

4239

Instrucciones
4.1 Instrucciones
¿Qué información devuelve el bloque de función?
El bloque de función proporciona los datos siguientes:
● Una lista de mensajes de error (en el parámetro "NodeStatusList").
Cada mensaje de error de esta lista hace referencia al controlador (handle)
correspondiente en el parámetro "NodeHdls".
Para cada controlador de nodo hay que comprobar si el servidor OPC UA lo ha podido
liberar.
Si no ha sido posible liberar un controlador de nodo, el programa de usuario deberá
interceptar este error: En un tratamiento de errores, por ejemplo, llame de nuevo esta
instrucción.

Cómo utilizar una conexión parametrizada
1. En el área "Árbol del proyecto", seleccione la CPU que deba actuar como cliente.
2. En la carpeta "Bloques de programa", seleccione el bloque de función que deba ejecutar la
instrucción del cliente.
En el ejemplo, el bloque de función se denomina "ReadFromProductionline".
Lenguaje seleccionado: SCL.
3. Arrastre la instrucción "OPC_UA_NodeReleaseHandleList" desde la carpeta "Instrucciones
> Comunicación > OPC UA > Cliente OPC UA" hasta el editor con la función Drag & Drop.
4. Seleccione la llamada como multiinstancia.
STEP 7 crea una instancia de esta instrucción y la denomina
"OPC_UA_NodeReleaseHandleList_Instance".
5. Haga clic en el símbolo de "Iniciar configuración" junto a la instrucción
"OPC_UA_NodeReleaseHandleList_Instance".
STEP 7 abre la ficha "Configuración" de la ventana de inspección.
6. En "Seleccionar interfaz del cliente para la interfaz OPC UA", elija la interfaz de cliente que
desee emplear con la instrucción.
En el ejemplo, la interfaz de cliente que habíamos creado para nuestra AUTOHOTSPOT se
denomina "Productionline".
7. Haga clic en "Acceso a datos" y elija una lista de lectura.
En el ejemplo, la lista de lectura se denomina "ReadListProduct".
STEP 7 asigna entonces automáticamente los valores configurados en la interfaz de cliente
a los parámetros de la instrucción.
8. Haga clic en "Parámetros del bloque" y asigne variables manualmente a los parámetros
REQ, Busy, Done, Error y Status.
STEP 7 inserta la variable seleccionada en la llamada de la función.

Llamada de la instrucción (primera llamada)
Encontrará el programa completo en el capítulo "Programa de ejemplo para leer variables PLC
(Página 4307)".

4240

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El programa de ejemplo utiliza la lista de lectura "ReadListProduct" que contiene las siguientes
variables PLC:
● NewProduct
● ProductNumber
El siguiente ejemplo de programa habilita los controladores (handles) para estas variables
PLC.
Instrucción CASE
El programa de ejemplo se divide en varias secciones (Cases) mediante una instrucción
CASE.
Aquí se ilustra el caso 5:
SCL
5: // case 5, release node handles
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_NodeReleaseHandleList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeCount,
NodeHdls :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeHdls,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList := "Productionline_Data"."ReadListProduct".NodeStatusList,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);

Ejecución asíncrona
La instrucción "OPC_UA_NodeReleaseHandleList" se ejecuta asíncronamente respecto al
programa de usuario y necesita varios ciclos de programa.
El estado actual de la ejecución se controla con los parámetros "Busy", "Done", "Error" y
"Status".
La ejecución asíncrona del programa se describe en el capítulo "Diferencia entre las
instrucciones que funcionan síncronamente y las que funcionan asíncronamente
(Página 618)".

Explicación de la llamada de la instrucción (primera llamada)
En la figura superior se ilustra el caso 5.

Programación del PLC
Manual de programación y manejo, 11/2019

4241

Instrucciones
4.1 Instrucciones
Esta sección del programa llama la instrucción "OPC_UA_NodeReleaseHandleList". Con ella
se habilitan controladores (handles) para las variables PLC. Las variables se recogen en la
lista de lectura "ReadListProduct".
Si la instrucción aún no se ejecuta, #Busy es igual a FALSE, de modo que la variable "#Req"
adopta el valor TRUE. Con ello se inicia la instrucción. En el siguiente ciclo, #Req tiene el valor
FALSE.

Llamada de la instrucción (tratamiento de errores)
La figura siguiente ilustra la evaluación de los parámetros "Done" y "Error".
SCL
IF #Done = TRUE THEN
IF "Productionline_Data"."ReadListProduct".NodeStatusList[0] = 0 AND
"Productionline_Data"."ReadListProduct".NodeStatusList[1] = 0
THEN
#State := #State + 1;
ELSE
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at NodeReleaseHandleList';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REG of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_NodeReleaseHandleList_Instance(REQ := FALSE,
ConnectionHdl :=
"Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeCount,
NodeHdls :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeHdls,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList :=
"Productionline_Data"."ReadListProduct".NodeStatusList);
END_IF;

Explicación de la llamada de la instrucción (tratamiento de errores)
En caso de error, el parámetro de salida "Error" adopta el valor TRUE. Entonces la variable
#State adopta el valor 100. Este caso está previsto para el tratamiento de errores. Además, el
programa de ejemplo llama la instrucción "OPC_UA_NodeReleaseHandleList" para poner el
parámetro REQ a FALSE.
Si el parámetro de salida "Done" tiene el valor TRUE, la instrucción se ejecuta correctamente.

4242

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Atención: Es posible que la instrucción se haya ejecutado correctamente (parámetro "Error" no
activado, parámetro "Done" activado), pero que no se haya podido habilitar un controlador
para una variable PLC.
Por este motivo, en el ejemplo se comprueba si se han habilitado los controladores para ambas
variables:
● Si el servidor ha liberado el controlador (handle) para la primera variable PLC, el primer
elemento del array al que señala el parámetro "NodeStatusList" tiene el valor 0.
En el ejemplo, el código de estado figura en
"Productionline_Data"."ReadListProduct".NodeStatusList[0].
● Si el servidor ha liberado el controlador (handle) para la segunda variable PLC, el segundo
elemento del array al que señala el parámetro "NodeStatusList" tiene el valor 0.
En el ejemplo, el código de estado figura en
"Productionline_Data"."ReadListProduct".NodeStatusList[1].
Si se cumplen ambas condiciones, el valor de la variable "#State" aumenta en uno. De este
modo, en el siguiente ciclo se ejecuta la siguiente sección del programa (caso 6: cerrar
conexión).
El caso 6 se describe en AUTOHOTSPOT.
Nota
El caso 6 sirve para liberar la conexión al servidor OPC UA. Con ello se liberan también todos
los demás recursos que el programa cliente había ocupado en el servidor. Si desea finalizar la
conexión al servidor, el programa de usuario puede ejecutar directamente el caso 6 y omitir el
caso 5.

Consulte también
Instrucciones OPC UA para programas de cliente (Página 4151)

OPC_UA_Disconnect: cerrar la conexión
Validez
Salvo que se indique lo contrario, la siguiente descripción de la instrucción
"OPC_UA_Disconnect" se aplica a las CPU S7-1500 con versión de firmware V2.6 y superior.

Programación del PLC
Manual de programación y manejo, 11/2019

4243

Instrucciones
4.1 Instrucciones

Descripción
Con la instrucción "OPC_UA_Disconnect" se cierra la conexión a un servidor OPC UA.
Nota
Manejo de los controladores (handles) de la conexión (ConnectionHdl) con versión de
firmware V2.8 y superior
A partir de la versión de firmware V2.8, tras un error de conexión (Error-Code
"BadConnectionClosed"), la conexión se debe cerrar explícitamente con la instrucción
"OPC_UA_Disconnect" para volver a liberar los recursos de conexión. El ConnectionHdl para
la conexión que ha dejado de ser válida debe restablecerse en el programa de usuario.
La figura siguiente muestra el símbolo de la instrucción en el editor (FUP).

En la figura superior, los parámetros de la instrucción todavía no reciben valores.
La instrucción "OPC_UA_Disconnect" finaliza la conexión y la sesión con un servidor OPC UA;
véase ③ en el siguiente gráfico.





23&B8$B'LVFRQQHFW

23&B8$B&RQQHFW
23&B8$B1DPHVSDFH*HW,QGH[/LVW
23&B8$B1RGH*HW+DQGOH/LVW

23&B8$B5HDG/LVW
23&B8$B:ULWH/LVW

①
②
③

4244

23&B8$B1RGH5HOHDVH+DQGOH/LVW

Instrucciones para preparar las operaciones de lectura y escritura
Instrucciones de lectura y escritura
Instrucciones para liberar recursos una vez ejecutadas las operaciones de lectura o escritura

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros de "OPC_UA_Disconnect"
Tabla 4-79

Los parámetros del bloque de función "OPC_UA_Disconnect"

Parámetro

Declara‐
ción en el
área

Tipo de
datos

Significado

REQ

Input

BOOL

Un flanco ascendente 0 → 1 en el parámetro dispara la
ejecución del bloque.

ConnectionHdl

Input

DWORD

Identificación unívoca de una conexión establecida: con‐
trolador (handle) de la conexión.
El controlador de la conexión se obtiene llamando el blo‐
que de función OPC_UA_Connect.

Timeout

Input

TIME

Intervalo de tiempo máximo para ejecutar el bloque de
función.
Consulte también la explicación de este parámetro
en OPC_UA_Connect: crear una conexión (Página 4153).

Done

Output

BOOL

Parámetro del estado de ejecución del bloque
● 0: Ejecución del bloque interrumpida, no finalizada o
no iniciada.
● 1: Ejecución del bloque finalizada sin errores.
Atención: Aunque la ejecución de la instrucción
"OPC_UA_Disconnect" haya finalizado con Done=1, el
recurso de conexión permanece ocupado unos 60 segun‐
dos más; ver AUTOHOTSPOT.

Busy

Output

BOOL

Parámetro del estado de ejecución del bloque
● 0: El bloque no se está ejecutando
● 1: El bloque se está ejecutando en estos momentos

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error. Consulte el parámetro
"Status".

Status

Programación del PLC
Manual de programación y manejo, 11/2019

Output

DWORD

Consulte más adelante "Números de error en el paráme‐
tro Status"

4245

Instrucciones
4.1 Instrucciones

Números de error en el parámetro Status
El parámetro "Status" informa sobre errores que pueden producirse durante la ejecución de la
instrucción:
Código de error

Nombre del error

Explicación

0000_0000

OpcUa_Good

Bloque de función ejecutado correc‐
tamente

8003_0000

OpcUa_BadOutOfMemory

No hay memoria disponible para el
cliente OPC UA.

(valores hexadecima‐
les)

Como el cliente OPC UA y el servidor
OPC UA comparten un área de me‐
moria es necesario reducir la memo‐
ria necesaria del servidor.
Para ello, existen las siguientes po‐
sibilidades:
● Liberar menos variables PLC
para OPC UA.
● Reducir el número de clientes
OPC UA conectados
actualmente con el servidor.
● Crear menos suscripciones.
800A_0000

OpcUa_BadTimeout

Se ha producido un timeout de red.
Posibles causas:
● La conexión al servidor OPC UA
es demasiado lenta (muy poca
capacidad).
● La red está sobrecargada.
● El servidor OPC UA no está
disponible
Posibles soluciones:
● Compruebe la URL del servidor
OPC UA
● Aumente el intervalo de tiempo
de timeout (mayor valor para el
parámetro Timeout del bloque de
función OPC_UA_Connect).

4246

800D_0000

OpcUa_BadServerNotConnected

El servidor no está conectado o el
controlador (handle) de la conexión
es incorrecto o no es válido.

800F_0000

OpcUa_BadNothingToDo

No hay que hacer nada: el servidor
OPC UA recibe una lista vacía sin
instrucciones del cliente OPC UA.

8010_0000

OpcUa_BadTooManyOperations

Se ha excedido el número de instruc‐
ciones "OPC_UA_Disconnect" que
pueden llamarse simultáneamente
por conexión (> 1); consulte: AUTO‐
HOTSPOT

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error

Nombre del error

Explicación

B080_C400

Simatic_ClientNotEnabled

El cliente OPC UA está desactivado.

B080_C600

Simatic_ClientNotAvailable

Error al inicializar el cliente

C080_C300

Simatic_OutOfResources

Se ha excedido el número máximo
de instrucciones de cliente que pue‐
den utilizarse simultáneamente.

(valores hexadecima‐
les)

Posibles soluciones:
● Reduzca el número de
instrucciones de cliente paralelas
de este tipo; consulte:
AUTOHOTSPOT
Encontrará más códigos de error en AUTOHOTSPOT

Cómo utilizar esta instrucción
En este capítulo se explica, a partir de un ejemplo, cómo se emplea la instrucción
"OPC_UA_Disconnect" en un programa que intercambia datos con un servidor OPC UA.

Requisitos
En la siguiente descripción se presupone lo siguiente:
● Se ha creado una interfaz de cliente; consulte "AUTOHOTSPOT"
● Se ha creado y parametrizado una conexión a un servidor OPC UA; consulte
"AUTOHOTSPOT".
Asimismo, para la instrucción "OPC_UA_Disconnect" deben cumplirse los siguientes
requisitos:
● Existe un controlador (handle) para una conexión a un servidor OPC UA.
El controlador (handle) de la conexión se obtiene llamando la instrucción;
consulte OPC_UA_Connect: crear una conexión (Página 4153).

Función de la instrucción
Para finalizar la conexión a un servidor OPC UA, llame la instrucción "OPC_UA_Disconnect".

Cómo utilizar una conexión parametrizada
1. En el área "Árbol del proyecto", seleccione la CPU que deba actuar como cliente.
2. En la carpeta "Bloques de programa", seleccione el bloque de función que deba ejecutar la
instrucción del cliente.
En el ejemplo, el bloque de función se denomina "ReadFromProductionline".
Lenguaje seleccionado: SCL.
3. Arrastre la instrucción "OPC_UA_Disconnect" desde la carpeta "Instrucciones >
Comunicación > OPC UA > Cliente OPC UA" hasta el editor con la función Drag & Drop.

Programación del PLC
Manual de programación y manejo, 11/2019

4247

Instrucciones
4.1 Instrucciones
4. Seleccione la llamada como multiinstancia.
STEP 7 crea una instancia de esta instrucción y la denomina
"OPC_UA_Disconnect_Instance".
5. Haga clic en el símbolo de "Iniciar configuración" junto a la instrucción
"OPC_UA_Disconnect_Instance".
STEP 7 abre la ficha "Configuración" de la ventana de inspección.
6. En "Seleccionar interfaz del cliente para la interfaz OPC UA", elija la interfaz de cliente que
desee emplear con la instrucción.
En el ejemplo, la interfaz de cliente que se había creado para AUTOHOTSPOT se
denomina "Productionline"; consulte "AUTOHOTSPOT".
STEP 7 asigna entonces automáticamente los valores configurados en la interfaz de cliente
a los parámetros de la instrucción.
7. Haga clic en "Parámetros del bloque" y asigne variables manualmente a los parámetros
REQ, Busy, Done, Error, Status.
STEP 7 inserta la variable elegida en cada llamada de la instrucción.

Llamada de la instrucción
Encontrará el programa completo en el capítulo "AUTOHOTSPOT".
El programa de ejemplo finaliza la conexión y la sesión con un servidor OPC UA:
SCL
6: // case 6, disconnect from server
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Disconnect_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);

El programa de ejemplo llama la instrucción "OPC_UA_Disconnect" por los siguientes motivos:
● para finalizar la conexión con el servidor OPC UA.
● para ajustar el parámetro REQ a FALSE si se ha producido un error.
Ejecución asíncrona
La instrucción "OPC_UA_Disconnect" se ejecuta asíncronamente respecto al programa de
usuario y necesita varios ciclos de programa.
El estado actual de la ejecución se controla con los parámetros "Busy", "Done", "Error" y
"Status".
La ejecución asíncrona del programa se describe en el capítulo "Diferencia entre las
instrucciones que funcionan síncronamente y las que funcionan asíncronamente
(Página 618)".

4248

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Explicación de la llamada de la instrucción
En la figura superior se representa el caso 6. Esta sección del programa finaliza la conexión y
la sesión con el servidor OPC UA conectado.
Si la variable #State tiene el valor 6, se ejecuta el caso 6.
Si la instrucción "OPC_UA_Disconnect" aún no se ejecuta, #Busy es igual a FALSE, de modo
que la variable "#Req" adopta el valor TRUE. Con ello se inicia la instrucción. En el siguiente
ciclo, #Req tiene el valor FALSE.
Si el parámetro de salida "Done" tiene el valor TRUE, se ha podido liberar el controlador
(handle) para la conexión y deshacer la conexión. Con ello el valor de la variable "#State"
aumenta en uno. De este modo, en el siguiente ciclo se ejecuta la siguiente sección del
programa (caso 7). Este caso ajusta las indicaciones de estado para el bloque de función
(Output_Busy = FALSE, Output_Done = TRUE).
Si la instrucción no se puede ejecutar correctamente, el parámetro de salida "Error" tiene el
valor TRUE, y la variable #State recibe el valor 100. Este caso está previsto para el tratamiento
de errores.

Diagnóstico
OPC_UA_ConnectionGetStatus: leer estado de la conexión
Validez
Salvo que se indique lo contrario, la siguiente descripción de la instrucción
"OPC_UA_ConnectionGetStatus" se aplica a las CPU S7-1500 con versión de firmware V2.6
y superior.

Descripción
La instrucción "OPC_UA_ConnectionGetStatus" se emplea para vigilar una conexión, es decir,
para obtener información sobre la calidad de la conexión con un servidor OPC UA.
La instrucción devuelve la siguiente información:
● Estado de la conexión
● Estado y ServiceLevel del servidor OPC UA conectado
(identificador de nodo de estado: i=2259, identificador de nodo de ServiceLevel: i=2267)

Programación del PLC
Manual de programación y manejo, 11/2019

4249

Instrucciones
4.1 Instrucciones



23&B8$B&RQQHFW



23&B8$B&RQQHFWLRQ*HW6WDWXV

23&B8$B'LVFRQQHFW

23&B8$B1DPHVSDFH*HW,QGH[/LVW
23&B8$B7UDQVODWLRQ3DWK/LVW
23&B8$B5HDG/LVW

23&B8$B1RGH*HW+DQGOH/LVW

①
②
③

23&B8$B:ULWH/LVW

23&B8$B1RGH5HOHDVH+DQGOH/LVW

Instrucciones para preparar las operaciones de lectura y escritura
Instrucciones de lectura y escritura
Instrucciones para "Clean-up" una vez ejecutadas las operaciones de lectura o escritura

Parámetros de "OPC_UA_ConnectionGetStatus"
Tabla 4-80

Los parámetros del bloque de función "OPC_UA_ConnectionGetStatus"

Parámetro

Declara‐
ción en el
área

Tipo de
datos

Significado

REQ

Input

BOOL

Un flanco ascendente 0 → 1 en el parámetro dispara
el procesamiento de la instrucción.

ConnectionHdl

Input

DWORD

Identificación unívoca de una conexión establecida.
El controlador (handle) se obtiene con la instrucción
AUTOHOTSPOT.

Timeout

Input

TIME

Intervalo de tiempo máximo en milisegundos para la
ejecución de la instrucción.
Consulte también la explicación de este parámetro
en AUTOHOTSPOT.

Done

Output

BOOL

Estado de ejecución:
● 0: Ejecución de la instrucción interrumpida, no
finalizada o no iniciada.
● 1: Ejecución de la instrucción finalizada sin
errores

Busy

Output

BOOL

Parámetro sobre el estado de la ejecución:
● 0: La instrucción no se está ejecutando
● 1: Instrucción ejecutándose en estos momentos

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error. Consulte el
parámetro "Status".

Status

4250

Output

DWORD

Causa del error, consulte más abajo "Números de
error de Status"

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción en el
área

Tipo de
datos

Significado

ConnectionStatus

Output

UDINT

Estado de la conexión identificada por el parámetro
ConnectionHdl.
Válido si Done=1.
Significado:
● 0: Se ha establecido conexión al servidor OPC
UA.
● 1: Conexión errónea con el servidor OPC UA
("ConnectionError"). La CPU intenta "reactivar"
la conexión en este estado.
● 2: No se ha podido reactivar la conexión con el
servidor OPC UA. La conexión de la CPU con el
servidor se ha desconectado ("ShutDown"). Se
debe cerrar la conexión (OPC_UA_Disconnect)
y, a continuación, establecer una nueva
conexión con el servidor OPC UA
(OPC_UA_Connect).

ServerState

Output

UDINT

Información sobre el servidor OPC UA. Válido si Do‐
ne=1 y ConnectionStatus=0.
Significado de los valores:
● 0: El servidor funciona normalmente.
● 1: Se ha producido un error en el servidor. El
servidor ha dejado de funcionar de modo fiable.
● 2: El servidor funciona. Pero no se ha cargado
ninguna configuración. Por ello no se
intercambian datos.
● 3: El servidor no está disponible temporalmente.
● 4: El servidor se ha desconectado o se está
desconectando.
● 5: El servidor funciona en modo Test. Las salidas
no están conmutadas.
● 6: El servidor funciona normalmente. Sin
embargo, hay problemas al leer las variables
PLC.
● 7: El estado del servidor se desconoce.
Este valor se activa si no existe ninguna
conexión al servidor.

ServiceLevel

Output

Byte

Un dato sobre la capacidad del servidor OPC UA
conectado. Válido si Done=1 y ConnectionStatus=0.
El servidor devuelve un número entre 0 y 255 para
indicar su capacidad: cuanto mayor sea dicho nú‐
mero, mayor será la capacidad del servidor.

Programación del PLC
Manual de programación y manejo, 11/2019

4251

Instrucciones
4.1 Instrucciones

Números de error de Status
El parámetro "Status" informa sobre errores que pueden producirse durante la ejecución de la
instrucción.
En la tabla siguiente encontrará una relación de códigos de error para esta instrucción:
Código de
error

Nombre del error

Explicación

0000_0000

OpcUa_Good

Instrucción finalizada correctamente

8003_0000

OpcUa_BadOutOfMemory

No hay memoria disponible para el cliente
OPC UA.

(valores hexa‐
decimales)

Como el cliente OPC UA y el servidor OPC
UA comparten un área de memoria es ne‐
cesario reducir la memoria necesaria del
servidor.
Para ello, existen las siguientes posibilida‐
des:
● Liberar menos variables PLC para OPC
UA.
● Reducir el número de clientes OPC UA
conectados actualmente con el servidor.
● Crear menos suscripciones.
8009_0000

OpcUa_BadUnknownResponse

El servidor envía una respuesta desconoci‐
da o no válida.

800A_0000

OpcUa_BadTimeout

Se ha producido un timeout de red.
Posibles causas:
● La conexión al servidor OPC UA es
demasiado lenta (muy poca capacidad).
● La red está sobrecargada.
● El servidor OPC UA no está disponible
Posibles soluciones:
● Compruebe la URL del servidor OPC UA
● Aumente el intervalo de tiempo de
timeout (mayor valor para el parámetro
Timeout del bloque de función
OPC_UA_Connect).

4252

800D_0000

OpcUa_BadServerNotConnected

El servidor no está conectado o el controla‐
dor (handle) de la conexión es incorrecto o
no es válido.

8010_0000

OpcUa_BadTooManyOperations

Se ha excedido el número de instrucciones
"OPC_UA_ConnectionGetStatus" que pue‐
den llamarse simultáneamente por conexión
(> 1); consulte: AUTOHOTSPOT

8074_0000

OpcUa_BadTypeMismatch

ServerState/ServiceLevel tienen un tipo
inesperado.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error

Nombre del error

Explicación

A000_0105

PLCopenUA_Bad_ConnectionInva‐
lidHdl

Controlador (handle) de la conexión (Con‐
nectionHdl) no válido/desconocido. Se debe
establecer una nueva conexión. Si se libera
una conexión con la instrucción
"OPC_UA_Disconnect", el "Connection Han‐
dle" de esa conexión también dejará de ser
válido. Nota: Para las CPU S7-1500 a partir
de la versión de firmware V2.8, el controla‐
dor (handle) de la conexión solo se liberará
o dejará de ser válido llamando la instruc‐
ción OPC_UA_Disconnect.

B080_C400

Simatic_ClientNotEnabled

El cliente OPC UA está desactivado.

C080_C300

Simatic_OutOfResources

Se ha excedido el número máximo de ins‐
trucciones de cliente que pueden utilizarse
simultáneamente.

(valores hexa‐
decimales)

Posibles soluciones:
● Reduzca el número de instrucciones de
cliente paralelas de este tipo; consulte:
AUTOHOTSPOT
Encontrará más códigos de error en AUTOHOTSPOT

Requisitos
Para la instrucción "OPC_UA_ConnectionGetStatus" deben cumplirse los siguientes
requisitos:
● Existe un controlador para una conexión a un servidor OPC UA.
El controlador (handle) de la conexión se obtiene con la instrucción AUTOHOTSPOT.

Llamada de la instrucción
Este capítulo describe el bloque de función "Analyze_Connection". El bloque de función
muestra cómo utilizar la instrucción "OPC_UA_ConnectionGetStatus".
Encontrará el ejemplo completo en el capítulo Programa de ejemplo para
OPC_UA_ConnectionGetStatus (Página 4302).
Declaración de las variables
Declare una instancia de la instrucción "OPC_UA_ConnectionGetStatus" y las variables con
las que se suministren valores a los parámetros de la instrucción.
El ejemplo de programa utiliza la declaración siguiente:

Programación del PLC
Manual de programación y manejo, 11/2019

4253

Instrucciones
4.1 Instrucciones
Programa de usuario
La figura siguiente muestra la sección del programa de ejemplo "Analyze_Connection" que
determina la calidad de la conexión al servidor.
El programa de ejemplo se divide en varias secciones (Cases) mediante una instrucción
CASE.
Aquí se ilustra el caso 2 (análisis de la conexión):
SCL
2: // case 2, analyse connection
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_ConnectionGetStatus_Instance(REQ := #Req,
ConnectionHdl := #ConnectionHdl,
Timeout := T#6S,
Done => #Done,
Error => #Error,
Busy => #Busy,
Status => #Status,
ConnectionStatus => #ConnectionStatus,
ServerState => #ServerState,
ServiceLevel => #ServiceLevel);
IF #Done = TRUE THEN
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
#State := 100;
#Mem_Status := #Status;
#OPC_UA_ConnectionGetStatus_Instance(REQ := FALSE, ConnectionHdl :=
#ConnectionHdl);
END_IF;

En caso de error de la instrucción "OPC_UA_ConnectionGetStatus" (#Error tiene el valor
"TRUE") el parámetro REQ se pone al valor "FALSE".
Ejecución asíncrona
La instrucción "OPC_UA_ConnectionGetStatus" se ejecuta asíncronamente respecto al
programa de usuario y necesita varios ciclos de programa.
El estado actual de la ejecución se controla con los parámetros "Busy", "Done", "Error" y
"Status".
La ejecución asíncrona del programa se describe en el capítulo "Diferencia entre las
instrucciones que funcionan síncronamente y las que funcionan asíncronamente
(Página 618)".

Explicación de la llamada de la instrucción
La figura superior muestra el caso 2 del programa de ejemplo "Analyze_Connection".

4254

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Esta sección del programa solo consulta los valores actuales de "ConnectionStatus",
"ServerState" y "ServiceLevel" del servidor OPC UA conectado, pero no los evalúa.
Si la variable #State tiene el valor 2, se ejecutará el caso 2.
Si la instrucción "OPC_UA_ConnectionGetStatus" aún no se ejecuta, #Busy es igual a FALSE,
de modo que la variable "#Req" se pone a TRUE. Con ello se inicia la instrucción. En el
siguiente ciclo, #Req tiene el valor FALSE.
Si el parámetro de salida "Error" tiene el valor TRUE, se ha producido un error al ejecutar la
instrucción. Entonces la variable "#State" adopta el valor 100. Este caso está previsto para el
tratamiento de errores.
Si el parámetro de salida "Done" tiene el valor TRUE, la instrucción se ha ejecutado
correctamente. Con ello el valor de la variable "#State" aumenta en uno. De este modo, en el
siguiente ciclo se ejecuta la siguiente sección del programa (caso 3). El caso 3 se describe en
OPC_UA_Disconnect: cerrar la conexión (Página 4243).

Métodos
OPC_UA_MethodGetHandleList: recoger controladores (handles) para llamadas de método
Validez
La siguiente descripción de la instrucción "OPC_UA_MethodGetHandleList" se aplica a las
CPU S7-1500 con versión de firmware V2.6 y superior.

Descripción
Un ejemplo de programación muestra cómo utilizar la instrucción en el lenguaje de
programación SCL.
Este capítulo parte del principio de que para la comunicación OPC UA se crea y parametriza
una interfaz cliente, consulte: AUTOHOTSPOT. Con este eficiente procedimiento los valores
se suministran automáticamente a la mayoría de los parámetros de la instrucción del cliente.
Utilice la instrucción "OPC_UA_MethodGetHandleList" en el programa de usuario para
obtener del servidor referencias numéricas (controladores/handles) para métodos
proporcionados por servidor para clientes OPC UA. OPC_UA_MethodGetHandleList permite
preparar las llamadas de métodos, ver ① en el siguiente gráfico.
La instrucción devuelve controladores para los métodos de servidor.

Programación del PLC
Manual de programación y manejo, 11/2019

4255

Instrucciones
4.1 Instrucciones





23&B8$B'LVFRQQHFW

23&B8$B&RQQHFW
23&B8$B1DPHVSDFH*HW,QGH[/LVW
23&B8$B0HWKRG*HW+DQGOH/LVW

①
②
③

23&B8$B0HWKRG&DOO

23&B8$B0HWKRG5HOHDVH+DQGOH/LVW

Instrucciones para preparar las llamadas de métodos
Llamadas de métodos
Instrucciones para "Clean-up" una vez ejecutadas las llamadas de métodos

Parámetros de "OPC_UA_MethodGetHandleList"
Tabla 4-81

Los parámetros de la instrucción "OPC_UA_MethodGetHandleList"

Parámetro

Declaración en
el área

Tipo de datos

Significado

REQ

Input

BOOL

Un flanco ascendente 0 → 1 en el
parámetro dispara la ejecución de la
instrucción.

ConnectionHdl

Input

DWORD

Identificación unívoca de una cone‐
xión establecida.
El controlador (handle) se obtiene
con la instrucción AUTOHOTSPOT.

NodeIDCount

Input

UINT

Número de elementos en los pará‐
metros ObjectNodeIDs o Methode‐
NodeIDs

ObjectNodeIDs

InOut

VARIANT

Puntero hacia un array con elemen‐
tos de tipo AUTOHOTSPOT.
El array contiene los ID de nodo (No‐
deIDs) de los objetos (carpetas) en
los que se encuentran los métodos
correspondientes.

MethodNodeIDs

InOut

VARIANT

Puntero hacia un array con elemen‐
tos de tipo AUTOHOTSPOT.
El array contiene los ID de nodo (No‐
deIDs) de los métodos para los que
el servidor consulta controladores
(handles).

4256

Timeout

Input

TIME

Intervalo de tiempo máximo en mili‐
segundos para ejecutar la instruc‐
ción. Consulte también la explica‐
ción de este parámetro en AUTO‐
HOTSPOT

NamespaceIndexCount

Input

UINT

Número de elementos del array en el
parámetro NamespaceIndexes.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración en
el área

Tipo de datos

Significado

NamespaceIndexes

InOut

VARIANT

Puntero a un array del tipo UINT.
Este parámetro no es necesario si
no hay ningún elemento en el pará‐
metro NamespaceIndexCount (Na‐
mespaceIndexCount = 0)..
El array se utiliza para que en el pa‐
rámetro NodeIDs se asignen índices
nuevos a los índices del espacio de
nombres.
Ejemplo:
Si en NamespaceIndexes[4] figura
el valor 10, a todos los NodeIds del
parámetro "NodeIDs" que hasta en‐
tonces tenían el índice de espacio
de nombres 4 se les asignará el ín‐
dice de espacio de nombres 10.

Done

Output

BOOL

Estado de ejecución:
● 0: Ejecución de la instrucción
interrumpida, no finalizada o no
iniciada.
● 1: Ejecución de la instrucción
finalizada sin errores

Busy

Output

BOOL

Parámetro sobre el estado de la eje‐
cución:
● 0: La instrucción no se está
ejecutando
● 1: Instrucción ejecutándose en
estos momentos

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error.
Consulte el parámetro "Status".

Status

Output

DWORD

Causa del error, consulte más abajo
"Números de error de Status"

StatusList

InOut

VARIANT

Puntero a un array del tipo DWORD.
El array contiene los códigos de
error de los diferentes métodos, con‐
sulte más abajo "Números de error
de NodeStatusList".
Para cada método se indica si se le
ha podido asignar un controlador.

MethodHdls

InOut

VARIANT

Puntero a un array del tipo DWORD.
El array contiene los controladores
(handles) de los diferentes métodos
(NodeIDs) que ha devuelto el servi‐
dor OPC UA.

Programación del PLC
Manual de programación y manejo, 11/2019

4257

Instrucciones
4.1 Instrucciones

Determinar los parámetros "ObjectNodeIDs" y "MethodNodeIDs"
ObjectNodeIDs
El OPC_UA_NodeId que debe registrarse en el parámetro "ObjectNodeIDs" se puede
determinar p. ej. con UaExpert:

MethodNodeIDs
Encontrará el OPC_UA_NodeId en el parámetro "MethodNodeIDs" aquí:

4258

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Números de error de Status
En la tabla siguiente encontrará una relación de códigos de error para esta instrucción:
Código de
Nombre del error
error (valores
hexadecima‐
les)

Explicación

0000_0000

OpcUa_Good

Instrucción finalizada correctamente

8003_0000

OpcUa_BadOutOfMemory

No hay memoria disponible para el cliente OPC
UA.
Como el cliente OPC UA y el servidor OPC UA
comparten un área de memoria es necesario re‐
ducir la memoria necesaria del servidor.
Para ello, existen las siguientes posibilidades:
● Liberar menos variables PLC para OPC UA.
● Reducir el número de clientes OPC UA
conectados actualmente con el servidor.
● Crear menos suscripciones.

8009_0000

OpcUa_BadUnknownResponse

El servidor no responde con el número esperado
de resultados

800A_0000

OpcUa_BadTimeout

Se ha producido un timeout de red.
Posibles causas:
● La conexión al servidor OPC UA es
demasiado lenta (muy poca capacidad).
● La red está sobrecargada.
● El servidor OPC UA está disponible.
Posibles soluciones:
● Compruebe la URL del servidor OPC UA
● Aumente el intervalo de tiempo de timeout
(mayor valor para el parámetro Timeout del
bloque de función OPC_UA_Connect).

800D_0000

OpcUa_BadServerNotConnected

El servidor no está conectado o el controlador
(handle) de la conexión es incorrecto o no es vá‐
lido.

800F_0000

OpcUa_BadNothingToDo

No hay que hacer nada: el servidor OPC UA re‐
cibe una lista vacía sin instrucciones del cliente
OPC UA.

8010_0000

OpcUa_BadTooManyOperations

Se ha excedido el número de instrucciones
"OPC_UA_MethodGetHandleList" que pueden
llamarse simultáneamente por conexión (> 1);
consulte: AUTOHOTSPOT

8074_0000

OpcUa_BadTypeMismatch

Se utiliza un tipo de datos que no concuerda con
el tipo de datos en el servidor.

B080_0100

Simatic_BadType_VariantInput1

Tipo de datos incorrecto para el parámetro "Ob‐
jectNodeIDs".

B080_0200

Simatic_BadType_VariantInput2

Tipo de datos incorrecto para el parámetro "Met‐
hodNodeIDs".

Programación del PLC
Manual de programación y manejo, 11/2019

4259

Instrucciones
4.1 Instrucciones
Código de
Nombre del error
error (valores
hexadecima‐
les)

Explicación

B080_0300

Simatic_BadType_VariantInput3

Tipo de datos incorrecto para el parámetro "Na‐
menspaceIndexes".

B080_0400

Simatic_BadType_VariantInput4

Tipo de datos incorrecto para el parámetro "Sta‐
tusList".

B080_0500

Simatic_BadType_VariantInput5

Tipo de datos incorrecto para el parámetro "Met‐
hodHdls".

B080_1100

Simatic_ArrayElements_TooMany

Número máximo para lista de métodos
(Max_ELEMENTS_METHODLIST) rebasado.

B080_3100

Simatic_BadNumElements_Varian‐
tInput1

● Número incorrecto de elementos de Array en
el primer parámetro VARIANT
(VariantInput1):
NodeIDCount > número de elementos del
Array ObjectNodeIDs

B080_3200
B080_3300
B080_3400
B080_3500
General:
B080_3N00(
N=enésimo
Variant de la
instrucción)

Simatic_BadNumElements_Varian‐
tInput2
Simatic_BadNumElements_Varian‐
tInput3
Simatic_BadNumElements_Varian‐
tInput4
Simatic_BadNumElements_Varian‐
tInput5
General:
Simatic_BadNumElements_Varian‐
tInputN
(N=enésimo Variant de la instruc‐
ción)

● Número incorrecto de elementos de Array en
el segundo parámetro VARIANT
(VariantInput2):
NodeIDCount > número de elementos del
Array MethodNodeIDs
● Número incorrecto de elementos de Array en
el tercer parámetro VARIANT
(VariantInput3):
NamespaceIndexCount > número de
elementos del Array NamespaceIndexes
● Número incorrecto de elementos de Array en
el cuarto parámetro VARIANT
(VariantInput4):
NodeIDCount > número de elementos del
Array StatusList
● Número incorrecto de elementos de Array en
el quinto parámetro VARIANT
(VariantInput5):
NodeIDCount > número de elementos del
Array MethodHdls
General: Número incorrecto de elementos en el
enésimo parámetro VARIANT.

4260

B080_C400

Simatic_ClientNotEnabled

El cliente OPC UA está desactivado.

B080_C500

Simatic_NothingToDo

No hay que hacer nada: La instrucción utiliza una
lista que no contiene ningún elemento.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
Nombre del error
error (valores
hexadecima‐
les)

Explicación

C080_C300

Se ha excedido el número máximo de instruccio‐
nes de cliente que pueden utilizarse simultánea‐
mente.

Simatic_OutOfResources

Posibles soluciones:
● Reduzca el número de instrucciones de
cliente paralelas de este tipo; consulte:
AUTOHOTSPOT
Encontrará más códigos de error en AUTOHOTSPOT

Números de error de StatusList
El parámetro StatusList contiene un código de error para cada ID de nodo (método).
La tabla siguiente explica los códigos de error:
Código de
Nombre del error
error (valores

Explicación

hexadecima‐
les)
0000_0000

OpcUa_Good

ningún error

8033_0000

OpcUa_BadNodeIdInvalid

La sintaxis del ID de nodo (NodeId) no es correcta.

8034_0000

OpcUa_BadNodeIdUnknown

El NodeId hace referencia a un nodo (un método)
que no existe en el servidor OPC UA.

8074_0000

OpcUa_BadTypeMismatch

El tipo de InputArguments/OutputArguments es
incorrecto

Encontrará más códigos de error en AUTOHOTSPOT

Requisitos
En la siguiente descripción se presupone lo siguiente:
● Se ha creado una interfaz de cliente; consulte "AUTOHOTSPOT".
● Se ha creado y parametrizado una conexión a un servidor OPC UA; consulte
"AUTOHOTSPOT".
Asimismo, para la instrucción "OPC_UA_MethodGetHandleList" deben cumplirse los
siguientes requisitos (ver gráfico superior):
● Existe un controlador para una conexión a un servidor OPC UA.
El controlador de la conexión se obtiene con la instrucción "OPC_UA_Connect".
● Índices de los espacios de nombres en los que se encuentran los métodos que se desea
llamar.
Los índices se obtienen con la instrucción AUTOHOTSPOT

Programación del PLC
Manual de programación y manejo, 11/2019

4261

Instrucciones
4.1 Instrucciones

Función de la instrucción
Para acelerar las llamadas de métodos, los servidores OPC UA utilizan referencias numéricas
(controladores o "handles") para métodos.
Estos controladores (handles) se obtienen del servidor OPC UA mediante la instrucción
"OPC_UA_MethodGetHandleList".
Estos controladores (handles) se requieren para la instrucción OPC UA para llamar métodos,
para "OPC_UA_MethodCall".

Cómo utilizar una conexión parametrizada
1. En el área "Árbol del proyecto", seleccione la CPU que deba actuar como cliente.
2. En la carpeta "Bloques de programa", seleccione el bloque de función que deba ejecutar la
instrucción del cliente.
En el ejemplo, el bloque de función se denomina "Call_OpenDoor_On_Productionline".
Lenguaje seleccionado: SCL.
3. Arrastre la instrucción "OPC_UA_MethodGetHandleList" desde la carpeta "Instrucciones >
Comunicación > OPC UA > Cliente OPC UA" hasta el editor con la función Drag & Drop.
4. Seleccione la llamada como multiinstancia.
STEP 7 crea una instancia de esta instrucción y la denomina
"OPC_UA_MethodGetHandleList_Instance".
5. Haga clic en el símbolo de "Iniciar configuración" junto a la instrucción
"OPC_UA_MethodGetHandleList_Instance".
STEP 7 abre la ficha "Configuración" de la ventana de inspección.
6. En "Seleccionar interfaz del cliente para la interfaz OPC UA", elija la interfaz de cliente que
desee emplear con la instrucción.
En el ejemplo, la interfaz de cliente se denomina "Productionline"; consulte
"AUTOHOTSPOT".
7. Haga clic en "Acceso a datos" y elija una lista de métodos.
En el ejemplo, la lista de métodos se denomina "MethodListOpenDoor".
STEP 7 asigna entonces automáticamente las variables adecuadas a casi todos los
parámetros de la instrucción.
8. Haga clic en "Parámetros del bloque" y asigne variables manualmente a los demás
parámetros.
STEP 7 inserta la variable seleccionada en la llamada de la función.

Llamada de la instrucción (primera llamada)
La siguiente sección del programa "Call_OpenDoor_On_Productionine" muestra cómo utilizar
la instrucción "OPC_UA_MethodGetHandleList".
El programa de ejemplo completo figura en el capítulo AUTOHOTSPOT
El programa de ejemplo se divide en varias secciones (Cases) mediante una instrucción CASE.

4262

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Aquí se ilustra el caso 3:
SCL
3: // case 3, get an handle for server method OpenDoor
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_MethodGetHandleList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeIDCount :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodCount,
ObjectNodeIDs :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".ObjectNodes,
MethodNodeIDs :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodNodes,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NamespaceIndexCount :=
"Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status,
StatusList := "Productionline_Data"."MethodListOpenDoor".MethodStatusList,
MethodHdls :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodHdls);

Ejecución asíncrona
La instrucción "OPC_UA_MethodGetHandleList" se ejecuta asíncronamente respecto al
programa de usuario y necesita varios ciclos de programa.
El estado actual de la ejecución se controla con los parámetros "Busy", "Done", "Error" y
"Status".
La ejecución asíncrona del programa se describe en el capítulo "Diferencia entre las
instrucciones que funcionan síncronamente y las que funcionan asíncronamente
(Página 618)".

Explicación de la llamada de la instrucción (primera llamada)
En la figura superior se ilustra el caso 3. Esta parte del programa registra el método
"OpenDoor" en el servidor OPC UA. Para ello se llama el método
"OPC_UA_MethodGetHandleList".
Si la instrucción aún no se ejecuta, #Busy es igual a FALSE, de modo que la variable "#Req"
adopta el valor TRUE. Con ello se inicia la instrucción. En el siguiente ciclo, #Req tiene el valor
FALSE.

Programación del PLC
Manual de programación y manejo, 11/2019

4263

Instrucciones
4.1 Instrucciones

Llamada de la instrucción (tratamiento de errores)
La figura siguiente ilustra la evaluación de los parámetros "Done" y "Error".
SCL
IF #Done = TRUE THEN
IF "Productionline_Data"."MethodListOpenDoor".MethodStatusList[0] = 0 THEN
//
one method
#State := #State + 1;
ELSE
#State := 100;
//In case 100, set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at MethodGetHandleList';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REG of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_MethodGetHandleList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeIDCount :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodCount,
ObjectNodeIDs :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".ObjectNodes,
MethodNodeIDs :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodNodes,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NamespaceIndexCount :=
"Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
StatusList := "Productionline_Data"."MethodListOpenDoor".MethodStatusList,
MethodHdls :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodHdls);
END_IF;

Explicación de la llamada de la instrucción (tratamiento de errores)
En caso de error, en el parámetro de salida "Error" se deposita el valor "TRUE". Entonces
"#State" adopta el valor 100. Este caso está previsto para el tratamiento de errores.
Si el parámetro de salida "Done" tiene el valor TRUE, la instrucción se ha ejecutado
correctamente.
Es posible que la instrucción se haya ejecutado correctamente (parámetro "Error" no activado,
parámetro "Done" activado), pero que no se haya podido devolver ningún controlador (handle)
para un método.

4264

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Por este motivo, en el ejemplo se comprueba si se ha devuelto un controlador (handle) para el
método "OpenDoor".
● Si el requisito se cumple el valor de la variable "#State" aumenta en uno. De este modo, en
el siguiente ciclo se ejecuta la siguiente sección del programa (caso 4: llamar método). El
caso 4 se describe en OPC_UA_MethodCall: llamar método (Página 4265).
● Si la condición no se cumple, se considera un error y #State recibe el valor 100. En el
siguiente ciclo se ejecuta el caso de error.
Nota
Si se registran varios métodos con OPC_UA_MethodGetHandleList en la aplicación, puede ser
conveniente incrementar siempre #State en uno cuando #Done = TRUE y, solo antes de llamar
los distintos métodos con "OPC_UA_MethodCall" (en el caso 4), comprobar si se ha devuelto
un controlador (handle) válido para el método en cuestión.

OPC_UA_MethodCall: llamar método
Validez
La siguiente descripción de la instrucción "OPC_UA_MethodCall" se aplica a las CPU S7-1500
con versión de firmware V2.6 y superior.

Descripción
La instrucción "OPC_UA_MethodCall" del programa de usuario se emplea para llamar un
método en el servidor.
El gráfico siguiente ilustra la estructura de un programa de usuario. La instrucción
"OPC_UA_MethodCall" se encuentra en el área ②:





23&B8$B'LVFRQQHFW

23&B8$B&RQQHFW
23&B8$B1DPHVSDFH*HW,QGH[/LVW
23&B8$B0HWKRG*HW+DQGOH/LVW

①
②
③

23&B8$B0HWKRG&DOO

23&B8$B0HWKRG5HOHDVH+DQGOH/LVW

Instrucciones para preparar las llamadas de métodos
Llamadas de métodos
Instrucciones para "Clean-up" una vez ejecutadas las llamadas de métodos

Programación del PLC
Manual de programación y manejo, 11/2019

4265

Instrucciones
4.1 Instrucciones

Parámetros de "OPC_UA_MethodCall"
Tabla 4-82

Los parámetros de la instrucción "OPC_UA_MethodCall"

Parámetro

Declaración en
el área

Tipo de datos

Significado

REQ

Input

BOOL

Un flanco ascendente 0 → 1 en el
parámetro dispara la ejecución de la
instrucción.

ConnectionHdl

Input

DWORD

Identificación unívoca de una cone‐
xión establecida.
El controlador (handle) se obtiene
con la instrucción AUTOHOTSPOT.

Timeout

Input

TIME

Intervalo de tiempo máximo en mili‐
segundos para la ejecución de la ins‐
trucción.
Consulte también la explicación de
este parámetro en AUTOHOTSPOT.

MethodHdl

Input

DWORD

Controlador (handle) para el método
que se desea llamar.

InputArguments

InOut

VARIANT

Puntero a una variable con el tipo de
datos PLC (UDT) o STRUCT, que
coincide en número, orden y tipo de
datos con los parámetros de entrada
esperados.

OutputArguments

InOut

VARIANT

Puntero a una variable con el tipo de
datos PLC (UDT) o STRUCT, que
coincide en número, orden y tipo de
datos con los parámetros de salida
esperados.

Done

Output

BOOL

Estado de ejecución:
● 0: Ejecución de la instrucción
interrumpida, no finalizada o no
iniciada.
● 1: Ejecución de la instrucción
finalizada sin errores

Busy

Output

BOOL

Parámetro sobre el estado de la eje‐
cución:
● 0: La instrucción no se está
ejecutando
● 1: Instrucción ejecutándose en
estos momentos

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error.
Consulte el parámetro "Status".

4266

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración en
el área

Tipo de datos

Significado

Status

Output

DWORD

Causa del error, consulte más abajo
"Números de error de Status"

MethodResult

InOut

VARIANT

Puntero a una variable de tipo
DWORD que contiene el código de
error (Result) del método de servidor
llamado.
Este código de error lo proporciona
el programa de usuario del servidor
OPC UA. En el caso de una CPU
S7-1500 que actúa de servidor OPC
UA, es el parámetro "UAMethod_Re‐
sult" de la instrucción de servidor
"OPC_UA_ServerMethodPost", que
se lee mediante la instrucción de
cliente "OPC_UA_MethodCall".
Si la instrucción "OPC_UA_Method‐
Call" no se ha ejecutado correcta‐
mente (Error = true, Status <> 0), no
se activa ningún valor para Metho‐
dResult.

Números de error de Status
El parámetro Status informa sobre errores que se producen durante la ejecución de la
instrucción.
La tabla siguiente explica los códigos de error:
Código de error
(valores hexade‐
cimales)

Nombre del error

Explicación

0000_0000

OpcUa_Good

Instrucción finalizada correctamente

8003_0000

OpcUa_BadOutOfMemory

No hay memoria disponible para el cliente
OPC UA.
Como el cliente OPC UA y el servidor
OPC UA comparten un área de memoria
es necesario reducir la memoria necesa‐
ria del servidor.
Para ello, existen las siguientes posibili‐
dades:
● Liberar menos variables PLC para
OPC UA.
● Reducir el número de clientes OPC
UA conectados actualmente con el
servidor.
● Crear menos suscripciones.

8006_0000

OpcUa_BadEncodingError

Error al descodificar el OutputArgument

8009_0000

OpcUa_BadUnknownResponse

El servidor no responde con el número
esperado de resultados

Programación del PLC
Manual de programación y manejo, 11/2019

4267

Instrucciones
4.1 Instrucciones
Código de error
(valores hexade‐
cimales)

Nombre del error

Explicación

800A_0000

OpcUa_BadTimeout

Se ha producido un timeout de red.
Posibles causas:
● La conexión al servidor OPC UA es
demasiado lenta (muy poca
capacidad).
● La red está sobrecargada.
● El servidor OPC UA no está disponible
Posibles soluciones:
● Compruebe la URL del servidor OPC
UA
● Aumente el intervalo de tiempo de
timeout (mayor valor para el
parámetro Timeout del bloque de
función OPC_UA_Connect).

800D_0000

OpcUa_BadServerNotConnected

El servidor no está conectado o el contro‐
lador (handle) de la conexión es incorrec‐
to o no es válido.

800F_0000

OpcUa_BadNothingToDo

No hay que hacer nada: el servidor OPC
UA recibe una lista vacía sin instruccio‐
nes del cliente OPC UA.

8010_0000

OpcUa_BadTooManyOperations

Se ha excedido el número de instruccio‐
nes "OPC_UA_MethodCall" que pueden
llamarse simultáneamente por conexión
(> 5); consulte:
AUTOHOTSPOT

8034_0000

BadNodeIdUnknown

The node id refers to a node that does not
exist in the server address space.
Posiblemente, el NamespaceIndex del
NodeId indicado no exista. Si se muestra
el código de error al llamar la instrucción
OPC_UA_MethodCall:
Otra causa posible es el uso de ID de ob‐
jeto no válidas en la llamada anterior de
OPC_UA_MethodGetHandleList. La ins‐
trucción OPC_UA_MethodGetHandleList
no evalúa los ID de objeto.

4268

8074_0000

OpcUa_BadTypeMismatch

El tipo del argumento Variant es incorrec‐
to.

8075_0000

OpcUa_BadMethodInvalid

No existe ningún método registrado para
el MethodHdl indicado.

8076_0000

BadArgumentsMissing

El cliente no ha especificado todos los ar‐
gumentos de entrada especificados.

80AB_0000

OpcUa_BadInvalidArgument

El tipo de InputArguments es incorrecto.

B080_0100

Simatic_BadType_VariantInput1

Tipo de datos incorrecto para el paráme‐
tro "MethodResult", al que señala el pri‐
mer parámetro Variant de la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error
(valores hexade‐
cimales)

Nombre del error

Explicación

B080_0200

Simatic_BadType_VariantInput2

Tipo de datos incorrecto para el paráme‐
tro "InputArguments", al que señala el se‐
gundo parámetro Variant de la instruc‐
ción.

B080_0300

Simatic_BadType_VariantInput3

Tipo de datos incorrecto para el paráme‐
tro "OutputArguments", al que señala el
tercer parámetro Variant de la instrucción.

B080_1100

Simatic_ArrayElements_TooMany

Código de error general. Ocurre cuando
un array tiene demasiados elementos.

B080_C400

Simatic_ClientNotEnabled

El cliente OPC UA está desactivado.

B080_C500

Simatic_NothingToDo

No hay que hacer nada: La instrucción
utiliza una lista que no contiene ningún
elemento.

C080_C300

Simatic_OutOfResources

Se ha excedido el número máximo de ins‐
trucciones de cliente que pueden utilizar‐
se simultáneamente.
Posibles soluciones:
● Reduzca el número de instrucciones
de cliente paralelas de este tipo;
consulte:
AUTOHOTSPOT

Encontrará más códigos de error en AUTOHOTSPOT

Requisitos
En la siguiente descripción se presupone lo siguiente:
● Se ha creado una interfaz de cliente; consulte "AUTOHOTSPOT"
● Se ha creado y parametrizado una conexión a un servidor OPC UA; consulte
"AUTOHOTSPOT".
Asimismo, para la instrucción "OPC_UA_MethodCall" deben cumplirse los siguientes
requisitos (ver gráfico superior):
● Existe un controlador para una conexión a un servidor OPC UA.
El controlador (handle) de la conexión se obtiene con la instrucción; consulte
AUTOHOTSPOT.
● Índices de los espacios de nombres en los que se encuentran los métodos que se desea
llamar con el cliente.
Los índices se obtienen con la instrucción "OPC_UA_NamespaceGetIndexList".
Un controlador (handle) para el método que desee llamar en el programa de usuario.
El controlador (handle) se obtiene con la instrucción; consulte AUTOHOTSPOT.

Función de la instrucción
La instrucción "OPC_UA_MethodCall" se utiliza para llamar un método que está habilitado en
un servidor OPC UA.

Programación del PLC
Manual de programación y manejo, 11/2019

4269

Instrucciones
4.1 Instrucciones

Cómo utilizar una conexión parametrizada
1. En el área "Árbol del proyecto", seleccione la CPU que deba actuar como cliente.
2. En la carpeta "Bloques de programa", seleccione el bloque de función que deba ejecutar la
instrucción del cliente.
En el ejemplo, el bloque de función se denomina "Call_OpenDoor_On_Productionline".
Lenguaje seleccionado: SCL.
3. Arrastre la instrucción "OPC_UA_MethodCall" desde la carpeta "Instrucciones >
Comunicación > OPC UA > Cliente OPC UA" hasta el editor con la función Drag & Drop.
4. Seleccione la llamada como multiinstancia.
STEP 7 crea una instancia de esta instrucción y la denomina
"OPC_UA_MethodCall_Instance".
5. Haga clic en el símbolo de "Iniciar configuración" junto a la instrucción
"OPC_UA_MethodCall_Instance".
STEP 7 abre la ficha "Configuración" de la ventana de inspección.
6. En "Seleccionar interfaz del cliente para la interfaz OPC UA", elija la interfaz de cliente que
desee emplear con la instrucción.
En el ejemplo, la interfaz de cliente se denomina "Productionline".
7. Haga clic en "Acceso a datos" y elija una lista de métodos.
En el ejemplo, la lista de métodos se denomina "MethodListOpenDoor".
STEP 7 asigna automáticamente variables a casi todos los parámetros de la instrucción,
pero no a los parámetros Busy, Done, Error.
8. Cree las variables locales para los parámetros que aún no han recibido valores.
9. Haga clic en "Parámetros del bloque" y asigne las variables locales al resto de parámetros.
STEP 7 inserta la variable seleccionada en la llamada de la función.

Llamada de la instrucción (primera llamada)
La siguiente sección del programa "Call_OpenDoor_On_Productionine" muestra cómo utilizar
la instrucción "OPC_UA_MethodCall".
El programa de ejemplo completo figura en el capítulo AUTOHOTSPOT.
El programa de ejemplo se divide en varias secciones (Cases) mediante una instrucción CASE.

4270

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Aquí se ilustra el caso 4:
SCL
4: // case 4, call method OpenDoor
IF #Init_Method_InputParameter = TRUE THEN
#Init_Method_InputParameter := FALSE;
//for our server method at Productionline, we set input parameters to 1
"Productionline_Data".MethodListOpenDoor.Method.Inputs.Number := 1;
END_IF;
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_MethodCall_Instance(REQ := #Req,
ConnectionHdl:="Productionline_Configuration".Connection.ConnectionHdl,
Timeout := "Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
MethodHdl :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodHdls[0],
Status => "Productionline_Data"."MethodListOpenDoor".MethodStatusList[0],
InputArguments := "Productionline_Data"."MethodListOpenDoor"."Method".Inputs,
OutputArguments := "Productionline_Data"."MethodListOpenDoor"."Method".Outputs,
MethodResult := "Productionline_Data"."MethodListOpenDoor".MethodResultList[0],
Done => #Done,
Busy => #Busy,
Error => #Error);
//"Productionline_Data"."MethodListOpenDoor".MethodResultList[0]] contains
//the status/error codes of the server method
//which was run on the connected CPU as user program
//These codes are defined as follows:
//
//
Good: 0x0000_0000 TO 0x3FFF_ FFFF
//
Uncertain: 0x4000_0000 TO 0x7FFF_FFFF
//
Bad: 0x8000_0000 TO 0xFFFF_FFFF

Ejecución asíncrona
La instrucción "OPC_UA_MethodCall" se ejecuta asíncronamente respecto al programa de
usuario y necesita varios ciclos de programa.
El estado actual de la ejecución se controla con los parámetros "Busy", "Done", "Error" y
"Status".
La ejecución asíncrona del programa se describe en el capítulo "Diferencia entre las
instrucciones que funcionan síncronamente y las que funcionan asíncronamente
(Página 618)".

Explicación de la llamada de la instrucción (primera llamada)
En la figura superior se ilustra el caso 4. Esta sección del programa llama el método de servidor
"OpenDoor" en el servidor OPC UA.
Para ello, la instrucción "OPC_UA_MethodCall" recibe el controlador (handle) para el método
de servidor y los parámetros de entrada.

Programación del PLC
Manual de programación y manejo, 11/2019

4271

Instrucciones
4.1 Instrucciones
En el ejemplo solo se utiliza el parámetro de entrada "Number". El valor se pone a 1 para que
se ejecute el método de servidor.

Llamada de la instrucción (tratamiento de errores)
La figura siguiente ilustra la evaluación de los parámetros "Done" y "Error".
SCL
IF #Done = TRUE THEN
IF "Productionline_Data".MethodListOpenDoor.MethodResultList[0] < 16#8000_0000 THEN
#State := #State + 1;
ELSE
//server method did not run successfully
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#Output_Error_Message := WString#' Error at server method';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := "Productionline_Data".MethodListOpenDoor.MethodStatusList[0];
#OPC_UA_MethodCall_Instance(REQ := #Req,
ConnectionHdl:="Productionline_Configuration".Connection.ConnectionHdl,
Timeout := "Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
MethodHdl :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodHdls[0],
Status => "Productionline_Data"."MethodListOpenDoor".MethodStatusList[0],
InputArguments := "Productionline_Data"."MethodListOpenDoor"."Method".Inputs,
OutputArguments := "Productionline_Data"."MethodListOpenDoor"."Method".Outputs,
MethodResult := "Productionline_Data"."MethodListOpenDoor".MethodResultList[0],
Done => #Done,
Busy => #Busy,
Error => #Error);
END_IF;

Explicación de la llamada de la instrucción (tratamiento de errores)
Si el parámetro de salida "Done" tiene el valor TRUE, la instrucción "OPC_UA_MethodCall" se
ha ejecutado correctamente.
Compruebe también si el método llamado en el servidor OPC UA "Productionline" se ha
ejecutado correctamente. Esto ocurre cuando el parámetro "MethodResult" contiene un valor
inferior a 16#8000_0000.
Si la ejecución es correcta, el valor de la variable "#State" aumenta en uno. De este modo, en
el siguiente ciclo se ejecuta la siguiente sección del programa (caso 5).
El caso 5 se describe en OPC_UA_MethodReleaseHandleList: habilitar controladores para
llamadas de método (Página 4273).

4272

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En caso de fallo de la instrucción "OPC_UA_MethodCall", en el parámetro de salida "Error" se
muestra el valor TRUE. Con ello, el valor de la variable "#State" adopta el valor 100. Este caso
está previsto para el tratamiento de errores.

OPC_UA_MethodReleaseHandleList: habilitar controladores para llamadas de método
Validez
La siguiente descripción de la instrucción "OPC_UA_MethodReleaseHandleList" se aplica a
las CPU S7-1500 con versión de firmware V2.6 y superior.

Descripción
Un ejemplo de programación muestra cómo utilizar la instrucción manualmente en el lenguaje
de programación SCL.
Este capítulo parte del principio de que para la comunicación OPC UA se crea y parametriza
una interfaz cliente, consulte: AUTOHOTSPOT. Con este eficiente procedimiento los valores
se suministran automáticamente a la mayoría de los parámetros de la instrucción del cliente.
La instrucción "OPC_UA_MethodReleaseHandleList" del programa de usuario se emplea para
habilitar referencias numéricas (controladores o handles) para métodos.
OPC_UA_MethodReleaseHandleList sirve para habilitar controladores de métodos; véase ③
en el siguiente gráfico.





23&B8$B'LVFRQQHFW

23&B8$B&RQQHFW
23&B8$B1DPHVSDFH*HW,QGH[/LVW
23&B8$B0HWKRG*HW+DQGOH/LVW

①
②
③

23&B8$B0HWKRG&DOO

23&B8$B0HWKRG5HOHDVH+DQGOH/LVW

Instrucciones para preparar las llamadas de métodos
Llamadas de métodos
Instrucciones para "Clean-up" una vez ejecutadas las llamadas de métodos

Programación del PLC
Manual de programación y manejo, 11/2019

4273

Instrucciones
4.1 Instrucciones

Parámetros de "OPC_UA_MethodReleaseHandleList"
Tabla 4-83

Los parámetros de la instrucción "OPC_UA_MethodReleaseHandleList"

Parámetro

Declaración en
el área

Tipo de datos

Significado

REQ

Input

BOOL

Un flanco ascendente 0 → 1 en el
parámetro dispara la ejecución de la
instrucción.

ConnectionHdl

Input

DWORD

Identificación unívoca de una cone‐
xión establecida.
El controlador (handle) se obtiene
con la instrucción AUTOHOTSPOT.

Timeout

Input

TIME

Intervalo de tiempo máximo en mili‐
segundos para la ejecución de la ins‐
trucción.
Consulte también la explicación de
este parámetro en AUTOHOTSPOT.

MethodHdlCount

Input

UINT

Número de elementos en el paráme‐
tro MethodHdls

MethodHdls

InOut

VARIANT

Puntero a un array del tipo DWORD.
El array contiene los controladores
(handles) de los diferentes métodos
(NodeIds) que van a habilitarse.

StatusList

InOut

VARIANT

Puntero a un array del tipo DWORD.
El array contiene los códigos de
error de los diferentes métodos, con‐
sulte más abajo "Números de error
de NodeStatusList".
Para cada método se indica si se ha
podido habilitar un controlador (han‐
dle) correctamente.

Done

Output

BOOL

Estado de ejecución:
● 0: Ejecución de la instrucción
interrumpida, no finalizada o no
iniciada.
● 1: Ejecución de la instrucción
finalizada sin errores

Busy

Output

BOOL

Parámetro sobre el estado de la eje‐
cución:
● 0: La instrucción no se está
ejecutando
● 1: Instrucción ejecutándose en
estos momentos

4274

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración en
el área

Tipo de datos

Significado

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error.
Consulte el parámetro "Status".

Status

Output

DWORD

Causa del error, consulte más abajo
"Números de error de Status"

Números de error de Status
En la tabla siguiente encontrará una relación de códigos de error para esta instrucción:
Código de
Nombre del error
error (valores
hexadecima‐
les)

Explicación

0000_0000

OpcUa_Good

Instrucción finalizada correctamente

8003_0000

OpcUa_BadOutOfMemory

No hay memoria disponible para el cliente OPC
UA.
Como el cliente OPC UA y el servidor OPC UA
comparten un área de memoria es necesario re‐
ducir la memoria necesaria del servidor.
Para ello, existen las siguientes posibilidades:
● Liberar menos variables PLC para OPC UA.
● Reducir el número de clientes OPC UA
conectados actualmente con el servidor.
● Crear menos suscripciones.

800A_0000

OpcUa_BadTimeout

Se ha producido un timeout de red.
Posibles causas:
● La conexión al servidor OPC UA es
demasiado lenta (muy poca capacidad).
● La red está sobrecargada.
● El servidor OPC UA está disponible.
Posibles soluciones:
● Compruebe la URL del servidor OPC UA
● Aumente el intervalo de tiempo de timeout
(mayor valor para el parámetro Timeout del
bloque de función OPC_UA_Connect).

800D_0000

OpcUa_BadServerNotConnected

El servidor no está conectado o el controlador
(handle) de la conexión es incorrecto o no es vá‐
lido.

800F_0000

OpcUa_BadNothingToDo

No hay que hacer nada: el servidor OPC UA re‐
cibe una lista vacía sin instrucciones del cliente
OPC UA.

Programación del PLC
Manual de programación y manejo, 11/2019

4275

Instrucciones
4.1 Instrucciones
Código de
Nombre del error
error (valores
hexadecima‐
les)

Explicación

8010_0000

OpcUa_BadTooManyOperations

Se ha excedido el número de instrucciones
"OPC_UA_MethodReleaseHandleList" que pue‐
den llamarse simultáneamente por conexión (>
1); consulte: AUTOHOTSPOT

B080_0100

Simatic_BadType_VariantInput1

Tipo de datos incorrecto para el parámetro "Met‐
hodHdls".

B080_0200

Simatic_BadType_VariantInput2

Tipo de datos incorrecto para el parámetro "Sta‐
tusList".

B080_1100

Simatic_ArrayElements_TooMany

MethodHdlCount > MAX_ELEMENTS_METHOD

B080_3100

BadNumElements_VariantInput1

MethodHdlCount > número de elementos del
array del parámetro "MethodHdls".

B080_3200

BadNumElements_VariantInput2

MethodHdlCount > número de elementos del
array del parámetro "StatusList".

B080_C400

Simatic_ClientNotEnabled

El cliente OPC UA está desactivado.

B080_C500

Simatic_NothingToDo

No hay que hacer nada: La instrucción utiliza una
lista que no contiene ningún elemento.

C080_C300

Simatic_OutOfResources

Se ha excedido el número máximo de instruccio‐
nes de cliente que pueden utilizarse simultánea‐
mente.
Posibles soluciones:
● Reduzca el número de instrucciones de
cliente paralelas de este tipo; consulte:
AUTOHOTSPOT

Encontrará más códigos de error en AUTOHOTSPOT

Números de error de "StatusList"
El parámetro "StatusList" contiene un código de error para cada controlador.
La tabla siguiente explica los códigos de error:
Código de error
(valores

Nombre del error

Explicación

0000_0000

OpcUa_Good

ningún error

8034_0000

OpcUa_BadNodeIdUnknown

Se desconoce el controlador de método trans‐
ferido.

hexadecimales)

Encontrará más códigos de error en AUTOHOTSPOT

4276

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Requisitos
En la siguiente descripción se presupone lo siguiente:
● Se ha creado una interfaz de cliente; consulte "AUTOHOTSPOT".
● Se ha creado y parametrizado una conexión a un servidor OPC UA; consulte
"AUTOHOTSPOT".
Asimismo, para la instrucción "OPC_UA_MethodReleaseHandleList" deben cumplirse los
siguientes requisitos (ver gráfico superior):
● Existe un controlador para una conexión a un servidor OPC UA.
El controlador (handle) de la conexión se obtiene con la instrucción AUTOHOTSPOT.
● Una lista de controladores de métodos que ya no se desea llamar en el programa de
usuario.
Esta lista de controladores (handles) se obtiene con la instrucción AUTOHOTSPOT
● Opcional (aquí no es necesario): Índices de los espacios de nombres en los que se
encuentran los métodos.
Los índices se obtienen con la instrucción AUTOHOTSPOT.

Función de la instrucción
Se llama la instrucción "OPC_UA_MethodReleaseHandleList" para liberar controladores de
métodos que ya no son necesarios en el programa.

Cómo utilizar una conexión parametrizada
1. En el área "Árbol del proyecto", seleccione la CPU que deba actuar como cliente.
2. En la carpeta "Bloques de programa", seleccione el bloque de función que deba ejecutar la
instrucción del cliente.
En el ejemplo, el bloque de función se denomina "Call_OpenDoor_On_Productionline".
Lenguaje seleccionado: SCL.
3. Arrastre la instrucción "OPC_UA_MethodReleaseHandleList" desde la carpeta
"Instrucciones > Comunicación > OPC UA > Cliente OPC UA" hasta el editor con la función
Drag & Drop.
4. Seleccione la llamada como multiinstancia.
STEP 7 crea una instancia de esta instrucción y la denomina
"OPC_UA_MethodReleaseHandleList_Instance".
5. Haga clic en "OPC_UA_MethodReleaseHandleList_Instance".
STEP 7 abre la "Configuración".
6. En "Seleccionar interfaz del cliente para la interfaz OPC UA", elija la interfaz de cliente que
desee emplear con la instrucción.
En el ejemplo, la interfaz de cliente que se había creado se denomina "Productionline";
consulte "AUTOHOTSPOT".
7. Haga clic en "Acceso a datos" y elija una lista de métodos.
En el ejemplo, la lista de métodos se denomina "MethodListOpenDoor".
STEP 7 asigna automáticamente variables a casi todos los parámetros de la instrucción,
pero no a los parámetros Busy, Done, Error.

Programación del PLC
Manual de programación y manejo, 11/2019

4277

Instrucciones
4.1 Instrucciones
8. Cree las variables locales para los parámetros que aún no han recibido valores.
9. Haga clic en "Parámetros del bloque" y asigne variables manualmente a los demás
parámetros.
STEP 7 inserta la variable seleccionada en la llamada de la función.

Llamada de la instrucción (primera llamada)
La siguiente sección del programa "Call_OpenDoor_On_Productionine" muestra cómo utilizar
la instrucción "OPC_UA_MethodReleaseHandleList".
El programa de ejemplo completo figura en el capítulo AUTOHOTSPOT
El programa de ejemplo se divide en varias secciones (Cases) mediante una instrucción CASE.
Aquí se ilustra el caso 5:
SCL
5: // case 5, release method handle
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_MethodReleaseHandleList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout := "Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
MethodHdlCount :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodCount,
MethodHdls :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodHdls,
StatusList := "Productionline_Data"."MethodListOpenDoor".MethodStatusList,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);

Ejecución asíncrona
La instrucción "OPC_UA_MethodReleaseHandleList" se ejecuta asíncronamente respecto al
programa de usuario y necesita varios ciclos de programa.
El estado actual de la ejecución se controla con los parámetros "Busy", "Done", "Error" y
"Status".
La ejecución asíncrona del programa se describe en el capítulo "Diferencia entre las
instrucciones que funcionan síncronamente y las que funcionan asíncronamente
(Página 618)".

Explicación de la llamada de la instrucción (primera llamada)
En la figura superior se ilustra el caso 5. Este extracto de programa vuelve a liberar el
controlador (handle) para un método de servidor.
En el ejemplo se transfiere al parámetro "MethodHdls" el controlador (handle) para el método
de servidor "OpenDoor".

4278

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si este controlador (handle) no se puede liberar, el parámetro "StatusList" contiene un código
de error.

Llamada de la instrucción (tratamiento de errores)
La figura siguiente ilustra la evaluación de los parámetros "Done" y "Error".
SCL
IF #Done = TRUE THEN
#Mem_Status := #Status;
IF "Productionline_Data"."MethodListOpenDoor".MethodStatusList[0] = 0 THEN
#State := #State + 1;
ELSE
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
Mem_Status := #Status;
#Output_Error_Message := WString#'Error at MethodGetHandleList';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REG of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_MethodReleaseHandleList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout := "Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
MethodHdlCount :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodCount,
MethodHdls :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodHdls,
StatusList := "Productionline_Data"."MethodListOpenDoor".MethodStatusList);
END_IF;

Explicación de la llamada de la instrucción (tratamiento de errores)
En caso de fallo de la instrucción "OPC_UA_MethodReleaseHandleList", en el parámetro de
salida "Error" se muestra el valor TRUE. Con ello, el valor de la variable "#State" adopta el valor
100. Este caso está previsto para el tratamiento de errores. Además, el programa de ejemplo
llama la instrucción "OPC_UA_MethodReleaseHandleList" para poner el parámetro REQ a
FALSE.
Si el parámetro de salida "Done" tiene el valor TRUE, la instrucción
"OPC_UA_MethodReleaseHandleList" se ha ejecutado correctamente.
En el ejemplo se comprueba, además, si también se ha podido liberar el controlador (handle)
para el método de servidor "OpenDoor".
Si la ejecución es correcta, el valor de la variable "#State" aumenta en uno. De este modo, en
el siguiente ciclo se ejecuta la siguiente sección del programa (caso 6).

Programación del PLC
Manual de programación y manejo, 11/2019

4279

Instrucciones
4.1 Instrucciones
El caso 6 se describe en OPC_UA_Disconnect: cerrar la conexión (Página 4243).
Nota
El caso 6 sirve para liberar la conexión al servidor OPC UA. Con ello se liberan también todos
los demás recursos que el programa cliente había ocupado en el servidor. Si desea finalizar la
conexión al servidor, el programa de usuario puede ejecutar directamente el caso 6 y omitir el
caso 5.

Tipos de datos de sistema para instrucciones de clientes OPC UA
OPC_UA_SessionConnectInfo
OPC_UA_SessionConnectInfo
Consulte el significado de la información de conexión para el parámetro "SessionConnectInfo"
de la instrucción "OPC_UA_Connect" en la tabla siguiente.
Tabla 4-84

Parámetros del tipo de datos de sistema "OPC_UA_SessionConnectInfo"

Parámetro

Tipo de datos
S7

Significado

SessionName

WSTRING[64]

Nombre de la sesión que puede introducirse aquí. El parámetro
puede estar vacío.
Si no se indica ningún nombre, el servidor OPC UA adjudica un
nombre.
El nombre de sesión se utiliza p. ej. para identificar la conexión
con fines de diagnóstico.

ApplicationName

WSTRING[64]

Nombre del cliente OPC UA. El nombre de aplicación es un com‐
ponente de la ClientDescription, que a su vez es un componente
de la sesión (consulte SessionName). No es posible establecer
un ApplicationName unívoco para cada sesión. El STRING tiene
que estar vacío; de lo contrario se devuelve el código de error
"Simatic_BadValue_VariantInput2 (0xB080_2200)". Como Appli‐
cationName en SIMATIC se utiliza el nombre de aplicación con‐
figurado (parámetro CPU en el área OPC UA).

SecurityMsgMode

UDINT

Procedimiento de seguridad
● 0 = Mejor procedimiento posible. Atención: Este ajuste no
está permitido.
● 1 = None
● 2 = Sign
● 3 = Sign&Encrypt

4280

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de datos
S7

Significado

SecurityPolicy

UDINT

Perfil Security
● 0 = Mejor perfil posible. Atención: Este ajuste no está
permitido.
● 1 = Ningún perfil de seguridad
● 2 = Basic128Rsa15
● 3 = Basic256
● 4 = Basic256Sha256

ServerUri

STRING[254]

Solo relevante para conexiones a un servidor OPC UA a través
de un servidor de pasarela.
Las CPU con versión de firmware ≤V2.6 no son compatibles con
los servidores de pasarela. Por este motivo, el parámetro debe
ocuparse con un string vacío.

CheckServerCerti‐ BOOL
ficate

Si el bit está activado, el cliente compara el certificado enviado
por el servidor con los certificados de confianza configurados. A
la lista de certificados de confianza se accede a través de las
propiedades de la CPU cliente > área "Protección y seguridad" >
Administrador de certificados. Allí aparece la tabla "Certificados
de los dispositivos interlocutores", que tiene que rellenar.
El requisito para rellenarla es que los certificados necesarios se
hayan importado a través del administrador de certificados glo‐
bal (árbol del proyecto > Administrador de certificados > ficha
"Autoridades de certificación raíz y certificados de confianza").
Si el bit no está activado, el cliente no comprueba el certificado de
servidor.

TransportProfile

UDINT

1 = UATP_UATcp
Solo se soporta este perfil de transporte conforme a la especifi‐
cación PLCopen.

UserIdentityTo‐
kenType

UDINT

Datos de la autenticación de usuario: consulte la explicación bajo
esta tabla.

UserTokenPa‐
ram1

WSTRING[64]

El significado depende de UserIdentityTokenType (p. ej. nombre
de usuario).

UserTokenPa‐
ram2

WSTRING[64]

El significado depende de UserIdentityTokenType (p. ej., contra‐
seña).

Programación del PLC
Manual de programación y manejo, 11/2019

4281

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de datos
S7

Significado

CertificateID

UDINT

El ID del certificado que se utiliza para el cliente OPC UA.
El ID se encuentra en STEP 7 (TIA Portal), en "Ajustes globales
de seguridad" > "Administrador de certificados" > "Certificados
de dispositivo" y en las propiedades de la CPU (área "Protección
y seguridad" > "Administrador de certificados"). Allí aparece la
tabla "Certificados de dispositivo" con los ID de los certificados.
Para crear un certificado para el cliente, proceda del modo si‐
guiente:
1. Seleccione en el TIA Portal las propiedades de la CPU que se
utilizará como cliente.
2. Si para Usted es suficiente un certificado autofirmado, salte
este paso. Si desea utilizar un certificado firmado por una CA,
en "Protección y seguridad" > "Administrador de certificados"
> "Ajustes globales de seguridad" active la opción "Utilizar
ajustes globales de seguridad para el administrador de
certificados".
3. Navegue a la tabla "Certificados de dispositivos" y haga
doble clic en un campo vacío de la columna "Titular del
certificado".
En el margen izquierdo de la fila aparece un símbolo de
certificado.
4. Vuelva a hacer clic en el campo "Titular del certificado".
Se abre una lista desplegable y muestra los certificados de
dispositivo ya existentes.
5. Haga clic en el botón "Agregar".
Se muestra un cuadro de diálogo con posibilidades de ajuste
del certificado.
6. Seleccione "Cliente OPC UA" o "Cliente y servidor OPC UA"
como finalidad de uso y a continuación "Aceptar".

SessionTimeout

TIME

Intervalo de tiempo máximo durante el que puede mantenerse
una sesión después de que se haya interrumpido la conexión al
servidor OPC UA (en milisegundos).
Ajuste predeterminado: 20000 (20 segundos)

MonitorConnec‐
tion

TIME

Tiempo de vigilancia de la conexión (en milisegundos)
Intervalo de tiempo para comprobar una conexión a través de la
cual no se están transfiriendo datos.
Ajuste predeterminado: 5000 (5 segundos)

LocaleIDs

4282

ARRAY[1..5]
of STRING[6]

Identificador opcional de idioma y región conforme a RFC 3066.
0 = ningún LocaleId o uno desconocido.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro "UserIdentityTokenType"
La tabla siguiente muestra la relación entre los parámetros "UserIdentityTokenType",
"UserTokenParam1" y "UserTokenParam2" del tipo de datos de sistema
"UASessionConnectInfo":
UserIdentityTokenType

UserTokenParam1

UserTokenParam2

Descripción

0: Acceso anónimo

se ignora

se ignora

Cuenta de invitado, sin
autenticación

1: Acceso con nombre
de usuario y contraseña

Nombre de usuario

Contraseña

La contraseña se guar‐
da en texto plano en el
bloque de datos global
o bloque de instancia
correspondiente y pue‐
de leerse.
Recomendación: En su
lugar, utilice el tipo SI‐
MATIC-User.

42: SIMATIC User

Nombre de un usuario
que se ha configurado
con STEP 7.

se ignora

En el caso de un usua‐
rio SIMATIC, la contra‐
seña se carga en la
CPU cliente junto con
los demás datos de
usuario y los datos de
configuración.
De este modo, la con‐
traseña está protegida
de accesos externos. El
usuario SIMATIC debe
tener asignado el dere‐
cho de acceso a funcio‐
nes "Autenticación de
usuario del cliente OPC
UA" en el árbol del pro‐
yecto (Ajustes de segu‐
ridad > Usuarios y ro‐
les).
Cuando realice los ajus‐
tes de la autenticación
de usuario en la interfaz
de cliente OPC UA, elija
la opción "Usuario (TIA
Portal: Ajustes de segu‐
ridad)" e introduzca un
nombre de usuario que
ya esté configurado.

Consulte también
OPC_UA_Connect: crear una conexión (Página 4153)

Programación del PLC
Manual de programación y manejo, 11/2019

4283

Instrucciones
4.1 Instrucciones

OPC_UA_NodeId
OPC_UA_NodeId
Consulte en la tabla siguiente el significado de los parámetros de "OPC_UA_NodeId" para
identificar el nodo de destino en el servidor OPC UA. "OPC_UA_NodeId" suministra valores al
parámetro "NodeIDs" de la instrucción "OPC_UA_NodeGetHandleList".
Tabla 4-85

Parámetros del tipo de datos de sistema"OPC_UA_NodeId"

Parámetro

Tipo de datos S7

Significado

NamespaceIndex

UINT

Índice del espacio de nombres del nodo en el servidor
OPC UA.
Un nodo puede ser, por ejemplo, un objeto o una va‐
riable.

Identifier

WSTRING[254]

La denominación del nodo (objeto o variable) depende
del tipo de identificador:
● Identificador numérico: El nodo se designa con un
número, por ejemplo "12345678" (STRING con
DWORD convertido).
● Identificador de String: el nodo se designa con un
nombre, por ejemplo "MiVariable". Se distingue
entre mayúsculas y minúsculas.
● Respecto a la designación de nodos del tipo
"GUID" y "Opaque" ver más abajo.

IdentifierType

UDINT

Tipo de identificador
● 0: Identificador numérico
● 1: Identificador de String
● 2: GUID
● 3: Opaque

Identifier del IdentifierType "GUID"
Formato: {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}
Ejemplo de entrada del formato de IdentifierType GUID (2) en STEP 7:
WSTRING#'5ce9dbce-5d79-434c-9ac3-1cfba9a6e92c'

Identifier del IdentifierType "Opaque"
Los Opaque Identifier son identificadores con una secuencia de caracteres en orden
aparentemente aleatorio y sin una semántica reconocible a primera vista.
En OPC UA se puede generar un Identifier del tipo Opaque codificando un array de bytes
cualquiera de longitud determinada (p. ej. una secuencia de caracteres ASCII 'abcd' o el HEX
Pendant (0x61626364) Base64. Para la codificación Base64 hay disponibles numerosas
herramientas.
Ejemplo de formato del IdentifierType Opaque (3) en STEP 7 tras codificar el valor HEX:
WSTRING#'YWJjZA=='

4284

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El servidor muestra el valor no codificado del identificador, que en este caso es el valor HEX.

Consulte también
OPC_UA_NodeGetHandleList: recoger controladores para accesos de lectura y escritura
(Página 4173)

OPC_UA_NodeAdditionalInfo
OPC_UA_NodeAdditionalInfo
Especifica los tipos de atributo y el área de índices del nodo para el parámetro "NodeAddInfos"
de las instrucciones "OPC_UA_ReadList" y "OPC_UA_WriteList".
● El tipo de datos se utiliza para valores escalares y arrays unidimensionales.
Utilice el tipo de datos "OPC_UA_NodeAdditionalInfoExt" para leer una sección de un array
multidimensional (hasta seis dimensiones (matriz)).
Tenga en cuenta las indicaciones sobre AUTOHOTSPOT.
● El índice inicial debe ser mayor o igual a "0" y menor o igual al índice final.
● Ajustes para la lectura completa de listas de lectura compuestas por escalares y arrays:
Si tanto el índice inicial como el índice final tienen el valor 4_294_967_295 (UDINT_MAX),
el servidor ignora el valor de los índices inicial y final y lee escalares y arrays enteros;
consulte Lectura del área de array con OPC_UA_ReadList (Página 4212).
Tabla 4-86

Parámetros del tipo de datos de sistema "OPC_UA_NodeAdditionalInfo"

Parámetro

Tipo de datos Significado

AttributeId

UDINT

Indica qué atributo de un nodo se leerá (una variable).
Los ID de los atributos están definidos en el tipo de enumeración
de OPC UA "UAAttributeId".
Ejemplos:
● 5: Description (Descripción)
● 13: Value (Valor).
● 14: DataType (Tipo de datos)
● 15: ValueRank (número de dimensiones en el atributo Value)
● 16: ArrayDimensions (longitud de una dimensión, número de
elementos)
El valor predeterminado es 13 (value).

StartIndex

UDINT

Si AttributeId = 13: Índice inicial de un array. Se leen valores a
partir de este índice.

EndIndex

UDINT

Si AttributeId = 13: Índice final de un array. Se leen valores hasta
este índice.

Consulte también
OPC_UA_NodeAdditionalInfoExt (Página 4286)

Programación del PLC
Manual de programación y manejo, 11/2019

4285

Instrucciones
4.1 Instrucciones

OPC_UA_NodeAdditionalInfoExt
OPC_UA_NodeAdditionalInfoExt
Especifica el atributo del nodo y el área de índices para el parámetro "NodeAddInfos"
(instrucciones "OPC_UA_ReadList" y "OPC_UA_WriteList").
Tabla 4-87

Parámetros del tipo de datos de sistema "OPC_UA_NodeAdditionalInfoExt"

Parámetro

Tipo de datos Significado
S7

AttributeID

UDINT

Indica el atributo que debe leerse de un nodo (una variable) o
escribirse en él.

IndexRangeCount

UDINT

Número de las siguientes áreas de índices.

StartIndex1

UDINT

El índice a partir del que deben leerse o escribirse valores para la
dimensión 1 del array.

EndIndex1

UDINT

El índice hasta el que deben leerse o escribirse valores para la
dimensión 1 del array.

StartIndex2

UDINT

El índice a partir del que deben leerse o escribirse valores para la
dimensión 2 del array.

EndIndex2

UDINT

El índice hasta el que deben leerse o escribirse valores para la
dimensión 2 del array.

StartIndex3

UDINT

El índice a partir del que deben leerse o escribirse valores para la
dimensión 3 del array.

EndIndex3

UDINT

El índice hasta el que deben leerse o escribirse valores para la
dimensión 3 del array.

StartIndex4

UDINT

El índice a partir del que deben leerse o escribirse valores para la
dimensión 4 del array.

EndIndex4

UDINT

El índice hasta el que deben leerse o escribirse valores para la
dimensión 4 del array.

StartIndex5

UDINT

El índice a partir del que deben leerse o escribirse valores para la
dimensión 5 del array.

EndIndex5

UDINT

El índice hasta el que deben leerse o escribirse valores para la
dimensión 5 del array.

StartIndex6

UDINT

El índice a partir del que deben leerse o escribirse valores para la
dimensión 6 del array.

EndIndex6

UDINT

El índice hasta el que deben leerse o escribirse valores para la
dimensión 6 del array.

El valor predeterminado es 13 (Value).
No es necesario indicar las seis áreas de índices.

Consulte también
OPC_UA_NodeAdditionalInfo (Página 4285)

4286

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

OPC_UA_BrowsePath
OPC_UA_BrowsePath
Consulte en la tabla siguiente la estructura del tipo de datos de sistema
"OPC_UA_BrowsePath":
Tabla 4-88

Parámetros del tipo de datos de sistema "OPC_UA_BrowsePath"

Nombre

Tipo de datos

Significado

StartingNode

OPC_UA_NodeId

NodeId del nodo (o de la variable) en
el que empieza esta ruta.
Debe navegarse a partir de este nodo.

RelativePath

OPC_UA_RelativePath

La ruta relativa que debe recorrerse
en la navegación, consulte AUTO‐
HOTSPOT.

OPC_UA_RelativePath
OPC_UA_RelativePath
Consulte en la tabla siguiente la estructura del tipo de datos de sistema
"OPC_UA_RelativePath":
Tabla 4-89

Parámetros del tipo de datos de sistema "OPC_UA_RelativePath"

Nombre

Tipo de datos

Significado

NoOfElements

UINT

Número de elementos en Elements

Elements

Array [4] of OPC_UA_RelativePathEle‐
ment

Array con un máximo de cuatro ele‐
mentos del tipo OPC_UA_Relative‐
PathElement (Página 4288)

Programación del PLC
Manual de programación y manejo, 11/2019

4287

Instrucciones
4.1 Instrucciones

OPC_UA_RelativePathElement
OPC_UA_RelativePathElement
Consulte en la tabla siguiente la estructura del tipo de datos de sistema
"OPC_UA_RelativePathElement":
Tabla 4-90

Parámetros del tipo de datos de sistema "OPC_UA_RelativePathElement"

Nombre

Tipo de datos

Significado

ReferenceTypeId

OPC_UA_NodeId

El tipo de referencia que debe seguirse en es‐
te RelativePathElement.
Por defecto está ajustado el ReferenceTypeId
para referencias jerárquicas.

IsInverse

BOOL

IncludeSubtypes

BOOL

Si es TRUE, se sigue el sentido contrario.
El valor predeterminado es FALSE.
Si es TRUE, se siguen también los tipos de
referencia derivados del tipo indicado en Re‐
ferenceTypeId.
El valor predeterminado es TRUE.

TargetName

OPC_UA_QualifiedName

Consulte el tipo de datos de sistema AUTO‐
HOTSPOT

OPC_UA_QualifiedName
OPC_UA_QualifiedName
Consulte en la tabla siguiente la estructura del tipo de datos de sistema
"OPC_UA_QualifiedName":
Tabla 4-91

Parámetros del tipo de datos de sistema "OPC_UA_QualifiedName"

Nombre

Tipo de datos

Significado

NamespaceIndex

UINT

El índice del espacio de nombres del nombre.

Name

WSTRING[64]

BrowseName del nodo (o de la variable).

4288

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Códigos de error
Códigos de error de Siemens
Códigos de estado SIMATIC para instrucciones OPC UA
En la tabla siguiente encontrará los códigos de error de Siemens para las instrucciones del
cliente OPC UA:
Código de estado

Significado

B080_0100

BadType_VariantInput1:
El tipo de datos de la variable a la que señala el primer parámetro
Variant de la instrucción no es correcto.
Ejemplo:
En la instrucción "OPC_UA_Connect", el parámetro "ServerEnd‐
pointUrl" es el primer parámetro Variant.
La secuencia de VariantInput1 a VariantInput5 corresponde al or‐
den de los parámetros Variant en la documentación de la instrucción
OPC UA respectiva.
Si el primer parámetro Variant señala a una variable que tiene un
tipo de datos incorrecto, se devuelve el código de estado
"B080_0100".
El tipo de datos correcto está registrado en la tabla "Parámetros" de
la instrucción correspondiente.
En el ejemplo, puede consultar el tipo de datos de la tabla 'Paráme‐
tros de "OPC_UA_Connect"' en el capítulo sobre la instrucción
"OPC_UA_Connect: crear una conexión (Página 4153)".

B080_0200

BadType_VariantInput2.
El tipo de datos de la variable a la que señala el segundo parámetro
Variant de la instrucción no es correcto.

B080_0300

BadType_VariantInput3:
El tipo de datos de la variable a la que señala el tercer parámetro
Variant de la instrucción no es correcto.

B080_0400

BadType_VariantInput4:
El tipo de datos de la variable a la que señala el cuarto parámetro
Variant de la instrucción no es correcto.

B080_0500

BadType_VariantInput5:
El tipo de datos de la variable a la que señala el quinto parámetro
Variant de la instrucción no es correcto.

B080_3100

BadNumElements_VariantInput1:
El número de elementos en Variant 1 es inferior al número guardado
en el parámetro Count de la instrucción (p. ej., NodeIDCount en
OPC_UA_NodeGetHandleList o NamespaceUrisCount en
OPC_UA_NamespaceGetIndexList, etc.).

B080_3200

BadNumElements_VariantInput2:
El número de elementos en Variant 2 es inferior al número guardado
en el parámetro Count de la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

4289

Instrucciones
4.1 Instrucciones
Código de estado

Significado

B080_3300

BadNumElements_VariantInput3:
El número de elementos en Variant 3 es inferior al número guardado
en el parámetro Count de la instrucción.

B080_3400

BadNumElements_VariantInput4:
El número de elementos en Variant 4 es inferior al número guardado
en el parámetro Count de la instrucción.

B080_3500

BadNumElements_VariantInput5:
El número de elementos en Variant 5 es inferior al número guardado
en el parámetro Count de la instrucción.

B080_C400

Simatic_ClientNotEnabled:
El cliente OPC UA está desactivado.

B080_C500

SimaticNothingToDo:
Error al inicializar el cliente

B080_C600

ClientNotAvailable
Error al inicializar el cliente

B080_0B00

ArrayElements_TooMany:
El array posee demasiados elementos.

B080_1100

ArrayElements_TooMany:
Código de error general. Ocurre cuando un array tiene demasiados
elementos:
NamespaceUrisCount > MAX_ELEMENTS_NAMESPACES
NodeIDCount > MAX_ELEMENTS_NODELIST
BrowsePathscount > MAX_ELEMENTS_RELATIVEPATH
MethodHdlCount > MAX_ELEMENTS_METHODLIST
MAX_ELEMENTS_NAMESPACES = 20
MAX_ELEMENTS_NODELIST = 300
MAX_ELEMENTS_METHODLIST = 100
MAX_ELEMENTS_BROWSEPATH = 10

B080_1200

ArrayElements_TooFew

B080_2100

BadValue_VariantInput1:
El valor de la variable a la que señala el primer Variant de la ins‐
trucción no es correcto.

B080_2200

BadValue_VariantInput2:
El valor de la variable a la que señala el segundo Variant de la
instrucción no es correcto.

B080_2300

BadValue_VariantInput3:
El valor de la variable a la que señala el tercer Variant de la instruc‐
ción no es correcto.

B080_2400

BadValue_VariantInput4:
El valor de la variable a la que señala el cuarto Variant de la ins‐
trucción no es correcto.

B080_2500

BadValue_VariantInput5:
El valor de la variable a la que señala el quinto Variant de la ins‐
trucción no es correcto.

4290

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de estado

Significado

B080_B000

TooManyMethods:
Se ha excedido el número máximo de métodos de servidor o el
número máximo de instancias del método de servidor.
(Llamada de las instrucciones OPC_UA_ServerMethodPre,
OPC_UA_ServerMethodPost):
Para S7-1510 hasta S7-1513...: máx. 20
Para S7-1515, S7-1516...: máx. 50
Para S7-1517, S7-1518, S7-1507S...: máx. 100

C080_C300

InsufficientResources:
No hay recursos suficientes. Puede ser (a) error en la asignación de
memoria o (b) demasiadas instancias del SFB

Códigos de error de la OPC Foundation
Códigos de error
La tabla siguiente contiene los códigos de error de la OPC Foundation.
Los nombres y las explicaciones de los errores se indican en su versión original (inglés) y
puntualmente se complementan con información adicional.

Códigos de error

Estado "Good" (0000_0000 - 3FFF_FFFF)
Número de
error (hex)

Nombre

Significado

0000_0000

Good

Success, no error.

002D_0000

GoodSubscriptionTransfe‐
rred

The subscription was transferred to another session.

002E_0000

GoodCompletesAsynchro‐
nously

The processing will complete asynchronously.

002F_0000

GoodOverload

Sampling has slowed down due to resource limitations.

0030_0000

GoodClamped

The value written was accepted but was clamped.

0096_0000

GoodLocalOverride

The value has been overridden.

00A2_0000

GoodEntryInserted

The data or event was successfully inserted into the historical database.

00A3_0000

GoodEntryReplaced

The data or event field was successfully replaced in the historical database.

00A5_0000

GoodNoData

No data exists for the requested time range or event filter.

00A6_0000

GoodMoreData

The data or event field was successfully replaced in the historical database.

00A7_0000

GoodCommunicationEvent

The communication layer has raised an event.

00A8_0000

GoodShutdownEvent

The system is shutting down.

00A9_0000

GoodCallAgain

The operation is not finished and needs to be called again.

00AA_0000

GoodNonCriticalTimeout

A non-critical timeout occurred.

00BA_0000

GoodResultsMayBeIncom‐
plete

The server should have followed a reference to a node in a remote server but
did not. The result set may be incomplete.

Programación del PLC
Manual de programación y manejo, 11/2019

4291

Instrucciones
4.1 Instrucciones
Estado "Good" (0000_0000 - 3FFF_FFFF)
Número de
error (hex)

Nombre

Significado

00D9_0000

GoodDataIgnored

The request pecifies fields which are not valid for the EventType or cannot be
saved by the historian.

00DC_0000

GoodEdited

The value does not come from the real source and has been edited by the
server.

00DD_0000

GoodPostActionFailed

There was an error in execution of these post-actions.

00E0_0000

GoodDependentValueChan‐
ged

A dependent value has been changed but the change has not been applied to
the device.

Estado "Uncertain" (4000_0000 - 7FFF_FFFF)
Número de
error (hex)

Nombre

Significado

406C_0000

UncertainReferenceOutOf‐
Server

One of the references to follow in the relative path references to a node in the
address space in another server.

408F_0000

UncertainNoCommunication‐ Communication to the data source has failed. The variable value is the last
LastUsableValue
value that had a good quality.

4090_0000

UncertainLastUsableValue

Whatever was updating this value has stopped doing so.

4091_0000

UncertainSubstituteValue

The value is an operational value that was manually overwritten.

4092_0000

UncertainInitialValue

The value is an initial value for a variable that normally receives its value from
another variable.

4093_0000

UncertainSensorNotAccurate The value is at one of the sensor limits.

4094_0000

UncertainEngineeringUnit‐
sExceeded

The value is outside of the range of values defined for this parameter.

4095_0000

UncertainSubNormal

The value is derived from multiple sources and has less than the required
number of Good sources.

40A4_0000

UncertainDataSubNormal

The value is derived from multiple values and has less than the required num‐
ber of Good values.

40BC_0000

UncertainReferenceNotDele‐ The server was not able to delete all target references.
ted

40C0_0000

UncertainNotAllNodesAvaila‐ The list of references may not be complete because the underlying system is
ble
not available.

40DE_0000

UncertainDominantValue‐
Changed

The related EngineeringUnit has been changed but the Variable Value is still
provided based on the previous unit.

40E2_0000

UncertainDependentValue‐
Changed

A dependent value has been changed but the change has not been applied to
the device. The quality of the dominant variable is uncertain.

4292

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Estado "Bad" (8000_0000 - FFFF_FFFF)
Número de
error (hex)

Nombre

Significado

8001_0000

BadUnexpectedError

An unexpected error occurred

8002_0000

BadInternalError

An internal error occurred as a result of a programming or configuration error.
Causa posible:
Ha accedido en modo de escritura a un único elemento de una variable del tipo
de datos DTL. Los accesos de escritura a variables del tipo de datos DTL solo
son posibles a la estructura completa.

8003_0000

BadOutOfMemory

Not enough memory to complete the operation.
Causa posible:
Capacidad funcional máxima del servidor OPC UA rebasada
Solución:
Reduzca el número de elementos que inician sesión mediante OPC UA.
Utilice una herramienta de diagnóstico del servidor OPC UA (p. ej. UaExpert
de Unified Automation) para asegurarse de que no hay sesiones ni suscrip‐
ciones inactivas. Para contrarrestar el problema puede elegir timeouts ade‐
cuados (Subscription Timeout <= Session Timeout) en el cliente.
Consulte también la descripción de los mensajes de error OPC_UA_Connect:
crear una conexión (Página 4153).

8004_0000

BadResourceUnavailable

An operating system resource is not available

8005_0000

BadCommunicationError

A low level communication error occurred.
Causa posible:
La dirección de servidor (ServerEndpointURL) es incorrecta o incompleta.
Consulte también la explicación de este código de error en OPC_UA_Con‐
nect: crear una conexión (Página 4153)

8006_0000

BadEncodingError

Encoding halted because of invalid data in the objects being serialized.

8007_0000

BadDecodingError

Decoding halted because of invalid data in the stream.

8008_0000

BadEncodingLimitsExcee‐
ded

The message encoding/decoding limits imposed by the stack have been ex‐
ceeded.

8009_0000

BadUnknownResponse

An unrecognized response was received from the server.

80B8_0000

BadRequestTooLarge

The request message size exceeds limits set by the server.

80B9_0000

BadResponseTooLarge

The response message size exceeds limits set by the client.

800A_0000

BadTimeout

The operation timed out.
Consulte también el mensaje de error en OPC_UA_Connect: crear una cone‐
xión (Página 4153).

800B_0000

BadServiceUnsupported

The server does not support the requested service.

800C_0000

BadShutdown

The operation was cancelled because the application is shutting down.

800D_0000

BadServerNotConnected

The operation could not complete because the client is not connected to the
server.

800E_0000

BadServerHalted

The server has stopped and cannot process any requests.

800F_0000

BadNothingToDo

There was nothing to do because the client passed a list of operations with no
elements.

8010_0000

BadTooManyOperations

The request could not be processed because it specified too many operations.
Consulte también el mensaje de error en OPC_UA_NamespaceGetIndexList:
leer índices de los espacios de nombres (Página 4163).

Programación del PLC
Manual de programación y manejo, 11/2019

4293

Instrucciones
4.1 Instrucciones
Estado "Bad" (8000_0000 - FFFF_FFFF)
Número de
error (hex)

Nombre

Significado

8011_0000

BadDataTypeIdUnknown

The extension object cannot be (de)serialized because the data type id is not
recognized.

8012_0000

BadCertificateInvalid

The certificate provided as a parameter is not valid.

8013_0000

BadSecurityChecksFailed

An error occurred verifying security. The certificate provided as a parameter is
not valid.

8014_0000

BadCertificateTimeInvalid

The Certificate has expired or is not yet valid.

8015_0000

BadCertificateIssuer
TimeInvalid

An Issuer Certificate has expired or is not yet valid.

8016_0000

BadCertificateHost
NameInvalid

The HostName used to connect to a Server does not match a HostName in the
Certificate.

8017_0000

BadCertificateUriInvalid

The URI specified in the Application Description does not match the URI in the
Certificate.

8018_0000

BadCertificateUseNotAllo‐
wed

The Certificate may not be used for the requested operation.

8019_0000

BadCertificateIssuerUse
NotAllowed

The Issuer Certificate may not be used for the requested operation.

801A_0000

BadCertificateUntrusted

The Certificate is not trusted.

801B_0000

BadCertificateRevocation
Unknown

It was not possible to determine if the Certificate has been revoked.

801C_0000

BadCertificateIssuer
RevocationUnknown

It was not possible to determine if the Issuer

801D_0000

BadCertificateRevoked

The Certificate has been revoked.

801E_0000

BadCertificateIssuerRevoked The Issuer Certificate has been revoked.

801F_0000

BadUserAccessDenied

User does not have permission to perform the requested operation.

8020_0000

BadIdentityTokenInvalid

The user identity token is not valid.

8021_0000

BadIdentityTokenRejected

The user identity token is valid but the server has rejected it.

8022_0000

BadSecureChannelIdInvalid

The specified secure channel is no longer valid.

8023_0000

BadInvalidTimestamp

The timestamp is outside the range allowed by the server.

8024_0000

BadNonceInvalid

The nonce does appear to be not a random value or it is not the correct length.

8025_0000

BadSessionIdInvalid

The session id is not valid.

8026_0000

BadSessionClosed

The session was closed by the client.

8027_0000

BadSessionNotActivated

The session cannot be used because ActivateSession has not been called.

8028_0000

BadSubscriptionIdInvalid

The subscription id is not valid.

802A_0000

BadRequestHeaderInvalid

The header for the request is missing or invalid.

802B_0000

BadTimestampsTo
ReturnInvalid

The timestamps to return parameter is invalid.

802C_0000

BadRequestCancelled
ByClient

The request was cancelled by the client.

8031_0000

BadNoCommunication

Communication with the data source is defined, but not established, and there
is no last known value available.

8032_0000

BadWaitingForInitialData

Waiting for the server to obtain values from the underlying data source.

8033_0000

BadNodeIdInvalid

The syntax of the node id is not valid.

4294

Certificate has been revoked.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Estado "Bad" (8000_0000 - FFFF_FFFF)
Número de
error (hex)

Nombre

8034_0000

BadNodeIdUnknown

Significado
The node id refers to a node that does not exist in the server address space.
Posiblemente, el NamespaceIndex del NodeId indicado no exista. Si se mues‐
tra el código de error al llamar la instrucción OPC_UA_MethodCall:
Otra causa posible es el uso de ID de objeto no válidas en la llamada anterior
de OPC_UA_MethodGetHandleList. La instrucción OPC_UA_MethodGetHan‐
dleList no evalúa los ObjectIds.

8035_0000

BadAttributeIdInvalid

The attribute is not supported for the specified Node.

8036_0000

BadIndexRangeInvalid

The syntax of the index range parameter is invalid.

8037_0000

BadIndexRangeNoData

No data exists within the range of indexes specified.

8038_0000

BadDataEncodingInvalid

The data encoding is invalid.

8039_0000

BadDataEncoding
Unsupported

The server does not support the requested data encoding for the node.

803A_0000

BadNotReadable

The access level does not allow reading or subscribing to the Node.

803B_0000

BadNotWritable

The access level does not allow writing to the Node.

803C_0000

BadOutOfRange

The value was out of range.
Posibles soluciones para arrays: compruebe si puede acceder a elementos no
definidos de un array.

803D_0000

BadNotSupported

The requested operation is not supported.
Causa posible:
La dirección de servidor (ServerEndpointURL) es incorrecta o incompleta.

803E_0000

BadNotFound

A requested item was not found or a search operation ended without success.

803F_0000

BadObjectDeleted

The object cannot be used because it has been deleted.

8040_0000

BadNotImplemented

Requested operation is not implemented.

8041_0000

BadMonitoringModeInvalid

The monitoring mode is invalid.

8042_0000

BadMonitoredItemIdInvalid

The monitoring item id does not refer to a valid monitored item.

8043_0000

BadMonitoredItem
FilterInvalid

The monitored item filter parameter is not valid.

8044_0000

BadMonitoredItem
FilterUnsupported

The server does not support the requested monitored item filter.

8045_0000

BadFilterNotAllowed

A monitoring filter cannot be used in combination with the attribute specified.

8046_0000

BadStructureMissing

A mandatory structured parameter was missing or null.

8047_0000

BadEventFilterInvalid

The event filter is not valid.

8048_0000

BadContentFilterInvalid

The content filter is not valid.

8049_0000

BadFilterOperandInvalid

The operand used in a content filter is not valid.

804A_0000

BadContinuation
PointInvalid

The continuation point provide is longer valid.

804B_0000

BadNoContinuationPoints

The operation could not be processed because all continuation points have
been allocated.

804C_0000

BadReferenceTypeIdInvalid

The operation could not be processed because all continuation points have
been allocated.

804D_0000

BadBrowseDirectionInvalid

The browse direction is not valid.

804E_0000

BadNodeNotInView

The node is not part of the view.

804F_0000

BadServerUriInvalid

The ServerUri is not a valid URI.

Programación del PLC
Manual de programación y manejo, 11/2019

4295

Instrucciones
4.1 Instrucciones
Estado "Bad" (8000_0000 - FFFF_FFFF)
Número de
error (hex)

Nombre

Significado

8050_0000

BadServerNameMissing

No ServerName was specified

8051_0000

BadDiscoveryUrlMissing

No DiscoveryUrl was specified.

8052_0000

BadSempahoreFileMissing

The semaphore file specified by the client is not valid.

8053_0000

BadRequestTypeInvalid

The security token request type is not valid.

8054_0000

BadSecurityModeRejected

The security mode does not meet the requirements set by the Server.
El servidor exige mayores requisitos de seguridad. Posibles soluciones: utilice
una configuración más segura para conectarse al servidor.

8055_0000

BadSecurityPolicyRejected

The security policy does not meet the requirements set by the Server.

8056_0000

BadTooManySessions

The server has reached its maximum number of sessions.

8057_0000

BadUserSignatureInvalid

The user token signature is missing or invalid.

8058_0000

BadApplicationSignature
Invalid

The signature generated with the client certificate is missing or invalid.

8059_0000

BadNoValidCertificates

The client did not provide at least one software certificate that is valid and
meets the profile requirements for the server.

805A_0000

BadRequestCancelled
ByRequest

The request was cancelled by the client with the Cancel service.

805B_0000

BadParentNodeIdInvalid

The parent node id does not to refer to a valid node.

805C_0000

BadReferenceNotAllowed

The reference could not be created because it violates constraints imposed by
the data model.

805D_0000

BadNodeIdRejected

The requested node id was reject because it was either invalid or server does
not allow node ids to be specified by the client.

805E_0000

BadNodeIdExists

The requested node id is already used by another node.

805F_0000

BadNodeClassInvalid

The node class is not valid.

8060_0000

BadBrowseNameInvalid

The browse name is invalid.

8061_0000

BadBrowseNameDuplicated

The browse name is not unique among nodes that share the same relationship
with the parent.

8062_0000

BadNodeAttributesInvalid

The node attributes are not valid for the node class.

8063_0000

BadTypeDefinitionInvalid

The type definition node id does not reference an appropriate type node.

8064_0000

BadSourceNodeIdInvalid

The source node id does not reference a valid node.

8065_0000

BadTargetNodeIdInvalid

The target node id does not reference a valid node.

8066_0000

BadDuplicateReference
NotAllowed

The reference type between the nodes is already defined.

8067_0000

BadInvalidSelfReference

The server does not allow this type of selfreference on this node.

8068_0000

BadReferenceLocalOnly

The reference type is not valid for a reference to a remote server.

8069_0000

BadNoDeleteRights

The server will not allow the node to be deleted.

806A_0000

BadServerIndexInvalid

The server index is not valid.

806B_0000

BadViewIdUnknown

The view id does not refer to a valid view node.

806D_0000

BadTooManyMatches

The requested operation has too many matches to return.

806E_0000

BadQueryTooComplex

The requested operation requires too many resources in the server.

806F_0000

BadNoMatch

The requested operation has no match to return.

8070_0000

BadMaxAgeInvalid

The max age parameter is invalid.

8071_0000

BadHistoryOperationInvalid

The history details parameter is not valid.

4296

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Estado "Bad" (8000_0000 - FFFF_FFFF)
Número de
error (hex)

Nombre

Significado

8072_0000

BadHistoryOperation
Unsupported

The server does not support the requested operation.

8073_0000

BadWriteNotSupported

The server not does support writing the combination of value, status and ti‐
mestamps provided.

8074_0000

BadTypeMismatch

The value supplied for the attribute is not of the same type as the attribute's
value.

8075_0000

BadMethodInvalid

The method id does not refer to a method for the specified object.

8076_0000

BadArgumentsMissing

The client did not specify all of the input arguments for the method.

8077_0000

BadTooManySubscriptions

The server has reached its maximum number of subscriptions.
Causa posible:
Número máximo de suscripciones rebasado
Solución:
Cree una suscripción en una nueva sesión.

8078_0000

BadTooManyPublish
Requests

The server has reached the maximum number of queued publish requests.

8079_0000

BadNoSubscription

There is no subscription available for this session.

807A_0000

BadSequenceNumber
Unknown

The sequence number is unknown to the server.

807B_0000

BadMessageNotAvailable

The requested notification message is no longer available.

807C_0000

BadInsufficientClientProfile

The Client of the current Session does not support one or more Profiles that
are necessary for the Subscription.

80BF_0000

BadStateNotActive

The sub-state machine is not currently active.

807D_0000

BadTcpServerTooBusy

The server cannot process the request because it is too busy.

807E_0000

BadTcpMessageTypeInvalid

The type of the message specified in the header invalid.

807F_0000

BadTcpSecureChannel
Unknown

The SecureChannelId and/or TokenId are not currently in use.

8080_0000

BadTcpMessageTooLarge

The size of the message specified in the header is too large.

8081_0000

BadTcpNotEnough
Resources

There are not enough resources to process the request.
Consulte también el mensaje de error en OPC_UA_Connect: crear una cone‐
xión (Página 4153).

8082_0000

BadTcpInternalError

An internal error occurred.

8083_0000

BadTcpEndpointUrlInvalid

The Server does not recognize the QueryString specified.

8084_0000

BadRequestInterrupted

The request could not be sent because of a network interruption.

8085_0000

BadRequestTimeout

Timeout occurred while processing the request.

8086_0000

BadSecureChannelClosed

The secure channel has been closed.

8087_0000

BadSecureChannelToken
Unknown

The token has expired or is not recognized.

8088_0000

BadSequenceNumberInvalid

The sequence number is not valid.

8089_0000

BadConfigurationError

There is a problem with the configuration that affects the usefulness of the
value.

808A_0000

BadNotConnected

The variable should receive its value from another variable, but has never
been configured to do so.

808B_0000

BadDeviceFailure

There has been a failure in the device/data source that generates the value
that has affected the value.

Programación del PLC
Manual de programación y manejo, 11/2019

4297

Instrucciones
4.1 Instrucciones
Estado "Bad" (8000_0000 - FFFF_FFFF)
Número de
error (hex)

Nombre

Significado

808C_0000

BadSensorFailure

There has been a failure in the sensor from which the value is derived by the
device/data source.

808D_0000

BadOutOfService

The source of the data is not operational.

808E_0000

BadDeadbandFilterInvalid

The dead band filter is not valid.

8097_0000

BadRefreshInProgress

This Condition refresh failed, a Condition refresh operation is already in pro‐
gress.

8098_0000

BadConditionAlreadyDisa‐
bled

This condition has already been disabled.

8099_0000

BadConditionDisabled

Property not available, this condition is disabled.

809A_0000

BadEventIdUnknown

The specified event id is not recognized.

809B_0000

BadNoData

No data exists for the requested time range or event filter.

809D_0000

BadDataLost

Data is missing due to collection started/stopped/lost.

809E_0000

BadDataUnavailable

Expected data is unavailable for the requested time range due to an unmoun‐
ted volume an off-line archive or tape or similar reason for temporary unavai‐
lability.

809F_0000

BadEntryExists

The data or event was not successfully inserted because a matching entry
exists.

80A0_0000

BadNoEntryExists

The data or event was not successfully updated because no matching entry
exists.

80A1_0000

BadTimestampNotSupported The client requested history using a timestamp format the server does not
support (i. e. requested ServerTimestamp when server only supports Source‐
Timestamp).

80AB_0000

BadInvalidArgument

One or more arguments are invalid.
Causa posible:
La dirección de servidor (ServerEndpointURL) es incorrecta o incompleta.

80AC_0000

BadConnectionRejected

Could not establish a network connection to remote server.

80AD_0000

BadDisconnect

The server has disconnected from the client.

80AE_0000

BadConnectionClosed

The network connection has been closed.

80AF_0000

BadInvalidState

The operation cannot be completed because the object is closed uninitialized
or in some other invalid state.

80B0_0000

BadEndOfStream

Cannot move beyond end of the stream.

80B1_0000

BadNoDataAvailable

No data is currently available for reading from a non-blocking stream.

80B2_0000

BadWaitingForResponse

The asynchronous operation is waiting for a response.

80B3_0000

BadOperationAbandoned

The asynchronous operation was abandoned by the caller.

80B4_0000

BadExpectedStreamToBlock The stream did not return all data requested (possibly because it is a nonblocking stream).

80B5_0000

BadWouldBlock

Non-blocking behavior is required and the operation would block.

80B6_0000

BadSyntaxError

A value had an invalid syntax.

80B7_0000

BadMaxConnections
Reached

The operation could not be finished because all available connections are in
use.

80BB_0000

BadEventNot
Acknowledgeable

The event cannot be acknowledged.

80BD_0000

BadInvalidTimestamp
Argument

The defined timestamp to return was invalid.

4298

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Estado "Bad" (8000_0000 - FFFF_FFFF)
Número de
error (hex)

Nombre

Significado

80BE_0000

BadProtocolVersion
Unsupported

The applications do not have compatible protocol versions.

80C1_0000

BadFilterOperatorInvalid

An unrecognized operator was provided in a filter.

80C2_0000

BadFilterOperator
Unsupported

A valid operator was provided, but the server does not provide support for this
filter operator.

80C3_0000

BadFilterOperandCount
Mismatch

The number of operands provided for the filter operator was less than expec‐
ted for the operand provided.

80C4_0000

BadFilterElementInvalid

The referenced element is not a valid element in the content filter.

80C5_0000

BadFilterLiteralInvalid

The referenced literal is not a valid value.

80C6_0000

BadIdentityChangeNotSup‐
ported

The Server does not support changing the user identity assigned to the ses‐
sion.

80C8_0000

BadNotTypeDefinition

The provided NodeId was not a type definition NodeId.

80C9_0000

BadViewTimestampInvalid

The view timestamp is not available or not supported.

80CA_0000

BadViewParameterMismatch The view parameters are not consistent with each other.

80CB_0000

BadViewVersionInvalid

The view version is not available or not supported.

80CC_0000

BadConditionAlready
Enabled

This condition has already been enabled.

80CD_0000

BadDialogNotActive

The dialog condition is not active.

80CE_0000

BadDialogResponseInvalid

The response is not valid for the dialog.

80CF_0000

BadConditionBranch
AlreadyAcked

The condition branch has already been acknowledged.

80D0_0000

BadConditionBranch
AlreadyConfirmed

The condition branch has already been confirmed.

80D1_0000

BadConditionAlreadyShel‐
ved

The condition has already been shelved.

80D2_0000

BadConditionNotShelved

The condition is not currently shelved.

80D3_0000

BadShelvingTimeOutOfRan‐
ge

The shelving time not within an acceptable range.

80D4_0000

BadAggregateListMismatch

The requested number of Aggregates does not match the requested number
of NodeIds.

80D5_0000

BadAggregateNotSupported

The requested Aggregate is not support by the server.

80D6_0000

BadAggregateInvalidInputs

The aggregate value could not be derived due to invalid data inputs.

Programación del PLC
Manual de programación y manejo, 11/2019

4299

Instrucciones
4.1 Instrucciones
Estado "Bad" (8000_0000 - FFFF_FFFF)
Número de
error (hex)

Nombre

Significado

80DB_0000

BadTooManyMonitoredItems The request could not be processed because there are too many monitored
items in the subscription.
Causa posible:
Se ha alcanzado el número máximo de elementos vigilados en una suscrip‐
ción.
Solución:
Para registrar otros elementos debe crearse una nueva suscripción.
En los proyectos de TIA Portal V15 y superior existe la posibilidad adicional de
ajustar el número máximo de elementos vigilados en la configuración de la
CPU.
Otra causa posible:
Request con demasiados elementos
Solución:
Observe los máximos indicados en el objeto "ServerCapabilities" del servidor.

80D7_0000

BadBoundNotFound

No data found to provide upper or lower bound value.

80D8_0000

BadBoundNotSupported

The server cannot retrieve a bound for the variable.

80DA_0000

BadAggregateConfiguration
Rejected

The aggregate configuration is not valid for specified node.

80E1_0000

BadDominantValueChanged

The related EngineeringUnit has been changed but this change has not been
applied to the device. The Variable Value is still dependent on the previous unit
but its status is currently bad.

80E3_0000

BadDependentValueChan‐
ged

A dependent value has been changed but the change has not been applied to
the device. The quality of the dominant variable is bad.

80E4_0000

BadRequestNotAllowed

The request was rejected by the server because it did not meet the criteria set
by the server.

80E5_0000

BadTooManyArguments

Too many arguments were provided.

80E6_0000

BadSecurityModeInsufficient

The operation is not permitted over the current secure channel.

810D_0000

BadCertificateChainIncom‐
plete

The certificate chain is incomplete.

810E_0000

BadLicenseExpired

The server requires a license to operate in general or to perform a service or
operation, but existing license is expired.

810F_0000

BadLicenseLimitsExceeded

The server has limits on number of allowed operations / objects, based on
installed licenses, and these limits where exceeded.

8110_0000

BadLicenseNotAvailable

The server does not have a license which is required to operate in general or
to perform a service or operation.

8111_0000

BadNotExecutable

The executable attribute does not allow the execution of the method.

8112_0000

BadNumericOverflow

The number was not accepted because of a numeric overflow.

8113_0000

BadRequestNotComplete

The request has not been processed by the server yet.

Códigos de error de PLCopen
Códigos de error
La tabla siguiente contiene los números de error de PLCopen.

4300

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los nombres y las explicaciones de los errores se muestran en su versión original. Solo están
disponibles en inglés.

Números de error de PLCopen
ErrorID (hex) Nombre

Significado

A000_0001

PLCopenUA_Bad_FW_
PermanentError

Internal, permanent error.

A000_0002

PLCopenUA_Bad_FW_
TempError

Temp. Error; FB could retry to reach FW.

A000_0100

PLCopenUA_Bad_
ConnectionError

Connection could not be established.

A000_0101

PLCopenUA_Bad_
HostNotFound

The requested hostname could not be found.

A000_0102

PLCopenUA_Bad_
AlreadyConnected

Connection was already established.

A000_0103

PLCopenUA_Bad_
SecurityFailed

Connection failed due to security setup.

A000_0104

PLCopenUA_Bad_
Suspended

Connection is suspended.

A000_0105

PLCopenUA_Bad_
ConnectionInvalidHdl

Provided ConnectionHdl is not known.

A000_0200

PLCopenUA_Bad_
NSNotFound

A namespace with the requested name cannot be found on server.

A000_0300

PLCopenUA_Bad_
ResultTooLong

Target PLC variable is too short for retrieved data.

A000_0301

PLCopenUA_Bad_
InvalidType

Invalid or unsupported Type.

A000_0302

PLCopenUA_Bad_
NodeInvalidHdl

Provided NodeHdl is not known.

A000_0303

PLCopenUA_Bad_
MethodInvalidHdl

Provided MethodHdl is not known.

A000_0304

PLCopenUA_Bad_
ReadFailed

Read failed for unknown reason.

A000_0305

PLCopenUA_Bad_
WriteFailed

Write failed for unknown reason.

A000_0306

PLCopenUA_Bad_
CallFailed

Method Call failed for unknown reason.

A000_0307

PLCopenUA_Bad_
InParamFailed

Method Call Input parameter conversion failed.

A000_0308

PLCopenUA_Bad_
OutParamFailed

Method Call Output parameter conversion failed. ATTENTION: this means the
MethodCall was executed successfully but the returned values could not be
converted.

A000_0500

PLCopenUA_Bad_
SubscriptionInvalidHdl

Provided SubscriptionHdl is not known.

A000_0501

PLCopenUA_Bad_
MonitoredItemInvalidHdl

Provided MonitoredItemHdl is not known.

Programación del PLC
Manual de programación y manejo, 11/2019

Encontrará más información en la descripción de los códigos de error de la
instrucción "OPC_UA_ConnectionGetStatus".

4301

Instrucciones
4.1 Instrucciones

Programas de ejemplo para clientes OPC UA
Observaciones previas
Los bloques de función de ejemplo "Call_OpenDoor_On_Productionline",
"ReadFromProductionline" y "WriteToProductionline" ilustran en cada caso únicamente la
función individual y no están pensados para el uso común. Por eso solo pueden ejecutarse
individualmente.
Cada uno de los FB establece una conexión propia con la instrucción OPC_UA_Connect y
accede a la misma interfaz de cliente y, con ello, al DB "Productionline_Configuration".
En caso de uso común, los controladores (handles) de las tres conexiones se depositan en la
misma variable y se sobrescriben mutuamente.
Tenga en cuenta este comportamiento si en su proyecto utiliza todas las funciones descritas.

Programa de ejemplo para OPC_UA_ConnectionGetStatus
Programa de ejemplo para analizar conexiones
Este capítulo contiene el código de programa completo para el programa de ejemplo
"Analyze_Connection".
El ejemplo muestra cómo un programa de usuario emplea la instrucción
"OPC_UA_ConnectionGetStatus" para recopilar información sobre una conexión con un
servidor OPC UA.
Encontrará la descripción de la instrucción "OPC_UA_ConnectionGetStatus" en el capítulo
OPC_UA_ConnectionGetStatus: leer estado de la conexión (Página 4249).
Estructura del programa
El programa trabaja como cliente OPC UA y se divide en las secciones siguientes:
1. Establecer una conexión con un servidor OPC UA.
2. Analizar la conexión.
3. Deshacer la conexión al servidor OPC UA.
El programa se inicia con un flanco ascendente en "Input_REQ".

4302

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Declaración
La figura siguiente muestra la declaración de las variables locales de un bloque de función que
utiliza la instrucción "OPC_UA_ConnectionGetStatus":

Programación del PLC
Manual de programación y manejo, 11/2019

4303

Instrucciones
4.1 Instrucciones

Programa
SCL
IF #Run = FALSE THEN
#Started := #Input_REQ AND NOT #Mem_Input_REQ;
#Mem_Input_REQ := #Input_REQ;
IF #Started THEN
#Output_Busy := TRUE;
#Output_Done := FALSE;
#Output_Error := FALSE;
#State := 1;
#Run := TRUE;
#ResetREQ_For_OPC_UA_Disconnect := TRUE;
#SetServerEndpoint := TRUE;
END_IF;
END_IF;
IF #Run = TRUE THEN
CASE #State OF
1: // case 1, connect to server
IF #SetServerEndpoint = TRUE THEN
#SetServerEndpoint := FALSE;
//set ServerSendpoint
#ServerEndpointUrl := WSTRING#'opc.tcp://192.168.1.1:4840';
/setting for SecurityMsgMode
//1 = None
//2 = Sign
//3 = Sign & Encrypt
#OPC_UA_SessionConnectInfo_Instance.SecurityMsgMode := 3;
//setting for SecurityPolicy
//1 = None
//2 = Basic128Rsa15
//3 = Basic256
//4 = Basic256Sha256
#OPC_UA_SessionConnectInfo_Instance.SecurityPolicy := 4;
//set TransportProfile to 1
#OPC_UA_SessionConnectInfo_Instance.TransportProfile := 1;
/we are using our Client-Certificate Nr. 10
//because Nr. 10 is the lastest Certificate we created for our client application
//please look into Certificate manager for the number of your Client certificate
//Certificate manager is located at
// "Project tree > Security settings > Security features"
#OPC_UA_SessionConnectInfo_Instance.CertificateID := 10;
END_IF;
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Connect_Instance(REQ := #Req,
ServerEndpointUrl := #ServerEndpointUrl,
SessionConnectInfo := #OPC_UA_SessionConnectInfo_Instance,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status,
ConnectionHdl => #ConnectionHdl);

4304

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
IF #Done = TRUE THEN
#State := #State + 1;
#ResetREQ_For_OPC_UA_Disconnect := TRUE;
END_IF;
IF #Error = TRUE THEN
// Did we get a connection handle?
IF #ConnectionHdl <> 0 THEN
// We have to release all resources in the server and disconnect
#State := 100;
ELSE
#State := 99;
END_IF;
#Mem_Status := #Status;
#OPC_UA_Connect_Instance(REQ := FALSE,
ServerEndpointUrl := #ServerEndpointUrl,
SessionConnectInfo := #OPC_UA_SessionConnectInfo_Instance);
#ResetREQ_For_OPC_UA_Disconnect := TRUE;
END_IF;
2: // case 2, analyse connection
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_ConnectionGetStatus_Instance(REQ := #Req,
ConnectionHdl := #ConnectionHdl,
ConnectionStatus => #ConnectionStatus,
ServerState => #ServerState,
ServiceLevel => #ServiceLevel,
Timeout := T#6S,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
#State := 100;
#Mem_Status := #Status;
#OPC_UA_ConnectionGetStatus_Instance(REQ := FALSE,
ConnectionHdl := #ConnectionHdl);
END_IF;
3: // case 3, disconnect from server
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Disconnect_Instance(REQ := #Req,
ConnectionHdl := #ConnectionHdl,
Timeout := T#6S,
Done => #Done,
Busy => #Busy,

Programación del PLC
Manual de programación y manejo, 11/2019

4305

Instrucciones
4.1 Instrucciones
SCL
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
#State := 100;
#Mem_Status := #Status;
#OPC_UA_Disconnect_Instance(REQ := FALSE,
ConnectionHdl := #ConnectionHdl);
END_IF;
4: //case = 4, function block has run successfully
#Output_Done := TRUE;
#Output_Busy := FALSE;
#State := 0;
#Mem_Input_REQ := FALSE;
#Run := FALSE;
#Started := FALSE;
99: // ERROR handling
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;
100:

4306

// ERROR handling, disconnect from server to release resources (handles)
IF #ResetREQ_For_OPC_UA_Disconnect = TRUE THEN
#ResetREQ_For_OPC_UA_Disconnect := FALSE;
//set REQ to FALSE
#OPC_UA_Disconnect_Instance(REQ := FALSE,
ConnectionHdl := #ConnectionHdl);
END_IF;
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Disconnect_Instance(REQ := #Req,
ConnectionHdl := #ConnectionHdl,
Timeout := T#6S,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
END_IF;
IF #Error = TRUE THEN
#Output_Error_Message := WString#'Error handling: Resources cannot be
released!';
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;
END_IF;
END_CASE;
END_IF;

Programa de ejemplo para leer variables PLC
Programa de ejemplo para leer variables PLC
Este capítulo contiene el código de programa completo para el programa de ejemplo
"ReadFromProductionline".
El ejemplo muestra cómo un programa de usuario lee los valores de variables PLC.
Estructura del programa
El programa trabaja como cliente OPC UA y se divide en los pasos siguientes:
1. Establecer una conexión con el servidor OPC UA de la CPU de la que se van a leer valores.
2. Leer los valores.
3. Deshacer la conexión al servidor OPC UA.
El programa se inicia con un flanco ascendente en "Input_REQ".

Requisitos
Para el programa de ejemplo es imprescindible haber configurado una interfaz de cliente
"Productionline" y que existan los siguientes bloques de datos:
● Productionline_Configuration
● Productionline_Data
STEP 7 (TIA Portal) genera estos bloques de datos automáticamente cuando se crea una
interfaz de cliente; consulte AUTOHOTSPOT.
Asimismo, para el programa de ejemplo es imprescindible haber creado y parametrizado una
conexión con el servidor OPC UA; consulte AUTOHOTSPOT.

Programación del PLC
Manual de programación y manejo, 11/2019

4307

Instrucciones
4.1 Instrucciones

Declaración
La figura siguiente muestra la declaración de las variables locales para el bloque de función
"ReadFromProductionline".

4308

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Programa
SCL
IF #Run = FALSE THEN
Started := #Input_REQ AND NOT #Mem_Input_REQ;
#Mem_Input_REQ := #Input_REQ;
IF #Started THEN
#Output_Busy := TRUE;
#Output_Done := FALSE;
#Output_Error := FALSE;
#Output_Status := 0;
#State := 1;
#Run := TRUE;
#Set_REQ_To_FALSE := TRUE;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
END_IF;
END_IF;
IF #Run = TRUE THEN
CASE #State OF
1: // case 1, connect to server
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Connect_Instance(REQ := #Req,
ServerEndpointUrl :=
"Productionline_Configuration".Connection.ServerEndpointUrl,
SessionConnectInfo := "Productionline_Configuration".Connection.ConnectInfo,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status,
ConnectionHdl => "Productionline_Configuration".Connection.ConnectionHdl);
IF #Done = TRUE THEN
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
// Did we get a connection handle?
IF "Productionline_Configuration".Connection.ConnectionHdl <> 0 THEN
// We have to release all resources in the server and disconnect
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
ELSE
#State := 99;
END_IF;
#Mem_Status := #Status;
// set parameter REQ of OPC_UA_Connect to FALSE
#OPC_UA_Connect_Instance(REQ := FALSE,
ServerEndpointUrl :=
"Productionline_Configuration".Connection.ServerEndpointUrl,
SessionConnectInfo := "Productionline_Configuration".Connection.ConnectInfo,

Programación del PLC
Manual de programación y manejo, 11/2019

4309

Instrucciones
4.1 Instrucciones
SCL
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
ConnectionHdl => "Productionline_Configuration".Connection.ConnectionHdl);
END_IF;
2: // case 2, get index for namespace
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_NamespaceGetIndexList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NamespaceUrisCount :=
"Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceUris := "Productionline_Configuration".Namespaces.NamespaceURIs,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
StatusList := "Productionline_Configuration".Namespaces.NamespaceStatusList,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
IF "Productionline_Configuration".Namespaces.NamespaceStatusList[0] = 0 THEN
#State := #State + 1;
ELSE
#State := 100;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at NamespaceGetIndexList';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_NamespaceGetIndexList_Instance(REQ := FALSE,
NamespaceUris := "Productionline_Configuration".Namespaces.NamespaceURIs,
StatusList := "Productionline_Configuration".Namespaces.NamespaceStatusList,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes);
END_IF;
3: // case 3, get handles for nodes
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_NodeGetHandleList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeIDCount :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeCount,

4310

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
NodeIDs := "Productionline_Configuration".ReadLists."ReadListProduct".Nodes,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NamespaceIndexCount :=
"Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
NodeStatusList := "Productionline_Data"."ReadListProduct".NodeStatusList,
NodeHdls :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeHdls,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
IF "Productionline_Data"."ReadListProduct".NodeStatusList[0] = 0 AND
"Productionline_Data"."ReadListProduct".NodeStatusList[1] = 0
THEN
#State := #State + 1;
ELSE
#State := 100;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at NodeGetHandleList';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#OPC_UA_NodeGetHandleList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeIDCount :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeCount,
NodeIDs := "Productionline_Configuration".ReadLists."ReadListProduct".Nodes,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NamespaceIndexCount :=
"Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
NodeStatusList := "Productionline_Data"."ReadListProduct".NodeStatusList,
NodeHdls :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeHdls);
END_IF;
4: // case 4, read from nodes
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_ReadList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeCount,

Programación del PLC
Manual de programación y manejo, 11/2019

4311

Instrucciones
4.1 Instrucciones
SCL
NodeHdls :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeHdls,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList := "Productionline_Data"."ReadListProduct".NodeStatusList,
TimeStamps := "Productionline_Data"."ReadListProduct".TimeStamps,
Variable := "Productionline_Data"."ReadListProduct".Variable,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
FOR #i := 0 TO
UINT_TO_INT("Productionline_Configuration".ReadLists."ReadListProduct".NodeCount) - 1 DO
IF NOT ("Productionline_Data"."ReadListProduct".NodeStatusList[#i] = 0) THEN
#Output_Error_Message := CONCAT_WSTRING(IN1 := WSTRING#'Error at Readlist
"ReadListProduct",
Index: ',IN2 := INT_TO_WSTRING(#i));
END_IF;
END_FOR;
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_ReadList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeCount,
NodeHdls :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeHdls,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList := "Productionline_Data"."ReadListProduct".NodeStatusList,
TimeStamps := "Productionline_Data"."ReadListProduct".TimeStamps,
Variable := "Productionline_Data"."ReadListProduct".Variable);
END_IF;
5: // case 5, release node handles
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_NodeReleaseHandleList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeCount,
NodeHdls :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeHdls,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList := "Productionline_Data"."ReadListProduct".NodeStatusList,
Done => #Done,

4312

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
Error => #Error,
Busy => #Busy,
Status => #Status);
IF #Done = TRUE THEN
IF "Productionline_Data"."ReadListProduct".NodeStatusList[0] = 0 AND
"Productionline_Data"."ReadListProduct".NodeStatusList[1] = 0
THEN
#State := #State + 1;
ELSE
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at NodeReleaseHandleList';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_NodeReleaseHandleList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeCount,
NodeHdls :=
"Productionline_Configuration".ReadLists."ReadListProduct".NodeHdls,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList := "Productionline_Data"."ReadListProduct".NodeStatusList);
END_IF;
6: // case 6, disconnect from server
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Disconnect_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
END_IF;

Programación del PLC
Manual de programación y manejo, 11/2019

4313

Instrucciones
4.1 Instrucciones
SCL
7: //case = 7, function block has run successfully
#Output_Done := TRUE;
#Output_Busy := FALSE;
#State := 0;
#Mem_Input_REQ := FALSE;
#Run := FALSE;
#Started := FALSE;
99: // ERROR handling
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;
100: // ERROR handling, disconnect from server to release resources (handles)
IF #Set_REQ_To_FALSE = TRUE THEN
#Set_REQ_To_FALSE := FALSE;
/set REQ to FALSE
#OPC_UA_Disconnect_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout);
END_IF;
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Disconnect_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;
END_IF;
IF #Error = TRUE THEN
#Output_Error_Message := WString#'Error handling: Resources cannot be released!';
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;

4314

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
#Started := FALSE;
END_IF;
END_CASE;
END_IF;

Programa de ejemplo para escribir variables PLC
Programa de ejemplo para escribir variables PLC
Este capítulo contiene el código de programa completo para el programa de ejemplo
"WriteToProductionline".
El ejemplo muestra cómo un programa de usuario escribe los valores de variables PLC.
Estructura del programa
El programa trabaja como cliente OPC UA y se divide en los pasos siguientes:
1. Establecer una conexión con el servidor OPC UA de la CPU en la que se van a escribir
valores.
2. Escribir los valores.
3. Deshacer la conexión al servidor OPC UA
El programa se inicia con un flanco ascendente en "Input_REQ".

Programación del PLC
Manual de programación y manejo, 11/2019

4315

Instrucciones
4.1 Instrucciones

Declaración
La figura siguiente muestra la declaración de las variables locales para el bloque de función
"WriteToProductionline":

Además, el programa de ejemplo utiliza los siguientes bloques de datos:
● Productionline_Configuration
● Productionline_Data
STEP 7 (TIA Portal) crea estos bloques de datos automáticamente, ya que el programa de
ejemplo utiliza la parametrización de OPC UA.

4316

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Programa
SCL
IF #Run = FALSE THEN
#Started := #Input_REQ AND NOT #Mem_Input_REQ;
#Mem_Input_REQ := #Input_REQ;
IF #Started THEN
#Output_Busy := TRUE;
#Output_Done := FALSE;
#Output_Error := FALSE;
#Output_Status := 0;
#State := 1;
#Run := TRUE;
#FirstCall := TRUE;
#Set_REQ_To_FALSE := TRUE;

//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE

END_IF;
END_IF;
IF #Run = TRUE THEN
CASE #State OF
1: // case 1, connect to server
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Connect_Instance(REQ := #Req,
ServerEndpointUrl :=
"Productionline_Configuration".Connection.ServerEndpointUrl,
SessionConnectInfo := "Productionline_Configuration".Connection.ConnectInfo,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status,
ConnectionHdl => "Productionline_Configuration".Connection.ConnectionHdl);
IF #Done = TRUE THEN
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
// Did we get a connection handle?
IF "Productionline_Configuration".Connection.ConnectionHdl <> 0 THEN
// We have to release all resources in the server and disconnect
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
ELSE
#State := 99;
END_IF;
#Mem_Status := #Status;
#OPC_UA_Connect_Instance(REQ := FALSE,

Programación del PLC
Manual de programación y manejo, 11/2019

4317

Instrucciones
4.1 Instrucciones
SCL
ServerEndpointUrl :=
"Productionline_Configuration".Connection.ServerEndpointUrl,
SessionConnectInfo := "Productionline_Configuration".Connection.ConnectInfo,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
ConnectionHdl => "Productionline_Configuration".Connection.ConnectionHdl);
END_IF;
2: // case 2, get index for namespace
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_NamespaceGetIndexList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NamespaceUrisCount := "Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceUris := "Productionline_Configuration".Namespaces.NamespaceURIs,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
StatusList := "Productionline_Configuration".Namespaces.NamespaceStatusList,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
Done => #Done,
Busy => #Busy,
Error => #Error);
IF #Done = TRUE THEN
IF "Productionline_Configuration".Namespaces.NamespaceStatusList[0] = 0 THEN
#State := #State + 1;
ELSE
#State := 100;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at NamespaceGetIndexList';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_NamespaceGetIndexList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NamespaceUrisCount := "Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceUris := "Productionline_Configuration".Namespaces.NamespaceURIs,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
StatusList := "Productionline_Configuration".Namespaces.NamespaceStatusList,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes);
END_IF;
3: // case 3, get handles for nodes
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;

4318

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
#OPC_UA_NodeGetHandleList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeIDCount :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeCount,
NodeIDs := "Productionline_Configuration".WriteLists."WriteListStatus".Nodes,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NamespaceIndexCount :=
"Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
NodeStatusList := "Productionline_Data"."WriteListStatus".NodeStatusList,
NodeHdls :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeHdls,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status =>#Status);
IF #Done = TRUE THEN
IF "Productionline_Data"."WriteListStatus".NodeStatusList[0] = 0
THEN
#State := #State + 1;
ELSE
#State := 100;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at NodeGetHandleList';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_NodeGetHandleList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeIDCount :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeCount,
NodeIDs := "Productionline_Configuration".WriteLists."WriteListStatus".Nodes,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NamespaceIndexCount :=
"Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
NodeStatusList := "Productionline_Data"."WriteListStatus".NodeStatusList,
NodeHdls :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeHdls);
END_IF;
4: // case 4; write value to PLC variable "ProductionEnabled"
IF #SetProductionEnabled = TRUE THEN
#SetProductionEnabled := FALSE;
//set new value to true
"Productionline_Data"."WriteListStatus".Variable.ProductionEnabled := TRUE;
END_IF;
IF #Busy = FALSE THEN

Programación del PLC
Manual de programación y manejo, 11/2019

4319

Instrucciones
4.1 Instrucciones
SCL
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_WriteList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeCount,
NodeHdls :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeHdls,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList := "Productionline_Data"."WriteListStatus".NodeStatusList,
Variable := "Productionline_Data"."WriteListStatus".Variable,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
FOR #i := 0 TO
UINT_TO_INT("Productionline_Configuration".WriteLists.WriteListStatus.NodeCount) - 1 DO
IF NOT ("Productionline_Data"."WriteListStatus".NodeStatusList[#i] = 0) THEN
#Output_Error_Message := CONCAT_WSTRING(IN1 := WSTRING#'Error at Writelist
"WriteListStauts", Index: ',
IN2 := INT_TO_WSTRING(#i));
END_IF;
END_FOR;
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_WriteList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeCount,
NodeHdls :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeHdls,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList := "Productionline_Data"."WriteListStatus".NodeStatusList,
Variable := "Productionline_Data"."WriteListStatus".Variable);
END_IF;
5: // case 5, release node handles
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_NodeReleaseHandleList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeCount,

4320

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
NodeHdls :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeHdls,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList := "Productionline_Data"."WriteListStatus".NodeStatusList,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
IF "Productionline_Data"."WriteListStatus".NodeStatusList[0] = 0
THEN
#State := #State + 1;
ELSE
#State := 100;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at NodeReleaseHandleList';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_NodeReleaseHandleList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeHdlCount :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeCount,
NodeHdls :=
"Productionline_Configuration".WriteLists."WriteListStatus".NodeHdls,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NodeStatusList := "Productionline_Data"."WriteListStatus".NodeStatusList);
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
END_IF;
6: // case 6, disconnect from server
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Disconnect_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN

Programación del PLC
Manual de programación y manejo, 11/2019

4321

Instrucciones
4.1 Instrucciones
SCL
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
END_IF;
7: //case = 7, function block has run successfully
#Output_Done := TRUE;
#Output_Busy := FALSE;
#State := 0;
#Mem_Input_REQ := FALSE;
#Run := FALSE;
#Started := FALSE;
99: // ERROR handling
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;
100: // ERROR handling, disconnect from server to release resources (handles)
IF #Set_REQ_To_FALSE = TRUE THEN
#Set_REQ_To_FALSE := FALSE;
//set REQ to FALSE
#OPC_UA_Disconnect_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout);
END_IF;
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Disconnect_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;
END_IF;
IF #Error = TRUE THEN
#Output_Error_Message := WString#'Error handling: Resources cannot be released!';

4322

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;
END_IF;
END_CASE;
END_IF;

Programa de ejemplo para OPC_UA_TranslatePathList
Programa de ejemplo para la instrucción "OPC_UA_TranslatePathList"
Este capítulo contiene el código de programa completo para el programa de ejemplo
"Read_From_RfidReader_Door_1".
El ejemplo muestra cómo un programa de usuario emplea la instrucción
"OPC_UA_TranslatePathList" para recibir los NodeIds de nodos y, a continuación, leer los
valores de dichos nodos.
Encontrará la descripción de la instrucción "OPC_UA_TranslatePathList" en el capítulo
OPC_UA_TranslatePathList: Determinar los ID de nodo actuales (Página 4186).
Estructura del programa
El programa trabaja como cliente OPC UA y se divide en los pasos siguientes:
1. Establecer una conexión con el servidor OPC UA de la CPU de la que se van a leer valores.
2. Leer los valores.
3. Deshacer la conexión al servidor OPC UA.
El programa se inicia con un flanco ascendente en "Input_REQ".

Declaración
La figura siguiente muestra la declaración de las variables locales del bloque de función
"Read_From_RfidReader_Door_1" que utiliza la instrucción "OPC_UA_TanslatePathList":

Programación del PLC
Manual de programación y manejo, 11/2019

4323

Instrucciones
4.1 Instrucciones

Tipo de datos "UDT_Variable" de los valores leídos
La variable local "Variable" (véase la fila 43 en la figura anterior) utiliza el tipo de datos
"UDT_Variable".
Para que el programa de ejemplo pueda introducir los valores de "DeviceInfo" y "DeviceStatus"
en la variable "Variable", hay que crear el tipo de datos de usuario "UDT_Variable" en el
proyecto de TIA Portal.
La figura siguiente muestra la estructura del tipo de datos "UDT_Variable":

4324

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Programa
El ejemplo siguiente muestra cómo utilizar la instrucción "OPC UA-TranslatePathList":

Programación del PLC
Manual de programación y manejo, 11/2019

4325

Instrucciones
4.1 Instrucciones

SCL
IF #Run = FALSE THEN
#Started := #Input_REQ AND NOT #Mem_Input_REQ;
#Mem_Input_REQ := #Input_REQ;
IF #Started THEN
#Output_Busy := TRUE;
#Output_Done := FALSE;
#Output_Error := FALSE;
#Output_Status := 0;
#State := 1;
#Run := TRUE;
#FirstCall := TRUE;
#Set_REQ_To_FALSE := TRUE; //In case 100, to set REQ of instruction
"OPC_UA_Disconnect" to FALSE
END_IF;
END_IF;
IF #Run = TRUE THEN
CASE #State OF
1: // case 1, connect to server
IF #FirstCall = TRUE THEN
#FirstCall := FALSE;
//set ServerEndPointUrl of the server we want to connect to
#SeverEndpointUrl := WString#'opc.tcp://192.168.1.1:4840';
//set Securtiy Message Mode
// 1 = None, 2 = Sign, 3 = Sign & Encrypt
#SessionConnectInfo.SecurityMsgMode := 1;
//set Security Policy
// 1 = None, 2 = Basic128Rsa15,, 3 = Basic256, 4 = Basic256Sha256
#SessionConnectInfo.SecurityPolicy := 1;
//set the number of the client certificate you are using
//in our case, this is 6
//#SessionConnectInfo.CertificateID := 6;
END_IF;
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Connect_Instance(REQ:=#Req,
ConnectionHdl=>#ConnectionHdl,
ServerEndpointUrl:=#SeverEndpointUrl,
SessionConnectInfo:=#SessionConnectInfo,
Timeout:=T#8S,
Done=>#Done,
Busy=>#Busy,
Error=>#Error,
Status=>#Status);
IF #Done = TRUE THEN
#State := #State + 1;
#FirstCall := TRUE;
END_IF;
IF #Error = TRUE THEN
// Did we get a connection handle?
IF #ConnectionHdl <> 0 THEN

4326

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
// We got a connection handle
// We have to release all resources in the server and disconnect
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
ELSE
// We did not get a connection handle
#State := 99;
END_IF;
#Mem_Status := #Status;
// set parameter REQ of OPC_UA_Connect to FALSE
#OPC_UA_Connect_Instance(REQ := FALSE,
ServerEndpointUrl := #SeverEndpointUrl,
SessionConnectInfo := #SessionConnectInfo);
#FirstCall := TRUE;
END_IF;
2: // case 2, get index of Siemens namespace
IF #FirstCall = TRUE THEN
#FirstCall := FALSE;
//set Simatic namespace
#NamespaceUris[0] := WString#'http://www.siemens.com/simatic-s7-opcua';
END_IF;
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_NamespaceGetIndexList_Instance(REQ := #Req,
ConnectionHdl := #ConnectionHdl,
NamespaceUrisCount := 1,
NamespaceUris := #NamespaceUris,
Timeout := T#6S,
StatusList := #NamespaceStatusList,
NamespaceIndexes := #NamespaceIndexes,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
IF #NamespaceStatusList[0] = 0 THEN //one namespace
#State := #State + 1;
ELSE
#State := 100;
#Mem_Status := #Status;
#Output_Error_Message := WString#' Error at NamespaceGetIndexList, Index 0';
END_IF;
#FirstCall := TRUE;
END_IF;
IF #Error = TRUE THEN
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#State := 100;
#Mem_Status := #Status;
#OPC_UA_NamespaceGetIndexList_Instance(REQ := FALSE,
NamespaceUris := #NamespaceUris,

Programación del PLC
Manual de programación y manejo, 11/2019

4327

Instrucciones
4.1 Instrucciones
SCL
StatusList := #NamespaceStatusList,
NamespaceIndexes := #NamespaceIndexes);
#FirstCall := TRUE;
END_IF;
3: // case 3, get NodeIds from server
IF #FirstCall = TRUE THEN
//set BrowsePath[0] for DeviceInfo
//set BrowsePath.StartingNode
#BrowsePaths[0].StartingNode.Identifier := WString#'85';
#BrowsePaths[0].StartingNode.IdentifierType := 0;
#BrowsePaths[0].StartingNode.NamespaceIndex := 0;
//set BrowsePath.RelativePath
#BrowsePaths[0].RelativePath.NoOfElements := 4;
#BrowsePaths[0].RelativePath.Elements[1].ReferenceTypeId.Identifier :=
WString#'33';
#BrowsePaths[0].RelativePath.Elements[1].ReferenceTypeId.IdentifierType := 0;
#BrowsePaths[0].RelativePath.Elements[1].ReferenceTypeId.NamespaceIndex := 0;
#BrowsePaths[0].RelativePath.Elements[1].TargetName.Name :=
WString#'productionline';
#BrowsePaths[0].RelativePath.Elements[1].TargetName.NamespaceIndex :=
#NamespaceIndexes[0];
#BrowsePaths[0].RelativePath.Elements[2].ReferenceTypeId.Identifier :=
WString#'33';
#BrowsePaths[0].RelativePath.Elements[2].ReferenceTypeId.IdentifierType := 0;
#BrowsePaths[0].RelativePath.Elements[2].ReferenceTypeId.NamespaceIndex := 0;
#BrowsePaths[0].RelativePath.Elements[2].TargetName.Name :=
WString#'DataBlocksGlobal';
#BrowsePaths[0].RelativePath.Elements[2].TargetName.NamespaceIndex :=
#NamespaceIndexes[0];
#BrowsePaths[0].RelativePath.Elements[3].ReferenceTypeId.Identifier :=
WString#'33';
#BrowsePaths[0].RelativePath.Elements[3].ReferenceTypeId.IdentifierType := 0;
#BrowsePaths[0].RelativePath.Elements[3].ReferenceTypeId.NamespaceIndex := 0;
#BrowsePaths[0].RelativePath.Elements[3].TargetName.Name :=
WString#'RfidReader_Door_1';
#BrowsePaths[0].RelativePath.Elements[3].TargetName.NamespaceIndex :=
#NamespaceIndexes[0];
#BrowsePaths[0].RelativePath.Elements[4].ReferenceTypeId.Identifier :=
WString#'33';
#BrowsePaths[0].RelativePath.Elements[4].ReferenceTypeId.IdentifierType := 0;
#BrowsePaths[0].RelativePath.Elements[4].ReferenceTypeId.NamespaceIndex := 0;
#BrowsePaths[0].RelativePath.Elements[4].TargetName.Name := WString#'DeviceInfo';
#BrowsePaths[0].RelativePath.Elements[4].TargetName.NamespaceIndex :=
#NamespaceIndexes[0];
//set BrowsePath[1] for DeviceStatus
//set BrowsePath.StartingNode
#BrowsePaths[1].StartingNode.Identifier := WString#'85';
#BrowsePaths[1].StartingNode.IdentifierType := 0;
#BrowsePaths[1].StartingNode.NamespaceIndex := 0;

4328

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
//set BrowsePath.RelativePath
#BrowsePaths[1].RelativePath.NoOfElements := 4;
#BrowsePaths[1].RelativePath.Elements[1].ReferenceTypeId.Identifier :=
WString#'33';
#BrowsePaths[1].RelativePath.Elements[1].ReferenceTypeId.IdentifierType := 0;
#BrowsePaths[1].RelativePath.Elements[1].ReferenceTypeId.NamespaceIndex := 0;
#BrowsePaths[1].RelativePath.Elements[1].TargetName.Name :=
WString#'productionline';
#BrowsePaths[1].RelativePath.Elements[1].TargetName.NamespaceIndex :=
#NamespaceIndexes[0];
#BrowsePaths[1].RelativePath.Elements[2].ReferenceTypeId.Identifier :=
WString#'33';
#BrowsePaths[1].RelativePath.Elements[2].ReferenceTypeId.IdentifierType := 0;
#BrowsePaths[1].RelativePath.Elements[2].ReferenceTypeId.NamespaceIndex := 0;
#BrowsePaths[1].RelativePath.Elements[2].TargetName.Name :=
WString#'DataBlocksGlobal';
#BrowsePaths[1].RelativePath.Elements[2].TargetName.NamespaceIndex :=
#NamespaceIndexes[0];
#BrowsePaths[1].RelativePath.Elements[3].ReferenceTypeId.Identifier :=
WString#'33';
#BrowsePaths[1].RelativePath.Elements[3].ReferenceTypeId.IdentifierType := 0;
#BrowsePaths[1].RelativePath.Elements[3].ReferenceTypeId.NamespaceIndex := 0;
#BrowsePaths[1].RelativePath.Elements[3].TargetName.Name :=
WString#'RfidReader_Door_1';
#BrowsePaths[1].RelativePath.Elements[3].TargetName.NamespaceIndex :=
#NamespaceIndexes[0];
#BrowsePaths[1].RelativePath.Elements[4].ReferenceTypeId.Identifier :=
WString#'33';
#BrowsePaths[1].RelativePath.Elements[4].ReferenceTypeId.IdentifierType := 0;
#BrowsePaths[1].RelativePath.Elements[4].ReferenceTypeId.NamespaceIndex := 0;
#BrowsePaths[1].RelativePath.Elements[4].TargetName.Name :=
WString#'DeviceStatus';
#BrowsePaths[1].RelativePath.Elements[4].TargetName.NamespaceIndex :=
#NamespaceIndexes[0];
END_IF;
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_TranslatePathList_Instance(REQ := #Req,
ConnectionHdl := #ConnectionHdl,
BrowsePathsCount := 2,
BrowsePaths := #BrowsePaths,
Timeout := T#6S,
NamespaceIndexCount := 0,
TargetNodeIDs := #TagetNodeIds,
TargetStatusList := #TargetStatusList,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN

Programación del PLC
Manual de programación y manejo, 11/2019

4329

Instrucciones
4.1 Instrucciones
SCL
IF #TargetStatusList[0] = 0 AND #TargetStatusList[1] = 0 THEN
#State := #State + 1;
ELSE
#State := 100;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at TranslatePathList';
END_IF;
#FirstCall := TRUE;
END_IF;
IF #Error = TRUE THEN
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#State := 100;
#Mem_Status := #Status;
#OPC_UA_TranslatePathList_Instance(REQ := FALSE,
ConnectionHdl := #ConnectionHdl,
BrowsePaths := #BrowsePaths,
TargetNodeIDs := #TagetNodeIds,
TargetStatusList := #TargetStatusList);
#FirstCall := TRUE;
END_IF;
4: // case 4, get handles for the NodeIds we have got in case 3
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_NodeGetHandleList_Instance(REQ := #Req,
ConnectionHdl := #ConnectionHdl,
NodeIDCount := 2,
NodeIDs := #TagetNodeIds,
Timeout := T#6S,
NodeStatusList := #NodeStatusList,
NodeHdls := #NodeHdls,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
IF #NodeStatusList[0] = 0 AND #NodeStatusList[1] = 0
THEN
#State := #State + 1;
ELSE
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#State := 100;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at NodeGetHandleList';
END_IF;
END_IF;
IF #Error = TRUE THEN
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#State := 100;
#Mem_Status := #Status;

4330

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
#OPC_UA_NodeGetHandleList_Instance(REQ := FALSE,
NodeIDs := #TagetNodeIds,
NodeStatusList := #NodeStatusList,
NodeHdls := #NodeHdls);
END_IF;
5: // case 5, read the values of the NodeIds
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_ReadList_Instance(REQ := #Req,
ConnectionHdl := #ConnectionHdl,
NodeHdlCount := 2,
NodeHdls := #NodeHdls,
Timeout := T#6S,
NodeStatusList := #NodeStatusList,
Variable := #Variable,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
FOR #i := 0 TO 1 DO
IF NOT (#NodeStatusList[#i] = 0) THEN
#Output_Error_Message := CONCAT_WSTRING(IN1 := WSTRING#'Error at Readlist,
Index: ',
IN2 := INT_TO_WSTRING(#i));
END_IF;
END_FOR;
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#State := 100;
#Mem_Status := #Status;
#OPC_UA_ReadList_Instance(REQ := FALSE,
NodeHdls := #NodeHdls,
NodeStatusList := #NodeStatusList,
Variable := #Variable);
END_IF;
6: // case 6, release the node handles
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_NodeReleaseHandleList_Instance(REQ := #Req,
ConnectionHdl := #ConnectionHdl,
NodeHdlCount := 1,
NodeHdls := #NodeHdls,
Timeout := T#6S,
NodeStatusList := #NodeStatusList,

Programación del PLC
Manual de programación y manejo, 11/2019

4331

Instrucciones
4.1 Instrucciones
SCL
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #NodeStatusList[0] = 0 AND #NodeStatusList[1] = 0
THEN
#State := #State + 1;
ELSE
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#State := 100;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at NodeReleasetHandleList';
END_IF;
IF #Error = TRUE THEN
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#State := 100;
#Mem_Status := #Status;
#OPC_UA_NodeReleaseHandleList_Instance(REQ := FALSE,
NodeHdls := #NodeHdls,
NodeStatusList := #NodeStatusList);
END_IF;
7: // case 7; disconnect form server
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Disconnect_Instance(REQ := #Req,
ConnectionHdl := #ConnectionHdl,
Timeout := T#6S,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#State := 100;
#Mem_Status := #Status;
#OPC_UA_Disconnect_Instance(REQ := FALSE,
ConnectionHdl := #ConnectionHdl);
END_IF;
8: //case = 8, function block has run successfully
#Output_Done := TRUE;
#Output_Busy := FALSE;
#State := 0;
#Mem_Input_REQ := FALSE;
#Run := FALSE;
#Started := FALSE;

4332

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
99: // ERROR handling
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;
100: // ERROR handling, disconnect from server to release resources (handles)
IF #Set_REQ_To_FALSE = TRUE THEN
#Set_REQ_To_FALSE := FALSE;
//set REQ to FALSE
#OPC_UA_Disconnect_Instance(REQ := FALSE,
ConnectionHdl := #ConnectionHdl);
END_IF;
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Disconnect_Instance(REQ := #Req,
ConnectionHdl := #ConnectionHdl,
Timeout := T#6S,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;
END_IF;
IF #Error = TRUE THEN
#Output_Error_Message := WString#'Error handling: Resources cannot be released!';
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;
END_IF;
END_CASE;
END_IF;

Programación del PLC
Manual de programación y manejo, 11/2019

4333

Instrucciones
4.1 Instrucciones

Programa de ejemplo para llamar un método de un servidor OPC UA.
Programa de ejemplo para llamar un método de servidor
Este capítulo contiene el código de programa completo para el programa de ejemplo
"Call_OpenDoor_On_Productionline".
El ejemplo muestra cómo un programa de usuario emplea la instrucción
"OPC_UA_MethodCall" para llamar a un método de servidor.
Encontrará la descripción de la instrucción "OPC_UA_MethodCall" en el capítulo
OPC_UA_MethodCall: llamar método (Página 4265).
Estructura del programa
El programa trabaja como cliente OPC UA y se divide en los pasos siguientes:
1. Establecer una conexión con un servidor OPC UA.
2. Llamar el método de servidor.
3. Deshacer la conexión al servidor OPC UA.
El programa se inicia con un flanco ascendente en "Input_REQ".

4334

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Declaración
La figura siguiente muestra la declaración de las variables locales para el bloque de función
"Call_OpenDoor_On_Productionline":

Programación del PLC
Manual de programación y manejo, 11/2019

4335

Instrucciones
4.1 Instrucciones

Programa
SCL
IF #Run = FALSE THEN
#Started := #Input_REQ AND NOT #Mem_Input_REQ;
#Mem_Input_REQ := #Input_REQ;
IF #Started THEN
#Output_Busy := TRUE;
#Output_Done := FALSE;
#Output_Error := FALSE;
#Output_Status := 0;
#Output_Error_Message := WSTRING#'';
#State := 1;
#Run := TRUE;
#Init_Method_InputParameter := TRUE;
#Set_REQ_To_FALSE := TRUE;
END_IF;
END_IF;
IF #Run = TRUE THEN
CASE #State OF
1: // case 1, connect to server
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Connect_Instance(REQ := #Req,
ServerEndpointUrl := "Productionline_Configuration".Connection.ServerEndpointUrl,
SessionConnectInfo := "Productionline_Configuration".Connection.ConnectInfo,
Timeout := "Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status,
ConnectionHdl => "Productionline_Configuration".Connection.ConnectionHdl);
IF #Done = TRUE THEN
#State := #State + 1;
END_IF;
IF #Error = TRUE THEN
// Did we get a connection handle?
IF "Productionline_Configuration".Connection.ConnectionHdl <> 0 THEN
// We have to release all resources in the server and disconnect
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
ELSE
#State := 99;
END_IF;
#Mem_Status := #Status;
#OPC_UA_Connect_Instance(REQ := FALSE,
ServerEndpointUrl :=
"Productionline_Configuration".Connection.ServerEndpointUrl,
SessionConnectInfo := "Productionline_Configuration".Connection.ConnectInfo,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
ConnectionHdl => "Productionline_Configuration".Connection.ConnectionHdl);

4336

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
END_IF;
2: // case 2, get index of Siemens namespace
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_NamespaceGetIndexList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NamespaceUrisCount :=
"Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceUris := "Productionline_Configuration".Namespaces.NamespaceURIs,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
StatusList := "Productionline_Configuration".Namespaces.NamespaceStatusList,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
IF "Productionline_Configuration".Namespaces.NamespaceStatusList[0] = 0 THEN //
one namespace
#State := #State + 1;
ELSE
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#Output_Error_Message := WString#' Error at NamespaceGetIndexList, Index 0';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_NamespaceGetIndexList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NamespaceUrisCount :=
"Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceUris := "Productionline_Configuration".Namespaces.NamespaceURIs,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
StatusList := "Productionline_Configuration".Namespaces.NamespaceStatusList,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes);
END_IF;
3: // case 3, get an handle for server method OpenDoor
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;

Programación del PLC
Manual de programación y manejo, 11/2019

4337

Instrucciones
4.1 Instrucciones
SCL
END_IF;
#OPC_UA_MethodGetHandleList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeIDCount :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodCount,
ObjectNodeIDs :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".ObjectNodes,
MethodNodeIDs :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodNodes,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NamespaceIndexCount :=
"Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status,
StatusList := "Productionline_Data"."MethodListOpenDoor".MethodStatusList,
MethodHdls :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodHdls);
IF #Done = TRUE THEN
IF "Productionline_Data"."MethodListOpenDoor".MethodStatusList[0] = 0 THEN //one
method
#State := #State + 1;
ELSE
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at MethodGetHandleList';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_MethodGetHandleList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
NodeIDCount :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodCount,
ObjectNodeIDs :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".ObjectNodes,
MethodNodeIDs :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodNodes,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
NamespaceIndexCount :=
"Productionline_Configuration".Namespaces.NamespaceCount,
NamespaceIndexes :=
"Productionline_Configuration".Namespaces.ServerNamespaceIndexes,
StatusList := "Productionline_Data"."MethodListOpenDoor".MethodStatusList,
MethodHdls :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodHdls);

4338

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
END_IF;
4: // case 4, call method OpenDoor
IF #Init_Method_InputParameter = TRUE THEN
#Init_Method_InputParameter := FALSE;
// for our server method at Productionline, we set input parameters to 1
"Productionline_Data".MethodListOpenDoor.Method.Inputs.Number := 1;
END_IF;
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
OPC_UA_MethodCall_Instance(REQ := #Req,
ConnectionHdl:="Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
MethodHdl :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodHdls[0],
InputArguments := "Productionline_Data"."MethodListOpenDoor"."Method".Inputs,
OutputArguments :=
"Productionline_Data"."MethodListOpenDoor"."Method".Outputs,
Done => #Done,
Busy => #Busy,
Error => #Error
Status => "Productionline_Data"."MethodListOpenDoor".MethodStatusList[0],
MethodResult :=
"Productionline_Data"."MethodListOpenDoor".MethodResultList[0]);
//"Productionline_Data"."MethodListOpenDoor".MethodResultList[0]] contains
//the status/error codes of the server method
//which was run on the connected CPU as user program
//These codes are defined as follows:
//
Good: 0x0000_0000 TO 0x3FFF_ FFFF
//
Uncertain: 0x4000_0000 TO 0x7FFF_FFFF
//
Bad: 0x8000_0000 TO 0xFFFF_FFFF
#Output_MethodResult :=
"Productionline_Data".MethodListOpenDoor.MethodResultList[0];
IF #Done = TRUE THEN
IF #MethodResult < 16#8000_0000 THEN
#State := #State + 1;
ELSE
//server method did not run successfully
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#Output_Error_Message := WString#' Error at server method';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := "Productionline_Data".MethodListOpenDoor.MethodStatusList[0];
#OPC_UA_MethodCall_Instance(REQ := #Req,
ConnectionHdl:="Productionline_Configuration".Connection.ConnectionHdl,

Programación del PLC
Manual de programación y manejo, 11/2019

4339

Instrucciones
4.1 Instrucciones
SCL
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
MethodHdl :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodHdls[0],
InputArguments := "Productionline_Data"."MethodListOpenDoor"."Method".Inputs,
OutputArguments :=
"Productionline_Data"."MethodListOpenDoor"."Method".Outputs,
Done => #Done,
Busy => #Busy,
Error => #Error
Status => "Productionline_Data"."MethodListOpenDoor".MethodStatusList[0],
MethodResult :=
"Productionline_Data"."MethodListOpenDoor".MethodResultList[0]);
END_IF;
5: // case 5, release method handle
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_MethodReleaseHandleList_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
MethodHdlCount :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodCount,
MethodHdls :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodHdls,
StatusList := "Productionline_Data"."MethodListOpenDoor".MethodStatusList,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
#Mem_Status := #Status;
IF "Productionline_Data"."MethodListOpenDoor".MethodStatusList[0] = 0 THEN
#State := #State + 1;
ELSE
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#Output_Error_Message := WString#'Error at MethodGetHandleList';
END_IF;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_MethodReleaseHandleList_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,

4340

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SCL
MethodHdlCount :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodCount,
MethodHdls :=
"Productionline_Configuration".MethodLists."MethodListOpenDoor".MethodHdls,
StatusList := "Productionline_Data"."MethodListOpenDoor".MethodStatusList);
END_IF;
6: // case 6, disconnect from server
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Disconnect_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
#State := #State + 1;
#Mem_Status := #Status;
END_IF;
IF #Error = TRUE THEN
#State := 100;
//In case 100, to set REQ of instruction "OPC_UA_Disconnect" to FALSE
#Set_REQ_To_FALSE := TRUE;
#Mem_Status := #Status;
#OPC_UA_Disconnect_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout);
END_IF;
7: //case = 7, function block has run successfully
#Output_Done := TRUE;
#Output_Busy := FALSE;
#State := 0;
#Mem_Input_REQ := FALSE;
#Run := FALSE;
#Started := FALSE;
99: // ERROR handling
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;
100: // ERROR handling, disconnect from server to release resources (handles)
IF #Set_REQ_To_FALSE = TRUE THEN
#Set_REQ_To_FALSE := FALSE;

Programación del PLC
Manual de programación y manejo, 11/2019

4341

Instrucciones
4.1 Instrucciones
SCL
//set REQ to definitely to FALSE
#OPC_UA_Disconnect_Instance(REQ := FALSE,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout);
END_IF;
IF #Busy = FALSE THEN
#Req := TRUE;
ELSE
#Req := FALSE;
END_IF;
#OPC_UA_Disconnect_Instance(REQ := #Req,
ConnectionHdl := "Productionline_Configuration".Connection.ConnectionHdl,
Timeout :=
"Productionline_Configuration".Connection.ConnectInfo.SessionTimeout,
Done => #Done,
Busy => #Busy,
Error => #Error,
Status => #Status);
IF #Done = TRUE THEN
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;
END_IF;
IF #Error = TRUE THEN
#Output_Error_Message := WString#'Error handling: Resources cannot be
released!';
#Output_Error := TRUE;
#Output_Status := #Mem_Status;
#State := 0;
#Output_Busy := FALSE;
#Run := FALSE;
#Mem_Input_REQ := FALSE;
#Started := FALSE;
END_IF;
END_CASE;
END_IF;

4342

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Instrucciones del servidor
Métodos
OPC_UA_ServerMethodPre: preparación de la llamada de métodos del servidor
Validez
La siguiente descripción de la instrucción "OPC_UA_ServerMethodPre" se aplica a las CPU
S7-1500 con versión de firmware V2.5 y superior.

Descripción
Este capítulo describe la instrucción "OPC_UA_ServerMethodPre".
Puesto que las instrucciones "OPC_UA_ServerMethodPre" y "OPC_UA_ServerMethodPost"
deben llamarse siempre de dos en dos en el programa de usuario, consulte también el capítulo
sobre la instrucción "OPC_UA_ServerMethodPost".

Parámetros de "OPC_UA_ServerMethodPre"
Tabla 4-92

Los parámetros de la instrucción "OPC_UA_ServerMethodPre"

Parámetros

Declaración

Tipo de datos

Done

Output

BOOL

Significado
Estado de ejecución:
● 0: Ejecución de la instrucción
interrumpida, no finalizada o no
iniciada.
● 1: Ejecución de la instrucción
finalizada sin errores

Busy

Output

BOOL

Parámetro sobre el estado de la eje‐
cución:
● 0: La instrucción no se está
ejecutando
● 1: Instrucción ejecutándose en
estos momentos

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error.
Consulte el parámetro "Status".

Status

Programación del PLC
Manual de programación y manejo, 11/2019

Output

DWORD

Causa del error, consulte más abajo
"Códigos de error de Status".

4343

Instrucciones
4.1 Instrucciones
Parámetros

Declaración

Tipo de datos

Significado

UAMethodCalled

Output

BOOL

Un cliente OPC UA ha llamado el
método proporcionado.

UAMethod_InParameters

InOut

VARIANT

Puntero hacia una variable que con‐
tiene los parámetros de entrada para
el método proporcionado.

Códigos de error de Status
El parámetro "Status" informa sobre errores que pueden producirse durante la ejecución de la
instrucción.
En la siguiente tabla se describen las diferentes categorías de los códigos de error.
Tabla 4-93

Códigos de error de Status

Código de error

Explicación

(valores hexadecimales)
0000_0000

Instrucción finalizada correctamente

8xxx_xxxx

Error específico de OPC UA

Axxx_xxxx

Error específico de PLCopen

B080_C300

Recursos insuficientes

B08x_yz00

Error específico de SIMATIC

Encontrará más códigos de error en AUTOHOTSPOT

Declaración de las variables
Declare una instancia de la instrucción "OPC_UA_ServerMethodPre" y las variables con las
que se suministren valores a los parámetros de la instrucción; consulte también Programa de
ejemplo para proporcionar un método para clientes OPC UA (Página 4349).

4344

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para la declaración son importantes los siguientes puntos:
● Cree la instrucción "OPC_UA_ServerMethodPre" como multiinstancia en el bloque de
función llamante.
Nota
Nombre de la multiinstancia
La multiinstancia debe llevar forzosamente el nombre
"OPC_UA_ServerMethodPre_Instance", de lo contrario no se creará ningún método en el
servidor.
Para ello, arrastre la instrucción desde la carpeta "Instrucciones > Comunicación > OPC UA
> Servidor OPC UA" hasta el editor con la función de arrastrar y colocar.
A continuación, haga clic en "Multiinstancia".
● Si el método de servidor tiene uno o varios parámetros de entrada, debe declararse una
variable con el nombre "UAMethod_InParameters".
Cree primero un tipo de datos PLC (UDT) para los parámetros de entrada del método de
servidor.
Utilice este UDT para la variable "UAMethod_InParameters".
El tipo de datos del ejemplo se llama "UDT_OpenDoorInArguments" y contiene el elemento
Number.
Alternativa:
También puede asignar el tipo de datos "Struct" a la variable "UAMethod_InParameters".
En tal caso, cree los componentes de dicho tipo de datos en función de los parámetros de
entrada del método de servidor (mismos nombres y tipos de datos).

Llamada de la instrucción
La instrucción "OPC_UA_ServerMethodPre" pregunta al sistema operativo si se ha llamado el
método de servidor.
Si es el cliente quien ha llamado el método de servidor, la instrucción
"OPC_UA_ServerMethodPre" proporciona los parámetros de entrada para dicho método.

Programación del PLC
Manual de programación y manejo, 11/2019

4345

Instrucciones
4.1 Instrucciones

Asignación de tipos de datos (SIMATIC - OPC UA)
En lo referente a los parámetros de entrada y salida de los métodos tenga en cuenta las
explicaciones de las reglas de los tipos de datos utilizables (AUTOHOTSPOT).
Nota
Suministro de tipos de datos estructurados con matrices anidadas
Si un tipo de datos estructurado (Struct/UDT) contiene un array, el servidor OPC UA no
proporcionará información sobre la longitud de dicho array.
Si se utiliza una estructura de este tipo, p. ej. como parámetro de entrada o salida de un método
de servidor, hay que asegurarse de que la matriz anidada reciba la longitud correcta al llamar
el método.
Si no se observa esta regla, el método fallará con el código de error "BadInvalidArgument".

OPC_UA_ServerMethodPost: procesamiento posterior de la llamada de métodos del servidor
Validez
La siguiente descripción de la instrucción "OPC_UA_ServerMethodPost" se aplica a las CPU
S7-1500 con versión de firmware V2.5 y superior.

Descripción
Este capítulo describe la instrucción "OPC_UA_ServerMethodPost".
Puesto que las instrucciones "OPC_UA_ServerMethodPre" y "OPC_UA_ServerMethodPost"
deben llamarse siempre de dos en dos en el programa de usuario, consulte también el capítulo
sobre la instrucción "OPC_UA_ServerMethodPre".

Parámetros de "OPC_UA_ServerMethodPost"
Tabla 4-94

Los parámetros de la instrucción "OPC_UA_ServerMethodPost"

Parámetro

Declaración

Tipo de datos

Significado

Done

Output

BOOL

Estado de ejecución:
● 0: Ejecución de la instrucción
interrumpida, no finalizada o no
iniciada.
● 1: Ejecución de la instrucción
finalizada sin errores

Busy

Output

BOOL

Parámetro sobre el estado de la eje‐
cución:
● 0: La instrucción no se está
ejecutando
● 1: Instrucción ejecutándose en
estos momentos

4346

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Significado

Error

Output

BOOL

Indicación de error
● 0: Ningún error
● 1: Se ha producido un error.
Consulte el parámetro "Status".

Status

Output

DWORD

Causa del error, consulte más abajo
"Códigos de error de Status".

UAMethod_Result

Input

DWORD

Códigos de error para el servidor
OPC UA, proporcionados por el pro‐
grama de usuario.
Recomendación: Para notificar erro‐
res, utilice códigos que empiecen
por 0xFF. Para OPC UA están defi‐
nidos los rangos siguientes:
● Good: 0x0000_0000 hasta
0x3FFF_ FFFF
● Uncertain: 0x4000_0000 hasta
0x7FFF_FFFF
● Bad: 0x8000_0000 hasta
0xFFFF_FFFF
Según el cliente es posible que los
códigos de los rangos "Good" y "Un‐
certain" no se emitan.

UAMethod_Finished

Input

BOOL

Ponga el valor del parámetro a
TRUE si se ha ejecutado el método
proporcionado.

UAMethod_OutParameters

InOut

VARIANT

Puntero hacia una variable que con‐
tiene los parámetros de salida del
método proporcionado.

Códigos de error de Status
El parámetro "Status" informa sobre errores que pueden producirse durante la ejecución de la
instrucción.
En la siguiente tabla se describen las diferentes categorías de los códigos de error.
Tabla 4-95

Códigos de error de Status

Código de error

Explicación

(valores hexadecimales)
0000_0000

Instrucción finalizada correctamente

8xxx_xxxx

Error específico de OPC UA

Axxx_xxxx

Error específico de PLCopen

B080_C300

Recursos insuficientes

B08x_yz00

Error específico de SIMATIC

Encontrará más códigos de error en AUTOHOTSPOT

Programación del PLC
Manual de programación y manejo, 11/2019

4347

Instrucciones
4.1 Instrucciones

Declaración de las variables
Declare una instancia de la instrucción "OPC_UA_ServerMethodPost" y las variables con las
que se suministran valores a los parámetros de la instrucción; consulte también Programa de
ejemplo para proporcionar un método para clientes OPC UA (Página 4349).
Para la declaración son importantes los siguientes puntos:
● Cree la instrucción "OPC_UA_ServerMethodPost" como multiinstancia en el bloque de
función llamante.
Nota
Nombre de la multiinstancia
La multiinstancia debe llevar forzosamente el nombre
"OPC_UA_ServerMethodPost_Instance", de lo contrario no se creará ningún método en el
servidor.
Para ello, arrastre la instrucción desde la carpeta "Instrucciones > Comunicación > OPC UA
> Servidor OPC UA" hasta el editor con la función de arrastrar y colocar. A continuación,
haga clic en "Multiinstancia".
● Si el método de servidor posee uno o varios parámetros de salida, debe declararse una
variable con el nombre "UAMethod_OutParameters".
Cree primero un tipo de datos PLC (UDT) para los parámetros de salida del método de
servidor.
Utilice este UDT para la variable "UAMethod_OutParameters".
El tipo de datos del ejemplo se llama "UDT_OpenDoorOutArguments"; el único parámetro
de salida es Result.
Alternativa:
También puede asignar el tipo de datos "Struct" a la variable "UAMethod_OutParameters".
En tal caso, cree los componentes de dicho tipo de datos en función de los parámetros de
salida del método de servidor (mismos nombres y tipos de datos).

Figura 4-2

Declaración de las variables

Llamada de la instrucción
La instrucción "OPC_UA_ServerMethodPost" informa al sistema operativo de que se ha
ejecutado el método de servidor y de que los valores de los parámetros de salida son válidos.

4348

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Asignación de tipos de datos (SIMATIC - OPC UA)
En lo referente a los parámetros de entrada y salida de los métodos tenga en cuenta las
explicaciones de las reglas de los tipos de datos utilizables que se dan en el apartado
"AUTOHOTSPOT".
Nota
Suministro de tipos de datos estructurados con matrices anidadas
Si un tipo de datos estructurado (Struct/UDT) contiene un array, el servidor OPC UA no
proporcionará información sobre la longitud de dicho array.
Si se utiliza una estructura de este tipo, p. ej. como parámetro de entrada o salida de un método
de servidor, hay que asegurarse de que la matriz anidada reciba la longitud correcta al llamar
el método.
Si no se observa esta regla, el método fallará con el código de error "BadInvalidArgument".

Programa de ejemplo para proporcionar un método para clientes OPC UA
Programa de ejemplo para un método de servidor
Este capítulo contiene el código de programa completo para el programa de ejemplo
"OpenDoor".
El ejemplo muestra cómo un programa de usuario emplea las instrucciones
"OPC_UA_ServerMethodPre" y "OPC_UA_ServerMethodPost".
Las instrucciones se describen en los capítulos OPC_UA_ServerMethodPre: preparación de
la llamada de métodos del servidor (Página 4343) y OPC_UA_ServerMethodPost:
procesamiento posterior de la llamada de métodos del servidor (Página 4346).
El programa proporciona un método de servidor para clientes OPC UA: El programa pone el
parámetro de salida "Result" al valor 1 cuando el parámetro de entrada "Number" tiene el valor
"1".
Para que el ejemplo siga siendo sencillo y claro, se ha renunciado a una evaluación de errores
detallada (parámetro "Status").
Estructura del programa
El programa se divide en las secciones siguientes:
1. Llamada de la instrucción "OPC_UA_ServerMethodPre" para determinar si un cliente ha
llamado el método de servidor.
2. Si se ha llamado el método de servidor, se ejecuta dicho método. Define la funcionalidad
propiamente dicha en la llamada del método por un cliente OPC UA.
3. Cuando el método de servidor ha finalizado, se llama la instrucción
"OPC_UA_ServerMethodPost". Esta sección informa al sistema operativo de que se ha
ejecutado el método de servidor.

Programación del PLC
Manual de programación y manejo, 11/2019

4349

Instrucciones
4.1 Instrucciones

Declaración
La figura siguiente muestra la declaración de las variables locales para el programa de ejemplo:

Programa
El programa siguiente muestra cómo se utilizan las instrucciones OPC UA para proporcionar
un método para clientes OPC UA que se ejecute en el programa de usuario (método de
servidor).
Llamada de la instrucción "OPC_UA_ServerMethodPre"
Primero se llama la instrucción "OPC_UA_ServerMethodPre" para consultar al sistema
operativo si el método de servidor ha sido llamado por un cliente OPC UA.
Si se ha llamado el método de servidor, la variable "#Method_Called" es igual a "TRUE".
Si además la instrucción "OPC_UA_ServerMethodPre" se ha ejecutado correctamente
(#Pre_Done = TRUE), la variable "#Started" adopta el valor "TRUE".
Método de servidor
Si la variable "#Started" tiene el valor "TRUE", entonces se ejecuta el verdadero programa de
usuario.
En esta sección se dispone de todas las posibilidades de programación: Pueden leerse o
emitirse valores de proceso, puede accederse a bloques de datos globales, puede llamarse a
funciones y bloques de función, etc.
El programa de usuario puede durar varios ciclos.
Para indicar el final del programa de usuario, ponga la variable "#Method_Finished" a "TRUE".

4350

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Con "#Method_Result" se transmite un código de error definido por el usuario que se utiliza en
el parámetro de bloque "UAMethod_Result" de la instrucción "OPC_UA_ServerMethodPost".
Llamada de la instrucción "OPC_UA_ServerMethodPost"
La variable "#Method_Finished" se ha activado (método de servidor) para guardar el estado
que indica que se ha ejecutado el programa de usuario.
Esta variable se utiliza en la instrucción "OPC_UA_ServerMethodPost" para informar al
sistema operativo de si se ha ejecutado el método de servidor o no.

Programación del PLC
Manual de programación y manejo, 11/2019

4351

Instrucciones
4.1 Instrucciones
Seguidamente, el sistema operativo se encarga de acusar recibo al cliente que ha llamado el
método.

4352

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

SCL
REGION PRE
IF #Started = FALSE AND #Method_Finished = FALSE THEN
#OPC_UA_ServerMethodPre_Instance(Done => #Pre_Done,
Error => #Pre_Error,
UAMethod_Called => #Method_Called,
UAMethod_InParameters := #UAMethod_InParameters);
IF #Pre_Error THEN
#Error_Message := WString#'Error at OPC_UA_ServerMethodPre';
END_IF;
IF #Pre_Done AND #Method_Called THEN
#Started := TRUE;
#Error_Message := WString#'';
END_IF;
END_IF;
END_REGION
REGION FUNCTIONALITY
// The purpose of this demo method is to demonstrate the basic structure of a server
method
IF #Started = TRUE THEN
// This demo server method just checks if input parameter
#UAMethod_InParameters.Number is 1
// If this is the case, the server method sets the ouput parameter.
IF #UAMethod_InParameters.Number = 1 THEN
//set doorLocked to false, so that the door can be opened
#doorLocked := FALSE;
//set values for output parameters
//this is just an example
#UAMethod_OutParameters.Result := 1;
#Method_Result := 16#0000_0000;
#Method_Finished := TRUE;
#Started := FALSE;
ELSE
#Error_Message := WString#'Input-Parameter Number must be 1 to run this example
server method';
//we send back an error code to the calling OPC UA client
//for our example, we define 16#FFFF_FFFF = "Input-Parameter Number must be 1"
#Method_Result := 16#FFFF_FFFF;
#Started := FALSE;
#Method_Finished := TRUE;
END_IF;
END_IF;
END_REGION
REGION POST
IF #Method_Finished = TRUE THEN
#OPC_UA_ServerMethodPost_Instance(UAMethod_Result := #Method_Result,

Programación del PLC
Manual de programación y manejo, 11/2019

4353

Instrucciones
4.1 Instrucciones
SCL
UAMethod_Finished := #Method_Finished,
Done => #Post_Done,
Error => #Post_Error,
UAMethod_OutParameters := #UAMethod_OutParameters);
IF #Post_Error = TRUE THEN
#Error_Message := WString#'Error at OPC_UA_ServerMethodPost';
#Method_Finished := FALSE;
END_IF;
IF #Post_Done = TRUE THEN
#Method_Finished := FALSE;
END_IF;
END_IF;
END_REGION

Borrar un método
Si ya no se dispone de un método de servidor y debe borrarse, no solo hay que eliminar la
llamada del FB correspondiente sino también borrar el bloque de datos de instancia.
Si no se borra el bloque de datos de instancia, el método es visible en el espacio de direcciones
y las variables no reciben valores.

4.1.6.4

Servidor web

WWW: sincronizar páginas de usuario
WWW: sincronizar páginas de usuario
Descripción
La instrucción WWW inicializa el servidor web de la CPU, o sincroniza las páginas web
definidas por el usuario, es decir: "páginas de usuario" con el programa de usuario de la CPU.
Las páginas de usuario, junto con el servidor web de la CPU, ofrecen la posibilidad de acceder
con un navegador web a páginas web de libre configuración de la CPU.
Mediante instrucciones de scripts (por ej., Javascript) y de código HTML en páginas de
usuario, es posible transmitir datos a la CPU desde un navegador web para su posterior
procesamiento, así como visualizar datos del área de operandos de la CPU en el navegador.
Para la sincronización del programa de usuario con el servidor web, y también para la
inicialización, es necesario llamar la instrucción "WWW" en el programa de usuario.

4354

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Inicialización
Las páginas de usuario se "comprimen" en bloques de datos para que la CPU pueda
procesarlas. Durante la configuración deberá generar los correspondientes bloques de datos
a partir de los datos fuente (archivos HTML, imágenes, archivos Javascript...). El DB Web
Control (por defecto: DB 333), que contiene información de estado y de control, así como
referencias a otros bloques de datos con páginas web cifradas, desempeña una función
particular. Los bloques de datos con páginas web codificadas se denominan DB de fragmento.
Si los bloques de datos se han cargado en la CPU, esta no "sabe" que las páginas de usuario
que contiene están cifradas. Por medio de la instrucción "WWW", por ejemplo, en el OB de
arranque, se notifica a la CPU qué DB es el DB Web Control. Tras esta inicialización, es posible
acceder a las páginas de usuario desde un navegador web.

Sincronización
Si el programa de usuario debe interactuar con las páginas de usuario, se debe utilizar la
instrucción "WWW" en la parte cíclica del programa.
Ejemplos de interacción entre programa de usuario y página web:
● Comprobar los datos recibidos
● Recopilar y reenviar los datos para el navegador web solicitante
En este caso, la información de estado ha de poder evaluarse en el acto, debiendo notificarse
al servidor la información de control, por ejemplo, para habilitar una página web solicitada por
el navegador web.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "WWW":
Parámetro

Declaración

Tipo de
datos

Área de memo‐ Descripción
ria

CTRL_DB

Input

DB_WWW I, Q, M, D, L o
constante

Bloque de datos que escribe en las pági‐
nas de usuario (DB Web Control)

RET_VAL

Output

INT

Información de error

I, Q, M, D, L

Encontrará más información sobre los tipos de datos válidos en Vista general de los tipos de
datos válidos (Página 241).

Programación del PLC
Manual de programación y manejo, 11/2019

4355

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
Código de
error
(W#16#...)

Explicación

0000

No ha ocurrido ningún error. No hay pendiente ninguna solicitud de página web que
deba ser habilitada por el programa de usuario.

00xy

x: indica si ha ocurrido un error al inicializar el DB Web Control (CTRL_DB):
x=0: no ha ocurrido ningún error.
x=1: se han producido errores. El error está codificado en el byte "CTRL_DB.last_error"
del DB Web Control, consulte la descripción del DB Web Control.
y: número de peticiones pendientes. Son posibles varias peticiones (p. ej., petición "0"
y "1" pendientes: y="3".
y="1": petición "0"
y="2": petición "1"
y="4": petición "2"
y="8": petición "3"

803A

El DB Web Control indicado no se encuentra en la CPU.

8081

Versión o formato erróneos del DB Web Control.

8082

El servidor web no está activado.

80C1

No se dispone de recursos para inicializar la aplicación web, p. ej., porque solamente
pueden ejecutarse dos o cuatro aplicaciones web.

Ejemplo
Encontrará el ejemplo aquí: Ejemplo de programa para WWW (Página 4356).
Encontrará información adicional y el código del programa del ejemplo aquí: Sample Library for
Instructions (Página 615).

Consulte también
Vista general de los tipos de datos válidos (Página 241)

Ejemplo de programa para WWW
Introducción
En el ejemplo siguiente se sincroniza una página web definida por el usuario con el ejemplo de
programa en una CPU S7-1500 y se prueba el ejemplo de programa utilizando el servidor web.

4356

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Requisitos
Para almacenar los datos es preciso crear diecinueve variables en un bloque de datos global.

Interconectar parámetros - en el FB "SLI_FB_www"
Las interconexiones siguientes se crean en un FB "SLI_FB_www". El FB se llama en un OB1.
Segmento 1: Los parámetros de la instrucción "WWW" se interconectan del siguiente modo.

Segmento 2: El programa para la página web se crea en la FC "SLI_FC_MainWebProg_www".
A continuación, se llama la FC "SLI_FC_MainWebProg_www" en el segmento 2 del FB.

Programación del PLC
Manual de programación y manejo, 11/2019

4357

Instrucciones
4.1 Instrucciones

Interconectar parámetros: en la FC "SLI_FC_SetTOD_www"
En una FC "SLI_FC_SetTOD_www" se crea un programa para utilizar un OB de alarma horaria
(OB11). Cree las interconexiones siguientes:
Segmento 1: En la FC se interconectan las siguientes variables locales con las instrucciones
"RD_SYS_T" y "T_ADD".

Segmento 2: A continuación se interconectan las variables para ajustar el OB de alarma
horaria.
La variable local "#startDateTime" (tipo de datos "Date_And_Time") transfiere la fecha y hora
de inicio al OB de alarma horaria.

Segmento 3: A continuación se interconectan las variables para activar el OB de alarma
horaria.

4358

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Interconectar parámetros - en el OB "SLI_todOB_www"
En el OB de alarma horaria "SLI_todOB_www" (OB11) se crean las interconexiones siguientes
para incrementar cíclicamente la variable "tankLevel".

Interconectar parámetros: en la FC "SLI_FC_MainWebProg_www"
Las interconexiones siguientes se crean en la FC "SLI_FC_MainWebProg_www".
El programa de "SLI_FC_MainWebProg_www" permite controlar un motor, una válvula y el
llenado del depósito. Además, permite emitir diferentes estados de alarma. El programa se
maneja con el servidor web.
Segmento 1: La FC "SLI_FC_SetTOD_www" se llama en la FC "SLI_FC_MainWebProg_www".

Segmento 2: A continuación se interconectan las variables para abrir la válvula.

Segmento 3: A continuación se interconectan las variables para arrancar el motor.

Segmento 4: A continuación se interconectan las variables para consultar el estado de alarma
"1".

Programación del PLC
Manual de programación y manejo, 11/2019

4359

Instrucciones
4.1 Instrucciones

Segmentos 5 a 8: A continuación se interconectan las variables para consultar el estado de
alarma "2".
Siga el mismo esquema para interconectar variables con el fin de consultar los estados de
alarma restantes.

Segmento 9: A continuación se interconectan las variables para apagar el motor e inicializar el
llenado del depósito.

Segmento 10: A continuación se interconectan las variables para inicializar todos los valores
restantes (BOOL).

4360

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Configurar las propiedades de la CPU
Realice los ajustes siguientes en las propiedades de la CPU:
● Active el acceso al servidor web en "... > Interfaz PROFINET > Acceso al servidor web".
● Active el servidor web para el módulo en "Propiedades de la CPU > Servidor web".
● En la sección "Administración de usuarios" cree un usuario nuevo con derechos de lectura
y escritura.
● En la sección "Páginas de usuario" realice los ajustes siguientes:
– Ajuste la "Ruta de archivo HTML".
Nota
La ruta de almacenamiento debería ser la misma que la de Sample Library for
Instructions (SLI). El nombre de la carpeta es "SLI_html". Por ejemplo: "C:\TIA\_library
\SLI_html".
– Introduzca el texto "index.html" para la "página de inicio HTML".
– Introduzca el nombre "WWW sample" para la aplicación.
– Haga clic en el botón "Crear bloque". El DB web (333) y el DB de fragmento (334) se
crean a continuación.

Resultado para WWW
Si el contacto NA ("executeWWW") devuelve el estado lógico "TRUE", se ejecuta la instrucción
"WWW". En el parámetro de entrada CTRL_DB ("333") se deposita el número del bloque de
datos que describe la página web definida por el usuario. La instrucción "WWW" inicializa la
página web definida por el usuario en el servidor web de la CPU y sincroniza de inmediato el
contenido con el ejemplo de programa.
En el parámetro de salida RET_VAL ("returnValueWWW") se indica que la ejecución se ha
realizado sin errores.

Programación del PLC
Manual de programación y manejo, 11/2019

4361

Instrucciones
4.1 Instrucciones

Resultado para el servidor web
El servidor web se llama desde el "Navegador de Internet > IP del servidor web". Inicie una
sesión con el nombre del usuario y la contraseña.
En "Páginas de usuario" del servidor web se muestra un enlace a la página web definida por
el usuario.

En la página web del ejemplo de programa existe la posibilidad tanto de emitir variables como
de transferir valores nuevos a las variables.

4362

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Funciones utilizadas en el documento HTML
A continuación se muestran extractos de las funciones utilizadas en el ejemplo de programa y
que se utilizan para transferir las variables al código fuente en el documento HTML. Para cada
función se implementa una variable en el documento HTML por medio de una llamada y se
utiliza en el lugar correspondiente del documento HTML mediante otra llamada.
Función

Para la llamada en el documento HTML Para la salida en el elemento HTML

Salida de datos:

<!-- AWP_In_Variable
:="SLI_gDB_www".tankLevel:
Name='"SLI_gDB_www".tankLevel
' -->

Enumeración (sustitución de valores):

<!-- AWP_Enum_Def
Name="OpValvValue"
Values='0:"Closed",
1:"Opened"' -->

Programación del PLC
Manual de programación y manejo, 11/2019

<!-- AWP_Enum_Ref
Name='"SLI_gDB_www".valveOutp
ut' Enum="OpValvValue" ->:="SLI_gDB_www".valveOutput:

4363

Instrucciones
4.1 Instrucciones
Función

Para la llamada en el documento HTML Para la salida en el elemento HTML

Modificación de valor (de INT):

<!-- AWP_In_Variable
<form method="post"
Name='"SLI_gDB_www".flowrate' action="" onsubmit="return
-->
check();">
<input type="text"
name='"SLI_gDB_www".flowrate'
size="10px"/>
<input class="button1"
type="submit" value="Set
flowrate"/>
</form>

Modificación de valor (de BOOL):

<!-- AWP_Enum_Def
Name="ResetValue"
Values='0:"Off", 1:"On"' -->

<form method="post"
action="">
<input class="button1"
type="submit" value="Reset"/>
<input type="hidden"
name='"SLI_gDB_www".reset'
size="34px" value="1"/>
</form>

Código del programa
Encontrará información adicional y el código del programa para el ejemplo anterior
aquí: Sample Library for Instructions (Página 615).

4.1.6.5

Procesador de comunicaciones

CM/CP SIMATIC NET
S7-300/400-CP
CP 443-1 OPC UA
Bloques de programa para el cliente UA OPC
Sinopsis de los bloques de programa para la función de cliente OPC UA
Para la función de cliente OPC UA del CP, en la librería "SIMATIC NET CP" existen los bloques
de función indicados a continuación. Utilice los bloques en la CPU.
Algunos bloques requieren tipos de datos PLC personalizados especiales (UDT), que
encontrará a continuación debajo del bloque de programa correspondiente. Los UDT están
disponibles como tipos de datos preconfeccionados. Para ello, cree un tipo de datos nuevo en
la entrada "Tipos de datos PLC" de la estación y escriba en el campo "Tipo de datos" el nombre

4364

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
del UDT, p. ej. "UA_SessionConnectInfo". Seguidamente, los parámetros necesarios en cada
caso se crearán de forma automática en la tabla de declaración del UDT.
● UA_Connect
Establece una conexión para una sesión con un servidor OPC UA.
– UA_SessionConnectInfo
Contiene la información de conexión para el parámetro de bloque "SessionConnectInfo".
– UA_UserIdentityToken
Contiene los datos de la autenticación de usuario para el parámetro de bloque
"UserIdentityToken".
● UA_NamespaceGetIndex
Recoge el índice de espacio de nombre de una URI de espacio de nombre.
● UA_NodeGetHandleList
Registra ID de nodo en el servidor conectado y recoge los handles de nodo en forma de lista.
– UA_NodeID
Contiene los parámetros para la identificación del nodo de destino para el parámetro de
bloque "NodeID".
● UA_NodeReleaseHandleList
Libera los handles de nodo de la lista utilizada en el servidor.
● UA_Disconnect
Establece la conexión de una sesión actual con un servidor OPC UA.
● UA_ReadList
Lee los datos de nodos del servidor conectado con ayuda de la lista.
– UA_NodeAdditionalInfo
Especifica el atributo Item y el rango de índices para el parámetro de bloque
"NodeAddInfos".
– UA_IndexRange
Determina los índices de inicio y fin para el parámetro de bloque "IndexRange".
– UA_AnyPointer
Refiere al área de memoria de la CPU en la que se depositan los datos de proceso para
el parámetro de bloque "Variables".
– UA_TimeStamps
Contiene el sello de tiempo de los elementos del área de datos del parámetro de bloque
"Variables".
● UA_WriteList
Escribe datos en nodos del servidor conectado con ayuda de la lista de los handles de nodo.
– UA_NodeAdditionalInfo
Especifica el atributo Item y el rango de índices para el parámetro de bloque
"NodeAddInfos".
– UA_IndexRange
Determina los índices de inicio y fin para el parámetro de bloque "IndexRange".
– UA_AnyPointer
Refiere al área de memoria de la CPU en la que están depositados los datos de proceso
para el parámetro de bloque "Variables".

Programación del PLC
Manual de programación y manejo, 11/2019

4365

Instrucciones
4.1 Instrucciones

Funciones de sistema (SFC) necesarias adicionalmente
Para que los bloques de programa para el cliente UA OPC funcionen por completo se
necesitan las funciones de sistema siguientes:
● BLKMOV (SFC20)
● TIME_TCK (SFC64)
UA_Connect necesita adicionalmente para su funcionamiento:
● LGC_GADR (SFC49)
● RDSYSST (SFC51)
Creación de las SFCs
Cree las funciones de sistema abriendo un bloque de organización (p. ej. OB1) en el directorio
de bloques de la CPU.
En el catálogo de bloques que se muestra al abrir el OB1, despliegue el grupo de bloques
correspondiente.
Encontrará las SFCs en las siguientes carpetas de bloque:
● BLKMOV (SFC20): Grupo "Instrucciones básicas" > carpeta "Mover"
● TIME_TCK (SFC64): Grupo "Instrucciones avanzadas" > carpeta "Fecha y hora"
● LGC_GADR (SFC 49): Grupo "Instrucciones avanzadas" > carpeta "Direccionamiento"
● RDSYSST (SFC 51): Grupo "Instrucciones avanzadas" > carpeta "Diagnóstico"
Arrastre las SFCs al segmento del bloque de organización y suministre los parámetros de las
SFCs.

Llamada e interacción de los bloques de programa
Nota
Indicaciones generales sobre los bloques de programa y los DBs de instancia
Cree los bloques de función con "acceso estándar". Deje la opción "Remanencia" desactivada
en los bloques de datos de instancia que se asignan en cada caso.
Cada bloque de programa debe llamarse cíclicamente hasta que el parámetro de estado
"Done" o "Error" cambie a 1.
Dentro de la sesión solo se puede llamar un único bloque simultáneamente. Dentro de una
sesión los bloques diferentes solo pueden editarse uno después de otro.
Con UA_Connect se establece una conexión entre el CP como cliente OPC UA y un servidor
UA abriendo así una sesión. El bloque debe llamarse para cada conexión con un servidor UA.
En caso necesario, para más de una conexión con un servidor UA el bloque puede llamarse
varias veces con bloques de datos de instancia (IDB) diferentes. Esto puede utilizarse, por
ejemplo, para leer una conexión y escribir a través de una segunda conexión o para leer o
escribir diferentes datos a través de varias conexiones.

4366

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para conexiones con varios servidores UA es necesario llamar el bloque UA_Connect varias
veces con parámetros de entrada distintos. Como cliente UA el CP puede establecer
conexiones con hasta cinco servidores UA.
Para consultar el índice de espacio de nombre de una URI de espacio de nombre del servidor
UA, llame un UA_NamespaceGetIndex dentro de la sesión. Para consultar varios URIs de
espacio de nombre el bloque se puede llamar varias veces con parámetros de entrada
distintos.
Para crear una lista de handles como preparación de los servicios de lectura y escritura llame
la UA_NodeGetHandleList. El bloque se llama por separado para cada nodo de destino con la
información correspondiente en el parámetro de entrada "NodeIDs".
A continuación se pueden leer y escribir los datos del item a través de los bloques UA_ReadList
y UA_WriteList. Ambos bloques pueden llamarse tantas veces como se desee dentro de una
misma sesión.
(VWDEOHFLPLHQWRGHXQDVHVLµQ
3UHSDUDFLµQSDUDOHHUHVFULELU
8$B&RQQHFW
8$B1DPH6SDFH*HW,QGH[
8$B1RGH*HW+DQGOH/LVW

8$B5HDG/LVW

7HUPLQDFLµQGHXQDVHVLµQ

RELHQ

8$B1RGH5HOHDVH+DQGOH/LVW

8$B:ULWH/LVW

8$B'LVFRQQHFW

Figura 4-3

Llamada e interacción de los bloques de programa cliente

Cuando la conexión ya no sea necesaria, vuelva a liberar handles en el servidor mediante el
bloque UA_NodeReleaseHandleList. De ese modo los handles se vuelven a borrar en el
servidor.
La conexión se deshace con UA_Disconnect, con lo que también se cierra la sesión.

Consulte también
Vigilancia temporal de los bloques (Página 4368)

Programación del PLC
Manual de programación y manejo, 11/2019

4367

Instrucciones
4.1 Instrucciones

Vigilancia temporal de los bloques
Parámetros del comportamiento temporal de los bloques
Para el control y la vigilancia del comportamiento temporal de los bloques de programa están
disponibles los tres parámetros siguientes:
● Timeout
Parámetro de entrada en todos los bloques para el cliente OPC UA
● SessionTimeout
Parámetro de entrada en el bloque UA_Connect
● MonitorConnection
Parámetro de entrada en el bloque UA_Connect
Puesto que los parámetros influyen en conjunto en la ejecución de la comunicación OPC UA,
a continuación se incluyen indicaciones relativas a estos parámetros antes de la descripción
de los bloques propiamente dicha.

Timeout
Este parámetro de entrada vigila todas las llamadas de un bloque. Si una llamada de bloque
no puede finalizarse dentro del tiempo máximo admisible que se ha configurado en cada caso,
el parámetro de estado "Error" se pone a 1 y se cancela la ejecución.

SessionTimeout
Este parámetro de entrada vigila la duración de una sesión sin tráfico de datos sin que el
bloque "UA_Disconnect" se llame para deshacer una conexión.
El valor mínimo de "SessionTimeout" suele ser de 30 segundos. Si se rebasa este valor se
deshace la conexión.
Este parámetro permite a un servidor liberar recursos vinculados cuando el cliente no utiliza la
sesión durante un tiempo prolongado.
Un tiempo suficientemente largo, en cambio, garantiza que una sesión no se cierre
inmediatamente cuando no es posible transferir datos en seguida a causa de fallos en la red,
por ejemplo.
Por norma general, el valor de "SessionTimeout" debería ser mayor que los valores de
"Timeout" en los bloques "UA_Connect" utilizados.

MonitorConnection
Este parámetro de entrada comprueba el estado de una conexión sin tráfico de datos. Una vez
transcurrido este tiempo de vigilancia de conexión se envía un telegrama para comprobar el
estado de la conexión con el servidor.
Para que la sesión no se cancele en seguida mediante el parámetro "SessionTimeout" en caso
de ausencia de tráfico de datos y de activación del tiempo de vigilancia de conexión, se
recomienda elegir para "MonitorConnection" un valor inferior a la mitad de "SessionTimeout".

4368

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Bloques de programa para el cliente UA OPC (Página 4364)

UA_Connect
Función
Función del bloque
Con el bloque UA_Connect se establece una conexión entre el CP como cliente OPC UA y un
servidor UA, abriendo así una sesión.
Como dirección de destino indique la URL del servidor UA en el parámetro
"ServerEndpointUrl".
Los datos correspondientes a la información de la conexión del parámetro
"SessionConnectInfo" se guardan en un bloque de datos.
UA_Connect requiere además las funciones de sistema LGC_GADR (SFC 49) y RDSYSST
(SFC 51).

Consulte también
Parámetros (Página 4369)
Bloques de programa para el cliente UA OPC (Página 4364)

Parámetros
Parámetros de bloque
En la tabla siguiente se explican los parámetros formales del bloque de programa.
Tabla 4-96

Parámetros del bloque UA_Connect

Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado

Execute

IN

BOOL

0, 1

Un flanco ascendente 0 → 1 en el parámetro ini‐
cia el procesamiento del bloque.

ServerEndpointUrl

IN

STRING

Máx. 254 caracte‐
res

Dirección (URL) del interlocutor (servidor). Solo
se admiten direcciones IPv4.

SessionConnectInfo

IN

UDT

Véase "Significa‐
do"

Información de la conexión, véase UASession‐
ConnectInfo (Página 4383).

Programación del PLC
Manual de programación y manejo, 11/2019

4369

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado

Timeout

IN

TIME

5000 .. 120000

Intervalo máximo para el establecimiento de la
conexión en milisegundos. Si se rebasa este va‐
lor, el procesamiento del bloque se cancela con
el número de error B0007001.
Si se realizan entradas fuera del rango permiti‐
do, se aplica el valor predeterminado de 60000
(60 segundos).

ConnectionHdl

OUT

DWORD

1 .. 5

Identificador unívoco de una conexión estableci‐
da
Este es requerido por otros bloques como pará‐
metro de entrada.

Done

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: procesamiento de bloque cancelado, aún
no finalizado o aún no iniciado
● 1: el bloque se ha procesado sin errores

Busy

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: el bloque no se está procesando
● 1: el bloque se está procesando

Error

OUT

BOOL

0, 1

Indicación de error
● 0: sin error
● 1: se ha producido un error. Consulte el
parámetro "ErrorID".

ErrorID

OUT

DWORD

Véase "Significa‐
do"

Indicación del número de error si "Error" = 1.
Respecto al significado de los números, consul‐
te el capítulo Números de error (Página 4389).
Nota: Si se emite el código de error B000F002, la
sesión OPC UA todavía no está establecida.
Vuelva a llamar el bloque.

UA_NamespaceGetIndex
Función
Función del bloque
Con el bloque UA_NamespaceGetIndex se recoge el índice de espacio de nombre de la URI
de espacio de nombre del servidor UA conectado.

Consulte también
Parámetros (Página 4371)
Bloques de programa para el cliente UA OPC (Página 4364)

4370

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
Parámetros de bloque
En la tabla siguiente se explican los parámetros formales del bloque de programa.
Tabla 4-97

Parámetros del bloque UA_NamespaceGetIndex

Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado

Execute

IN

BOOL

0, 1

Un flanco ascendente 0 → 1 en el parámetro ini‐
cia el procesamiento del bloque. Mientras Exe‐
cute sea 1, los parámetros de entrada restantes
no pueden modificarse.

ConnectionHdl

IN

DWORD

1 .. 5

Identificación de conexión suministrado por
UA_Connect

NamespaceUri

IN

STRING

Máx. 254 caracte‐
res

Indicación de la dirección (URI de espacio de
nombre) del servidor de destino
Ejemplo del espacio de nombre de los símbolos
de CPU en el S7‑400 con CP 443‑1 OPC UA:
http://www.siemens.com/simatic-classic-s7-op‐
cua

Timeout

IN

TIME

5000 .. 120000

Intervalo máximo para el establecimiento de la
conexión en milisegundos. Si se rebasa este va‐
lor, el procesamiento del bloque se cancela con
el número de error B0007001.
Si se realizan entradas fuera del rango permiti‐
do, se aplica el valor predeterminado de 60000
(60 segundos).

NamespaceIndex

OUT

WORD

0 .. 65535

Se deposita el índice de espacio de nombre del
espacio de nombre indicado en el parámetro
"NamespaceUri".
Los índices de espacio de nombre 0 y 1 están
reservados y especificados por la OPC Founda‐
tion.

Done

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: procesamiento de bloque cancelado, aún
no finalizado o aún no iniciado
● 1: el bloque se ha procesado sin errores

Busy

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: el bloque no se está procesando
● 1: el bloque se está procesando

Programación del PLC
Manual de programación y manejo, 11/2019

4371

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado

Error

OUT

BOOL

0, 1

Indicación de error
● 0: sin error
● 1: se ha producido un error. Consulte el
parámetro "ErrorID".

ErrorID

OUT

DWORD

Véase "Significa‐
do"

Indicación del número de error si "Error" = 1.
Respecto al significado de los números, consul‐
te el capítulo Números de error (Página 4389).

UA_NodeGetHandleList
Función
Función del bloque
Con el bloque UA_NodeGetHandleList se registran ID de nodo en el servidor UA conectado.
El servidor UA devuelve los handles. El bloque deposita dichos handles en el parámetro
"NodeHdls" A los items de los handles de nodo se accede con los bloques "UA_ReadList" y
"UA_WriteList" en el parámetro de entrada "NodeHdls".
Los IDs de nodo del servidor de destino especificados en el parámetro de entrada "NodeIDs"
deben conocerse. Se depositan en un UDT "UANodeIDs".
El número de nodos de destino en el parámetro de entrada "NodeIDCount" siempre es 1, por
lo que hay que llamar el bloque por separado para cada ID de nodo.

Consulte también
Parámetros (Página 4372)
Bloques de programa para el cliente UA OPC (Página 4364)

Parámetros
Parámetros de bloque
En la tabla siguiente se explican los parámetros formales del bloque de programa.
Tabla 4-98

Parámetros del bloque UA_NodeGetHandleList

Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado

Execute

IN

BOOL

0, 1

Un flanco ascendente 0 → 1 en el parámetro ini‐
cia el procesamiento del bloque.

ConnectionHdl

IN

DWORD

1 .. 5

Identificación de conexión suministrado por
UA_Connect

4372

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado

NodeIDCount

IN

WORD

1

Número de elementos en el área de datos de
"NodeIDs". El número debe ser 1.

NodeIDs

IN

ARRAY of
UDT

Véase "Significa‐
do"

Estructura de los parámetros del nodo de desti‐
no del servidor OPC UA.
El número de IDs de nodo (1) debe ser idéntico
al número depositado en el parámetro de salida
"NodeHdls".
Respecto a la estructura de UDT consulte UA‐
NodeID (Página 4385).

Timeout

IN

TIME

5000 .. 120000

Intervalo máximo para el establecimiento de la
conexión en milisegundos. Si se rebasa este va‐
lor, el procesamiento del bloque se cancela con
el número de error B0007001.
Si se realizan entradas fuera del rango permiti‐
do, se aplica el valor predeterminado de 60000
(60 segundos).

NodeHdls

OUT

ARRAY of
DWORD

0 .. 4 294 967 295

Matriz de los handles que el servidor OPC UA
devuelve como respuesta a la solicitud del clien‐
te. Los handles permiten identificar unívocamen‐
te el item en el servidor.
Los handles son válidos hasta que son reempla‐
zados o pierden la validez debido a la llamada
del bloque UA_NodeReleaseHandleList.
Cuando se cierra la sesión, el CP deshace todos
los handles de nodos registrados de dicha se‐
sión.
El parámetro se utiliza para el parámetro de en‐
trada "NodeHdls" de los bloques "UA_ReadList"
y "UA_WriteList".

Done

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: procesamiento de bloque cancelado, aún
no finalizado o aún no iniciado
● 1: el bloque se ha procesado sin errores

Busy

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: el bloque no se está procesando
● 1: el bloque se está procesando

Error

OUT

BOOL

0, 1

Indicación de error
● 0: sin error
● 1: se ha producido un error. Consulte el
parámetro "ErrorID".

Programación del PLC
Manual de programación y manejo, 11/2019

4373

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado

ErrorID

OUT

DWORD

Véase "Significa‐
do"

Indicación del número de error si "Error" = 1.

Véase "Significa‐
do"

Contiene los números de error para todos los
elementos del área de datos de "NodeIDs".

NodeErrorIDs

OUT

ARRAY of
DWORD

Respecto al significado de los números, consul‐
te el capítulo Números de error (Página 4389).

Respecto al significado de los números, consul‐
te el capítulo Números de error (Página 4389).

UA_NodeReleaseHandleList
Función
Función del bloque
Con el bloque UA_NodeReleaseHandleList se liberan los handles de nodo de la sesión actual
en el servidor UA conectado. Con ello se borra la lista.
El parámetro de entrada "NodeHdls" referencia el bloque de datos en el que se escribieron los
handles del parámetro de salida "NodeHdls" del bloque "UA_NodeGetHandleList".
El número de handles en el parámetro de entrada "NodeHdICount" siempre es 1, por lo que
hay que llamar el bloque por separado para cada handle.

Consulte también
Parámetros (Página 4374)
Bloques de programa para el cliente UA OPC (Página 4364)

Parámetros
Parámetros de bloque
En la tabla siguiente se explican los parámetros formales del bloque de programa.
Tabla 4-99

Parámetros del bloque UA_NodeReleaseHandleList

Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado / Observación

Execute

IN

BOOL

0, 1

Un flanco ascendente 0 → 1 en el parámetro ini‐
cia el procesamiento del bloque.

ConnectionHdl

IN

DWORD

1 .. 5

Identificación de conexión suministrado por
UA_Connect

NodeHdlCount

IN

WORD

1

Número de elementos en el área de datos de
"NodeHdls". El número debe ser 1.

4374

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado / Observación

NodeHdls

IN

ARRAY of
DWORD

0 .. 4 294 967 295

Matriz de los IDs de los handles reemplazados.

TIME

5000 .. 120000

Timeout

IN

Si el bloque se procesa correctamente, los han‐
dles se reemplazarán en el servidor, por lo que
perderán su validez.
Intervalo máximo para el establecimiento de la
conexión en milisegundos. Si se rebasa este va‐
lor, el procesamiento del bloque se cancela con
el número de error B0007001.
Si se realizan entradas fuera del rango permiti‐
do, se aplica el valor predeterminado de 60000
(60 segundos).

Done

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: procesamiento de bloque cancelado, aún
no finalizado o aún no iniciado
● 1: el bloque se ha procesado sin errores

Busy

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: el bloque no se está procesando
● 1: el bloque se está procesando

Error

OUT

BOOL

0, 1

Indicación de error
● 0: sin error
● 1: se ha producido un error. Consulte el
parámetro "ErrorID".

ErrorID

OUT

NodeErrorIDs

OUT

DWORD

ARRAY of
DWORD

Véase "Significa‐
do"

Indicación del número de error si "Error" = 1.

Véase "Significa‐
do"

Contiene códigos de error para todos los ele‐
mentos del área de datos de "NodeHdls".

Respecto al significado de los números, consul‐
te el capítulo Números de error (Página 4389).

UA_Disconnect
Función
Función del bloque
Con el bloque UA_Disconnect se deshace una conexión existente entre el CP como cliente
OPC UA y un servidor UA. De ese modo finaliza la sesión existente.

Consulte también
Bloques de programa para el cliente UA OPC (Página 4364)

Programación del PLC
Manual de programación y manejo, 11/2019

4375

Instrucciones
4.1 Instrucciones

Parámetros
Parámetros de bloque
En la tabla siguiente se explican los parámetros formales del bloque de programa.
Tabla 4-100 Parámetros del bloque UA_Disconnect
Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado

Execute

IN

BOOL

0, 1

Un flanco ascendente 0 → 1 en el parámetro ini‐
cia el procesamiento del bloque.

ConnectionHdl

IN

DWORD

1 .. 5

Identificación de conexión suministrado por
UA_Connect

Timeout

IN

TIME

5000 .. 120000

Intervalo máximo para el establecimiento de la
conexión en milisegundos. Si se rebasa este va‐
lor, el procesamiento del bloque se cancela con
el número de error B0007001.
Si se realizan entradas fuera del rango permiti‐
do, se aplica el valor predeterminado de 60000
(60 segundos).

Done

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: procesamiento de bloque cancelado, aún
no finalizado o aún no iniciado
● 1: el bloque se ha procesado sin errores

Busy

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: el bloque no se está procesando
● 1: el bloque se está procesando

Error

OUT

BOOL

0, 1

Indicación de error
● 0: sin error
● 1: se ha producido un error. Consulte el
parámetro "ErrorID".

ErrorID

OUT

DWORD

Véase "Significa‐
do"

Indicación del número de error si "Error" = 1.
Respecto al significado de los números, consul‐
te el capítulo Números de error (Página 4389).

UA_ReadList
Función
Función del bloque
Con el bloque UA_ReadList se leen los datos del servidor UA conectado.

4376

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los atributos leídos se programan en un UDT "UANodeAdditionalInfo" referenciado por el
parámetro de entrada "NodeAddInfos".
Los handles requeridos en el parámetro de entrada "NodeHdls" se leen desde la matriz del
parámetro de salida "NodeHdls" del bloque "UA_NodeGetHandleList".
El número de IDs de nodo en el parámetro de entrada "NodeIDCount" es 1, por lo que hay que
llamar el bloque por separado para cada nodo de destino.

Consulte también
Parámetros (Página 4377)
Bloques de programa para el cliente UA OPC (Página 4364)

Parámetros
Parámetros de bloque
En la tabla siguiente se explican los parámetros formales del bloque de programa.
Tabla 4-101 Parámetros del bloque UA_ReadList
Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado

Execute

IN

BOOL

0, 1

Un flanco ascendente 0 → 1 en el parámetro ini‐
cia el procesamiento del bloque.

ConnectionHdl

IN

DWORD

1 .. 5

Identificación de conexión suministrado por
UA_Connect

NodeHdlCount

IN

WORD

1

Número de elementos en el área de destino leí‐
da. El número debe ser 1.

NodeHdls

IN

ARRAY of
DWORD

1

Matriz de los handles de los nodos de destino
(items) del servidor OPC UA. Los handles se
leen de la matriz del parámetro de salida "No‐
deHdls" del bloque "UA_NodeGetHandleList".

NodeAddInfos

IN

ARRAY of
UDT

Véase "Significa‐
do"

Especifica el atributo leído de los items y el rango
de índices. Respecto a la estructura de UDT
consulte UANodeAdditionalInfo (Página 4386).

Timeout

IN

TIME

5000 .. 120000

Intervalo máximo para el establecimiento de la
conexión en milisegundos. Si se rebasa este va‐
lor, el procesamiento del bloque se cancela con
el número de error B0007001.
Si se realizan entradas fuera del rango permiti‐
do, se aplica el valor predeterminado de 60000
(60 segundos).

Variables

IN_OUT

UDT

Véase "Significa‐
do"

Referencia a los datos leídos. Respecto a la es‐
tructura de UDT consulte UAAnyPointer (Pági‐
na 4387).
Para más información sobre los tipos de datos
soportados, consulte el capítulo Tipos de datos
(Página 4380).

Programación del PLC
Manual de programación y manejo, 11/2019

4377

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado

Done

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: procesamiento de bloque cancelado, aún
no finalizado o aún no iniciado
● 1: el bloque se ha procesado sin errores

Busy

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: el bloque no se está procesando
● 1: el bloque se está procesando

Error

OUT

BOOL

0, 1

Indicación de error
● 0: sin error
● 1: se ha producido un error. Consulte el
parámetro "ErrorID".

ErrorID

OUT

NodeErrorIDs

OUT

DWORD

ARRAY of
DWORD

Véase "Significa‐
do"

Indicación del número de error si "Error" = 1.

Véase "Significa‐
do"

Contiene los números de error para todos los
elementos del área de datos de "Variables".

Respecto al significado de los números, consul‐
te el capítulo Números de error (Página 4389).

Respecto al significado de los números, consul‐
te el capítulo Números de error (Página 4389).
TimeStamps

OUT

UDT

Véase "Significa‐
do"

Contiene sellos de tiempo para todos los ele‐
mentos del área de datos de "Variables". Res‐
pecto a la estructura de UDT consulte UATimeS‐
tamp (Página 4387).

UA_WriteList
Función
Función del bloque
Con el bloque UA_WriteList se escriben los datos en el servidor UA conectado.
Los atributos que deben escribirse se programan en un UDT "UANodeAdditionalInfo"
referenciado por el parámetro de entrada "NodeAddInfos".
Los handles requeridos en el parámetro de entrada "NodeHdls" se leen desde la matriz del
parámetro de salida "NodeHdls" del bloque "UA_NodeGetHandleList".
El número de IDs de nodo en el parámetro de entrada "NodeIDCount" es 1, por lo que hay que
llamar el bloque por separado para cada nodo de destino.

Consulte también
Parámetros (Página 4379)
Bloques de programa para el cliente UA OPC (Página 4364)

4378

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
Parámetros de bloque
En la tabla siguiente se explican los parámetros formales del bloque de programa.
Tabla 4-102 Parámetros del bloque UA_WriteList
Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado

Execute

IN

BOOL

0, 1

Un flanco ascendente 0 → 1 en el parámetro ini‐
cia el procesamiento del bloque.

ConnectionHdl

IN

DWORD

1 .. 5

Identificación de conexión suministrado por
UA_Connect

NodeHdlCount

IN

WORD

1

Número de elementos en el área de destino es‐
crita. El número debe ser 1.

NodeHdls

IN

ARRAY of
DWORD

1

Matriz de los handles de los nodos de destino
(items) del servidor OPC UA. Los handles se
leen de la matriz del parámetro de salida "No‐
deHdls" del bloque "UA_NodeGetHandleList".

NodeAddInfos

IN

ARRAY of
UDT

Véase "Significa‐
do"

Especifica el atributo escrito de los items y el
rango de índices. Respecto a la estructura de
UDT consulte UANodeAdditionalInfo (Pági‐
na 4386).

Timeout

IN

TIME

5000 .. 120000

Intervalo máximo para el establecimiento de la
conexión en milisegundos. Si se rebasa este va‐
lor, el procesamiento del bloque se cancela con
el número de error B0007001.
Si se realizan entradas fuera del rango permiti‐
do, se aplica el valor predeterminado de 60000
(60 segundos).

Variables

IN_OUT

UDT

Véase "Significa‐
do"

Referencia a los datos escritos. Respecto a la
estructura de UDT consulte UAAnyPointer (Pá‐
gina 4387).
Para más información sobre los tipos de datos
soportados, consulte el capítulo Tipos de datos
(Página 4380).

Done

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: procesamiento de bloque cancelado, aún
no finalizado o aún no iniciado
● 1: el bloque se ha procesado sin errores

Busy

OUT

BOOL

0, 1

Parámetros de estado para el procesamiento del
bloque
● 0: el bloque no se está procesando
● 1: el bloque se está procesando

Error

OUT

BOOL

0, 1

Indicador de error
● 0: sin error
● 1: se ha producido un error. Consulte el
parámetro "ErrorID".

Programación del PLC
Manual de programación y manejo, 11/2019

4379

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos S7

Valores posibles

Significado

ErrorID

OUT

DWORD

Véase "Significa‐
do"

Indicación del número de error si "Error" = 1.

Véase "Significa‐
do"

Contiene los números de error para todos los
elementos del área de datos de "Variables".

NodeErrorIDs

OUT

ARRAY of
DWORD

Respecto al significado de los números, consul‐
te el capítulo Números de error (Página 4389).

Respecto al significado de los números, consul‐
te el capítulo Números de error (Página 4389).

Tipos de datos
Tipos de datos y áreas de memoria
El CP 443‑1 OPC UA soporta los tipos de datos indicados a continuación para datos de
proceso.
Los símbolos correspondientes de la CPU se permiten para las áreas de operandos indicadas
en cada caso. Las áreas de memoria tienen las abreviaturas siguientes. Las siglas entre
paréntesis son las abreviaturas relacionadas con la nemónica ajustada (alemán/inglés).
● E = memoria imagen de proceso de las entradas (E/I)
● A= memoria imagen de proceso de las salidas (A/Q)
● PE = área de periferia de las entradas (PE/PI)
● PA = área de periferia de las salidas (PA/PQ)
● M = marcas
● DB = bloque de datos / bloque de datos de sistema / bloque de datos de instancia
Solo el servidor OPC UA soporta las áreas de periferia.
Tabla 4-103 Tipos de datos
Tamaño
[bit], tipo

Área

1

0 .. 255

Tipo de datos
SIMATIC S7

IEC 61131‑3

OPC UA

BOOL

BOOL

Boolean

Observación

Área de operan‐
dos de la CPU

0 = false

I, Q, PI, PQ; M,
DB

1 .. 255 = true
Números
8, UInt8

0 .. 255

BYTE

BYTE,
USINT

Byte

8, UInt8

0 .. 255

CHAR

CHAR

Byte

16, UInt16 0 .. 65535

WORD

WORD,
UINT

UInt16

I, Q, PI, PQ; M,
DB

16, Int16

INT

INT

Int16

I, Q, PI, PQ; M,
DB

DWORD

DWORD,
UDINT

UInt32

I, Q, PI, PQ; M,
DB

-32768 .. 32767

32, UInt32 0 .. 4294967295

4380

I, Q, PI, PQ; M,
DB
Caracteres ASCII
32 .. 255

I, Q, PI, PQ; M,
DB

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tamaño
[bit], tipo

Área

32, Int32
32, Float

Tipo de datos

Observación

Área de operan‐
dos de la CPU

SIMATIC S7

IEC 61131‑3

OPC UA

2147483648 ..
2147483647

DINT

DINT

Int32

I, Q, PI, PQ; M,
DB

±1.175 495e-38 ..
3.402823e+38

REAL

REAL

Float

DB

S5TIME

TIME

UInt16

Fecha y hora
16, UInt16 0 .. 999

Hora SIMATIC

DB

Respecto a la codifica‐
ción consulte la ayuda on‐
line de STEP 7.
16, UInt16 D#1990‑1‑1 ..
D#2168‑12‑31

DATE

DATE

UInt16

Fecha IEC [d]

DB

UInt32

Hora [ms]

DB

UInt32

Hora IEC [ms]

DB

Fecha y hora

DB

(0 .. 65378)
TIME_OF_
32, UInt32 TOD#0:0:0.0 ..
TIME_OF_
DAY
DAY (TOD)
TOD#23:59:59.999
(0 .. 86399999)
32, UInt32 -24D_20H_31M_
23S_648MS ..
T#24D_20H_31M_
23S_647MS

TIME

TIME

(-2147483648 ..
2147483647)
Tipos de datos compuestos
64

254 * 8

1990‑1‑1-0:0:0.0 ..
2089‑12‑31-23:59:
59.999

UInt32+
DATE_AND_ DT DATE_
AND_TIME UInt32
TIME

STRING *

STRING

String

Respecto a la codifica‐
ción consulte la ayuda on‐
line de STEP 7.
Máx. 254 bytes de datos
de usuario

DB

ARRAY *

Campo multidimensional DB
de tipos de datos elemen‐
tales o compuestos

UDT *

Tipo de datos definido
por el usuario para gru‐
pos de parámetros espe‐
cíficos

DB

* Respecto a la codificación véase más abajo.

Encontrará la descripción detallada de la codificación de los tipos de datos en la Ayuda en
pantalla de STEP 7.
Particularidades de los tipos de datos compuestos
Para los tipos de datos compuestos que utiliza la función OPC UA del CP rigen normas de
codificación especiales, que se describen a continuación.

STRING
Un STRING puede tener como máx. 254 caracteres.

Programación del PLC
Manual de programación y manejo, 11/2019

4381

Instrucciones
4.1 Instrucciones
Se admiten caracteres ASCII comprendidos en el rango 32 (0x20) .. 255 (0xFF).
De ellos, los caracteres siguientes no están permitidos: 127 (0x7F), 129 (0x81), 141 (0x8D),
143 (0x8F), 144 (0x90), 157 (0x9D)
Particularidades del servidor OPC UA
Los caracteres se codifican en formato UTF‑8 en el servidor OPC UA del CP.
Particularidades del cliente OPC UA
Para los datos de proceso con el tipo de datos STRING referenciados por el UDT
"UAAnyPointer" se indica el tipo de datos "2" (BYTE).
Como factor de repetición en el UAAnyPointer elija siempre el valor máximo de 256 (0x100):
254 para los datos de usuario + 2 para el encabezado.

ARRAY
Particularidades del cliente OPC UA
Los bloques de programa del cliente solo soportan la transferencia de arrays unidimensionales
desde el área de memoria "DB".
Los bloques de programa del cliente no soportan la transferencia del tipo de datos "ARRAY of
BOOL".
En un ARRAY of STRING, la longitud máxima (256) debe indicarse "n" veces en los límites de
la dimensión de cada elemento del string, siendo "n" el número de strings en el array.
Particularidades del servidor OPC UA
El tipo de datos "ARRAY of BOOL" puede leerse en todos los casos.
El tipo de datos "ARRAY of BOOL" solo puede escribirse si la longitud es un múltiplo de 8.

UDT
Encontrará la estructura de los UDT necesarios para los bloques de programa para la función
de cliente OPC UA en el capítulo AUTOHOTSPOT.

Tipos de parámetros
Los tipos de parámetros "TIMER" y "COUNTER" solo se soportan para el servidor OPC UA del
CP.

4382

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

UDT para el CP 443-1 OPC UA
UASessionConnectInfo
UASessionConnectInfo
Consulte en la tabla siguiente el significado de la información de la conexión para el parámetro
"SessionConnectInfo" del bloque UA_Connect.
Tabla 4-104 Parámetros de UDT UASessionConnectInfo
Parámetro

Tipo de datos
S7

Rango de valo‐ Significado
res

SessionName

STRING

0 .. 254 carac‐
teres

Nombre de la sesión
Si la cadena permanece vacía, el sistema asig‐
na el siguiente nombre de sesión:
<Connection>+<Valor decimal de "Connec‐
tionHdl">

ApplicationName

STRING

0 .. 254 carac‐
teres

El parámetro es asignado por STEP 7 con el
nombre de aplicación del CP (cliente OPC UA)
configurado en HW Config.

SecurityMsgMode

WORD

0 .. 3

Procedimiento de seguridad
● 0 = mejor procedimiento posible
● 1 = Ningún procedimiento de seguridad
● 2 = Autentificar
● 3 = Autentificar y cifrar

SecurityPolicy

WORD

0 .. 4

Perfil Security
● 0 = Mejor perfil posible
● 1 = Ningún perfil de seguridad
● 2 = Basic128Rsa15
● 3 = Basic256
● 4 = Basic256Sha256

CertificateStore

STRING

ClientCertificate‐
Name

STRING

ServerUri

STRING

0 .. 254 carac‐
teres

Memoria de certificado del CP (cliente OPC UA)
El parámetro es asignado por STEP 7.

0 .. 254 carac‐
teres

Nombre del certificado de cliente

0 .. 254 carac‐
teres

Dirección de servidor (URI), que también está
guardada en el certificado de servidor.

El parámetro es asignado por STEP 7.

El parámetro solo puede dejarse vacío para se‐
siones sin procedimiento de seguridad.
Ejemplo:
urn:<ApplicationName>:GUID

Programación del PLC
Manual de programación y manejo, 11/2019

4383

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de datos
S7

CheckServerCerti‐ BOOL
ficate

Rango de valo‐ Significado
res
0, 1

Sincronización (comprobación) del certificado
enviado por el servidor con el certificado de
servidor guardado en la memoria de certifica‐
dos del CP cliente:
● 0 = ninguna comprobación
● 1 = comprobación
Nota:
Los ajustes de este parámetro se sobrescriben
con los ajustes de seguridad de la configura‐
ción.
Si activa la comprobación (1) pero las funciones
de seguridad están desactivadas en la configu‐
ración del CP, el establecimiento de la conexión
se cancelará con un mensaje de error.
Recomendación: Deje el parámetro en al ajuste
predeterminado (0), ya que las funciones de
seguridad se activan a través de la configura‐
ción del CP.

TransportProfile

WORD

1

1 = UATP_UATcp
Solo se soporta este perfil de transporte confor‐
me a la especificación PLCopen.

UserIdentityToken

UDT

Véase "Signifi‐ Datos de la identificación de usuario,
cado"
consulte UAUserIdentityToken (Página 4385).

VendorSpecificPa‐ WORD
rameter

Véase "Signifi‐ Entrada de la dirección lógica del
cado"
CP 443‑1 OPC UA. La encontrará en el cuadro
de diálogo de propiedades del CP de STEP 7
como dirección de entrada en la ficha "Direc‐
ciones"

SessionTimeout

30000 ..
86 400 000

TIME

Intervalo máximo (milisegundos) durante el
cual se mantiene una sesión sin tráfico de da‐
tos.
Si se rebasa este valor, la sesión (conexión) se
cancela. En ese caso hay que volver a estable‐
cer la conexión llamando UA_Connect.
Si se programan valores fuera del rango de va‐
lores permitido (30 segundos ... 1 día) se utiliza
el valor 1200000 (20 minutos).

MonitorConnec‐
tion

TIME

5000 ..
86 400 000

Tiempo de vigilancia de conexión (milisegun‐
dos)
Intervalo sin tráfico de datos después del cual el
cliente comprueba la conexión con el servidor
enviando un telegrama.
Ajuste predeterminado: 15000 (15 segundos)

LocaleIDs

4384

ARRAY[1..5]
of String[6]

Ejemplos:
en‑US, de‑DE,
zh‑CHS ...

Identificador opcional de idioma y región con‐
forme a RFC 3066.
0 = ningún LocaleID o uno desconocido

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

UAUserIdentityToken
UAUserIdentityToken
Consulte en la tabla siguiente el significado de los datos de autenticación de usuario que se
suministran al parámetro "UserIdentityToken" del UDT "UASessionConnectInfo".
Tabla 4-105 Parámetros de UDT UAUserIdentityToken
Parámetro

Tipo de datos
S7

Rango de valo‐ Significado
res

UserIdentity
TokenType

WORD

0, 1

0 = ninguna autenticación
1 = autenticación
Si el interlocutor (servidor) requiere una auten‐
ticación mediante nombre de usuario y contra‐
seña, ponga este parámetro a 1 y los dos si‐
guientes conforme a las exigencias del servidor.

TokenParam1

STRING

1 .. 254 carac‐
teres

Nombre de usuario

TokenParam2

STRING

1 .. 254 carac‐
teres

Contraseña

UANodeID
UANodeID
Consulte en la tabla siguiente el significado de los parámetros de UANodeID para la
identificación del nodo de destino en el servidor OPC UA. UANodeID alimenta el parámetro
"NodeIDs" del bloque UA_NodeGetHandleList".
Tabla 4-106 Parámetros de UDT UANodeID
Parámetro

Tipo de da‐
tos S7

Rango de va‐ Significado
lores

NamespaceIndex

WORD

0 .. 65535

Índice del espacio de nombre del servidor

Identifier

STRING

Máx. 254

Especifica el ID de nodo en el índice de espacio de
nombre.

IdentifierType

WORD

1 .. 2

Determina el formato y el rango de validez (general‐
mente el servidor) de NodeID. Tipos soportados:
● 1: UAIdentifierType_String
los identificadores de cadena distinguen entre
mayúsculas y minúsculas.
● 2: UAIdentifierType_Numeric
identificador numérico

Programación del PLC
Manual de programación y manejo, 11/2019

4385

Instrucciones
4.1 Instrucciones

UANodeAdditionalInfo
UANodeAdditionalInfo
Especifica el atributo del item y el rango de índices para el parámetro de bloque
"NodeAddInfos".
Tabla 4-107 Parámetros de UDT UANodeAdditionalInfo
Parámetro

Tipo de datos Rango de valores
S7

Significado

AttributeID

WORD

13

Atributo de los items. Solo se soporta el atri‐
buto 13 (UAAI_Value) para el valor del item.

IndexRangeCount

WORD

0 .. 1

Número de áreas de índice
El valor es irrelevante en tipos de datos ele‐
mentales.
Para elementos con el tipo de datos ARRAY
rige lo siguiente:
● 0: Un único índice. Se lee/escribe el Array
completo.
● 1: Un área parcial de una matriz definida
por "IndexRange".

IndexRange

UDT

Véase "Significa‐
do"

Área de la matriz para el parámetro Index‐
RangeCount. Respecto a la estructura de
UDT consulte UAIndexRange (Página 4386).

UAIndexRange
UAIndexRange
Determina los índices de inicio y fin para el parámetro "IndexRange" del UDT
"UANodeAdditionalInfo".
Tabla 4-108 Parámetros de UDT UAIndexRange
Parámetro

Tipo de datos

Rango de va‐ Significado
lores

StartIndex

WORD

0 .. 65535

Índice a partir del cual se lee.

EndIndex

WORD

0 .. 65535

Índice hasta el cual se lee.

Reglas:
Si se utiliza IndexRangeCount = 1, rigen las siguientes reglas para la programación del área
de índices:
● StartinIndex y EndIndex deben asignarse.
● Para el acceso a más de un elemento es necesario que StartIndex sea menor que
EndIndex.
La no observancia provoca un error con el número 80360000.

4386

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● Para leer solo un elemento de la matriz, indique el mismo valor para StartIndex y EndIndex.
● Para poder acceder a todos los elementos de la matriz hay que asignar StartIndex y
EndIndex en función del número total de los elementos de la matriz.
Las entradas fuera del tamaño de la matriz provocan un error con el número 80370000.
Ejemplo para la asignación de "StartIndex" y "EndIndex" en matrices:
De una matriz con un tamaño de 10 elementos (n.º 1 .. 10) deben leerse los elementos 3 a 5.
Ambos índices se programan del siguiente modo:
● StartIndex = 2 (elemento n.º 3)
● EndIndex = 4 (elemento n.º 5)

UATimeStamp
UATimeStamp
El UDT contiene los sellos de tiempo de los elementos del área de datos en milisegundos.
UATimeStamp alimenta el parámetro "TimeStamps" del bloque UA_ReadList".
Tabla 4-109 Parámetros de UDT UATimeStamp
Parámetro

Tipo de datos Rango de valores
S7

Significado

TimestampL

WORD

Véase más abajo

Palabra menos significativa (bits 0..15)

TimestampH

WORD

Véase más abajo

Palabra más significativa (bits 16..31)

Rango de valores de la palabra doble completa:
TOD#0:0:0.0 .. TOD#23:59:59.999 (0 .. 86 399 999 Milisegundos)

UAAnyPointer
UAAnyPointer
El UDT "UAAnyPointer" es referenciado por el parámetro "Variables" del bloque de programa.
El UDT hace referencia al área de memoria de los datos de proceso en la CPU. Para ello es
necesario copiar en un bloque de datos los datos de proceso de las áreas de operandos
"Entradas" o "Salidas".
Deposite el UDT en un bloque de datos.
Tabla 4-110 Parámetros de UDT UAAnyPointer
Parámetro

Tipo de datos Valores posibles
S7

Significado

SyntaxID

WORD

10

El valor para el ID de sintaxis siempre es 10.

DataType

WORD

Véase "Significa‐
do"

Tipo de datos del nodo de destino. Respecto
al rango de valores consulte la tabla "Codifi‐
cación del tipo de datos" a continuación.

Programación del PLC
Manual de programación y manejo, 11/2019

4387

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de datos Valores posibles
S7

Significado

RepetitionFactor

WORD

Factor de repetición

0 .. 65535

Encontrará más información en la Ayuda en
pantalla de STEP 7.
DB_Number

WORD

0 .. 65535

Número del bloque de datos (DB)
Si indica un DB, en "MemArea" introduzca:
b#16#84

MemArea

WORD

Véase "Significa‐
do"

Área de memoria
Si indica un área de memoria, introduzca un
cero en "DB_Number".
Respecto al rango de valores del área de
memoria consulte la tabla "Codificación del
área de memoria" a continuación.

ByteOffset

WORD

Dependiendo del
área de memoria,
consulte "Signifi‐
cado"

Decalaje de bytes en el área de memoria in‐
dicada a partir del cual se accede a los datos.

BitOffset

WORD

0 .. 7

Decalaje de bits en el área de memoria indi‐
cada

Tipo de datos
La tabla siguiente explica la codificación del tipo de datos en el parámetro "DataType" del UDT
UAAnyPointer.
Tabla 4-111 Codificación del tipo de datos
Código hexadecimal

Tipo de datos S7

Descripción

b#16#01

BOOL

Bit

b#16#02

BYTE

Byte (8 bits)

b#16#03

CHAR

Carácter (8 bits)

b#16#04

WORD

Palabra (16 bits)

b#16#05

INT

Entero (16 bits)

b#16#06

DWORD

Palabra (32 bits)

b#16#07

DINT

Entero (32 bits)

b#16#08

REAL

Número en coma flotante (32 bits)

b#16#09

DATE

Fecha

b#16#0A

TIME_OF_DAY (TOD) Hora

b#16#0B

TIME

Tiempo

b#16#0C

S5TIME

Tipo de datos S5TIME

b#16#0E

DATE_AND_TIME
(DT)

Fecha y hora (64 bits)

b#16#02 *

STRING

Cadena de caracteres

* La cadena utiliza el tipo de datos subordinado BYTE. Observe las particularidades recogidas
en el capítulo Tipos de datos (Página 4380).

4388

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Área de memoria
La tabla siguiente explica la codificación del área de memoria en el parámetro "MemArea" del
UDT UAAnyPointer.
Tabla 4-112 Codificación del área de memoria
Código hexadecimal

Área

Descripción

b#16#80

P

Área de memoria de la periferia

b#16#81

E

Área de memoria de las entradas

b#16#82

A

Área de memoria de las salidas

b#16#83

M

Área de memoria de las marcas

b#16#84

DB

Bloque de datos

Números de error
Valoración de los parámetros de salida
Los parámetros de salida Done (BOOL), Error (BOOL) y ErrorID (DWORD) de los bloques de
programa del cliente OPC UA se actualizan en cada llamada del bloque. Valore los estados de
los parámetros de salida en el programa de usuario.
Ejemplo:
Después de la llamada el bloque de programa UA_Connect proporciona los siguientes valores
a los tres parámetros de salida:
● Done = 1
● Error = 0
● ErrorID = 00000000
Significado: La petición se ha completado correctamente.

Significado de los números de error (hexadecimales) de ErrorID
Tabla 4-113 Significado de ErrorID en combinación con Done y Error
Done Error

ErrorID (hex) Nombre

Significado

1

00000000

El procesamiento del bloque se ha completado correctamente.

0

Números de error específicos de CP
0

1

B0006001

Falta flanco positivo para llamar el bloque de programa

0

1

B0007001

Tiempo excedido

0

1

B0008004

NodeIDCount no válido

0

1

B0008086

Handle de nodo no válido

0

1

B0008087

Se ha alcanzado el número máximo de conexiones (5).

0

1

B0008090

Dirección lógica incorrecta. Establecimiento de conexión can‐
celado.

Programación del PLC
Manual de programación y manejo, 11/2019

4389

Instrucciones
4.1 Instrucciones
Done Error

ErrorID (hex) Nombre

Significado

0

1

B0008093

La dirección lógica no se puede procesar. Se utiliza un módulo
no permitido.

0

1

B00080A1

El handle de nodo no se ha configurado para esta conexión.

0

1

B00080C3

Los recursos de conexión de la CPU están agotados tempo‐
ralmente.

0

1

B0009085

Se ha rebasado el espacio de memoria máximo para elemen‐
tos (64000 bytes) del cliente OPC UA.

0

1

B000800A

El cliente OPC UA no se ha activado en la configuración.

0

1

B0008723

La petición de lectura/escritura referencia un área de datos
que no existe en un DB.

0

1

B000F001

En un ciclo se han llamado dos bloques de función.

0

1

B000F002

La sesión OPC UA todavía no está establecida. Vuelva a lla‐
mar el bloque UA_Connect.

0

1

B000F003

Error de comunicación

0

1

B000F004

Valor no válido para el parámetro "SyntaxID" en el UDT
"UAAnyPointer"

0

1

B000F005

Tipo de datos no válido en UAAnyPointer

0

1

B000F006

Valor no válido para el parámetro "RepetitionFactor" en el UDT
"UAAnyPointer"

0

1

B000F007

Área de operandos no válida de UAAnyPointer

0

1

B000F010

Área de operandos no válida en una petición de lectura o es‐
critura: no se permiten arrays de entradas, arrays de salidas,
arrays de marcas, arrays de datos locales ni arrays de datos
locales del bloque predecesor.

0

1

B000F011

El offset de bits debe ser cero.

0

1

B0010001

Paquete datos erróneo en UA_Connect

0

1

B0010002

URL no válida de un punto final de servidor

0

1

B0010003

Valor no válido para Timeout

0

1

B0010004

Valor no válido para SessionTimeout

0

1

B0010005

Valor no válido para MonitorConnection

0

1

B0010006

Perfil de transporte no válido

0

1

B0010007

URI de servidor no válida

0

1

B0010008

Procedimiento de Security no válido

0

1

B0010009

Perfil de Security no válido

0

1

B001000A

Valor no válido para UserIdentityToken

0

1

B001000B

Nombre de aplicación no válido

0

1

B0010101

Formato no válido de la URL del punto final del servidor. Debe
empezar por "opc.tcp://".

0

1

B0010102

La ruta de la URL del punto final del servidor no se soporta.

0

1

B0010103

El cliente no debe conectarse al servidor del propio CP.

0

1

B0010104

Puerto no válido

0

1

B0010105

Dirección no válida. DNS no se soporta.

0

1

B0020001

Paquete datos erróneo en UA_NameSpaceGetIndex

0

1

B0030001

Paquete datos erróneo en UA_NodeGetHandleList

0

1

B0030002

Identifier de NodeID no válido

4390

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Done Error

ErrorID (hex) Nombre

Significado

0

1

B0030003

Se ha rebasado el número máx. de elementos (64000)

0

1

B0030004

Atributo "ValueRank" no soportado de una variable. Los valo‐
res 1 (array unidimensional) y -1 (de escala) de ValueRank no
se soportan.

0

1

B0040001

Paquete datos erróneo en UA_NodeReleaseHandleList

0

1

B0050001

Paquete datos erróneo en UA_Disconnect

0

1

B0050002

No es posible llamar UA_Disconnect porque no hay conexión.

0

1

B0060001

Paquete datos erróneo en UA_ReadList

0

1

B0060002

La longitud de los datos que deben leerse excede el máximo
de 64000.

0

1

B0060003

Rango no válido de IndexRangeCount

0

1

B0060004

IndexRange no válido. StartIndex no debe ser mayor que En‐
dIndex y EndIndex no debe ser mayor que la longitud del array.

0

1

B0060005

AttributeID no válido

0

1

B0060006

El área de datos leída es demasiado pequeña.

0

1

B0060007

Longitud de string no válida. El valor (datos de usuario) debe
ser 254.

0

1

B0060008

Valor no válido del nodo. El valor no puede leerse en una va‐
riable S7.

0

1

B0060010

Área de operandos no válida en una petición de lectura o es‐
critura: no se permiten arrays de entradas, arrays de salidas,
arrays de marcas, arrays de datos locales ni arrays de datos
locales del bloque predecesor.

0

1

B0070001

Paquete de datos erróneo en UA_WriteList

0

1

B0070002

La longitud de los datos que deben escribirse excede el máxi‐
mo.

0

1

B0070003

Rango no válido de IndexRangeCount

0

1

B0070004

IndexRange no válido. StartIndex no debe ser mayor que En‐
dIndex y EndIndex no debe ser mayor que la longitud del array.

0

1

B0070005

AttributeID no válido

0

1

B0070006

El área de datos está fuera del rango admisible.

0

1

B0070009

Carácter no válido en el string

Corrija los datos en el UDT "UAIndexRange".

Números de error según IEC 61131‑3 para OPC UA
0

1

002D0000

GoodSubscription
Transferred

The subscription was transferred to another session.

0

1

002E0000

GoodCompletes
Asynchronously

The processing will complete asynchronously.

0

1

002F0000

GoodOverload

Sampling has slowed down due to resource limitations.

0

1

00300000

GoodClamped

The value written was accepted but was clamped.

0

1

00960000

GoodLocalOverride

The value has been overridden.

0

1

00A20000

GoodEntryInserted

The data or event was successfully inserted into the historical
database.

0

1

00A30000

GoodEntryReplaced

The data or event field was successfully replaced in the histo‐
rical database.

0

1

00A50000

GoodNoData

No data exists for the requested time range or event filter.

Programación del PLC
Manual de programación y manejo, 11/2019

4391

Instrucciones
4.1 Instrucciones
Done Error

ErrorID (hex) Nombre

Significado

0

1

00A60000

GoodMoreData

The data or event field was successfully replaced in the histo‐
rical database.

0

1

00A70000

GoodCommunicationEvent

The communication layer has raised an event.

0

1

00A80000

GoodShutdownEvent

The system is shutting down.

0

1

00A90000

GoodCallAgain

The operation is not finished and needs to be called again.

0

1

00AA0000

GoodNonCriticalTimeout

A non-critical timeout occurred.

0

1

00BA0000

GoodResultsMayBe
Incomplete

The server should have followed a reference to a node in a
remote server but did not. The result set may be incomplete.

0

1

406C0000

UncertainReferenceOutOf
Server

One of the references to follow in the relative path references
to a node in the address space in another server.

0

1

408F0000

UncertainNoCommunication
LastUsableValue

Communication to the data source has failed. The variable va‐
lue is the last value that had a good quality.

0

1

40900000

UncertainLastUsableValue

Whatever was updating this value has stopped doing so.

0

1

40910000

UncertainSubstituteValue

The value is an operational value that was manually overwrit‐
ten.

0

1

40920000

UncertainInitialValue

The value is an initial value for a variable that normally receives
its value from another variable.

0

1

40930000

UncertainSensorNotAccurate The value is at one of the sensor limits.

0

1

40940000

UncertainEngineeringUnits
Exceeded

The value is outside of the range of values defined for this
parameter.

0

1

40950000

UncertainSubNormal

The value is derived from multiple sources and has less than
the required number of Good sources.

0

1

40A40000

UncertainDataSubNormal

The value is derived from multiple values and has less than the
required number of Good values.

0

1

40BC0000

UncertainReferenceNot
Deleted

The server was not able to delete all target references.

0

1

40C00000

UncertainNotAllNodes
Available

The list of references may not be complete because the un‐
derlying system is not available.

0

1

80010000

BadUnexpectedError

An unexpected error occurred

0

1

80020000

BadInternalError

An internal error occurred as a result of a programming or con‐
figuration error.

0

1

80030000

BadOutOfMemory

Not enough memory to complete the operation.

0

1

80040000

BadResourceUnavailable

An operating system resource is not available

0

1

80050000

BadCommunicationError

A low level communication error occurred.

0

1

80060000

BadEncodingError

Encoding halted because of invalid data in the objects being
serialized.

0

1

80070000

BadDecodingError

Decoding halted because of invalid data in the stream.

0

1

80080000

BadEncodingLimitsExcee‐
ded

The message encoding/decoding limits imposed by the stack
have been exceeded.

0

1

80B80000

BadRequestTooLarge

The resources (memory) of the CPU are temporarily occupied

0

1

80B90000

BadResponseTooLarge

The response message size exceeds limits set by the client.

0

1

80B90000

BadUnknownResponse

An unrecognized response was received from the server.

0

1

800A0000

BadTimeout

The operation timed out.

0

1

800B0000

BadServiceUnsupported

The server does not support the requested service.

0

1

800C0000

BadShutdown

The operation was cancelled because the application is shut‐
ting down.

4392

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Done Error

ErrorID (hex) Nombre

Significado

0

1

800D0000

BadServerNotConnected

The operation could not complete because the client is not
connected to the server.

0

1

800E0000

BadServerHalted

The server has stopped and cannot process any requests.

0

1

800F0000

BadNothingToDo

There was nothing to do because the client passed a list of
operations with no elements.

0

1

80100000

BadTooManyOperations

The request could not be processed because it specified too
many operations.

0

1

80110000

BadDataTypeIdUnknown

The extension object cannot be (de)serialized because the da‐
ta type id is not recognized.

0

1

80120000

BadCertificateInvalid

The certificate provided as a parameter is not valid.

0

1

80130000

BadSecurityChecksFailed

The certificate provided as a parameter is not valid.

0

1

80140000

BadCertificateTimeInvalid

The Certificate has expired or is not yet valid.

0

1

80150000

BadCertificateIssuer
TimeInvalid

An Issuer Certificate has expired or is not yet valid.

0

1

80160000

BadCertificateHost
NameInvalid

The HostName used to connect to a Server does not match a
HostName in the Certificate.

0

1

80170000

BadCertificateUriInvalid

The URI specified in the Application Description does not
match the URI in the Certificate.

0

1

80180000

BadCertificateUseNotAllo‐
wed

The Certificate may not be used for the requested operation.

0

1

80190000

BadCertificateIssuerUse
NotAllowed

The Issuer Certificate may not be used for the requested ope‐
ration.

0

1

801A0000

BadCertificateUntrusted

The Certificate is not trusted.

0

1

801B0000

BadCertificateRevocation
Unknown

It was not possible to determine if the Certificate has been
revoked.

0

1

801C0000

BadCertificateIssuer
RevocationUnknown

It was not possible to determine if the Issuer
The Certificate has been revoked.

Certificate has been revoked.

0

1

801D0000

BadCertificateRevoked

0

1

801E0000

BadCertificateIssuerRevoked The Issuer Certificate has been revoked.

0

1

801F0000

BadUserAccessDenied

User does not have permission to perform the requested ope‐
ration.

0

1

80200000

BadIdentityTokenInvalid

The user identity token is not valid.

0

1

80210000

BadIdentityTokenRejected

The user identity token is valid but the server has rejected it.

0

1

80220000

BadSecureChannelIdInvalid

The specified secure channel is no longer valid.

0

1

80230000

BadInvalidTimestamp

The timestamp is outside the range allowed by the server.

0

1

80240000

BadNonceInvalid

The nonce does appear to be not a random value or it is not the
correct length.

0

1

80250000

BadSessionIdInvalid

The session id is not valid.

0

1

80260000

BadSessionClosed

The session was closed by the client.

0

1

80270000

BadSessionNotActivated

The session cannot be used because ActivateSession has not
been called.

0

1

80280000

BadSubscriptionIdInvalid

The subscription id is not valid.

0

1

802A0000

BadRequestHeaderInvalid

The header for the request is missing or invalid.

0

1

802B0000

BadTimestampsTo
ReturnInvalid

The timestamps to return parameter is invalid.

Programación del PLC
Manual de programación y manejo, 11/2019

4393

Instrucciones
4.1 Instrucciones
Done Error

ErrorID (hex) Nombre

Significado

0

1

802C0000

BadRequestCancelled
ByClient

The request was cancelled by the client.

0

1

80310000

BadNoCommunication

Communication with the data source is defined, but not esta‐
blished, and there is no last known value available.

0

1

80320000

BadWaitingForInitialData

Waiting for the server to obtain values from the underlying data
source.

0

1

80330000

BadNodeIdInvalid

The syntax of the node id is not valid.

0

1

80340000

BadNodeIdUnknown

The node id refers to a node that does not exist in the server
address space.

0

1

80350000

BadAttributeIdInvalid

The attribute is not supported for the specified Node.

0

1

80360000

BadIndexRangeInvalid

The syntax of the index range parameter is invalid.

0

1

80370000

BadIndexRangeNoData

No data exists within the range of indexes specified.

0

1

80380000

BadDataEncodingInvalid

The data encoding is invalid.

0

1

80390000

BadDataEncoding
Unsupported

The server does not support the requested data encoding for
the node.

0

1

803A0000

BadNotReadable

The access level does not allow reading or subscribing to the
Node.

0

1

803B0000

BadNotWritable

The access level does not allow writing to the Node.

0

1

803C0000

BadOutOfRange

The value was out of range.

0

1

803D0000

BadNotSupported

The requested operation is not supported.

0

1

803E0000

BadNotFound

A requested item was not found or a search operation ended
without success.

0

1

803F0000

BadObjectDeleted

The object cannot be used because it has been deleted.

0

1

80400000

BadNotImplemented

Requested operation is not implemented.

0

1

80410000

BadMonitoringModeInvalid

The monitoring mode is invalid.

0

1

80420000

BadMonitoredItemIdInvalid

The monitoring item id does not refer to a valid monitored item.

0

1

80430000

BadMonitoredItem
FilterInvalid

The monitored item filter parameter is not valid.

0

1

80440000

BadMonitoredItem
FilterUnsupported

The server does not support the requested monitored item fil‐
ter.

0

1

80450000

BadFilterNotAllowed

A monitoring filter cannot be used in combination with the at‐
tribute specified.

0

1

80460000

BadStructureMissing

A mandatory structured parameter was missing or null.

0

1

80470000

BadEventFilterInvalid

The event filter is not valid.

0

1

80480000

BadContentFilterInvalid

The content filter is not valid.

0

1

80490000

BadFilterOperandInvalid

The operand used in a content filter is not valid.

0

1

804A0000

BadContinuation
PointInvalid

The continuation point provide is longer valid.

0

1

804B0000

BadNoContinuationPoints

The operation could not be processed because all continuation
points have been allocated.

0

1

804C0000

BadReferenceTypeIdInvalid

The operation could not be processed because all continuation
points have been allocated.

0

1

804D0000

BadBrowseDirectionInvalid

The browse direction is not valid.

0

1

804E0000

BadNodeNotInView

The node is not part of the view.

0

1

804F0000

BadServerUriInvalid

The ServerUri is not a valid URI.

0

1

80500000

BadServerNameMissing

No ServerName was specified

4394

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Done Error

ErrorID (hex) Nombre

Significado

0

1

80510000

BadDiscoveryUrlMissing

No DiscoveryUrl was specified.

0

1

80520000

BadSempahoreFileMissing

The semaphore file specified by the client is not valid.

0

1

80530000

BadRequestTypeInvalid

The security token request type is not valid.

0

1

80540000

BadSecurityModeRejected

The security mode does not meet the requirements set by the
Server.

0

1

80550000

BadSecurityPolicyRejected

The security policy does not meet the requirements set by the
Server.

0

1

80560000

BadTooManySessions

The server has reached its maximum number of sessions.

0

1

80570000

BadUserSignatureInvalid

The user token signature is missing or invalid.

0

1

80580000

BadApplicationSignature
Invalid

The signature generated with the client certificate is missing or
invalid.

0

1

80590000

BadNoValidCertificates

The client did not provide at least one software certificate that
is valid and meets the profile requirements for the server.

0

1

805A0000

BadRequestCancelled
ByRequest

The request was cancelled by the client with the Cancel servi‐
ce.

0

1

805B0000

BadParentNodeIdInvalid

The parent node id does not to refer to a valid node.

0

1

805C0000

BadReferenceNotAllowed

The reference could not be created because it violates cons‐
traints imposed by the data model.

0

1

805D0000

BadNodeIdRejected

The requested node id was reject because it was either invalid
or server does not allow node ids to be specified by the client.

0

1

805F0000

BadNodeClassInvalid

The node class is not valid.

0

1

80600000

BadBrowseNameInvalid

The browse name is invalid.

0

1

80610000

BadBrowseNameDuplicated

The browse name is not unique among nodes that share the
same relationship with the parent.

0

1

80620000

BadNodeAttributesInvalid

The node attributes are not valid for the node class.

0

1

80630000

BadTypeDefinitionInvalid

The type definition node id does not reference an appropriate
type node.

0

1

80640000

BadSourceNodeIdInvalid

The source node id does not reference a valid node.

0

1

80650000

BadTargetNodeIdInvalid

The target node id does not reference a valid node.

0

1

80660000

BadDuplicateReference
NotAllowed

The reference type between the nodes is already defined.

0

1

80670000

BadInvalidSelfReference

The server does not allow this type of selfreference on this
node.

0

1

80680000

BadReferenceLocalOnly

The reference type is not valid for a reference to a remote ser‐
ver.

0

1

80690000

BadNoDeleteRights

The server will not allow the node to be deleted.

0

1

806A0000

BadServerIndexInvalid

The server index is not valid.

0

1

806B0000

BadViewIdUnknown

The view id does not refer to a valid view node.

0

1

806D0000

BadTooManyMatches

The requested operation has too many matches to return.

0

1

806E0000

BadQueryTooComplex

The requested operation requires too many resources in the
server.

0

1

806F0000

BadNoMatch

The requested operation has no match to return.

0

1

80700000

BadMaxAgeInvalid

The max age parameter is invalid.

0

1

80710000

BadHistoryOperationInvalid

The history details parameter is not valid.

0

1

80720000

BadHistoryOperation
Unsupported

The server does not support the requested operation.

Programación del PLC
Manual de programación y manejo, 11/2019

4395

Instrucciones
4.1 Instrucciones
Done Error

ErrorID (hex) Nombre

Significado

0

1

80730000

BadWriteNotSupported

The server not does support writing the combination of value,
status and timestamps provided.

0

1

80740000

BadTypeMismatch

The value supplied for the attribute is not of the same type as
the attribute's value.

0

1

80750000

BadMethodInvalid

The method id does not refer to a method for the specified
object.

0

1

80760000

BadArgumentsMissing

The client did not specify all of the input arguments for the
method.

0

1

80770000

BadTooManySubscriptions

The server has reached its maximum number of subscriptions.

0

1

80780000

BadTooManyPublish
Requests

The server has reached the maximum number of queued pu‐
blish requests.

0

1

80790000

BadNoSubscription

There is no subscription available for this session.

0

1

807A0000

BadSequenceNumber
Unknown

The sequence number is unknown to the server.

0

1

807B0000

BadMessageNotAvailable

The requested notification message is no longer available.

0

1

807C0000

BadInsufficientClientProfile

The Client of the current Session does not support one or more
Profiles that are necessary for the Subscription.

0

1

80BF0000

BadStateNotActive

The sub-state machine is not currently active.

0

1

807D0000

BadTcpServerTooBusy

The server cannot process the request because it is too busy.

0

1

807E0000

BadTcpMessageTypeInvalid

The type of the message specified in the header invalid.

0

1

807F0000

BadTcpSecureChannel
Unknown

The SecureChannelId and/or TokenId are not currently in use.

0

1

80800000

BadTcpMessageTooLarge

The size of the message specified in the header is too large.

0

1

80810000

BadTcpNotEnough
Resources

There are not enough resources to process the request.

0

1

80820000

BadTcpInternalError

An internal error occurred.

0

1

80830000

BadTcpEndpointUrlInvalid

The Server does not recognize the QueryString specified.

0

1

80840000

BadRequestInterrupted

The request could not be sent because of a network interrup‐
tion.

0

1

80850000

BadRequestTimeout

Timeout occurred while processing the request.

0

1

80860000

BadSecureChannelClosed

The secure channel has been closed.

0

1

80870000

BadSecureChannelToken
Unknown

The token has expired or is not recognized.

0

1

80880000

BadSequenceNumberInvalid

The sequence number is not valid.

0

1

80890000

BadConfigurationError

There is a problem with the configuration that affects the use‐
fulness of the value.

0

1

808A0000

BadNotConnected

The variable should receive its value from another variable, but
has never been configured to do so.

0

1

808B0000

BadDeviceFailure

There has been a failure in the device/data source that gene‐
rates the value that has affected the value.

0

1

808C0000

BadSensorFailure

There has been a failure in the sensor from which the value is
derived by the device/data source.

0

1

808D0000

BadOutOfService

The source of the data is not operational.

0

1

808E0000

BadDeadbandFilterInvalid

The dead band filter is not valid.

0

1

80970000

BadRefreshInProgress

This Condition refresh failed, a Condition refresh operation is
already in progress.

4396

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Done Error

ErrorID (hex) Nombre

Significado

0

1

80980000

BadConditionAlreadyDisa‐
bled

This condition has already been disabled.

0

1

80990000

BadConditionDisabled

Property not available, this condition is disabled.

0

1

809A0000

BadEventIdUnknown

The specified event id is not recognized.

0

1

809B0000

BadNoData

No data exists for the requested time range or event filter.

0

1

809D0000

BadDataLost

Data is missing due to collection started/stopped/lost.

0

1

809E0000

BadDataUnavailable

Expected data is unavailable for the requested time range due
to an unmounted volume an off-line archive or tape or similar
reason for temporary unavailability.

0

1

809F0000

BadEntryExists

The data or event was not successfully inserted because a
matching entry exists.

0

1

80A00000

BadNoEntryExists

The data or event was not successfully updated because no
matching entry exists.

0

1

80A10000

BadTimestampNotSupported The client requested history using a timestamp format the ser‐
ver does not support (i. e. requested ServerTimestamp when
server only supports SourceTimestamp).

0

1

80AB0000

BadInvalidArgument

0

1

80AC0000

BadConnectionRejected

Could not establish a network connection to remote server.

0

1

80AD0000

BadDisconnect

The server has disconnected from the client.

0

1

80AE0000

BadConnectionClosed

The network connection has been closed.

0

1

80AF0000

BadInvalidState

The operation cannot be completed because the object is clo‐
sed uninitialized or in some other invalid state.

0

1

80B00000

BadEndOfStream

Cannot move beyond end of the stream.

0

1

80B10000

BadNoDataAvailable

No data is currently available for reading from a non-blocking
stream.

0

1

80B20000

BadWaitingForResponse

The asynchronous operation is waiting for a response.

0

1

80B30000

BadOperationAbandoned

The asynchronous operation was abandoned by the caller.

0

1

80B40000

BadExpectedStreamToBlock The stream did not return all data requested (possibly because
it is a non-blocking stream).

0

1

80B50000

BadWouldBlock

Non-blocking behavior is required and the operation would
block.

0

1

80B60000

BadSyntaxError

A value had an invalid syntax.

0

1

80B70000

BadMaxConnections
Reached

The operation could not be finished because all available con‐
nections are in use.

0

1

80BB0000

BadEventNot
Acknowledgeable

The event cannot be acknowledged.

0

1

80BD0000

BadInvalidTimestamp
Argument

The defined timestamp to return was invalid.

0

1

80BE0000

BadProtocolVersion
Unsupported

The applications do not have compatible protocol versions.

0

1

80C10000

BadFilterOperatorInvalid

An unrecognized operator was provided in a filter.

0

1

80C20000

BadFilterOperator
Unsupported

A valid operator was provided, but the server does not provide
support for this filter operator.

0

1

80C30000

BadFilterOperandCount
Mismatch

The number of operands provided for the filter operator was
less than expected for the operand provided.

0

1

80C40000

BadFilterElementInvalid

The referenced element is not a valid element in the content
filter.

Programación del PLC
Manual de programación y manejo, 11/2019

One or more arguments are invalid.

4397

Instrucciones
4.1 Instrucciones
Done Error

ErrorID (hex) Nombre

Significado

0

1

80C50000

BadFilterLiteralInvalid

The referenced literal is not a valid value.

0

1

80C90000

BadViewTimestampInvalid

The view timestamp is not available or not supported.

0

1

80CA0000

BadViewParameterMismatch The view parameters are not consistent with each other.

0

1

80CB0000

BadViewVersionInvalid

The view version is not available or not supported.

0

1

80CC0000

BadConditionAlready
Enabled

This condition has already been enabled.

0

1

80CD0000

BadDialogNotActive

The dialog condition is not active.

0

1

80CF0000

BadConditionBranch
AlreadyAcked

The condition branch has already been acknowledged.

0

1

80D00000

BadConditionBranch
AlreadyConfirmed

The condition branch has already been confirmed.

0

1

80D10000

BadConditionAlreadyShel‐
ved

The condition has already been shelved.

0

1

80D20000

BadConditionNotShelved

The condition is not currently shelved.

0

1

80D30000

BadShelvingTimeOutOfRan‐
ge

The shelving time not within an acceptable range.

0

1

80D40000

BadAggregateListMismatch

The requested number of Aggregates does not match the re‐
quested number of NodeIds.

0

1

80D50000

BadAggregateNotSupported

The requested Aggregate is not support by the server.

0

1

80D60000

BadAggregateInvalidInputs

The aggregate value could not be derived due to invalid data
inputs.

0

1

80DB0000

BadTooManyMonitoredItems The request could not be processed because there are too
many monitored items in the subscription.

0

1

80D70000

BadBoundNotFound

0

1

80D80000

BadBoundNotSupported

The server cannot retrieve a bound for the variable.

0

1

00D90000

GoodDataIgnored

The request specifies fields which are not valid for the EventTy‐
pe or cannot be saved by the historian.

0

1

80DA0000

BadAggregateConfiguration
Rejected

The aggregate configuration is not valid for specified node.

No data found to provide upper or lower bound value.

Números de error de PLCOpen para OPC UA
0

1

A0000001

PLCopenUA_Bad_FW_
PermanentError

Internal, permanent error.

0

1

A0000002

PLCopenUA_Bad_FW_
TempError

Temp. Error; FB could retry to reach FW.

0

1

A0000003

PLCopenUA_Bad_
ConnectionError

Connection could not be established.

0

1

A0000004

PLCopenUA_Bad_
HostNotFound

The requested hostname could not be found.

0

1

A0000005

PLCopenUA_Bad_
AlreadyConnected

Connection was already established.

0

1

A0000006

PLCopenUA_Bad_
SecurityFailed

Connection failed due to security setup.

0

1

A0000007

PLCopenUA_Bad_
Suspended

Connection is suspended.

0

1

A0000008

PLCopenUA_Bad_
ConnectionInvalidHdl

Provided ConnectionHdl is not known.

4398

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Done Error

ErrorID (hex) Nombre

Significado

0

1

A0000009

PLCopenUA_Bad_
NSNotFound

A namespace with the requested name cannot be found on
server.

0

1

A000000A

PLCopenUA_Bad_
ResultTooLong

Target PLC variable is too short for retrieved data.

0

1

A000000B

PLCopenUA_Bad_
InvalidType

Invalid or unsupported Type.

0

1

A000000C

PLCopenUA_Bad_
NodeInvalidHdl

Provided NodeHdl is not known.

0

1

A000000D

PLCopenUA_Bad_
MethodInvalidHdl

Provided MethodHdl is not known.

0

1

A000000E

PLCopenUA_Bad_
ReadFailed

Read failed for unknown reason.

0

1

A000000F

PLCopenUA_Bad_
WriteFailed

Write failed for unknown reason.

0

1

A0000010

PLCopenUA_Bad_
CallFailed

Method Call failed for unknown reason.

0

1

A0000011

PLCopenUA_Bad_
InParamFailed

Method Call Input parameter conversion failed.

0

1

A0000012

PLCopenUA_Bad_
OutParamFailed

Method Call Output parameter conversion failed. ATTEN‐
TION: this means the MethodCall was executed successfully
but the returned values could not be converted.

0

1

A0000013

PLCopenUA_Bad_
SubscriptionInvalidHdl

Provided SubscriptionHdl is not known.

0

1

A0000014

PLCopenUA_Bad_
MonitoredItemInvalidHdl

Provided MonitoredItemHdl is not known.

CM/CP S7-1200
Telecontrol
Instrucciones de Telecontrol
TC_CON: establecer un enlace a través de la red GSM
Significado
La instrucción TC_CON permite a un S7-1200 con CP de Telecontrol (p. ej. CP 1242‑7 ‑
6GK7242-7KX30-0XE0) establecer conexiones de los tipos siguientes:
● ISO‑ON‑TCP
El interlocutor de la conexión es un CP en una estación S7.
Las conexiones ISO-ON-TCP solo se utilizan en el CP 1242‑7 en el modo de operación
"GPRS directo".
● UDP
El interlocutor es uno cualquiera.

Programación del PLC
Manual de programación y manejo, 11/2019

4399

Instrucciones
4.1 Instrucciones
● SMS
El interlocutor es un cliente SMS.
● Conexión de Telecontrol (protocolo: TeleControl Basic)
El interlocutor es un servidor de Telecontrol o bien otra estación a la que se accede a través
del servidor de Telecontrol.
Un TC_CON establece una conexión. Dependiendo del modo de operación del CP 1242-7 y
del protocolo utilizado, por cada CP se soportan un máximo de 3 a 5 conexiones paralelas con
IDs únicas (véase más abajo). El número máximo posible de conexiones paralelas puede
consultarse en los datos de rendimiento del CP.
Para describir la conexión, el parámetro CONNECT utiliza un bloque de datos (DB) con una
estructura definida por el tipo de datos del sistema (SDT).
El tipo de conexión deseado se define mediante un SDT "TCON_..." específico de la conexión
(véase más abajo). Para cada uno de los tipos de conexión mencionados anteriormente debe
parametrizarse uno de los siguientes SDTs:
● TCON_IP_RFC para conexiones ISO‑ON‑TCP
● TCON_IP_V4 para conexiones UDP
● TCON_PHONE para conexiones SMS
● TCON_WDC para conexiones Telecontrol
En el parámetro "ActiveEstablished" de estos SDTs se define, entre otros, si se trata de un
establecimiento de conexión activo o pasivo.
Para parametrizar estos SDTs consulte TCON_...: SDTs para el establecimiento de un enlace
Telecontrol (Página 4417).
El parámetro ID referencia la conexión. La ID se asigna y debe ser unívoca dentro de la CPU.
El parámetro INTERFACE referencia la interfaz del CP local deseado. Esta debe ser adoptada
desde STEP 7.

Interfaz de llamada en representación FUP
7&B&21

4400

%22/

5(4

%86<

%22/

&211B28&

,'

'21(

%22/

+:B,17(5)$&(

,17(5)$&(

(5525

%22/

7&21B3DUDP

&211(&7

67$786

:25'

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Explicación de los parámetros formales
La tabla siguiente explica los parámetros formales de la instrucción TC_CON.
Parámetro

Declaración

Tipo de datos

Rango de valores

Descripción

REQ

INPUT

BOOL

0, 1

Con un flanco ascendente se inicia el pro‐
cesamiento de la instrucción y se iniciali‐
zan los indicadores de estado.
Actualización de los indicadores de esta‐
do DONE, ERROR y STATUS cuando no
hay ningún flanco ascendente.

ID

INPUT

CONN_OUC

1...07FFh

Referencia a la conexión correspondien‐
te. La ID se asigna.
El valor de ID también es requerido por el
tipo de datos de sistema (SDT) corres‐
pondiente al parámetro CONNECT.

INTERFACE

INPUT

HW_INTERFA‐
CE

CONNECT

INOUT

TCON_Param

Referencia a la interfaz del CP (ID de
hardware) *
Véase también "TCON_...:
SDTs para establecer la cone‐
xión de Telecontrol"

Referencia a un bloque de datos para el
establecimiento de la conexión.
Los SDT del tipo TCON_IP_RFC,
TCON_IP_V4, TCON_PHONE o
TCON_WDC predeterminan la estructura
del bloque de datos apto para la conexión
correspondiente.
Tenga en cuenta el parámetro "ActiveEs‐
tablished" (establecimiento activo / pasi‐
vo de la conexión) en los SDTs.

ENO

OUTPUT

BOOL

0: error
1: correcto

BUSY

OUTPUT

BOOL

0: procesamiento de la instruc‐
ción todavía no iniciado, finali‐
zado o cancelado

Salida de habilitación
Si la instrucción presenta un error en el
tiempo de ejecución, se pondrá ENO = 0.
Indicador del estado de procesamiento
de la instrucción

1: procesamiento de la instruc‐
ción en curso
DONE

OUTPUT

BOOL

0: 1: procesamiento de la instruc‐
ción finalizado correctamente

ERROR

STATUS

OUTPUT

OUTPUT

BOOL

WORD

El parámetro de estado indica si la peti‐
ción se ha desarrollado correctamente.
Consulte el significado en relación con los
parámetros ERROR y STATUS en Indi‐
cadores de la instrucción.

0: -

Indicador de error

1: error

Consulte el significado en relación con los
parámetros DONE y STATUS en Indica‐
dores de la instrucción.
Indicador de estado
Consulte el significado en relación con los
parámetros DONE y ERROR en Indica‐
dores de la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

4401

Instrucciones
4.1 Instrucciones
* En función del tipo de CP debe referenciarse la "ID de hardware" de la interfaz de Telecontrol
o de la interfaz Ethernet. Una vez seleccionado el CP en la vista de redes o dispositivos de
STEP 7, encontrará la "ID de hardware" en el lugar siguiente de la ventana de inspección:
● Hasta STEP 7 V14 SP1
Ficha "Propiedades" > "General" > "Interfaz en cuestión" > grupo de parámetros "ID de
hardware"
● A partir de STEP 7 V15
Ficha "Propiedades" > "Constantes de sistema" > "ID de hardware" (constante de sistema
del tipo de datos "Hw_Interface")
En función del tipo de CP es relevante la constante de sistema siguiente:
– CP 1242‑7 (6GK7242-7KX30-0XE0)
"Local~<nombre del CP>~<nombre de la interfaz de Telecontrol>"
– Todos los demás CP de Telecontrol
"Local~<nombre del CP>~<nombre de la interfaz de Ethernet>"

Indicadores BUSY, DONE y ERROR
Los indicadores DONE y ERROR solo son relevantes si BUSY = 0.
BUSY

DONE

ERROR

Significado

0

0

0

Ninguna petición en proceso

Encontrará todas las demás combinaciones de los indicadores DONE y ERROR en la tabla
siguiente.
En caso de llamada, la instrucción permanecerá en el estado BUSY = 1 por algunos segundos.
En los siguientes casos puede durar más tiempo el estado BUSY = 1:
● En el caso de conexiones ISO‑ON‑TCP activas, cuando no se puede acceder al interlocutor.
● En el caso de conexiones pasivas, cuando no se recibe ningún telegrama.

Indicadores DONE, ERROR y STATUS
La tabla siguiente muestra el significado de la información suministrada por DONE, ERROR y
STATUS, la cual tiene que ser evaluada por el programa de usuario.
DONE

ERROR

STATUS

Significado

1

0

0000H

Petición ejecutada correctamente

0

0

7000H

No hay ningún procesamiento de petición activo (primera llamada de la instrucción)

0

0

7001H

Procesamiento de petición iniciado (primera llamada de la instrucción)

0

0

7002H

Procesamiento de petición en curso (nueva llamada de la instrucción si BUSY = 1)

0

1

8086H

Valor no permitido para ID

0

1

8087H

Número máximo de conexiones alcanzado, no es posible ninguna otra conexión

4402

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
DONE

ERROR

STATUS

Significado

0

1

80E3H

La ID ya se está utilizando en otra conexión. Esto significa que con TC_SEND, TC_RECV
o TC_DISCON actualmente BUSY es TRUE.
También se emitirá el indicador de estado si EN_R con TC_RECV es TRUE de forma
permanente. Esto hace que se acceda principalmente a TC_RECV. Solución para este
caso: desactive EN_R antes de que se llame TC_CON o TC_DISCON. EN_R solo se
debe volver a activar si se ha ejecutado TC_CON correctamente.

0

1

80E6H

Ninguna solicitud en proceso (la activación de la instrucción no se inicia)

0

1

80E8H

Interlocutor remoto no accesible. Compruebe los parámetros de conexión.
En el modo de operación "GPRS directo", el aviso se emite cuando el interlocutor está
accesible pero no acepta las peticiones de conexión.

0

1

80EBH

Solicitud rechazada por el momento (TC_CON ya se ha llamado con la misma dirección
de destino.)

0

1

80ECH

No se ha podido abrir el Listener Port:

0

1

80F2H

El CP está en el modo de operación equivocado:

Compruebe los parámetros de conexión.
● Las conexiones Telecontrol solo se permiten en el modo de operación "Telecontrol".
● Las conexiones ISO‑ON‑TCP solo se utilizan en el modo de operación "GPRS
directo".
0

1

80F3H

No hay ningún punto final libre en la conexión para enviar datos:
● Utilice menos conexiones o
● Utilice menos conexiones pasivas o
● Desactive la opción NTP.
Tenga en cuenta el número máximo de conexiones paralelas del CP 1242-7.

0

1

80F4H

No se puede generar el punto final de la conexión:
Repita la llamada. En dado caso, compruebe los parámetros de conexión.

0

1

80F5H

Punto final de la conexión no válido: fallo en el establecimiento de la conexión a través de
TC_CON.
Repita la llamada del bloque.

0

1

80F6H

Error de formato de un parámetro en el bloque de datos llamado (tamaño erróneo, for‐
mato incorrecto, valor no válido o número de llamada en TCON_Phone con más de 20
caracteres)
Compruebe la configuración del SDT "TC_CON...".

TC_DISCON: desconectar un enlace a través de la red GSM
Significado
En un S7-1200 con CP 1242-7, la instrucción TC_DISCON provoca la desconexión de una
conexión ISO-ON-TCP, UDP, SMS o de Telecontrol establecida con la instrucción TC_CON.
Encontrará información detallada sobre los tipos de conexión en la descripción de la
instrucción TC_CON.
TC_DISCON desconecta solo de forma lógica la conexión con el servidor de Telecontrol. En
el nivel TCP/IP, la conexión permanece.

Programación del PLC
Manual de programación y manejo, 11/2019

4403

Instrucciones
4.1 Instrucciones
Si la conexión con el servidor de Telecontrol va a desconectarse físicamente, debe
configurarse como "Conexión temporal" en STEP 7 en el grupo de parámetros "Servidor de
Telecontrol". Las estaciones temporales deshacen la conexión automáticamente después de
enviar los datos.
Nota
Procesamiento de otros bloques de programa cancelado por TC_DISCON
Una llamada de TC_DISCON finaliza la ejecución de los bloques TC_CON, TC_SEND y
TC_RECV que se llamaron con la misma ID de conexión (parámetro "ID") e interfaz (parámetro
"INTERFACE"). A continuación, dichos bloques notifican ERROR.
No llamar TC_DISCON si TC_CON muestra "Error = 1".
Si TC_CON muestra "ERROR" significa que la conexión no se ha establecido. En este caso no
debe llamarse TC_DISCON.
Si se llama TC_DISCON en esta situación, la ID de conexión ("ID") queda reservada por un
tiempo breve, con lo que si se llamara seguidamente TC_CON se mostraría ERROR y
STATUS 80E3.
El parámetro ID referencia la conexión GPRS. La ID debe ser unívoca dentro de la CPU e
idéntica a la ID utilizada en TC_CON.
El parámetro INTERFACE referencia la interfaz GPRS del CP local deseado. El valor debe ser
idéntico al utilizado para INTERFACE en TC_CON.

Interfaz de llamada en representación FUP
7&B',6&21

4404

%22/

5(4

%86<

%22/

&211B28&

,'

'21(

%22/

+:B,17(5)$&(

,17(5)$&(

(5525

%22/

67$786

:25'

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Explicación de los parámetros formales
La tabla siguiente muestra los parámetros formales de la instrucción TC_DISCON.
Parámetro

Declaración

Tipo de datos

Rango de valores

Descripción

REQ

INPUT

BOOL

0, 1

Con un flanco ascendente se inicia el pro‐
cesamiento de la instrucción y se iniciali‐
zan los indicadores de estado.
Actualización de los indicadores de esta‐
do DONE, ERROR y STATUS cuando no
hay ningún flanco ascendente.

ID

INPUT

CONN_OUC

INTERFACE

INPUT

HW_INTERFA‐
CE

ENO

OUTPUT

BOOL

1...07FFh

Referencia a la interfaz del CP
Consulte la "ID de hardware" en el capí‐
tulo TC_CON: establecer un enlace a tra‐
vés de la red GSM (Página 4399).
0: error
1: correcto

BUSY

OUTPUT

BOOL

Referencia a la conexión correspondiente

0: procesamiento de la instruc‐
ción todavía no iniciado, finali‐
zado o cancelado

Salida de habilitación
Si la instrucción presenta un error en el
tiempo de ejecución, se pondrá ENO = 0.
Indicador del estado de procesamiento
de la instrucción

1: procesamiento de la instruc‐
ción en curso
DONE

OUTPUT

BOOL

0: 1: procesamiento de la instruc‐
ción finalizado correctamente

ERROR

OUTPUT

STATUS

OUTPUT

BOOL

El parámetro de estado indica si la peti‐
ción se ha desarrollado correctamente.
Consulte el significado en relación con los
parámetros ERROR y STATUS en Indi‐
cadores de la instrucción.

0: -

Indicador de error

1: error

Consulte el significado en relación con los
parámetros DONE y STATUS en Indica‐
dores de la instrucción.

WORD

Indicador de estado
Consulte el significado en relación con los
parámetros DONE y ERROR en Indica‐
dores de la instrucción.

Indicadores BUSY, DONE y ERROR
Los indicadores DONE y ERROR solo son relevantes si BUSY = 0.
BUSY

DONE

ERROR

Significado

0

0

0

La instrucción todavía no se ha llamado.

Programación del PLC
Manual de programación y manejo, 11/2019

4405

Instrucciones
4.1 Instrucciones
Encontrará todas las demás combinaciones de los indicadores DONE y ERROR en la tabla
siguiente.
Nota
En caso de llamada, la instrucción permanecerá en el estado BUSY = 1 por algunos segundos.

Indicadores DONE, ERROR y STATUS
La tabla siguiente muestra el significado de la información suministrada por DONE, ERROR y
STATUS, la cual tiene que ser evaluada por el programa de usuario.
DONE

ERROR

STATUS

Significado

1

0

0000H

Petición ejecutada correctamente

0

0

7000H

No hay ningún procesamiento de petición activo (primera llamada de la instrucción)

0

0

7001H

Procesamiento de petición iniciado (primera llamada de la instrucción)

0

0

7002H

Procesamiento de petición en curso (nueva llamada de la instrucción si BUSY = 1)

0

1

8086H

Valor no permitido para ID

0

1

80E4H

ID desconocida: No existe ninguna conexión e a través de TC_CON con esta ID.

0

1

80E6H

Ninguna solicitud en proceso (la activación de la instrucción no se inicia)

0

1

80F5H

Punto final de la conexión no válido:
● Fallo en el establecimiento de la conexión a través de TC_CON o
● Desconexión por parte del interlocutor remoto.

0

1

80F6H

Error de formato de un parámetro en el bloque de datos llamado (tamaño erróneo, for‐
mato incorrecto o valor no válido)
Compruebe la configuración del SDT "TC_CON...".

TC_SEND: enviar datos a través de la red GSM
Significado
La instrucción TC_SEND permite enviar datos a través de las conexiones programadas de los
tipos siguientes:
● Conexiones ISO‑ON‑TCP
● Conexiones UDP
● Conexiones SMS
El envío de SMS solo es soportado si este se estableció en la configuración STEP 7 del CP.
● Conexiones Telecontrol
Nota
Enviar SMS a varios destinatarios
Si desea enviar un SMS idéntico a varios destinatarios, deberá establecer una conexión
para cada destinatario.

4406

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará más información detallada sobre los tipos de conexión en la descripción de la
instrucción TC_CON.
El parámetro ID referencia la conexión GPRS. El valor de la ID debe ser equivalente al valor
de ID utilizado en TC_CON.
El parámetro INTERFACE referencia la interfaz GPRS del CP local deseado. El valor debe ser
idéntico al utilizado para INTERFACE en TC_CON.
El número de datos que deben enviarse se indica en el parámetro LEN.
El tamaño del rango de datos indicado en DATA debe ser como mínimo tan grande como el
número de bytes configurado en LEN. Los tipos de datos permitidos en el rango de datos
indicado en DATA son todos excepto BOOL y ARRAY of BOOL.
La dirección de destino (interlocutor) para los datos que deben enviarse se configura en la
instrucción TC_CON.

Interfaz de llamada en representación FUP
7&B6(1'
%22/

5(4

%86<

%22/

&211B28&

,'

'21(

%22/

+:B,17(5)$&(

,17(5)$&(

(5525

%22/

8,17

/(1

67$786

:25'

9$5,$17

'$7$

Explicación de los parámetros formales
La tabla siguiente muestra los parámetros formales de la instrucción TC_SEND.
Parámetro

Declaración

Tipo de datos

Rango de valores

Descripción

REQ

INPUT

BOOL

0, 1

Con un flanco ascendente se inicia el pro‐
cesamiento de la instrucción y se iniciali‐
zan los indicadores de estado.
Actualización de los indicadores de esta‐
do DONE, ERROR y STATUS cuando no
hay ningún flanco ascendente.

ID

INPUT

CONN_OUC

INTERFACE

INPUT

HW_INTERFA‐
CE

LEN

INPUT

UINT

1...07FFh

Referencia a la conexión correspondiente
Referencia a la interfaz del CP
Consulte la "ID de hardware" en el capí‐
tulo TC_CON: establecer un enlace a tra‐
vés de la red GSM (Página 4399).

1...2048

Número de bytes de los datos que deben
enviarse.
El valor debe ser ≥ 1 y ≤ 2048.
El valor debería corresponderse con el ta‐
maño del rango de DATA.

Programación del PLC
Manual de programación y manejo, 11/2019

4407

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

DATA

INOUT

VARIANT

ENO

OUTPUT

BOOL

Rango de valores

Referencia de dirección al rango de datos
de la CPU que debe transferirse*
0: Error
1: correcto

BUSY

OUTPUT

BOOL

Descripción

0: procesamiento de la instruc‐
ción todavía no iniciado, finali‐
zado o cancelado

Salida de habilitación
Si la instrucción presenta un error en el
tiempo de ejecución, se pondrá ENO = 0.
Indicador del estado de procesamiento
de la instrucción

1: procesamiento de la instruc‐
ción en curso
DONE

OUTPUT

BOOL

0: 1: procesamiento de la instruc‐
ción finalizado correctamente

ERROR

STATUS

OUTPUT

OUTPUT

BOOL

El parámetro de estado indica si la peti‐
ción se ha desarrollado correctamente. **
Consulte el significado en relación con los
parámetros ERROR y STATUS en Indi‐
cadores de la instrucción.

0: -

Indicador de error

1: Error

Consulte el significado en relación con los
parámetros DONE y STATUS en Indica‐
dores de la instrucción.

WORD

Indicador de estado
Consulte el significado en relación con los
parámetros DONE y ERROR en Indica‐
dores de la instrucción.

* Consulte el apartado siguiente para las particularidades del parámetro DATA para textos SMS.
** Tras enviar un telegrama, TC_SEND pone DONE = 1. Observe el comportamiento siguiente:
el fallo de una conexión ISO-on-TCP no es detectada por el emisor hasta pasados 1 o 2 minutos. Los datos transferidos pueden
haberse perdido aunque TC_SEND haya puesto DONE = 1 en el emisor.
Si se cancela una conexión ISO-on-TCP tras recibir un telegrama y antes de iniciar TC_RECV, es posible que los datos
transferidos se pierdan incluso si TC_SEND ha puesto DONE = 1 en el emisor.

Configuración de textos SMS con el parámetro DATA
La instrucción envía como texto SMS aquellos datos a los que hace referencia el indicador del
tipo VARIANT del parámetro DATA.
Si desde DATA se hace referencia a un operando del tipo de datos STRING para textos SMS,
entonces también se transfieren los dos primeros bytes con indicaciones de longitud del string.
Una posibilidad para la representación correcta de textos SMS para enviar es la conversión del
string de texto en un Array of BYTE o Array of CHAR con ayuda de la función de conversión
Strg_TO_Chars. Strg_TO_Chars se vincula al parámetro EN con el parámetro de salida ENO
de TC_SEND.
Para textos SMS, el CP no soporta todos los caracteres especiales, como por ejemplo la
diéresis. Se aplica la especificación GSM 03.38. Pueden aparecer limitaciones adicionales
debido al proveedor de red GSM.

4408

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Indicadores BUSY, DONE y ERROR
Los indicadores DONE y ERROR solo son relevantes si BUSY = 0.
BUSY

DONE

ERROR

Significado

0

0

0

Ninguna petición en proceso

Encontrará todas las demás combinaciones de los indicadores DONE y ERROR en la tabla
siguiente.

Indicadores DONE, ERROR y STATUS
La tabla siguiente muestra el significado de la información suministrada por DONE, ERROR y
STATUS, la cual tiene que ser evaluada por el programa de usuario.
DONE

ERROR

STATUS *

Significado

1

0

0000H

Petición ejecutada correctamente

0

0

7000H

No hay ningún procesamiento de petición activo (primera llamada de la instrucción)

0

0

7001H

Procesamiento de petición iniciado (primera llamada de la instrucción)

0

0

7002H

Procesamiento de petición en curso (nueva llamada de la instrucción si BUSY = 1)

0

1

8086H

Valor no permitido para ID

0

1

80E0H

Error interno
Si se envían telegramas directamente al servidor de Telecontrol (modo de operación
"Telecontrol"), asegúrese de que el tiempo de ciclo de emisión ≥ 1 segundo.

0

1

80E1H

Rebase de tiempo:
● Aumente el valor del "tiempo de vigilancia de conexión" en la configuración del
CP 1242-7 o
● Compruebe el interlocutor.

0

1

80E4H

ID desconocida:
Llame en primer lugar la instrucción TC_CON.

0

1

80E6H

Ninguna solicitud en proceso (la activación de la instrucción no se inicia)

0

1

80E7H

Los datos que debían enviarse no se han transferido íntegramente:

0

1

80E8H

Repita la petición.
Interlocutor remoto no accesible. Compruebe los parámetros de conexión.
En el modo de operación "GPRS directo", el aviso se emite cuando el interlocutor está
accesible pero no acepta las peticiones de conexión.
0

1

80E9H

Desconexión por parte del interlocutor remoto:
Compruebe el interlocutor. En dado caso, deshaga la conexión con TC_DISCON y es‐
tablézcala nuevamente con TC_CON.

0

1

80EAH

Mensaje de error del interlocutor remoto:
● Compruebe el interlocutor. Active la instrucción "TC_RECV" en el interlocutor.
● En dado caso, deshaga la conexión con TC_DISCON y establézcala nuevamente con
TC_CON.

Programación del PLC
Manual de programación y manejo, 11/2019

4409

Instrucciones
4.1 Instrucciones
DONE

ERROR

STATUS *

Significado

0

1

80EFH

No se ha podido enviar el SMS:
● Compruebe si existe la dirección de destino (número de llamada del participante
destinatario).
● Compruebe si la tarjeta SIM insertada soporta el envío de SMS.
● Compruebe la longitud del texto SMS enviado. Los textos SMS > 160 caracteres no
se envían.
● Asegúrese de que la opción "Estándar" se haya seleccionado para el acceso al
bloque en el momento de crear el bloque de datos TCON_PHONE.

0

1

80F1H

En envío de SMS no está activado en la configuración STEP 7 del CP:

0

1

80F4H

No se puede generar el punto final de la conexión:

0

1

80F5H

Punto final de la conexión no válido:

Active la opción "Permitir SMS" en la configuración del CP.
Compruebe el interlocutor.
● Fallo en el establecimiento de la conexión a través de TC_CON.
o bien
● Desconexión por parte del interlocutor remoto: Llame la instrucción TC_DISCON.
0

1

80F6H

Error de formato de un parámetro en el bloque de datos llamado (tamaño erróneo, for‐
mato incorrecto o valor no válido):
Compruebe la configuración del SDT "TC_CON...".

* Encontrará otros estados que no aparecen aquí en los indicadores de estado de las instrucciones "RDREC" y "WRREC", bajo
los dos bytes de estado centrales (STATUS[2], STATUS[3]).

4410

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

TC_RECV: recibir datos a través de la red GSM
Significado
La instrucción TC_RECV permite recibir datos a través de las conexiones programadas de los
tipos siguientes:
● conexiones ISO‑ON‑TCP
● conexiones SMS
Para recibir SMS debe estar configurado el número de llamada del remitente en la
configuración STEP 7 del CP que debe recibirse (números de llamada autorizados). El
remitente debe soportar la función CLIP.
El número de llamada del interlocutor debe introducirse en el SDT "TCON_PHONE".
Los SMS de alarma se excluyen mediante un filtro.
● Conexiones Telecontrol
Nota
Recibir SMS de varios remitentes
Si desea recibir SMS de varios remitentes, puede escoger para ello entre dos alternativas:
● Debe configurar varias conexiones (TC_CON, TC_RECV, TC_DISCON).
o bien
● En una única conexión configurada en el bloque de datos necesario "TCON_PHONE"
en el parámetro "PhoneNumber" no puede introducir ningún número de llamada. Esto
se interpretará durante la recepción de mensajes como comodín para todos los
interlocutores autorizados.
Encontrará más información detallada sobre los tipos de conexión en la descripción de la
instrucción TC_CON.
El parámetro ID referencia la conexión GPRS. El valor de la ID debe ser equivalente al valor
de ID utilizado en TC_CON.
El parámetro INTERFACE referencia la interfaz GPRS del CP local deseado. El valor debe ser
idéntico al utilizado para INTERFACE en TC_CON.
El número máximo de los datos de recepción se indica en el parámetro LEN.
El tamaño del rango de datos indicado en DATA debe ser como mínimo tan grande como el
número de bytes configurado en LEN. Los tipos de datos permitidos en el rango de datos
indicado en DATA son todos excepto BOOL y ARRAY of BOOL. Los datos recibidos se
interpretan como si el interlocutor remitente hubiera utilizado los mismos tipos de datos.
El DB (tipo de datos de sistema) utilizado para la descripción de la conexión de TC_RECV se
debe distinguir de un DB utilizado para TC_SEND.

Programación del PLC
Manual de programación y manejo, 11/2019

4411

Instrucciones
4.1 Instrucciones

Almacenamiento de SMS
Los SMS recibidos se almacenan de forma remanente en el CP 1242-7 (25 espacios de
memoria) y en la tarjeta SIM (número variable de espacios de memoria).
● Una vez TC_RECV ha leído el SMS, este se borra de la memoria.
● Si todos los espacios de memoria están ocupados y se recibe un nuevo SMS, se borra el
más antiguo.

Interfaz de llamada en representación FUP
7&B5(&9
%22/

(1B5

&211B28&

,'

+:B,17(5)$&(

,17(5)$&(

8,17
9$5,$17

5&9'B/(1

8,17

%86<

%22/

1'5

%22/

/(1

(5525

%22/

'$7$

67$786

:25'

Explicación de los parámetros formales
La tabla siguiente muestra los parámetros formales de la instrucción TC_RECV.
Parámetro

Declaración

Tipo de datos

Rango de valores

Descripción

EN_R

INPUT

BOOL

0: recepción de datos bloquea‐
da

Permitir/bloquear la recepción de datos.

1: recepción de datos permitida

● Versión 1.1 del bloque: tras pasar de 1
a 0 el bloque queda inactivo.
● Versión 1.0 del bloque: tras pasar de 1
a 0, el bloque de programa recibe
datos una vez más (hasta que DONE
= 0 y ERROR = 0).
Tenga en cuenta las indicaciones sobre el
indicador de estado 80E3 en TC_CON.

ID

INPUT

CONN_OUC

INTERFACE

INPUT

HW_INTERFA‐
CE

LEN

INPUT

UINT

DATA

INOUT

VARIANT

ENO

OUTPUT

BOOL

1...07FFh

Referencia a la interfaz del CP 1242‑7
Consulte la "ID de hardware" en el capí‐
tulo TC_CON: establecer un enlace a tra‐
vés de la red GSM (Página 4399).
1...2048

4412

OUTPUT

UINT

Número (mínimo) de bytes de los datos
que deben recibirse, máximo 2048
Referencia de dirección al rango de datos
de recepción de la CPU*

0: error
1: correcto

RCVD_LEN

Referencia a la conexión correspondiente

Salida de habilitación
Si la instrucción presenta un error en el
tiempo de ejecución, se pondrá ENO = 0.
Número de bytes de los datos recibidos

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Rango de valores

Descripción

BUSY

OUTPUT

BOOL

0: procesamiento de la instruc‐
ción todavía no iniciado, finali‐
zado o cancelado

Indicador del estado de procesamiento
de la instrucción

1: procesamiento de la instruc‐
ción en curso
DONE

OUTPUT

BOOL

0: 1: procesamiento de la instruc‐
ción finalizado correctamente

ERROR

OUTPUT

STATUS

OUTPUT

BOOL

El parámetro de estado indica si la peti‐
ción se ha desarrollado correctamente.
Consulte el significado en relación con los
parámetros ERROR y STATUS en Indi‐
cadores de la instrucción.

0: -

Indicador de error

1: error

Consulte el significado en relación con los
parámetros DONE y STATUS en Indica‐
dores de la instrucción.

WORD

Indicador de estado
Consulte el significado en relación con los
parámetros DONE y ERROR en Indica‐
dores de la instrucción.

* Consulte el apartado siguiente para las particularidades del parámetro DATA para textos SMS.

Configuración de textos SMS con el parámetro DATA
La instrucción hace referencia al texto SMS recibido con el indicador del tipo VARIANT del
parámetro DATA en el rango de datos de la CPU.
Si desde DATA se hace referencia a un operando del tipo de datos STRING para el texto SMS,
entonces se interpretan los dos primeros bytes del texto SMS como indicaciones de longitud
del tipo de datos STRING y no como texto SMS.
Una posibilidad para la representación correcta de textos SMS para recibir es la conversión de
un Array of BYTE o Array of CHAR en un string de texto con ayuda de la función de conversión
Chars_TO_Strg. Chars_TO_Strg se vincula al parámetro EN con el parámetro de salida ENO
de TC_RECV.
Para textos SMS, el CP no soporta todos los caracteres especiales, como por ejemplo la
diéresis. Se aplica la especificación GSM 03.38. Pueden aparecer limitaciones adicionales
debido al proveedor de red GSM.

Indicadores BUSY, DONE y ERROR
Los indicadores DONE y ERROR solo son relevantes si BUSY = 0.
BUSY

DONE

ERROR

Significado

0

0

0

Ninguna petición en proceso

Encontrará todas las demás combinaciones de los indicadores DONE y ERROR en la tabla
siguiente.

Programación del PLC
Manual de programación y manejo, 11/2019

4413

Instrucciones
4.1 Instrucciones

Indicadores DONE, ERROR y STATUS
La tabla siguiente muestra el significado de la información suministrada por DONE, ERROR y
STATUS, la cual tiene que ser evaluada por el programa de usuario.
DONE

ERROR

STATUS *

Significado

1

0

0000H

Petición ejecutada correctamente

0

0

7000H

No hay ningún procesamiento de petición activo (primera llamada de la instrucción)

0

0

7001H

Procesamiento de petición iniciado (primera llamada de la instrucción)

0

0

7002H

Procesamiento de petición en curso (nueva llamada de la instrucción si BUSY = 1)

0

1

80A3H

● Se está intentando volver a establecer una conexión existente.
● Se está intentando finalizar una conexión no existente.

0

1

80E0H

Error interno

0

1

8086H

Valor no permitido para ID

0

1

80E4H

ID desconocida:
llame en primer lugar la instrucción TC_CON.

0

1

80E6H

Ninguna solicitud en proceso (la activación de la instrucción no se inicia)

0

1

80F5H

Punto final de la conexión no válido:
● Fallo en el establecimiento de la conexión a través de TC_CON.
o bien
● Desconexión por parte del interlocutor remoto: llame la instrucción TC_DISCON.

0

1

80F6H

Error de formato de un parámetro en el bloque de datos llamado (tamaño erróneo, for‐
mato incorrecto o valor no válido)
Compruebe la configuración del SDT "TC_CON...".

* Encontrará otros estados que no aparecen aquí en los indicadores de estado de las instrucciones "RDREC" y "WRREC", bajo
los dos bytes de estado centrales (STATUS[2], STATUS[3]).

TC_CONFIG: transferir datos de configuración al CP
Significado
La instrucción TC_CONFIG permite modificar los parámetros de un CP de telefonía móvil
S7-1200 que se han configurado en STEP 7. Los valores configurados no se sobrescriben de
forma remanente. Los valores sobrescritos siguen siendo válidos hasta una nueva llamada de
TC_CONFIG o hasta el siguiente arranque de la estación (arranque en frío mediante la tensión
OFF → ON).
Para poder utilizar esta función, en la configuración básica del CP en STEP 7 debe haber
valores configurados.
Si los datos de configuración STEP 7 del CP deben modificarse permanentemente, entonces
la instrucción debe llamarse de nuevo después de cada arranque de la estación (arranque en
frío) o se debe cargar un proyecto modificado en la estación.
El parámetro CONFIG hace referencia al área de memoria con los datos de configuración. Los
datos de configuración se guardan en un bloque de datos (DB). La estructura del DB está
predeterminada por el tipo de datos de sistema (SDT) IF_CONF.

4414

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los datos de configuración que deben modificarse en el CP se compilan en el IF_CONF como
bloques "IF_CONF_..." para los diferentes parámetros, según sea necesario.
Los parámetros que no deben modificarse con la instrucción no se introducen en el IF_CONF.
Estos conservan el valor configurado en STEP 7.
Encontrará información detallada sobre la parametrización de IF_CONF en el apartado
IF_CONF: SDT para datos de configuración Telecontrol (Página 4421).
El parámetro INTERFACE referencia la interfaz GPRS del CP local deseado.

Interfaz de llamada en representación FUP
7&B&21),*
%22/

5(4

%86<

%22/

+:B,17(5)$&(

,17(5)$&(

'21(

%22/

(5525

%22/

67$786

:25'

9$5,$17

&21),*

Explicación de los parámetros formales
La tabla siguiente muestra los parámetros formales de la instrucción TC_CONFIG.
Parámetro

Declaración

Tipo de datos

Rango de valores

Descripción

REQ

INPUT

BOOL

0, 1

Con un flanco ascendente se inicia el pro‐
cesamiento de la instrucción y se iniciali‐
zan los indicadores de estado.
Actualización de los indicadores de esta‐
do DONE, ERROR y STATUS cuando no
hay ningún flanco ascendente.

INTERFACE

INPUT

HW_INTERFA‐
CE (WORD)

Referencia a la interfaz del CP 1242‑7
Consulte la "ID de hardware" en el capí‐
tulo TC_CON: establecer un enlace a tra‐
vés de la red GSM (Página 4399).

CONFIG

INOUT

VARIANT

Véase también "IF_CONF:
SDT para datos de configura‐
ción de Telecontrol"

Referencia al área de memoria con la
compilación de los datos de configuración
que deben modificarse

ENO

OUTPUT

BOOL

0: error

Salida de habilitación
Si la instrucción presenta un error en el
tiempo de ejecución, se pondrá ENO = 0.

1: correcto
BUSY

OUTPUT

BOOL

0: procesamiento de la instruc‐
ción todavía no iniciado, finali‐
zado o cancelado

Indicador del estado de procesamiento
de la instrucción

1: procesamiento de la instruc‐
ción en curso

Programación del PLC
Manual de programación y manejo, 11/2019

4415

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Rango de valores

Descripción

DONE

OUTPUT

BOOL

0: -

El parámetro de estado indica si la peti‐
ción se ha desarrollado correctamente.

1: procesamiento de la instruc‐
ción finalizado correctamente

ERROR

OUTPUT

STATUS

OUTPUT

BOOL

Consulte el significado en relación con los
parámetros ERROR y STATUS en Indi‐
cadores de la instrucción.

0: -

Indicador de error

1: error

Consulte el significado en relación con los
parámetros DONE y STATUS en Indica‐
dores de la instrucción.

WORD

Indicador de estado
Consulte el significado en relación con los
parámetros DONE y ERROR en Indica‐
dores de la instrucción.

Indicadores BUSY, DONE y ERROR
Los indicadores DONE y ERROR solo son relevantes si BUSY = 0.
BUSY

DONE

ERROR

Significado

0

0

0

Ninguna petición en proceso

Encontrará todas las demás combinaciones de los indicadores DONE y ERROR en la tabla
siguiente.

Indicadores DONE, ERROR y STATUS
La tabla siguiente muestra el significado de la información suministrada por DONE, ERROR y
STATUS, la cual tiene que ser evaluada por el programa de usuario.
DONE

ERROR

STATUS

Significado

1

0

0000H

Petición ejecutada correctamente

0

0

7000H

No hay ningún procesamiento de petición activo (primera llamada de la instrucción)

0

0

7001H

Procesamiento de petición iniciado (primera llamada de la instrucción)

0

0

7002H

Procesamiento de petición en curso (nueva llamada de la instrucción si BUSY = 1)

0

1

80E0H

Error interno (p. ej. no hay valores en la configuración básica de un parámetro)

0

1

80E6H

Ninguna solicitud en proceso (la activación de la instrucción no se inicia)

0

1

80EBH

Solicitud rechazada temporalmente (el CP es configurado momentáneamente por STEP
7).

0

1

80F6H

Error de formato de un parámetro en el bloque de datos llamado (tamaño erróneo, for‐
mato incorrecto o valor no válido)
Compruebe el SDT "IF_CONF".

0

1

80F7H

ID incorrecta en los bloques de parámetros de los datos de configuración:
Compruebe el SDT "IF_CONF".

4416

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

TCON_...: SDTs para el establecimiento de un enlace Telecontrol
Tipos de datos de sistema TCON_... para conexiones de Telecontrol
Los cuatro tipos de datos de sistema TCON_... que se describen a continuación se utilizan,
entre otros, para la descripción de conexiones de Telecontrol de un CP de Telecontrol.
TCON_PHONE se utiliza también en CP de telefonía móvil del S7-1200 para describir una
conexión de Open User Communication con el fin de transferir SMS (TCON / TDISCON /
TSEND o TSEND_C).
Para configurar el establecimiento de una conexión de Telecontrol en el CP de Telecontrol
mediante la instrucción TC_CON se utiliza el parámetro CONNECT de la instrucción para
describir la conexión.
La descripción del enlace está especificada por la estructura de un tipo de datos del sistema
(SDT). La estructura del SDT correspondiente contiene los parámetros necesarios para
establecer el enlace con un interlocutor remoto.
Para diferentes tipos de enlace que dependen del interlocutor remoto correspondiente se
utilizan los siguientes SDTs:
● TCON_IP_RFC para enlaces ISO‑on‑TCP con estaciones IPv4 con CP de Telecontrol
● TCON_IP_V4 para enlaces UDP con estaciones IPv4 (solo enviar)
● TCON_PHONE para enlaces con clientes SMS
● TCON_WDC para enlaces con servidores Telecontrol o estaciones a las que se accede a
través del servidor Telecontrol.
La parametrización de la descripción del enlace se realiza en un bloque de datos del mismo
tipo que el SDT.

Creación de un DB del tipo TCON_...
Los tipos de datos de cada DB deben introducirse con el teclado. No se muestran en la lista de
selección. No se tienen en cuenta las mayúsculas/minúsculas al introducir los tipos de datos.
Para crear un DB TCON_... proceda del siguiente modo:
1. Cree un bloque de datos del tipo "DB global" con acceso estándar al bloque (no optimizado).
2. Cree un SDT en la tabla de configuración de parámetros del DB asignándole un nombre e
introduciendo el tipo deseado en la celda del tipo de datos (por ejemplo, "TCON_IP_RFC").
Se crea el SDT con sus parámetros (ver abajo).
3. Configure los parámetros que se describen a continuación para cada tipo SDT.
Los bits reservados no se muestran.

Programación del PLC
Manual de programación y manejo, 11/2019

4417

Instrucciones
4.1 Instrucciones

Tipo de datos de sistema TCON_IP_RFC para enlaces con estaciones IPv4
Este tipo de enlace solo es soportado en enlaces ISO‑on‑TCP con interlocutores con dirección
IP fija. El CP debe estar configurado para el modo de operación "GPRS directo".
Tabla 4-114 Parámetros de TCON_IP_RFC
Byte

Parámetro

Tipo de datos

0 ... 1

InterfaceID

HW_ANY

Valor inicial

Descripción
Referencia a la interfaz del CP
Consulte la "ID de hardware" en el capítulo TC_CON:
establecer un enlace a través de la red GSM (Pági‐
na 4399).

2 ... 3

ID

CONN_OUC

1...07FFh

Referencia al enlace GPRS local. La ID se asigna y
debe ser unívoca dentro de la CPU.
Aquí debe utilizarse el mismo valor que el del pará‐
metro ID de la instrucción TC_CON.

4

ConnectionType

BYTE

5

ActiveEstablished

BOOL

W#16#0C

Variante de protocolo 12 (Ch): Enlace ISO‑on‑TCP
Identificación del tipo de establecimiento del enlace:
● 0: establecimiento pasivo del enlace
● 1: establecimiento activo del enlace

6 ... 7
8 ... 11

-

-

RemoteAddress

IP_V4

Dirección IP de los interlocutores

Array [1...4] of
Byte

Dirección IP del interlocutor respectivo

TSelector

Selector T remoto

UINT

Tamaño del selector T remoto "RemoteTSelector"

ADDR
RemoteTSelector

12 ...
13

TSelLen

14 ...
45

TSel

Array [1...32]
of Byte

-

Cualquiera

- reservado -

Selector de transporte remoto del enlace
● Si "ActiveEstablished" = 1:
El selector T del interlocutor local debe ser idéntico
al selector T del interlocutor en el establecimiento
de enlace activo (establecimiento de enlace
pasivo en el interlocutor remoto).
● Si "ActiveEstablished" = 0 correspondiente
(establecimiento de conexión local pasivo,
establecimiento de conexión remota activo)

LocalTSelector
46 ...
47

TSelLen

48 ...
79

TSel

TSelector

Selector T local

UINT

Longitud del selector T local "LOCAL_TSel"

Array [1...32]
of Byte

Cualquiera

Selector de transporte local del enlace
● Si "ActiveEstablished" = 1:
El selector T del interlocutor local debe ser idéntico
al selector T del interlocutor en el establecimiento
de enlace activo (establecimiento de enlace
pasivo en el interlocutor remoto).
● Si "ActiveEstablished" = 0 correspondiente
(establecimiento de conexión local pasivo,
establecimiento de conexión remota activo)

4418

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Tipo de datos de sistema TCON_IP_V4 para enlaces con estaciones IPv4
Este tipo de enlace solo es soportado para el envío a través de enlaces UDP a interlocutores
con dirección IP fija.
Si se debe recibir, entonces ActiveEstablished = 0 debe activarse.
Tabla 4-115 Parámetros de TCON_IP_V4
Byte

Parámetro

Tipo de datos

0 ... 1

InterfaceID

HW_ANY

Valor inicial

Descripción
Referencia a la interfaz del CP
Consulte la "ID de hardware" en el capítulo TC_CON:
establecer un enlace a través de la red GSM (Pági‐
na 4399).

2 ... 3

ID

CONN_OUC

1...07FFh

Referencia al enlace GPRS local. La ID se asigna y
debe ser unívoca dentro de la CPU.
Aquí debe utilizarse el mismo valor que el del pará‐
metro ID de la instrucción TC_CON.

4

ConnectionType

BYTE

5

ActiveEstablished

BOOL

W#16#0B

Variante de protocolo 11 (Bh): Enlace UDP
Identificación del tipo de establecimiento del enlace:
● 0: establecimiento pasivo del enlace
Ajuste para el envío y la recepción de datos.
● 1: establecimiento activo del enlace
Ajuste solo para el envío de datos.

6 ... 9

RemoteAddress
ADDR

10 ...
11

RemotePort

12 ...
13

LocalPort

IP_V4

Dirección IP del interlocutor

Array [1...4] of
Byte

Los cuatro bytes (ADDR[1] ... ADDR[4]) especifican
los cuatro bloques de la dirección IP.

UINT

1...65535

Puerto IP del interlocutor
Sin relevancia si ActiveEstablished = 0.

UINT

1...65535

Puerto IP local ("0" no está permitido.)
Sin relevancia si ActiveEstablished = 1.

Tipo de datos de sistema TCON_PHONE para enlaces SMS
Nota
Números de llamada autorizados
El requisito para que el CP acepte un SMS es la autorización del interlocutor emisor mediante
su número de llamada. Estos números de llamada se configuran en STEP 7 con el CP en la
lista "Números de llamada autorizados".
Texto SMS
● Se accede a los textos SMS programados para SMS que deben ser enviados a través del
parámetro DATA de la instrucción TC_SEND.
● El texto de un SMS recibido se asigna al rango de direcciones de la CPU a través del
parámetro DATA de la instrucción TC_RECV.

Programación del PLC
Manual de programación y manejo, 11/2019

4419

Instrucciones
4.1 Instrucciones
Tabla 4-116 Parámetros de TCON_PHONE
Byte

Parámetro

Tipo de datos

0 ... 1

InterfaceID

HW_ANY

Valor inicial

Descripción
Referencia a la interfaz del CP
Consulte la "ID de hardware" en el capítulo TC_CON:
establecer un enlace a través de la red GSM (Pági‐
na 4399).

2 ... 3

ID

CONN_OUC

1...07FFh

Referencia a la conexión local de telefonía móvil. La
ID se asigna y debe ser unívoca dentro de la CPU.
Aquí debe utilizarse el mismo valor que el del pará‐
metro ID de la instrucción TC_CON.

4

ConnectionType

BYTE

5

ActiveEstablished

BOOL

W#16#0E

Variante de protocolo 14 (Eh): enlace SMS
Identificación del tipo de establecimiento del enlace
(no relevante para el CP 1242‑7):
● 0: establecimiento pasivo del enlace (irrelevante
en este caso)
● 1: establecimiento activo del enlace

6...7

-

-

8 ... 31 PhoneNumber

STRING[22]

-

- reserviert Número de abonado del interlocutor
Valores permitidos: signo más (+) y cifras
Tenga en cuenta los caracteres concretos del prefijo
de país de los números de llamada en cuestión asig‐
nado por el proveedor de red (signos "+" o ceros).
Sin la entrada del parámetro PhoneNumber no se es‐
pecificará ningún interlocutor y se podrán recibir SMS
de todos los interlocutores autorizados.
Al arrancar, tenga en cuenta lo siguiente: Si no se
realiza ninguna entrada, el TC_RECV suministra pri‐
mero el SMS recibido con más anterioridad.

Tipos de datos del sistema TCON_WDC para conexiones con servidores de Telecontrol o estaciones
remotas
El enlace con el servidor Telecontrol que está asignado al S7-1200 o con una estación remota
a la que se accede a través del servidor Telecontrol se puede configurar con TCON_WDC. Los
datos de dirección del servidor Telecontrol asignado al CP se encuentran en STEP 7, en la
ficha "Interfaz de Telecontrol > Modo de operación" del CP. El servidor Telecontrol o la
estación remota se direcciona mediante el nombre de host o mediante la dirección IP.

4420

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En el parámetro "RemoteWdcAddress" de TCON_WDC se indica la ID de acceso del
interlocutor.
Tabla 4-117 Parámetros de TCON_WDC
Byte

Parámetro

Tipo de datos

0 ... 1

InterfaceID

HW_ANY

Valor inicial

Descripción
Referencia a la interfaz del CP
Consulte la "ID de hardware" en el capítulo TC_CON:
establecer un enlace a través de la red GSM (Pági‐
na 4399).

2 ... 3

ID

CONN_OUC

1...07FFh

Referencia al enlace GPRS local. La ID se asigna y
debe ser unívoca dentro de la CPU.
Aquí debe utilizarse el mismo valor que el del pará‐
metro ID de la instrucción TC_CON.

4

ConnectionType

BYTE

5

ActiveEstablished

BOOL

W#16#0F

Variante de protocolo 15 (Fh): enlace Telecontrol me‐
diante dirección IP
Identificación del tipo de establecimiento del enlace:
● 0: establecimiento pasivo del enlace
● 1: establecimiento activo del enlace

6 ... 7

-

-

8 ... 11 RemoteWdcAddress

-

DWORD

- reservado Indicación de la ID de acceso (hex). La ID de acceso
depende del interlocutor.
● Enlace con un CP remoto:
La ID de acceso está compuesta por:
–

número de proyecto de STEP 7

–

número de estación

–

slot
Si la estación remota tiene varios CP GPRS y
no va a definirse la ruta, deberá ponerse 0 en
el último byte para el slot.

La ID de acceso se encuentra en el proyecto de
STEP 7, en el grupo de parámetros "Autenticación
CP" del CP.
● No hay conexión con el servidor de Telecontrol:
ID de acceso = 0
● Solo para escribir en la imagen de proceso del CP:
ID de acceso = DW#16#FEEDDADA

IF_CONF: SDT para datos de configuración Telecontrol
Establecimiento del tipo de datos del sistema IF_CONF para la instrucción TC_CONFIG
El parámetro CONFIG de la instrucción TC_CONFIG referencia el área de memoria con los
datos de configuración del CP que deben modificarse. Los datos de configuración
almacenados en un bloque de datos se describen como estructura del tipo de datos del
sistema (SDT) IF_CONF.

Programación del PLC
Manual de programación y manejo, 11/2019

4421

Instrucciones
4.1 Instrucciones
Para poder utilizar esta función, en la configuración básica del CP en STEP 7 debe haber
valores configurados.
IF_CONF está formado por un encabezado y los bloques siguientes, correspondientes a los
parámetros o áreas de parámetros del CP en las propiedades de dispositivos del proyecto de
STEP 7.
Los datos de configuración del CP que deben modificarse se compilan a modo de bloques
IF_CONF. Los parámetros que no deben modificarse no se tienen en cuenta en la estructura
de IF_CONF y se quedan tal como se han configurado en el proyecto de STEP 7.

Creación de un DB y de las estructuras IF_CONF
Los parámetros del CP los puede crear dentro del DB IF_CONF en una o más estructuras y
cada una con uno o más bloques.
Los tipos de datos de cada bloque deben introducirse con el teclado. No se muestran en la lista
de selección. No se tienen en cuenta las mayúsculas/minúsculas al introducir los tipos de
datos.
Proceda del siguiente modo para crear IF_CONF:
1. Cree un bloque de datos del tipo "DB global" con acceso al bloque "estándar".
2. Cree una estructura en la tabla de la configuración del parámetro del DB (tipo de datos
"Struct").
Puede determinar el nombre libremente.
3. Inserte un encabezado en esta estructura asignando el nombre del encabezado e
introduciéndolo en la celda del tipo de datos "IF_CONF_Header".
Se crea el encabezado de la estructura con sus tres parámetros (ver abajo).
4. Cree un bloque para el primer parámetro que debe modificarse introduciendo el tipo de
datos deseado (por ejemplo, "IF_CONF_APN") en la celda del tipo de datos.
5. Repita el último paso para todos aquellos parámetros que desee modificar con ayuda de la
instrucción TC_CONFIG en el CP.
6. A continuación actualice en el encabezado el número de bloques en el parámetro
"subfieldCnt".

Encabezado de IF_CONF
Tabla 4-118 IF_CONF_Header
Byte

Parámetro

Tipo de datos Valor inicial

Descripción

0 ... 1

fieldType

UINT

Tipo de bloque: tiene que ser siempre 0.

2 ... 3

fieldId

UINT

ID de bloque: tiene que ser siempre 0.

4 ... 5

subfieldCnt

UINT

Número total de bloques incluidos en la estructura

4422

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros generales de los bloques de parámetros
Cada bloque contiene los siguientes parámetros generales:
● Id
Este parámetro identifica el bloque correspondiente y no puede modificarse.
● Length
Este parámetro indica el tamaño del bloque. El valor solo sirve para fines informativos.
Los bloques que contienen strings y/o arrays tienen una longitud variable. Debido a los
bytes ocultos, la longitud real de los bloques puede ser mayor que la suma de los
parámetros mostrados.
● Mode
Para este parámetro se admiten los valores siguientes:
Tabla 4-119 Valores de "Mode"
Valor

Significado

1

Validez permanente de los datos de configuración
Irrelevante en el CP

2

Validez temporal de los datos de configuración, inclusive el borrado de los datos de
configuración permanentes existentes
Los datos de configuración permanentes se reemplazan por los bloques de parámetros
de IF_CONF.

Bloque para el área de parámetros "Acceso GPRS"
Tabla 4-120 IF_CONF_APN
Parámetro

Tipo de datos

Valor inicial

Descripción

Id

UINT

4

Identificación del bloque de parámetros

Length

UINT

Tamaño del bloque de parámetros en bytes: 174

Mode

UINT

Validez (1: permanente, 2: temporal)

AccesspointGPRS

STRING [98]

APN: Nombre del punto de acceso del operador de red
GSM a Internet

AccesspointUser

STRING [42]

Nombre de usuario APN

AccesspointPassword

STRING [22]

Contraseña APN

Bloque para el área de parámetros "Identificación CP"
Tabla 4-121 IF_CONF_Login
Parámetro

Tipo de datos

Valor inicial

Descripción

Id

UINT

5

Identificación del bloque de parámetros

Length

UINT

Tamaño del bloque de parámetros en bytes: 54

Mode

UINT

Validez (1: permanente, 2: temporal)

Programación del PLC
Manual de programación y manejo, 11/2019

4423

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de datos

ModemName

STRING [22]

Valor inicial

Descripción
ID de acceso
El valor no es parametrizable.

ModemPassword

STRING [22]

Contraseña de Telecontrol (máx. 20 caracteres)
La contraseña del CP 1242‑7 (6GK7 242‑7KX30‑0XE0) no
puede cambiarse con el SDT.

Bloque para el área de parámetros "Acceso al servidor Telecontrol"
Este bloque solo debe utilizarse si el servidor Telecontrol se direcciona con un nombre que
puede resolverse mediante DNS. Si el servidor Telecontrol se direcciona con su dirección IP,
se utilizará el bloque "IF_CONF_TCS_IP_V4".
En STEP 7, los datos correspondientes se encuentran en el área de parámetros "Modo de
operación".
Si hay varios servidores Telecontrol, utilice el bloque una vez por servidor.
Tabla 4-122 IF_CONF_TCS_Name
Parámetro

Tipo de datos

Valor inicial

Descripción

Id

UINT

6

Identificación del bloque de parámetros

Length

UINT

Mode

UINT

TcsName

-

Tamaño del bloque de parámetros en bytes: 266
Validez (1: permanente, 2: temporal)
-

- reservado -

STRING [254]

Nombre del servidor Telecontrol que puede resolverse me‐
diante DNS

RemotePort

UINT

Puerto del servidor Telecontrol

Rank

UINT

Prioridad del servidor [1, 2]
1 = primer servidor Telecontrol,
2 = segundo servidor Telecontrol

Bloque para el área de parámetros "Acceso al servidor Telecontrol"
El SDT solo puede utilizarse en el CP 1242‑7 (6GK7 242‑7KX30‑0XE0) en tiempo de ejecución
con fines de configuración.
Este bloque solo debe utilizarse si el servidor Telecontrol se direcciona con su dirección IP. Si
el servidor Telecontrol se direcciona con su nombre DNS, se utiliza el bloque
"IF_CONF_TCS_Name".
En STEP 7, los datos correspondientes se encuentran en el área de parámetros "Modo de
operación".
Si hay varios servidores Telecontrol, utilice el bloque una vez por servidor.
Tabla 4-123 IF_CONF_TCS_IP_v4
Parámetro

Tipo de datos

Valor inicial

Descripción

Id

UINT

7

Identificación del bloque de parámetros

Length

UINT

4424

Tamaño del bloque de parámetros en bytes: 14

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de datos

Mode

UINT

Valor inicial

Validez (1: permanente, 2: temporal)

Descripción

RemoteAddress

IP_V4

Dirección IP del servidor Telecontrol

RemotePort

UINT

Puerto del servidor Telecontrol

Rank

UINT

Prioridad del servidor [1, 2]
1 = primer servidor Telecontrol,
2 = segundo servidor Telecontrol

Bloque para el área de parámetros "Modo de operación"
El SDT solo puede utilizarse en el CP 1242‑7 (6GK7 242‑7KX30‑0XE0) en tiempo de ejecución
con fines de configuración.
En STEP 7, los datos correspondientes se encuentran en las secciones de parámetros "Modo
de operación" y "Configuración del módem".
Tabla 4-124 IF_CONF_GPRS_Mode
Parámetro

Tipo de datos

Valor inicial
8

Descripción

Id

UINT

Length

UINT

Tamaño del bloque de parámetros en bytes: 10

Identificación del bloque de parámetros

Mode

UINT

Validez (1: permanente, 2: temporal)

GPRSmode

UINT

Modo de operación del CP:
● 0 = Telecontrol
● 1 = GPRS directo

TemporaryStation

BOOL

Bit 0: Conexión temporal
Si la opción está activada, el CP establece un enlace de
forma temporal para enviar datos. Una vez finalizada co‐
rrectamente la transferencia de los telegramas, el CP des‐
hace la conexión.
● 1: activado (conexión temporal)
● 0: desactivado (enlace permanente)

SMS_Enabled

BOOL

Bit 1: Permitir SMS
La activación de esta opción permite a la estación S7 en‐
viar SMS.
● 1: activado (se permite SMS)
● 0: desactivado (sin SMS)

Programación del PLC
Manual de programación y manejo, 11/2019

4425

Instrucciones
4.1 Instrucciones

Bloque para el parámetro "SMSC"
En STEP 7, los datos correspondientes se encuentran en el área de parámetros
"Configuración del módem".
Tabla 4-125 IF_CONF_SMS_Provider
Tipo de datos

Valor inicial

Id

UINT

10

Length

UINT

Tamaño del bloque de parámetros en bytes: 28

Mode

UINT

Validez (1: permanente, 2: temporal)

SMSProvider

STRING [20]

Número de dispositivo de la central SMS (SMSC) del ope‐
rador de red GSM con el que se ha cerrado el contrato de
telefonía móvil para esta estación.

Parámetro

Descripción
Identificación del bloque de parámetros

Bloque para el parámetro "PIN"
En STEP 7, los datos correspondientes se encuentran en el área de parámetros
"Configuración del módem".
Tabla 4-126 IF_CONF_PIN
Tipo de datos

Valor inicial

Id

UINT

11

Length

UINT

Tamaño del bloque de parámetros en bytes: 16

Mode

UINT

Validez (1: permanente, 2: temporal)

Pin

STRING [8]

PIN de la tarjeta SIM insertada en el CP

Parámetro

Descripción
Identificación del bloque de parámetros

Este parámetro no es relevante si se ha configurado el PIN
correctamente. En caso de haber configurado el PIN erró‐
neamente, el PIN correcto puede introducirse aquí.

Bloque para tiempos de vigilancia
El SDT solo puede utilizarse en el CP 1242‑7 (6GK7 242‑7KX30‑0XE0) en tiempo de ejecución
con fines de configuración.
En STEP 7, los datos correspondientes se encuentran en las áreas de parámetros "Tiempo de
espera Keep Alive" y "Modo de operación" del CP.
Tabla 4-127 IF_CONF_TC_Timeouts
Parámetro

Tipo de datos

Valor inicial
12

Id

UINT

Length

UINT

Mode

UINT

KeepAliveTimeout

‑

4426

Descripción
Identificación del bloque de parámetros
Tamaño del bloque de parámetros en bytes: 12
Validez (1: permanente, 2: temporal)

‑

- Reservado - (no parametrizable)

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de datos

SendTimeout

UINT

Valor inicial

Descripción
Tiempo de vigilancia de conexión: Tiempo de vigilancia de
la conexión con el interlocutor (segundos)
Relevante en los modos de operación "Telecontrol" y
"GPRS directo"

RedialTimeout

UINT

Retardo al establecer la conexión: valor básico del tiempo
de espera hasta el próximo intento de establecer un enlace
después de fallar el presente. Cada 3 intentos se duplica el
valor básico, hasta 900 s como máximo. Rango de valores:
10...600 s.
Ejemplo: un valor básico de 20 da los siguientes intervalos
de llamada: tres veces 20 s, tres veces 40 s, tres veces 80
s, etc. hasta un máximo de 900 s.
Si se ha configurado un segundo servidor de Telecontrol /
router, en el cuarto intento el CP tratará de conectarse con
el segundo interlocutor. Si tampoco puede conectarse al
segundo interlocutor, el CP intenta en el 7.º intento volver
a conectarse con el primer interlocutor.
Sin relevancia para conexiones SMS

Bloque para el área de parámetros "Autorización de alarma"
Tabla 4-128 IF_CONF_WakeupList
Parámetro

Tipo de datos

Valor inicial

Descripción

Id

UINT

13

Identificación del bloque de parámetros

Length

UINT

Tamaño del bloque de parámetros en bytes: 246

Mode

UINT

Validez (1: permanente, 2: temporal)

WakeupPhone [1...10]

ARRAY
[1...10] of
STRING [22]

Número de llamada del dispositivo autorizado como des‐
pertador
El asterisco (*) al final de un número de abonado sirve de
comodín para números con extensiones.

Bloque para el área de parámetros "Redes GSM preferentes"
Tabla 4-129 IF_CONF_PrefProvider
Parámetro

Tipo de datos

Valor inicial

Descripción

Id

UINT

14

Identificación del bloque de parámetros

Length

UINT

Programación del PLC
Manual de programación y manejo, 11/2019

Tamaño del bloque de parámetros en bytes: 46

4427

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de datos

Mode

UINT

Valor inicial

Validez (1: permanente, 2: temporal)

Descripción

Provider [1...5]

ARRAY [1...5]
of STRING [6]

Redes GSM alternativas con prioridad 1 a 5, a las que se
conecta el CP de forma preferente. Es posible configurar 5
redes como máximo. La n.º 1 tiene la máxima prioridad y la
n.º 5 la mínima.
Entrada del Public Land Mobile Network (PLMN) del ope‐
rador de red, consistente en Mobile Country Code (MCC) y
Mobile Network Code (MNC).
Ejemplo (red de pruebas de Siemens AG): 26276

Bloque para el área de parámetros "Configuración DNS"
El SDT solo puede utilizarse en el CP 1242‑7 (6GK7 242‑7KX30‑0XE0) en tiempo de ejecución
con fines de configuración.
Tabla 4-130 IF_CONF_DNS
Parámetro

Tipo de datos

Valor inicial

Descripción

Id

UINT

16

Identificación del bloque de parámetros

Length

UINT

Tamaño del bloque de parámetros en bytes: 14

Mode

UINT

Validez (1: permanente, 2: temporal)

DNS_IP [1]

IP_V4

Dirección IP del 1.er servidor Domain Name System

DNS_IP [2]

IP_V4

Dirección IP del 2.º servidor Domain Name System

Bloque para el área de parámetros "Sincronización horaria"
El SDT solo puede utilizarse en el CP 1242‑7 (6GK7 242‑7KX30‑0XE0) en tiempo de ejecución
con fines de configuración.
Tabla 4-131 IF_CONF_NTP
Parámetro

Tipo de datos

Valor inicial

Descripción

Id

UINT

17

Identificación del bloque de parámetros

Length

UINT

Tamaño del bloque de parámetros en bytes: 24

Mode

UINT

Validez (1: permanente, 2: temporal)

NTP_IP [1]

ARRAY [1...4]
of IP_V4

Dirección IP del servidor NTP 1

...

...

(dirección IP del servidor NTP 2...3)

NTP_IP [4]

ARRAY [1...4]
of IP_V4

Dirección IP del servidor NTP 4

Bloque para activar / desactivar usuarios de TeleService
El SDT solo puede utilizarse en el CP 1242‑7 (6GK7 242‑7KX30‑0XE0) en tiempo de ejecución
con fines de configuración.

4428

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
SDT para activar o desactivar usuarios de TeleService que ya se han configurado en el
proyecto STEP 7 del CP. En STEP 7, los datos correspondientes se encuentran en el área de
parámetros "Configuración TeleService" > "Administración de usuarios de TeleService".
Tabla 4-132 IF_CONF_GPRS_UserList
Parámetro

Tipo de datos

Valor inicial

Descripción

Id

UINT

19

Identificación del bloque de parámetros

Length

UINT

Tamaño del bloque de parámetros en bytes: 506

Mode

UINT

Validez (1: permanente, 2: temporal)

GPRS_User [1...10]

ARRAY
[1...10] of
GPRS_User

Usuarios de TeleService de n.º 1 a n.º 10 como máximo

La matriz se forma a partir de los juegos de parámetros para los usuarios de TeleService
("GPRS_User" [1...n]).
Tabla 4-133 GPRS_User [n] (parámetro para usuarios de TeleService)
Parámetro

Tipo de datos

Valor inicial

Descripción

UserName [n]

STRING [22]

Nombre de usuario de TeleService

Password [n]

STRING [22]

- El string tiene que estar vacío -

Diag_Allowed [n]

BOOL

- Reservado - (no parametrizable)

Teleserv_Allowed [n]

BOOL

Activación del usuario de TeleService
● 0 = usuario desactivado
● 1 = usuario activado

FW_Load_Allowed [n]

BOOL

- Reservado - (no parametrizable)

Bloque para la parametrización del acceso TeleService (Nombre DNS del servidor)
Datos de acceso del servidor de TeleService (centralita).
En STEP 7, los datos correspondientes se encuentran en el área de parámetros
"Configuración TeleService".
Si hay dos servidores de TeleService, utilice el bloque una vez por servidor.
Tabla 4-134 IF_CONF_TS_Name
Tipo de datos

Valor inicial

Id

UINT

20

Length

UINT

Tamaño del bloque de parámetros en bytes: 266

Mode

UINT

Validez (1: permanente, 2: temporal)

ts_name

String [254]

Nombre del servidor de TeleService que puede resolverse
mediante DNS

Parámetro

Descripción
Identificación del bloque de parámetros

RemotePort

UINT

Puerto de la estación de ingeniería

Rank

UINT

Prioridad del servidor [1] o [2]
1 = servidor 1, 2 = servidor 2

Programación del PLC
Manual de programación y manejo, 11/2019

4429

Instrucciones
4.1 Instrucciones

Bloque para la parametrización del acceso TeleService (dirección IP del servidor)
Datos de acceso del servidor de TeleService (centralita).
En STEP 7, los datos correspondientes se encuentran en el área de parámetros
"Configuración TeleService".
Si hay dos servidores de TeleService, utilice el bloque una vez por servidor.
Tabla 4-135 IF_CONF_TS_IF_V4
Parámetro

Tipo de datos

Valor inicial
21

Descripción

Id

UINT

Length

UINT

Tamaño del bloque de parámetros en bytes: 14

Identificación del bloque de parámetros

Mode

UINT

Validez (1: permanente, 2: temporal)

RemoteAddress

IP_V4

Dirección IP del servidor de TeleService

RemotePort

UINT

Puerto del servidor de TeleService

Rank

UINT

Prioridad del servidor [1] o [2]
1 = servidor 1, 2 = servidor 2

CM/CP S7-1500
Industrial Ethernet
Instrucciones para servicios FTP
FTP_CMD para servicios FTP
Panorámica de FTP_CMD
Significado
Con la instrucción FTP_CMD se pueden establecer conexiones FTP y transmitir archivos
desde y a un servidor FTP.
Nota
Versiones de los bloques
En una estación la versión V2.x del FTP_CMD solo puede utilizarse en combinación con una
CPU V2.x y un CP V2.x.
En cuanto la estación contiene una CPU V1.x o un CP V1.x, hay que utilizar el FTP_CMD en
la versión anterior V1.x (por ejemplo V1.4). Cambie para ello la versión de la librería
"SIMATIC NET CP" a V3.4. Entonces podrá seleccionar una versión anterior del bloque.

4430

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La transferencia de datos se puede realizar vía FTP o FTPS (conexiones SSL seguras).
Nota
FTPS: sincronizar certificados
FTPS requiere la sincronización de los certificados entre el servidor FTP y el cliente FTP. Si el
servidor FTP se configura fuera del proyecto STEP 7 del cliente FTP, habrá que importar el
certificado del servidor FTP. En el administrador de certificados importe el certificado del
servidor FTP como certificado de confianza.

Funcionamiento
La instrucción FTP_CMD hace referencia a un bloque de petición (ARG) en el que se
especifica el comando FTP. Según sea el tipo de comando FTP (CMD), este bloque de petición
utiliza diferentes estructuras de datos para la parametrización. Para dichas estructuras están
disponibles en cada caso los tipos de datos adecuados (UDT).
La figura siguiente ilustra la estructura de llamada:
)73B&0'
%ORTXHGHSHWLFLµQ
&0'
$5*

)LOH'%

)73B),/(1$0(B

(QFDEH]DGR

)73B&211(&7B
'DWRV

Bloques de petición
Para los bloques de petición se utilizan las siguientes estructuras de datos:
● Establecimiento de la conexión
Para establecer la conexión están disponibles diferentes estructuras de datos para los
siguientes tipos de acceso:
– FTP_CONNECT_IPV4: Establecimiento de la conexión con direcciones IP según IPv4
– FTP_CONNECT_IPV6: Establecimiento de la conexión con direcciones IP según IPv6
– FTP_CONNECT_NAME: Establecimiento de la conexión con nombres de servidor
(DNS)
● Transferencia de datos
Para la transferencia de datos están disponibles dos estructuras de datos distintas:
– FTP_FILENAME: Estructura de datos para el acceso a un archivo completo
– FTP_FILENAME_PART: Estructura de datos para el acceso de lectura a un área de
datos

Programación del PLC
Manual de programación y manejo, 11/2019

4431

Instrucciones
4.1 Instrucciones

Transferencia de datos en el File-DB
Los datos se transfieren mediante bloques que contienen un encabezado para datos de
petición y el área de datos de usuario. El bloque de datos se indica en el búfer de peticiones.

Requisitos en la configuración de la CPU
Utilice los ajustes siguientes para permitir el acceso FTP:
● En todos los bloques de datos utilizados como File-DB desactive el atributo "Acceso
optimizado al bloque".
● Solo en caso de utilizar una CPU V1.x y un CP V1.1.x:
en los datos de configuración de la CPU, en "Propiedades > General > Propiedades"
desactive la opción "Desactivar comunicación PUT/GET" (PUT/GET debe estar habilitado).

Validez
La instrucción FTP_CMD se puede utilizar en combinación con los siguientes tipos de módulos:
● CP 1543‑1
● CP 1545‑1

Interfaz de llamada
Interfaz de llamada en representación FUP
)73B&0'
%22/

5(4

'21(

%22/

:25'

,'

%86<

%22/

%<7(

&0'

(5525

%22/

67$786

:25'

9$5,$17

$5*

9$5,$17

Consulte también
Parámetros de salida e informaciones de estado FTP_CMD (Página 4440)
Parámetros de entrada FTP_CMD (Página 4433)
Estructura de los bloques de datos (File-DB) para servicios FTP - modo FTP-Client
(Página 4443)

4432

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros de entrada FTP_CMD
Explicación de los parámetros de entrada
Deben suministrarse los siguientes parámetros de entrada a la instrucción FTP_CMD:
Tabla 4-136 Parámetros formales de la instrucción FTP_CMD - parámetros de entrada
Parámetro

Declaración

Tipo de datos

Área de memoria

Significado / Observación

REQ

Input

BOOL

E, A, M, DB, L

Inicia la petición de emisión con un flanco as‐
cendente.

ID *

INPUT

INT

1, 2 ... 64

Las peticiones de FTP se desarrollan a través
de conexiones FTP. El parámetro identifica la
conexión utilizada.

CMD *

INPUT

BYTE

Consulte la tabla si‐ Comando FTP que debe ejecutarse al llamar
guiente "Comandos". la instrucción. Encontrará los rangos de valo‐
res para los tipos de comandos FTP a conti‐
nuación de la tabla.
El comando FTP indicado aquí debe indicarse
de forma idéntica en el bloque de petición (pa‐
rámetro ARG).
Si un comando no es compatible con el firm‐
ware del CP, se emite un mensaje de error con
STATUS = 8F6BH.

ARG *

INPUT

VARIANT

Consulte la tabla si‐ Bloque de petición
guiente "Comandos". Hace referencia al área de datos con los pará‐
metros de ejecución adecuados para el co‐
mando FTP.
En función del comando FTP se utilizan tipos
de datos específicos (UDT). Los UDT se indi‐
can del siguiente modo.
El tipo de datos ANY no está permitido para el
puntero que debe especificarse aquí.

* Los valores de los parámetros de entrada "ID" y "CMD" sobrescriben el valor del parámetro de entrada "ARG".

Programación del PLC
Manual de programación y manejo, 11/2019

4433

Instrucciones
4.1 Instrucciones

Comandos FTP en el parámetro "CMD"
Consulte en la tabla siguiente qué significado tienen los comandos del parámetro "CMD" y qué
UDTs se utilizan para abastecer a los bloques de petición.
Tabla 4-137 Tipos de comando
CMD (tipo de comando) Bloques de petición rele‐
vantes / UDT

Significado / Manejo

0 (NOOP)

*

El FB llamado no ejecuta ninguna acción. Las indicaciones de estado
se ponen como sigue para este abastecimiento de parámetros:

1 (CONNECT)

FTP_CONNECT_IPV4

Establecimiento de la conexión FTP

FTP_CONNECT_IPV6

El cliente FTP establece con este comando una conexión FTP con un
servidor FTP (puerto 21).

DONE=1; ERROR=0; STATUS=0

FTP_CONNECT_NAME

2 (STORE)

FTP_FILENAME

La conexión está disponible, con la ID de conexión aquí asignada, para
todos los demás comandos FTP. Los datos se intercambian entonces
con el servidor FTP indicado para este usuario.
Con esta llamada de función se transmite un bloque de datos (File-DB)
del cliente FTP (CPU S7) al servidor FTP.
Atención: Si el archivo (File-DB) ya existe en el servidor FTP, se so‐
brescribe.

3 (RETRIEVE)

FTP_FILENAME

Con esta llamada de función se transmite un archivo del servidor FTP
al cliente FTP (CPU S7).
Atención: Si el bloque de datos (File-DB) del cliente FTP ya contiene
un archivo, este se sobrescribe.

4 (DELETE)

FTP_FILENAME

Con esta llamada de función se borra un archivo en el servidor FTP.

5 (QUIT)

*

Con esta llamada de función se deshace la conexión FTP indicada en
"ID".

6 (APPEND)

FTP_FILENAME

De forma similar a "STORE", el comando "APPEND" (añadir) guarda
un archivo en el servidor FTP. Pero con "APPEND" no se sobrescribe
el archivo en el servidor FTP, sino que el nuevo contenido a guardar se
añade al archivo.
Si el archivo no existe en el servidor FTP, se crea.

7 (RETR_PART)

FTP_FILENAME_PART

Con el comando "RETR_PART" (leer longitud parcial) se puede pedir
del servidor FTP una parte de un archivo.
En caso de archivos muy grandes se puede limitar así la lectura a la
parte necesaria.
Para esto se tiene que conocer la estructura del archivo.
Indique la parte deseada del archivo con ayuda de los dos parámetros
"OFFSET" y "LEN" en el FB 40.

* En los tipos de comando 0 (NOOP) y 5 (QUIT) debe indicarse un bloque de petición cualquiera (UDT). Dicho bloque no se
evaluará.

Consulte también
Panorámica de FTP_CMD (Página 4430)

4434

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Bloques de petición para FTP_CMD
Significado
La instrucción FTP_CMD se abastece con un bloque de petición a través del parámetro ARG.
La estructura depende del tipo de comando FTP. Al utilizar los tipos de datos especificados
(UDT), la instrucción reconoce el tipo del bloque de petición. A continuación se indican los tipos
de datos (UDT) correspondientes a los siguientes bloques de petición:
● Establecimiento de la conexión FTP con dirección IP según IPv4
● Establecimiento de la conexión FTP con dirección IP según IPv6
● Establecimiento de la conexión FTP con nombre de servidor
● Acceso de escritura y lectura así como otros comandos FTP
● Comando FTP RETR_PART

Bloque de petición para establecimiento de la conexión FTP con dirección IP según IPv4
Para el establecimiento de la conexión FTP con dirección IP según IPv4 se utiliza la siguiente
estructura de datos.
Tabla 4-138 FTP_CONNECT_IPV4
Parámetro
InterfaceID

Tipo

Rango de valores

HW_ANY

Significado / Observación
Dirección inicial del módulo
Al llamar una instrucción se transfiere en el parámetro
LADDR la dirección inicial de módulo del CP.
La dirección inicial de módulo del CP puede consultarse en
la configuración del CP en: "Propiedades>Direcciones>En‐
tradas"

ID

CONN_OUC

1, 2...64

Las peticiones de FTP se desarrollan a través de conexio‐
nes FTP. El parámetro identifica la conexión utilizada.

ConnectionType

BYTE

0

Tipo de conexión "FTP"

ActiveEstablishment BOOL

TRUE

TRUE = iniciativa local

FTPCmd

1

Comando FTP "CONNECT"

BYTE

Comando FTP que se ejecutará al llamar la instrucción. En‐
contrará los rangos de valores para los tipos de comandos
en el capítulo Parámetros de entrada FTP_CMD (Pági‐
na 4433).
Nota:
El comando FTP indicado aquí debe indicarse de forma
idéntica en el parámetro de entrada CMD.
CertIndex

BYTE

0 = FTP

Elija o bien el tipo de protocolo FTP, o bien FTPS.

1 = FTPS

Nota para FTPS:
Si el servidor FTP se configura fuera del proyecto STEP 7
del cliente FTP, habrá que importar el certificado del servidor
FTP.

UserName

STRING[32]

Programación del PLC
Manual de programación y manejo, 11/2019

’benutzer’

Nombre del usuario para iniciar sesión en el servidor FTP

4435

Instrucciones
4.1 Instrucciones
Parámetro

Tipo

Rango de valores

Significado / Observación

Password

STRING[32]

’passwort’

Contraseña para iniciar sesión en el servidor FTP

FTPserverIPaddr

IP_V4

ADDR(1) ...
ADDR(4)

Dirección IP del servidor FTP como Array[1..4] of Byte, en la
que cada byte especifica 1 bloque de la dirección.
Ejemplo: ADDR(1) especifica el primer bloque de dirección
(el primer byte de la dirección).

Bloque de petición para establecimiento de la conexión FTP con dirección IP según IPv6
Para el establecimiento de la conexión FTP con dirección IP según IPv6 se utiliza la siguiente
estructura de datos.
Tabla 4-139 FTP_CONNECT_IPV6
Parámetro
InterfaceID

Tipo

Rango de valores

HW_ANY

Significado / Observación
Dirección inicial del módulo
Al llamar una instrucción se transfiere en el parámetro
LADDR la dirección inicial de módulo del CP.
La dirección inicial de módulo del CP puede consultarse en
la configuración del CP en: "Propiedades>Direcciones>En‐
tradas"

ID

CONN_OUC

1, 2...64

Las peticiones de FTP se desarrollan a través de conexio‐
nes FTP. El parámetro identifica la conexión utilizada.

ConnectionType

BYTE

0

Tipo de conexión "FTP"

ActiveEstablishment BOOL

TRUE

TRUE = iniciativa local

FTPCmd

1

Comando FTP "CONNECT"

BYTE

Comando FTP que se ejecutará al llamar la instrucción. En‐
contrará los rangos de valores para los tipos de comandos
en el capítulo Parámetros de entrada FTP_CMD (Pági‐
na 4433).
Nota:
El comando FTP indicado aquí debe indicarse de forma
idéntica en el parámetro de entrada CMD.
CertIndex

BYTE

0 = FTP

Elija o bien el tipo de protocolo FTP, o bien FTPS.

1 = FTPS

Nota para FTPS:
Si el servidor FTP se configura fuera del proyecto STEP 7
del cliente FTP, habrá que importar el certificado del servidor
FTP.

UserName

STRING[32]

’usuario’

Nombre del usuario para iniciar sesión en el servidor FTP

Password

STRING[32]

’contraseña’

Contraseña para iniciar sesión en el servidor FTP

FTPserverIPaddr

IP_V6

ADDR(1) ...
ADDR(16)

Dirección IP del servidor FTP como Array[1..16] of Byte, en
la que cada 2 bytes especifican un bloque de la dirección.
Ejemplo: ADDR(1) + ADDR(2) especifican el primer bloque
de dirección.

4436

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Bloque de petición para establecimiento de la conexión FTP con nombre de servidor
Para el establecimiento de la conexión FTP indicando un nombre de servidor se utiliza la
siguiente estructura de datos. El nombre de servidor se asigna a una dirección IP mediante
DNS.
Tabla 4-140 FTP_CONNECT_NAME
Parámetro
InterfaceID

Tipo

Rango de valores

HW_ANY

Significado / Observación
Dirección inicial del módulo
Al llamar una instrucción se transfiere en el parámetro
LADDR la dirección inicial de módulo del CP.
La dirección inicial de módulo del CP puede consultarse en
la configuración del CP en: "Propiedades>Direcciones>En‐
tradas"

ID

CONN_OUC

1, 2...64

Las peticiones de FTP se desarrollan a través de conexio‐
nes FTP. El parámetro identifica la conexión utilizada.

ConnectionType

BYTE

0

Tipo de conexión "FTP"

ActiveEstablishment BOOL

TRUE

TRUE = iniciativa local

FTPcmd

1

Comando FTP "CONNECT"

BYTE

Comando FTP que se ejecutará al llamar la instrucción. En‐
contrará los rangos de valores para los tipos de comandos
en el capítulo Parámetros de entrada FTP_CMD (Pági‐
na 4433).
Nota:
El comando FTP indicado aquí debe indicarse de forma
idéntica en el parámetro de entrada CMD.
CertIndex

BYTE

0 = FTP

Elija o bien el tipo de protocolo FTP, o bien FTPS.

1 = FTPS

Nota para FTPS:
Si el servidor FTP se configura fuera del proyecto STEP 7
del cliente FTP, habrá que importar el certificado del servidor
FTP.

UserName

STRING[32]

’benutzer’

Nombre del usuario para iniciar sesión en el servidor FTP

Password

STRING[32]

’passwort’

Contraseña para iniciar sesión en el servidor FTP

FTPserverName

STRING[254]

Programación del PLC
Manual de programación y manejo, 11/2019

Dirección IP del servidor FTP

4437

Instrucciones
4.1 Instrucciones

Bloque de petición para acceso de escritura y lectura así como otros comandos FTP
Para los comandos FTP store, retrieve, delete y append se utiliza la siguiente estructura de
datos.
Tabla 4-141 FTP_FILENAME
Parámetro
InterfaceID

Tipo

Rango de valores

HW_ANY

Significado / Observación
Dirección inicial del módulo
Al llamar una instrucción se transfiere en el parámetro
LADDR la dirección inicial de módulo del CP.
La dirección inicial de módulo del CP puede consultarse en
la configuración del CP en: "Propiedades>Direcciones>En‐
tradas"

ID

CONN_OUC

1, 2...64

Las peticiones de FTP se desarrollan a través de conexio‐
nes FTP. El parámetro identifica la conexión utilizada.

ConnectionType

BYTE

0

Tipo de conexión "FTP"

ActiveEstablishment BOOL

TRUE

TRUE = iniciativa local

FTPcmd

2, 3, 4, 6

Comando FTP "STORE / RETRIEVE / DELETE / APPEND"

BYTE

Comando FTP que se ejecutará al llamar la instrucción. En‐
contrará los rangos de valores para los tipos de comandos
en el capítulo Parámetros de entrada FTP_CMD (Pági‐
na 4433).
Nota:
El comando FTP indicado aquí debe indicarse de forma
idéntica en el parámetro de entrada CMD.
CertIndex

BYTE

0 = FTP

Elija o bien el tipo de protocolo FTP, o bien FTPS.

1 = FTPS

Nota para FTPS:
Si el servidor FTP se configura fuera del proyecto STEP 7
del cliente FTP, habrá que importar el certificado del servidor
FTP.

DataBlockNumber

UINT

LenFilename

UINT

El bloque de datos aquí indicado contiene el File-DB que se
debe leer / escribir.
0...1000

El parámetro "LenFilename" que indica la longitud total del
nombre de archivo no se evalúa.
En su lugar se evalúa la longitud indicada en el string del
parámetro "Filename".

Filename

4438

ARRAY[0..3] OF
STRING[254]

Nombre del archivo de origen o destino.
Los cuatro strings del nombre de archivo se encadenan y se
transfieren al servidor como un solo string completo.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Bloque de petición para el comando FTP RETR_PART
Para el comando FTP RETR_PART se utiliza la siguiente estructura de datos.
Tabla 4-142 FTP_FILENAME_PART
Parámetro
InterfaceID

Tipo

Rango de valores

HW_ANY

Significado / Observación
Dirección inicial del módulo
Al llamar una instrucción se transfiere en el parámetro
LADDR la dirección inicial de módulo del CP.
La dirección inicial de módulo del CP puede consultarse en
la configuración del CP en: "Propiedades>Direcciones>En‐
tradas"

ID

CONN_OUC

1, 2...64

Las peticiones de FTP se desarrollan a través de conexio‐
nes FTP. El parámetro identifica la conexión utilizada.

ConnectionType

BYTE

0

Tipo de conexión "FTP"

ActiveEstablishment BOOL

TRUE

TRUE = iniciativa local

FTPcmd

7

Comando FTP "RETR_PART"

BYTE

Comando FTP que se ejecutará al llamar la instrucción. En‐
contrará los rangos de valores para los tipos de comandos
en el capítulo Parámetros de entrada FTP_CMD (Pági‐
na 4433).
El comando FTP indicado aquí debe indicarse de forma
idéntica en el parámetro de entrada CMD.
CertIndex

BYTE

0 = FTP

Elija o bien el tipo de protocolo FTP, o bien FTPS.

1 = FTPS

Nota para FTPS: Si el servidor FTP se configura fuera del
proyecto STEP 7 del cliente FTP, habrá que importar el cer‐
tificado del servidor FTP.

Offset

DWORD

Offset en bytes, a partir del cual se debe leer el archivo.

Length

DWORD

Longitud parcial en bytes que se debe leer a partir del valor
indicado en "OFFSET".
Peculiaridades:
● Si se indica "DW#16#FFFFFFFF" se lee el resto
disponible del archivo.
Resultado OK (DONE = 1, STATUS = 0), si no se
presenta ningún otro error.
● Si OFFSET > longitud del archivo original:
Longitud del archivo de destino (ACT_LENGTH en el
File-DB): 0 bytes en la CPU.
Resultado OK (DONE = 1, STATUS = 0), si no se
presenta ningún otro error.
● Si OFFSET + LEN > longitud del archivo original (y LEN
≠ 0xFFFFFFFF):
Longitud del archivo de destino (ACT_LENGTH en el
File-DB): Bytes disponibles a partir de "OFFSET".
Resultado OK (DONE = 1, STATUS = 0), si no se presenta
ningún otro error.

DataBlockNumber

UINT

Programación del PLC
Manual de programación y manejo, 11/2019

El bloque de datos aquí indicado contiene el File-DB que se
debe leer / escribir.

4439

Instrucciones
4.1 Instrucciones
Parámetro

Tipo

LenFilename

Rango de valores

UINT

0...1000

Significado / Observación
El parámetro "LenFilename" que indica la longitud total del
nombre de archivo no se evalúa.
En su lugar se evalúa la longitud indicada en el string del
parámetro "Filename".

Filename

ARRAY[0..3] OF
STRING[254]

Nombre del archivo de origen o destino.

Consulte también
Panorámica de FTP_CMD (Página 4430)

Parámetros de salida e informaciones de estado FTP_CMD
Parámetros BUSY, DONE y ERROR
El estado de ejecución se controla con los parámetros BUSY, DONE, ERROR y STATUS. El
parámetro BUSY muestra el estado de procesamiento. Con el parámetro DONE se controla si
una petición se ha ejecutado correctamente. El parámetro ERROR se activa cuando se
producen errores durante la ejecución de "FTP_CMD". La información se error se visualiza en
el parámetro STATUS.
La tabla siguiente muestra la relación entre los parámetros BUSY, DONE y ERROR:
BUSY

DONE

ERROR

Descripción

1

-

-

La petición se procesa.

0

1

0

La petición se ha llevado a cabo correctamente.

0

0

1

La petición ha finalizado con un error. La causa del error se indica en el parámetro STA‐
TUS.

0

0

0

No se ha asignado ninguna petición nueva.

Evaluar indicaciones de estados
Nota
Evaluación
● Evaluación si BUSY = 0
No evalúe los indicadores de estado hasta que BUSY = 0.
● Estado 8FxxH
Para las entradas con el estado 8FxxH, tenga también en cuenta lo indicado en el manual
de referencia STEP 7 Funciones estándar y funciones del sistema. Allí encontrará
informaciones en el capítulo "Evaluación de fallos con el parámetro de salida RET_VAL".

4440

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-143 FTP_CMD: Significado del parámetro STATUS en relación con DONE y ERROR
DONE

ERROR

STATUS

Significado

0

0

0000H

No hay ninguna petición en proceso.

1

0

0000H

La petición ha terminado sin errores.

0

0

7001H

La petición ha sido lanzada por primera vez.

0

0

7002H

La petición aún está en curso.

0

1

80C4H

Error de comunicación (se presenta temporalmente; por ello es conve‐
niente una repetición en el programa de usuario).

0

1

8183H

La configuración no es acorde con los parámetros de la petición.

0

1

8401H

Error desconocido
Causas posibles:
● En la conexión se detectó un timeout.
● El servidor FTP canceló la conexión.
Solución: Enviar los comandos QUIT y CONNECT para volver a crear la
conexión.

0

1

8402H

Estado de la conexión incorrecto.
Es posible que se haya excedido el timeout de la conexión o el servidor
FTP puede haber deshecho la conexión.
Solución: Enviar nuevamente los comandos QUIT y CONNECT para
volver a establecer la conexión.

0

1

8403H

Error al iniciar sesión.

0

1

8404H

Servidor FTP no accesible.

0

1

8405H

Error en la transferencia.

0

1

8406H

Timeout en la operación actual

0

1

8407H

No se ha encontrado el archivo en el servidor FTP.

0

1

8408H

No es posible transferir.

0

1

8409H

No se ha podido recuperar el archivo.

0

1

8410H

Error el activar el puerto TCP para la conexión de datos.

0

1

8411H

La indicación de offset no concuerda.

0

1

8412H

Error al cambiar la indicación de directorio

0

1

8413H

Error al recibir datos

0

1

8414H

Error al enviar datos.

0

1

8415H

El cliente ha rechazado la indicación CMD (tipo de comando).

0

1

8416H

El servidor FTP ha cerrado la conexión.

0

1

8418H

Error en los datos de usuario.
Posibles causas:
● El nombre del archivo está vacío.
● La longitud de datos es "0".
● etc.

0

1

8419H

No hay recursos de socket para abrir una conexión de datos.

0

1

8420H

No hay recursos de socket para abrir una conexión de control.

0

1

8421H

Error al abrir el File-DB que debe leerse.

0

1

8422H

Error al abrir el File-DB que debe escribirse.

0

1

8423H

Error al establecer la conexión con el servidor FTP.

Programación del PLC
Manual de programación y manejo, 11/2019

4441

Instrucciones
4.1 Instrucciones
DONE

ERROR

STATUS

Significado

0

1

8424H

Error interno

0

1

8425H

Error de formato en el nombre del dominio

0

1

8426H

Hay demasiadas peticione DNS.

0

1

8427H

El servidor DNS indicado no ha podido asignar el nombre de dominio
especificado.

0

1

8428H

No hay ningún recurso de conexión disponible.

0

1

8429H

ID de canal desconocida

0

1

8430H

El File-DB es demasiado corto.

0

1

8431H

Error al escribir en el File-DB.

0

1

8432H

Error al leer del File-DB.

0

1

8433H

Error al acceder al File-DB.

0

1

8434H

Acción cancelada.

0

1

8435H

Se reseteará el canal.

0

1

8436H

Respuesta inesperada del servidor

0

1

8437H

No se ha podido verificar el certificado.

0

1

8438H

Se ha producido un error desconocido.

0

1

8439H

El comando FTP causa un error. La causa debe buscarse en el servidor
FTP (comando REST).

0

1

8440H

El servidor FTP no soporta el protocolo SSL exigido.

0

1

8446H

Después de enviar la contraseña FTP al servidor FTP, éste devolvió un
código inesperado.

0

1

8451H

Al intentar cambiar el modo de transmisión de binario a ASCII, se notificó
un error.

0

1

8455H

Error en una petición de memorización en el CM/CP.

0

1

8460H

Ha surgido un problema en la gestión de SSL/TLS.

0

1

8469H

Error de interfaz
No se ha podido utilizar la interfaz de salida especificada.
Solución:
Indique qué interfaz debe utilizarse para las conexiones salientes.

0

1

8475H

El certificapdo SSL o el SSH md5 fingerprint no se consideran de con‐
fianza.

0

1

8476H

El servidor FTP no ha recibido nada. En el estado actual debe contarse
con un comportamiento erróneo.

0

1

8477H

No se encontró el "Crypto engine" (módulo criptográfico) indicado.

0

1

8478H

Se produjo un error al configurar como estándar el "Crypto engine" SSL
(módulo criptográfico) seleccionado.

0

1

8480H

Ha surgido un problema con el certificado del cliente FTP.

0

1

8481H

No se pudo utilizar la cifra indicada.

0

1

8482H

El servidor FTP utiliza una codificación que no está soportada.

0

1

8484H

Se ha excedido el tamaño máximo del archivo.

0

1

8485H

El File-DB ha sido modificado durante el envío o su estructura no es
correcta.

0

1

8489H

No se han podido enviar los datos. No hay suficiente memoria disponible
para la operación en el servidor FTP.

0

1

8492H

El archivo ya existe. El archivo no se sobrescribe.

4442

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
DONE

ERROR

STATUS

Significado

0

1

8496H

Ha surgido un problema al leer el certificado CA SSL.

0

1

8497H

Se ha producido un error inesperado en la sesión SSH.

0

1

8498H

No se pudo deshacer la conexión SSL.

0

1

8499H

El socket no está listo para enviar/recibir. Espere hasta que haya señal
de disponibilidad y vuélvalo a intentar.

0

1

8501H

Error en la comprobación del certificado SSL por el servidor FTP.

0

1

8507H

Durante la sesión FTP activa se ha producido un timeout al establecer la
conexión y esperar al servidor FTP.

0

1

8F54H

El bit "EXIST" del encabezado del File-DB no está activado.

0

1

8F55H

Bit de estado del encabezado: Locked

0

1

8F56H

El bit NEW en el encabezado del File-DB no se ha desactivado

0

1

8F6BH

Posibles causas:
● Valor incorrecto para el parámetro CMD
Se permiten valores entre 0 y 15.
● Un comando del FB 40 no es compatible.
Posible causa: Firmware incorrecto del CP
Solución: Actualización del firmware (en el caso de CPs menos
recientes, utilizar en lugar del FB 40 las funciones FC 40...FC 44.)

0

1

8F7FH

Error interno, p. ej., referencia ANY no permitida.

Consulte también
Panorámica de FTP_CMD (Página 4430)

Estructura y uso del File-DB - Modo cliente FTP
Estructura de los bloques de datos (File-DB) para servicios FTP - modo FTP-Client
Funcionamiento
Para la transmisión de datos mediante FTP hay que crear bloques de datos (File-DBs) en la
CPU de la estación S7. Dichos bloques de datos han de tener una determinada estructura para
que los servicios FTP puedan tratarlos como archivos transmisibles. Constan de los siguientes
sectores:
● Sector 1: encabezado del File-DB (tiene una estructura fija con una longitud de 20 byte)
● Sector 2: Datos de usuario como "Array [..] of Byte" o "Array [..] of Char" (de longitud y
estructura variable)

Programación del PLC
Manual de programación y manejo, 11/2019

4443

Instrucciones
4.1 Instrucciones

Requisitos en la configuración de la CPU
CP 1543‑1 con versión de firmware < V2
Utilice los ajustes siguientes para permitir el acceso FTP:
● En los datos de configuración de la CPU, en "Propiedades > General > Protección":
desactive la opción "Desactivar comunicación PUT/GET".
● En todos los bloques de datos utilizados como File-DB desactive el atributo "Acceso
optimizado al bloque".
Estos ajustes ya no son necesarios para el CP 1543‑1 a partir de la versión de firmware V2.

Encabezado del File-DB para modo cliente FTP
El encabezado del File-DB aquí descrito es idéntico al encabezado del File-DB descrito para
el modo de servidor.
Parámetro
EXIST

Tipo
BOOL

Valor / Significado

Alimentación

El bit EXIST indica si hay datos vá‐ El comando FTP "DELETE" pone
lidos en el área de datos de usua‐ EXIST=0.
rio.
El comando FTP "STORE" pone EXIST=1.
El comando FTP retrieve solo pro‐
cesa la petición si EXIST=1.
● 0: el File-DB no contiene datos
de usuario válidos (el archivo
no existe).
● 1: el File-DB contiene datos de
usuario válidos (el archivo
existe).

LOCKED

BOOL

Los comandos FTP "STORE" y "RETRIE‐
VE" ponen LOCKED=1 durante la edición
● 0: se puede acceder al File-DB. si el bit estaba antes en 0.
El programa de usuario almacenado en la
● 1: el File-DB está bloqueado.
CPU S7 también puede activar o desacti‐
var LOCKED para asegurar la coherencia
durante un acceso de escritura.
El bit LOCKED sirve para la pro‐
tección de acceso al File-DB.

Con ello se consigue garantizar un blo‐
queo mutuo entre el programa de usuario
y el proceso FTP para asegurar la cohe‐
rencia.
Procedimiento recomendado para el pro‐
grama de usuario:
1. Comprobar el bit LOCKED (si = 0)
2. Poner el bit WRITEACCESS=0
3. Comprobar el bit LOCKED (si = 0)
4. Poner el bit LOCKED=1
5. Escribir datos
6. Poner el bit LOCKED=0

4444

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Tipo

NEW

BOOL

Valor / Significado

Alimentación

El bit NEW informa sobre si los da‐ El comando FTP store pone NEW=1 tras
tos se han modificado desde la úl‐ la edición
tima operación de lectura.
El programa de usuario de la CPU S7 de‐
● 0: el contenido del File-DB no be poner NEW=0 tras la lectura de los da‐
tos para permitir un nuevo comando "RE‐
ha cambiado desde la última
TRIEVE".
operación de escritura. El
programa de usuario de la
CPU S7 ha registrado el último
cambio.
● 1: el programa de usuario de la
CPU S7 no ha registrado la
última operación de escritura.

WRITE_ACCESS

BOOL

● 0: El programa de usuario
tiene derecho de escritura
para los File-DBs de la CPU
S7.
● 1: El programa de usuario no
tiene derecho de escritura
para los File-DBs de la CPU
S7.

El bit se pone a un valor de inicialización al
configurar el DB.
Recomendación:
A ser posible, el bit debería dejarse inalte‐
rado. En caso especiales es posible una
adaptación durante el funcionamiento.

ACT_LENGTH

DINT

Longitud actual del área de datos
de usuario.
El contenido de este campo solo
es válido si EXIST = 1.

La longitud actual se actualiza después de
una operación de escritura.

MAX_LENGTH

DINT

Longitud máxima del área de da‐
tos de usuario (longitud total del
DB menos 20 bytes del encabeza‐
do).

La longitud máxima se debería definir al
configurar el DB.
El valor puede ser modificado por el pro‐
grama de usuario también durante el fun‐
cionamiento.

FTP_REPLY_CODE INT

Cifra sin signo (16 bit) que contie‐
ne el último código Reply de FTP
como valor binario.
El contenido de este campo solo
es válido si EXIST = 1.

Es actualizado por el tramitador de proto‐
colo FTP al procesar comandos FTP del
servidor.

DATE_TIME

Fecha y hora de la última modifi‐
cación del archivo.
El contenido de este campo solo
es válido si EXIST = 1.

La fecha actual se actualiza tras un pro‐
ceso de escritura.

DATE_AND_TIME

Si se utiliza la función "Transmisión de ho‐
ra", la entrada equivale a la hora transmi‐
tida.
Si la función "Transmisión de hora" no se
utiliza, se introduce una hora relativa. La
referencia es el momento de arranque del
CP (valor de inicialización: 01.01.1994
00:00h).

Consulte también
Bloque de datos FILE_DB_HEADER como plantilla - modo cliente FTP (Página 4446)

Programación del PLC
Manual de programación y manejo, 11/2019

4445

Instrucciones
4.1 Instrucciones

Bloque de datos FILE_DB_HEADER como plantilla - modo cliente FTP
Significado
El encabezado del File-DB aquí descrito es idéntico para los modos de cliente y servidor FTP.
Para la creación de un encabezado del File-DB está predeterminado el tipo de datos
FILE_DB_HEADER.

Funcionamiento
Para la transmisión de datos mediante FTP hay que crear bloques de datos (File-DBs) en la
CPU de la estación S7. Dichos bloques de datos han de tener una determinada estructura para
que los servicios FTP puedan tratarlos como archivos transmisibles. Constan de los siguientes
sectores:
● Sector 1: encabezado del File-DB (tiene una estructura fija con una longitud de 20 byte)
● Sector 2: datos de usuario (longitud y estructura variables)

Proceda del siguiente modo:
1. Cree un bloque de datos del tipo "DB global" en la CPU en la que se crea el programa de
usuario con las instrucciones FTP.
Nota
Agregar nuevo bloque - Selección de tipo
Al crear nuevos bloques de datos, en la entada "Tipo" de la lista desplegable también se
ofrece el tipo de bloque "FILE_DB_HEADER". ¡No utilice esta opción!
Un DB del tipo "FILE_DB_HEADER" únicamente contiene la estructura de encabezado y no
puede ampliarse con el área necesaria para depositar datos de usuario.
– Solo para CP 1543‑1 con versión de firmware < V2:
Abra el cuadro de diálogo de propiedades del bloque de datos recién creado (menú
contextual), desactive el atributo "Acceso optimizado al bloque" y vuelva a cerrar el
cuadro de diálogo de propiedades.
2. En el editor de bloques del DB, seleccione la fila que va a utilizar como línea de inicio para
el File-DB.
3. En la columna "Tipo de datos" seleccione un elemento de estructura del tipo
"FILE_DB_HEADER" o bien introduzca el tipo "FILE_DB_HEADER" a través del teclado.
Resultado: Se crea una estructura de datos con la estructura de encabezado necesaria
para el File-DB.
4. Ponga el parámetro "WRITE_ACCESS" a "true" para permitir el acceso.
5. Indique un valor para la longitud de los datos de usuario en el parámetro "MAX_LENGTH",
consulte el siguiente punto.
6. Cree un campo de datos del tipo "Array [..] of Byte" o "Array [..] of Char" para los datos de
usuario a transmitir.
El tamaño del campo debe coincidir con la indicación de MAX_LENGTH en el encabezado.

4446

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Bloque de datos FILE_DB_HEADER - Ejemplo y plantilla para el encabezado del File-DB
En la vista de declaración se reconoce la siguiente estructura:
Dirección

Nombre

0.0

Tipo

Valor inicial

Comentario

STRUCT

+0.0

bit08

BOOL

FALSE

reservado

+0.1

bit09

BOOL

FALSE

reservado

+0.2

bit10

BOOL

FALSE

reservado

+0.3

bit11

BOOL

FALSE

reservado

+0.4

bit12

BOOL

FALSE

reservado

+0.5

bit13

BOOL

FALSE

reservado

+0.6

bit14

BOOL

FALSE

reservado

+0.7

bit15

BOOL

FALSE

reservado

+1.0

EXIST

BOOL

FALSE

Si TRUE: el File-DB contiene
datos válidos.

+1.1

LOCKED

BOOL

FALSE

Si TRUE: El File-DB está blo‐
queado debido a un cambio de
contenido.

+1.2

NEW

BOOL

FALSE

Si TRUE: el contenido del FileDB es nuevo y no puede so‐
brescribirse.

+1.3

WRITE_ACCESS

BOOL

FALSE

Si TRUE: el servidor FTP tiene
acceso de escritura.

+1.4

bit04

BOOL

FALSE

reservado

+1.5

bit05

BOOL

FALSE

reservado

+1.6

bit06

BOOL

FALSE

reservado

+1.7

bit07

BOOL

FALSE

reservado

+2.0

ACT_LENGTH

DINT

L#0

Longitud actual del contenido
en bytes (sin incluir los 20 bytes
del encabezado)

+6.0

MAX_LENGTH

DINT

L#0

Longitud máxima del contenido
en bytes (sin incluir los 20 bytes
del encabezado)

+10.0

FTP_REPLY_CODE

INT

0

Es actualizado por el tramitador
de protocolo FTP al procesar
comandos FTP, última informa‐
ción de respuesta del servidor
FTP.

+12.0

DATE_TIME

DATE_AND_TIME

DT#00-1-1-0:0:0.000

Fecha y hora del último cambio
en el contenido del File-DB.

=20.0

Programación del PLC
Manual de programación y manejo, 11/2019

END_STRUCT

4447

Instrucciones
4.1 Instrucciones

Punto a punto
Sinopsis de la comunicación Freeport
STEP 7 ofrece instrucciones avanzadas que permiten realizar la comunicación Freeport
utilizando un protocolo especificado en el programa de usuario. Dichas instrucciones se
dividen en dos categorías:
● Instrucciones de configuración
● Instrucciones de comunicación
Nota
Capacidad de la CPU
Las instrucciones Freeport se comunican con los módulos de comunicaciones mediante
lectura o escritura de registros.
Por ello, al utilizar las instrucciones debe tenerse en cuenta la capacidad de lectura y escritura
de registros de la CPU correspondiente.
Si varias instrucciones de una CPU deben leer o escribir registros de forma simultánea, es
posible que el programa de usuario tenga que llamar las instrucciones con un desfase
temporal.

Instrucciones de configuración
Antes de que el programa de usuario pueda iniciar la comunicación Freeport, es necesario
configurar la interfaz de comunicación y los parámetros para transmitir y recibir datos.
La configuración de interfaces y datos se realiza para cada CM en la configuración de
dispositivos o con las siguientes instrucciones del programa de usuario:
● Port_Config (Página 4453)
● Send_Config (Página 4456)
● Receive_Config (Página 4458)
● P3964_Config (Página 4463)

4448

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

ATENCIÓN
Configuración de dispositivos <-> Instrucciones de configuración
Los parámetros de la configuración de dispositivos se transfieren al CM en cada Power On de
la CPU (retorno de la tensión).
Los parámetros de las instrucciones de configuración se transfieren al CM de acuerdo con su
programa de usuario.
No existe ninguna sincronización entre los parámetros de la configuración de dispositivos y
los parámetros de las instrucciones de configuración, es decir, los parámetros de las
instrucciones de configuración no se aplican a la configuración de dispositivos de la CPU.
El programa de usuario permite controlar qué parámetros se aplican en el CM en cada
momento.

Instrucciones de comunicación
Las instrucciones de la comunicación Freeport permiten al programa de usuario enviar datos
a las interfaces de comunicación y recibirlos de estas. Los CM envían datos a los dispositivos
de comunicación y los reciben de ellos.
● Send_P2P (Página 4465)
● Receive_P2P (Página 4469)
Nota
Coherencia de datos
● En el caso de que los datos que vayan a enviarse deban transferirse de forma coherente,
no deben modificarse desde el ascenso del flanco del parámetro REQ hasta establecer
DONE con la instrucción Send_P2P .
● Si los datos recibidos deben leerse de forma coherente, solo deben evaluarse en el ciclo en
el que NDR = TRUE.
Con instrucciones adicionales es posible inicializar el búfer de recepción, así como consultar
y activar señales RS232 especiales.
● Receive_Reset (Página 4471)
● Signal_Get (Página 4472)
● Signal_Set (Página 4473)
Las siguientes instrucciones permiten leer y escribir funciones avanzadas, siempre que el
módulo las soporte.
● Get_Features (Página 4475)
● Set_Features (Página 4476)
Todas las instrucciones Freeport funcionan de forma asíncrona. Por ello, las instrucciones
deben llamarse repetidas veces hasta que el parámetro de salida DONE indique que ha
finalizado la ejecución.

Programación del PLC
Manual de programación y manejo, 11/2019

4449

Instrucciones
4.1 Instrucciones
Utilizando una arquitectura de consultas, el programa de usuario puede determinar el estado
de transmisión y recepción. Send_P2P y Receive_P2P pueden ejecutarse a la vez. Los
módulos de comunicaciones respaldan los datos enviados y recibidos hasta un tamaño
máximo del búfer específico del módulo.

Nota
Resolución de tiempos de bit
Para diversos parámetros se indica el número de tiempos de bits en la velocidad de
transferencia configurada. Debido a la indicación del parámetro en tiempos de bit, dicho
parámetro es independiente de la velocidad de transferencia. Todos los parámetros con la
unidad de tiempos de bit pueden indicarse con un número máximo de 65535.

Aplicación de las instrucciones
Las instrucciones Freeport deben llamarse cíclicamente para consultar los datos recibidos o el
fin de una transmisión.
En función del volumen de datos, la transmisión puede desarrollarse en varias llamadas (ciclos
del programa).
Si la petición se ha completado con DONE = TRUE o NDR = TRUE, se ha ejecutado sin errores.
Nota
Guardar STATUS
Los parámetros DONE, NDR, ERROR y STATUS solo permanecen durante una ejecución del
bloque. Por ello, para visualizar STATUS debe copiarlo en un área de datos libre.

maestro
Secuencia típica de un maestro:
1. La instrucción Send_P2P lanza una transferencia al CM.
Con un flanco ascendente en la entrada REQ se inicia la transmisión de los datos.
2. La instrucción Send_P2P se ejecuta en ciclos consecutivos para consultar el estado del
proceso de transferencia.
3. Si la instrucción Send_P2P en la salida DONE notifica que la transferencia ha finalizado, el
código de usuario puede preparar la recepción de la respuesta.
4. La instrucción Receive_P2P se ejecuta repetidamente para consultar una respuesta. Una
vez que el CM ha leído los datos de respuesta, la instrucción Receive_P2P copia la
respuesta en la CPU y notifica en la salida NDR que se han recibido datos nuevos.
5. El programa de usuario puede procesar la respuesta.
6. Regreso al paso 1 y repetición de la secuencia.

4450

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

esclavo
Secuencia típica de un esclavo:
1. El programa de usuario ejecuta la instrucción Receive_P2P en cada ciclo.
2. Una vez que el CM ha recibido una solicitud, la instrucción Receive_P2P notifica en la salida
NDR que hay datos nuevos preparados y la solicitud se copia en la CPU.
3. El programa de usuario procesa la solicitud y genera una respuesta.
4. Con la instrucción Send_P2P , la respuesta se devuelve al maestro.
5. La instrucción Send_P2P debe ejecutarse repetidamente para asegurarse de que el
proceso de transmisión tiene lugar realmente.
6. Regreso al paso 1 y repetición de la secuencia.
El esclavo debe procurar que Receive_P2P se llame tantas veces como sea necesario para
que el maestro pueda recibir una transferencia antes de que cancele el proceso por rebasar el
tiempo mientras espera una respuesta. Para cumplir esta tarea, el programa de usuario puede
llamar a Receive_P2P desde un OB de ciclo cuyo tiempo de ciclo sea lo suficientemente corto
como para recibir una transferencia del maestro antes de que transcurra el timeout ajustado.
Si el tiempo de ciclo para el OB se ajusta de modo que se lleven a cabo dos ejecuciones dentro
del timeout ajustado, el programa de usuario puede recibir todas las transferencias sin
pérdidas.

Parámetros comunes para las operaciones Freeport
Tabla 4-144 Parámetros de entrada comunes de las instrucciones Freeport
Parámetro

Descripción

REQ

Con un flanco ascendente en la entrada REQ se inicia la transmisión de los datos. Un flanco
adicional en REQ solamente puede generarse una vez finalizada la petición (DONE o bien
ERROR). Dependiendo del volumen de datos, la transmisión puede desarrollarse en varias lla‐
madas (ciclos del programa).
Al insertar una instrucción Freeport en el programa, STEP 7 le pedirá que indique el DB de instancia
(o que cree mediante STEP 7 un DB de instancia correspondiente). Utilice un DB unívoco para
cada llamada de instrucción PtP.

PORT

Al configurar el módulo de comunicaciones se asigna una dirección de puerto. Con el parámetro
PORT se comunica a la instrucción la asignación a un determinado módulo de comunicaciones.
Tras la configuración se puede seleccionar un nombre simbólico para el puerto estándar. El valor
de puerto asignado del CM es la propiedad "identificador de hardware" de la configuración de
dispositivos en el S7-1200/1500 o la "dirección de entrada" en el S7-300/400. El nombre simbólico
del puerto se asigna en la tabla de símbolos.

Programación del PLC
Manual de programación y manejo, 11/2019

4451

Instrucciones
4.1 Instrucciones
Los parámetros de salida DONE, NDR, ERROR y STATUS de las instrucciones Freeport
indican el estado de ejecución de las funciones Freeport.
Tabla 4-145 Parámetros de salida DONE, NDR, ERROR y STATUS
Parámetro

Tipo de datos

Estándar

Descripción

DONE

Bool

FALSE

Se pone a TRUE durante todo un ciclo para indicar que la última
petición ha concluido correctamente; en caso contrario, FALSE.

NDR

Bool

FALSE

Se pone a TRUE durante todo un ciclo para indicar que se han
recibido nuevos datos; en caso contrario, FALSE.

ERROR

Bool

FALSE

Se pone a TRUE durante todo un ciclo para indicar que la última
petición ha concluido con error; el código de error correspondiente
se encuentra en STATUS; en caso contrario, FALSE.

STATUS

Word

16#0000 o
16#7000

Estado del resultado:
● Si el bit DONE o NDR está activado, se ajusta STATUS a
0/16#7000 o a un código de error específico.
● Si está activado el bit ERROR, se indica un código de error en
STATUS.
● Si no se activa ninguno de los bits mencionados, la instrucción
puede devolver resultados de estado que describen el estado
actual de la función.
El valor de STATUS es válido hasta la siguiente llamada de esta
instrucción (con la misma dirección única de puerto).

Tabla 4-146 Parámetro de entrada/salida COM_RST
Parámetro

Tipo de datos

Estándar

Descripción

COM_RST

Bool

FALSE

Inicialización de la instrucción
Con TRUE se inicializa la instrucción. Seguidamente se ajusta
COM_RST de nuevo a FALSE.
Nota: En el arranque, COM_RST debe ajustarse a TRUE y, des‐
pués, no debería modificar más este parámetro, p. ej., no asignar
ningún valor al llamar la instrucción. Tras inicializar el DB de ins‐
tancia, la instrucción resetea COM_RST.

Nota
Tenga en cuenta que los parámetros DONE, NDR, ERROR y STATUS solo están activados
durante un ciclo.

Tabla 4-147 Códigos de error comunes
Código de error

Descripción

16#0000

No hay error

16#7000

Función inactiva

16#7001

Primera llamada tras iniciar una petición.

4452

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error

Descripción

16#7002

Llamada posterior tras iniciar una petición.

16#8x3A

Puntero no admisible en parámetro x

Tabla 4-148 Clases de errores comunes del parámetro STATUS
Descripción de la clase

Clases de error

Configuración del puerto

Descripción

16#81Ax

Para la descripción de errores frecuentes en la configuración de
interfaces

Configuración de transmisión

16#81Bx

Para la descripción de errores en la configuración de transmisión

Configuración de recepción

16#81Cx

Para la descripción de errores en la configuración de recepción

Transferir

16#81Dx

Para la descripción de errores del tiempo de ejecución al transmitir

Recibir

16#81Ex

Para la descripción de errores del tiempo de ejecución al recibir

Señales cualificadoras RS232

16#81Fx

Para la descripción de errores en relación con el procesamiento
de señales

Port_Config: configurar el puerto de comunicación PtP
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

Descripción
La instrucción Port_Config (configuración del puerto) permite modificar parámetros como la
velocidad de transferencia desde el programa durante el funcionamiento. Los datos
pendientes del CM se borran al ejecutar Port_Config.
Los cambios de configuración de Port_Config no se guardan en la CPU sino en el CM. En caso
de retorno de la tensión, el CM se parametriza con los datos guardados en la configuración de
dispositivos.

Programación del PLC
Manual de programación y manejo, 11/2019

4453

Instrucciones
4.1 Instrucciones

Parámetros
Parámetro

Declara‐
ción

REQ

IN

PORT

IN

Tipo de datos
S71200/1500

S7300/400/
WinAC

Bool
PORT
(UInt)

Word

Ajuste prede‐ Descripción
terminado

FALSE

Inicia la transferencia de datos al CM con un flanco as‐
cendente en esta entrada.

0

Especifica el módulo de comunicación a través del cual
se produce la comunicación:
● para S7-1500/S7-1200: "Identificador de hardware"
de la configuración del dispositivo.
El nombre simbólico del puerto está asignado en la
ficha "Constantes de sistema" de la tabla de
variables PLC y puede adoptarse de ahí.
● para S7-300/S7-400: "Dirección de entrada" de la
configuración del dispositivo.
En los sistemas S7-300/400/WinAC se asigna al
parámetro PORT la dirección de entrada otorgada
en HWCN.

PROTO‐
COL

IN

UInt

Word

0

Protocolo
● 0 = protocolo Freeport
● 1 = protocolo 3964(R)

BAUD

IN

UInt

Word

6

Velocidad de transferencia del puerto:
● 1 = 300 bits/s
● 2 = 600 bits/s
● 3 = 1200 bits/s
● 4 = 2400 bits/s
● 5 = 4800 bits/s
● 6 = 9600 bits/s
● 7 = 19200 bits/s
● 8 = 38400 bits/s
● 9 = 57600 bits/s
● 10 = 76800 bits/s
● 11 = 115200 bits/s

PARITY

IN

UInt

Word

1

Paridad del puerto:
● 1 = ninguna
● 2 = paridad par
● 3 = paridad impar
● 4 = paridad Mark
● 5 = paridad Space
● 6 = cualquiera

DATABITS IN

UInt

Word

1

Bits por carácter:
● 1 = 8 bits de datos
● 2 = 7 bits de datos

4454

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción

STOPBITS IN

Tipo de datos
S71200/1500
UInt

S7300/400/
WinAC
Word

Ajuste prede‐ Descripción
terminado

1

Bits de parada:
● 1 = 1 bit de parada
● 2 = 2 bits de parada

FLOWCTR IN
L

UInt

Word

1

Control del flujo:
● 1 = no hay control del flujo
● 2 = XON/XOFF
● 3 = RTS de HW siempre ON
● 4 = RTS de HW con protocolo de intercambio
● 5 = RTS de HW siempre ON, ignorar DTR/DSR

XON‐
CHAR

IN

Char

16#0011

Indica el carácter que sirve de carácter XON. Suele ser
un carácter DC1 (11H). Este parámetro solo se evalúa
cuando está activado el control del flujo de software.

XOFF‐
CHAR

IN

Char

16#0013

Indica el carácter que sirve de carácter XOFF. Suele ser
un carácter DC3 (13H). Este parámetro solo se evalúa
cuando está activado el control del flujo de software.

WAITIME

IN

UInt

Word

2000

Indica el tiempo durante el que se espera un carácter
XON tras recibir un carácter XOFF o bien el tiempo du‐
rante el que se espera la señal CTS = ON tras CTS =
OFF (de 0 a 65535 ms). Este parámetro solo se evalúa
cuando está activado el control del flujo.

MODE

IN

USInt

Byte

0

Modo de operación
Los modos de operación admitidos son:
● 0 = dúplex (RS232)
● 1 = dúplex (RS422) modo a cuatro hilos (punto a
punto)
● 2 = dúplex (RS422) modo a cuatro hilos (maestro
multipunto, CM PtP (ET 200SP))
● 3 = dúplex (RS422) modo a cuatro hilos (esclavo
multipunto, CM PtP (ET 200SP))
● 4 = semidúplex (RS485) modo a dos hilos 1)

Programación del PLC
Manual de programación y manejo, 11/2019

4455

Instrucciones
4.1 Instrucciones
Parámetro

LINE_PRE

Declara‐
ción

IN

Tipo de datos
S71200/1500
USInt

S7300/400/
WinAC
Byte

Ajuste prede‐ Descripción
terminado

0

Estado inicial de la línea de recepción
Los estados iniciales admitidos son:
● 0 = "sin" asignación inicial 1)
● 1 = señal R(A) = 5 V, señal R(B) = 0 V (detección
Break):
en este estado inicial es posible una detección de
rotura (Break).
Solo disponible con: "Dúplex (RS422) modo a
cuatro hilos (acoplamiento punto a punto)" y "Dúplex
(RS422) modo a cuatro hilos (esclavo multipunto)".
● 2 = señal R(A) = 0 V, señal R(B) = 5 V:
este estado inicial corresponde al estado de reposo
(ninguna transmisión activa). Con este estado inicial
no es posible la detección de rotura (Break).

BRK_DET

IN

USInt

Byte

0

Detección break
Se admiten:
● 0 = detección Break desactivada
● 1 = detección Break activada

COM_RST IN/OUT

---

Bool

FALSE

Inicialización de la instrucción
La instrucción se inicializa con TRUE. Seguidamente, la
instrucción ajusta COM_RST de nuevo a FALSE.

DONE

OUT

Bool

FALSE

TRUE durante un ciclo después de que la última peti‐
ción se haya ejecutado correctamente

ERROR

OUT

Bool

FALSE

TRUE durante un ciclo después de que la última peti‐
ción se haya ejecutado con errores

STATUS

OUT

Word

16#7000

Código de error (consulte Mensajes de error (Pági‐
na 4478))

1)

Ajuste necesario si se utilizan cables PROFIBUS en CM 1241 para RS485

Encontrará más información acerca de los parámetros generales en "Parámetros comunes
para las operaciones Freeport (Página 4451)".

Send_Config: configurar el emisor PtP
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

4456

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Descripción
Con la instrucción Send_Config (configuración de transmisión) puede cambiar los parámetros
de transmisión durante el funcionamiento desde el programa (condiciones que marcan el
principio y fin de los datos que deben enviarse). Los datos pendientes en un CM se borran
cuando se ejecuta Send_Config.
Los cambios de configuración de Send_Config no se guardan en la CPU sino en el CM. Los
parámetros guardados en la configuración de dispositivos se restablecen al retornar la tensión
de la CPU o del módulo de comunicaciones.

Parámetros
Parámetro

Declara‐
ción

REQ

IN

PORT

IN

Tipo de datos
S71200/150
0

S7300/400/
WinAC

Bool
PORT
(UInt)

Word

Ajuste prede‐ Descripción
terminado

FALSE

Activa el cambio de configuración con un flanco ascen‐
dente en esta entrada.

0

Especifica el módulo de comunicación a través del cual
se produce la comunicación:
● para S7-1500/S7-1200: "Identificador de hardware"
de la configuración del dispositivo.
El nombre simbólico del puerto está asignado en la
ficha "Constantes de sistema" de la tabla de variables
PLC y puede adoptarse de ahí.
● para S7-300/S7-400: "Dirección de entrada" de la
configuración del dispositivo.
En los sistemas S7-300/400/WinAC se asigna al
parámetro PORT la dirección de entrada otorgada en
HWCN.

RTSONDL
Y

IN

UInt

Word

0

Número de milisegundos que debe esperarse tras la ac‐
tivación de RTS antes de iniciar una transferencia de da‐
tos de envío. Este parámetro solo es válido cuando está
activado el control del flujo de hardware. El rango válido
es de 0 a 65535 ms. El valor 0 desactiva la función.

RTSOFFD
LY

IN

UInt

Word

0

Número de milisegundos que debe esperarse después
de transferir datos de transmisión antes de que se de‐
sactive RTS: Este parámetro solo es válido cuando está
activado el control del flujo de hardware. El rango válido
es de 0 a 65535 ms. El valor 0 desactiva la función.

BREAK

IN

UInt

Word

0

Este parámetro indica que se envía un BREAK antes de
iniciar cada trama durante el número indicado de tiempos
de bit. El número máximo de tiempos de bit es 65535. El
valor 0 desactiva la función.

IDLELINE

IN

UInt

Word

0

Este parámetro indica que la línea permanece vacía an‐
tes de iniciar cada trama durante el número indicado de
tiempos de bit. El número máximo de tiempos de bit es
65535. El valor 0 desactiva la función.

Programación del PLC
Manual de programación y manejo, 11/2019

4457

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción

Tipo de datos
S71200/150
0

S7300/400/
WinAC

Ajuste prede‐ Descripción
terminado

USR_END

IN

STRING[2]

0

Entrada de los caracteres de fin.
Se pueden configurar como máximo 2 caracteres de fin.
Se envían el o los caracteres de fin, independientemente
de la longitud de trama parametrizada.

APP_END

IN

STRING[5]

0

Entrada de los caracteres que deben añadirse.
Se pueden añadir como máximo 5 caracteres.

COM_RST IN/OUT

---

Bool

FALSE

Inicialización de la instrucción
La instrucción se inicializa con TRUE. Seguidamente, la
instrucción ajusta COM_RST de nuevo a FALSE.

DONE

OUT

Bool

FALSE

TRUE durante un ciclo después de que la última petición
se haya ejecutado correctamente

ERROR

OUT

Bool

FALSE

TRUE durante un ciclo después de que la última petición
se haya ejecutado con errores

STATUS

OUT

Word

16#7000

Código de error (consulte Mensajes de error (Pági‐
na 4478))

Encontrará más información acerca de los parámetros generales en "Parámetros comunes
para las operaciones Freeport (Página 4451)".

Receive_Config: configurar el receptor PtP
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

Descripción
Con la instrucción Receive_Config (configuración de recepción) puede cambiar los parámetros
de recepción durante el funcionamiento desde el programa. Esta instrucción configura las
condiciones que marcan el principio y fin de los datos recibidos. Los datos pendientes en un
CM se borran cuando se ejecuta Receive_Config.
Los cambios de configuración de Receive_Config no se guardan de manera remanente en el
CM. Los parámetros guardados en la configuración de dispositivos se restablecen al retornar
la tensión de la CPU o del módulo de comunicaciones. Por eso, se debe llamar de nuevo la
instrucción Receive_Config desde el programa de usuario al retornar la tensión de la CPU o del
módulo de comunicación, para volver a sobrescribir los parámetros guardados en la
configuración del dispositivo.

4458

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
Parámetro

Declara‐
ción

REQ

IN

PORT

IN

Tipo de datos
S71200/1500

S7300/400/
WinAC

Bool
PORT
(UInt)

Word

Ajuste prede‐ Descripción
terminado

FALSE

Activa el cambio de configuración con un flanco ascen‐
dente en esta entrada.

0

Especifica el módulo de comunicación a través del cual
se produce la comunicación:
● para S7-1500/S7-1200: "Identificador de hardware"
de la configuración del dispositivo.
El nombre simbólico del puerto está asignado en la
ficha "Constantes de sistema" de la tabla de variables
PLC y puede adoptarse de ahí.
● para S7-300/S7-400: "Dirección de entrada" de la
configuración del dispositivo.
En los sistemas S7-300/400/WinAC se asigna al
parámetro PORT la dirección de entrada otorgada en
HWCN.

RECEI‐
VE_CON‐
DITIONS

IN

COM_RST IN/OUT

Variant

Any

‑

La estructura de datos de Receive_Conditions indica las
condiciones de inicio y fin en virtud de las cuales se iden‐
tifica el principio y fin de una trama.

---

Bool

FALSE

Inicialización de la instrucción
La instrucción se inicializa con TRUE. Seguidamente, la
instrucción ajusta COM_RST de nuevo a FALSE.

DONE

OUT

Bool

FALSE

TRUE durante un ciclo después de que la última petición
se haya ejecutado correctamente

ERROR

OUT

Bool

FALSE

TRUE durante un ciclo después de que la última petición
se haya ejecutado con errores

STATUS

OUT

Word

16#7000

Código de error (consulte Mensajes de error (Pági‐
na 4478))

Encontrará más información acerca de los parámetros generales en "Parámetros comunes
para las operaciones Freeport (Página 4451)".

Condiciones de inicio de la instrucción Receive_P2P
La instrucción Receive_P2P utiliza la configuración de dispositivos o bien la indicada por la
instrucción Receive_Config para determinar el inicio y el fin de tramas de la comunicación
Freeport. El inicio de la trama queda definido por las condiciones de inicio. El inicio de la trama
puede especificarse mediante una o varias condiciones de inicio.
Si están activados tanto Break como Idle Line, debe cumplirse Break y, además, Idle Line. A
continuación, basta una de las condiciones restantes (carácter de inicio o secuencia de inicio)
para iniciar la transmisión de datos.
La condición de inicio "Cualquier carácter" no puede combinarse con otras condiciones de
inicio.

Programación del PLC
Manual de programación y manejo, 11/2019

4459

Instrucciones
4.1 Instrucciones

Estructura del tipo de datos del parámetro Receive_Conditions, parte 1 (condiciones de inicio)
Tabla 4-149 Estructura de Receive_Conditions para condiciones de inicio
Parámetro

Declaración Tipo de
datos

Ajuste prede‐ Descripción
terminado

START.START‐
COND

IN

16#0002

Word

Indicación de la condición de inicio
● 01H - detección del carácter de inicio
● 02H - cualquier carácter
● 04H - detección de Line Break
● 08H - detección de Idle Line
● 10H - detección de la secuencia de inicio 1
● 20H - detección de la secuencia de inicio 2
● 40H - detección de la secuencia de inicio 3
● 80H - detección de la secuencia de inicio 4
Las condiciones de inicio pueden combinarse sumando los va‐
lores.

START.IDLETI‐
ME

IN

Word

16#0028

Número de tiempos de bit necesarios en vacío para que se de‐
tecte un nuevo inicio de la trama (valor predeterminado:
W#16#28). Solo en combinación con la condición "detección de
Idle Line".

START.START‐
CHAR

IN

Byte

16#0002

Carácter de inicio para la condición "carácter de inicio". (valor
predeterminado: B#16#2)

START.SEQ[1].
CTL

IN

Byte

0

Secuencia de inicio 1, desactivar/activar comparación para ca‐
da carácter: (valor predeterminado: B#16#0)

0 a FFFF

Estos son los bits de activación para cada carácter de la se‐
cuencia de inicio.
● 01H - carácter 1
● 02H - carácter 2
● 04H - carácter 3
● 08H - carácter 4
● 10H - carácter 5
Si se desactiva un bit para un carácter determinado, significa
que en esta posición de la secuencia cada carácter representa
una secuencia de inicio válida (p. ej. 1FH = se interpretan los 5
caracteres).
START.SEQ[1].
STR[1] ..
START.SEQ[1].
STR.[5]

IN

Char[5]

0

Secuencia de inicio 1, carácter de inicio (5 caracteres).

START.SEQ[2].
CTL

IN

Byte

0

Secuencia de inicio 2, desactivar/activar comparación para ca‐
da carácter. Valor predeterminado: B#16#0)

START.SEQ[2].
STR[1] ..
START.SEQ[2].
STR.[5]

IN

Char[5]

0

Secuencia de inicio 2, carácter de inicio (5 caracteres).

4460

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración Tipo de
datos

Ajuste prede‐ Descripción
terminado

START.SEQ[3].
CTL

IN

Byte

0

Secuencia de inicio 3, desactivar/activar comparación para ca‐
da carácter. Valor predeterminado: B#16#0

START.SEQ[3].
STR[1] ..
START.SEQ[3].
STR.[5]

IN

Char[5]

0

Secuencia de inicio 3, carácter de inicio (5 caracteres).

START.SEQ[4].
CTL

IN

Byte

0

Secuencia de inicio 4, desactivar/activar comparación para ca‐
da carácter. Valor predeterminado: B#16#0

START.SEQ[4].
STR[1] ..
START.SEQ[4].
STR.[5]

IN

Char[5]

0

Secuencia de inicio 4, carácter de inicio (5 caracteres).

Ejemplo
Observe los siguientes datos recibidos en código hexadecimal: "68 10 aa 68 bb 10 aa 16".
Encontrará las secuencias de caracteres de inicio configuradas en la tabla siguiente. Las
secuencias de caracteres de inicio se evalúan una vez se ha recibido correctamente el primer
carácter 68H. Tras la recepción correcta del cuarto carácter (el segundo 68H) se ha cumplido
la condición de inicio 1. Si se cumplen las condiciones de inicio, empieza la evaluación de las
condiciones de fin.
El procesamiento de la secuencia de caracteres inicial puede finalizarse debido a diferentes
errores de paridad, framing o intervalos entre los caracteres. Dichos errores hacen que los
datos no se reciban porque no se cumple la condición de inicio (se genera un mensaje de error).
Tabla 4-150 Condiciones de inicio
Condición de inicio

Primer carácter

Primer carácter +1 Primer carácter +2 Primer carácter +3 Primer carácter +4

1

68H

xx

xx

68H

xx

2

10H

aaH

xx

xx

xx

3

dcH

aaH

xx

xx

xx

4

e5H

xx

xx

xx

xx

Condiciones de fin de la instrucción Receive_P2P
El final de una trama se define por la primera aparición de una o varias condiciones de fin
configuradas.
Las condiciones de fin se configuran en las propiedades de la interfaz de comunicación de la
configuración de dispositivos o bien mediante la instrucción Receive_Config. Tras retornar la
tensión de la CPU o del módulo de comunicaciones, los parámetros de recepción (condiciones
de inicio y fin) se ponen de nuevo a los ajustes de la configuración de dispositivos. Si el
programa de usuario de STEP 7 ejecuta Receive_Config, los ajustes cambian a los parámetros
de Receive_Config .

Programación del PLC
Manual de programación y manejo, 11/2019

4461

Instrucciones
4.1 Instrucciones

Estructura del tipo de datos del parámetro Receive_Conditions, parte 2 (condiciones de fin)
Tabla 4-151 Estructura de Receive_Conditions para condiciones de fin
Parámetro

Declaración Tipo de
datos

Ajuste prede‐ Descripción
terminado

END.END‐
COND

IN

0

Word

Este parámetro indica la condición para el fin de trama:
● 01H - tiempo de respuesta excedido
● 02H - tiempo de espera del mensaje excedido
● 04H - tiempo de retardo de caracteres
● 08H - longitud máxima de trama
● 10H - leer longitud del mensaje en el mensaje (N+LEN+M)
● 20H - secuencia de fin
● 40H - longitud fija de trama

END.FIXLEN

IN

Word

1

Longitud fija de trama: solo se utiliza si se selecciona la condi‐
ción de fin "Longitud fija de trama".
De 1 a 4000 bytes (en función del módulo hasta 4 kbytes)

END.MAXLEN

IN

Word

1

Longitud máxima de trama: solo se utiliza si se selecciona la
condición de fin "Longitud máxima de trama".
De 1 a 4000 bytes (en función del módulo hasta 4 kbytes)

END.N

IN

Word

0

Posición de byte del campo de longitud en la trama. Solo se
utiliza con la condición de fin N+LEN+M.
De 1 a 4000 bytes (en función del módulo hasta 4 kbytes)

END.LENGTH‐
SIZE

IN

Word

0

Tamaño del campo de longitud (1, 2 o 4 bytes). Solo se utiliza
con la condición de fin N+LEN+M.

END.LENGTHM IN

Word

0

Número de caracteres posteriores al campo de longitud que no
están incluidos en el valor del mismo. Este dato solo se utiliza
con la condición de fin N+LEN+M. 0 a 255 bytes

END.RCVTIME

Word

200

Indique el tiempo durante el que debe esperarse el primer ca‐
rácter recibido tras enviar una trama. La instrucción de recep‐
ción finalizará con un mensaje de error si dentro del tiempo
indicado no se recibe ningún carácter correctamente. Este dato
solo se utiliza con la condición "tiempo de respuesta excedido".
(0 a 65535 ms).

IN

Nota: Este parámetro no puede utilizarse como criterio único de
fin, sino solamente en combinación con al menos otra condición
de fin.
END.MSGTIME

IN

Word

200

Indique el tiempo que debe esperarse a la recepción completa
de la trama tras haber recibido el primer carácter. Este paráme‐
tro solo se utiliza cuando está seleccionada la condición "tiempo
de espera del mensaje excedido". (0 a 65535 ms)

END.CHARGAP IN

Word

12

Indique el número máximo de tiempos de bit entre los caracte‐
res. Si el número de tiempos de bit entre los caracteres rebasa
por exceso el valor indicado, se cumple la condición de fin. Este
dato solo se utiliza con la condición "tiempo de retardo de ca‐
racteres". (0 a 65535 tiempos de bit)

4462

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración Tipo de
datos

Ajuste prede‐ Descripción
terminado

END.SEQ.CTL

IN

0

Byte

Secuencia de caracteres 1, desactivar/activar comparación pa‐
ra cada carácter:
Estos son los bits de activación para cada carácter de la se‐
cuencia de fin. El carácter 1 es el bit 0, el carácter 2 es el bit 1, ...,
el carácter 5 es el bit 4. Si se desactiva un bit para un carácter
concreto, significa que en esta posición de la secuencia cada
carácter representa una coincidencia.

END.SEQ.STR[
1] ..
END.SEQ.STR[
5]

IN

Char[5]

0

Secuencia de caracteres 1, carácter de inicio (5 caracteres)

Tabla 4-152 Parámetros generales de la instrucción Receive_P2P
Parámetro

Declaración Tipo de
datos

Ajuste prede‐ Descripción
terminado

GENE‐
RAL.MBUF_SI‐
ZE

IN

Byte

255

Entrada del número de tramas que deben guardarse en el búfer
de recepción del CM.
Si no hay otras condiciones activas que influyan en el compor‐
tamiento del búfer de recepción (impedir sobrescritura, control
del flujo de datos), tras alcanzar el límite se rechazan las nuevas
tramas (1 a 255 tramas).

GENE‐
IN
RAL.OW_PROT

Byte

0

Activa la función para no sobrescribir la trama en búfer, en caso
de que el CM reciba una nueva trama sin que se haya efectuado
la lectura del búfer de recepción del CM. Con esto se evita una
eventual pérdida de las tramas de recepción que ya están en el
búfer.
● 0 - no activado
● 1 - activado

GENE‐
RAL.CLR_MBU
F

IN

Byte

0

Activa el borrado del búfer de recepción en el arranque de la
CPU.
Si este parámetro está activado, el búfer de recepción se borra
automáticamente en la transición de la CPU de STOP a RUN.
En el búfer de recepción solo hay tramas que fueron recibidas
después del arranque de la CPU.
● 0 - no activado
● 1 - activado

P3964_Config: Configurar el protocolo 3964(R)
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

Programación del PLC
Manual de programación y manejo, 11/2019

4463

Instrucciones
4.1 Instrucciones

Descripción
La instrucción P3964_Config (configuración del protocolo) permite modificar desde el
programa y durante el funcionamiento los parámetros del protocolo 3964(R) como tiempo de
retardo de caracteres, prioridad y control de bloque.
Los cambios de configuración de P3964_Config no se guardan en la CPU sino en el CM. Los
parámetros guardados en la configuración de dispositivos se restablecen al retornar la tensión
de la CPU o del módulo de comunicaciones.

Parámetros
Parámetro

Declara‐
ción

REQ

IN

PORT

IN

Tipo de datos
S71200/150
0

S7300/400/
WinAC

Bool
PORT
(UInt)

Word

Ajuste pre‐
determina‐
do

Descripción

FALSE

Inicia la instrucción con un flanco ascendente en esta
entrada.

0

Especifica el módulo de comunicación a través del
cual se produce la comunicación:
● para S7-1500/S7-1200: "Identificador de
hardware" de la configuración del dispositivo.
El nombre simbólico del puerto está asignado en
la ficha "Constantes de sistema" de la tabla de
variables PLC y puede adoptarse de ahí.
● para S7-300/S7-400: "Dirección de entrada" de la
configuración del dispositivo.
En los sistemas S7-300/400/WinAC se asigna al
parámetro PORT la dirección de entrada otorgada
en HWCN.

BCC

IN

USInt

Byte

1

Activa/desactiva el uso de la comprobación de bloque
● 0 = sin control de bloque
● 1 = con control de bloque

Priority

IN

USInt

Byte

1

Ajuste de la prioridad
● 0 = prioridad baja
● 1 = prioridad alta

CharacterDe‐
layTime

IN

UInt

Word

16#00DC

AcknDelayTime IN

UInt

Word

16#07D0

Ajuste del tiempo de retardo de caracteres (en función
de la velocidad de transferencia de datos ajustada)
(valor predeterminado: 220 ms)
De 1 a 65535 ms
Ajuste del tiempo de retardo de acuse (en función de
la velocidad de transferencia de datos ajustada) (valor
predeterminado: 2000 ms)
De 1 a 65535 ms

BuildupAt‐
tempts

4464

IN

USInt

Byte

16#0006

Ajuste del número de intentos de establecer conexión
(valor predeterminado: 6 intentos de establecer cone‐
xión)
1 a 255

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción

Tipo de datos
S71200/150
0

S7300/400/
WinAC

Ajuste pre‐
determina‐
do

Descripción

Ajuste del número de intentos de transmisión (valor
predeterminado: 6 intentos de establecer conexión)
1 a 255

RepetitionAt‐
tempts

IN

USInt

Byte

16#0006

COM_RST

IN/OUT

---

Bool

FALSE

Inicialización de la instrucción
La instrucción se inicializa con TRUE. Seguidamente,
la instrucción ajusta COM_RST de nuevo a FALSE.

DONE

OUT

Bool

FALSE

TRUE durante un ciclo después de que la última pe‐
tición se haya ejecutado correctamente

ERROR

OUT

Bool

FALSE

TRUE durante un ciclo después de que la última pe‐
tición se haya ejecutado con errores

STATUS

OUT

Word

16#7000

Código de error (consulte Mensajes de error (Pági‐
na 4478))

Encontrará más información acerca de los parámetros generales en "Parámetros comunes
para las operaciones Freeport (Página 4451)".

Send_P2P: transferir datos
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

Descripción
La instrucción Send_P2P (enviar datos punto a punto) inicia la transferencia de los datos y
transfiere el contenido del búfer asignado al módulo de comunicaciones. El programa de la
CPU se sigue ejecutando mientras el CM envía los datos a la velocidad de transferencia. No
puede haber más de una instrucción de transmisión a la vez para cada módulo de
comunicaciones. El CM emite un error si se ejecuta una segunda instrucción Send_P2P
mientras el CM está enviando una trama.

Programación del PLC
Manual de programación y manejo, 11/2019

4465

Instrucciones
4.1 Instrucciones

Parámetros
Parámetro

Declara‐
ción

REQ

IN

PORT

IN

Tipo de datos
S71200/150
0

S7300/400/
WinAC

Bool
PORT
(UInt)

Word

Ajuste prede‐ Descripción
terminado

FALSE

Inicia la transferencia de datos al CM con un flanco as‐
cendente en esta entrada.

0

Especifica el módulo de comunicación a través del cual se
produce la comunicación:
● para S7-1500/S7-1200: "Identificador de hardware" de
la configuración del dispositivo.
El nombre simbólico del puerto está asignado en la
ficha "Constantes de sistema" de la tabla de variables
PLC y puede adoptarse de ahí.
● para S7-300/S7-400: "Dirección de entrada" de la
configuración del dispositivo.
En los sistemas S7-300/400/WinAC se asigna al
parámetro PORT la dirección de entrada otorgada en
HWCN.

BUFFER

IN

Variant

Any

0

Este parámetro señala el área de memoria del búfer de
transmisión.
Notas:
● No se soportan datos booleanos ni campos
booleanos.
● Si el búfer de transmisión está en el área de memoria
optimizada, la máxima longitud admisible de datos
enviados es de 1024 bytes.
Excepción: los arrays de Byte, Word o DWord se
soportan hasta una longitud de 4096 bytes.
● Si el búfer de transmisión es de tipo String o WString,
el contenido del string se transmite sin la longitud
actual y máxima.
Más información en "Uso de los parámetros BUFFER y
LENGTH en operaciones de comunicación (Página 4468)"

LENGTH

IN

UInt

Word

0

Longitud de los datos que deben transmitirse en bytes.
Con LENGTH = 0 se transfiere completamente el área de
memoria direccionada en el parámetro BUFFER.
Más información en "Uso de los parámetros BUFFER y
LENGTH en operaciones de comunicación (Página 4468)"

COM_RST IN/OUT

---

Bool

FALSE

Inicialización de la instrucción Send_P2P
Con 1 se inicializa la instrucción. Seguidamente, la ins‐
trucción pone COM_RST de nuevo a 0.
Nota:
El parámetro solo está disponible para instrucciones
S7-300/400.

DONE

4466

OUT

Bool

FALSE

TRUE durante un ciclo después de que la última petición
se haya ejecutado correctamente

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción

Tipo de datos
S71200/150
0

S7300/400/
WinAC

Ajuste prede‐ Descripción
terminado

ERROR

OUT

Bool

FALSE

TRUE durante un ciclo después de que la última petición
se haya ejecutado con errores

STATUS

OUT

Word

16#7000

Código de error (consulte Mensajes de error (Pági‐
na 4478))

Encontrará más información acerca de los parámetros generales en "Parámetros comunes
para las operaciones Freeport (Página 4451)".

Parámetros
Cuando una instrucción de transmisión se está procesando, las salidas DONE y ERROR están
en estado FALSE. Una vez finalizada una instrucción de transmisión, una de las salidas DONE
o ERROR se pone a TRUE durante un ciclo para notificar el estado de la instrucción de
transmisión. Si ERROR está en estado TRUE, puede evaluarse el código de error en la salida
STATUS.
La instrucción emite el estado 16#7001 si la interfaz de comunicación acepta los datos
transmitidos. Las ejecuciones posteriores de Send_P2P emiten el valor 16#7002 mientras el
CM sigue enviando. Tras finalizar la instrucción de transmisión, el CM emite el estado 16#0000
para la instrucción de transmisión (siempre que no se produzca ningún error). Las ejecuciones
posteriores de Send_P2P con REQ = 0 dan el estado 16#7000 (libre).
El diagrama siguiente muestra la relación entre los valores de salida y REQ. Se presupone que
la instrucción se llama cíclicamente para comprobar el estado del proceso de transmisión (se
representa mediante los valores de STATUS).

La figura siguiente muestra cómo los parámetros DONE y STATUS solo son válidos durante
un ciclo si en la línea REQ (durante un ciclo) hay un impulso para lanzar la instrucción de
transmisión.

La figura siguiente muestra la relación de los parámetros DONE, ERROR y STATUS en caso
de error.

Programación del PLC
Manual de programación y manejo, 11/2019

4467

Instrucciones
4.1 Instrucciones

Los valores de DONE, ERROR y STATUS son válidos únicamente hasta que Send_P2P se
ejecuta con el mismo DB de instancia.

Uso de los parámetros BUFFER y LENGTH en operaciones de comunicación
Interacción de los parámetros BUFFER y LENGTH para Send_P2P
El tamaño mínimo de los datos que puede enviar la instrucción Send_P2P es de un byte.
El parámetro BUFFER define el tamaño de los datos que deben enviarse si durante una
llamada se transfiere un "0" en el parámetro LENGTH. De ese modo basta con indicar una
variable.
Para el parámetro BUFFER no es posible utilizar el tipo de datos Bool ni matrices del tipo Bool.
Si se transfieren grandes cantidades de datos, se recomienda reflejarlo en los tipos de datos
Array o Struct.
Tabla 4-153 Parámetro BUFFER
BUFFER

Descripción

Tipo de datos simple

En el envío, se aplica lo siguiente: El valor LENGTH debe contener el número de bytes de este tipo
de datos.
Ejemplo: con un valor Word, LENGTH debe ser dos. Con un valor DWord o Real, LENGTH debe ser
cuatro.

Estructura

En relación con la memoria optimizada, se aplica lo siguiente: la longitud máxima permitida de
BUFFER es 1024 Byte; de lo contrario, se admiten hasta 4 kbytes en función del módulo.
En la transmisión se aplica lo siguiente: el valor de LENGTH puede contener un número de bytes
inferior a la longitud completa de bytes de la estructura; en este caso, solo se envían los primeros
bytes LENGTH de la estructura de BUFFER.

Array

En relación con la memoria optimizada, se aplica lo siguiente: Si el tipo de datos Array es diferente
de Byte, Word o DWord, la longitud máxima permitida del búfer es de 1024 Byte. Si la memoria no
está optimizada, pueden transferirse hasta 4 KB en función del módulo, independientemente de la
estructura de datos.
En el envío se aplica lo siguiente: el valor de LENGTH puede contener un número de bytes inferior
a la longitud completa de bytes de la matriz, siendo siempre un múltiplo del número de bytes del
elemento de datos. Ejemplo: el parámetro LENGTH de una matriz del tipo Word debe ser un múltiplo
de dos y, con una matriz del tipo Real, un múltiplo de cuatro.
Si se indica LENGTH, se transfiere el número de elementos de matriz. Si, por ejemplo, BUFFER
contiene una matriz con 15 elementos DWord (60 Bytes en total) y se indica LENGTH = 20, se
transfieren los cinco primeros elementos DWord de la matriz.

String

4468

El parámetro LENGTH contiene el número de caracteres que deben transmitirse. Solo se transmiten
los caracteres de String. Los bytes con la longitud máxima y real de String no se transmiten.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-154 Parámetro LENGTH
LENGTH

Descripción

=0

Se transfiere el contenido completo del área de memoria especificada mediante BUFFER.
Si BUFFER señala a un string, se transfiere todo el contenido del string sin los bytes con la longitud
máxima y real.

>0

Se transfiere el contenido hasta la longitud parametrizada del área de memoria especificada me‐
diante BUFFER.

Receive_P2P: recibir datos
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

Descripción
La instrucción Receive_P2P (datos recibidos mediante una comunicación punto a punto)
comprueba las tramas que se han recibido en el CM. Cuando hay una trama disponible, el CM
la transfiere a la CPU. Un error de recepción se indica en el parámetro STATUS.

Programación del PLC
Manual de programación y manejo, 11/2019

4469

Instrucciones
4.1 Instrucciones

Parámetros
Parámetro

Declara‐
ción

PORT

IN

Tipo de datos
S71200/150
0
PORT
(UInt)

S7300/400/
WinAC
Word

Ajuste prede‐
terminado

Descripción

0

Especifica el módulo de comunicación a través del cual se
produce la comunicación:
● para S7-1500/S7-1200: "Identificador de hardware" de
la configuración del dispositivo.
El nombre simbólico del puerto está asignado en la
ficha "Constantes de sistema" de la tabla de variables
PLC y puede adoptarse de ahí.
● para S7-300/S7-400: "Dirección de entrada" de la
configuración del dispositivo.
En los sistemas S7-300/400/WinAC se asigna al
parámetro PORT la dirección de entrada otorgada en
HWCN.

BUFFER

IN

Variant

Any

0

Este parámetro señala la dirección de inicio del búfer de
recepción. Este búfer debe ser lo suficientemente grande
como para recibir la longitud máxima de la trama.
Nota:
● No se soportan datos booleanos o campos booleanos.
● Si el búfer de recepción está en el área de memoria
optimizada, la máxima longitud admisible de datos
recibidos es de 1024 bytes.
Excepción: los arrays de Byte, Word o DWord se
soportan hasta una longitud de 4096 bytes.
● Si el búfer de recepción es de tipo String o WString, los
datos recibidos se escriben en el contenido del string,
y la longitud actual del string se ajusta de forma
correspondiente.
Más información en "Uso de los parámetros BUFFER y
LENGTH en operaciones de comunicación (Página 4468)"

LENGTH

OUT

UInt

Word

0

Longitud de la trama recibida en bytes
Más información en "Uso de los parámetros BUFFER y
LENGTH en operaciones de comunicación (Página 4468)"

NDR

OUT

Bool

COM_RST IN/OUT

---

Bool

FALSE

TRUE durante un ciclo cuando hay datos nuevos prepa‐
rados y la instrucción ha finalizado correctamente.

FALSE

Inicialización de la instrucción
La instrucción se inicializa con TRUE. Seguidamente, la
instrucción ajusta COM_RST de nuevo a FALSE.

ERROR

OUT

Bool

FALSE

TRUE durante un ciclo después de que la instrucción haya
finalizado con errores.

STATUS

OUT

Word

16#7000

Código de error (consulte Mensajes de error (Pági‐
na 4478))

Encontrará más información acerca de los parámetros generales en "Parámetros comunes
para las operaciones Freeport (Página 4451)".

4470

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si ERROR está en estado TRUE, puede evaluarse el código de error en la salida STATUS. El
valor de STATUS suministra el motivo para finalizar la operación de recepción en el CM.
Este suele ser un valor positivo que indica que la operación de recepción ha sido correcta y qué
criterio de fin de trama se ha detectado.
Si el valor de STATUS es negativo (se ha activado el bit más significativo del valor
hexadecimal), la operación de recepción ha finalizado debido a una condición de error, como
error de paridad, framing o desbordamiento.
Cada módulo de comunicaciones puede respaldar un número de tramas específico del
módulo. Si hay varias tramas disponibles en el CM, la instrucción Receive_P2P emite la más
antigua (FIFO).

Receive_Reset: borrar el búfer de recepción
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

Descripción
La instrucción Receive_Reset (resetear receptor) borra el búfer de recepción del CM.

Parámetros
Parámetro

Declara‐
ción

REQ

IN

PORT

IN

Tipo de datos
S71200/150
0

S7300/400/
WinAC

Bool
PORT
(UInt)

Word

Ajuste prede‐ Descripción
terminado

FALSE

Inicia la transferencia de datos al CM con un flanco as‐
cendente en esta entrada.

0

Especifica el módulo de comunicación a través del cual se
produce la comunicación:
● para S7-1500/S7-1200: "Identificador de hardware" de
la configuración del dispositivo.
El nombre simbólico del puerto está asignado en la
ficha "Constantes de sistema" de la tabla de variables
PLC y puede adoptarse de ahí.
● para S7-300/S7-400: "Dirección de entrada" de la
configuración del dispositivo.
En los sistemas S7-300/400/WinAC se asigna al
parámetro PORT la dirección de entrada otorgada en
HWCN.

COM_RST IN/OUT

---

Bool

FALSE

Inicialización de la instrucción
La instrucción se inicializa con TRUE. Seguidamente, la
instrucción ajusta COM_RST de nuevo a FALSE.

Programación del PLC
Manual de programación y manejo, 11/2019

4471

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción

Tipo de datos
S71200/150
0

S7300/400/
WinAC

Ajuste prede‐ Descripción
terminado

DONE

OUT

Bool

FALSE

TRUE durante un ciclo significa que la última petición se
ha ejecutado correctamente.

ERROR

OUT

Bool

FALSE

TRUE significa que la última petición se ha ejecutado con
errores. Si esta salida es TRUE, la salida STATUS con‐
tiene los códigos de error correspondientes.

STATUS

OUT

Word

16#7000

Código de error (consulte Mensajes de error (Pági‐
na 4478))

Encontrará más información acerca de los parámetros generales en "Parámetros comunes
para las operaciones Freeport (Página 4451)".

Signal_Get: leer estado
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

Descripción
La instrucción Signal_Get (consultar señales RS232) lee los estados actuales de las señales
cualificadoras RS232 y las muestra en las salidas correspondientes de la instrucción.
Nota
Limitación
● Esta instrucción solo puede utilizarse con los CM RS232 BA y RS232 HF.
● Si en el modo de operación está ajustado RS232C, esta instrucción también podrá
utilizarse con el CM PtP (ET200SP).

4472

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
Parámetro

Declara‐
ción

REQ

IN

PORT

IN

Tipo de datos
S71200/150
0

S7300/400/
WinAC

Bool
PORT
(UInt)

Word

Ajuste prede‐ Descripción
terminado

FALSE

Inicia la transferencia de datos al CM con un flanco as‐
cendente en esta entrada.

0

Especifica el módulo de comunicación a través del cual se
produce la comunicación:
● para S7-1500/S7-1200: "Identificador de hardware" de
la configuración del dispositivo.
El nombre simbólico del puerto está asignado en la
ficha "Constantes de sistema" de la tabla de variables
PLC y puede adoptarse de ahí.
● para S7-300/S7-400: "Dirección de entrada" de la
configuración del dispositivo.
En los sistemas S7-300/400/WinAC se asigna al
parámetro PORT la dirección de entrada otorgada en
HWCN.

NDR

OUT

Bool

FALSE

TRUE durante un ciclo cuando las señales cualificadoras
RS232 se han leído y la instrucción ha finalizado correc‐
tamente.

ERROR

OUT

Bool

FALSE

TRUE durante un ciclo después de que la instrucción haya
finalizado con errores.

STATUS

OUT

Word

16#7000

Código de error (consulte Mensajes de error (Pági‐
na 4478))

DTR

OUT

Bool

FALSE

Terminal de datos preparado, módulo disponible (salida)

DSR

OUT

Bool

FALSE

Terminal de datos preparado, dispositivo de comunica‐
ción preparado (entrada)

RTS

OUT

Bool

FALSE

petición de transmisión, módulo preparado para enviar
(salida)

CTS

OUT

Bool

FALSE

Listo para transmitir, el dispositivo de comunicación pue‐
de recibir datos (entrada)

DCD

OUT

Bool

FALSE

Señal del soporte de datos detectada, nivel de señal reci‐
bido

RING

OUT

Bool

FALSE

Indicador de llamada, aviso de una llamada entrante

Encontrará más información acerca de los parámetros generales en "Parámetros comunes
para las operaciones Freeport (Página 4451)".

Signal_Set: activar señales cualificadoras
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

Programación del PLC
Manual de programación y manejo, 11/2019

4473

Instrucciones
4.1 Instrucciones

Descripción
La instrucción Signal_Set (establecer señales RS232) permite establecer las señales de
comunicación RS232.
Nota
Limitaciones
● Esta instrucción solo puede utilizarse con los CM RS232 BA y RS232 HF.
● Si en el modo de operación está ajustado RS232C, esta instrucción también podrá
utilizarse con el CM PtP (ET200SP).

Parámetros
Parámetro

Declara‐
ción

REQ

IN

PORT

IN

Tipo de datos
S71200/150
0

S7300/400/
WinAC

Bool
PORT
(UInt)

Word

Ajuste prede‐ Descripción
terminado

FALSE

Inicia la instrucción con un flanco ascendente en esta en‐
trada.

0

Especifica el módulo de comunicación a través del cual se
produce la comunicación:
● para S7-1500/S7-1200: "Identificador de hardware" de
la configuración del dispositivo.
El nombre simbólico del puerto está asignado en la
ficha "Constantes de sistema" de la tabla de variables
PLC y puede adoptarse de ahí.
● para S7-300/S7-400: "Dirección de entrada" de la
configuración del dispositivo.
En los sistemas S7-300/400/WinAC se asigna al
parámetro PORT la dirección de entrada otorgada en
HWCN.

SIGNAL

IN

Byte

0

Selección de la señal que debe establecerse (se admiten
varias):
● 01H = RTS
● 02H = DTR
● 04H = DSR (solo válido para el tipo de interfaz DCE)

RTS

IN

Bool

FALSE

petición de transmisión, módulo preparado para enviar
Definir este valor en la salida (TRUE o FALSE), valor pre‐
determinado: FALSE

DTR

IN

Bool

FALSE

Terminal de datos preparado, módulo preparado
Definir este valor en la salida (TRUE o FALSE), valor pre‐
determinado: FALSE

DSR

IN

COM_RST IN/OUT

Bool
---

Bool

FALSE

Terminal de datos preparado (solo válido para el tipo de
interfaz DCE), no utilizado.

FALSE

Inicialización de la instrucción
La instrucción se inicializa con TRUE. Seguidamente, la
instrucción ajusta COM_RST de nuevo a FALSE.

4474

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción

Tipo de datos
S71200/150
0

S7300/400/
WinAC

Ajuste prede‐ Descripción
terminado

DONE

OUT

Bool

FALSE

TRUE durante un ciclo después de que la última petición
se haya ejecutado correctamente

ERROR

OUT

Bool

FALSE

TRUE durante un ciclo después de que la última petición
se haya ejecutado con errores

STATUS

OUT

Word

16#7000

Código de error (consulte Mensajes de error (Pági‐
na 4478))

Encontrará más información acerca de los parámetros generales en "Parámetros comunes
para las operaciones Freeport (Página 4451)".

Get_Features: obtener funciones avanzadas
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

Descripción
La instrucción Get_Features (obtener funciones avanzadas) permite consultar información
relacionada con la capacidad del módulo para soportar CRC y generar avisos de diagnóstico,
siempre que el módulo la soporte.

Parámetros
Parámetro

Declara‐
ción

REQ

IN

PORT

IN

Tipo de datos
S71200/15
00

S7300/400/
WinAC
Bool

PORT

Word

Ajuste pre‐
Descripción
determinado

FALSE

Inicia la instrucción con un flanco ascendente en esta en‐
trada.

0

Especifica el módulo de comunicación a través del cual se
produce la comunicación:
● para S7-1500/S7-1200: "Identificador de hardware" de
la configuración del dispositivo.
El nombre simbólico del puerto está asignado en la
ficha "Constantes de sistema" de la tabla de variables
PLC y puede adoptarse de ahí.
● para S7-300/S7-400: "Dirección de entrada" de la
configuración del dispositivo.
En los sistemas S7-300/400/WinAC se asigna al
parámetro PORT la dirección de entrada otorgada en
HWCN.

Programación del PLC
Manual de programación y manejo, 11/2019

4475

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción

Tipo de datos
S71200/15
00

S7300/400/
WinAC

Ajuste pre‐
Descripción
determinado

NDR

OUT

Bool

FALSE

TRUE durante un ciclo cuando hay datos nuevos prepa‐
rados y la instrucción ha finalizado correctamente

MOD‐
BUS_CRC

OUT

Bool

FALSE

Soporte de Modbus CRC

DIAG_ALA
RM

OUT

Bool

FALSE

Generación de avisos de diagnóstico

SUPPLY_V
OLT

OUT

Bool

FALSE

Diagnóstico disponible para Falta tensión de alimentación
L+

COM_RST

IN/OUT

---

Bool

FALSE

Inicialización de la instrucción
La instrucción se inicializa con TRUE. Seguidamente, la
instrucción ajusta COM_RST de nuevo a FALSE.

ERROR

OUT

Bool

FALSE

TRUE durante un ciclo después de que la instrucción haya
finalizado con errores.

STATUS

OUT

Word

16#7000

Código de error (consulte Mensajes de error (Pági‐
na 4478))

Encontrará más información acerca de los parámetros generales en "Parámetros comunes
para las operaciones Freeport (Página 4451)".

Set_Features: activar funciones avanzadas
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

Descripción
La instrucción Set_Features (seleccionar funciones avanzadas) permite activar la
compatibilidad con CRC y la generación de avisos de diagnóstico, siempre que el módulo la
soporte.

4476

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
Parámetro

Declara‐
ción

REQ

IN

PORT

IN

Tipo de datos
S71200/150
0

S7300/400/
WinAC

Bool
PORT
(UInt)

Word

Ajuste pre‐
determina‐
do

Descripción

FALSE

La instrucción para establecer funciones avanzadas
se inicia con un flanco ascendente en esta entrada.

0

Especifica el módulo de comunicación a través del
cual se produce la comunicación:
● para S7-1500/S7-1200: "Identificador de
hardware" de la configuración del dispositivo.
El nombre simbólico del puerto está asignado en la
ficha "Constantes de sistema" de la tabla de
variables PLC y puede adoptarse de ahí.
● para S7-300/S7-400: "Dirección de entrada" de la
configuración del dispositivo.
En los sistemas S7-300/400/WinAC se asigna al
parámetro PORT la dirección de entrada otorgada
en HWCN.

EN_MOD‐
BUS_CRC

IN

Bool

FALSE

Activar soporte de Modbus CRC

EN_DIAG_AL
ARM

IN

Bool

FALSE

Activar generación de avisos de diagnóstico

EN_SUPPLY_
VOLT

IN

Bool

FALSE

Activar diagnóstico para Falta tensión de alimentación
L+
Nota:
Los módulos de comunicación S7-1500 y ET 200MP
no soportan este diagnóstico. Esto es aplicable aun‐
que el parámetro se pueda activar en combinación
con, p. ej., MODBUS_CRC.

COM_RST

IN/OUT

---

Bool

FALSE

Inicialización de la instrucción
La instrucción se inicializa con TRUE. Seguidamente,
la instrucción ajusta COM_RST de nuevo a FALSE.

DONE

OUT

Bool

FALSE

TRUE durante una ejecución después de que la última
petición se haya ejecutado correctamente

ERROR

OUT

Bool

FALSE

TRUE durante un ciclo después de que la instrucción
haya finalizado con errores.

STATUS

OUT

Word

16#7000

Código de error (consulte Mensajes de error (Pági‐
na 4478))

Encontrará más información acerca de los parámetros generales en "Parámetros comunes
para las operaciones Freeport (Página 4451)".

Programación del PLC
Manual de programación y manejo, 11/2019

4477

Instrucciones
4.1 Instrucciones

Mensajes de error
Sinopsis de los mensajes de error PtP
Los mensajes de error se ponen a disposición en la salida STATUS de una instrucción y allí
pueden ser evaluados o procesados en el programa de usuario.
Código de
error

Descripción

Solución

16#0000

No hay error

‑

Estado de RECEIVE y códigos de error
16#0094

Fin de telegrama detectado por "recepción de una lon‐ ‑
gitud fija/máxima de telegrama"

16#0095

Fin de telegrama detectado por "tiempo de espera del
mensaje excedido"

‑

16#0096

Fin de telegrama detectado por fin del "tiempo de re‐
tardo de caracteres"

‑

16#0097

El telegrama se ha cancelado porque se ha alcanzado
el tiempo de respuesta máximo.

‑

16#0098

Fin de telegrama detectado por cumplirse las condi‐
ciones de "Leer longitud del mensaje en el mensaje"

‑

16#0099

Fin de telegrama detectado por recepción de la "se‐
cuencia de fin"

‑

Estado de SEND y códigos de error
16#7000

Bloque en vacío

‑

16#7001

Primera llamada para un nuevo telegrama: transferen‐ ‑
cia de datos iniciada

16#7002

Llamada intermedia: transferencia de datos en curso

‑

16#8085

Indicación de longitud no válida

Seleccione una longitud de telegrama adecuada.
Se admiten (en función del módulo):
1-1024/2048/4096 (Byte)

16#8088

Indicación de longitud mayor que el área ajustada en el
búfer de recepción.
Nota: En el caso de que en el parámetro BUFFER se
haya especificado el tipo de datos STRING, también
aparece este código de error si la longitud de String
actual es inferior al valor indicado en el parámetro
LENGTH.

16#8090

Error de configuración: número impar de bytes como
WString

Modifique el área en el búfer de recepción o seleccio‐
ne una longitud de telegrama adecuada al área ajus‐
tada en el búfer.
Se admiten (en función del módulo):
1-1024/2048/4096 (bytes)

Elija un número par de bytes.

Estado de RECEIVE y códigos de error
16#7001

Primera llamada para un nuevo telegrama: transferen‐ ‑
cia de datos iniciada

16#7002

Llamada intermedia: transferencia de datos en curso

‑

16#8088

El número de caracteres recibidos es superior al es‐
pecificado en el parámetro BUFFER.

Seleccione una longitud de telegrama adecuada.

Error de configuración: número impar de bytes como
WString

Elija un número par de bytes.

16#8090

4478

Se admiten (en función del módulo):
1-1024/2048/4096 (bytes)

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error

Descripción

Solución

Códigos de mensajes de error de las funciones especiales
16#818F

Ajuste erróneo del número de parámetro (solo en USS) Seleccione un número de parámetro adecuado (PA‐
RAM).
Se admiten: 0-2047

16#8190

Ajuste erróneo del cálculo CRC

Seleccione un valor adecuado para el cálculo CRC.
Se admiten: desactivado o activado.
Compruebe si el módulo direccionado soporta el cál‐
culo CRC.

16#8191

Ajuste erróneo de la alarma de diagnóstico

Seleccione un valor adecuado para "Alarma de diag‐
nóstico".
Se admiten: alarma de diagnóstico desactivada o
alarma de diagnóstico activada.
Compruebe si el módulo direccionado soporta la ge‐
neración de alarmas de diagnóstico.

16#8193

El módulo no soporta el diagnóstico de tensión de ali‐ Seleccione un valor adecuado para "Alarma de diag‐
mentación L+.
nóstico".
Se admiten: alarma de diagnóstico desactivada o
alarma de diagnóstico activada.
Compruebe si el módulo direccionado soporta la ge‐
neración de alarmas de diagnóstico.

Códigos de mensajes de error de la "Configuración del puerto"
16#81A0

El módulo no soporta este protocolo.

Seleccione un protocolo compatible con el módulo
(PROTOCOL).

16#81A1

El módulo no soporta esta velocidad de transferencia
de datos.

Seleccione una velocidad de transferencia de datos
compatible con el módulo (BAUD).

16#81A2

El módulo no soporta este ajuste de paridad.

Seleccione un valor adecuado para "Paridad" (PA‐
RITY).
Se admiten:
● Sin (1)
● Par (2)
● Impar (3)
● Mark (4)
● Space (5)
● Cualquiera (6)

16#81A3

El módulo no soporta este número de bits de datos.

Seleccione un valor adecuado para "Bits de datos"
(DATABITS).
Se admiten:
● 7 (2)
● 8 (1)

16#81A4

El módulo no soporta este número de bits de parada.

Seleccione un valor adecuado para "Bits de parada"
(STOPBITS).
Se admiten:
● 1 (1)
● 2 (2)

Programación del PLC
Manual de programación y manejo, 11/2019

4479

Instrucciones
4.1 Instrucciones
Código de
error

Descripción

Solución

16#81A5

El módulo no soporta este tipo de control del flujo de
datos.

Seleccione un control del flujo de datos compatible
con el módulo (FLOWCTRL).

16#81A7

Valor no admisible para XON o XOFF

Seleccione valores adecuados para XON (XON‐
CHAR) y XOFF (XOFFCHAR).

16#81AA

Modo de operación no admisible

Rango admisible: 0...255
Los modos de operación admitidos son:
● Dúplex (RS232) (0)
● Dúplex (RS422) modo a cuatro hilos (punto a
punto) (1)
● Dúplex (RS422) modo a cuatro hilos (maestro
multipunto) (2)/(CM PtP (ET 200SP))
● Dúplex (RS422) modo a cuatro hilos (esclavo
multipunto) (3)/(CM PtP (ET 200SP))
● Semidúplex (RS485) modo a dos hilos (4)
16#81AB

Estado inicial no admisible de la línea de recepción

Los estados iniciales admitidos son:
● "Sin" estado inicial (0)
● Señal R(A) = 5 V, señal R(B) = 0 V (detección
break) (1):
Solo disponible con: "Dúplex (RS422) modo a
cuatro hilos (acoplamiento punto a punto)" y
"Dúplex (RS422) modo a cuatro hilos (esclavo
multipunto)".
● Señal R(A) = 0 V, señal R(B) = 5 V (2): este estado
inicial corresponde al estado de reposo (ninguna
transmisión activa).

16#81AC

Valor no admisible para "Detección break"

Seleccione un valor adecuado para "Detección
break". Se admiten:
● Detección break desactivada (0)
● Detección break activada (1)

16#81AF

El módulo no soporta este protocolo.

Seleccione un protocolo compatible con el módulo.

Códigos de error de la "Configuración de transmisión"
16#81B5

Más de 2 caracteres de fin -o biensecuencia de fin > 5 caracteres

Seleccione valores adecuados para "Carácter de fin"
y "Secuencia de fin".
Se admiten:
● desactivado (0)
● 1 (1) o 2 (2) caracteres de fin
o bien:
● desactivado (0)
● de 1 (1) a 5 (5) caracteres para la secuencia de fin

16#81B6

Send Configuration rechazado porque está seleccio‐
nado el protocolo 3964(R)

Asegúrese de que no se envía ninguna configuración
de transmisión cuando esté ajustado el protocolo
3964(R).

Códigos de error de la "Configuración de recepción"

4480

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error

Descripción

Solución

16#81C0

Condición de inicio no admisible

Seleccione una condición de inicio adecuada.
Se admiten:
● Enviar break antes de iniciar el telegrama
● Enviar Idle Line.

16#81C1

Condición de fin no admisible o no se ha seleccionado
ninguna condición de fin

Seleccione una condición de fin adecuada (consulte
AUTOHOTSPOT).

16#81C3

Valor no admisible para "Longitud máxima del mensa‐ Seleccione un valor adecuado para "Longitud máxi‐
je"
ma del mensaje" (MAXLEN).
Rango admisible (en función del módulo):
1‑1024/2048/4096 (bytes)

16#81C4

Valor no admisible para "Offset de la longitud en el
mensaje"

Seleccione un valor adecuado para "Offset de la lon‐
gitud en el mensaje".
Rango admisible (en función del módulo):
1‑1024/2048/4096 (bytes)

16#81C5

Valor no admisible de "Tamaño del campo de longitud" Seleccione un valor adecuado para "Tamaño del
campo de longitud" (LENGTHSIZE).
Rango admisible en bytes:
● 1 (1)
● 2 (2)
● 4 (4)

16#81C6

Valor no admisible para "Número de caracteres que se
excluyen de la longitud"

16#81C7

La suma de "Offset del mensaje + tamaño del campo
de longitud + número de caracteres que se excluyen"
es mayor que la longitud máxima del telegrama

Seleccione un valor adecuado para "Número de ca‐
racteres que se excluyen de la longitud" (LENGTHM).
Rango admisible: de 0 a 255 (bytes)
Seleccione valores adecuados para "Offset del men‐
saje", "Tamaño del campo de longitud" y "Número de
caracteres excluidos".
Rango admisible:
● Offset del mensaje (en función del módulo):
0-1024/2048/4096 (bytes)
● Tamaño del campo de longitud: 1, 2 o 4 (bytes)
● Número de caracteres excluidos: 0-255 (bytes)

16#81C8

Valor no admisible para "Tiempo de respuesta excedi‐ Seleccione un valor adecuado para "Tiempo de res‐
do"
puesta excedido".
Rango admisible: 1-65535 (ms)

16#81C9

Valor no admisible para "Tiempo de retardo de carac‐ Seleccione un valor adecuado para "Tiempo de retar‐
teres"
do de caracteres".
Rango admisible: 1-65535 (tiempos de bit)

16#81CB

Secuencia de fin de telegrama activada, pero ninguno
de los caracteres está activado para la comprobación

Active uno o varios caracteres para la comprobación.

16#81CC

Secuencia de principio de telegrama activada, pero
ninguno de los caracteres está activado para la com‐
probación

Active uno o varios caracteres para la comprobación.

Programación del PLC
Manual de programación y manejo, 11/2019

4481

Instrucciones
4.1 Instrucciones
Código de
error

Descripción

Solución

16#81CD

Valor no admisible para "Impedir sobrescritura"

Seleccione un valor adecuado para "Impedir sobres‐
critura".
Se admiten:
● Impedir sobrescritura desactivado (0)
● Impedir sobrescritura activado (1)

16#81CE

Valor no admisible para "Borrar búfer de recepción al
arrancar"

Seleccione un valor adecuado para "Borrar búfer de
recepción al arrancar".
Se admiten:
● Borrar búfer de recepción al arrancar desactivado
(0)
● Borrar búfer de recepción al arrancar activado (1)

Estado de SEND y códigos de error
16#81D0

Recibir orden de transmisión durante el tiempo de eje‐ Asegúrese de que no se solicitan más transmisiones
cución de una orden de transmisión
durante el tiempo de ejecución de una orden de trans‐
misión.

16#81D1

El tiempo de espera a XON o CTS = ON ha transcurri‐ El interlocutor falla, es demasiado lento o está offline.
do.
Compruebe el interlocutor o modifique la parametri‐
zación en caso necesario.

16#81D2

"Hardware RTS siempre ON": orden de transmisión
cancelada por cambio de DSR = ON a OFF

Compruebe el interlocutor. Asegúrese de que DSR
está ON durante toda la transferencia.

16#81D3

Desbordamiento del búfer de transmisión / telegrama
de transmisión demasiado grande

Seleccione una longitud de telegrama menor.

16#81D5

Transferencia cancelada por cambio en la parametri‐
zación, detección de rotura de hilo o CPU en STOP

Compruebe la parametrización, rotura de hilo o el es‐
tado de la CPU.

16#81D6

Transferencia cancelada porque no se ha recibido el
delimitador de fin

Compruebe la parametrización de los caracteres de
fin y el telegrama del interlocutor.

16#81D7

Fallo de comunicación entre programa de usuario y
módulo

Compruebe la comunicación (p. ej. coincidencia del
número de secuencia).

16#81D8

Intento de transmisión rechazado porque el módulo no
está parametrizado

Parametrice el módulo.

16#81DF

El módulo ha inicializado la interfaz al FB por uno de
los motivos siguientes:

—

Se admiten (en función del módulo):
1-1024/2048/4096 (bytes)

● El módulo se ha rearrancado.
● El módulo se ha parametrizado nuevamente.
● STOP de la CPU
Códigos de error de la configuración de recepción
16#81E0

En el programa de usuario, llame la función de recep‐
Telegrama cancelado: desbordamiento del búfer de
recepción / telegrama de recepción demasiado grande ción con mayor frecuencia o parametrice una comu‐
nicación con control del flujo de datos.

16#81E1

Telegrama cancelado: error de paridad

4482

Compruebe la línea de conexión de los interlocutores
y asegúrese de que en ambos interlocutres esté ajus‐
tada la misma velocidad de transmisión, la misma pa‐
ridad y el mismo número de bits de parada.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error

Descripción

Solución

16#81E2

Telegrama cancelado: error de trama

Compruebe los ajustes de bit de inicio, bits de datos,
bit de paridad, velocidad de transferencia de datos y
bit(s) de parada.

16#81E3

Telegrama cancelado: error de desbordamiento de ca‐ Error de firmware: póngase en contacto con el Cus‐
racteres
tomer Support.

16#81E4

Telegrama cancelado: la longitud de "Offset del men‐ Compruebe los ajustes de offset en el mensaje, ta‐
saje + tamaño del campo de longitud + número de ca‐ maño del campo de longitud y número de caracteres
racteres excluidos" es mayor que el búfer de recepción excluidos.

16#81E5

Telegrama cancelado: break

La línea de recepción hacia el interlocutor está inte‐
rrumpida.
Restablezca la conexión o conecte el interlocutor.

16#81E6

Número máximo de "Tramas de recepción en búfer"
excedido

En el programa de usuario llame la instrucción con
más frecuencia o parametrice una comunicación con
control del flujo de datos, o bien aumente el número
de telegramas en búfer.

16#81E7

Error de sincronización entre módulo y Receive_P2P

Asegúrese de que no haya diferentes instancias de
Receive_P2P accediendo al mismo módulo.

16#81E8

Telegrama cancelado: tiempo de retardo de caracte‐
res transcurrido antes de detectar el criterio de fin del
mensaje

El interlocutor es demasiado lento o falla. Si fuese
necesario, utilice un dispositivo de comprobación de
interfaces que se conecte a la línea de transferencia.

16#81E9

Error de Modbus CRC (solo módulos de comunicacio‐ Error de suma de verificación del telegrama Modbus.
nes compatibles con Modbus)
Compruebe el interlocutor.

16#81EA

Telegrama Modbus demasiado corto (solo módulos de
comunicaciones compatibles con Modbus)

Rebase por defecto de la longitud mínima de la trama
Modbus. Compruebe el interlocutor.

16#81EB

Telegrama cancelado: longitud máxima de telegrama
alcanzada

Seleccione una longitud de telegrama menor en el
interlocutor.
Se admiten (en función del módulo):
1-1024/2048/4096 (bytes)
Compruebe los parámetros de detección de fin del
telegrama.

Códigos de error de las señales cualificadoras V24
16#81F0

El módulo no soporta señales cualificadoras V24

Ha intentado ajustar señales cualificadoras para un
módulo que no soporta señales cualificadoras V24.
Asegúrese de estar utilizando un módulo RS232 y de
que esté ajustado el modo RS232 (ET 200SP).

16#81F1

No es posible manejar las señales cualificadoras V24

Si el control del flujo de datos de hardware está activo
no es posible controlar manualmente las señales cua‐
lificadoras V24.

16#81F2

No se puede activar la señal DSR porque el módulo es
del tipo DTE.

Compruebe el tipo parametrizado del módulo.

No se puede ajustar la señal DSR porque el módulo es
del tipo DCE.

Compruebe el tipo parametrizado del módulo.

16#81F3

16#81F4

Error en el encabezado del bloque (p. ej. tipo o longitud
del bloque incorrecto)

El tipo de módulo debe ser del tipo DCE (data com‐
munication equipment).
El tipo de módulo debe ser del tipo DTE (data terminal
equipment).
Compruebe el DB de instancia y el encabezado del
bloque.

Códigos de error de la configuración de recepción

Programación del PLC
Manual de programación y manejo, 11/2019

4483

Instrucciones
4.1 Instrucciones
Código de
error

Descripción

16#8201 1)

Receive_Conditions señala a un tipo de datos no per‐ Introduzca un puntero hacia uno de los siguientes ti‐
mitido
pos de datos:
DB, BOOL, BYTE, CHAR, WORD, INT, DWORD,
DINT, REAL, DATE, TIME_OF_DAY, TIME, S5TIME,
DATE_AND_TIME, STRING

16#8225

Receive_Conditions señala al área de memoria opti‐
mizada mayor que 1 kbyte

Introduzca un puntero hacia un área con la longitud
máxima siguiente:

o bien

● Área de memoria optimizada: 1 KB

Receive_Conditions señala al área de memoria opti‐
mizada y la longitud de recepción es mayor que la del
área direccionada por Receive_Conditions.

● Área de memoria no optimizada: 4 KB

16#8229 1)

Receive_Conditions señala a BOOL con un número de
bits diferente de n * 8

Solución

Nota: Si el puntero señala a un área de memoria op‐
timizada, no envíe más de 1 KB.
Si utiliza un puntero hacia BOOL, el número de bits
debe ser un múltiplo de 8.

Códigos de error generales
16#8280

Acuse negativo al leer el módulo

Encontrará información más detallada sobre la causa
del error en los parámetros estáticos RDREC.STA‐
TUS, así como en la descripción del SFB RDREC.
● Compruebe la entrada en el parámetro PORT
● Ajuste el parámetro COM_RST antes de la 1.ª
llamada.

16#8281

Acuse negativo al escribir en el módulo

Compruebe la entrada en el parámetro PORT
Encontrará información más detallada sobre la causa
del error en los parámetros estáticos WRREC.STA‐
TUS, así como en la descripción del SFB WRREC.

16#8282

Módulo no disponible

Compruebe la entrada en el parámetro PORT y ase‐
gúrese de que el módulo está accesible.

Códigos de error de la configuración de recepción
16#82C1

Valor no admisible para "Tramas de recepción en bú‐
fer".

Seleccione un valor adecuado para "Tramas de re‐
cepción en búfer".
Rango admisible: 1-255

16#82C2

Receive Configuration rechazado porque está selec‐
cionado el protocolo 3964(R)

Asegúrese de que no se envía ninguna configuración
de recepción si está ajustado el protocolo 3964(R).

16#8301 1)

Receive_Conditions señala a un tipo de datos no per‐ Seleccione un tipo de datos compatible.
mitido
Se admiten: DB, BOOL, BYTE, CHAR, WORD, INT,
DWORD, DINT, REAL, DATE, TIME_OF_DAY, TI‐
ME, S5TIME, DATE_AND_TIME, STRING

16#8322

Error de longitud de área al leer un parámetro

Compruebe la entrada en el parámetro Receive_Con‐
ditions

16#8324

Error de área al leer un parámetro

Compruebe la entrada en el parámetro Receive_Con‐
ditions

16#8328

Error de ajuste al leer un parámetro

Compruebe la entrada en el parámetro Receive_Con‐
ditions

Estado de SEND y códigos de error
16#8328 1)

BUFFER señala a BOOL con un número de bits dife‐
rente de n * 8

Si utiliza un puntero hacia BOOL, el número de bits
debe ser un múltiplo de 8.

Códigos de error de la configuración de recepción

4484

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error

Descripción

Solución

16#8332

Bloque de datos no admisible en el parámetro Recei‐
ve_Conditions

Compruebe la entrada en el parámetro Receive_Con‐
ditions

16#833A

El nombre del bloque de datos del parámetro Recei‐
Compruebe la entrada en el parámetro Receive_Con‐
ve_Conditions señala un bloque de datos no cargado. ditions

16#8351

Tipo de datos no admisible

Compruebe la entrada en el parámetro Receive_Con‐
ditions

16#8352 1)

Receive_Conditions no señala un bloque de datos

Compruebe el puntero hacia Receive_Conditions

16#8353

Receive_Conditions no señala a una estructura del ti‐
po Receive_Conditions

Compruebe el puntero hacia Receive_Conditions

1)

Códigos de error del protocolo 3964(R)
16#8380

Error de parametrización: valor no admisible para
"Tiempo de retardo de caracteres".

Seleccione un valor adecuado para "Tiempo de retar‐
do de caracteres" (CharacterDelayTime).
Rango admisible: 1-65535 (ms)

16#8381

Error de parametrización: Valor no admisible para
"Tiempo de respuesta excedido".

16#8382

Error de parametrización: valor no admisible para
"Prioridad".

Seleccione un valor adecuado para "Tiempo de res‐
puesta excedido" (AcknDelayTime).
Rango admisible: 1-65535 (ms)
Seleccione un valor adecuado para "Prioridad" (Prio‐
rity).
Se admiten:
● Alta (1)
● Baja (0)

16#8383

Error de parametrización: valor no admisible para
"Comprobación de bloque"

Seleccione un valor adecuado para "Comprobación
de bloque" (BCC).
Se admiten:
● con comprobación de bloque (1)
● sin comprobación de bloque (0)

16#8384

Error de parametrización: valor no admisible para "In‐
tentos de establecer conexión".

Seleccione un valor adecuado para "Intentos de es‐
tablecer conexión" (BuildupAttempts).
Rango admisible: 1-255

16#8385

Error de parametrización: valor no admisible para "In‐
tentos de transmisión".

Seleccione un valor adecuado para "Intentos de trans‐
misión" (RepetitionAttempts).
Rango admisible: 1-255

16#8386

Error en tiempo de ejecución: se ha excedido el núme‐ Compruebe el cable de la interfaz y los parámetros de
ro de intentos de establecer conexión
transferencia.
Compruebe también que la función de recepción esté
correctamente parametrizada en el interlocutor.

16#8387

Error en tiempo de ejecución: se ha excedido el núme‐ Compruebe el cable de la interfaz, los parámetros de
ro de intentos de transmisión
transferencia y la parametrización del interlocutor.

16#8388

Error en tiempo de ejecución: error en el "Carácter de
comprobación de bloque"

Compruebe que la conexión no tenga fuertes interfe‐
rencias. De ser así, observará de vez en cuando có‐
El valor del carácter de control de bloque determinado digos de error. Si fuese necesario, verifique el com‐
internamente no concuerda con el recibido por el inter‐ portamiento correcto del dispositivo interlocutor con
un dispositivo de test de interfaz conectado a la línea
locutor al final de la conexión.
de transferencia.

Programación del PLC
Manual de programación y manejo, 11/2019

4485

Instrucciones
4.1 Instrucciones
Código de
error

Descripción

Solución

16#8389

Error en tiempo de ejecución: se ha recibido un carác‐ Cuando el búfer de recepción está vacío, se responde
ter no admisible mientras se esperaba un búfer de re‐ a la orden de transmisión del interlocutor (STX, 02H)
con DLE. Antes no se debe recibir ningún otro carác‐
cepción libre
ter (excepto STX de nuevo).
Si fuese necesario, verifique el comportamiento co‐
rrecto del dispositivo interlocutor con un dispositivo
de test de interfaz conectado a la línea de transferen‐
cia.

16#838A

16#838B

Tras la recepción de DLE se ha recibido otro carácter
cualquiera (salvo DLE, ETX).

Compruebe que el interlocutor no haya incluido el
DLE por duplicado en el encabezado del telegrama o
en la cadena de datos, y que la conexión se establez‐
ca con DLE ETX. Si fuese necesario, verifique el
comportamiento correcto del dispositivo interlocutor
con un dispositivo de test de interfaz conectado a la
línea de transferencia.

Error en tiempo de ejecución: tiempo de retardo de
caracteres excedido

El dispositivo interlocutor es demasiado lento o está
defectuoso.

Error en tiempo de ejecución: error lógico durante la
recepción.

Si fuese necesario, verifíquelo con un dispositivo de
test de interfaz conectado a la línea de transferencia.
16#838C

Error en tiempo de ejecución: se ha iniciado el tiempo
de espera a un búfer de recepción libre

En el programa de usuario llame la instrucción con
más frecuencia o parametrice una comunicación con
control del flujo de datos.

16#838D

Error en tiempo de ejecución: después de NAK, el te‐
legrama no se repite hasta transcurridos 4 s

Compruebe el interlocutor. Si un telegrama se recibe
con errores, el interlocutor debe repetirlo en un inter‐
valo de 4 segundos.

16#838E

Error en tiempo de ejecución: se han recibido uno o
más caracteres durante el estado de reposo (excepto
NAK y STX).

Verifique el comportamiento correcto del dispositivo
interlocutor si fuese necesario con un dispositivo de
test de interfaz conectado a la línea de transferencia.

16#838F

Error en tiempo de ejecución: conflicto de inicializa‐
ción; ambos interlocutores tienen ajustada una priori‐
dad alta

Ajuste una prioridad "baja" en uno de los interlocuto‐
res

16#8391

Error de parametrización: se han rechazado los datos
de parametrización 3964 porque está ajustado Free‐
port

Asegúrese de que no se envía ningún dato de para‐
metrización 3964 si está ajustado el protocolo Free‐
port.

Códigos de error generales
16#8FFF
1)

El módulo no está operativo temporalmente debido a
un reset.

Repita la consulta.

Solo en instrucciones para CPU S7-300/400

4486

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

USS
Dependencias entre las versiones de librerías
Utilice las librerías de instrucciones "USS" y "punto a punto" solo en una de las siguientes
combinaciones de versiones:
Versión de librería "USS"

Versión de librería "punto a punto"

V1.3

V1.1

V2.4

V2.4

V3.1

V2.4

V4.3

V3.2

Resumen de la comunicación USS
Comunicación USS
Las instrucciones USS controlan el funcionamiento de accionamientos que soportan el
protocolo de la interfaz serie universal (USS). Los módulos de comunicación PtP hacen posible
la comunicación con varios accionamientos a través de conexiones RS485 e instrucciones
USS. Cada puerto RS485 puede operar un máximo de 16 accionamientos.
El protocolo USS utiliza una red de maestros y esclavos para la comunicación a través de un
bus serie. El maestro utiliza un parámetro de dirección para enviar datos a un esclavo concreto.
Un esclavo no puede enviar nunca por sí mismo sin haber recibido previamente una solicitud.
La comunicación entre los diferentes esclavos no es posible. La comunicación USS funciona
en modo semidúplex. La figura siguiente muestra un diagrama de red para un ejemplo de
aplicación con 16 accionamientos.
1

2

&38

&0

3

               

①
②
③

CPU
CM

Accionamientos USS en una red USS
Figura 4-4
Ejemplo de interconexión con un módulo de comunicación S7-1500

Programación del PLC
Manual de programación y manejo, 11/2019

4487

Instrucciones
4.1 Instrucciones

Nota
Comunicación con un accionamiento mediante RS232
En principio, también es posible utilizar CM PtP RS232 BA y CM PtP RS232 HF para la
comunicación con un accionamiento. Sin embargo, solo es posible conectar un accionamiento
a un puerto RS232.
Comunicación con un accionamiento mediante RS422
En principio, también es posible utilizar la interfaz RS422 del CM PtP RS422/485 BA y CM PtP
RS422/485 HF para la comunicación con un accionamiento. Sin embargo, solo es posible
conectar un accionamiento a un puerto RS422.

Instrucciones USS en el programa
● USS_Port_Scan: la instrucción USS_Port_Scan permite la comunicación a través de un
módulo de comunicaciones con hasta 16 accionamientos, mediante una red USS (debe ser
llamada de forma cíclica).
En el programa solo hay una instrucción USS_Port_Scan por puerto de comunicación PtP
que controla la transferencia a todos los accionamientos.
● USS_Drive_Control: la instrucción USS_Drive_Control permite preparar los datos de
USS_Port_Scan para un accionamiento y mostrar los datos recibidos.
USS_Drive_Control configura los datos que deben enviarse y evalúa los datos recibidos por
USS_Port_Scan en una solicitud anterior.
● USS_Read_Param: la instrucción USS_Read_Param permite leer parámetros de un
accionamiento.
● USS_Write_Param: la instrucción USS_Write_Param permite modificar los parámetros de
un accionamiento.

4488

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Requisitos para utilizar el protocolo USS
Las cuatro instrucciones USS utilizan 2 FB y 2 FC para soportar el protocolo USS. Para cada
red USS se emplea un bloque de datos de instancia para USS_Port_Scan y un bloque de datos
de instancia común para todas las llamadas de USS_Drive_Conrol.
'%GHLQVWDQFLD
866B3RUWB6FDQ
'%GHLQVWDQFLD
866B'ULYHB&RQWURO
$FFWR

6HQGB33

0µGXORGH
FRPXQLFDFLRQHV
PDHVWUR

5HFHLYHB33
B&RQILJ

866B'ULYHB&RQWURO
$FFWR

866B'ULYHB&RQWURO
$FFWR

866
$FFWR
866
$FFWR
866
$FFWR

866B5HDGB3DUDP
866B:ULWHB3DUDP

Figura 4-5

Ejecución del programa - USS

Todos los accionamientos (máx. 16) que están conectados a un puerto RS485 forman parte de
la misma red USS. Todos los accionamientos que están conectados a otro puerto RS485
forman parte de otra red USS. Cada red USS se gestiona por medio de un bloque de datos de
instancia único para todas las instrucciones USS_Drive_Control y otro bloque de datos de
instancia para la instrucción USS_Port_Scan. Todas las instrucciones que forman parte de una
red USS deben utilizar conjuntamente el bloque de datos de instancia para USS_Drive_Conrol.
Para ello, las instrucciones USS_Port_Scan, USS_Read_Param y USS_Write_Param cuentan

Programación del PLC
Manual de programación y manejo, 11/2019

4489

Instrucciones
4.1 Instrucciones
con el parámetro USS_DB, que debe interconectarse con el parámetro (estático) USS_DB del
DB de instancia de la instrucción USS_Drive_Control.
● Las instrucciones USS_Drive_Control y USS_Port_Scan son bloques de función (FB). Si se
inserta la instrucción USS_Drive_Control o USS_Port_Scan en el editor de programación,
deberá asignarse un DB a este FB en el cuadro de diálogo "Opciones de llamada". Si se
trata de la primera instrucción USS_Drive_Control del programa para esta red USS, existe
la posibilidad de aplicar la asignación estándar de DB (o cambiar el nombre en caso
necesario) y el nuevo DB se creará automáticamente. Sin embargo, si no se trata de la
primera instrucción USS_Drive_Control para este accionamiento, es necesario seleccionar
en la lista desplegable del cuadro de diálogo "Opciones de llamada" el DB que se ha
asignado previamente a esta red USS.
● Las instrucciones USS_Write_Param y USS_Read_Param son funciones (FC). Si se
insertan estas FC en el editor, no se asignará ningún DB. Si se insertan estas FC o la
instrucción USS_Port_Scan en el editor, deberá asignarse a la entrada USS_DB de estas
instrucciones el parámetro USS_DB del DB de instancia correspondiente de
USS_Drive_Control. Haga doble clic en el campo de parámetros y pulse seguidamente el
icono para visualizar los DB disponibles. Introduzca un punto "." y seleccione el parámetro
USS_DB en la lista desplegable.
● La función USS_Port_Scan controla la comunicación entre la CPU y los accionamientos a
través del puerto de comunicación punto a punto RS485. Cada vez que se llama esta
función se procesa una comunicación con un accionamiento. El programa debe llamar esta
función con la suficiente rapidez como para que los accionamientos no notifiquen un rebase
de tiempo. Para garantizar un comportamiento temporal constante de la transmisión de
tramas, esta instrucción debe llamarse con un OB de alarma cíclica.
● La instrucción USS_Drive_Control proporciona al programa acceso a un accionamiento
concreto de la red USS. Sus entradas y salidas corresponden a los estados y las funciones
de control del accionamiento. Si hay 16 accionamientos en la red, USS_Drive_Control debe
llamarse 16 veces en el programa, es decir, una vez por accionamiento.
La instrucción USS_Drive_Control solo debería llamarse desde un OB cíclico.
● Con las funciones USS_Read_Param y USS_Write_Param se leen y escriben los
parámetros operativos del accionamiento. Dichos parámetros controlan el funcionamiento
interno del accionamiento. Encontrará una definición de estos parámetros en el manual del
accionamiento. El programa puede contener un número cualquiera de estas funciones,
aunque únicamente puede estar activa una orden de lectura o escritura para un
accionamiento. Las funciones USS_Read_Param y USS_Write_Param solo deben
llamarse desde el OB de ciclo de un programa principal.

4490

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

ATENCIÓN
Llamadas de las instrucciones USS
Llame USS_Drive_Control, USS_Read_Param y USS_Write_Param únicamente desde un
OB de ciclo del programa principal. La instrucción USS_Port_Scan puede llamarse desde
cualquier OB, aunque normalmente se llama desde un OB de alarma cíclica.
No utilice las instrucciones USS_Drive_Control, USS_Read_Param y USS_Write_Param en
un OB con una prioridad más alta que la instrucción USS_Port_Scan correspondiente. No
inserte USS_Port_Scan en el programa principal ni USS_Read_Param en un OB de alarma
cíclica, por ejemplo. Si la ejecución de USS_Port_Scan es interrumpida por otra instrucción,
pueden producirse errores imprevistos.
Nota
Valor de identificación del parámetro
Para los accionamientos es preciso configurar el uso de 4 palabras PKW.

Calcular el tiempo para la comunicación con el accionamiento
La comunicación con el accionamiento se lleva a cabo de forma asíncrona al ciclo de la CPU.
La CPU suele ejecutar varios ciclos antes de que finalice la comunicación con un
accionamiento.
Para que la vigilancia de tiempo parametrizada durante el accionamiento no responda, las
tramas de transmisión deben enviarse al accionamiento dentro de esta vigilancia de tiempo.
También debe incluirse el número de intentos si se requieren varios para completar la
transacción debido a errores de comunicación. De forma predeterminada, para el protocolo
USS se realizan hasta 2 intentos en cada transacción.
El intervalo máximo entre dos tramas de transmisión se calcula del siguiente modo:
N * (5 * tiempo de ciclo + tiempo de ejecución de tramas + timeout de la trama de recepción
máx.) * (número de intentos de transmisión)
N
Factor 5
Tiempo de ciclo
Tiempo de ejecución
de tramas
Número de intentos
de transmisión
Timeout de la trama
de recepción
Timeout de la trama
de recepción máx.

Programación del PLC
Manual de programación y manejo, 11/2019

Número de accionamientos en esta red
Para la transmisión y recepción de tramas se requieren 5 ciclos típi‐
camente.
Tiempo de ciclo máx. de los OB de alarma cíclica en los que se llama
la instrucción USS_Port_Scan.
Tiempo de ejecución de tramas = (número de caracteres por trama) *
(11 Bit por carácter) / (velocidad de transferencia en Bit/s)
Número de intentos + 1
RCVTIME (si no se recibe respuesta del accionamiento)
RCVTIME + MSGTIME (si poco antes de transcurrir RCVTIME se
recibe una respuesta incompleta y la vigilancia de MSGTIME finali‐
za o bien si al transcurrir RCVTIME aún hay una respuesta en proce‐
so, se prolonga el Timeout con el tiempo de MSGTIME)

4491

Instrucciones
4.1 Instrucciones
Para el "Timeout de la trama de recepción" se aplican los siguientes tiempos (ms):
Bits/s

115200

57600

38400

19200

9600

4800

2400

1200

Receive_Condi‐
tions.END.RCVTIME

25

29

33

56

72

100

100

100

Receive_Condi‐
tions.END.MSGTIME

25

29

33

56

72

124

240

460

Timeout de la trama de recepción máx. = (Receive_Conditions.END.RCVTIME (0,072 s) +
Receive_Conditions.END.MSGTIME (0,072 s))
Ejemplo:
5 accionamientos
Velocidad de transferencia de datos = 9600 bits/s
28 caracteres por trama
Tiempo de ciclo = 0,020 s
Número de intentos = 2
Intervalo = 5 * ((5*0,02) + ((1*28*11)/9600) + 0,072 + 0,072) * (2+1) = 4,14 (segundos)
La vigilancia de tiempo del accionamiento debe ajustarse a aprox. 4 segundos en este caso.

USS_Port_Scan / USS_Port_Scan_31: comunicación vía red USS
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.
Nota
Uso de la instrucción USS_Port_Scan_31
La instrucción USS_Port_Scan_31 solo puede usarse en una CPU S7-1500.

Descripción
La instrucción USS_Port_Scan procesa la comunicación a través de una red USS para un
máximo de 16 accionamientos.
La instrucción USS_Port_Scan_31 procesa la comunicación a través de una red USS para un
máximo de 31 accionamientos.
STEP 7 crea automáticamente un DB de instancia cuando se inserta la instrucción.

4492

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
Parámetro

PORT

Declaración

IN

Tipo de datos
S7-1200/1
500

S7-300/4
00/
WinAC

Port

Word

Estándar

Descripción

0

Especifica el módulo de comunicación a través del cual se
produce la comunicación:
● para S7-1500/S7-1200: "Identificador de hardware" de
la configuración del dispositivo.
El nombre simbólico del puerto está asignado en la
ficha "Constantes de sistema" de la tabla de variables
PLC y puede adoptarse de ahí.
● para S7-300/S7-400: "Dirección de entrada" de la
configuración del dispositivo.
En los sistemas S7-300/400/WinAC se asigna al
parámetro PORT la dirección de entrada otorgada en
HWCN.

BAUD

IN

DInt

9600

Velocidad de transferencia de datos para la comunicación
USS
Se admiten:
● 1200 bits/s
● 2400 bits/s
● 4800 bits/s
● 9600 bits/s
● 19200 bits/s
● 38400 bits/s
● 57600 bits/s
● 115200 bits/s

USS_DB

INOUT

COM_RST INOUT

USS_BASE

---

Bool

–

El parámetro USS_DB debe interconectarse con el pará‐
metro (estático) USS_DB del DB de instancia, que se crea
e inicializa cuando se inserta una instrucción USS_Dri‐
ve_Control / USS_Drive_Control_31 en el programa.

FALSE

Inicialización de la instrucción USS_Port_Scan /
USS_Port_Scan_31
Con TRUE se inicializa la instrucción. Seguidamente, la
instrucción ajusta COM_RST de nuevo a FALSE.
Nota:
El parámetro solo está disponible para instrucciones
S7-300/400.

ERROR

OUT

Bool

FALSE

Si es TRUE, la salida indica que se ha producido un error y
la salida STATUS es válida.
Si es necesario, compruebe además el valor de la variable
estática USS_DB. w_USSExtendedError en el DB de ins‐
tancia de la instrucción USS_Drive_Control / USS_Dri‐
ve_Control_31.

STATUS

OUT

Word

Programación del PLC
Manual de programación y manejo, 11/2019

0

Código de error (consulte Mensajes de error (Pági‐
na 4507)).

4493

Instrucciones
4.1 Instrucciones
Solo hay una instrucción USS_Port_Scan / USS_Port_Scan_31 por puerto de comunicación
PtP en el programa y cada llamada de dicha instrucción controla una transferencia hacia o
desde todos los accionamientos de esta red. Todas las funciones USS que están asignadas a
una red USS y a un puerto de comunicación PtP deben utilizar el mismo DB de instancia.
El programa debe ejecutar la instrucción USS_Port_Scan / USS_Port_Scan_31 tantas veces
como sea necesario para que no se produzca ningún timeout en el accionamiento (consulte
Requisitos para utilizar el protocolo USS (Página 4489) el apartado "Calcular el tiempo para la
comunicación con el accionamiento").
La instrucción USS_Port_Scan / USS_Port_Scan_31 se llama normalmente desde un OB de
alarma cíclica para impedir timeouts del accionamiento y tener disponibles las últimas
actualizaciones de datos USS para llamadas de USS_Drive_Control / USS_Drive_Control_31 .

Variables de bloques de datos de USS_Port_Scan / USS_Port_Scan_31
La tabla siguiente muestra las variables estáticas públicas del DB de instancia de
USS_Port_Scan / USS_Port_Scan_31 que pueden utilizarse en el programa.
Tabla 4-155 Variables estáticas en el DB de instancia
Variable

Tipo de da‐ Estándar
tos

Descripción

MODE

USInt

Modo de operación

4

Los modos de operación admitidos son:
● 0 = dúplex (RS232)
● 1 = dúplex (RS422) modo a cuatro hilos (punto a punto)
● 2 = dúplex (RS422) modo a cuatro hilos (maestro multipunto, CM PtP
(ET 200SP))
● 3 = dúplex (RS422) modo a cuatro hilos (esclavo multipunto, CM PtP
(ET 200SP))
● 4 = semidúplex (RS485) modo a dos hilos 1)
LINE_PRE

USInt

2

Estado inicial de la línea de recepción
Los estados iniciales admitidos son:
● 0 = "sin" asignación inicial 1)
● 1 = señal R(A) = 5 V, señal R(B) = 0 V (detección Break):
en este estado inicial es posible una detección de rotura (Break).
Solo disponible con: "Dúplex (RS422) modo a cuatro hilos (acoplamiento
punto a punto)" y "Dúplex (RS422) modo a cuatro hilos (esclavo multipunto)".
● 2 = señal R(A) = 0 V, señal R(B) = 5 V:
este estado inicial corresponde al estado de reposo (ninguna transmisión
activa). Con este estado inicial no es posible la detección de rotura (Break).

BRK_DET

USInt

0

Activar aviso de diagnóstico:
● 0 - no activado
● 1 - activado

RETRIES_MAX

SInt/Byte

2

Número de intentos cuando se producen errores de comunicación.
Este parámetro permite establecer el número de intentos de envío de una trama
de petición en el caso de que la trama de respuesta no se reciba dentro del
tiempo ajustado.

4494

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Variable

Tipo de da‐ Estándar
tos

Descripción

EN_DIAG_ALAR
M

Bool

Activar aviso de diagnóstico:

EN_SUPPLY_V
OLT

Bool

0

● 0 - no activado
● 1 - activado
0

Activar diagnóstico para Falta tensión de alimentación L+
● 0 - no activado
● 1 - activado

1)

Ajuste necesario si se utilizan cables PROFIBUS en CM 1241 para RS485

Aunque la versión 2.5 tiene exactamente tiene la misma funcionalidad que la versión 2.4, se ha
incrementado el número por motivos internos.

Versiones de la instrucción
USS_Port_Scan:
Aunque la versión 2.5 tiene exactamente tiene la misma funcionalidad que la versión 2.4, se ha
incrementado el número por motivos internos.
USS_Port_Scan_31:
Aunque la versión 1.2 tiene exactamente tiene la misma funcionalidad que la versión 1.1, se ha
incrementado el número por motivos internos.

USS_Drive_Control / USS_Drive_Control_31: Preparar y mostrar datos para el accionamiento
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.
Nota
Uso de la instrucción USS_Drive_Control_31
La instrucción USS_Drive_Control_31 solo puede usarse en una CPU S7-1500.

Descripción
La instrucción USS_Drive_Control prepara datos de transmisión para un máximo de 16
accionamientos y evalúa los datos de respuesta de estos.
La instrucción USS_Drive_Control_31 prepara datos de transmisión para un máximo de 31
accionamientos y evalúa los datos de respuesta de estos.
Para cada accionamiento debe utilizarse una instancia propia de la instrucción, y todas las
funciones USS que están asignadas a una red USS y a un puerto de comunicación PtP deben
utilizar el mismo bloque de datos de instancia. Debe introducirse el nombre del DB al insertar

Programación del PLC
Manual de programación y manejo, 11/2019

4495

Instrucciones
4.1 Instrucciones
la primera instrucción USS_Drive_Control / USS_Drive_Control_31. Seguidamente, hay que
remitir al DB que se ha creado al insertar la primera instrucción.
STEP 7 crea automáticamente el DB cuando se inserta la instrucción.

Parámetros
Parámetro

Declaración

Tipo de datos

Estándar

Descripción

S7S7-300/4
1200/1500
00/
WinAC
RUN

IN

Bool

FALSE

Bit de arranque del accionamiento: si este parámetro es
TRUE, la entrada hace posible el funcionamiento del accio‐
namiento con el número de revoluciones predeterminado.
Si RUN pasa a FALSE mientras el accionamiento está en
marcha, el motor se desacelera hasta pararse. Este com‐
portamiento difiere de la desconexión de la alimentación
(OFF2) y del frenado del motor (OFF3).

OFF2

IN

Bool

FALSE

Bit "Decelerar hasta parar": si este parámetro es FALSE,
este bit provoca la parada natural del accionamiento sin
frenar.

OFF3

IN

Bool

FALSE

Bit de parada rápida: si este parámetro es FALSE, este bit
provoca una parada rápida frenando el accionamiento.

F_ACK

IN

Bool

FALSE

Bit de acuse de error: con este bit se desactiva el bit de error
de un accionamiento. El bit se activa tras borrar el error, con
lo que el accionamiento detecta que el error anterior no de‐
be seguir notificándose.

DIR

IN

Bool

FALSE

Control de sentido del accionamiento: este bit se activa
cuando el accionamiento debe funcionar hacia delante
(cuando SPEED_SP es positivo, ver tabla "Interacción de
los parámetros SPEED_SP y DIR").

DRIVE

IN

USInt

Byte

1

Dirección del accionamiento: esta entrada es la dirección
del accionamiento USS. El rango válido está entre acciona‐
miento 1 y accionamiento 16.

PZD_LEN

IN

USInt

Byte

2

Longitud de palabra: es el número de palabras de datos
PZD. Los valores válidos son 2, 4, 6 u 8 palabras.

SPEED_S
P

IN

Real

0.0

Consigna de velocidad: es el número de revoluciones del
accionamiento proporcionalmente a la frecuencia configu‐
rada. Un valor positivo significa que el accionamiento fun‐
ciona hacia delante (si DIR es true). El rango válido es de
200,00 a -200,00.

CTRL3

IN

Word

0

Palabra de control 3: valor que se escribe en un parámetro
personalizable del accionamiento. Debe configurarse en el
accionamiento (parámetro opcional).

CTRL4

IN

Word

0

Palabra de control 4: valor que se escribe en un parámetro
personalizable del accionamiento. Debe configurarse en el
accionamiento (parámetro opcional).

CTRL5

IN

Word

0

Palabra de control 5: valor que se escribe en un parámetro
personalizable del accionamiento. Debe configurarse en el
accionamiento (parámetro opcional).

4496

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Estándar

Descripción

S7S7-300/4
1200/1500
00/
WinAC
CTRL6

IN

Word

0

Palabra de control 6: valor que se escribe en un parámetro
personalizable del accionamiento. Debe configurarse en el
accionamiento (parámetro opcional).

CTRL7

IN

Word

0

Palabra de control 7: valor que se escribe en un parámetro
personalizable del accionamiento. Debe configurarse en el
accionamiento (parámetro opcional).

CTRL8

IN

Word

0

Palabra de control 8: valor que se escribe en un parámetro
personalizable del accionamiento. Debe configurarse en el
accionamiento (parámetro opcional).

FALSE

Inicialización de la instrucción USS_Drive_Control /
USS_Drive_Control_31

COM_RST IN/OUT

---

Bool

Con TRUE se inicializa la instrucción. Seguidamente, la
instrucción ajusta COM_RST de nuevo a FALSE.
Nota:
El parámetro solo está disponible para instrucciones
S7-300/400.
NDR

OUT

Bool

FALSE

Datos nuevos preparados: si este parámetro es TRUE, el bit
notifica que en la salida hay preparados datos de una nueva
petición de comunicación.

ERROR

OUT

Bool

FALSE

Se ha producido un error: Si es TRUE, indica que se ha
producido un error y la salida STATUS es válida. Todas las
salidas restantes se ponen a cero en caso de error. Los
errores de comunicación solo se notifican en las salidas
ERROR y STATUS de la instrucción USS_Port_Scan /
USS_Port_Scan_31.

STATUS

OUT

Word

0

Código de error (consulte Mensajes de error (Página 4507)).

RUN_EN

OUT

Bool

FALSE

Servicio habilitado: este bit notifica si el accionamiento está
en marcha.

D_DIR

OUT

Bool

FALSE

Sentido del accionamiento: este bit notifica si el acciona‐
miento funciona hacia delante.
● FALSE – adelante
● TRUE – atrás

INHIBIT

OUT

Bool

FALSE

Accionamiento bloqueado: este bit notifica el estado del bit
de bloqueo para el accionamiento.
● FALSE – no bloqueado
● TRUE – bloqueado

FAULT

OUT

Bool

FALSE

Error en accionamiento: este bit notifica que en el acciona‐
miento se ha producido un error. Hay que eliminar el fallo y
activar el bit F_ACK para borrar este bit.

SPEED

OUT

Real

0.0

Valor real de velocidad del accionamiento (valor escalado
de STATUS 2 del accionamiento): es la velocidad del ac‐
cionamiento proporcionalmente a la velocidad configurada.

STATUS1

OUT

Word

0

STATUS 1 del accionamiento
Este valor contiene bits de estado fijos de un accionamiento.

Programación del PLC
Manual de programación y manejo, 11/2019

4497

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Estándar

Descripción

0

STATUS 3 del accionamiento

S7S7-300/4
1200/1500
00/
WinAC
STATUS3

OUT

Word

Este valor contiene una palabra de estado personalizable
del accionamiento.
STATUS4

OUT

Word

0

STATUS 4 del accionamiento
Este valor contiene una palabra de estado personalizable
del accionamiento.

STATUS5

OUT

Word

0

STATUS 5 del accionamiento
Este valor contiene una palabra de estado personalizable
del accionamiento.

STATUS6

OUT

Word

0

STATUS 6 del accionamiento
Este valor contiene una palabra de estado personalizable
del accionamiento.

STATUS7

OUT

Word

0

STATUS 7 del accionamiento
Este valor contiene una palabra de estado personalizable
del accionamiento.

STATUS8

OUT

Word

0

STATUS 8 del accionamiento
Este valor contiene una palabra de estado personalizable
del accionamiento.

Cuando USS_Drive_Control / USS_Drive_Control_31 se ejecuta por primera vez, el
accionamiento indicado por la dirección USS (parámetro DRIVE) se inicializa en el DB de
instancia. Al término de la inicialización, las instrucciones USS_Port_Scan /
USS_Port_Scan_31 posteriores pueden iniciar la comunicación con el accionamiento con este
número.
Si se cambia el número de accionamiento, la CPU debe ponerse primero a STOP y después
a RUN de nuevo para que se inicialice el DB de instancia. Los parámetros de entrada se
configuran en el búfer de transmisión USS y las salidas, si existen, se leen de un búfer de
respuesta "anterior" válido. USS_Drive_Control / USS_Drive_Control_31 configura solo los
datos que deben enviarse y evalúa los datos recibidos en una petición anterior.
El sentido de giro del accionamiento se controla desde la entrada D_IR (Bool) o mediante el
signo (positivo o negativo) de la entrada SPEED_SP (Real). La tabla siguiente explica cómo
funcionan estas entradas conjuntamente para especificar el sentido de giro del accionamiento,
suponiendo que el motor gira hacia delante.
Tabla 4-156 Interacción de los parámetros SPEED_SP y DIR

4498

SPEED_SP

DIR

Sentido de giro del accionamiento

Valor > 0

0

Atrás

Valor > 0

1

Adelante

Valor < 0

0

Adelante

Valor < 0

1

Atrás

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Variables de bloques de datos de USS_Drive_Control / USS_Drive_Control_31
La tabla siguiente muestra las variables estáticas públicas del DB de instancia de
USS_Drive_Control/ USS_Drive_Control_31 que pueden utilizarse en el programa.
Tabla 4-157 Variables estáticas en el DB de instancia
Variable

Tipo de da‐ Estándar
tos

Descripción

USS_DB. w_US‐
SExtendedError

Word

USS Drive Extended Error Code: valor específico del accionamiento

16#0

El significado del mensaje de error depende de qué instrucción ha
notificado antes un error (ERROR = TRUE). Se distinguen los siguientes casos:
● USS_Write_Param / USS_Write_Param_31: : el significado del código de
error figura en la descripción del accionamiento.
● USS_Read_Param / USS_Read_Param_31: : el significado del código de
error figura en la descripción del accionamiento.
● USS_Port_Scan / USS_Port_Scan_31: : número del accionamiento
afectado por el mensaje de error.

Versiones de la instrucción
USS_Drive_Control:
Aunque la versión 2.0 tiene exactamente tiene la misma funcionalidad que la versión 1.2, se ha
incrementado el número por motivos internos.
USS_Drive_Control_31:
Aunque la versión 2.0 tiene exactamente tiene la misma funcionalidad que la versión 1.0, se ha
incrementado el número por motivos internos.

USS_Read_Param / USS_Read_Param_31: leer datos del accionamiento
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.
Nota
Uso de la instrucción USS_Read_Param_31
La instrucción USS_Read_Param_31 solo puede usarse en una CPU S7-1500.

Descripción
La instrucción USS_Read_Param lee un parámetro de un accionamiento de como máximo 16.
La instrucción USS_Read_Param_31 lee un parámetro de un accionamiento de como máximo
31.

Programación del PLC
Manual de programación y manejo, 11/2019

4499

Instrucciones
4.1 Instrucciones
Todas las funciones USS que están asignadas a una red USS y a un puerto de comunicación
PtP deben utilizar el bloque de datos de instancia de la instrucción USS_Drive_Control /
USS_Drive_Control_31 . USS_Read_Param / USS_Read_Param_31 debe llamarse desde un
OB de ciclo del programa principal.

Parámetros
Parámetro

Declaración

Tipo de datos
S71200/1500

Estándar

Descripción

–

Con un flanco ascendente en REQ se genera una nueva
orden de lectura.

–

Dirección del accionamiento: DRIVE es la dirección del ac‐
cionamiento USS. El rango válido está entre accionamiento
1 y accionamiento 16.

S7300/400/
WinAC

REQ

IN

Bool

DRIVE

IN

PARAM

IN

UInt

–

Número de parámetro: PARAM indica el parámetro de ac‐
cionamiento que se escribe. El rango de este parámetro
está entre 0 y 2047. En algunos accionamientos se puede
acceder a valores de parámetro superiores a 2047 por me‐
dio del byte más significativo del parámetro INDEX. Encon‐
trará más información sobre el acceso a un rango ampliado
en el manual del accionamiento.

INDEX

IN

UInt

–

Índice de parámetro: INDEX indica el índice de parámetro
del accionamiento en el que debe escribirse. Es un valor de
16 bits en el que el byte menos significativo es el valor real
del índice, con un rango de (0 a 255). El byte más signifi‐
cativo también puede ser utilizado por el accionamiento y
es específico del mismo. Encontrará más información en el
manual del accionamiento.

USS_DB

INOUT

USS_BASE

–

El parámetro USS_DB debe interconectarse con el pará‐
metro (estático) USS_DB del DB de instancia, que se crea
e inicializa cuando se inserta una instrucción USS_Dri‐
ve_Control / USS_Drive_Control_31 en el programa.

DONE1

OUT

Bool

FALSE

Si este parámetro es TRUE, en la salida VALUE está pen‐
diente el valor previamente solicitado para el parámetro de
lectura. Este bit se activa cuando la instrucción USS_Dri‐
ve_Control / USS_Drive_Control_31 detecta la respuesta
de lectura del accionamiento. Este bit se inicializará con la
siguiente llamada de USS_Read_Param / USS_Read_Pa‐
ram_31 .

ERROR

OUT

Bool

FALSE

ERROR = TRUE: se ha producido un error y la salida STA‐
TUS es válida. Todas las salidas restantes se ponen a cero
en caso de error. Los errores de comunicación solo se no‐
tifican en las salidas ERROR y STATUS de la instrucción
USS_Port_Scan / USS_Port_Scan_31.

USInt

Byte

Si es necesario, compruebe además el valor de la variable
estática USS_DB. w_USSExtendedError en el DB de ins‐
tancia de la instrucción USS_Drive_Control / USS_Dri‐
ve_Control_31.

4500

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos
S71200/1500

1

STATUS

OUT

VALUE

OUT

Estándar

Descripción

0

Código de error (consulte Mensajes de error (Pági‐
na 4507)).

–

Es el valor del parámetro que se ha leído y solo es válido si
el bit DONE es true.

S7300/400/
WinAC

UInt
Variant

Any

(Word, Int,
UInt,
DWord,
DInt,
UDInt,
Real)

(Word,
Int,
DWord,
DInt,
Real)

El bit DONE indica que se han leído datos válidos del accionamiento de motor referenciado y se han suministrado a la CPU.
No hace referencia al hecho de que la instrucción está preparada para leer inmediatamente otro parámetro. Una orden de
lectura vacía debe enviarse al accionamiento del motor y también debe ser acusada por la instrucción antes de que se
habilite el canal de parámetros para que sea utilizado por el accionamiento correspondiente. La llamada inmediata de
USS_Read_Param / USS_Read_Param_31 o USS_Write_Param / USS_Write_Param_31 para el accionamiento de motor
específico provoca el error 16#818A.

Versiones de la instrucción
USS_Read_Param:
Aunque la versión 1.5 tiene exactamente tiene la misma funcionalidad que la versión 1.4, se ha
incrementado el número por motivos internos.
USS_Read_Param_31:
Aunque la versión 1.1 tiene exactamente tiene la misma funcionalidad que la versión 1.0, se ha
incrementado el número por motivos internos.

USS_Write_Param / USS_Write_Param_31: modificar datos del accionamiento
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.
Nota
Uso de la instrucción USS_Write_Param_31
La instrucción USS_Write_Param_31 solo puede usarse en una CPU S7-1500.
Nota
Para instrucciones de escritura EEPROM (EEPROM en un accionamiento USS) se aplica lo
siguiente:
Mantenga en un número reducido las operaciones de escritura EEPROM para garantizar una
larga vida útil del EEPROM.

Programación del PLC
Manual de programación y manejo, 11/2019

4501

Instrucciones
4.1 Instrucciones

Descripción
La instrucción USS_Write_Param modifica un parámetro de un accionamiento de como
máximo 16.
La instrucción USS_Write_Param_31 modifica un parámetro de un accionamiento de como
máximo 31.
Todas las funciones USS que están asignadas a una red USS y a un puerto de comunicación
PtP deben utilizar el bloque de datos de instancia del USS_Drive_Control /
USS_Drive_Control_31.
USS_Write_Param / USS_Write_Param_31 debe llamarse desde el OB de ciclo de un
programa principal.

Parámetros
Tabla 4-158 Tipos de datos de los parámetros
Parámetro

Declaración

Tipo de datos

Estándar

Descripción

–

Con un flanco ascendente en REQ se genera una nueva
orden de escritura.

–

Dirección del accionamiento: DRIVE es la dirección del ac‐
cionamiento USS. El rango válido está entre accionamien‐
to 1 y accionamiento 16.

S7S7-300/40
1200/1500
0/
WinAC
REQ

IN

DRIVE

IN

PARAM

IN

UInt

–

Número de parámetro: PARAM indica el parámetro de ac‐
cionamiento que se escribe. El rango de este parámetro
está entre 0 y 2047. En algunos accionamientos se puede
acceder a valores de parámetro superiores a 2047 por me‐
dio del byte más significativo del parámetro INDEX. En‐
contrará más información sobre el acceso a un rango am‐
pliado en el manual del accionamiento.

INDEX

IN

UInt

–

Índice de parámetro: INDEX indica el índice de parámetro
del accionamiento en el que debe escribirse. Es un valor de
16 bits en el que el byte menos significativo es el valor real
del índice, con un rango de (0 a 255). El byte más signifi‐
cativo también puede ser utilizado por el accionamiento y
es específico del mismo. Encontrará más información en el
manual del accionamiento.

EEPROM

IN

Bool

–

Guardar en el EEPROM del accionamiento: si es TRUE, la
transacción de un parámetro para escribir en el acciona‐
miento se guarda en el EEPROM del accionamiento. Si es
FALSE, el valor escrito solo se guarda temporalmente y se
perderá la próxima vez que se conecte el accionamiento.

VALUE

IN

–

Valor del parámetro en el que debe escribirse. Debe ser
válido con un flanco ascendente de REQ.

4502

Bool
USInt

Byte

Variant

Any

(Word, Int,
UInt,
DWord,
DInt,
UDInt,
Real)

(Word,
Int,
DWord,
DInt, Real)

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Estándar

Descripción

–

El parámetro USS_DB debe interconectarse con el pará‐
metro (estático) USS_DB del DB de instancia, que se crea
e inicializa cuando se inserta una instrucción USS_Dri‐
ve_Control / USS_Drive_Control_31 en el programa.

S7S7-300/40
1200/1500
0/
WinAC
USS_DB

INOUT

USS_BASE

DONE1

OUT

Bool

FALSE

Si es TRUE, la entrada VALUE se ha escrito en el accio‐
namiento. Este bit se activa cuando la instrucción USS_Dri‐
ve_Control / USS_Drive_Control_31 detecta la respuesta
de escritura del accionamiento. Este bit se inicializará con
la siguiente llamada de USS_Write_Param / USS_Wri‐
te_Param_31.

ERROR

OUT

Bool

FALSE

Si es TRUE, se ha producido un error y la salida STATUS
es válida. Todas las salidas restantes se ponen a cero en
caso de error. Los errores de comunicación solo se notifi‐
can en las salidas ERROR y STATUS de la instrucción
USS_Port_Scan / USS_Port_Scan_31 .
Si es necesario, compruebe además el valor de la variable
estática USS_DB. w_USSExtendedError en el DB de ins‐
tancia de la instrucción USS_Drive_Control / USS_Dri‐
ve_Control_31.

STATUS
1

OUT

UInt

0

Código de error (consulte Mensajes de error (Pági‐
na 4507)).

El bit DONE indica que se han leído datos válidos del accionamiento de motor referenciado y se han suministrado a la CPU.
No hace referencia al hecho de que la librería USS está preparada para leer inmediatamente otro parámetro. Una orden de
escritura vacía debe enviarse al accionamiento del motor y también debe ser acusada por la instrucción antes de que se
habilite el canal de parámetros para que sea utilizado por el accionamiento correspondiente. La llamada inmediata de
USS_Read_Param / USS_Read_Param_31 o USS_Write_Param / USS_Write_Param_31 FC para el accionamiento de
motor específico provoca el error 0x818A.

Versiones de la instrucción
USS_Write_Param:
Aunque la versión 1.6 tiene exactamente tiene la misma funcionalidad que la versión 1.5, se ha
incrementado el número por motivos internos.
USS_Write_Param_31:
Aunque la versión 1.1 tiene exactamente tiene la misma funcionalidad que la versión 1.0, se ha
incrementado el número por motivos internos.

Programación del PLC
Manual de programación y manejo, 11/2019

4503

Instrucciones
4.1 Instrucciones

Información general sobre el dispositivo de accionamiento
Requisitos para la configuración del accionamiento
● Para los accionamientos debe configurar el uso de 4 palabras PKW
(Parameterkennungswert o valor de identificación de parámetro).
● Configure los accionamientos para 2, 4, 6 u 8 palabras PZD (Prozessdatenbereich o rango
de datos de proceso).
● Procure que el número de palabras PZD en el accionamiento se corresponda con la
entrada PZD_LEN de la instrucción USS_Drive_Control del accionamiento.
● Procure que la velocidad de transferencia de todos los accionamientos se corresponda con
la entrada BAUD de la instrucción USS_Port_Scan.
● Procure que el accionamiento esté configurado para la comunicación USS.
● Asegúrese de que se haya determinado en el accionamiento que la consigna de frecuencia
se proporcione a través de la interfaz USS.
● Asegúrese de que la dirección del accionamiento esté definida (rangos: 1-16).
Esta dirección debe corresponderse con la entrada DRIVE en el bloque USS_Drive_Control
del accionamiento.
● Asegúrese de que la red RS485 esté correctamente cerrada.

Conexión y configuración del accionamiento SINAMICS V20
Un ejemplo de aplicación para el funcionamiento de un SINAMICS V20 en una S7-1200 se
puede consultar en Internet. (http://support.automation.siemens.com/WW/view/es/63696870)

Conexión del accionamiento SINAMICS V20
Ejemplo de conexión de un accionamiento SIEMENS G120(C) a una red USS. Encontrará
ejemplos de conexión para otros accionamientos en el manual del correspondiente
accionamiento.
La conexión de un accionamiento SINAMICS G120(C) a la red USS se realiza a través de un
conector. La conexión es resistente a cortocircuitos y está aislada galvánicamente.

1

0 V potencial de referencia

2

RS485N, recepción y transmisión (-)

3

RS485N, recepción y transmisión (+)

4

Pantalla del cable

5
No utilizado
Figura 4-6
Conexión USS

4504

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

ATENCIÓN
Diferentes tensiones de referencia
Si se conectan entre sí dispositivos que no tienen la misma tensión de referencia, pueden
producirse intensidades no deseadas en el cable de conexión. Estas intensidades no
deseadas pueden provocar errores de comunicación o daños materiales en los dispositivos.
Asegúrese de que todos los dispositivos que estén conectados entre sí a través de un cable
de comunicación tengan el mismo conductor de referencia en el circuito o bien estén
separados eléctricamente para que no se produzcan intensidades no deseadas.
Asegúrese de que la pantalla esté conectada a masa o al pin 1 del conector de bus del
accionamiento.
Asegúrese de que el borne de cableado 2 (GND) del G120(C) esté conectado a masa.
En caso de que el maestro RS485 (p. ej., una CPU S7-1200 con módulo de comunicaciones
CM1241) esté conectado a través de un conector PROFIBUS, los cables de bus deben
tenderse como sigue:

A1
B1

Figura 4-7

A2
B2

Conexión del módulo de comunicaciones

Si el maestro RS485 es un dispositivo terminador de red o si se tiene una conexión punto a
punto, deben utilizarse los bornes A1 y B1 (no A2 y B2) del conector PROFIBUS, porque dichos
bornes permiten los ajustes de terminación (p. ej. en el conector DP 6ES7972‑0BB52‑0XA0).
En caso de que el G120(C) esté configurado como dispositivo terminador de red, debe ajustar
el interruptor para la resistencia terminadora de bus en "ON".
&RQHFWRU56SDUDOD
FRPXQLFDFLµQDWUDY«VGH
VLVWHPDVGHEXVGHFDPSR
,QWHUUXSWRUSDUD
UHVLVWHQFLDWHUPLQDGRUD

Figura 4-8

Conexión del dispositivo terminador

Programación del PLC
Manual de programación y manejo, 11/2019

4505

Instrucciones
4.1 Instrucciones

Configuración de un accionamiento G120(C)
Antes de conectar un accionamiento al S7-1500 o al ET 200SP, hay que asegurarse de que se
dispone de los siguientes parámetros de sistema.
Paso
1

Instrucción

Instrucciones de servicio
G120 1)

G120C 2)

Cap. 4.4.3

Cap. 6.4.1

Cap. 6.2.2.1

Cap. 8.4.2.1

En los pasos siguientes, con el BOP-2 se accede directamente a parámetros
seleccionando sus números y modificando sus valores.

Cap. 4.4.2

Cap. 6.4.2

Adapte los siguientes parámetros de convertidor de su aplicación relativos a la
comunicación:

Cap. 6.2.2.2

Cap. 8.4.2.1

Efectúe una puesta en marcha básica del accionamiento con el panel de ope‐
rador BOP-2.
El convertidor ofrece diferentes asignaciones predefinidas (macros) para sus
entradas y salidas y la interfaz del bus de campo. Elija en el 9.º paso de la puesta
en marcha básica (MAC PAR p15) la macro 21 para la comunicación USS. Con
ello estarán también predefinidos los siguientes parámetros:
● Velocidad de transferencia (p2020): 38400 bits/s
● Número de PZD (p2022): 2
● Número de PKW (p2023): variable
Nota:
La puesta en marcha básica también se puede ejecutar con el software de
puesta en marcha STARTER o con SINAMICS Startdrive.

2

Defina la dirección de USS del convertidor a través del interruptor de dirección
de la Control Unit del G120 o del G120(C).
● Área de direcciones válida: 1 … 30
Nota:
La dirección USS también se puede ajustar a través del parámetro p2021 o a
través de STARTER o de SINAMICS Startdrive.

3

● Velocidad de transferencia (p2020), siempre que sea ≠ 38400 bits/s
(Preste atención a la concordancia con el parámetro BAUD de la instrucción
de comunicación USS_Port_Scan.)
● Número de PZD (p2022), siempre que sea ≠ 2
(Preste atención a la concordancia con el parámetro PZD_LEN de la
instrucción de comunicación USS_Drive_Control.)
● Número de PKW (p2023) = 4
(Modifique a "4" el valor ajustado por defecto a través de la macro 21 a
"variable" (127) (las instrucciones USS_Read_Param y USS_Write_Param lo
requieren.)
● Bus de campo SS Tiempo de vigilancia [ms] (p2040)
4

Defina el origen para la consigna de velocidad.
● Selec n_cons (p1000[0]) = 6
(La consigna de velocidad se proporciona a través del bus USS.)

4506

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Paso

Instrucción

Instrucciones de servicio
G120 1)

5

G120C 2)

Ajuste la magnitud de referencia para la velocidad y la frecuencia.
● n_ref f_ref (p2000) = (6.00 min-1 hasta 210000.00 min-1)
(Todas las velocidades o frecuencias indicadas como relativas se refieren a esta
magnitud de referencia. La magnitud de referencia corresponde al 100% o a
4000hex (Palabra) o 4000 0000hex (Palabra doble). En ese caso:
fmagnitud ref (en Hz) = nmagnitud ref (en ((min-1) / 60) x número de pares de polos))

6

Transfiera los parámetros a la memoria no volátil.
● Guardar par (p0971) = 1

1) G120 (http://support.automation.siemens.com/CN/view/es/62089662)
2) G120(C) (http://support.automation.siemens.com/WW/view/es/61462568)

Mensajes de error
Sinopsis de los mensajes de error USS
Código de
error

Descripción

Solución

16#0000

No hay error

‑

16#8180

Error de longitud en la respuesta del accionamiento

Compruebe el telegrama de respuesta del acciona‐
miento.

16#8181

Error del tipo de datos

Compruebe el parámetro VALUE.

Error de número de parámetro

Rango admisible del parámetro PARAM: de 0 a 2047

16#8182

Error del tipo de datos: no se permite devolver "palabra
doble" o "real" a la orden de "palabra".

Compruebe el telegrama de respuesta del acciona‐
miento.

16#8183

Error del tipo de datos: no se permite devolver "pala‐
bra" a la orden de "palabra doble" o "real".

Compruebe el telegrama de respuesta del acciona‐
miento.

16#8184

Error de suma de verificación en la respuesta del ac‐
cionamiento

Compruebe el accionamiento y la conexión de comu‐
nicación.

16#8185

Error de direccionamiento

Rango de direcciones admisible del accionamiento:
de 1 a 16

16#8186

Error de consigna

Rango de consignas admisible: de -200 % a +200 %

16#8187

Devolución de número de accionamiento erróneo

Compruebe el telegrama de respuesta del acciona‐
miento.

16#8188

Longitud de PZD no admisible

Longitudes de PZD admisibles: 2, 4, 6 u 8 palabras

16#8189

El módulo no soporta esta velocidad de transferencia
de datos.

Seleccione una velocidad de transferencia de datos
compatible con el módulo.

16#818A

Para este accionamiento está activa otra orden.

Repita la orden de lectura o de escritura de paráme‐
tros más tarde.

16#818B

El accionamiento no responde.

Compruebe el accionamiento.

Programación del PLC
Manual de programación y manejo, 11/2019

4507

Instrucciones
4.1 Instrucciones
Código de
error

Descripción

Solución

16#818C

El accionamiento responde a una consulta de paráme‐ Compruebe el telegrama de respuesta del acciona‐
tros con un mensaje de error.
miento.
Compruebe la consulta de parámetros.
Compruebe si las instrucciones USS_Read_Param,
USS_Write_Param o USS_Port_Scan han notificado
un error. En caso afirmativo, compruebe el valor de
las variables estáticas USS_DB. w_USSExtendedE‐
rror de la instrucción USS_Drive_Control.

16#818D

El accionamiento responde a una consulta de paráme‐ Compruebe el telegrama de respuesta del acciona‐
tros con un error de acceso.
miento.

16#818E

El accionamiento no se ha inicializado.

Compruebe el programa de usuario y asegúrese de
que se llama la instrucción USS_Drive_Control para
este accionamiento.

16#8280

Acuse negativo al leer el módulo

Compruebe la entrada en el parámetro PORT.

Compruebe la consulta de parámetros.

Encontrará información más detallada sobre la causa
del error en los parámetros estáticos Port_Con‐
fig.RDREC.STATUS, Send_Config.RDREC.STA‐
TUS , Receive_Config.RDREC.STATUS ,
Send_P2P.RDREC.STATUS o Recei‐
ve_P2P.RDREC.STATUS, así como en la descrip‐
ción del SFB RDREC.
16#8281

Acuse negativo al escribir en el módulo

Compruebe la entrada en el parámetro PORT.
Encontrará información más detallada sobre la causa
del error en los parámetros estáticos Port_Con‐
fig.WRREC.STATUS, Send_Config.WRREC.STA‐
TUS , Receive_Config.WRREC.STATUS ,
Send_P2P.RDREC.STATUS o Recei‐
ve_P2P.RDREC.STATUS, así como en la descrip‐
ción del SFB WRREC.

Códigos de error generales
16#8FFF
1)

El módulo no está operativo temporalmente debido a
un reset.

Repita la consulta.

Solo en instrucciones para CPU S7-300/400

MODBUS (RTU)
Dependencias entre las versiones de librerías
Utilice las librerías de instrucciones "MODBUS (RTU)" y "punto a punto" solo en una de las
siguientes combinaciones de versiones:

4508

Versión de librería "MODBUS (RTU)"

Versión de librería "punto a punto"

V1.1

V1.1

V2.1

V2.4

V3.1

V2.4

V4.4

V3.2

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Resumen de la comunicación Modbus RTU
Comunicación Modbus RTU
Modbus RTU (Remote Terminal Unit) es un protocolo estándar para la comunicación en la red
y utiliza la conexión RS232 o RS422/485 para la transferencia de datos serie entre dispositivos
Modbus de la red.
Modbus RTU utiliza una red de maestro/esclavos en la que toda la comunicación sale de un
solo dispositivo maestro, mientras que los esclavos simplemente reaccionan a la solicitud del
maestro. El maestro envía una solicitud a una dirección de esclavo y solo responde al comando
el esclavo con dicha dirección de esclavo.
Caso especial: la dirección de esclavo Modbus 0 envía una trama Broadcast (difusión) a todos
los esclavos (sin respuesta del esclavo).

Códigos de función Modbus
● Una CPU que se utiliza como maestro Modbus RTU puede leer y escribir datos y estados
E/S en un esclavo Modbus RTU conectado por medio de una conexión de comunicación.
● Una CPU que se utiliza como esclavo Modbus RTU permite a un maestro Modbus RTU
conectado por medio de una conexión de comunicación leer y escribir datos y estados E/S
en la propia CPU.
Tabla 4-159 Funciones para leer datos: leer datos de programa y E/S descentralizadas
Código de función Modbus

Funciones para lectura de datos del esclavo (servidor) - direccionamien‐
to estándar

01

Leer bits de salida: 1 hasta 2000/19921) bits por solicitud

02

Leer bits de entrada: 1 hasta 2000/19921) bits por solicitud

03

Leer registro de paradas: 1 hasta 125/1241) palabras por solicitud

04

Leer palabras de entrada: 1 hasta 125/1241) palabras por solicitud

1) Con direccionamiento avanzado

Tabla 4-160 Funciones para escribir datos: escribir E/S descentralizadas y modificar datos de programa
Código de función Modbus

Funciones para escritura de datos en el esclavo (servidor) - direcciona‐
miento estándar

05

Escribir un bit de salida: 1 bit por solicitud

06

Escribir un registro de paradas: 1 palabra por solicitud

15

Escribir uno o varios bits de salida: 1 a 1960 bits por solicitud

16

Escribir uno o varios registros de paradas: 1 a 122 palabras por solicitud

● Los códigos de función Modbus 08 y 11 ofrecen posibilidades de diagnóstico para la
comunicación con el dispositivo esclavo.
● La dirección de esclavo Modbus 0 envía una trama Broadcast (de difusión) a todos los
esclavos (sin respuesta del esclavo; para códigos de función 5, 6, 15, 16).

Programación del PLC
Manual de programación y manejo, 11/2019

4509

Instrucciones
4.1 Instrucciones
Tabla 4-161 Direcciones de estación en la red Modbus
Estación
Equipo RTU

Dirección
Dirección de estación estándar

1 a 247 , así como 0 para Broadcast

Dirección de estación avanzada

1 a 65535, así como 0 para Broadcast

Direcciones de memoria Modbus
El número de direcciones de memoria Modbus (direcciones de entrada/salida) realmente
disponibles se rige por la variante de CPU y la memoria de trabajo disponible.

Instrucciones Modbus RTU en el programa
● Modbus_Comm_Load: es necesario ejecutar Modbus_Comm_Load para establecer
parámetros PtP como velocidad de transferencia de datos, paridad y control del flujo de
datos. Una vez se ha configurado el módulo de comunicación para el protocolo Modbus
RTU, solo pueden utilizarlo la instrucción Modbus_Master o la instrucción Modbus_Slave.
● Modbus_Master: con la instrucción de maestro Modbus es posible utilizar la CPU como
dispositivo maestro Modbus RTU para la comunicación con uno o varios dispositivos
esclavos Modbus.
● Modbus_Slave: con la instrucción de esclavo Modbus es posible utilizar la CPU como
dispositivo esclavo Modbus RTU para la comunicación con un dispositivo maestro Modbus.

Modbus_Comm_Load: configurar un módulo de comunicaciones para Modbus
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

Descripción
La instrucción Modbus_Comm_Load configura un módulo de comunicaciones para la
comunicación a través del protocolo Modbus RTU. Si se inserta la instrucción
Modbus_Comm_Load en el programa, se asigna automáticamente un bloque de datos de
instancia.
Los cambios de configuración de Modbus_Comm_Load no se guardan en la CPU sino en el
CM. Al restablecerse la tensión y al desenchufar/enchufar, el CM se parametriza con los datos
guardados en la configuración de dispositivos. En estos casos debe volverse a llamar la
instrucción Modbus_Comm_Load.

4510

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro
Parámetro

Declara‐
ción

REQ

IN

PORT

IN

Tipo de datos
S71200/150
0

S7300/400/
WinAC

Bool
Port

Estándar Descripción

Word

FALSE

Inicia la instrucción con un flanco ascendente en esta en‐
trada.

0

Especifica el módulo de comunicación a través del cual se
produce la comunicación:
● para S7-1500/S7-1200: "Identificador de hardware" de
la configuración del dispositivo.
El nombre simbólico del puerto está asignado en la ficha
"Constantes de sistema" de la tabla de variables PLC y
puede adoptarse de ahí.
● para S7-300/S7-400: "Dirección de entrada" de la
configuración del dispositivo.
En los sistemas S7-300/400/WinAC se asigna al
parámetro PORT la dirección de entrada otorgada en
HWCN.

BAUD

IN

UDInt

DInt

9600

Selección de la velocidad de transferencia de datos
Los valores admisibles son: 300, 600, 1200, 2400, 4800,
9600, 19200, 38400, 57600, 76800, 115200 bit/s.

PARITY

IN

UInt

Word

0

Selección de la paridad:
● 0 – ninguna
● 1 – impar
● 2 – par

FLOW_CTR
L

IN

UInt

Word

0

Selección del control del flujo:
● 0 – (estándar) no hay control del flujo
● 1 – control del flujo de hardware con RTS siempre ON
(no es válido para CM RS422/485)
● 2 – control del flujo de hardware con RTS con protocolo
de intercambio (no es válido para CM RS422/485)

RTS_ON_D
LY

IN

UInt

Word

0

Selección del retardo a la conexión RTS:
● 0 – no hay retardo de "RTS activo" hasta que se envía el
primer carácter de la trama.
● 1 a 65535 – retardo en milisegundos de "RTS activo"
hasta que se envía el primer carácter de la trama (no es
válido para CM RS422/485). Los retardos RTS deben
aplicarse independientemente de la selección
FLOW_CTRL.

Programación del PLC
Manual de programación y manejo, 11/2019

4511

Instrucciones
4.1 Instrucciones
Parámetro

Declara‐
ción

RTS_OFF_D IN
LY

Tipo de datos
S71200/150
0
UInt

Estándar Descripción

S7300/400/
WinAC
Word

0

Selección del retardo a la desconexión RTS:
● 0 – no hay retardo tras la transferencia del último
carácter hasta "RTS inactivo"
● 1 a 65535 – retardo en milisegundos desde la
transferencia del último carácter hasta "RTS inactivo"
(no es válido para puertos RS422/485). Los retardos
RTS deben aplicarse independientemente de la
selección FLOW_CTRL.

RESP_TO

IN

UInt

Word

1000

Timeout de respuesta:
5 ms a 65535 ms - tiempo en milisegundos que Mod‐
bus_Master espera una respuesta del esclavo. Si el esclavo
no responde durante este período, Modbus_Master repite la
petición o la finaliza con un error una vez que se ha enviado
el número indicado de repeticiones (ver abajo, parámetro
RETRIES).

MB_DB

IN/OUT

MB_BASE

‑

Una referencia al bloque de datos de instancia de las ins‐
trucciones Modbus_Master o Modbus_Slave.
El parámetro MB_DB debe interconectarse con el paráme‐
tro MB_DB (estático y, por tanto, no visible en la instrucción)
de la instrucción Modbus_Master o Modbus_Slave .

COM_RST

IN/OUT

---

Bool

FALSE

Inicialización de la instrucción Modbus_Comm_Load
La instrucción se inicializa con TRUE. Seguidamente, la
instrucción ajusta COM_RST de nuevo a FALSE.
Nota:
El parámetro solo está disponible para instrucciones
S7-300/400.

DONE

OUT

Bool

FALSE

El bit DONE es TRUE durante un ciclo después de que se
haya ejecutado correctamente la última orden.

ERROR

OUT

Bool

FALSE

El bit ERROR es TRUE durante un ciclo después de que la
última orden haya finalizado con errores. El código de error
del parámetro STATUS solo es válido en el ciclo en que
ERROR = TRUE.

STATUS

OUT

Word

16#7000

Código de error (consulte Mensajes de error (Página 4538))

Modbus_Comm_Load se ejecuta para configurar un puerto para el protocolo Modbus RTU.
Una vez se ha configurado un puerto para el protocolo Modbus RTU, solo pueden utilizarlo la
instrucción Modbus_Master o Modbus_Slave.
Para la configuración de cada puerto de comunicación utilizado para la comunicación Modbus
debe utilizarse una ejecución de Modbus_Comm_Load. Hay que asignar un DB de instancia
Modbus_Comm_Load unívoco a cada puerto utilizado. Posteriormente, solo debe volver a
ejecutarse Modbus_Comm_Load cuando deban modificarse parámetros de comunicación
como velocidad de transferencia de datos o paridad, así como tras restablecerse la red, en
caso necesario.
Si se inserta, p. ej., Modbus_Master o Modbus_Slave en el programa, se asigna
automáticamente un bloque de datos de instancia a la instrucción. Debe interconectar el

4512

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
parámetro MB_DB de la instrucción Modbus_Comm_Load con el parámetro MB_DB de la
instrucción Modbus_Master o Modbus_Slave.

Variables de bloques de datos de Modbus_Comm_Load
La tabla siguiente muestra las variables estáticas públicas del DB de instancia de
Modbus_Comm_Load que pueden utilizarse en el programa.
Tabla 4-162 Variables estáticas en el DB de instancia
Variable

Tipo de datos
S71200/150
0

Están‐
dar

Descripción

S7300/400/
WinAC

ICHAR_GAP

Word

0

Tiempo de retardo de caracteres máximo entre caracteres. Este pará‐
metro se indica en milisegundos y sirve para aumentar el período pre‐
visto entre los caracteres recibidos. El número correspondiente de
tiempos de bit para este parámetro se suma al valor estándar Modbus
de 35 tiempos de bit (3,5 tiempos de carácter).

RETRIES

Word

2

Número de intentos repetidos que lleva a cabo el maestro antes de
devolver el código de error 0x80C8 para "sin respuesta".

EN_SUPPLY_V
OLT

Bool

0

Activar diagnóstico para Falta tensión de alimentación L+

0

Modo de operación

MODE

USInt

Byte

Los modos de operación admitidos son:
● 0 = dúplex (RS232)
● 1 = dúplex (RS422) modo a cuatro hilos (punto a punto)
● 2 = dúplex (RS422) modo a cuatro hilos (maestro multipunto, CM
PtP (ET 200SP))
● 3 = dúplex (RS422) modo a cuatro hilos (esclavo multipunto, CM
PtP (ET 200SP))
● 4 = semidúplex (RS485) modo a dos hilos 1)
LINE_PRE

USInt

Byte

0

Estado inicial de la línea de recepción
Los estados iniciales admitidos son:
● 0 = "sin" asignación inicial 1)
● 1 = señal R(A) = 5 V, señal R(B) = 0 V (detección Break):
en este estado inicial es posible una detección de rotura (Break).
Solo disponible con: "Dúplex (RS422) modo a cuatro hilos
(acoplamiento punto a punto)" y "Dúplex (RS422) modo a cuatro
hilos (esclavo multipunto)".
● 2 = señal R(A) = 0 V, señal R(B) = 5 V:
este estado inicial corresponde al estado de reposo (ninguna
transmisión activa). Con este estado inicial no es posible la
detección de rotura (Break).

Programación del PLC
Manual de programación y manejo, 11/2019

4513

Instrucciones
4.1 Instrucciones
Variable

BRK_DET

Tipo de datos
S71200/150
0

S7300/400/
WinAC

USInt

Byte

Están‐
dar

Descripción

0

Detección break
Se admiten:
● 0 = detección Break desactivada
● 1 = detección Break activada

EN_DIAG_ALAR
M

Bool

0

Activar aviso de diagnóstico:
● 0 - no activado
● 1 - activado

STOP_BITS

USINT

Byte

1

N.º de bits parada
● 1 = 1 bit de parada,
● 2 = 2 bits de parada,
● 0, 3 a 255 = reservado

1)

Ajuste necesario si se utilizan cables PROFIBUS en CM 1241 para RS485

Versiones de la instrucción
Aunque la versión 3.1 tiene exactamente tiene la misma funcionalidad que la versión 3.0, se ha
incrementado el número por motivos internos.

Modbus_Master: comunicarse como maestro Modbus
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

Descripción
La instrucción Modbus_Master se comunica en calidad de maestro Modbus a través de un
puerto configurado con la instrucción Modbus_Comm_Load. Si se inserta la instrucción
Modbus_Master en el programa, se asigna automáticamente un bloque de datos de instancia.
El parámetro MB_DB de la instrucción Modbus_Comm_Load debe interconectarse con el
parámetro MB_DB (estático) de la instrucción Modbus_Master .
Nota
Para un DB de instancia de la instrucción Modbus_Master no está permitido activar la
remanencia (Retain).

4514

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
Parámetro

Declaración

Tipo de datos
S71200/1500

REQ

IN

MB_ADDR IN

Descripción

FALSE

FALSE = no hay orden
TRUE = orden de enviar datos al esclavo Modbus

‑

Dirección de estación Modbus RTU:

S7300/400/
WinAC

Bool
UInt

Estándar

Word

Área de direccionamiento estándar (1 a 247 y 0 para Broad‐
cast)
Área de direccionamiento ampliada (1 a 65535 y 0 para
Broadcast)
El valor 0 está reservado para el Broadcast (difusión) de
una trama a todos los esclavos Modbus. Para el Broadcast
(difusión) solo se soportan los códigos de función Modbus
05, 06, 15 y 16.
MODE

IN

USInt

Byte

0

Selección de modo: indica el tipo de orden (lectura, escri‐
tura o diagnóstico). Encontrará más información en la tabla
de las funciones Modbus más adelante.

DA‐
TA_ADDR

IN

UDInt

DWord

0

Dirección inicial en el esclavo: indica la dirección inicial de
los datos a los que debe accederse en el esclavo Modbus.
Encontrará las direcciones válidas en la tabla de las fun‐
ciones Modbus más adelante.

DA‐
TA_LEN

IN

UInt

Word

0

Longitud de datos: indica el número de bits o palabras a los
que debe acceder esta orden. Encontrará las longitudes
válidas en la tabla de las funciones Modbus más adelante.

---

Bool

FALSE

COM_RST IN/OUT

Inicialización de la instrucción Modbus_Master
Con TRUE se inicializa la instrucción. Seguidamente, la
instrucción ajusta COM_RST de nuevo a FALSE.
Nota:
El parámetro solo está disponible para instrucciones
S7-300/400.

DA‐
TA_PTR

IN/OUT

Variant

Any

‑

Puntero de datos: apunta a la dirección de marca o DB de
los datos que deben escribirse o leerse.
A partir de la versión de la instrucción V3.0:
El parámetro puede apuntar también a un área de memoria
optimizada. En el área de memoria optimizada puede ha‐
ber un elemento single o un array con los siguientes tipos
de datos: Bool, Byte, Char, Word, Int, DWord, DInt, Real,
USInt, UInt, UDInt, SInt, WChar. Cualquier otro tipo de da‐
tos da lugar al mensaje de error 16#818C.

DONE

OUT

Bool

FALSE

El bit DONE es TRUE durante un ciclo después de que se
haya ejecutado correctamente la última orden.

BUSY

OUT

Bool

‑

● FALSE – no hay órdenes activas para Modbus_Master
● TRUE – se está procesando una orden para
Modbus_Master

Programación del PLC
Manual de programación y manejo, 11/2019

4515

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos
S71200/1500

Estándar

Descripción

S7300/400/
WinAC

ERROR

OUT

Bool

FALSE

El bit ERROR es TRUE durante un ciclo después de que la
última orden haya finalizado con errores. El código de error
del parámetro STATUS solo es válido en el ciclo en que
ERROR = TRUE.

STATUS

OUT

Word

0

Código de error (consulte Mensajes de error (Página 4538))

Variables en el bloque de datos del maestro Modbus
La tabla siguiente muestra las variables estáticas públicas del DB de instancia de
Modbus_Master que pueden utilizarse en el programa.
Tabla 4-163 Variables estáticas en el DB de instancia
Variable

Tipo de
datos

Estándar

Descripción

Blocked_Proc_Timeout

Real

3.0

Tiempo (en segundos) que debe esperarse una instancia bloquea‐
da del maestro Modbus antes de que esta se elimine como ACTIVA.
Esto puede suceder, por ejemplo, cuando se ha emitido una orden
de maestro y, seguidamente, el programa deja de llamar la función
del maestro antes de que la orden haya finalizado por completo. El
valor de tiempo debe ser mayor que 0 y menor que 55 segundos, de
lo contrario se produce un error.
Ver también los apartados "Reglas para la comunicación del Mod‐
bus-Master" y "Llamada de la instrucción Modbus_Master con dife‐
rentes ajustes de parámetros".

Extended_Addressing

Bool

FALSE

Configura la dirección de estación del esclavo como byte único o
doble.
● FALSE = dirección de un byte; 0 a 247
● TRUE = dirección de dos bytes (corresponde al
direccionamiento avanzado);
0 a 65535

4516

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Variable

Tipo de
datos

Estándar

Descripción

Compatibility_Mode 1)

Bool

FALSE

Modo de compatibilidad con CP 341, CP 441-2 y ET 200S 1Sl con
driver para Modbus RTU y con ET 200S 1SI para Modbus.
El valor predeterminado es 0.
● FALSE = según especificación Modbus, no compatible
● TRUE = compatible

MB_DB

1)

MB_BA‐
SE

-

–

Con FC1 y FC2 se aplica lo siguiente: Los datos leídos en la
trama de recepción se escriben palabra por palabra en la
memoria direccionada de la CPU y se sustituyen byte por
byte.
Si el número de bits que deben transmitirse no es múltiplo de
16, los bits no relevantes de la última palabra se ponen a
cero.

–

Con FC15 se aplica lo siguiente: Las palabras que deben
transmitirse se leen una a una en la memoria direccionada y
se escriben byte por byte en la trama de transmisión.
Si el número de bits que deben transmitirse no es múltiplo de
8, los bits no relevantes del último byte se leen sin cambios
en la memoria direccionada y se insertan en la trama de
transmisión.

El parámetro MB_DB de la instrucción Modbus_Comm_Load debe
conectarse con el parámetro MB_DB de la instrucción Modbus_Mas‐
ter.

Los módulos de comunicación PtP se comportan según la especificación Modbus. Para que Modbus se comporte como en
los CP 341, CP 441‑2 y ET 200SP 1SI , utilice el parámetro "Compatibility_Mode".

El programa puede escribir valores en las variables Blocked_Proc_Timeout y
Extended_Addressing para controlar las operaciones del maestro Modbus.

Reglas para la comunicación del Modbus-Master
● Modbus_Comm_Load debe ejecutarse para configurar un puerto con el fin de que la
instrucción Modbus_Master pueda comunicarse con dicho puerto.
● Si debe utilizarse un puerto como Modbus Master, Modbus_Slave no debe utilizar este
puerto. Con este puerto pueden utilizarse una o varias instancias de Modbus_Master 1). Sin
embargo, todas las ejecuciones de Modbus_Master deben utilizar el mismo DB de instancia
para el puerto.
● Las instrucciones Modbus no utilizan eventos de alarma de la comunicación para controlar
el proceso de comunicación. El programa debe consultar la instrucción Modbus_Master si
hay órdenes terminadas (DONE, ERROR).
● Se recomienda llamar todas las ejecuciones de Modbus_Master para un puerto concreto
desde un OB de ciclo de programa. Las instrucciones de maestro Modbus solo pueden
ejecutarse en cada caso en un ciclo de programa o bien en un nivel de procesamiento
cíclico/controlado por tiempo. No deben procesarse en distintos niveles de procesamiento.
La interrupción de preferencia de una instrucción de maestro Modbus por otra instrucción
de maestro Modbus en un nivel de procesamiento con mayor prioridad provoca un
funcionamiento incorrecto. Las instrucciones de maestro Modbus no deben procesarse en
niveles de arranque, diagnóstico o errores de tiempo.

Programación del PLC
Manual de programación y manejo, 11/2019

4517

Instrucciones
4.1 Instrucciones
El concepto "instancia de maestro Modbus" significa en este caso una llamada de la
instrucción Modbus_Master con la misma interconexión que una instrucción
Modbus_Comm_Load y el mismo ajuste para los parámetros MB_ADDR, MODE,
DATA_ADDR y DATA_LEN .

1)

Ejemplo.
Modbus_Master se llama con MODE=0 y DATA_ADDR=10
Esta orden está activa hasta que finaliza con DONE=1 o ERROR=1 o hasta que ha
transcurrido la vigilancia de tiempo parametrizada en el parámetro Blocked_Proc_Timeout . Si
una vez finalizada la vigilancia de tiempo se inicia una nueva orden antes de que la orden
anterior haya finalizado, la orden anterior se cancelará sin mensaje de error.
En caso de que se produzca una segunda llamada de la instrucción con los mismos datos de
instancia pero con ajustes distintos en los parámetros MODE y DATA_ADDR mientras se esté
ejecutando la orden, esta segunda llamada finalizará con ERROR=1 y STATUS=8200.

Llamada de la instrucción Modbus_Master con diferentes ajustes de parámetros
Si en el programa deben disponerse varias llamadas de la instrucción Modbus_Master con
distintos ajustes para MB_ADDR, MODE, DATA_ADDR o DATA_LEN , debe asegurarse de
que no haya más de una llamada activa a la vez, ya que, de lo contrario, se emitirá el mensaje
de error 16#8200 (la interfaz está ocupada por una orden en curso).
Si el procesamiento de la llamada no puede completarse, se activará la vigilancia de tiempo a
través del parámetro Blocked_Proc_Timeout y se cancelará la orden en curso.

Parámetro REQ
FALSE = no hay orden; TRUE = orden de enviar datos al esclavo Modbus
Habilitación de la transferencia solicitada. Con ello, el contenido del búfer se transfiere a la
interfaz de comunicación punto a punto.

Por medio de los parámetros DATA_ADDR y MODE se selecciona el código de función Modbus.
DATA_ADDR (dirección inicial Modbus en el esclavo): indica la dirección inicial de los datos a
los que debe accederse en el esclavo Modbus.
La instrucción Modbus_Master utiliza una entrada MODE en lugar de una entrada de código de
función. La combinación entre MODE y DATA_ADDR especifica el código de función que se
utiliza en la trama Modbus propiamente dicha. La tabla siguiente muestra la asignación entre
el parámetro MODE, el código de función Modbus y el área de direcciones Modbus en
DATA_ADDR.
Tabla 4-164 Funciones Modbus
MODE

DATA_ADDR (dirección
Modbus)

0

Código de fun‐
ción Modbus

Bits por orden
1 a

4518

DATA_LEN
(longitud de los datos)

9999

1 a

Operación y datos
01 Leer bits de salida:

2000/1992

1

0 a

9998

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
MODE

DATA_ADDR (dirección
Modbus)

0

DATA_LEN
(longitud de los datos)

Código de fun‐
ción Modbus

Bits por orden
10001 a

19999

0

1 a

02 Leer bits de entrada:
2000/1992

49999

1 a

125/124 1

400001 a

465535

1 a

125/124

1

Palabras por orden
39999

1

1 a

1 a

9999

125/124 1

49999

400001 a

465535

1

0 a

1

1

2 a

49999

2 a

400001 a

465534

2 a

22

1968/1960 1

9999

22

1 a

9998

0 a

9998

0 a

65524

0 a

9998

16 Escribir varios registros de parada:
123/122

123/122

1

Bits por orden
1 a

9998

15 Escribir varios bits de salida:

Palabras por orden
40001 a

65534

06 Escribir un registro de paradas:

1

9999

0 a
0 a

1

Bits por orden
1 a

9998

05 Escribir un bit de salida:

1 palabra por orden
40001 a

0 a
04 Leer palabras de entrada:

Bit por orden

1

9998

03 Leer registro de paradas:

40001 a

30001 a

0 a

1

Palabras por orden

0

Operación y datos

0 a

9998

0 a

65534

15 Escribir uno o varios bits de salida:
1968/1960 1

Palabras por orden

0 a

9998

16 Escribir uno o varios registros de pa‐
radas:

40001 a

49999

1 a

123

0 a

9998

400001 a

465535

1 a

122 1

0 a

65534

11 Los dos operandos DATA_ADDR y DATA_LEN de Mod‐
bus_Master se ignoran en esta función.

11 Leer palabra de estado y contador
de eventos de la comunicación del
esclavo. La palabra de estado indi‐
ca la ocupación (0 - no ocupado,
0xFFFF - ocupado). El contador de
eventos se incrementa cada vez
que se procesa correctamente una
trama.

80

08

1 palabra por orden

81

1
1 palabra por orden

-

Programación del PLC
Manual de programación y manejo, 11/2019

1

Comprobar el estado del esclavo
mediante el código de diagnóstico
de datos 0x0000 (test de bucle de
control - el esclavo devuelve un eco
de la orden)
-

08 Inicializar el contador de eventos del
esclavo mediante el código de diag‐
nóstico de datos 0x000A
-

4519

Instrucciones
4.1 Instrucciones
MODE

DATA_ADDR (dirección
Modbus)

104 3

Código de fun‐
ción Modbus

Palabras por orden
0 a

3 a 10,
12 a
79,
82 a
103,
105 a
255

DATA_LEN
(longitud de los datos)

-

65535

1 a
-

125/124

Operación y datos
04 Leer palabras de entrada
0 a

1

65535

Reservado

1

En el direccionamiento avanzado (ver parámetro Extended_Adressing), la longitud de datos máxima es 1 byte o 1 palabra
menos, según sea el tipo de datos de la función.

2

MODE 2 permite escribir uno o varios bits de salida y uno o varios registros Holding utilizando las funciones Modbus 15 y 16.
MODE 1 utiliza las funciones Modbus 5 y 6 para escribir 1 bit de salida y 1 registro Holding y las funciones Modbus 15 y 16
para escribir varios bits de salida y varios registros Holding.

3

En el caso de S7-300/400/WinAC, no se soporta.

Parámetro DATA_PTR
El parámetro DATA_PTR indica la dirección DB o M en la que se escribe o de la que se lee. Si
se utiliza un bloque de datos, hay que crear un bloque de datos global que ponga a disposición
la memoria de datos para procesos de lectura y escritura en esclavos Modbus.
Nota
S7-1200/1500 - El bloque de datos direccionado mediante DATA_PTR debe permitir el
direccionamiento directo
El bloque de datos debe permitir el direccionamiento directo (absoluto) y simbólico.
Nota
Uso del código de función 5
Con el código de función 5 puede activarse o borrarse un bit individual.
Para activar un bit debe predefinirse el valor "16#FF00" en la primera palabra del área de
marcas o de DB direccionada mediante DATA_PTR.
● En S7-1200 también se puede predefinir el valor "16#0100" para activar un bit.
● Para desactivar un bit debe predefinirse el valor "16#0000" en la primera palabra del área
de marcas o de DB direccionada mediante DATA_PTR.
El resto de los valores se rechazan con ERROR = TRUE y STATUS = 16#8384.

4520

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Estructuras de bloques de datos para el parámetro DATA_PTR
● Estos tipos de datos son válidos para leer palabras del área de direcciones Modbus
(DATA_PTR) 30001 a 39999, 40001 a 49999 y 400001 a 465535, así como para escribir
palabras del área de direcciones Modbus (parámetro DATA_PTR) 40001 a 49999 y 400001
a 465535.
– Matriz estándar de los tipos de datos WORD, UINT o INT
– Estructura denominada del tipo WORD, UINT o INT en la que cada elemento tiene un
nombre unívoco y un tipo de datos de 16 bits.
– Estructura compleja denominada en la que cada elemento tiene un nombre unívoco y un
tipo de datos de 16 o 32 bits.
● Para leer y escribir bits para el área de direcciones Modbus (parámetro DATA_PTR) 00001
a 09999 y para leer bits de 10001 a 19999.
– Campo estándar de tipos de datos booleanos.
– Estructura booleana con nombres a partir de variables booleanas de nombre unívoco
● Si bien no es necesario que cada instrucción Modbus_Master tenga un área de memoria
propia y separada, es recomendable. Esto se debe a que la posibilidad de que se destruyan
datos es mayor cuando varias instrucciones Modbus_Master leen y escriben en la misma
área de memoria.
● No es necesario que las áreas de memoria de DATA_PTR estén en el mismo bloque de
datos global. Es posible crear un bloque de datos con varias áreas para procesos de lectura
Modbus, un bloque de datos para procesos de escritura Modbus o un bloque de datos para
cada estación esclava.

Versiones de la instrucción
Aunque la versión 3.0 tiene exactamente tiene la misma funcionalidad que la versión 2.4, se ha
incrementado el número por motivos internos.

Modbus_Slave
Modbus_Slave: comunicarse como esclavo Modbus
Nota
Uso con CM1241
El uso de esta instrucción con un CM 1241 solo es posible con una versión de firmware V2.1
o superior del módulo.

Programación del PLC
Manual de programación y manejo, 11/2019

4521

Instrucciones
4.1 Instrucciones

Descripción
La instrucción Modbus_Slave permite al programa comunicarse como esclavo Modbus a
través de un CM (RS422/485 o RS232). STEP 7 crea automáticamente un DB de instancia
cuando se inserta la instrucción. El parámetro MB_DB de la instrucción Modbus_Comm_Load
debe interconectarse con el parámetro MB_DB (estático) de la instrucción Modbus_Slave .
Nota
Para un DB de instancia de la instrucción Modbus_Slave no está permitido activar la
remanencia (Retain).

Parámetros
Parámetro

MB_ADDR

Declara‐
ción

IN

Tipo de datos
S71200/1500
UInt

Estándar

Descripción

‑

Dirección de estación del esclavo Modbus:
área de direccionamiento estándar (1 a 247)
área de direccionamiento ampliada (0 a 65535)

S7300/400/
WinAC
Word

Nota: 0 es la dirección Broadcast
COM_RST

IN/OUT

---

Bool

FALSE

Inicialización de la instrucción Modbus_Slave
La instrucción se inicializa con TRUE. Seguidamente, la
instrucción ajusta COM_RST de nuevo a FALSE.
Nota:
El parámetro solo está disponible para instrucciones
S7-300/400.

MB_HOLD_
REG

IN/OUT

Variant

Any

‑

Puntero hacia el DB de registro de paradas Modbus: el re‐
gistro de paradas Modbus puede ser el área de memoria de
las marcas o bien un bloque de datos.
A partir de la versión de la instrucción V4.0:
El parámetro debe apuntar a un área de memoria con una
longitud mínima de 16 bits. Las longitudes menores dan
lugar al mensaje de error 16#8187. Esto afecta a los ele‐
mentos single, arrays, STRUCT y UDT. P. ej., un Single
Bool o un array con una longitud inferior a 16 elementos
booleanos da lugar al mensaje de error.
Si la longitud no es un múltiplo de 16 bits, la instrucción
Modbus_Slave no puede leer ni escribir los bits restantes al
final del área de memoria.
El parámetro puede apuntar también a un área de memoria
optimizada. En el área de memoria optimizada puede haber
un elemento single o un array con los siguientes tipos de
datos: Bool, Byte, Char, Word, Int, DWord, DInt, Real,
USInt, UInt, UDInt, SInt, WChar. Cualquier otro tipo de da‐
tos da lugar al mensaje de error 16#818C.

4522

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

NDR

Declara‐
ción

Tipo de datos
S71200/1500

OUT

Estándar

Descripción

FALSE

Datos nuevos preparados:

S7300/400/
WinAC

Bool

● FALSE – No hay datos nuevos
● TRUE – Indica que se han escrito datos nuevos del
maestro Modbus
El bit NDR es TRUE durante un ciclo después de que la
última petición haya finalizado sin errores.
DR

OUT

Bool

FALSE

Leer datos:
● FALSE – No se han leído datos
● TRUE – Indica que la instrucción del maestro Modbus
ha guardado datos recibidos en la zona de destino.
El bit DR es TRUE durante un ciclo después de que la últi‐
ma petición haya finalizado sin errores.

ERROR

OUT

Bool

FALSE

El bit ERROR es TRUE durante un ciclo después de que la
última orden haya finalizado con errores. Si la ejecución
finaliza con un error, el código de error del parámetro STA‐
TUS solo es válido en el ciclo en que ERROR = TRUE.

STATUS

OUT

Word

0

Código de error (consulte Mensajes de error (Página 4538))

Los códigos de función de la comunicación Modbus (1, 2, 4, 5 y 15) pueden leer y escribir bits
y palabras directamente en la memoria imagen de proceso de las entradas y en la memoria
imagen de proceso de las salidas de la CPU. En estos códigos de función debe definirse el
parámetro MB_HOLD_REG como un tipo de datos mayor que un byte. La tabla siguiente
muestra la asignación de ejemplo de las direcciones Modbus a la memoria imagen de proceso
de la CPU.
Tabla 4-165 Asignación de las direcciones Modbus a la memoria imagen de proceso
Funciones Modbus
Código

S7-1200

Función

Área de datos Área de direccio‐ Área de datos
nes

01

Leer bits

Salida

0 a

8191 Memoria imagen de proce‐
so de las salidas

Q0.0 a

Q1023.7

02

Leer bits

Entrada

0 a

8191 Memoria imagen de proce‐
so de las entradas

I0.0 a

I1023.7

04

Leer pala‐
bras

Entrada

0 a

511 Memoria imagen de proce‐
so de las entradas

IW0 a

IW1022

05

Escribir bit

Salida

0 a

8191 Memoria imagen de proce‐
so de las salidas

Q0.0 a

Q1023.7

15

Escribir bits

Salida

0 a

8191 Memoria imagen de proce‐
so de las salidas

Q0.0 a

Q1023.7

Programación del PLC
Manual de programación y manejo, 11/2019

Dirección de la CPU

4523

Instrucciones
4.1 Instrucciones
Tabla 4-166 Asignación de las direcciones Modbus a la memoria imagen de proceso
Funciones Modbus

S7-1500/S7-300/S7-400

Código de fun‐
ción

Función

Área de datos Área de direccio‐
nes

01

Leer bits

Salida

0 a

9998 Memoria imagen de proceso
de las salidas

Q0.0 a

Q1249.6

02

Leer bits

Entrada

0 a

9998 Memoria imagen de proceso
de las entradas

I0.0 a

I1249.6

04

Leer pala‐ Entrada
bras

0 a

9998 Memoria imagen de proceso
de las entradas

IW0 a

IW19996

05

Escribir bit Salida

0 a

9998 Memoria imagen de proceso
de las salidas

Q0.0 a

Q1249.6

15

Escribir
bits

0 a

9998 Memoria imagen de proceso
de las salidas

Q0.0 a

Q1249.6

Salida

Área de datos

Dirección de la CPU

Nota
El área de direcciones disponible puede ser también más pequeña, en función de la
configuración de memoria de la CPU.
Los códigos de función de la comunicación Modbus (3, 6, 16) utilizan un registro de paradas
Modbus que puede ser un área de direcciones del área de memoria de las marcas o bien un
bloque de datos. El tipo del registro de paradas se indica en el parámetro MB_HOLD_REG de
la instrucción Modbus_Slave.
Nota
S7-1200/1500 - Tipo del bloque de datos MB_HOLD_REG
Un bloque de datos con registro de paradas Modbus debe permitir el direccionamiento directo
(absoluto) y simbólico.

Tabla 4-167 Funciones de diagnóstico
Funciones de diagnóstico Modbus de Modbus_Slave del S7-1200
Códigos de fun‐
ción
08

0000H

Emitir datos de consulta Echotest: la instrucción Modbus_Slave devuelve a un maestro
Modbus el eco de una palabra de datos recibida.

08

000AH

Borrar contador de eventos de comunicación: la instrucción Modbus_Slave borra el con‐
tador de eventos de comunicación utilizado para la función Modbus 11.

11

4524

Función par‐ Descripción
cial

Consultar contador de eventos de comunicación: la instrucción Modbus_Slave utiliza un
contador interno de eventos de comunicación para registrar el número de peticiones
correctas de lectura y escritura Modbus que se envían al esclavo Modbus. El contador no
se incrementa con la función 8, función 11 y peticiones Broadcast. Tampoco se incre‐
menta en las peticiones que provocan errores de comunicación (p. ej., errores de paridad
o CRC).

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucción Modbus_Slave soporta peticiones de escritura Broadcast de maestros Modbus,
en tanto que las peticiones abarquen el acceso a direcciones válidas. Para códigos de función
que no se soporten en la función Broadcast, Modbus_Slave genera el código de error 16#8188.

Variables del esclavo Modbus en la versión de la instrucción V3.0
Esta tabla muestra las variables estáticas públicas del bloque de datos de instancia de
Modbus_Slave que pueden utilizarse en el programa.
Tabla 4-168 Variables del esclavo Modbus
Variable

Tipo de
datos

Estándar

Descripción

HR_Start_Offset

Word

0

Indica la dirección inicial del registro de paradas Modbus (estándar =
0)

QB_Start

Word

0

Dirección inicial del área de direcciones escribibles de las salidas (byte
0 a 65535).
Nota:
La variable no está disponible para S7-300, S7-400 y WinAC.

QB_Count

Word

0xFFFF

Número de bytes de salida escribibles por el maestro Modbus.
Nota:
La variable no está disponible para S7-300, S7-400 y WinAC.

Extended_Addressing

Bool

FALSE

Direccionamiento avanzado, configura el direccionamiento del escla‐
vo como byte individual o doble
(FALSE = dirección de byte único, TRUE = dirección de byte doble)

Request_Count

Word

0

Número de todas las peticiones recibidas por este esclavo

Slave_Message_Count

Word

0

Número de las peticiones recibidas para este esclavo específico

Bad_CRC_Count

Word

0

Número de peticiones recibidas que presentan un error CRC

Broadcast_Count

Word

0

Número de peticiones Broadcast recibidas

Exception_Count

Word

0

Errores específicos de Modbus, que se acusan en el maestro con una
excepción

Success_Count

Word

0

Número de las peticiones recibidas para este esclavo específico sin
errores de protocolo

MB_DB

MB_BA‐
SE

-

El parámetro MB_DB de la instrucción Modbus_Comm_Load debe
conectarse con el parámetro MB_DB de la instrucción Modbus_Mas‐
ter.

El programa puede escribir valores en las variables HR_Start_Offset y Extended_Addressing
y controlar las operaciones del esclavo Modbus. Las demás variables pueden leerse para
vigilar el estado de Modbus.

Reglas para la comunicación del esclavo Modbus
● Modbus_Comm_Load debe ejecutarse para configurar un puerto con el fin de que la
instrucción Modbus_Slave pueda comunicarse a través de dicho puerto.
● Si un puerto debe reaccionar como esclavo a un maestro Modbus, dicho puerto no debe
programarse con la instrucción Modbus_Master .
● Solo es posible utilizar una instancia de Modbus_Slave con un puerto concreto, de lo
contrario pueden producirse comportamientos imprevistos.

Programación del PLC
Manual de programación y manejo, 11/2019

4525

Instrucciones
4.1 Instrucciones
● Las instrucciones Modbus no utilizan eventos de alarma de la comunicación para controlar
el proceso de comunicación. El programa debe controlar el proceso de comunicación
consultando la instrucción Modbus_Slave respecto de procesos de transmisión y recepción
terminados.
● La instrucción Modbus_Slave debe ejecutarse regularmente y con una frecuencia que
permita una respuesta temprana a peticiones entrantes de un maestro Modbus. Se
recomienda ejecutar Modbus_Slave en cada ciclo desde un OB de ciclo de programa.
Modbus_Slave puede ejecutarse desde un OB de alarma cíclica, aunque no es
recomendable, porque unos retardos de tiempo excesivos en el programa de interrupción
pueden bloquear temporalmente la ejecución de otros programas de interrupción.

Control de tiempo de la señal Modbus
Modbus_Slave debe ejecutarse regularmente para recibir todas las peticiones del maestro
Modbus y responder de un modo adecuado. La frecuencia de ejecución de Modbus_Slave se
rige por el valor de timeout para la respuesta especificado por el maestro Modbus. Esto se
representa en la figura siguiente.

$'5

)&

'DWD

7LPHRXW
GHUHVSXHVWD

&5&

(OHVFODYRHQY¯D

(OPDHVWURHQY¯D
,QWHUYDOR
&5& LQLFLDO WLHPSRVGH
FDUDFWHUHV

$'5

5HWDUGR
GH

$'5

)&

'DWD

,QWHUYDOR
&5& LQLFLDO

El período de timeout de la respuesta (RESP_TO) es el tiempo que espera un maestro Modbus
al principio de una respuesta de un esclavo Modbus. Dicho período no se define en el protocolo
Modbus, sino en un parámetro de la instrucción Modbus_Comm_Load. Puesto que tanto la
recepción como la transmisión de una trama requieren varias llamadas (tres como mínimo) de
la instrucción Modbus_Slave, debería ejecutarse Modbus_Slave un mínimo de doce veces
durante el período de timeout para la respuesta del maestro Modbus para que la recepción y
transmisión de datos por parte del esclavo Modbus se ejecute el doble de veces de las
especificadas por el período de timeout.

HR_Start_Offset
Las direcciones del registro de paradas Modbus empiezan en 40001 o 400001. Estas
direcciones equivalen a la dirección de inicio del registro de paradas en la memoria del sistema
de destino. De todas formas, es posible configurar la variable HR_Start_Offset para configurar
una dirección inicial distinta de 40001 o 400001 para el registro de paradas Modbus.
La dirección 0 en el telegrama de recepción corresponde a la dirección inicial del registro de
paradas en la memoria del sistema de destino. A través de la variable HR_Start_Offset se
puede configurar otra dirección inicial como 0 para el registro de paradas de Modbus.
Así, por ejemplo, existe la posibilidad de configurar un registro de paradas que empiece en
MW100 y una longitud de 100 palabras. Si HR_Start_Offset = 20, la dirección 20 del telegrama
de recepción corresponde a la dirección de inicio del registro de paradas en la memoria de

4526

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
destino (MW100). Toda dirección del telegrama de recepción por debajo de 20 y por encima
de 119 provoca un error de direccionamiento.
Tabla 4-169 Ejemplo de direccionamiento del registro de paradas de Modbus si DATA_PTR señala a MW100 con una
longitud de 100 palabras
HR_Start_Offset
0
20

Dirección

Mínimo

Máximo

Dirección Modbus (palabra)

0

99

Dirección S7-1500

MW100

MW298

Dirección Modbus (palabra)

20

119

Dirección S7-1500

MW100

MW298

HR_Start_Offset es un valor de palabra que indica la dirección inicial del registro de paradas
Modbus y está guardado en el bloque de datos de instancia Modbus_Slave . Esta variable
estática pública se selecciona mediante la lista desplegable de parámetros después de haber
insertado Modbus_Slave en el programa.
Si, por ejemplo, se ha insertado Modbus_Slave en un segmento KOP, es posible pasar a un
segmento anterior y asignar el valor HR_Start_Offset con el comando Move. El valor debe
asignarse antes de ejecutar Modbus_Slave.
Introducir una variable de esclavo Modbus mediante el nombre de DB estándar:
1. Coloque el cursor en el campo de parámetros OUT1 e introduzca el carácter m.
2. Seleccione en la lista desplegable el DB de instancia que desee para la instrucción
Modbus_Slave.
3. Coloque el cursor a la derecha del nombre de DB (después de las comillas) e introduzca un
punto.
4. Seleccione en la lista desplegable "Modbus_Slave_DB.HR_Start_Offset".

Versiones de la instrucción
Aunque la versión 4.0 tiene exactamente tiene la misma funcionalidad que la versión 3.0, se ha
incrementado el número por motivos internos.

Acceso a áreas de datos en DB en lugar del acceso directo a direcciones MODBUS a partir de la versión
V4.0
Acceso a áreas de datos en DB en lugar del acceso directo a direcciones MODBUS a partir de la versión
V4.0
A partir de la versión V4.0 de Modbus_Slave y las versiones de firmware V2.5 (CPU S7-1500)
o V4.2 (CPU S7-1200) se puede acceder a áreas de datos en DB en lugar de acceder
directamente a imágenes de proceso y registros Holding. Para ello, el DB debe tener el atributo
"Acceso optimizado al bloque" desactivado y no debe estar exclusivamente en la memoria de
carga.
Si se recibe una solicitud MODBUS y no se ha definido ninguna área de datos para el tipo de
datos MODBUS del código de función correspondiente, la solicitud será tratada igual que en

Programación del PLC
Manual de programación y manejo, 11/2019

4527

Instrucciones
4.1 Instrucciones
las anteriores versiones de la instrucción, es decir, se producirá un acceso directo a memorias
imagen de proceso y fichas Holding.
En cambio, si se ha definido un área de datos para el tipo de datos MODBUS del código de
función, la instrucción Modbus_Slave lee o escribe en esa área de datos. Del tipo de orden
dependerá que se lea o se escriba.
Una única solicitud MODBUS solo puede leerse en un área de datos o escribirse en un área
de datos. Por tanto, si se desea leer registros Holding que se extiendan por varias áreas de
datos, se necesitarán varias solicitudes MODBUS.

Reglas para definir las áreas de datos
Pueden definirse como máximo ocho áreas de datos en diferentes DB; cada DB solo puede
contener un área de direcciones. Una única solicitud MODBUS solo puede leerse en
exactamente un área de datos o escribirse en exactamente un área de datos. Cada área de
datos se corresponde con un área de direcciones MODBUS. La definición se realiza en la
variable estática Data_Area_Array del DB de instancia; Data_Area_Array es un campo que
consta de ocho elementos.
Si desea utilizar menos de ocho áreas de datos, las áreas de datos deseadas deben
encontrarse una tras otra y sin huecos. La primera entrada vacía de las áreas de datos finaliza
la búsqueda del área de datos durante la ejecución. Por tanto, si p. ej. se han definido los
elementos de campo 1, 2, 4 y 5, solo se detectan los elementos de campo 1 y 2, puesto que
el elemento de campo 3 está vacío.
El campo Data_Area_Array consta de 8 elementos: Data_Area_Array[1] ... Data_Area_Array[8]
Cada elemento de campo Data_Area_Array[x], 1 <= x <= 8, es un UDT del tipo MB_DataArea
y tiene la estructura siguiente:

4528

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Paráme‐
tros

Tipo
de da‐
tos

da‐
ta_type

UInt

Significado

Identificador del tipo de datos MODBUS que se mapea en esta área de datos:
● 0: identificador de un elemento de campo vacío o de un área de datos no utilizada. En este caso son
irrelevantes los valores de db, start y length.
● 1: Memoria Imagen de proceso de las salidas (utilizada con los códigos de función 1, 5 y 15)
● 2: Memoria imagen de proceso de las entradas (utilizada con el código de función 2)
● 3: Registro Holding (se utiliza con los códigos de función 3, 6 y 16)
● 4: Registro de entrada (se utiliza con el código de función 4)
Nota: Si se ha definido un área de datos para un tipo de datos MODBUS, la instrucción MB_SERVER ya
no podrá acceder directamente a dicho tipo de datos MODBUS. Si la dirección de una solicitud MODBUS
para dicho tipo de datos no se corresponde con ningún área de datos definida, en STATUS se devuelve
el valor W#16#8383.

db

UInt

Número del bloque de datos en el que se representan los registros MODBUS o los bits definidos a
continuación.
El número de DB debe ser unívoco en las áreas de datos. El mismo número de DB no puede estar
definido en varias áreas de datos.
El DB debe ser un DB con acceso estándar y no debe estar exclusivamente en la memoria de carga.
Las áreas de datos empiezan siempre en la dirección de byte 0 del DB.
Valores permitidos: 1 a 60999

start

UInt

Primera dirección MODBUS que se mapea en el bloque de datos a partir de la dirección 0.0.
Valores permitidos: de 0 a 65535

length

UInt

Número de bits (para los valores 1 y 2 de data_type) o número de registros (para los valores 3 y 4 de
data_type).
Las áreas de direcciones MODBUS de un mismo tipo de datos MODBUS no pueden solaparse.
Valores permitidos: de 1 a 65535

Ejemplos de definición de áreas de datos
● Primer ejemplo: data_type = 3, db = 1, start = 10, length = 6
Los registros Holding (data_type = 3) se mapean en el bloque de datos 1 (db = 1). La
dirección Modbus 10 (start = 10) se encuentra en la palabra de datos 0. La última dirección
Modbus válida 15 (length = 6) se encuentra en la palabra de datos 5.
● Segundo ejemplo: data_type = 2, db = 15, start = 1700, length = 112
Las entradas (data_type = 2) se mapean en el bloque de datos 15 (db = 15). La dirección
Modbus 1700 (start = 1700) se encuentra en la palabra de datos 0. La última dirección
Modbus válida 1811 (length = 112) se encuentra en la palabra de datos 111.

Programación del PLC
Manual de programación y manejo, 11/2019

4529

Instrucciones
4.1 Instrucciones

Limitación del acceso de lectura a memorias imagen de proceso a partir de la versión V4.0
Limitación del acceso de lectura a memorias imagen de proceso
A partir de la versión de la instrucción V4.0 de Modbus_Slave, en la imagen de proceso de las
entradas y en la imagen de proceso de las salidas pueden definirse sendas áreas que permiten
el acceso de lectura desde dispositivos MODBUS. Entonces ya no será posible un acceso de
lectura de dispositivos MODBUS remotos a direcciones fuera de dichas áreas de la memoria
imagen de proceso.
Nota
Limitación del acceso de escritura a memorias imagen de proceso
Desde la versión de la instrucción V3.0, es posible restringir a un área determinada el acceso
de escritura a la imagen de proceso de las salidas.

Definición de áreas de lectura en las memorias imagen de proceso
La definición de áreas de lectura en las memorias imagen de proceso se realiza en las
siguientes variables estáticas del DB de instancia:
● QB_Read_Start: dirección del primer byte de la memoria imagen de proceso de salidas que
puede leerse desde un dispositivo MODBUS remoto (se aplica para el código de función 1)
● QB_Read_Count: número de bytes de la memoria imagen de proceso de salidas que
pueden leerse desde un dispositivo MODBUS remoto (se aplica para el código de función
1)
● IB_Read_Start: dirección del primer byte de la memoria imagen de proceso de entradas que
puede leerse desde un dispositivo MODBUS remoto (se aplica para los códigos de función
2 y 4)
● IB_Read_Count: Número de bytes de la memoria imagen de proceso de entradas que
pueden leerse desde un dispositivo MODBUS remoto (se aplica para los códigos de función
2 y 4)

Variables estáticas en el DB de instancia para definir áreas de escritura y de lectura en las memorias
imagen de proceso
La siguiente tabla describe las variables estáticas mencionadas anteriormente en el DB de
instancia de la instrucción Modbus_Slave con las que se definen las áreas de lectura en las
imágenes de proceso.
Para ofrecer una visión completa, se indican también las variables estáticas con las que se
definen las áreas de escritura en las imágenes de proceso (QB_Start y QB_Count) a partir de
la versión V3.0.

4530

Variable

Tipo de datos

Valor de arranque

QB_Start

UInt

0

QB_Count

UInt

65535

QB_Read_Start

UInt

0

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Variable

Tipo de datos

Valor de arranque

QB_Read_Count

UInt

65535

IB_Read_Start

UInt

0

IB_Read_Count

UInt

65535

Estructura de la trama
Extended_Addressing
A la variable Extended_Addressing se accede de un modo similar que a la referencia
HR_Start_Offset, excepto por el hecho de que la variable Extended_Addressing es un valor
booleano.
Para el direccionamiento de esclavo Modbus puede configurarse un byte individual (el
estándar de Modbus) con Extended_Adressing = FALSE, o bien dos bytes
(Extended_Adressing = TRUE). El direccionamiento avanzado sirve para direccionar más de
247 dispositivos en una sola red. Con Extended_Adressing = TRUE es posible activar un
máximo de 65535 direcciones. A continuación se muestra una trama Modbus a modo de
ejemplo.
Tabla 4-170 Dirección del esclavo con un byte (byte 0)
Byte 0

Byte 1

Byte 2

Byte 3

Solicitud

Dirección
del esclavo

Código de
función

Respuesta váli‐
da

Dirección
del esclavo

Código de
función

Longitud

Mensaje de error

Dirección
del esclavo

0xxx

Código de ex‐
cepción

Byte 4

Dirección inicial

Byte 5
Datos
Datos...

Tabla 4-171 Dirección del esclavo con dos bytes (byte 0 y byte 1)
Byte 0

Byte 1

Byte 2

Byte 3

Byte 4

Solicitud

Dirección del esclavo

Código de
función

Respuesta váli‐
da

Dirección del esclavo

Código de
función

Longitud

Mensaje de error

Dirección del esclavo

0xxx

Código de ex‐
cepción

Byte 5

Dirección inicial

Byte 6
Datos

Datos...

Descripción de las tramas
El intercambio de datos entre maestro y esclavo comienza con la dirección del esclavo,
seguida del código de función. A continuación se transfieren los datos. La estructura del campo
de datos depende del código de función utilizado. Al final de la trama se transmitirá la suma de
comprobación (CRC).

Programación del PLC
Manual de programación y manejo, 11/2019

4531

Instrucciones
4.1 Instrucciones

Código de función 1 - Esta función permite leer bits de salida individuales
Tabla 4-172 FC 1 - Leer bits de salida
Byte 0

Byte 1

Dirección del
esclavo

Código de fun‐
ción 1

Respuesta váli‐ Dirección del
da
esclavo

Código de fun‐
ción 1

Longitud 1

Mensaje de
error

0x81

Código de ex‐
cepción 2

Petición

Dirección del
esclavo

Byte 2

Byte 3

Byte 4

Dirección inicial

Byte 5
Número de salidas

Datos de salida 3)
---

1

Longitud: si de la división de las salidas entre 8 se obtiene un residuo, el número de bytes debe incrementarse en 1.

2

Código E: 01, 02, 03 o 04

3

Los datos de salida pueden abarcar varios bytes

Byte 0

Byte 1

Byte 2

Byte 3

Byte 4

Petición

Dirección del esclavo

Código de
función 1

Respuesta
válida

Dirección del esclavo

Código de
función 1

Longitud 1

Mensaje de
error

Dirección del esclavo

0x81

Código de ex‐
cepción 2

Byte 5

Dirección inicial

Byte 6

Número de salidas
Datos de salida
---

1

Longitud: si de la división de las salidas entre 8 se obtiene un residuo, el número de bytes debe incrementarse en 1.

2

Código E: 01, 02, 03 o 04

3

Los datos de salida pueden abarcar varios bytes

Código de función 2 - Esta función permite leer bits de entrada individuales
Tabla 4-173 FC 2 - Leer bits de entrada
Byte 0

Byte 1

Dirección del
esclavo

Código de fun‐
ción 2

Respuesta váli‐ Dirección del
da
esclavo

Código de fun‐
ción 2

Longitud 1

Mensaje de
error

0x82

Código de ex‐
cepción 2

Petición

Dirección del
esclavo

Byte 2

Byte 3
Dirección inicial

Byte 4

Byte 5
Número de entradas

Datos de entrada
---

1

Longitud: si de la división de las entradas entre 8 se obtiene un residuo, el número de bytes debe incrementarse en 1.

2

Código E: 01, 02, 03 o 04

4532

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Byte 0

Byte 1

Byte 2

Byte 3

Byte 4

Petición

Dirección del esclavo

Código de
función 2

Respuesta
válida

Dirección del esclavo

Código de
función 2

Longitud 1

Mensaje de
error

Dirección del esclavo

0x82

Código de ex‐
cepción 2

Byte 5

Dirección inicial

Byte 6

Número de entradas
Datos de entrada
---

1

Longitud: si de la división de las entradas entre 8 se obtiene un residuo, el número de bytes debe incrementarse en 1.

2

Código E: 01, 02, 03 o 04

Código de función 3 - Esta función permite leer registros individuales
Tabla 4-174 FC 3 - Leer registro de paradas
Byte 0

Byte 1

Dirección del
esclavo

Código de fun‐
ción 3

Respuesta váli‐ Dirección del
da
esclavo

Código de fun‐
ción 3

Longitud 1

Mensaje de
error

0x83

Código de ex‐
cepción 2

Petición

Dirección del
esclavo

1

Longitud: Número de bytes

2

Código E: 01, 02, 03 o 04

Byte 0

Byte 1

Byte 2

Byte 3
Dirección inicial

Byte 2

Byte 3

Byte 4

Código de
función 3

Respuesta
válida

Dirección del esclavo

Código de
función 3

Longitud 1

Mensaje de
error

Dirección del esclavo

0x83

Código de ex‐
cepción 2

Longitud: Número de bytes
Código E: 01, 02, 03 o 04

Programación del PLC
Manual de programación y manejo, 11/2019

Número de registros

---

Dirección del esclavo

2

Byte 5

Datos de registro

Petición

1

Byte 4

Dirección inicial

Byte 5

Byte 6

Número de registros
Datos de registro
---

4533

Instrucciones
4.1 Instrucciones

Código de función 4 - Esta función permite leer registros individuales
Tabla 4-175 FC 4 - Leer palabras de entrada
Byte 0

Byte 1

Dirección del
esclavo

Código de fun‐
ción 4

Respuesta váli‐ Dirección del
da
esclavo

Código de fun‐
ción 4

Longitud 1

Mensaje de
error

0x84

Código de ex‐
cepción 2

Petición

Dirección del
esclavo

Byte 2

1

Longitud: 2 * número de palabras de entrada

2

Código E: 01, 02, 03 o 04

Byte 0

Byte 1

Byte 3
Dirección inicial

Byte 2

Byte 3

Byte 4

Código de
función 4

Respuesta
válida

Dirección del esclavo

Código de
función 4

Longitud 1

Mensaje de
error

Dirección del esclavo

0x84

Código de ex‐
cepción 2

Longitud: 2 * número de palabras de entrada
Código E: 01, 02, 03 o 04

Número de palabras de entrada

---

Dirección del esclavo

2

Byte 5

Datos de entrada

Petición

1

Byte 4

Dirección inicial

Byte 5

Byte 6

Número de palabras de en‐
trada
Datos de entrada
---

Código de función 5- Con esta función puede activarse o borrarse un bit individual
Tabla 4-176 FC 5 - Escribir un bit de salida
Byte 0

Byte 1

Dirección del
esclavo

Código de fun‐
ción 5

Respuesta váli‐ Dirección del
da
esclavo

Código de fun‐
ción 5

Longitud

Mensaje de
error

0x85

Código de ex‐
cepción 1

Petición

1

Dirección del
esclavo

Byte 3

Byte 4

Byte 5

Dirección inicial

Valor
Valor
---

Código E: 01, 02, 03 o 04

Byte 0

1

Byte 2

Byte 1

Byte 2

Byte 3

Byte 4

Petición

Dirección del esclavo

Código de
función 5

Respuesta
válida

Dirección del esclavo

Código de
función 5

Longitud

Mensaje de
error

Dirección del esclavo

0x85

Código de ex‐
cepción 1

Byte 5

Dirección inicial

Byte 6
Valor

Valor
---

Código E: 01, 02, 03 o 04

4534

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Código de función 6 - Esta función permite escribir registros individuales
Tabla 4-177 FC 6 - Escribir registro de paradas
Byte 0

Byte 1

Dirección del
esclavo

Código de fun‐
ción 6

Dirección

Registros

Respuesta váli‐ Dirección del
da
esclavo

Código de fun‐
ción 6

Dirección

Registros

Mensaje de
error

0x86

Petición

1

Dirección del
esclavo

Byte 3

Byte 4

Código de ex‐
cepción 1

Byte 5

---

Código E: 01, 02, 03 o 04

Byte 0

1

Byte 2

Byte 1

Byte 2

Byte 3

Byte 4

Byte 5

Byte 6

Petición

Dirección del esclavo

Código de
función 6

Dirección

Registros

Respuesta
válida

Dirección del esclavo

Código de
función 6

Dirección

Registros

Mensaje de
error

Dirección del esclavo

0x86

Código de ex‐
cepción 1

---

Código E: 01, 02, 03 o 04

Código de función 8 - Esta función permite comprobar la conexión de comunicación
Tabla 4-178 FC 8 - Estado del esclavo
Byte 0

Byte 1

Dirección del
esclavo

Código de fun‐
ción 8

Código de diagnóstico

Valor de prueba

Respuesta váli‐ Dirección del
da
esclavo

Código de fun‐
ción 8

Código de diagnóstico

Valor de prueba

Mensaje de
error

0x88

Petición

1

Dirección del
esclavo

Byte 3

Byte 4

Código de ex‐
cepción 1

Byte 5

---

Código E: 01, 03 o 04

Byte 0

1

Byte 2

Byte 1

Byte 2

Byte 3

Byte 4

Byte 5

Byte 6

Petición

Dirección del esclavo

Código de
función 8

Código de diagnóstico

Valor de prueba

Respuesta
válida

Dirección del esclavo

Código de
función 8

Código de diagnóstico

Valor de prueba

Mensaje de
error

Dirección del esclavo

0x88

Código de ex‐
cepción 1

---

Código E: 01, 03 o 04

Programación del PLC
Manual de programación y manejo, 11/2019

4535

Instrucciones
4.1 Instrucciones

Código de función 11 - Esta función permite leer una "Status-Word" de 2 bytes y un "Event-Counter" de
2 bytes
Tabla 4-179 FC 11 - Contador de eventos de la comunicación del esclavo
Byte 0

Byte 1

Dirección del
esclavo

Código de fun‐
ción 11

Respuesta váli‐ Dirección del
da
esclavo

Código de fun‐
ción 11

Mensaje de
error

0x8B

Petición

1

Dirección del
esclavo

Byte 3

Byte 4

Byte 5

--Status

Contador de eventos

Código de ex‐
cepción 1

---

Código E: 01 o 04

Byte 0

1

Byte 2

Byte 1

Byte 2

Byte 3

Petición

Dirección del esclavo

Código de
función 11

Respuesta
válida

Dirección del esclavo

Código de
función 11

Mensaje de
error

Dirección del esclavo

0x8B

Byte 4

Byte 5

Byte 6

--Status

Contador de eventos

Código de ex‐
cepción 1

---

Código E: 01 o 04

Código de función 15 - Esta función permite escribir varios bits
Tabla 4-180 FC 15 - Escribir uno o varios bits de salida
Byte 0

Byte 1

Byte 2

Petición

Dirección del
esclavo

Código de
función 15

Dirección inicial

Número de palabras
de salida

Respuesta
válida

Dirección del
esclavo

Código de
función 15

Dirección inicial

Número de palabras
de salida

Mensaje de
error

Dirección del
esclavo

0x8F

Código
de ex‐
cepción

Byte 3

Byte 4

Byte 5

Byte 6

Byte 7

Contador
de bytes 1

Byte n
Valor

-----

2

1

Contador de bytes: si de la división del número de bytes entre 8 se obtiene un residuo, el número de bytes debe
incrementarse en 1.

2

Código E: 01, 02, 03 o 04

4536

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Byte 0

Byte 1

Byte 2

Byte 3

Byte 4

Byte 5

Byte 6

Petición

Dirección del es‐ Código de
clavo
función 15

Dirección inicial

Número de palabras
de salida

Respuesta
válida

Dirección del es‐ Código de
clavo
función 15

Dirección inicial

Número de palabras
de salida

Mensaje de
error

Dirección del es‐ 0x8F
clavo

Código de ex‐
cepción 2

Byte 7

Byte 8

Contador
de bytes 1

Byte n
Valor

-----

1

Contador de bytes: si de la división del número de bytes entre 8 se obtiene un residuo, el número de bytes debe
incrementarse en 1.

2

Código E: 01, 02, 03 o 04

Código de función 16 - Esta función permite escribir uno o varios registros
Tabla 4-181 FC 16 - Escribir uno o varios registros de paradas
Byte 0

Byte 1

Petición

Dirección del
esclavo

Código de
función 16

Dirección inicial

Número de registros Contador
de bytes 1

Respuesta
válida

Dirección del
esclavo

Código de
función 16

Dirección inicial

Número de registros

Mensaje de
error

Dirección del
esclavo

0x90

Byte 2

Byte 3

Byte 4

Byte 5

Código
de ex‐
cepción

Byte 6

Byte 7

Byte n
Valor

-----

2

1

Contador de bytes: Número de registros * 2

2

Código E: 01, 02, 03 o 04

Byte 0

Byte 1

Byte 2

Byte 3

Byte 4

Byte 5

Byte 6

Petición

Dirección del es‐ Código de
clavo
función 16

Dirección inicial

Número de registros

Respuesta
válida

Dirección del es‐ Código de
clavo
función 16

Dirección inicial

Número de registros

Mensaje de
error

Dirección del es‐ 0x90
clavo

Código de ex‐
cepción 2

1

Contador de bytes: Número de registros * 2

2

Código E: 01, 02, 03 o 04

Programación del PLC
Manual de programación y manejo, 11/2019

Byte 7

Byte 8

Contador
de bytes 1

Byte n
Valor

-----

4537

Instrucciones
4.1 Instrucciones

Mensajes de error
Sinopsis de los mensajes de error Modbus
Código de
error

Descripción

Solución

16#0000

No hay error

‑

Error de configuración de la interfaz: Modbus_Comm_Load
16#8181

El módulo no soporta esta velocidad de transferencia
de datos.

Seleccione una velocidad de transferencia de datos
compatible con el módulo en el parámetro BAUD.

16#8182

El módulo no soporta este ajuste de paridad.

Seleccione un valor adecuado para "Paridad" en el
parámetro PARITY.
Se admiten:
● Sin (1)
● Par (2)
● Impar (3)
● Mark (4)
● Space (5)
● Cualquiera (6)

16#8183

El módulo no soporta este tipo de control del flujo de
datos.

Seleccione un control del flujo de datos compatible
con el módulo en el parámetro FLOW_CTRL.

16#8184

Valor no admisible para "Tiempo de respuesta excedi‐ Seleccione un valor adecuado para "Tiempo de res‐
do".
puesta excedido" en el parámetro RESP_TO.
Rango admisible: 1-65535 (ms)

16#8280

Acuse negativo al leer el módulo

Compruebe la entrada en el parámetro PORT.
Encontrará información más detallada sobre la causa
del error en los parámetros estáticos Send_Con‐
fig.RDREC.STATUS, Receive_Config.RDREC.STA‐
TUS o RDREC.STATUS, así como en la descripción
del SFB RDREC.

16#8281

Acuse negativo al escribir en el módulo

Compruebe la entrada en el parámetro PORT.
Encontrará información más detallada sobre la causa
del error en los parámetros estáticos Send_Con‐
fig.WRREC.STATUS, Receive_Config.WRREC.STA‐
TUS o WRREC.STATUS, así como en la descripción
del SFB WRREC.

16#8282

Módulo no disponible

Compruebe la entrada en el parámetro PORT y ase‐
gúrese de que el módulo está accesible.

Error de configuración: Modbus_Slave
16#8186

Dirección del esclavo no admisible

Seleccione una dirección del esclavo adecuada en el
parámetro MB_ADDR.
Se admiten: 1-247 con área de direcciones estándar;
1-65535 con área de direcciones ampliada
(0 está reservado para Broadcast)

16#8187

4538

Valor no admisible en el parámetro MB_HOLD_REG

Seleccione un valor adecuado para el Holding Regis‐
ter en el parámetro MB_HOLD_REG.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error

Descripción

Solución

16#8188

Modo de operación no admisible o Broadcast
(MB_ADDR = 0) y parámetro MODE ≠ 1

En el modo de operación Broadcast seleccione el
valor 1 para MODE o elija un modo de operación dis‐
tinto.

16#818C

El puntero hacia un área MB_HOLD_REG debe ser un
bloque de datos o un área de marcas.

Seleccione un valor adecuado para el puntero hacia
el área MB_HOLD_REG.

16#8280

Acuse negativo al leer el módulo

Compruebe la entrada en el parámetro PORT.
Encontrará información más detallada sobre la causa
del error en los parámetros estáticos
Send_P2P.RDREC.STATUS o Recei‐
ve_P2P.RDREC.STATUS, así como en la descrip‐
ción del SFB RDREC.

16#8281

Acuse negativo al escribir en el módulo

Compruebe la entrada en el parámetro PORT.
Encontrará información más detallada sobre la causa
del error en los parámetros estáticos
Send_P2P.WRREC.STATUS o Recei‐
ve_P2P.WRREC.STATUS, así como en la descrip‐
ción del SFB WRREC.

16#8452 1)

MB_HOLD_REG no señala a ningún DB ni área de
marcas

Compruebe el puntero MB_HOLD_REG

16#8453 1)

MB_HOLD_REG no es un puntero del tipo BOOL o
WORD

Compruebe el puntero MB_HOLD_REG

16#8454 1)

La longitud del área direccionada con
MB_HOLD_REG supera la longitud del DB o el área
direccionada es demasiado pequeña para el número
de datos que deben leerse o escribirse.

Compruebe el puntero MB_HOLD_REG

16#8455 1)

MB_HOLD_REG señala a un DB protegido contra es‐ Compruebe el puntero MB_HOLD_REG
critura

16#8456 1)

Error al ejecutar la instrucción. La causa del error figura Determine el valor del parámetro SFCSTATUS. Lea
en el parámetro estático STATUS.
su significado en la descripción del SFC51, paráme‐
tro STATUS.

Error de configuración: Modbus_Master
16#8180

Valor no admisible para el parámetro MB_DB

El valor parametrizado para MB_DB (DB de datos de
instancia) en la instrucción Modbus_Comm_Load no
es admisible.
Compruebe la interconexión de la instrucción Mod‐
bus_Comm_Load y sus mensajes de error.

16#8186

Dirección de estación no admisible

Seleccione una dirección de estación adecuada en el
parámetro MB_ADDR.
Se admiten: 1-247 con área de direcciones estándar;
1-65535 con área de direcciones ampliada
(0 está reservado para Broadcast)

16#8188

Modo de operación no admisible o Broadcast
(MB_ADDR = 0) y parámetro MODE ≠ 1

En el modo de operación Broadcast, seleccione el
valor 1 para MODE o elija un modo de operación dis‐
tinto.

16#8189

Dirección de datos no admisible

Seleccione un valor adecuado para la dirección de
datos en el parámetro DATA_ADDR.
Consulte la descripción Modbus_Master (Pági‐
na 4514) en el sistema de información

Programación del PLC
Manual de programación y manejo, 11/2019

4539

Instrucciones
4.1 Instrucciones
Código de
error

Descripción

Solución

16#818A

Indicación de longitud no válida

Seleccione una longitud de datos adecuada en el pa‐
rámetro DATA_LEN.
Consulte la descripción Modbus_Master (Pági‐
na 4514) en el sistema de información

16#818B

Valor no admisible para DATA_PTR

Seleccione un valor adecuado para el puntero de da‐
tos (dirección M o DB) en el parámetro DATA_PTR.
Consulte la descripción Modbus_Master (Pági‐
na 4514) en el sistema de información

16#818C

Error de interconexión del parámetro DATA_PTR

Compruebe la interconexión de la instrucción.

16#818D

La longitud del área direccionada con DATA_PTR re‐
basa la longitud del DB o el área direccionada es de‐
masiado pequeña para el número de datos que debe
leerse o escribirse.

Compruebe el puntero DATA_PTR

16#8280

Acuse negativo al leer el módulo

Compruebe la entrada en el parámetro PORT.
Encontrará información más detallada sobre la causa
del error en los parámetros estáticos
Send_P2P.RDREC.STATUS o Recei‐
ve_P2P.RDREC.STATUS, así como en la descrip‐
ción del SFB RDREC.

16#8281

Acuse negativo al escribir en el módulo

Compruebe la entrada en el parámetro PORT.
Encontrará información más detallada sobre la causa
del error en los parámetros estáticos
Send_P2P.WRREC.STATUS, Recei‐
ve_P2P.WRREC.STATUS o Receive_Reset, así co‐
mo en la descripción del SFB WRREC.

Error de comunicación - Modbus_Master y Modbus_Slave
16#80D1

El tiempo de espera a XON o CTS = ON ha transcurri‐ El interlocutor falla, es demasiado lento o está offline.
do.
Compruebe el interlocutor o modifique la parametri‐
zación en caso necesario.

16#80D2

"Hardware RTS siempre ON": orden de transmisión
cancelada por cambio de DSR = ON a OFF

Compruebe el interlocutor. Asegúrese de que DSR
está ON durante toda la transferencia.

16#80E0

Telegrama cancelado: Desbordamiento del búfer de
transmisión / telegrama de transmisión demasiado
grande

En el programa de usuario llame la instrucción con
más frecuencia o parametrice una comunicación con
control del flujo de datos.

16#80E1

Telegrama cancelado: error de paridad

Compruebe la línea de conexión de los interlocutores
y asegúrese de que en ambos interlocutres esté ajus‐
tada la misma velocidad de transmisión, la misma pa‐
ridad y el mismo número de bits de parada.

16#80E2

Telegrama cancelado: error de trama

Compruebe los ajustes de bit de inicio, bits de datos,
bit de paridad, velocidad de transferencia de datos y
bit(s) de parada.

16#80E3

Telegrama cancelado: error de desbordamiento de ca‐ Compruebe el número de datos en el telegrama del
racteres
interlocutor.

16#80E4

Telegrama cancelado: longitud máxima de telegrama
alcanzada

Seleccione una longitud de telegrama menor en el
interlocutor.
Se admiten (en función del módulo):
1-1024/2048/4096 (bytes)

Error de comunicación - Modbus_Master

4540

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error

Descripción

Solución

16#80C8

El esclavo no responde dentro del tiempo ajustado

Compruebe la velocidad de transferencia de datos, la
paridad y el cableado del esclavo.

16#80C9

El esclavo no responde dentro del tiempo ajustado
mediante Blocked_Proc_Timeout.

Compruebe el ajuste de Blocked_Proc_Timeout.

16#8200

La interfaz está ocupada por una orden en curso.

Compruebe si el módulo se ha parametrizado con la
instrucción Modbus_Comm_Load. Tal vez tenga que
reparametrizarse el módulo mediante Mod‐
bus_Comm_Load tras desenchufar/enchufar o tras
restablecerse la corriente.
Repita la orden más tarde. Asegúrese de que no se
esté ejecutando ninguna orden antes de iniciar una
nueva.

Error de protocolo - Modbus_Slave (solo módulos de comunicaciones compatibles con Modbus)
16#8380

Error CRC

Error de suma de verificación del telegrama Modbus.
Compruebe el interlocutor.

16#8381

El código de función no se soporta o no se soporta para Compruebe el interlocutor y asegúrese de que se en‐
Broadcast.
vía un código de función válido.

16#8382

Indicación de longitud no válida en el telegrama de
orden

16#8383

Dirección de datos no válida en el telegrama de orden Seleccione un valor adecuado para la dirección de
datos en el parámetro DATA_ADDR.

16#8384

Error de valor de datos no válido en el telegrama de
orden

Compruebe el valor de datos en el telegrama de or‐
den del maestro Modbus

16#8385

El esclavo Modbus no soporta el valor de diagnóstico
(código de función 08)

El esclavo Modbus solo soporta los valores de diag‐
nóstico 16#0000 y 16#000A.

Seleccione una longitud de datos adecuada en el pa‐
rámetro DATA_LEN.

Error de protocolo - Modbus_Master (solo módulos de comunicaciones compatibles con Modbus)
16#8380

Error CRC

Error de suma de verificación del telegrama Modbus.
Compruebe el interlocutor.

16#8381

Telegrama de respuesta de Modbus Slave con men‐
saje de error: El código de función no se soporta.

Compruebe el interlocutor y asegúrese de que se en‐
vía un código de función válido.

16#8382

Telegrama de respuesta de Modbus Slave con men‐
saje de error: Indicación de longitud no válida

Seleccione una longitud de datos adecuada.

16#8383

Telegrama de respuesta de Modbus Slave con men‐
saje de error: Dirección de datos no válida en el tele‐
grama de orden

Seleccione un valor adecuado para la dirección de
datos en el parámetro DATA_ADDR.

16#8384

Telegrama de respuesta de Modbus Slave con men‐
saje de error: Error de valor de datos

Compruebe el telegrama de orden en el esclavo Mod‐
bus.

16#8385

Telegrama de respuesta de Modbus Slave con men‐
saje de error: El esclavo Modbus no soporta el valor de
diagnóstico

Los esclavos Modbus solo soportan los valores de
diagnóstico 16#0000 y 16#000A.

16#8386

El código de función devuelto no concuerda con el có‐ Compruebe el telegrama de respuesta y el direccio‐
digo de función solicitado.
namiento del esclavo.

16#8387

Un esclavo no consultado responde

Compruebe el telegrama de respuesta del esclavo.
Compruebe los ajustes de direcciones de los escla‐
vos.

16#8388

Error en la respuesta del esclavo a una orden de es‐
critura.

Compruebe el telegrama de respuesta del esclavo.

16#8828 1)

DATA_PTR señala a una dirección de bit diferente de
n*8

Compruebe el puntero DATA_PTR

Programación del PLC
Manual de programación y manejo, 11/2019

4541

Instrucciones
4.1 Instrucciones
Código de
error

Descripción

16#8852 1)

DATA_PTR no señala a ningún DB ni área de marcas Compruebe el puntero DATA_PTR

16#8853

Solución

1)

DATA_PTR no es un puntero del tipo BOOL o WORD Compruebe el puntero DATA_PTR

16#8855 1)

DATA_PTR señala a un DB protegido contra escritura Compruebe el puntero DATA_PTR

16#8856 1)

Error al llamar el SFC51

Repita la llamada de la instrucción Modbus_Master

Error - Modbus_Slave (solo módulos de comunicaciones compatibles con Modbus)
16#8428 1)

MB_HOLD_REG señala a una dirección de bit diferen‐ Compruebe el puntero MB_HOLD_REG
te de n * 8

16#8452 1)

MB_HOLD_REG no señala a ningún DB ni área de
marcas

Compruebe el puntero MB_HOLD_REG

16#8453 1)

MB_HOLD_REG no es un puntero del tipo BOOL o
WORD

Compruebe el puntero MB_HOLD_REG

16#8454 1)

La longitud del área direccionada con
MB_HOLD_REG supera la longitud del DB o el área
direccionada es demasiado pequeña para el número
de datos que deben leerse o escribirse.

Compruebe el puntero MB_HOLD_REG

16#8455 1)

MB_HOLD_REG señala a un DB protegido contra es‐ Compruebe el puntero MB_HOLD_REG
critura

16#8456 1)

Error al llamar el SFC51

Repita la llamada de la instrucción Modbus_Slave

Códigos de error generales
16#8FFF
1)

El módulo no está operativo temporalmente debido a
un reset.

Repita la consulta.

Solo en instrucciones para CPU S7-300/400

Interfaz serie ET 200S
Notas sobre el uso en una S7-1500
S_SEND / S_RCV / S_USSI / S_MODB a S7‑1500
Tenga en cuenta lo siguiente si utiliza las instrucciones S_SEND, S_RCV, S_USSI o S_MODB
de la periferia descentralizada ET 200S 1SI en una S7‑1500:
● S_SEND
Tipo de datos del parámetro DB_NO: UInt.
Solamente pueden enviarse datos de áreas de memoria no optimizadas. Tenga esto en
cuenta durante la parametrización de los parámetros DB_NO, DBB_NO y LEN.
● S_RCV
Tipo de datos del parámetro DB_NO: UInt.
Solamente pueden recibirse datos de áreas de memoria no optimizadas. Tenga esto en
cuenta durante la parametrización de los parámetros DB_NO, DBB_NO y LEN.

4542

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● S_USSI
– Tipo de datos de los parámetros DBND, DBPA y DBCP: UInt
Números de DB admisibles para los parámetros DBND, DBPA y DBCP: 60000 a 60999
– Comportamiento de la CPU en caso de error
En caso de error, la CPU no pasa a STOP.
Si se desea que la CPU pase a STOP en caso de error, debe evaluarse el parámetro
ANZ en el programa de usuario
(si ANZ es distinto de cero, debe llamarse a la instrucción STP):
● S_MODB
Tipo de datos del parámetro DB_NO: DB_ANY.
Solamente pueden intercambiarse datos de áreas de memoria no optimizadas. Tenga esto
en cuenta durante la parametrización del parámetro DB_NO y del bloque de datos con la
tabla de direcciones de datos Modbus.

Instrucciones de la librería "Procesador de comunicaciones > Interfaz serie ET200S"
Tenga en cuenta lo siguiente si utiliza las instrucciones de la periferia descentralizada
ET 200S 1SI en una S7‑1500 (librería: "Procesador de comunicaciones > Interfaz serie
ET200S"):
● En el parámetro LADDR debe parametrizarse el identificador de hardware del módulo de
comunicaciones.
● Tanto el búfer de transmisión como el de recepción deben estar en el área de memoria no
optimizada.

Instrucciones de la ET 200S 1SI
Encontrará las descripciones de las instrucciones de la ET 200S 1SI en los siguientes
capítulos:
● ET 200S 1SI para 3964(R) y ASCII (Página 7195)
● ET 200S 1SI de Modbus (Página 7213)
● ET 200S 1SI de USS (Página 7231)

Punto a punto
PORT_CFG: Configurar parámetros de comunicación dinámicamente
Nota
Uso con CM1241
Esta instrucción solo puede utilizarse con un CM1241 a partir de la versión de firmware V2.1
del módulo.

Programación del PLC
Manual de programación y manejo, 11/2019

4543

Instrucciones
4.1 Instrucciones

Descripción
La instrucción "PORT_CFG" sirve para configurar dinámicamente los parámetros de
comunicación de un puerto de comunicación punto a punto.
La configuración estática original del puerto se ajusta en la configuración de hardware. Esta
configuración se puede modificar ejecutando la instrucción "PORT_CFG". Esta función
también sirve, por ejemplo, para guardar en librerías los bloques creados y no tener que
configurar el puerto en la configuración del hardware en caso de reutilizarlos.
"PORT_CFG" permite modificar los siguientes ajustes de los parámetros de comunicación:
● Paridad
● Velocidad de transferencia
● Número de bits por carácter
● Número de bits de parada
● Tipo y propiedades del control de flujo
Las modificaciones realizadas por la instrucción "PORT_CFG" no se guardan de forma
permanente en el sistema de destino.
Los datos serie pueden transferirse vía las conexiones eléctricas RS-232 (semidúplex y
dúplex) y RS-485 (semidúplex).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "PORT_CFG":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Activa la modificación de la configuración cuando se
detecta un flanco ascendente.

PORT

Input

PORT

I, Q, M, D, L o cons‐
tante

Identificación del puerto de comunicación (ID HW)

PROTOCOL

Input

UINT

I, Q, M, D, L o cons‐
tante

Protocolo de transmisión:
● 0: protocolo de comunicación punto a punto
● 1..n: definición futura para protocolos de
transmisión específicos

4544

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

BAUD

Input

UINT

I, Q, M, D, L o cons‐
tante

Velocidad de transferencia del puerto:
● 1: 300 baudios
● 2: 600 baudios
● 3: 1200 baudios
● 4: 2400 baudios
● 5: 4800 baudios
● 6: 9600 baudios (ajuste estándar)
● 7: 19200 baudios
● 8: 38400 baudios
● 9: 57600 baudios
● 10: 76800 baudios
● 11: 115200 baudios

PARITY

Input

UINT

I, Q, M, D, L o cons‐
tante

Paridad del puerto:
● 1: Sin paridad (ajuste estándar)
● 2: Paridad par
● 3: Paridad impar
● 4: Selección de paridad
● 5: Espacio de paridad

DATABITS

Input

UINT

I, Q, M, D, L o cons‐
tante

Bits por carácter:
● 1: 8 bits por carácter (ajuste estándar)
● 2: 7 bits por carácter

STOPBITS

Input

UINT

I, Q, M, D, L o cons‐
tante

Número de bits de parada:
● 1: 1 bit de parada (ajuste estándar)
● 2: 2 bits de parada

FLOWCTRL

Input

UINT

I, Q, M, D, L o cons‐
tante

Control de flujo de datos:
● 1: Ninguno (ajuste estándar)
● 2: XON/XOFF
● 3: Control de flujo por hardware (RTS activado
permanentemente)
● 4: Control de flujo por hardware (RTS
desactivable durante la transferencia)

XONCHAR

Input

CHAR

I, Q, M, D, L o cons‐
tante

Indica el carácter que se utiliza como XON. El ajuste
estándar es el carácter DC1 (11H).

XOFFCHAR

Input

CHAR

I, Q, M, D, L o cons‐
tante

Indica el carácter que se utiliza como XOFF. El ajuste
estándar es el carácter DC3 (13H).

WAITTIME

Input

UINT

I, Q, M, D, L o cons‐
tante

Indica el tiempo de espera hasta XON o CTS tras el
inicio de la transferencia.
El valor especificado debe ser mayor que 0. El ajuste
estándar es 2000 milisegundos.

DONE

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores siguientes:
● 0: Petición no iniciada aún o en ejecución
● 1: Petición finalizada sin errores

Programación del PLC
Manual de programación y manejo, 11/2019

4545

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores siguientes:
● 0: Ningún error
● 1: Se han producido errores

STATUS

Output

WORD

I, Q, M, D, L

Estado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de error* Descripción
(W#16#...)
80A0

El protocolo especificado no es válido.

80A1

La velocidad de transferencia especificada no es válida.

80A2

La paridad especificada no es válida.

80A3

El número indicado de bits por carácter no es válido.

80A4

El número indicado de bits de parada no es válido.

80A5

El tipo indicado de control de flujo no es válido.

80A6

Valor erróneo en el parámetro WAITTIME
Si el control de flujo de datos está activado, el valor del parámetro WAITTIME debe ser mayor que cero.

80A7

Valores no válidos en los parámetros XONCHAR y XOFFCHAR.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Encontrará más información sobre los códigos de error generales de las instrucciones de
comunicación en: "Información general sobre el estado de los bloques de comunicación
(Página 4565)".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

SEND_CFG: Configurar parámetros de transmisión serie dinámicamente
Nota
Uso con CM1241
Esta instrucción solo puede utilizarse con un CM1241 a partir de la versión de firmware V2.1
del módulo.

4546

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Descripción
La instrucción "SEND_CFG" permite configurar dinámicamente los parámetros de
transferencia serie de un puerto de comunicación punto a punto. Todos los mensajes
pendientes para la transferencia se rechazan tras la ejecución de "SEND_CFG".
La configuración estática original del puerto se ajusta en la configuración de hardware. Esta
configuración se puede modificar ejecutando la instrucción "SEND_CFG". Esta función
también sirve, por ejemplo, para guardar en librerías los bloques creados y no tener que
configurar el puerto en la configuración del hardware en caso de reutilizarlos. "SEND_CFG"
permite modificar los siguientes ajustes de los parámetros de transferencia:
● Intervalo entre la activación de RTS (Request to Send) y el inicio de la transferencia
● Intervalo entre el final de la transferencia y la desactivación de RTS
● Definir tiempos de bit para pausas
Las modificaciones realizadas por la instrucción "SEND_CFG" no se guardan de forma
permanente en el sistema de destino.
Los datos serie pueden transferirse vía las conexiones eléctricas RS-232 (semidúplex y
dúplex) y RS-485 (semidúplex).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SEND_CFG":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Activa la modificación de la configuración cuando se
detecta un flanco ascendente.

PORT

Input

PORT

I, Q, M, D, L o cons‐
tante

Identificación del puerto de comunicación (ID HW)

RTSONDLY

Input

UINT

I, Q, M, D, L o cons‐
tante

Tiempo que debe transcurrir desde la activación de
RTS hasta el inicio de la transferencia.
Los valores válidos para este parámetro son:
● 0 (ajuste estándar)
● de 0 a 65535 ms en incrementos de 1 ms
Este parámetro no es válido para los módulos
RS-485.

RTSOFFDLY

Input

UINT

I, Q, M, D, L o cons‐
tante

Tiempo que debe transcurrir desde el final de la trans‐
ferencia hasta la desactivación de RTS.
Los valores válidos para este parámetro son:
● 0 (ajuste estándar)
● de 0 a 65535 ms en incrementos de 1 ms
Este parámetro no es válido para los módulos
RS-485.

BREAK

Input

UINT

I, Q, M, D, L o cons‐
tante

Indica los tiempos de bit para una pausa que se envía
al inicio del mensaje.
El ajuste estándar es 12 tiempos de bit. Se admiten
como máximo 25000 tiempos de bit.

Programación del PLC
Manual de programación y manejo, 11/2019

4547

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

IDLELINE

Input

UINT

I, Q, M, D, L o cons‐
tante

Indica los tiempos de bit para Idle Line tras la pausa al
inicio del mensaje.
El ajuste estándar es 12 tiempos de bit. Se admiten
como máximo 25000 tiempos de bit.

DONE

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores siguientes:
● 0: Petición no iniciada aún o en ejecución
● 1: Petición finalizada sin errores

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores siguientes:
● 0: Ningún error
● 1: Se han producido errores

STATUS

Output

WORD

I, Q, M, D, L

Estado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de error* Descripción
(W#16#...)
80B0

No está permitido configurar una interrupción de la transferencia

80B1

El tiempo de pausa especificado excede el máximo permitido de 25000 tiempos de bit

80B2

El tiempo especificado para Idle Line excede el máximo permitido de 25000 tiempos de bit

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Encontrará más información sobre los códigos de error generales de las instrucciones de
comunicación en: "Información general sobre el estado de los bloques de comunicación
(Página 4565)".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

RCV_CFG: Configurar parámetros de recepción serie dinámicamente
Nota
Uso con CM1241
Esta instrucción solo puede utilizarse con un CM1241 a partir de la versión de firmware V2.1
del módulo.

4548

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Descripción
La instrucción "RCV_CFG" permite configurar dinámicamente los parámetros de recepción
serie de un puerto de comunicación punto a punto. Esta instrucción permite configurar las
condiciones que determinan el principio y fin de un mensaje que debe transferirse. La
recepción de los mensajes que cumplen dichas condiciones se habilita mediante la instrucción
"RCV_PTP (Página 4559)".
La configuración estática original del puerto se ajusta en las propiedades de la configuración
de hardware. Ejecute la instrucción "RCV_CFG" en el programa con objeto de modificar la
configuración. Esta función también sirve, por ejemplo, para guardar en librerías los bloques
creados y no tener que configurar el puerto en la configuración del hardware en caso de
reutilizarlos. Las modificaciones realizadas por la instrucción "RCV_CFG" no se guardan de
forma permanente en el sistema de destino.
Todos los mensajes pendientes para la transferencia se rechazan tras la ejecución de la
instrucción "RCV_CFG".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RCV_CFG":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Activa la modificación de la configuración
cuando se detecta un flanco ascendente.

PORT

Input

PORT

I, Q, M, D, L o cons‐
tante

Identificación del puerto de comunicación
(ID HW)

CONDITIONS

Input

CONDITIONS

D, L

Estructura de datos que define las condicio‐
nes de inicio y fin de la transferencia de da‐
tos.

DONE

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores si‐
guientes:
● 0: Petición no iniciada aún o en ejecución
● 1: Petición finalizada sin errores

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores si‐
guientes:
● 0: Ningún error
● 1: Se han producido errores.

STATUS

Output

WORD

I, Q, M, D, L

Estado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Programación del PLC
Manual de programación y manejo, 11/2019

4549

Instrucciones
4.1 Instrucciones

Tipo de datos CONDITIONS
Por medio de la estructura CONDITIONS se definen las condiciones de inicio y fin para la
transferencia de mensajes. La estructura CONDITIONS está incluida en el bloque de datos de
instancia de la instrucción "RCV_CFG". Por medio de la estructura CONDITIONS se definen
las condiciones de inicio y fin, el momento en el que finaliza la transferencia de un mensaje y
el momento en el que empieza la siguiente.
● La condición de inicio para la transferencia de datos se define en la estructura START
● La condición de fin para la transferencia de datos se define en la estructura END
Es posible definir una o varias condiciones de inicio y fin. Si se especifican varias condiciones
de inicio o fin, se enlazan con una puerta O.

4550

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra la estructura CONDITIONS:
Parámetro

Tipo de datos

Descripción

START

STRUCT

Condiciones de inicio

UINT

Especifica la condición de inicio (detalles más abajo).

STARTCOND

La condición de inicio se especifica en forma de valor hexadecimal de 16 bits. Los
valores posibles para dicha condición son:
● 1: carácter inicial
● 2: cualquier carácter (ajuste estándar)
● 4: Line break
● 8: Idle line
● 16: cadena de caracteres 1
● 32: cadena de caracteres 2
● 64: cadena de caracteres 3
● 128: cadena de caracteres 4
También es posible definir varias condiciones de inicio en el parámetro START‐
COND. Para ello se indica la suma de los valores de las diferentes condiciones. Si,
por ejemplo, debe definirse la condición de inicio "Idle line" O "cadena de carac‐
teres 1" O "cadena de caracteres 4", hay que especificar el valor "152".
IDLETIME

UINT

Indica el tiempo de pausa máximo de la línea antes de iniciar la recepción.
Los valores válidos para este parámetro son:
● 40 tiempos de bit (ajuste estándar)
● de 0 a 2500 tiempos de bit

STARTCHAR

BYTE

Especifica el carácter inicial. Dicho ajuste sólo es efectivo si la condición de inicio
configurada es "carácter inicial".
Los valores válidos para este parámetro son:
● 02 (STX): ajuste estándar
● B#16#00 a B#16#FF

SEQ[1].CTL

BYTE

Cadena de caracteres 1: control de cada carácter
La posición de bit de los caracteres permite determinar qué caracteres de la ca‐
dena se consideran o ignoran. Para evaluar los caracteres hay que activar los bits
correspondientes.
● Bit 0: 1 carácter
● Bit 1: 2 caracteres
● Bit 2: 3 caracteres
● Bit 3: 4 caracteres
● Bit 4: 5 caracteres
Un carácter se ignora cuando se desactiva el bit correspondiente.

SEQ[1].STR

CHAR[5]

SEQ[2].CTL

BYTE

Cadena de caracteres 2: ignorar/comparar el control de cada carácter

SEQ[2].STR

CHAR[5]

Cadena de caracteres 2: carácter inicial (5 caracteres)

SEQ[3].CTL

BYTE

Cadena de caracteres 3: ignorar/comparar el control de cada carácter

SEQ[3].STR

CHAR[5]

Cadena de caracteres 3: carácter inicial (5 caracteres)

SEQ[4].CTL

BYTE

Cadena de caracteres 4: ignorar/comparar el control de cada carácter

SEQ[4].STR

CHAR[5]

Cadena de caracteres 4: carácter inicial (5 caracteres)

Programación del PLC
Manual de programación y manejo, 11/2019

Cadena de caracteres 1: carácter inicial (5 caracteres)

4551

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de datos

Descripción

END

STRUCT

Condiciones de fin

4552

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro
ENDCOND

Tipo de datos

Descripción

UINT

Especifica la condición de fin (detalles más abajo).
La condición de fin se especifica en forma de valor hexadecimal de 16 bits. Los
valores posibles para dicha condición son:
● 1: tiempo de respuesta excedido
● 2: tiempo de mensaje excedido
● 4: tiempo excedido dentro de la cadena de caracteres
● 8: longitud máxima
● 16: N+LEN+M; la información sobre la longitud del mensaje está integrada en
él y es evaluada.
● 32: cadena de caracteres 1
También es posible definir varias condiciones de fin en el parámetro ENDCOND.
Para ello se indica la suma de los valores de las diferentes condiciones de fin. Si,
por ejemplo, debe definirse la condición de fin "longitud máxima" O "secuencia 1",
hay que especificar el valor "40".

MAXLEN

UINT

Indica el número de caracteres máximo de un mensaje.
Los valores* válidos para este parámetro son:
● 1 carácter (ajuste estándar)
● de 0 a 1024 caracteres
Dicho ajuste sólo es efectivo si se ha ajustado la condición de fin "longitud máxima"
en el parámetro ENDCOND.

N

UINT

Offset del campo de longitud en un mensaje
Los valores válidos para este parámetro son:
● 0 caracteres (ajuste estándar)
● de 0 a 1024 caracteres
Dicho ajuste sólo es efectivo si se ha ajustado la condición de fin "N+LEN+M" en
el parámetro ENDCOND.

LENGTHSIZE

UINT

Tamaño del campo de longitud en bytes
Los valores* válidos para este parámetro son:
● 0 bytes (ajuste estándar)
● 1 byte
● 2 bytes
● 4 bytes
Dicho ajuste sólo es efectivo si se ha ajustado la condición de fin "N+LEN+M" en
el parámetro ENDCOND.

LENGTHM

UINT

Especifica el número de caracteres de fin que siguen al campo de longitud pero
que no están contenidos en la longitud del mensaje.
Los valores válidos para este parámetro son:
● 0 caracteres (ajuste estándar)
● de 0 a 255 caracteres
Dicho ajuste sólo es efectivo si se ha ajustado la condición de fin "N+LEN+M" en
el parámetro ENDCOND.

RCVTIME

UINT

Indica la duración máxima para la recepción del primer carácter de un mensaje.
Los valores válidos para este parámetro son:
● 200 ms (ajuste estándar)

Programación del PLC
Manual de programación y manejo, 11/2019

4553

Instrucciones
4.1 Instrucciones
Parámetro

Tipo de datos

Descripción
● de 0 a 65535 ms en incrementos de 1 ms
Dicho ajuste sólo es efectivo si se ha ajustado la condición de fin "tiempo de
respuesta excedido" en el parámetro ENDCOND.

MSGTIME

UINT

Indica la duración máxima para la recepción de un mensaje.
Los valores válidos para este parámetro son:
● 200 ms (ajuste estándar)
● de 0 a 65535 ms en incrementos de 1 ms
Dicho ajuste sólo es efectivo si se ha ajustado la condición de fin "tiempo de
mensaje excedido" en el parámetro ENDCOND.

CHARGAP

UINT

Especifica el intervalo entre la recepción de dos caracteres consecutivos.
Los valores válidos para este parámetro son:
● 12 tiempos de bit (ajuste estándar)
● de 0 a 2500 tiempos de bit
Dicho ajuste sólo es efectivo si se ha ajustado la condición de fin "tiempo excedido
dentro de la cadena de caracteres" en el parámetro ENDCOND.

SEQ.CTL

BYTE

Cadena de caracteres: control de cada carácter
La posición de bit de los caracteres permite determinar qué caracteres de la ca‐
dena se consideran o ignoran. Para evaluar los caracteres hay que activar los bits
correspondientes.
● Bit 0: 1 carácter
● Bit 1: 2 caracteres
● Bit 2: 3 caracteres
● Bit 3: 4 caracteres
● Bit 4: 5 caracteres
Un carácter se ignora cuando se desactiva el bit correspondiente.

SEQ.STR

CHAR[5]

Cadena de caracteres: carácter inicial (5 caracteres)

* Estos rangos también son aplicables a los respectivos ajustes de hardware para la definición del final del mensaje.

Condiciones de inicio para la recepción de un mensaje (parámetro STARTCOND)
El receptor detecta el inicio de un mensaje cuando se produce la condición de inicio
configurada. Las condiciones siguientes pueden definirse como iniciales para la recepción de
mensajes:
● Carácter inicial: el inicio de un mensaje se detecta cuando aparece un carácter
determinado. Dicho carácter se guarda como primer carácter del mensaje. Todos los
caracteres recibidos antes del carácter inicial se rechazan.
● Cualquier carácter: un carácter cualquiera define el inicio de un mensaje. Dicho carácter se
guarda como primer carácter del mensaje.
● Line Break: el inicio de un mensaje se detecta cuando el flujo de datos recibidos se ha
interrumpido durante un tiempo superior a la longitud de un carácter.

4554

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● Idle Line: el inicio de un mensaje se detecta cuando la línea de transferencia está en reposo
durante un tiempo determinado (indicado en tiempos de bit) y, después, se siguen
transfiriendo caracteres.
● Cadena de caracteres (secuencia): el inicio de un mensaje se detecta cuando aparece una
cadena de caracteres determinada en el flujo de datos. Se admiten como máximo cuatro
secuencias de cinco caracteres cada una como máximo.
Ejemplo: Un mensaje recibido con código hexadecimal contiene los siguientes caracteres:
"68 10 aa 68 bb 10 aa 16". Las cadenas de caracteres de inicio configuradas se muestran
en la siguiente
tabla. Las cadenas de caracteres de inicio son evaluadas después de que el primer carácter
68H
ha sido recibido correctamente. Después de recibir correctamente el cuarto carácter (el
segundo 68H) se cumple la condición de inicio "1". Una vez cumplidas las condiciones de
inicio,
comienza la evaluación de las condiciones de fin.
El procesamiento de la cadena de caracteres de inicio puede cancelarse debido a distintos
errores de paridad,
framing o intervalos entre los caracteres. Estos errores hacen
que el mensaje no se reciba por no cumplirse la condición de inicio.

Condición de ini‐ Primer carácter
cio

Primer carácter +1

Primer carácter +2

Primer carácter +3

Primer carácter +4

1

xx

xx

68H

xx

68H

2

10H

aaH

xx

xx

xx

3

dcH

aaH

xx

xx

xx

4

e5H

xx

xx

xx

xx

Condiciones de fin para la recepción de un mensaje (parámetro ENDCOND)
El receptor detecta el fin de un mensaje cuando se produce la condición de fin configurada. Las
condiciones siguientes pueden definirse como finales para la recepción de mensajes:
● Tiempo de respuesta excedido: La recepción de un mensaje finaliza cuando se excede la
duración máxima predefinida para la recepción de un carácter. La duración máxima se
define en el parámetro RCVTIME. El transcurso del tiempo definido se inicia en cuanto ha
finalizado la última transferencia y la instrucción RCV_PTP habilita la recepción del
mensaje. Si dentro del tiempo definido (RCVTIME) no se ha recibido ningún carácter, la
instrucción RCV_PTP notifica un error.
● Tiempo de mensaje excedido: La recepción de un mensaje finaliza cuando se excede la
duración máxima predefinida para la recepción de un mensaje. La duración máxima se
define en el parámetro MSGTIME. El transcurso del tiempo definido se inicia en cuanto se
ha recibido el primer carácter del mensaje.
● Tiempo excedido dentro de la cadena de caracteres: La recepción de un mensaje finaliza
cuando el intervalo de tiempo entre la recepción de dos caracteres consecutivos es mayor
que el valor del parámetro CHARGAP.
● Longitud máxima: La recepción de un mensaje finaliza cuando se excede la longitud del
mensaje definida en el parámetro MAXLEN .

Programación del PLC
Manual de programación y manejo, 11/2019

4555

Instrucciones
4.1 Instrucciones
● Leer longitud de mensaje (N+LEN+M): La recepción de un mensaje finaliza cuando se
alcanza una longitud de mensaje determinada. Dicha longitud se calcula mediante los
valores de los parámetros siguientes:
– N: posición del carácter en el mensaje a partir del que empieza el campo de longitud.
– LENGTHSIZE: tamaño del campo de longitud en bytes
– LENGTHM: número de caracteres de fin que siguen al campo de longitud. Dichos
caracteres no se toman en consideración al evaluar la longitud del mensaje.
● Cadena de caracteres: La recepción de un mensaje finaliza cuando se recibe una cadena
de caracteres determinada. Dicha cadena admite cinco caracteres como máximo. Para
cada carácter de la cadena es posible definir, a través de la posición de bit, si se considera
o ignora en la evaluación.

Parámetro STATUS
Código de
error*

Descripción

(W#16#...)
80C0

Error en la condición de inicio

80C1

● Error en la condición de fin
● No se ha definido ninguna condición de fin

80C2

Alarma de recepción activada

80C3

Estando activada la condición de fin "longitud máxima", se ha introducido un valor igual a 0 o mayor que 4132
en el parámetro MAXLEN.

80C4

Estando activada la condición de fin "N+LEN+M", se ha introducido un valor mayor que 4131 en el parámetro
N.

80C5

Estando activada la condición de fin "N+LEN+M", se ha introducido un valor igual a 0 o no válido en el
parámetro LENGTHSIZE.

80C6

Estando activada la condición de fin "N+LEN+M", se ha introducido un valor mayor que 255 en el parámetro
LENGTHM.

80C7

Estando activada la condición de fin "N+LEN+M", se ha calculado una longitud de mensaje mayor que 4132.

80C8

Estando activada la condición de fin "tiempo de respuesta excedido", se ha introducido un valor igual a 0 en
el parámetro RCVTIME.

80C9

Estando activada la condición de fin "tiempo excedido dentro de la cadena de caracteres", se ha introducido
un valor igual a 0 o mayor que 2500 en el parámetro CHARGAP.

80CA

Estando activada la condición de inicio "Idle line", se ha introducido un valor igual a 0 o mayor que 2500 en
el parámetro IDLETIME.

80CB

A pesar de haber activado la condición de fin "cadena de caracteres", todos los caracteres de la cadena
están marcados como irrelevantes.

80CC

A pesar de haber activado la condición de inicio "cadena de caracteres", todos los caracteres de la cadena
están marcados como irrelevantes.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Encontrará más información sobre los códigos de error generales de las instrucciones de
comunicación en: "Información general sobre el estado de los bloques de comunicación
(Página 4565)".

4556

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

SEND_PTP: Transmitir datos del búfer de transmisión
Nota
Uso con CM1241
Esta instrucción solo puede utilizarse con un CM1241 a partir de la versión de firmware V2.1
del módulo.

Descripción
La instrucción "SEND_PTP" inicia la transferencia de datos. Sin embargo, la instrucción
"SEND_PTP" no ejecuta la transferencia de datos propiamente dicha. Los datos del búfer de
transmisión se envían al módulo de comunicación punto a punto (CM). El CM realiza entonces
la transferencia propiamente dicha.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SEND_PTP":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Habilitación de la transferencia solicitada al detectar‐
se un flanco ascendente de esa entrada de habilita‐
ción. El contenido del búfer de transmisión se envía al
módulo de comunicación punto a punto (CM).

PORT

Input

PORT

I, Q, M, D, L o cons‐
tante

Identificación del puerto de comunicación (ID HW)

BUFFER

Input

VARIANT

I, Q, M, D, L o cons‐
tante

Puntero hacia la dirección inicial del búfer de transmi‐
sión. Valores booleanos o Array of BOOL no sopor‐
tados.

LENGTH

Input

UINT

I, Q, M, D, L o cons‐
tante

Longitud del búfer de transmisión

PTRCL

Input

BOOL

I, Q, M, D, L o cons‐
tante

Este parámetro selecciona el búfer para la comunica‐
ción punto a punto normal o para protocolos especí‐
ficos de Siemens que están implementados en el CM
conectado.
FALSE = operaciones punto a punto controladas por
el programa de usuario (única opción disponible)

DONE

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores siguientes:
● 0: Petición no iniciada aún o en ejecución
● 1: Petición finalizada sin errores

Programación del PLC
Manual de programación y manejo, 11/2019

4557

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores siguientes:
● 0: Ningún error
● 1: Se han producido errores

STATUS

Output

WORD

I, Q, M, D, L

Estado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de error* Descripción
(W#16#...)
7000

La operación de transmisión no está activa.

7001

La operación de transmisión procesa la primera llamada.

7002

La operación de transmisión procesa las llamadas posteriores (consultas tras la primera llamada).

8080

La identificación introducida para el puerto de comunicación no es válida.

8088

La longitud del parámetro LENGHT no se corresponde con la longitud de los datos que deben transmitirse.
Consulte también: Parámetros LENGHT y BUFFER.

80D0

Se ha recibido una solicitud de transmisión nueva durante una transferencia en curso.

80D1

La transferencia se ha cancelado porque la señal CTS no se ha confirmado dentro del tiempo de espera
especificado.

80D2

La solicitud de transmisión se ha cancelado porque el interlocutor (DCE) no ha señalizado la disponibili‐
dad de recepción (DSR).

80D3

La solicitud de transmisión se ha cancelado porque se ha sobrepasado el tamaño máximo del intervalo de
espera (más de 1024 bytes).

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Encontrará más información sobre los códigos de error generales de las instrucciones de
comunicación en: "Información general sobre el estado de los bloques de comunicación
(Página 4565)".

4558

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros LENGTH y BUFFER
El volumen mínimo de datos que puede enviarse con la instrucción "PTP_SEND" es un byte.
El parámetro BUFFER define el volumen de datos que deben enviarse. Para el tipo de
parámetro BUFFER no se puede utilizar ni el tipo de datos BOOL ni Array of BOOL.
Parámetro LENGTH

Parámetro BUFFER

Descripción

LENGTH = 0

No utilizado

Los datos completos se envían como definidos por el parámetro
BUFFER. Si LENGTH = 0, no es necesario indicar el número de
bytes transferidos.

LENGTH > 0

Tipo de datos simple

El valor LENGTH debe contener el número de bytes de este tipo de
datos. De lo contrario no se produce ninguna transferencia y se
visualiza el error 8088.

STRUCT

El valor LENGTH puede contener un número de bytes inferior a toda
la longitud de bytes de la estructura. En este caso sólo se transfieren
los primeros bytes LENGTH.

ARRAY

El valor LENGTH puede contener un número de bytes inferior a toda
la longitud de bytes del campo. En este caso sólo se transfieren los
elementos de campo que caben completamente en los bytes
LENGTH.
El valor LENGTH debe ser múltiplo del número de bytes de los
elementos de datos. De lo contrario, STATUS = 8088, ERROR = 1
y no se transfiere nada.

STRING

Se transfiere toda la disposición de la memoria del formato de la
cadena de caracteres, y también la información sobre la longitud
máxima de la cadena de caracteres y su longitud actual.
El valor LENGTH debe contener los bytes de longitud máxima, lon‐
gitud real y los caracteres de la cadena.
En el tipo de datos STRING todas las longitudes y caracteres tienen
el tamaño de un byte.
Si para el parámetro BUFFER se utiliza una cadena de caracteres,
el valor LENGTH también debe contener dos bytes para los dos
campos de longitud.

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

RCV_PTP: Habilitar recepción de mensajes
Nota
Uso con CM1241
Esta instrucción solo puede utilizarse con un CM1241 a partir de la versión de firmware V2.1
del módulo.

Programación del PLC
Manual de programación y manejo, 11/2019

4559

Instrucciones
4.1 Instrucciones

Descripción
La instrucción "RCV_PTP" habilita la recepción de un mensaje transmitido. Cada mensaje se
debe habilitar por separado. Los datos transmitidos no están disponibles en el área de
recepción hasta que el interlocutor en cuestión haya acusado el mensaje.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RCV_PTP":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

EN_R

Input

BOOL

I, Q, M, D, L o cons‐ Habilitación de la recepción al detectarse un flanco as‐
tante
cendente.

PORT

Input

PORT

I, Q, M, D, L o cons‐ Identificación del puerto de comunicación (ID HW)
tante

BUFFER

Input

VARIANT

I, Q, M, D, L o cons‐ Apunta a la dirección inicial del búfer de recepción. No
tante
utilice ninguna variable del tipo STRING en el búfer de
recepción.

NDR

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores siguientes:
● 0: Petición no iniciada aún o en ejecución
● 1: Petición finalizada sin errores

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores siguientes:
● 0: Ningún error
● 1: Se han producido errores

STATUS

Output

WORD

I, Q, M, D, L

Estado de la instrucción

LENGTH

Output

UINT

I, Q, M, D, L

Longitud del mensaje en el búfer de recepción

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de error* Descripción
(W#16#....)
80E0

La recepción del mensaje se ha finalizado porque el búfer de recepción está lleno.

80E1

La recepción del mensaje se ha finalizado debido a un error de paridad.

80E2

La recepción del mensaje se ha finalizado debido a un error de framing.

80E3

La recepción del mensaje se ha finalizado debido a un error de desbordamiento.

80E4

La recepción del mensaje se ha finalizado porque la longitud calculada (N+LEN+M) excede el tamaño del
búfer de recepción.

8080

La identificación introducida para el puerto de comunicación no es válida.

8088

Con el parámetro BUFFER se ha creado una referencia al tipo de datos STRING.

0094

La recepción del mensaje se ha finalizado porque se ha alcanzado la longitud máxima de caracteres.

0095

La recepción del mensaje se ha finalizado debido a un tiempo excedido.

0096

La recepción del mensaje se ha finalizado debido a un tiempo excedido dentro de la cadena de caracteres.

0097

La recepción del mensaje se ha finalizado debido a un tiempo de respuesta excedido.

4560

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error* Descripción
(W#16#....)
0098

La recepción del mensaje se ha finalizado porque no se cumple la condición de longitud "N+LEN+M".

0099

La recepción del mensaje se ha finalizado porque se ha recibido la cadena de caracteres definida como
condición de fin.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Encontrará más información sobre los códigos de error generales de las instrucciones de
comunicación en: "Información general sobre el estado de los bloques de comunicación
(Página 4565)".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

RCV_RST: Borrar búfer de recepción
Nota
Uso con CM1241
Esta instrucción solo puede utilizarse con un CM1241 a partir de la versión de firmware V2.1
del módulo.

Descripción
La instrucción "RCV_RST" borra el búfer de recepción de un interlocutor.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "RCV_RST":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Habilitación para borrar el búfer de recepción al de‐
tectarse un flanco ascendente

PORT

Input

PORT

I, Q, M, D, L o cons‐
tante

Identificación del puerto de comunicación (ID HW)

DONE

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores siguientes:
● 0: Petición no iniciada aún o en ejecución
● 1: Petición finalizada sin errores

Programación del PLC
Manual de programación y manejo, 11/2019

4561

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores siguientes:
● 0: Ningún error
● 1: Se han producido errores

STATUS

Output

WORD

I, Q, M, D, L

Estado de la instrucción
Encontrará más información sobre los códigos de
error generales de las instrucciones de comunica‐
ción en: "Información general sobre el estado de los
bloques de comunicación (Página 4565)".

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

SGN_GET: Consultar señales RS-232
Nota
Uso con CM1241
Esta instrucción solo puede utilizarse con un CM1241 a partir de la versión de firmware V2.1
del módulo.

Descripción
La instrucción "SGN_GET" consulta el estado actual de varias señales de un módulo de
comunicación RS-232.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SGN_GET":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Habilitación de consulta al detectarse un flanco
ascendente

PORT

Input

PORT

I, Q, M, D, L o cons‐
tante

Identificación del puerto de comunicación (ID
HW)

NDR

Output

BOOL

I, Q, M, D, L

Se activa durante un ciclo cuando hay nuevos
datos disponibles y la instrucción se ha ejecutado
sin errores.

DTR

Output

BOOL

I, Q, M, D, L

Terminal de datos disponible, módulo listo

DSR

Output

BOOL

I, Q, M, D, L

Juego de datos listo, interlocutor listo

RTS

Output

BOOL

I, Q, M, D, L

Solicitud de transmisión, módulo listo para trans‐
mitir

CTS

Output

BOOL

I, Q, M, D, L

Listo para transmitir; el interlocutor puede recibir
datos (reacción a RTS = módulo ON).

DCD

Output

BOOL

I, Q, M, D, L

Detección de portadora de datos, nivel de señal
de recepción

4562

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RING

Output

BOOL

I, Q, M, D, L

Indicación de timbre, señalización de una llama‐
da entrante

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores siguientes:
● 0: Ningún error
● 1: Se han producido errores

STATUS

Output

WORD

I, Q, M, D, L

Estado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de error*

Descripción

(W#16#....)
80F0

El módulo de comunicación es un módulo RS485; no hay señales disponibles.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Encontrará más información sobre los códigos de error generales de las instrucciones de
comunicación en: "Información general sobre el estado de los bloques de comunicación
(Página 4565)".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

SGN_SET: Activar señales RS-232
Nota
Uso con CM1241
Esta instrucción solo puede utilizarse con un CM1241 a partir de la versión de firmware V2.1
del módulo.

Descripción
La instrucción "SGN_SET" activa el estado de las señales de salida de un módulo de
comunicación RS-232.

Programación del PLC
Manual de programación y manejo, 11/2019

4563

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "SGN_SET":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o cons‐
tante

Activa el proceso cuando se detecta un flanco as‐
cendente.
Valor inicial: FALSE

PORT
SIGNAL

Input
Input

PORT
BYTE

I, Q, M, D, L o cons‐
tante

Identificación del puerto de comunicación (ID HW)

I, Q, M, D, L o cons‐
tante

Especifica las señales que deben activarse:

Valor inicial: FALSE
● 01H = activar RTS
● 02H = activar DTR
● 04H = activar DSR
Valor inicial: FALSE

RTS

Input

BOOL

I, Q, M, D, L o cons‐
tante

Solicitud de transmisión, módulo listo para transmi‐
tir
Valor inicial: FALSE

DTR
DSR

Input
Input

BOOL
BOOL

I, Q, M, D, L o cons‐
tante

Terminal de datos disponible, módulo listo

I, Q, M, D, L o cons‐
tante

Juego de datos listo (aplicable sólo a interfaces tipo
DCE)

Valor inicial: FALSE

Valor inicial: FALSE
DONE

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores siguientes:
● 0: Petición no iniciada aún o en ejecución
● 1: Petición finalizada sin errores
Valor inicial: FALSE

ERROR

Output

BOOL

I, Q, M, D, L

Parámetro de estado con los valores siguientes:
● 0: Ningún error
● 1: Se han producido errores
Valor inicial: FALSE

STATUS

Output

WORD

I, Q, M, D, L

Estado de la instrucción
Valor inicial: 0

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de error*
(W#16#....)

Descripción

80F0

El módulo de comunicación es un módulo RS485; no hay señales disponibles.

80F1

No es posible activar señales porque está activado el control de flujo por hardware.

80F2

La señal DSR no puede activarse porque el módulo es del tipo DTE.

4564

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error*
(W#16#....)

Descripción

80F3

La señal DTR no puede activarse porque el módulo es del tipo DCE.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Encontrará más información sobre los códigos de error generales de las instrucciones de
comunicación en: "Información general sobre el estado de los bloques de comunicación
(Página 4565)".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Información general sobre el estado de los bloques de comunicación
Información general sobre el estado de ejecución de los bloques de comunicación
La tabla siguiente muestra la información general que se muestra en el parámetro STATUS de
los bloques de comunicación:
Código de error* Descripción
(W#16#....)
0000

Ningún error

7000

No se está procesando ninguna petición.

7001

Inicio de la ejecución de la petición. Parámetro BUSY = 1, DONE = 0.

7002

Llamada intermedia (REQ irrelevante): La instrucción ya está activa; BUSY tiene el valor "1".

8x3A

Puntero no autorizado en el parámetro x.

8070

Todas las memorias instancia internas están en uso.

8080

La identificación introducida para el puerto de comunicación no es válida

8081

Tiempo excedido, error del módulo, error interno

8082

La parametrización ha fallado porque se está llevando a cabo una parametrización en segundo plano.

8083

Desbordamiento de búfer: el CM o CB ha devuelto un aviso de recepción con una longitud superior a la
admitida por el parámetro de longitud.

8085

Error al indicar la longitud en el parámetro LENGHT. La longitud indicada es "0" o mayor que el valor
máximo admisible.

8090

Longitud del mensaje no válida, módulo no válido, mensaje no válido

8091

Tipo erróneo en el mensaje de parametrización

8092

Longitud del juego de datos no válido en el mensaje de parametrización

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Programación del PLC
Manual de programación y manejo, 11/2019

4565

Instrucciones
4.1 Instrucciones

USS
Panorámica de las instrucciones USS
Introducción
Las instrucciones USS controlan la operación de accionamientos compatibles con el protocolo
de la interfaz serie universal (USS). Las instrucciones USS permiten que se comunique con
varios accionamientos a través de una conexión RS-485.
Para ello necesita un módulo de comunicación RS485 CM 1241 o una tarjeta de comunicación
RS485 CB 1241. En una CPU S7-1200 se pueden montar hasta tres módulos RS485 CM 1241
y una tarjeta RS485 CB 1241.
Cada puerto RS485 puede operar hasta dieciséis accionamientos.
El protocolo USS usa una red maestro/esclavo para la comunicación a través de un bus serie.
El maestro emplea un parámetro de dirección para enviar un mensaje a un esclavo
seleccionado. Un esclavo no puede efectuar un envío por iniciativa propia sin recibir
previamente una solicitud al respecto. No es posible transmitir mensajes directamente entre
los esclavos individuales. La comunicación USS funciona en modo semidúplex.
La figura siguiente muestra el ejemplo de un diagrama de red USS:
&0
0µGXORV56

&386

$FFLRQDPLHQWRV866UHG

    

          

$FFLRQDPLHQWRV866UHG



4566



 



Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Requisitos para utilizar el protocolo USS
Requisitos generales para la configuración de accionamientos
● Para los accionamientos se debe configurar el uso de 4 palabras de identificador/valor del
parámetro.
● Los accionamientos se pueden configurar para 2, 4, 6 u 8 palabras de datos de proceso.
● La cantidad de palabras de datos de proceso en el accionamiento debe corresponder a la
entrada PZD_LEN de la instrucción "USS_DRIVE (Página 4571)" del accionamiento.
● La velocidad de transferencia de todos los accionamientos debe corresponder a la
velocidad de transferencia en el parámetro de entrada BAUD de la instrucción "USS_PORT
(Página 4570)".
● El accionamiento se debe configurar para mando a distancia.
● En la consigna de frecuencia de la conexión COM del accionamiento se debe determinar
USS.
● En la dirección de accionamiento debe constar 1 a 16. Esta dirección debe corresponder a
la dirección en el parámetro de entrada DRIVE de la instrucción "USS_DRIVE
(Página 4571)".
● Para el control de dirección del accionamiento se debe configurar el uso de la polaridad de
la consigna del accionamiento.
● La red RS485 debe disponer de una terminación correcta.

Definición: Área de identificador/valor del parámetro / área de datos de proceso
● El área de identificador/valor del parámetro hace referencia al tratamiento de la interfaz del
identificador/valor del parámetro (PKW).
La interfaz del identificador/valor del parámetro no es una interfaz física, sino que describe
un mecanismo que regula el intercambio de parámetros entre dos interlocutores de
comunicación. Es decir, lectura y escritura de valores de parámetros, descripciones de
parámetros y textos correspondientes, así como el tratamiento de cambios de parámetros
mediante mensajes espontáneos. Todas las tareas que se efectúan a través de la interfaz
del identificador/valor del parámetro son principalmente tareas de manejo y observación,
servicio y diagnóstico.
● El área de datos de proceso incluye las señales necesarias para la automatización:
– Palabra(s) de mando y consigna(s) del maestro al esclavo
– Palabra(s) de estado y valor(es) real(es) del esclavo al maestro.
Ambas áreas forman en conjunto el bloque de datos útiles. Éste se transmite como telegrama
de petición del maestro al esclavo, o bien como telegrama de respuesta del esclavo al maestro.

Programación del PLC
Manual de programación y manejo, 11/2019

4567

Instrucciones
4.1 Instrucciones

Descripción
Cada módulo de comunicación CM 1241 RS485 soporta un máximo de 16 accionamientos. Un
solo bloque de datos instancia contiene funciones temporales de memoria y búfer para todos
los accionamientos de la red USS conectados con uno de los módulos de comunicación PtP
que se han instalado. Las instrucciones USS para este accionamiento tienen acceso común a
la información de este bloque de datos.
866B3257

(OEORTXHGHGDWRV866B'59B'%
HVXQE¼IHUDOTXHVµORSXHGH
DFFHGHUVHLQGLUHFWDPHQWHDWUDY«V
GHODVRSHUDFLRQHV866

866B'%

866B'59B'%
866B'59B'%
5HVHUYDGRSDUD
373
GDWRV&20
E\WHV

'ULYHGDWD

866B'59B'%
866B'59








'5,9(

&056
RGHU
&%56









(OPµGXORGHFRPXQL
FDFLµQVRSRUWDKDVWD
DFFLRQDPLHQWRV
,QWURGX]FDGHD
FRPRHQWUDGDGHO
FXDGURSDUDHO
SDU£PHWURGHO
DFFLRQDPLHQWR


866B530


'5,9(




'ULYH
'ULYH



866B:30


'5,9(

● Todos los accionamientos (máx. 16) conectados a un puerto RS485 forman parte de la
misma red USS. Todos los accionamientos conectados a otro puerto RS485 forman parte
de otra red USS. Dado que el S7-1200 soporta hasta tres módulos CM 1241 RS485, es
posible configurar un máximo de tres redes USS, cada una con un máximo de 16
accionamientos en cada red, de manera que en total se soportan 48 accionamientos USS.
● Cada red USS se administra a través de un bloque de datos unívoco (para tres redes USS
con tres módulos CM 1241 RS485 se requieren tres bloques de datos). Todas las
instrucciones que pertenecen a una red USS deben utilizar este bloque de datos común.
Éste abarca todas las instrucciones "USS_DRIVE (Página 4571)", "USS_PORT
(Página 4570)", "USS_RPM (Página 4574)" y "USS_WPM (Página 4576)" para controlar
todos los accionamientos de una red USS.

4568

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● La instrucción "USS_DRIVE (Página 4571)" es un bloque de función (FB). Si se inserta la
instrucción "USS_DRIVE" en el editor, en el cuadro de diálogo "Opciones de llamada" se
debe asignar un DB a la instrucción.
– Si se trata de la primera instrucción "USS_DRIVE" en este programa para esta red USS,
se puede aplicar la asignación estándar de DB (o en caso necesario modificar el
nombre) y se crea el nuevo DB.
– Si, por el contrario, no es la primera instrucción "USS_DRIVE" para esta red, en la lista
desplegable del cuadro de diálogo "Opciones de llamada" se debe seleccionar el
correspondiente DB que ya se ha asignado previamente a esta red USS.
● Todas las instrucciones "USS_PORT (Página 4570), USS_RPM (Página 4574)" y
"USS_WPM (Página 4576)" son funciones (FCs). Si estas funciones se insertan en el
editor, no se asigna ningún DB. En su lugar se debe asignar la entrada USS_DB de estas
instrucciones al DB correspondiente (haga doble clic en el campo del parámetro y, a
continuación, en el símbolo para visualizar los DBs disponibles).
● La instrucción "USS_PORT (Página 4570)" controla la comunicación entre la CPU y los
accionamientos a través del módulo de comunicación PtP. En cada llamada la instrucción
establece una comunicación con un accionamiento. El programa debe llamar a esta función
lo suficientemente rápido como para que el accionamiento no notifique ningún rebase de
tiempo. La instrucción puede ser llamada desde el programa principal o desde un OB de
alarma cualquiera.
● El bloque de función "USS_DRIVE (Página 4571)" le da al programa acceso a un
accionamiento indicado en la red USS. Sus entradas y salidas corresponden a los estados
y las funciones de manejo del accionamiento. Si existen 16 accionamientos en la red,
"USS_DRIVE" debe ser llamado en el programa al menos 16 veces, es decir, una vez por
cada accionamiento. La rapidez con la que se llama a los bloques depende de la velocidad
necesaria para el control de las funciones de accionamiento.
La instrucción "USS_DRIVE" sólo puede ser llamada desde el OB del programa principal.
PRECAUCIÓN
Llame a "USS_DRIVE", "USS_RPM", "USS_WPM" sólo desde el OB del programa
principal. La instrucción "USS_PORT" puede ser llamada desde un OB cualquiera,
normalmente se llama desde un OB de alarma de retardo. Si la instrucción "USS_PORT"
se interrumpe durante la ejecución, se puede producir un error inesperado.
Con las instrucciones "USS_RPM" y "USS_WPM" se leen y escriben los parámetros
operativos del accionamiento. Dichos parámetros controlan el funcionamiento interno del
accionamiento. En el manual del accionamiento encontrará la definición de estos parámetros.
El programa puede contener el número que se desee de estas funciones; no obstante, sólo
puede haber una solicitud de lectura o escritura activa para un accionamiento. Las
instrucciones "USS_RPM" y "USS_WPM" sólo pueden ser llamadas desde un OB del
programa principal.

Calcular el tiempo para comunicarse con el accionamiento
La comunicación con el accionamiento es asíncrona con respecto al ciclo del S7-1200. El
S7-1200 suele ejecutar varios ciclos antes de que haya finalizado la comunicación con un
accionamiento.

Programación del PLC
Manual de programación y manejo, 11/2019

4569

Instrucciones
4.1 Instrucciones
El intervalo de "USS_PORT" es el tiempo necesario para una transacción del accionamiento.
La tabla siguiente muestra los intervalos mínimos para "USS_PORT" con cada velocidad de
transferencia. Si se llama la instrucción "USS_PORT" con más frecuencia de la predefinida en
el intervalo "USS_PORT", el número de transacciones no se incrementa. El intervalo de
timeout del accionamiento es el tiempo disponible para una transacción cuando se necesitan
tres intentos para finalizar la transacción debido a errores de comunicación. Por defecto, en el
protocolo USS se realizan en cada transacción hasta 2 repeticiones.
Velocidad de
transferencia

Intervalo mínimo calculado para llamar
USS_PORT (ms)

Timeout de intervalo para aviso de ac‐
cionamiento por accionamiento (ms)

1200

790

2370

2400

405

1215

4800

212,5

638

9600

116,3

349

19200

68,2

205

38400

44,1

133

57600

36,1

109

115200

28,1

85

USS_PORT: Editar la comunicación vía red USS
Nota
Uso con CM1241
Esta instrucción solo puede utilizarse con un CM1241 a partir de la versión de firmware V2.1
del módulo.

Descripción
La instrucción "USS_PORT" edita la comunicación a través de la red USS. En el programa,
utilice cada vez una instrucción "USS_PORT" por puerto de comunicación PtP para controlar
la transferencia a o desde un accionamiento.
Todas las instrucciones USS que están asignadas a una red USS y a un puerto de
comunicación PtP deben utilizar el mismo bloque de datos de instancia.

Llamada
El programa debe ejecutar la instrucción "USS_PORT" lo bastante a menudo como para que
no aparezca ningún rebase de tiempo en el accionamiento. Llame por tanto a la instrucción
"USS_PORT" desde un OB de alarma cíclica para evitar rebases de tiempo en el
accionamiento y tener disponibles las últimas actualizaciones de datos USS para llamadas de
"USS_DRIVE (Página 4571)".

4570

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "USS_PORT":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

PORT

Input

PORT

D, L o constante

Identificación del puerto de comunicación PtP
Constante a la que puede señalarse en la tabla de
variables estándar de la ficha "Constantes".

BAUD

Input

DINT

I, Q, M, D, L o cons‐
tante

Velocidad de transferencia para la comunicación
USS.

USS_DB

InOut

USS_BASE D

Referencia al DB de instancia de la instrucción
"USS_DRIVE (Página 4571)".

ERROR

Output

BOOL

I, Q, M, D, L

Si se presenta un error, ERROR se pone a TRUE. En
la salida STATUS se visualiza un código de error co‐
rrespondiente.

STATUS (Pá‐
gina 4577)

Output

WORD

I, Q, M, D, L

Valor de estado de la solicitud. Indica el resultado del
ciclo o de la inicialización. Encontrará más informa‐
ción acerca de algunos códigos de estado en la va‐
riable "USS_Extended_Error (Página 4577)".

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

USS_DRIVE: Intercambiar datos con el accionamiento
Nota
Uso con CM1241
Esta instrucción solo puede utilizarse con un CM1241 a partir de la versión de firmware V2.1
del módulo.

Descripción
La instrucción "USS_DRIVE" intercambia datos con el accionamiento creando avisos de
solicitud y evaluando los avisos de respuesta del accionamiento. Para cada accionamiento
debe utilizarse una instrucción propia, pero todas las instrucciones USS que están asignadas
a una red USS y a un módulo de comunicación PtP deben utilizar el mismo bloque de datos de
instancia. Se debe introducir el nombre del DB al insertar la primera instrucción "USS_DRIVE".
Después siga utilizando el DB que se ha creado al insertar la primera instrucción.
Cuando se produce la primera ejecución de "USS_DRIVE", se inicializa el accionamiento
indicado en la dirección USS (parámetro DRIVE) en el DB de instancia. Después de la
inicialización, las siguientes instrucciones "USS_PORT (Página 4570)" pueden iniciar la
comunicación con el accionamiento en este número de accionamiento.
Si se modifica el número de accionamiento, el sistema de destino debe ponerse primero en
STOP y después volver a RUN para que se inicialice el DB instancia. Los parámetros de
entrada se configuran en el búfer de transmisión USS y las salidas, si existen, se leen desde
un búfer de respuesta válido "anterior". Durante la ejecución de la instrucción "USS_DRIVE" no
se realiza ninguna transferencia de datos. Tras la ejecución de "USS_PORT (Página 4570)" se

Programación del PLC
Manual de programación y manejo, 11/2019

4571

Instrucciones
4.1 Instrucciones
comunica con los accionamientos. "USS_DRIVE" configura solo los avisos que deben
enviarse y evalúa los datos recibidos en una solicitud anterior.
Es posible controlar el sentido de giro del accionamiento con la entrada DIR (BOOL) o con el
signo (positivo o negativo) de la entrada SPEED_SP (REAL). La tabla siguiente explica cómo
funcionan las entradas de forma conjunta para determinar el sentido de giro del accionamiento,
siempre que el motor gire hacia delante.
SPEED_SP

DIR

Sentido de giro del accionamiento

Valor > 0

0

Atrás

Valor > 0

1

Adelante

Valor < 0

0

Adelante

Valor < 0

1

Atrás

Parámetros
Amplíe el cuadro para visualizar todos los parámetros. Para ello haga clic en el área inferior del
cuadro. Las conexiones de parámetros, que se representan en gris, son opcionales y no deben
asignarse obligatoriamente.
La tabla siguiente muestra los parámetros de la instrucción "USS_DRIVE":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

RUN

Input

BOOL

I, Q, M, D, L o cons‐
tante

Bit de inicio del accionamiento: Si el parámetro tiene
el valor TRUE, permite a la entrada utilizar el accio‐
namiento con la velocidad predeterminada.

OFF2

Input

BOOL

I, Q, M, D, L o cons‐
tante

Bit "Finalizar en parada": Si el parámetro tiene el valor
FALSE, el bit inicia la parada del accionamiento sin
frenar.

OFF3

Input

BOOL

I, Q, M, D, L o cons‐
tante

Bit de parada rápida - Si el parámetro tiene el valor
FALSE, el bit provoca una parada rápida frenando el
accionamiento.

F_ACK

Input

BOOL

I, Q, M, D, L o cons‐
tante

Bit de acuse de error - Con este bit se desactiva el bit
de error de un accionamiento. Se activa después de
borrar el error y así el accionamiento detecta que el
error anterior no debe notificarse más.

DIR

Input

BOOL

I, Q, M, D, L o cons‐
tante

Control de sentido del accionamiento - El bit se activa
cuando el accionamiento debe funcionar hacia delan‐
te (si SPEED_SP es positivo).

DRIVE

Input

USINT

I, Q, M, D, L o cons‐
tante

Dirección del accionamiento: esta entrada es la direc‐
ción del accionamiento USS. El rango válido está en‐
tre el accionamiento 1 y el accionamiento 16.

PZD_LEN

Input

USINT

I, Q, M, D, L o cons‐
tante

Longitud de palabra - Es el número de palabras de
datos PZD. Los valores válidos son 2, 4, 6 u 8 pala‐
bras. El valor predeterminado es 2.

SPEED_SP

Input

REAL

I, Q, M, D, L o cons‐
tante

Consigna de velocidad - Es el porcentaje de la velo‐
cidad del accionamiento respecto a la frecuencia con‐
figurada. Un valor positivo significa que el acciona‐
miento funciona hacia delante (si DIR tiene el valor
TRUE).

4572

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

CTRL3

Input

WORD

I, Q, M, D, L o cons‐
tante

Palabra de control 3 - Valor que se escribe en un pa‐
rámetro del accionamiento configurable por el usua‐
rio. El usuario debe configurarlo en el accionamiento.
Parámetro opcional.

CTRL4

Input

WORD

I, Q, M, D, L o cons‐
tante

Palabra de control 4 - Valor que se escribe en un pa‐
rámetro del accionamiento configurable por el usua‐
rio. El usuario debe configurarlo en el accionamiento.
Parámetro opcional.

CTRL5

Input

WORD

I, Q, M, D, L o cons‐
tante

Palabra de control 5 - Valor que se escribe en un pa‐
rámetro del accionamiento configurable por el usua‐
rio. El usuario debe configurarlo en el accionamiento.
Parámetro opcional.

CTRL6

Input

WORD

I, Q, M, D, L o cons‐
tante

Palabra de control 6 - Valor que se escribe en un pa‐
rámetro del accionamiento configurable por el usua‐
rio. El usuario debe configurarlo en el accionamiento.

CTRL7

Input

WORD

I, Q, M, D, L o cons‐
tante

Palabra de control 7 - Valor que se escribe en un pa‐
rámetro del accionamiento configurable por el usua‐
rio. El usuario debe configurarlo en el accionamiento.
Parámetro opcional.

CTRL8

Input

WORD

I, Q, M, D, L o cons‐
tante

Palabra de control 8 - Valor que se escribe en un pa‐
rámetro del accionamiento configurable por el usua‐
rio. El usuario debe configurarlo en el accionamiento.
Parámetro opcional.

NDR

Output

BOOL

I, Q, M, D, L

Nuevos datos listos - Si el parámetro tiene el valor
TRUE, el bit notifica que en la salida hay datos dispo‐
nibles de una nueva solicitud de comunicación.

ERROR

Output

BOOL

I, Q, M, D, L

Con errores - Si el parámetro tiene el valor TRUE, el
bit notifica que se ha producido un error y la salida
STATUS es válida. Todas las demás salidas se po‐
nen a cero en caso de error. Los errores de comuni‐
cación sólo se notifican en las salidas ERROR y STA‐
TUS de la instrucción "USS_PORT".

STATUS (Pá‐
gina 4577)

Output

WORD

I, Q, M, D, L

Valor de estado de la solicitud. Indica el resultado del
ciclo. No es una palabra de estado emitida por el ac‐
cionamiento.

RUN_EN

Output

BOOL

I, Q, M, D, L

Operación autorizada - El bit notifica si el acciona‐
miento está funcionando.

D_DIR

Output

BOOL

I, Q, M, D, L

Sentido del accionamiento - El bit notifica si el accio‐
namiento funciona hacia delante.

INHIBIT

Output

BOOL

I, Q, M, D, L

Accionamiento bloqueado - El bit notifica el estado del
bit de bloqueo para el accionamiento.

FAULT

Output

BOOL

I, Q, M, D, L

Error de accionamiento - El bit notifica que se ha pro‐
ducido un error en el accionamiento. El usuario debe
solucionar el fallo y activar el bit F_ACK para borrar
este bit.

SPEED

Output

REAL

I, Q, M, D, L

Valor real de velocidad del accionamiento (valor es‐
calado de la palabra de estado 2 del accionamiento) El valor porcentual de la velocidad del accionamiento
respecto a la velocidad configurada.

Programación del PLC
Manual de programación y manejo, 11/2019

4573

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

STATUS1

Output

WORD

I, Q, M, D, L

Palabra de estado 1 del accionamiento - El valor con‐
tiene bits de estado fijos de un accionamiento.

STATUS3

Output

WORD

I, Q, M, D, L

Palabra de estado 3 del accionamiento - El valor con‐
tiene una palabra de estado del accionamiento confi‐
gurable por el usuario.

STATUS4

Output

WORD

I, Q, M, D, L

Palabra de estado 4 del accionamiento - El valor con‐
tiene una palabra de estado del accionamiento confi‐
gurable por el usuario.

STATUS5

Output

WORD

I, Q, M, D, L

Palabra de estado 5 del accionamiento - El valor con‐
tiene una palabra de estado del accionamiento confi‐
gurable por el usuario.

STATUS6

Output

WORD

I, Q, M, D, L

Palabra de estado 6 del accionamiento - El valor con‐
tiene una palabra de estado del accionamiento confi‐
gurable por el usuario.

STATUS7

Output

WORD

I, Q, M, D, L

Palabra de estado 7 del accionamiento - El valor con‐
tiene una palabra de estado del accionamiento confi‐
gurable por el usuario.

STATUS8

Output

WORD

I, Q, M, D, L

Palabra de estado 8 del accionamiento - El valor con‐
tiene una palabra de estado del accionamiento confi‐
gurable por el usuario.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

USS_RPM: Leer parámetros del accionamiento
Nota
Uso con CM1241
Esta instrucción solo puede utilizarse con un CM1241 a partir de la versión de firmware V2.1
del módulo.

Descripción
La instrucción "USS_RPM" lee un parámetro del accionamiento. Todas las funciones USS que
están asignadas a una red USS y a un módulo de comunicación PtP deben utilizar el mismo
bloque de datos. "USS_RPM" debe llamarse desde el OB del programa principal.

4574

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "USS_RPM":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L

Solicitud de transmisión: si el parámetro tiene el valor
TRUE, se requiere una nueva solicitud de lectura. Se
ignora si la solicitud para este parámetro ya está fija‐
da.

DRIVE

Input

USINT

I, Q, M, D, L o cons‐
tante

Dirección del accionamiento: esta entrada es la direc‐
ción del accionamiento USS. El rango válido está en‐
tre el accionamiento 1 y el accionamiento 16.

PARAM

Input

UINT

I, Q, M, D, L o cons‐
tante

Número de parámetro: la entrada indica qué paráme‐
tro de accionamiento se escribe. El rango de este pa‐
rámetro es de 0 a 2047. Encontrará más información
sobre el acceso a parámetros que excedan este ran‐
go en el manual del accionamiento.

INDEX

Input

UINT

I, Q, M, D, L o cons‐
tante

Índice de parámetro: la entrada indica en qué índice
de parámetro del accionamiento se debe escribir. Es
un valor de 16 bits, en el que el byte menos significa‐
tivo es el valor de índice real, con un rango de 0 a 255.
El accionamiento también puede utilizar el byte más
significativo, que es específico del accionamiento.
Encontrará más información en el manual del accio‐
namiento.

USS_DB

InOut

USS_BASE D

Referencia al bloque de datos de instancia que se
crea e inicializa cuando se inserta una instrucción
"USS_DRIVE" en el programa.

DONE

Output

BOOL

Si el parámetro tiene el valor TRUE, fija en la salida
VALUE el valor solicitado anteriormente para el pará‐
metro de lectura.

I, Q, M, D, L

El bit se activa cuando la instrucción "USS_DRIVE"
detecta la palabra de lectura del accionamiento.
El bit se desactiva cuando:
● Se solicitan los datos de respuesta a través de
otra consulta "USS_RPM"
o
● Se ejecuta la segunda de las dos llamadas
siguientes de "USS_DRIVE (Página 4571)"
ERROR

Output

BOOL

I, Q, M, D, L

Con errores - Si el parámetro tiene el valor TRUE, el
bit notifica que se ha producido un error y la salida
STATUS es válida. Todas las demás salidas se po‐
nen a cero en caso de error. Los errores de comuni‐
cación sólo se notifican en las salidas ERROR y STA‐
TUS de la instrucción "USS_PORT (Página 4570)".

STATUS (Pá‐
gina 4577)

Output

WORD

I, Q, M, D, L

Es el valor de estado de la solicitud. Indica el resulta‐
do de la solicitud de lectura. Encontrará más informa‐
ción acerca de algunos códigos de estado en la va‐
riable "USS_Extended_Error (Página 4577)".

VALUE

Output

VARIANT

I, Q, M, D, L

Es el valor del parámetro que se ha leído y sólo es
válido cuando el bit DONE tiene el valor TRUE.

Programación del PLC
Manual de programación y manejo, 11/2019

4575

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

USS_WPM: Modificar parámetros en el accionamiento
Nota
Uso con CM1241
Esta instrucción solo puede utilizarse con un CM1241 a partir de la versión de firmware V2.1
del módulo.

Descripción
La instrucción "USS_WPM" modifica un parámetro en el accionamiento. Todas las funciones
USS que están asignadas a una red USS y a un módulo de comunicación PtP deben utilizar
el mismo bloque de datos. "USS_WPM" debe llamarse desde el OB del programa principal.
Nota
Operaciones de escritura en EEPROM
No utilice excesivamente la operación de escritura en EEPROM. Minimice el número de
operaciones de escritura en EEPROM para prolongar la vida útil de EEPROM.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "USS_WPM":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L

Solicitud de transmisión: Si el parámetro tiene el valor
TRUE, se requiere una nueva solicitud de escritura. Se
ignora si la solicitud para este parámetro ya está fijada.

DRIVE

Input

USINT

I, Q, M, D, L o cons‐ Dirección del accionamiento: esta entrada es la direc‐
tante
ción del accionamiento USS. El rango válido está entre
el accionamiento 1 y el accionamiento 16.

PARAM

Input

UINT

I, Q, M, D, L o cons‐ Número de parámetro: la entrada indica qué parámetro
tante
de accionamiento se escribe. El rango de este paráme‐
tro es de 0 a 2047. Encontrará más información sobre el
acceso a parámetros que excedan este rango en el ma‐
nual del accionamiento.

INDEX

Input

UINT

I, Q, M, D, L o cons‐ Índice de parámetro: la entrada indica en qué índice de
tante
parámetro del accionamiento se debe escribir. Es un
valor de 16 bits, en el que el byte menos significativo es
el valor de índice real, con un rango de 0 a 255. El ac‐
cionamiento también puede utilizar el byte más signifi‐
cativo, que es específico del accionamiento. Encontrará
más información en el manual del accionamiento.

4576

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

EEPROM

Input

BOOL

I, Q, M, D, L o cons‐ Guardar en EEPROM del accionamiento: si el paráme‐
tante
tro tiene el valor TRUE, los valores escritos en el pará‐
metro del accionamiento se guardan en la EEPROM del
accionamiento. Si el parámetro tiene el valor FALSE, el
valor escrito sólo se guarda temporalmente y se pierde
en la siguiente conexión del accionamiento.

VALUE

Input

VARIANT

I, Q, M, D, L o cons‐ Valor del parámetro en el que se debe escribir. Debe ser
tante
válido en el cambio de estado de REQ.

USS_DB

InOut

USS_BASE D

Es una referencia al DB de instancia que se crea e ini‐
cializa cuando se inserta una instrucción "USS_DRIVE
(Página 4571)" en el programa.

DONE

Output

BOOL

Si el parámetro tiene el valor TRUE, la entrada VALUE
se ha escrito en el accionamiento.

I, Q, M, D, L

Descripción

El bit se activa cuando la instrucción "USS_DRIVE (Pá‐
gina 4571)" detecta la respuesta de escritura del accio‐
namiento.
El bit se desactiva cuando:
Se solicita que el accionamiento confirme a través de
otra consulta "USS_WPM" que se ha realizado la escri‐
tura, o cuando se ejecuta la segunda de las dos llama‐
das siguientes de "USS_DRIVE (Página 4571)".
ERROR

Output

BOOL

I, Q, M, D, L

Con errores: si el parámetro tiene el valor TRUE, se ha
producido un error y se muestra en la salida STATUS.
Todas las demás salidas se ponen a cero en caso de
error. Los errores de comunicación sólo se notifican en
las salidas ERROR y STATUS de la instrucción
"USS_PORT (Página 4570)".

STATUS (Pá‐
gina 4577)

Output

WORD

I, Q, M, D, L

Es el valor de estado de la solicitud. Indica el resultado
de la solicitud de escritura. Encontrará más información
acerca de algunos códigos de estado en la variable
"USS_Extended_Error (Página 4577)".

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS de las instrucciones USS
Parámetro STATUS
La tabla siguiente contiene los códigos de estado de la operación USS que se indican en la
salida STATUS de las instrucciones USS.
STATUS*
(W#16#....)

Descripción

0000

Sin errores

8180

La longitud de la respuesta del accionamiento no se corresponde con los caracteres recibidos en el accio‐
namiento. El número del accionamiento en el que se ha producido el error se visualiza en la variable
"USS_Extended_Error". La descripción de los errores avanzados aparece a continuación de esta tabla.

8181

El parámetro VALUE no es del tipo de datos WORD, REAL o DWORD

Programación del PLC
Manual de programación y manejo, 11/2019

4577

Instrucciones
4.1 Instrucciones
STATUS*
(W#16#....)

Descripción

8182

El usuario ha introducido un valor de parámetro del tipo palabra y ha recibido la respuesta del accionamiento
en el formato DWORD o REAL

8183

El usuario ha introducido un valor de parámetro del tipo DWORD o REAL y ha recibido la respuesta del
accionamiento en el formato de palabra

8184

El telegrama de respuesta del accionamiento tenía una suma de verificación errónea. El número del accio‐
namiento en el que se ha producido el error se visualiza en la variable "USS_Extended_Error". La descripción
de los errores avanzados aparece a continuación de esta tabla.

8185

Dirección de accionamiento no admisible (área de direcciones válida para accionamientos: 1-16)

8186

La consigna de velocidad se encuentra fuera del rango válido (rango de consigna válido para la velocidad:
de -200% a 200%)

8187

Un número de accionamiento erróneo ha respondido a la solicitud enviada. El número del accionamiento en
el que se ha producido el error se visualiza en la variable "USS_Extended_Error". La descripción de los
errores avanzados aparece a continuación de esta tabla.

8188

Longitud de palabra PZD no admisible (rango admisible = 2, 4, 6 u 8 palabras)

8189

Velocidad de transferencia no admisible

818A

El canal de solicitud para el parámetro es utilizado por otra solicitud para este accionamiento

818B

El accionamiento no ha reaccionado a las solicitudes y repeticiones. El número del accionamiento en el que
se ha producido el error se visualiza en la variable "USS_Extended_Error". La descripción de los errores
avanzados aparece a continuación de esta tabla.

818C

El accionamiento ha emitido un error avanzado relativo a una solicitud de parámetros. La descripción de los
errores avanzados aparece a continuación de esta tabla.

818D

El accionamiento ha emitido un error de acceso no permitido en una solicitud de parámetros. Encontrará más
información sobre la limitación de acceso a los parámetros en el manual del accionamiento.

818E

El accionamiento no se ha inicializado: Este código de error se emite en "USS_RPM (Página 4574)" o
"USS_WPM (Página 4576)" cuando la instrucción "USS_DRIVE (Página 4571)" no se ha llamado al menos
una vez para este accionamiento. De esta manera se impide que la inicialización de "USS_DRIVE (Pági‐
na 4571)" en el primer ciclo sobrescriba una solicitud pendiente de lectura o escritura de los parámetros,
puesto que inicializa el accionamiento como entrada nueva. Para solucionar este error, llame a la instrucción
"USS_DRIVE (Página 4571)" para este accionamiento.

80Ax-80Fx

Errores específicos que devuelven las instrucciones llamadas por la librería USS para la comunicación punto
a punto (PtP): estos códigos de error no se modifican en la librería USS y se definen en las descripciones de
las instrucciones PtP.

*Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Véase también".

4578

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

USS_Extended_Error - Códigos de error adicionales de los accionamientos USS
Los accionamientos USS soportan accesos de lectura y escritura a los parámetros internos de
un accionamiento. Esta función permite controlar y configurar el accionamiento de forma
descentralizada. Los accesos a los parámetros del accionamiento pueden fallar debido a
errores como valores fuera de rango o solicitudes no admisibles en el modo de operación
actual del accionamiento. El accionamiento crea un código de error que se indica en la variable
"USS_Extended_Error" del DB de instancia de la instrucción "USS_DRIVE (Página 4571)".
Este código de error sólo sirve para la última ejecución de la instrucción "USS_RPM
(Página 4574)" o "USS_WPM (Página 4576)". El código de error del accionamiento se deposita
en la variable "USS_Extended_Error" cuando STATUS tiene el valor hexadecimal 818C. El
código de error de "USS_Extended_Error" se rige por la variante del accionamiento.
Encontrará una descripción de los códigos de error avanzados para funciones de lectura y
escritura de parámetros en el manual del accionamiento.

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

MODBUS (RTU)
MB_COMM_LOAD: Configurar puerto en módulo PtP para Modbus-RTU
Descripción
La instrucción "MB_COMM_LOAD" configura un puerto para la comunicación mediante el
protocolo Modbus RTU. Para ello se puede utilizar el hardware siguiente:
● Hasta tres módulos punto a punto (PtP) CM 1241 RS485 o CM 1241 RS232
● Además, una tarjeta de comunicación CB 1241 RS485
Después de configurar el puerto la comunicación se establece a través de Modbus ejecutando
la instrucción "MB_SLAVE" o "MB_MASTER".

Llamada
"MB_COMM_LOAD" debe ser llamado una vez para configurar el puerto para el protocolo
Modbus-RTU. Al terminar la configuración, el puerto puede ser utilizado por las instrucciones
"MB_MASTER (Página 4582)" y "MB_SLAVE (Página 4590)".
"MB_COMM_LOAD" sólo debe volver a llamarse si hay que cambiar uno de los parámetros de
comunicación. Cada llamada de "MB_COMM_LOAD" borra el búfer de comunicación. Para
evitar la pérdida de datos en la comunicación, no efectúe llamadas innecesarias de la
instrucción.
Para configurar el puerto de cada módulo de comunicación que se usa para la comunicación
Modbus, se debe utilizar una instancia de "MB_COMM_LOAD". A cada puerto que se utilice,
se le deberá asignar un bloque de datos de instancia "MB_COMM_LOAD" unívoco. La CPU
S7-1200 está limitada a tres módulos de comunicación.

Programación del PLC
Manual de programación y manejo, 11/2019

4579

Instrucciones
4.1 Instrucciones
Cuando se insertan las instrucciones "MB_MASTER (Página 4582)" o "MB_SLAVE
(Página 4590)", se asigna un bloque de datos de instancia. Dicho bloque se referencia
indicándolo en el parámetro MB_DB de la instrucción "MB_COMM_LOAD".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "MB_COMM_LOAD":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L

Ejecución de la instrucción con flanco ascendente.

PORT

Input

PORT

I, Q, M, D, L o cons‐
tante

Identificación del puerto de comunicación:

I, Q, M, D, L o cons‐
tante

Selección de la velocidad de transferencia:

BAUD

Input

UDINT

Tras haber insertado el módulo de comunicación
en la configuración de dispositivos, la identificación
de puerto aparece en la lista desplegable de la co‐
nexión del cuadro PORT. Esta constante también
se puede referenciar en la tabla de variables de la
ficha "Constantes".
300, 600, 1200, 2400, 4800, 9600, 19200, 38400,
57600, 76800, 115200
Todos los demás valores no son válidos.

PARITY

Input

UINT

I, Q, M, D, L o cons‐
tante

Selección de la paridad:
● 0 – Ninguna
● 1 – Impar
● 2 – Par

FLOW_CTRL

Input

UINT

I, Q, M, D, L o cons‐
tante

Selección del control de flujo:
● 0 – (ajuste predeterminado) Sin control de flujo
● 1 – Control de flujo por hardware con RTS
siempre ON (no se aplica a los puertos RS485)
● 2 - Control de flujo por hardware con RTS
conectado

RTS_ON_DLY

Input

UINT

I, Q, M, D, L o cons‐
tante

Selección de retardo a la conexión de RTS:
● 0 – (ajuste predeterminado) Sin retardo de
"RTS activo" hasta que se envía el primer
carácter del aviso.
● De 1 a 65535 – Retardo en milisegundos de
"RTS activo" hasta que se envía el primer
carácter del mensaje (no aplicable para puertos
RS-485). Los retardos de RTS deben utilizarse
independientemente de la selección
FLOW_CTRL.

4580

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

RTS_OFF_DLY

Input

UINT

I, Q, M, D, L o cons‐
tante

Selección de retardo a la desconexión de RTS:
● 0 – (ajuste predeterminado) Sin retardo
después de la transferencia del último carácter
hasta "RTS inactivo"
● De 1 a 65535 – Retardo en milisegundos desde
la transferencia del último carácter hasta "RTS
inactivo" (no se aplica a los puertos RS-485).
Los retardos de RTS deben utilizarse
independientemente de la selección
FLOW_CTRL.

RESP_TO

Input

UINT

I, Q, M, D, L o cons‐
tante

Timeout de respuesta:
Tiempo en milisegundos que "MB_MASTER (Pági‐
na 4582)" espera una respuesta del esclavo. Si el
esclavo no responde en este tiempo, "MB_MAS‐
TER (Página 4582)" repite la solicitud o la finaliza
con un error, siempre que se haya enviado el nú‐
mero de repeticiones indicado.
de 5 ms a 65535 ms (valor estándar = 1000 ms).

MB_DB

Input

MB_BASE

D

Una referencia al bloque de datos de instancia de
las instrucciones "MB_MASTER (Página 4582)" o
"MB_SLAVE (Página 4590)". Después de haber in‐
sertado "MB_SLAVE (Página 4590)" o "MB_MAS‐
TER (Página 4582)" en el programa, la identifica‐
ción de DB está disponible en la lista desplegable
en la conexión del cuadro MB_DB.

DONE

Output

BOOL

I, Q, M, D, L

Ejecución de la instrucción finalizada sin errores.

ERROR

Output

BOOL

I, Q, M, D, L

Error:
● 0 – No se ha detectado ningún error
● 1 – Indica que se ha detectado un error. En el
parámetro STATUS se devuelve un código de
error.

STATUS

Output

WORD

I, Q, M, D, L

Código de error de la configuración del puerto

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Código de error*
(W#16#....)

Descripción

0000

Ningún error

8180

Valor no válido para la ID de puerto (dirección errónea del módulo de comunicación).

8181

Valor no válido para la velocidad de transferencia.

8182

Valor no válido para la paridad.

8183

Valor no válido para el control de flujo.

Programación del PLC
Manual de programación y manejo, 11/2019

4581

Instrucciones
4.1 Instrucciones
Código de error*
(W#16#....)

Descripción

8184

Valor no válido para el tiempo excedido de la respuesta (el lapso de tiempo hasta que se comunica el
tiempo excedido debe ser como mínimo 25 ms).

8185

Puntero incorrecto en el parámetro MB_DB hacia el DB de instancia de la instrucción "MB_MASTER
(Página 4582)" o "MB_SLAVE (Página 4590)".

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Variables de bloques de datos MB_COMM_LOAD
La siguiente tabla muestra las variables estáticas públicas del DB de instancia de
MB_COMM_LOAD que puede utilizar en su programa.
Tabla 4-182 Variables estáticas del DB de instancia
Variable

Tipo de
datos

Ajuste prede‐
terminado

Descripción

ICHAR_GAP

WORD

0

Retardo para la distancia entre caracteres. Este parámetro se indica en mi‐
lisegundos y sirve para aumentar el intervalo de tiempo esperado entre los
caracteres recibidos. La cantidad de tiempos de bit correspondiente para
este parámetro se suma al valor estándar de Modbus de 35 tiempos de bit
(3,5 tiempos de carácter).

RETRIES

WORD

2

La cantidad de intentos repetidos que ejecuta el maestro antes de que se
devuelva el código de error 0x80C8 para "Sin respuesta".

STOP_BITS

USINT

1

Número de bits de parada por carácter. Valores válidos: 1 y 2

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

MB_MASTER: Comunicar como maestro Modbus vía puerto PtP
Descripción de MB_MASTER
Descripción
La instrucción "MB_MASTER" permite al programa comunicarse como maestro Modbus a
través del puerto de un módulo punto a punto (CM) o una tarjeta de comunicación (CB). Es
posible acceder a los datos de uno o varios dispositivos esclavo Modbus.
Para que la instrucción "MB_MASTER" pueda comunicarse con un puerto, se debe ejecutar
previamente "MB_COMM_LOAD (Página 4579)".
Cuando se inserta la instrucción "MB_MASTER" en el programa, se crea un DB de instancia.
Introduzca este DB de instancia en el parámetro de entrada MB_DB de la instrucción
"MB_COMM_LOAD (Página 4579)".

4582

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Reglas para la comunicación del maestro Modbus
● Un puerto utilizado para las solicitudes del maestro Modbus no se puede usar para
"MB_SLAVE".
● Un puerto se puede usar para una o varias llamadas de "MB_MASTER" si se utiliza el
mismo DB de instancia.
● Las operaciones Modbus no utilizan eventos de alarma de comunicación para controlar el
proceso de comunicación. El programa debe consultar la instrucción "MB_MASTER" en
procedimientos de transmisión y recepción finalizados.
● Llamada de la instrucción:
– Si resulta posible, efectúe la llamada de la instrucción "MB_MASTER" en un OB de
programa cíclico. La instrucción también se puede llamar en un OB de retardo o de
alarma cíclica.
– No llame varias instrucciones "MB_MASTER" en bloques de organización con clases de
prioridad distintas. En caso de ejecución anticipada de una instrucción "MB_MASTER"
desde una clase de prioridad superior, la ejecución puede resultar errónea.
– No llame instrucciones "MB_MASTER" en un OB de arranque, diagnóstico o error de
tiempo.
● Tras el comienzo de una transmisión, en el parámetro EN (KOP/FUP) se debe presentar
transitoriamente el valor "1" hasta que la instrucción ponga a "1" el parámetro de salida
DONE o ERROR. Una nueva llamada a través del parámetro REQ mientras la instrucción
se está ejecutando provoca un error. Después de ejecutar la instrucción, el bit del
parámetro REQ permanece activado por el tiempo definido en el parámetro
BLOCKED_PROC_TIMEOUT del DB de instancia.
● Si "MB_MASTER" envía una solicitud a un esclavo, se debe proseguir la ejecución de
"MB_MASTER" hasta que la respuesta del esclavo haya llegado.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "MB_MASTER":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

REQ (Pági‐
na 4585)

Input

BOOL

I, Q, M, D, L

Entrada de solicitud:
● 0 – Ninguna solicitud
● 1 – Solicitud de enviar datos a esclavo(s) Modbus

MB_ADDR

Input

UINT

I, Q, M, D, L o cons‐ Dirección de estación Modbus RTU:
tante
● Área de direccionamiento estándar: 0 a 247
● Área de direccionamiento ampliada: 0 a 65535
El valor "0" está reservado para la difusión general de un
aviso a todos los esclavos Modbus. Para el broadcast
sólo se soportan los códigos de función Modbus 05, 06,
15 y 16.

MODE (Pági‐
na 4586)

Input

USINT

Programación del PLC
Manual de programación y manejo, 11/2019

I, Q, M, D, L o cons‐ Modo de selección: Indica el tipo de solicitud: lectura,
tante
escritura o diagnóstico
En la tabla de funciones Modbus encontrará más deta‐
lles.

4583

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

DATA_ADDR Input
(Página 4586)

UDINT

I, Q, M, D, L o cons‐ Dirección inicial en el esclavo: indica la dirección inicial
tante
de los datos a los que se debe acceder en el esclavo
Modbus. Las direcciones válidas se pueden encontrar
en la tabla de funciones Modbus.

DATA_LEN

UINT

I, Q, M, D, L o cons‐ Longitud de datos: indica el número de bits o palabras a
tante
los que debe acceder esta solicitud. Las longitudes vá‐
lidas se pueden encontrar en la tabla de funciones Mod‐
bus.

DATA_PTR
In_Out
(Página 4587)

VARIANT

M, D

Puntero hacia la dirección del DB o de la marca de la
CPU de los datos que se deben escribir o leer. En un
DB, éste se debe crear con el tipo de acceso "Estándar:
compatible con S7-300/400".

DONE

Output

BOOL

I, Q, M, D, L

● 0: Transacción no finalizada

BUSY

Output

BOOL

I, Q, M, D, L

Input

Descripción

● 1: Transacción finalizada sin errores
● 0: No se está ejecutando ninguna transacción de
"MB_MASTER"
● 1: Transacción de "MB_MASTER" en ejecución
ERROR

Output

BOOL

I, Q, M, D, L

● 0: Ningún error
● 1: Error; el código de error se visualiza en el
parámetro STATUS

STATUS

Output

WORD

I, Q, M, D, L

Condición de ejecución

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
Tabla 4-183 Mensajes de error de comunicación y de error de configuración de la instrucción
Código de error* Descripción
(W#16#....)
0000

Ningún error

80C8

Timeout del esclavo. Compruebe la velocidad de transferencia, la paridad y las conexiones del esclavo.

80D1

El receptor ha solicitado un control de flujo para interrumpir una transmisión en curso, pero la transmisión
no se ha vuelto a activar en el tiempo de espera.
Este error también se crea en el control de flujo por hardware cuando el receptor no detecta ningún CTS
en el tiempo de espera.

80D2

La solicitud de transmisión se ha cancelado, porque no se recibe ninguna señal DSR del DCE.

80E0

El aviso se ha finalizado porque el búfer de recepción está lleno.

80E1

El aviso se ha finalizado por un error de paridad.

80E2

El aviso se ha finalizado por un error de telegrama.

80E3

El aviso se ha finalizado por un error de desbordamiento.

80E4

El aviso se ha cancelado, porque la longitud indicada excede el tamaño del búfer total.

8180

Valor no válido para la ID de puerto.

4584

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de error* Descripción
(W#16#....)
8186

Dirección de estación Modbus no válida

8188

Valor no válido en el parámetro MODE para una llamada de difusión general.

8189

Valor no válido para la dirección de datos.

818A

Valor no válido para la longitud de datos.

818B

Puntero no válido hacia el origen o destino de datos local: tamaño incorrecto

818C

Puntero no válido en el parámetro DATA_PTR. Utilice un puntero hacia un área de marcas o un DB con
el tipo de acceso "Estándar: compatible con S7-300/400".

8200

El puerto está ocupado procesando una solicitud de transmisión

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Tabla 4-184 Mensajes de error del protocolo Modbus
Código de error*
(W#16#....)

Código de res‐
Descripción
puesta del esclavo

8380

-

Error CRC

8381

01

Código de función no soportado

8382

03

Error en la longitud de datos

8383

02

Error en la dirección de los datos o dirección fuera del rango válido de DATA_PTR

8384

> 03

Error en el valor de datos

8385

03

Valor del código de diagnóstico de datos no soportado (código de función 08)

8386

-

El código de función de la respuesta no concuerda con el código de función de la
consulta.

8387

-

Respuesta de un esclavo equivocado

8388

-

La respuesta del esclavo a una llamada de escritura no es correcta. Los datos en‐
viados por el esclavo no concuerdan con la consulta del maestro.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Parámetro REQ
Descripción
● REQ = FALSE: ninguna solicitud
● REQ = TRUE: solicitud de enviar datos a esclavo(s) Modbus
Esta entrada se puede controlar mediante un contacto controlado por nivel o flanco.

Programación del PLC
Manual de programación y manejo, 11/2019

4585

Instrucciones
4.1 Instrucciones
Siempre que se active esta entrada, se iniciará una máquina de estado para garantizar que
otra instrucción "MB_MASTER" utilice los mismos DB de instancia y que no se puede emitir
una petición hasta que la actual no se haya finalizado. Los restantes estados de entrada se
registran y se guardan internamente para la petición actual hasta que se reciba respuesta o se
detecte un error.
Si la misma instancia de "MB_MASTER" se vuelve a ejecutar con la entrada REQ = 1 mientras
no se haya procesado la petición actual, no se realizarán más transferencias. Sin embargo, si
la petición se ha completado, en cuanto "MB_MASTER" se vuelva a ejecutar con la entrada
REQ = 1, se lanzará una nueva solicitud.

Parámetros DATA_ADDR y MODE
Descripción
Con el parámetro DATA_ADDR se especifica la dirección inicial para el acceso a los datos en
el esclavo Modbus.
Con el parámetro MODE y la dirección Modbus se determina el código de función que se
transfiere al esclavo Modbus. La tabla siguiente muestra la relación entre el parámetro MODE,
el código de función y el área de direccionamiento Modbus.
MODE

Función
Modbus

Longitud de da‐
tos

Operación y datos

Dirección Modbus

0

01

de 1 a 2000

Leer bits de salida:

de 1 a 9999

1 a 1992

1 a (1992 ó 2000) bits por consulta

0
0
0
1

02
03
04
05

(1)

de 1 a 2000

Leer bits de entrada:

1 a 1992 (1)

1 a (1992 ó 2000) bits por consulta

10001 a 19999

de 1 a 125

Leer registro de parada:

40001 a 49999 ó

1 a 124 (1)

1 a (124 ó 125) WORD por consulta

de 400001 a 465535

de 1 a 125

Leer WORD de entrada:

30001 a 39999

1 a 124 (1)

1 a (124 ó 125) WORD por consulta

1

Escribir un bit de salida:

de 1 a 9999

Un bit por consulta
1
1
1
2

06
15
16
15

1

Escribir un registro de parada:

40001 a 49999 ó

1 WORD por consulta

de 400001 a 465535

de 2 a 1968

Escribir varios bits de salida:

de 1 a 9999

1 a 1960 (2)

2 a (1960 ó 1968) bits por consulta

de 2 a 123

Escribir varios registros de parada:

40001 a 49999 ó

1 a 122

2 a (122 ó 123) WORD por consulta

de 400001 a 465535

Escribir uno o varios bits de salida:

de 1 a 9999

(2)

de 1 a 1968
1 a 1960

2

4586

16

(2)

1 a (1960 ó 1968) bits por consulta

de 1 a 123

Escribir uno o varios registros de parada:

40001 a 49999 ó

1 a 122

1 a (122 ó 123) WORD por consulta

de 400001 a 465535

(2)

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
MODE

Función
Modbus

Longitud de da‐
tos

Operación y datos

Dirección Modbus

11

11

0

Lectura de la palabra de estado de comunicación
del esclavo y del contador de eventos:

-

La palabra de estado indica la ejecución de la ins‐
trucción (0: no se ejecuta; 0xFFFF: se ejecuta). El
contador de eventos se incrementa en un mensaje
cada vez que se efectúa correctamente una trans‐
misión.
Los parámetros DATA_ADDR y DATA_LEN de la
instrucción "MB_MASTER" son ignorados en esta
función.
80

08

1

Compruebe el estado del esclavo leyendo el código
de error (0x0000):

-

1 WORD por consulta
81

08

1

Resetee el contador del esclavo mediante el código
de diagnóstico 0x000A:

-

1 WORD por consulta
3 a 10, 12 a
79, 82 a
2555

Reservada

-

Para el modo "Área de direccionamiento ampliada", la longitud máxima de datos se reduce en un byte o un WORD, según
el tipo de datos que se utilice para la función.

(1)

Parámetro DATA_PTR
Descripción
El parámetro DATA_PTR es un puntero a un bloque de datos o a una marca desde los que se
escriben o se leen datos. Si utiliza un bloque de datos, cree un bloque de datos global con el
tipo de acceso "Estándar: compatible con S7-300/400".

Programación del PLC
Manual de programación y manejo, 11/2019

4587

Instrucciones
4.1 Instrucciones

Estructuras del bloque de datos para el parámetro DATA_PTR
● Estos tipos de datos sirven para la lectura de palabras de las direcciones Modbus 30001 a
39999, 40001 a 49999 y 400001 a 465536, así como para la escritura de palabras en las
direcciones Modbus 40001 a 49999 y 400001 a 465536.
– Campo estándar de tipos de datos WORD, UINT o INT (véase abajo).
– Estructura con nombres del tipo WORD, UINT o INT, en la que cada elemento tiene un
nombre unívoco y un tipo de datos de 16 bits.
– Estructura compleja con nombres, en la que cada elemento tiene un nombre unívoco y
un tipo de datos de 16 ó 32 bits.
● Para la lectura y escritura de bits de las direcciones Modbus 00001 a 09999 y 10001 a
19999.
– Campo estándar de tipos de datos booleanos.
– Estructura booleana con nombres a partir de variables booleanas con nombres
unívocos.
● No es imprescindible, pero sí recomendable, que cada instrucción "MB_MASTER" tenga un
área de memoria propia separada en un bloque de datos global. El motivo es que la
posibilidad de que los datos se corrompan aumenta cuando varias instrucciones
"MB_MASTER" leen y escriben en la misma área de un bloque de datos global.
● No es necesario que las áreas de memoria para DATA_PTR se encuentren en el mismo
bloque de datos global. Se puede crear un bloque de datos con varias áreas para lecturas
Modbus, un bloque de datos para escrituras Modbus o un bloque de datos para cada
estación esclava.

DB de instancia de la instrucción "MB_MASTER"
Variables estáticas del DB de instancia
La tabla siguiente describe las variables estáticas del DB de instancia de la instrucción que se
pueden utilizar en el programa de usuario.
Variable

Tipo de da‐
tos

Descripción

MB_STATE

UINT

Estado interno de la instrucción Modbus.

BLOCKED_
PROC_TIMEOUT

REAL

Intervalo de tiempo tras el final de la llamada de la instrucción y
reseteo del bit ACTIVE en el DB de instancia. El búfer de tiempo se
usa para evitar que la ejecución de la instrucción termine antes de
haber enviado por completo una petición. El intervalo de tiempo
preajustado es 500 ms.

EXTENDED_ AD‐
DRESSING

BOOL

Configuración del direccionamiento:
● 0: Área de direccionamiento estándar (1 byte)
● 1: Área de direccionamiento ampliada (2 bytes)
En la sección siguiente puede encontrar más información sobre la
variable EXTENDED_ADDRESSING. DB de instancia de la instruc‐
ción "MB_SLAVE" (Página 4594)

4588

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Programa de ejemplo para un maestro Modbus
Segmentos (KOP)
Segmento 1: Los parámetros del módulo RS-485 se deben inicializar sólo una vez durante el
primer ciclo.

Segmento 2: Leer 100 palabras del registro de parada del esclavo.

Segmento 3: Éste es un segmento opcional que muestra los valores de las 3 primeras palabras
si la operación de lectura se ha efectuado.

Segmento 4: Escribir 64 bits en la memoria imagen de proceso de las salidas, inicio en la
dirección del esclavo A2.0.

Programación del PLC
Manual de programación y manejo, 11/2019

4589

Instrucciones
4.1 Instrucciones

MB_SLAVE: Comunicar como esclavo Modbus vía puerto PtP
Descripción de MB_SLAVE
Descripción
La instrucción "MB_SLAVE" permite al programa comunicarse como esclavo Modbus a través
del puerto de un módulo punto a punto (PtP) o una tarjeta de comunicación (CB). Un maestro
Modbus RTU puede enviar una solicitud y el programa responde ejecutando "MB_SLAVE".
Cuando se inserta la instrucción "MB_SLAVE" en el programa, es preciso asignar un bloque de
datos de instancia unívoco. Este bloque de datos de instancia se utiliza cuando se especifica
en el parámetro MB_DB de la instrucción "MB_COMM_LOAD (Página 4579)".
Los códigos de función de la comunicación Modbus (códigos de función 1, 2, 4, 5 y 15) pueden
leer y escribir bits y palabras directamente en la memoria imagen de proceso de las entradas
y de las salidas del sistema de destino. La tabla siguiente muestra la asignación de las
direcciones Modbus en la memoria imagen de proceso de la CPU.
Funciones Modbus de "MB_SLAVE"

S7-1200

Códigos

Función

Área de datos Área de direcciones

Área de datos

Dirección de la CPU

01

Leer bits

Salida

1

a

8192

Memoria imagen de
proceso de las salidas

Q0.0 a Q1023.7

02

Leer bits

Entrada

10001

a

18192

I0.0 a I1023.7
Memoria imagen de
proceso de las entradas

04

Leer palabras

Entrada

30001

a

30512

IW0 a IW1022
Memoria imagen de
proceso de las entradas

05

Escribir bit

Salida

1

a

8192

Memoria imagen de
proceso de las salidas

Q0.0 a Q1023.7

15

Escribir bits

Salida

1

a

8192

Memoria imagen de
proceso de las salidas

Q0.0 a Q1023.7

Los códigos de función de la comunicación Modbus (códigos de función 3, 6, 16) utilizan un
registro de parada propio. Para ello se puede utilizar una marca o un bloque de datos con el
tipo de acceso "Estándar: compatible con S7-300/400".

4590

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El tipo de registro de parada se determina mediante el parámetro MB_HOLD_REG de la
instrucción "MB_SLAVE". La tabla siguiente muestra la asignación del registro de parada
Modbus a la dirección DB de MB_HOLD_REG en el sistema destino.
Funciones Modbus de "MB_SLAVE"
Códi‐
gos

S7-1200

Función

Área de datos Área de direcciones
(Número WORD)

(Número BYTE)

(Número BYTE)

03

Leer palabras

Registros de
parada

40001 a 49999 ó

DW0 a DW19998 o bien

MW0 a límite de CPU

400001 a 465535

DW0 a DW131068

06

Escribir palabra

Registros de
parada

40001 a 49999 ó

DW0 a DW19998 o bien

400001 a 465535

DW0 a DW131068

Registros de
parada

40001 a 49999 ó

DW0 a DW19998 o bien

400001 a 465535

DW0 a DW131068

16

Escribir palabras

Dirección en el DB

Dirección de marca

La tabla siguiente muestra las funciones de diagnóstico Modbus soportadas.
Funciones de diagnóstico Modbus de "MB_SLAVE" del S7-1200
Códigos

Subfunción

Descripción

08

0000H

Emitir datos de consulta del test de eco: la instrucción "MB_SLAVE" devuelve a un maestro
Modbus el eco de una palabra de datos recibida.

08

000AH

Borrar contador de eventos de comunicación: la instrucción "MB_SLAVE" borra el contador de
eventos de comunicación que se ha utilizado para la función Modbus 11.

11

-

Consultar contador de eventos de comunicación: la instrucción "MB_SLAVE" utiliza un contador
de eventos de comunicación interno para registrar el número de solicitudes correctas de lectura
y escritura Modbus que se envían al esclavo Modbus. El contador no se incrementa con las
funciones 8 y 11, ni con las solicitudes broadcast. Tampoco se incrementa con solicitudes que
provocan errores de comunicación (p. ej., errores de paridad o CRC).

La instrucción "MB_SLAVE" soporta solicitudes de escritura broadcast del maestro Modbus
mientras las solicitudes sean para acceder a direcciones válidas.
Independientemente de la validez de una solicitud, "MB_SLAVE" no emite ninguna respuesta
a un maestro Modbus como resultado de una solicitud broadcast.

Reglas para la comunicación del esclavo Modbus
● "MB_COMM_LOAD" debe ejecutarse para configurar un puerto para que la instrucción
"MB_SLAVE" pueda comunicarse con este puerto.
● Si un puerto debe responder a un maestro Modbus como esclavo, dicho puerto no puede
ser utilizado por "MB_MASTER (Página 4582)". Sólo se puede utilizar una instancia de
"MB_SLAVE" para un puerto determinado.
● Las instrucciones Modbus no utilizan eventos de alarma de comunicación para controlar el
proceso de comunicación. El programa debe controlar el proceso de comunicación
consultando la instrucción "MB_SLAVE" en los procedimientos de transmisión y recepción
finalizados.
● La instrucción "MB_SLAVE" debe ejecutarse periódicamente con una frecuencia que
permita una respuesta actual a las solicitudes entrantes de un maestro Modbus. Por este
motivo, resulta recomendable llamar la instrucción en un OB de programa cíclico. La
llamada de la instrucción "MB_SLAVE" se puede efectuar en un OB de alarma, pero no es
recomendable ya que puede provocar retardos temporales considerables en la ejecución.
Programación del PLC
Manual de programación y manejo, 11/2019

4591

Instrucciones
4.1 Instrucciones

Frecuencia de ejecución de "MB_SLAVE"
La instrucción "MB_SLAVE" debe ejecutarse periódicamente para recibir todas las solicitudes
del maestro Modbus y responder como corresponda. La frecuencia de ejecución de
"MB_SLAVE" se rige por el valor del timeout de respuesta indicado en el maestro Modbus. Esto
se representa en la figura que hay a continuación.

$'5

)&

'DWRV

3HU¯RGRGHWLPHRXW
GHODUHVSXHVWD

&5&

(OPDHVWURHQY¯D

(OHVFODYRHQY¯D
7LHPSRGHUHWDUGR
GHODUHVSXHVWD
$'5

,QWHUYDORGH
&5& LQLFLR WLHPSRVGH
FDUDFWHUHV

$'5

)&

'DWRV

,QWHUYDOR
&5& GHLQLFLR

El período de timeout de respuesta es el tiempo que espera un maestro Modbus hasta el inicio
de respuesta de un esclavo Modbus. Este período no se define en el protocolo Modbus, sino
en un parámetro del correspondientes maestro Modbus. La frecuencia de ejecución (el tiempo
entre una ejecución y la siguiente) de "MB_SLAVE" debe regirse por los parámetros
correspondientes del maestro Modbus. Como mínimo, "MB_SLAVE" debe ejecutarse dos
veces durante el período de timeout de respuesta del maestro Modbus.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "MB_SLAVE":
Parámetro

Declaración

Tipo de da‐
tos

Área de memoria

Descripción

MB_ADDR

Input

V1.0:
USINT

I, Q, M, D, L o cons‐ Dirección de estación del esclavo Modbus (espacio
tante
de direcciones: de 0 a 255)

V2.0: UINT
MB_HOLD_REG

In_Out

VARIANT

D

NDR

Output

BOOL

I, Q, M, D, L

Puntero hacia el DB del registro de parada Modbus.
El DB se debe crear con el tipo de acceso "Están‐
dar: compatible con S7-300/400".
Nuevos datos listos:
● 0: no hay datos nuevos
● 1: indica que el maestro Modbus ha escrito
datos nuevos

DR

Output

BOOL

I, Q, M, D, L

Leer datos:
● 0: no se han leído datos
● 1: indica que los datos han sido leídos por el
maestro Modbus

ERROR

Output

BOOL

I, Q, M, D, L

● 0: no se ha detectado ningún error
● 1: error; el código de error correspondiente se
devuelve en el parámetro STATUS

STATUS

4592

Output

WORD

I, Q, M, D, L

Código de error

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Parámetro STATUS
STATUS*
(W#16#....)

Descripción

80C8

El timeout de respuesta indicado (véase RCVTIME o MSGTIME) es "0".

80D1

El receptor ha solicitado un control de flujo para interrumpir una transmisión en curso, pero la transmisión
no se ha vuelto a activar en el tiempo de espera.
Este error también se crea en el control de flujo por hardware cuando el receptor no detecta ningún CTS
en el tiempo de espera.

80D2

La solicitud de transmisión se ha cancelado, porque no se recibe ninguna señal DSR del DCE.

80E0

El aviso se ha finalizado porque el búfer de recepción está lleno

80E1

El aviso se ha cancelado por un error de paridad

80E2

El aviso se ha cancelado por un error de telegrama

80E3

El aviso se ha cancelado por un error de desbordamiento

80E4

El aviso se ha cancelado, porque la longitud indicada excede el tamaño del búfer total

8180

Valor no válido para la ID de puerto.

8186

Dirección de estación Modbus no válida

8187

Puntero no válido hacia MB_HOLD_REG-DB

818C

Puntero hacia un tipo de DB MB_HOLD_REG típico (se requiere un tipo de DB clásico)

Código de respuesta enviado al maestro Modbus (B#16#...)
8380

Sin respuesta

Error CRC

8381

01

Código de función no soportado, o bien no soportado dentro de una difusión ge‐
neral

8382

03

Error en la longitud de datos

8383

02

Error en la dirección de los datos o dirección fuera del rango válido de
MB_HOLD_REG

8384

03

Error en el valor de datos

8385

03

Valor del código de diagnóstico de datos no soportado (código de función 08)

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Consulte también
Cambiar formatos de visualización en el estado del programa (Página 8529)

Programación del PLC
Manual de programación y manejo, 11/2019

4593

Instrucciones
4.1 Instrucciones

DB de instancia de la instrucción "MB_SLAVE"
Variables estáticas del DB de instancia
La tabla siguiente describe las variables estáticas del DB de instancia de la instrucción que se
pueden utilizar en el programa de usuario. El programa puede escribir valores en las variables
HR_Start_Offset y Extended_Addressing y controlar las operaciones del esclavo Modbus.
Las demás variables pueden ser leídas para supervisar el estado del Modbus.
Variable

Tipo de da‐
tos

Descripción

HR_Start_Offset

WORD

Dirección inicial del registro de parada Modbus (estándar="0")

Extended_ Ad‐
dressing

BOOL

Configuración del direccionamiento:
● 0: Área de direccionamiento estándar (1 byte)
● 1: Área de direccionamiento ampliada (2 bytes)

Request_Count

WORD

Número de todas las consultas recibidas por el esclavo

Slave_Messa‐
ge_Count

WORD

Número de consultas enviadas específicamente a este esclavo

Bad_CRC_Count

WORD

Número de consultas recibidas con error CRC

Broadcast_Count

WORD

Número de consultas recibidas de difusión general

Exception_Count

WORD

Número de errores específicos del Modbus que requieren el reenvío
de una excepción

Success_Count

WORD

Número de solicitudes para este esclavo específico recibidas sin
error de protocolo

HR_Start_Offset
Las direcciones del registro de parada del Modbus empiezan en 40001 ó 400001. Estas
direcciones corresponden a la dirección inicial del registro de parada en la memoria del
sistema de destino. Por medio de la variable HR_Start_Offset se puede especificar el
desplazamiento respecto a otra dirección inicial.
Ejemplo: Un registro de parada empieza en MW100 y tiene una longitud de 100 WORD. Con
un desplazamiento de 20 en el parámetro HR_Start_Offset, el registro de parada empieza en
la dirección 40021 en vez de en 40001. Toda dirección inferior a 40021 y superior a 400119
provoca un error de direccionamiento.
HR_Start_Offset = 0

4594

HR_Start_Offset = 20

Dirección de pa‐
labra Modbus

Dirección de
byte S7-1200

Dirección de pala‐
bra Modbus

Dirección de byte
S7-1200

Mínimo

40001

MW100

40021

MW100

Máximo

40099

MW198

40119

MW198

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Extended_Addressing
Para el direccionamiento del esclavo Modbus se puede configurar un solo byte (área de
direccionamiento estándar) o un byte doble (área de direccionamiento ampliada). El
direccionamiento ampliado sirve para direccionar más de 247 dispositivos en una única red. Si
opta por el direccionamiento ampliado, puede direccionar 64.000 direcciones como máximo.
A continuación se muestra un telegrama de la función Modbus 1 como ejemplo.
Tabla 4-185 Dirección del esclavo con un byte (byte 0)
Función 1

Byte 0

Byte 1

Byte 2

Requisito

Dirección
del esclavo

Código F

Respuesta váli‐
da

Dirección
del esclavo

Código F

Longitud

Respuesta erró‐
nea

Dirección
del esclavo

0x81

Código E

Byte 3

Byte 4

Dirección inicial

Byte 5

Longitud de las bobinas
Datos de las bobinas

Tabla 4-186 Dirección del esclavo con dos bytes (byte 0 y byte 1)
Función 1

Byte 0

Byte 1

Byte 2

Byte 3

Byte 4

Requisito

Dirección del esclavo

Código F

Respuesta váli‐
da

Dirección del esclavo

Código F

Longitud

Dirección inicial

Respuesta erró‐
nea

Dirección del esclavo

0x81

Código F

Byte 5

Byte 6

Longitud de las bobinas
Datos de las bobinas

Programa de ejemplo de un esclavo Modbus
Segmentos (KOP)
Segmento 1: Inicializar los parámetros del módulo RS-485 sólo una vez durante el primer ciclo.

Segmento 2: Comprobar en cada ciclo la presencia de solicitudes del maestro Modbus. El
registro de parada Modbus está configurado con 100 palabras a partir de MW1000.

Programación del PLC
Manual de programación y manejo, 11/2019

4595

Instrucciones
4.1 Instrucciones

MODBUS (TCP)
MODBUS (TCP) para las versiones de librería V2.1 y V3.x de las CPU S7-1200
MB_CLIENT: Comunicarse como cliente Modbus TCP vía PROFINET
Descripción MB_CLIENT
Descripción
La instrucción "MB_CLIENT" permite la comunicación como cliente Modbus TCP a través de
la conexión PROFINET de la CPU S7-1200. Para utilizar esta instrucción no se requiere ningún
módulo de hardware adicional. La instrucción "MB_CLIENT" permite establecer una conexión
entre el cliente y el servidor, enviar órdenes y recibir respuestas y controlar la desconexión del
servidor Modbus TCP.

4596

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "MB_CLIENT":
Parámetro

Declaración

Tipo de datos Descripción

REQ (Página 4600)

Input

BOOL

Orden de comunicación con el servidor Modbus TCP
El parámetro REQ se controla por nivel. Así, mientras la entrada
esté activada (REQ=true), la instrucción enviará órdenes de comu‐
nicación.
● Con la orden de comunicación se bloquea el DB de instancia
para otros clientes.
● Las modificaciones de los parámetros de entrada no se hacen
efectivas hasta que no hay respuesta del servidor o hasta que no
se devuelve un mensaje de error.
● Si durante una orden Modbus en curso se vuelve a activar el
parámetro REQ, a continuación no se ejecuta ninguna otra
transferencia.

DISCONNECT (Pá‐
gina 4600)

Input

BOOL

Mediante este parámetro se controla el establecimiento de la cone‐
xión y la desconexión con el servidor Modbus:
● 0: Establecer una conexión de comunicación con la dirección IP
y número de puerto especificados.
● 1: Deshacer la conexión. Durante la desconexión no se ejecuta
ninguna otra función. Tras deshacer la conexión correctamente,
el parámetro STATUS devuelve el valor 7003.
Si el parámetro REQ está activado mientras se establece la cone‐
xión, la consulta se envía de inmediato.

CONNECT_ID

Input

UINT

ID unívoca para identificar la conexión. A cada instancia de las ins‐
trucciones "MB_CLIENT" y "MB_SERVER (Página 4606)" debe
asignársele una ID de conexión unívoca.

IP_OCTET_1

Input

USINT

1.er octeto de la dirección IP* del servidor Modbus TCP.

IP_OCTET_2

Input

USINT

2.º octeto de la dirección IP* del servidor Modbus TCP.

IP_OCTET_3

Input

USINT

3.er octeto de la dirección IP* del servidor Modbus TCP.

IP_OCTET_4

Input

USINT

4.º octeto de la dirección IP* del servidor Modbus TCP.

IP_PORT

Input

UINT

Número de IP y puerto del servidor con el que el cliente establece la
conexión y con el que se comunica mediante el protocolo TCP/IP
(valor estándar: 502).

MB_MODE (Pági‐
na 4600)

Input

USINT

Selección del modo de consulta (lectura, escritura o diagnóstico).

MB_DATA_ADDR
(Página 4600)

Input

UDINT

Dirección inicial de los datos a los que accede la instrucción
"MB_CLIENT".

DATA_LEN

Input

UINT

Longitud de datos: Número de bits o palabras para el acceso a los
datos (ver "Parámetros MB_MODE y MB_DATA_ADDR": longitud
de datos).

MB_DATA_PTR (Pá‐ InOut
gina 4602)

VARIANT

Puntero al registro de datos Modbus: El registro es un búfer para los
datos recibidos desde el servidor Modbus o que se van a enviar al
servidor Modbus. El puntero debe remitir a un bloque de datos glo‐
bal con acceso estándar.

DONE

BOOL

El número de bits direccionados debe ser divisible entre 8.
Out

Programación del PLC
Manual de programación y manejo, 11/2019

El bit del parámetro de salida DONE se pone a "1" en cuanto se ha
ejecutado sin errores la última orden.

4597

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos Descripción

BUSY

Out

BOOL

● 0: No se está ejecutando ninguna orden de "MB_CLIENT "
● 1: Orden de "MB_ CLIENT " en ejecución

ERROR

Out

BOOL

● 0: Ningún error
● 1: Con errores. La causa del error se indica mediante el
parámetro STATUS.

STATUS (Pági‐
na 4603)

Out

WORD

Código de error de la instrucción.

* Componente de 8 bits de longitud de la dirección IP IPv4 de 32 bits del servidor Modbus TCP.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".
Nota
Datos de entrada coherentes durante una llamada de "MB_CLIENT"
En cuanto un cliente Modbus ejecuta una instrucción Modbus, el estado de los parámetros de
entrada se almacena internamente y luego se compara en la siguiente llamada. La
comparación se utiliza para determinar si es esa orden concreta la que ha iniciado la consulta
en curso. Pueden realizarse varias llamadas de "MB_CLIENT" utilizando un DB de instancia
común. Los valores de los parámetros de entrada no deben modificarse mientras esté
ejecutándose una instancia "MB_CLIENT". Si se modifican los parámetros de entrada durante
la ejecución, no se puede comprobar mediante "MB_CLIENT" si la instancia se está
ejecutando en el momento actual.

Conexiones múltiples de clientes
Un cliente Modbus TCP puede admitir varias conexiones TCP (el número máximo de
conexiones depende de la CPU utilizada). El total de conexiones de una CPU, incluidos los
clientes Modbus TCP y los servidores, no debe exceder el número máximo de conexiones
admitido. Las conexiones Modbus TCP también pueden ser utilizadas conjuntamente por las
conexiones de cliente y/o servidor.
En algunas conexiones de cliente deben respetarse las siguientes reglas:
● Cada conexión "MB_CLIENT" debe utilizar un DB de instancia unívoco.
● Para cada conexión "MB_CLIENT" debe especificarse una dirección IP unívoca del
servidor.
● Cada conexión "MB_CLIENT" requiere una ID de conexión unívoca.
Para cada DB de instancia de la instrucción debe utilizarse la correspondiente ID de
conexión. Los ID de conexión y los DB de instancia se agrupan por pares y deben ser
unívocos para cada conexión.
● Según la configuración del servidor, se requerirán o no números unívocos de puerto IP.

4598

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Variables estáticas de la instrucción
En la siguiente tabla se describen las variables estáticas editables del bloque de datos de
instancia de la instrucción "MB_CLIENT".
Variable

Tipo de datos

Valor de
arranque

Descripción

Blocked_Proc_Ti‐
meout

REAL

3.0

Tiempo en segundos que hay que esperar para que se inicialice la
variable estática ACTIVE en una instancia Modbus bloqueada. Esto
puede suceder, por ejemplo, cuando, habiéndose emitido una orden
de cliente, se cancela la ejecución de la función de cliente antes de
que se haya ejecutado por completo la orden. El tiempo de espera
máximo es de 55 segundos.

MB_Transaction_ID

WORD

1

ID de transacción del protocolo Modbus TCP. El valor de arranque
"1" solo debe modificarse en caso de que el servidor Modbus TCP
necesite un valor diferente.

MB_Unit_ID

BYTE

255

Unit Identifier
ID de dispositivo Modbus:
Para acceder a un servidor TCP Modbus se utiliza su dirección IP.
Por ello no se utiliza el parámetro MB_UNIT_ID para el direcciona‐
miento Modbus TCP.
El parámetro MB_UNIT_ID equivale al campo de la dirección de
esclavo en el protocolo Modbus RTU. Si se utiliza un servidor Mod‐
bus TCP como pasarela a un protocolo Modbus RTU, el dispositivo
esclavo en la red serie puede identificarse con MB_UNIT_ID. En tal
caso, el parámetro MB_UNIT_ID reenviaría la orden a la dirección
de esclavo Modbus RTU correcta.
Tenga en cuenta que algunos dispositivos Modbus TCP pueden
necesitar el parámetro MB_UNIT_ID para la inicialización dentro de
un rango de valores limitado.

RCV_TIMEOUT

REAL

2.0

Intervalo en segundos durante el que la instrucción "MB_CLIENT"
permanece a la espera de una respuesta del servidor.

Connected

BOOL

0

Indica si la conexión con el cliente asignado está establecida o no:
1 = conectado, 0 = no conectado.

Consulte también
MB_CLIENT ejemplo 1: Enviar varias peticiones a través de una conexión TCP (Página 4613)
MB_CLIENT ejemplo 2: Enviar varias peticiones a través de varias conexiones TCP
(Página 4614)
MB_CLIENT ejemplo 3: Coordinar varias peticiones (Página 4615)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)

Programación del PLC
Manual de programación y manejo, 11/2019

4599

Instrucciones
4.1 Instrucciones

Parámetros REQ y DISCONNECT
Descripción
Si no se ejecuta ninguna instancia de la instrucción "MB_CLIENT" y si el parámetro
DISCONNECT tiene el valor "0", con REQ=1 se ejecuta otra petición. Si todavía no se ha
establecido ninguna conexión, esta se establecerá al ejecutarse la instrucción.
Si se vuelve a ejecutar la misma instancia de la instrucción "MB_CLIENT" (DISCONNECT=0
y REQ=1) antes de que se ejecute la petición activa, esta no se ejecutará a continuación de la
petición activa. Solo podrá iniciarse una nueva petición una vez que haya finalizado la petición
activa (REQ=1).
Para vigilar el estado de la ejecución puede usarse el parámetro de salida DONE. Este puede
usarse para vigilar el estado de ejecución durante una ejecución secuencial de la instrucción
"MB_CLIENT".

Consulte también
Descripción MB_CLIENT (Página 4596)

Parámetros MB_MODE, MB_DATA_ADDR y MB_DATA_LEN
Descripción
Para los valores 0, 1 y 2 de MB_MODE, la combinación de los parámetros MB_MODE,
MB_DATA_ADDR y MB_DATA_LEN define el código de función Modbus que se utiliza en el
mensaje Modbus actual:
● MB_MODE contiene la información de si debe leerse o escribirse.
MB_MODE=0: lectura, MB_MODE=1 y 2: escritura
● MB_DATA_ADDR contiene la información de lo que debe leerse o escribirse, así como
información de la dirección con la que la instrucción "MB_CLIENT" calcula la dirección
remota.
● DATA_LEN contiene el número de valores que se van a leer o escribir.
Ejemplos:
● La combinación MB_MODE=1, MB_DATA_ADDR=1, DATA_LEN=1 define el código de
función 05. A partir de la dirección remota 0 se escribe 1 bit de salida.
● La combinación MB_MODE=1, MB_DATA_ADDR=1, DATA_LEN=2 define el código de
función 15. A partir de la dirección remota 0 se escriben 2 bits de salida.

4600

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra la relación entre los parámetros de entrada MB_MODE,
MB_DATA_ADDR, DATA_LEN de la instrucción "MB_CLIENT" y la función Modbus
correspondiente.
MB_MODE

MB_DA‐
TA_ADDR

DATA_LEN Función
Modbus

Función y tipo de datos

0

de 1 a 9.999

de 1 a
2.000

01

Leer de 1 a 2.000 bits de salida en la dirección remota de 0
a 9.998

0

de 10.001 a
19.999

de 1 a
2.000

02

Leer de 1 a 2.000 bits de entrada en la dirección remota de 0
a 9.998

0

de 40.001 a
49.999

de 1 a 125

03

Leer de 1 a 125 registros de parada en la dirección remota de
0 a 9.998

0

de 30.001 a
39.999

de 1 a 125

04

Leer de 1 a 125 palabras de entrada en la dirección remota de
0 a 9.998

1

de 1 a 9.999

1

05

Escribir 1 bit de salida en la dirección remota de 0 a 9.998

1

de 40.001 a
49.999

1

06

Escribir 1 registro de retención en la dirección remota de 0 a
9.998

1

de 1 a 9.999

de 2 a
1.968

15

Escribir de 2 a 1.968 bits de salida en la dirección remota de
0 a 9.998

1

de 40.001 a
49.999

de 2 a 123

16

Escribir de 2 a 123 registros de parada en la dirección remota
de 0 a 9.998

2

de 1 a 9.999

de 1 a
1.968

15

Escribir de 1 a 1.968 bits de salida en la dirección remota de
0 a 9.998

2

de 40.001 a
49.999

de 1 a 123

16

Escribir de 1 a 123 registros de parada en la dirección remota
de 0 a 9.998

11

11
Los parámetros MB_DA‐
TA_ADDR y DATA_LEN no se
evalúan al ejecutar esta función.

Leer la palabra de estado y el contador de eventos del servi‐
dor:
● La palabra de estado forma el estado de ejecución (0: no
en ejecución, 0xFFFF: en ejecución).
● El contador de eventos se incrementa si la orden Modbus
se ha ejecutado correctamente. Si se produce un error al
ejecutar una función Modbus, el servidor envía un
mensaje, pero el contador de eventos no se incrementa.

80

-

1

08

Comprobación del estado del servidor por el código de diag‐
nóstico 0x0000 (test de bucle de retorno: el servidor devuelve
la orden):
● 1 WORD por llamada

81

-

1

08

Reiniciar el contador de eventos del servidor mediante el có‐
digo de diagnóstico 0x000A:
● 1 WORD por llamada

de 3 a 10,
de 12 a 79,
de 82 a 255

Programación del PLC
Manual de programación y manejo, 11/2019

Reservado

4601

Instrucciones
4.1 Instrucciones

Nota
Unit Identifier para dispositivos RTU mediante MB-TCP
La identificación del dispositivo (Unit Identifier) para dispositivos RTU mediante Modbus TCP
se encuentra como variable "MB_Unit_ID" en las variables editables del bloque de datos de
instancia de la instrucción "MB_CLIENT". El Unit Identifier sirve para asignar de forma unívoca
los miembros del acoplamiento.

Consulte también
Descripción MB_CLIENT (Página 4596)

Parámetro MB_DATA_PTR
Descripción
El parámetro MB_DATA_PTR es un puntero hacia un búfer de datos para almacenar los datos
que se han leído o escrito en el servidor Modbus. Puede usarse como búfer de datos un bloque
de datos global o un área de memoria (M).
Para un búfer en el área de memoria (M), utilice un puntero con el formato ANY según el
patrón"P#dirección_de_bit" "Tipo de datos" "Longitud" (ejemplo: P#M1000.0 WORD 500).
El parámetro MB_DATA_PTR utiliza un búfer de comunicación:
● Para las funciones de comunicación de la instrucción "MB_CLIENT":
– Lectura y escritura de datos de 1 bit de las direcciones de servidor Modbus de 00001 a
09999 y de 10001 a 19999.
– Lectura de datos WORD de 16 bits de las direcciones de servidor Modbus de 30001 a
39999 y de 40001 a 49999.
– Escritura de datos WORD de 16 bits de las direcciones del servidor Modbus de 40001
a 49999.
● Para la transferencia de datos (longitud: bit o WORD) desde o hacia el DB global o el área
de memoria (M) que se ha asignado mediante el parámetro MB_DATA_PTR.
Si se utiliza en el parámetro MB_DATA_PTR un bloque de datos para el puntero al búfer, deben
asignarse tipos de datos a los elementos de DB.
● Para una dirección de bit Modbus, utilice el tipo de datos de 1 bit BOOL
● Para una dirección Modbus WORD, utilice un tipo de datos de 16 bits como WORD, UINT,
INT o REAL.
● Para dos direcciones Modbus WORD, utilice un tipo de datos de 32 bits (palabra doble)
como DWORD, DINT o REAL.

4602

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● Mediante MB_DATA_PTR se puede acceder también a elementos de DB complejos como:
– Matrices estándar
– Estructuras con nombres de elemento unívocos
– Estructuras complejas con denominación unívoca de los elementos longitudes de tipo
de datos de 16 ó 32 bits.
● Las áreas de datos para el parámetro MB_DATA_PTR pueden encontrarse también en
distintos bloques de datos globales (o en distintas áreas de memoria). Por ejemplo, puede
utilizarse un bloque de datos para las operaciones de lectura y otro para las operaciones de
escritura, o un bloque de datos independiente para cada estación "MB_CLIENT".

Consulte también
Descripción MB_CLIENT (Página 4596)

Parámetro STATUS
Parámetro STATUS (información de estado general) (versión de librería V2.1)
STATUS*
(W#16#)

Descripción

0000

Instrucción ejecutada sin errores.

7000

Ninguna llamada activa (REQ=0).

7001

Primera llamada con REQ=1: Ejecución iniciada; BUSY tiene el valor 1.

7002

Llamada intermedia (REQ irrelevante). Ejecución ya activa; BUSY tiene el valor 1.

7003

Deshaciendo la conexión.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Parámetro STATUS (información de estado general) (versión de librería V3.x)
STATUS*
(W#16#)

Descripción

0000

Instrucción ejecutada sin errores.

0001

Conexión establecida.

0003

Desconexión realizada.

7000

Ninguna llamada activa (REQ=0).

7001

Primera llamada con REQ=1: Ejecución iniciada; BUSY tiene el valor 1.

7002

Llamada intermedia (REQ irrelevante). Ejecución ya activa; BUSY tiene el valor 1.

7003

Deshaciendo la conexión.

7004

Conexión establecida y vigilada. No se está procesando ninguna petición.

7005

Datos enviados.

Programación del PLC
Manual de programación y manejo, 11/2019

4603

Instrucciones
4.1 Instrucciones
STATUS*
(W#16#)

Descripción

7006

Datos recibidos.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Parámetro STATUS (error de protocolo)
STA‐
TUS*
(W#16#)

Error local o
remoto

Código de error en la
respuesta de
MB_SERVER
(B#16#)

Descripción

80C8

local

-

No ha habido respuesta del servidor en el periodo definido. Compruebe la
conexión con el servidor Modbus. Este error no se notifica hasta que no ha
finalizado el número configurado de reintentos.
Si la instrucción "MB_CLIENT" no obtiene respuesta alguna con la ID de
transacción transmitida originalmente (variable MB_TRANSACTION_ID)
dentro del periodo definido, se emitirá este código de error.

8380

local

-

El frame Modbus recibido no tiene el formato correcto o el número de bytes
recibidos no es suficiente.

8381

remoto

01

Código de función no soportado.

8382

local

-

● La longitud del frame Modbus indicada en el encabezado del frame no
coincide con el número de bytes recibidos.
● El número de bytes no coincide con los bytes realmente transferidos
(solo funciones 1-4). Esto sucede, por ejemplo, cuando "MB_CLIENT"
solicita un número impar de palabras pero "MB_SERVER" envía
siempre un número par de palabras.
● La dirección de inicio que figura en el frame recibido no coincide con la
dirección de inicio guardada (funciones 5, 6, 15, 16).
● El número de palabras no coincide con las palabras realmente
transferidas (funciones 15 y 16).

8383

8384

remoto

03

Indicación de longitud no admisible en el frame Modbus recibido. Com‐
pruebe el lado del servidor.

local

-

Error al leer o escribir los datos o acceso fuera del área de direcciones
de MB_DATA_PTR (Página 4602).

remoto

02

Error al leer o escribir los datos o acceso fuera del área de direcciones del
servidor

local

-

● El Exception Code recibido no es válido.
● Se ha recibido otro valor de datos distinto del enviado originalmente por
el cliente (funciones 5, 6 y 8).
● El valor de estado recibido no es válido (función 11)

8385

remoto

03

Error en el valor de datos para la función 5

local

-

● Código de diagnóstico no soportado.
● Se ha recibido otro código de subfunción distinto del enviado
originalmente por el cliente (función 8).

8386

4604

remoto

03

Código de diagnóstico no soportado

local

-

El código de función recibido no coincide con el enviado originalmente.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
STA‐
TUS*
(W#16#)

Error local o
remoto

Código de error en la
respuesta de
MB_SERVER
(B#16#)

Descripción

8387

local

-

● La ID de conexión asignada es distinta de las de anteriores peticiones.
Solo puede utilizarse una ID de conexión para cada DB de instancia de
la instrucción "MB_CLIENT".
● Este código de error se emite aunque la ID del protocolo Modbus TCP
recibido por el servidor sea distinta de "0".

8388

local

-

Se ha enviado a través del servidor Modbus una longitud de datos distinta
de la solicitada. Este error solo se produce si se utilizan las funciones Mod‐
bus 15 o 16.

* Los códigos de estado en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Parámetro STATUS (error de parámetro)
Además de los errores listados en la siguiente tabla, con la instrucción "MB_CLIENT" pueden
producirse también errores en las instrucciones de comunicación utilizadas por la instrucción
("TCON", "TDISCON", "TSEND" y "TRCV").
STATUS*
(W#16#)

Descripción

80BB

Valor no válido en el parámetro ACTIVE_EST (identificador del modo de establecimiento de conexión, véase
T_CON_PARAM):
● El lado del servidor solo permite el establecimiento pasivo de la conexión (ACTIVE_EST = FALSE).
● El lado del cliente solo permite el establecimiento activo de la conexión (ACTIVE_EST = TRUE).

8188

Valor no válido en el parámetro MB_MODE.

8189

Direccionamiento no válido de los datos en el parámetro MB_DATA_ADDR.

818A

Longitud de datos no válida en el parámetro MB_DATA_LEN.

818B

Puntero no válido en el parámetro MB_DATA_PTR. Compruebe además los valores de los
parámetros MB_DATA_ADDR (Página 4600) y MB_DATA_LEN.

818C

● El puntero del parámetro MB_DATA_PTR (Página 4596) señala a un bloque de datos optimizado. Utilice
un bloque de datos con acceso estándar o un área de memoria.
● Rebase de tiempo en el parámetro BLOCKED_PROC_TIMEOUT (ver variables estáticas de la instrucción).
Se ha rebasado el límite de 55 segundos.

8200

● En este momento se está procesando otra petición Modbus a través del puerto.
● Otra instancia de MB_CLIENT con los mismos parámetros de conexión está procesando una petición
Modbus ya existente.

* Los códigos de error en el editor de programas se pueden representar como valores enteros o hexadecimales. Encontrará
más información sobre el cambio de los formatos de visualización en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

4605

Instrucciones
4.1 Instrucciones

Nota
Códigos de error de las instrucciones de comunicación utilizadas internamente.
Además de los errores listados en las tablas, con la instrucción "MB_CLIENT" pueden
producirse también errores en las instrucciones de comunicación ("TCON", "TDISCON",
"TSEND" y "TRCV") utilizadas por la instrucción.
La asignación del código de error se puede realizar a través del bloque de datos de instancia
de la instrucción "MB_CLIENT". En la sección Static se indican los códigos de error en la
instrucción correspondiente bajo STATUS.
El significado de los códigos de error se puede consultar en la documentación de la instrucción
de comunicación correspondiente.

Consulte también
Parámetro MB_HOLD_REG (Página 4610)
Cambiar formatos de visualización en el estado del programa (Página 8529)

MB_SERVER: Comunicarse como servidor Modbus TCP vía PROFINET
Descripción MB_SERVER
Descripción
La instrucción "MB_SERVER" permite la comunicación como servidor Modbus TCP a través
de la conexión PROFINET de la CPU S7-1200. Para utilizar esta instrucción no se requiere
ningún módulo de hardware adicional. La instrucción "MB_SERVER" permite procesar
peticiones de conexión de un cliente Modbus TCP, recibir peticiones de funciones Modbus y
enviar mensajes de respuesta.
ATENCIÓN
Nota de seguridad
Tenga en cuenta que todos los clientes de la red tienen acceso de lectura y escritura a la
memoria imagen de proceso de las entradas y salidas y al bloque de datos o al área de
marcas definido por el registro de parada de Modbus.
Para evitar que personas no autorizadas lleven a cabo procesos de lectura y escritura, es
posible restringir el acceso a una dirección IP. No obstante, tenga en cuenta que la dirección
habilitada también ofrece acceso a personas no autorizadas.

4606

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "MB_SERVER":
Parámetro

Declaración

Tipo de da‐
tos

Descripción

DISCONNECT

Input

BOOL

La instrucción "MB_SERVER" tiene una conexión pasiva con un módulo
interlocutor, es decir, el servidor reacciona a una petición de conexión
TCP de cada dirección IP que la solicite. Este parámetro permite contro‐
lar cuándo se aceptará una petición de conexión:
● 0: Si no hay ninguna conexión establecida, se establece una conexión
pasiva.
● 1: Inicialización del establecimiento de la conexión. Si la entrada esta
activada, no se ejecutan otras operaciones. Tras deshacer la
conexión correctamente, el parámetro STATUS devuelve el valor
7003.

CONNECT_ID

Input

UINT

Mediante este parámetro se identifica una conexión en la CPU de modo
unívoco. Cada una de las instancias de las instrucciones "MB_CLIENT
(Página 4596)" y "MB_SERVER" debe utilizar una ID unívoca en el pa‐
rámetro CONNECT_ID.

IP_PORT

Input

UINT

Valor de arranque=502 El número del puerto IP determina qué puerto IP
se vigila para peticiones de conexión del cliente Modbus.
Los siguientes números de puerto TCP no deben usarse para la conexión
pasiva de la instrucción "MB_SERVER": 20, 21, 25, 80, 102, 123, 5001,
34962, 34963 y 34964.

MB_HOLD_REG
(Página 4610)

InOut

VARIANT

Puntero al registro de parada Modbus de la instrucción "MB_SERVER":
Utilice como registro de parada un bloque de datos global con acceso
estándar. El registro de parada contiene los valores a los que está auto‐
rizado a acceder un cliente Modbus mediante las funciones Modbus 3
(lectura), 6 (escritura) y 16 (lectura).

NDR

Output

BOOL

"New Data Ready":
● 0: No hay datos nuevos
● 1: El cliente Modbus ha escrito datos nuevos

DR

Output

BOOL

"Data Read":
● 0: No se han leído datos
● 1: El cliente Modbus ha leído datos

ERROR

Output

BOOL

Si se produce un error durante una llamada de la instrucción "MB_SER‐
VER", la salida del parámetro ERROR se ajusta a TRUE. La causa de‐
tallada del error se muestra en el parámetro STATUS.

STATUS (Pági‐
na 4611)

Output

WORD

Código de error de la instrucción.

Encontrará más información sobre los tipos de datos válidos en "Vista general de los tipos de
datos válidos (Página 241)".

Reproducir las direcciones Modbus en la memoria imagen de proceso
La instrucción "MB_SERVER" permite a las funciones Modbus entrantes (1, 2, 4, 5 y 15)
acceder directamente en lectura y escritura a la memoria imagen de proceso de las entradas
y salidas de la CPU S7-1200 (usando los tipos de datos BOOL y WORD).

Programación del PLC
Manual de programación y manejo, 11/2019

4607

Instrucciones
4.1 Instrucciones
Para la transferencia de datos de los códigos de función 3, 6 y 16, el registro de parada
(parámetro MB_HOLD_REG) debe definirse con una longitud de más de un byte. La tabla
siguiente muestra la imagen de las direcciones Modbus en la memoria imagen de proceso de
la CPU.
Función Modbus

S7-1200

Código Función

Área de datos

Espacio de direcciones

Área de datos

Dirección de la CPU

01

Leer: bits

Output

0

a

8191

Memoria imagen de pro‐
ceso de las salidas

De Q0.0 a Q1023.7

02

Leer: bits

Input

0

a

8191

Memoria imagen de pro‐
ceso de las entradas

De I0.0 a I1023.7

04

Leer: WORD

Input

0

a

1021

Memoria imagen de pro‐
ceso de las entradas

De IW0 a IW1022

05

Escribir: bits

Output

0

a

8191

Memoria imagen de pro‐
ceso de las salidas

De Q0.0 a Q1023.7

15

Escribir: bits

Output

0

a

8191

Memoria imagen de pro‐
ceso de las salidas

De Q0.0 a Q1023.7

Los mensajes Modbus entrantes con los códigos de función 3, 6 y 16 escriben o leen desde el
registro de parada de Modbus (el registro de parada debe especificarse en el parámetro
MB_HOLD_REG).

Conexiones múltiples a servidor
Pueden establecerse conexiones múltiples a servidor. Gracias a ello, una sola CPU puede
establecer conexiones con varios clientes Modbus TCP al mismo tiempo.
Un servidor Modbus TCP puede admitir varias conexiones TCP (el número máximo de
conexiones depende de la CPU utilizada).
El total de conexiones de una CPU, incluidos los clientes Modbus TCP y los servidores, no
debe exceder el número máximo de conexiones admitido.
Las conexiones Modbus TCP también pueden ser utilizadas conjuntamente por las
conexiones de cliente y/o servidor.
Para las conexiones de servidor deben respetarse las siguientes reglas:
● Cada conexión "MB_SERVER" debe utilizar un DB de instancia unívoco.
● Cada conexión "MB_SERVER" debe establecerse con un número unívoco de puerto IP. Se
admite una sola conexión para cada puerto.
● Cada conexión "MB_SERVER" debe utilizar una ID de conexión unívoca.
Para cada DB de instancia de la instrucción debe utilizarse la correspondiente ID de
conexión. Las ID de conexión y los DB de instancia se agrupan por pares y deben ser
unívocos para cada conexión.
● Para cada conexión debe llamarse separadamente la instrucción "MB_SERVER".

4608

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Funciones de diagnóstico Modbus
La tabla siguiente contiene la descripción de las funciones de diagnóstico de Modbus.
Código Subfunción

Descripción

08

0x0000

Prueba de eco: La instrucción "MB_SERVER" recibe una palabra de datos y la devuelve inalte‐
rada al maestro Modbus.

08

0x000A

Inicializar el contador de eventos: La instrucción "MB_SERVER" inicializa el contador de eventos
de comunicación que se utiliza para la función Modbus 11.

11

-

Recoger contador de eventos de la comunicación: Durante la comunicación, la instrucción
"MB_SERVER" utiliza un contador de eventos interno para registrar el número de peticiones de
lectura y escritura correctas que se envían al servidor Modbus.
El contador de eventos no se incrementa en las funciones 8 y 11 ni en las peticiones de difusión
general. Lo mismo sucede con las peticiones que dan lugar a un error de comunicación (por
ejemplo en caso de errores de paridad o de CRC). La función de difusión general no está dis‐
ponible para Modbus TCP, ya que solo puede existir una conexión cliente/servidor al mismo
tiempo.

Variables estáticas de la instrucción
En la tabla siguiente se describen las variables estáticas del bloque de datos de instancia de
la instrucción MB_SERVER que se pueden utilizar en el programa. A la variable
HR_Start_Offset se puede acceder en escritu