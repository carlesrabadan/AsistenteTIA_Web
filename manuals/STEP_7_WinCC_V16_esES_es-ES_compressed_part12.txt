BOOL

TRUE

INT

2

INT

3

Variable del tipo de da‐
tos A <Tipo de datos
PLC>

Valor de la va‐
riable

1

RLO de la ins‐
trucción

BOOL

<Operando1>

1106

RLO de la ins‐
trucción

0

<Operando2>

RLO de la ins‐
trucción

VARIANT (recibe da‐ Valor de la varia‐
tos de la variable del ble
tipo de datos A)

1

BOOL

FALSE

BOOL

FALSE

INT

2

INT

2

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Igual":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, secuencias
de caracteres,
temporizadores,
fecha y hora,
ARRAY of <tipo de
datos> con límites
de ARRAY fijos y
variables,
STRUCT, VA‐
RIANT, ANY, tipo
de datos PLC

Primer valor de comparación

IN2

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, secuencias
de caracteres,
temporizadores,
fecha y hora,
ARRAY of <tipo de
datos> con límites
de ARRAY fijos y
variables,
STRUCT, VA‐
RIANT, ANY, tipo
de datos PLC

Segundo valor de compara‐
ción

Como se ha descrito anteriormente, los tipos de datos ARRAY, STRUCT (dentro de un tipo de datos
PLC), VARIANT, ANY y el tipo de datos PLC (UDT) están disponibles a partir de las versiones de
firmware 2.0 y 4.2, respectivamente.

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
,17
ಯ7DJB9DOXHಯ
ಯ7DJB9DOXHಯ

,1
,1

ಯ7DJ,QBಯ

ಯ7DJ2XWಯ
6

La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● El operando "TagIn_1" devuelve el estado lógico "1".
● Se cumple la condición de la instrucción de comparación cuando "Tag_Value1" =
"Tag_Value2".

Programación del PLC
Manual de programación y manejo, 11/2019

1107

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

CMP <>: Diferente
Descripción
La instrucción "Diferente" permite consultar si el valor de la entrada IN1 es distinto al valor de
la entrada IN2.
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1". Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".
Si está activada la verificación CEI, los operandos que comparar deben ser del mismo tipo de
datos. Si no está activada la verificación CEI, el ancho de los operandos debe ser igual.

Comparación de números en coma flotante
Si desea comparar tipos de datos REAL o LREAL, utilice en lugar de la instrucción "CMP <>:
Diferente" la instrucción "OUT_RANGE: Valor fuera del rango".
Si se comparan números en coma flotante, los operandos que comparar deben ser del mismo
tipo de datos, independientemente del ajuste de la verificación CEI.
Los patrones de bits especiales de números en coma flotante no válidos (NaN) que se generan
en caso de resultados indefinidos (p. ej. raíz de -1) no pueden compararse. Es decir, si uno de
los dos operandos tiene el valor NaN, la instrucción "CMP <>: Diferente" da como resultado
FALSE.

Comparación de cadenas de caracteres
En una comparación de cadenas de caracteres, los distintos caracteres se comparan según su
codificación (p. ej. 'a' es mayor que 'A'). La comparación se realiza de izquierda a derecha. El
primer carácter diferente es el decisivo para el resultado de la comparación.
La tabla siguiente muestra ejemplos de comparación de cadenas de caracteres:
IN1

IN2

RLO de la instrucción

'AA'

'aa'

1

'Hello World'

'HelloWorld'

1

'AA'

'AA'

0

'aa'

'aaa'

1

También es posible comparar caracteres individuales de una cadena de caracteres. El número
del carácter que se va a comparar se indica entre corchetes al lado del nombre del operando.

1108

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si se indica "MyString[2]", se compara p. ej. el segundo carácter de la cadena de caracteres
"MyString".
Nota
El estado se sigue mostrando a pesar de que la instrucción está "inactiva"
En las condiciones citadas a continuación se aplica lo siguiente:
● Antes de la instrucción "CMP <>: Diferente" (con tipo de datos STRING, WSTRING o
VARIANT) se consulta una condición (p. ej. un contacto normalmente abierto) en el
segmento.
● "Activar observación" está activado.
● Un nuevo resultado de la condición vuelve a poner el segmento a FALSE. De este modo,
la instrucción "CMP <>: Diferente" está inactiva.
Resultado:
Para la instrucción "CMP <>: Diferente" (tipo de datos STRING, WSTRING o VARIANT) se
sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observación" o se desplaza a otro segmento, se mostrará
de nuevo el estado correcto de la instrucción "CMP <>: Diferente" (tipo de datos STRING,
WSTRING o VARIANT). La instrucción "CMP <>: Diferente" se muestra atenuada en el
segmento cuando está inactiva.

Comparación de tiempos, fecha y hora
Los patrones de bits de temporizadores, fechas y horas no válidos, p. ej.
DT#2015-13-33-25:62:99.999_999_999, no pueden compararse. Es decir, si uno de los dos
operandos tiene un valor no válido, la instrucción "CMP <>: Diferente" da como resultado
FALSE.
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Comparación de variables del tipo de datos WORD con variables del tipo de datos S5TIME
Cuando se compara una variable del tipo de datos WORD con una variable del tipo de datos
S5TIME, ambas variables se convierten al tipo de datos TIME. La variable WORD se interpreta
como un valor S5TIME. En caso de que no fuera posible convertir una de las dos variables, la
comparación no se realizará y el resultado será FALSE. Si la conversión es correcta, la
comparación se realizará en función de la instrucción de comparación seleccionada.

Programación del PLC
Manual de programación y manejo, 11/2019

1109

Instrucciones
4.1 Instrucciones

Comparación de tipos de datos de hardware
Para poder comparar operandos del tipo de datos PORT con la instrucción "Diferente", deberá
seleccionar el tipo de datos WORD en la lista desplegable del cuadro de la instrucción.
Si desea comparar los dos tipos de datos de hardware HW_IO y HW_DEVICE, primero deberá
crear una variable del tipo de datos HW_ANY en la sección "Temp" de la interfaz del bloque y
después copiar el LADDR (del tipo de datos HW_DEVICE) a la variable. A continuación se
pueden comparar HW_ANY y HW_IO.

Comparación de estructuras
Nota
Disponibilidad de la comparación de estructuras
La posibilidad de comparar estructuras está disponible en las CPU de la serie S7-1200 a partir
de la versión de firmware >= 4.2 y en las CPU de la serie S7-1500 a partir de la versión de
firmware >= 2.0.
Es posible comparar entre sí los valores de dos operandos estructurados cuando las dos
variables tienen el mismo tipo de datos de estructura. Si se comparan estructuras, los
operandos que comparar deben ser del mismo tipo de datos, independientemente del ajuste
de la verificación CEI. Esto no es aplicable a comparaciones en las que uno de los dos
operandos es un VARIANT o un ANY. Si el tipo de datos se desconoce en el momento de crear
el programa, puede emplearse VARIANT. En este caso, será posible también comparar el
operando con una variable estructurada de cualquier tipo de datos. También pueden
compararse entre sí dos variables del tipo de datos VARIANT o ANY.
Para comparar estructuras, seleccione el tipo de datos VARIANT en la lista desplegable del
cuadro de la instrucción. Son posibles los siguientes tipos de datos:
● Tipo de datos PLC
● STRUCT (la estructura del tipo de datos STRUCT debe estar contenida en un tipo de datos
PLC (UDT) o las dos estructuras que van a compararse son dos elementos de un ARRAY
of STRUCT. No se permiten las estructuras anónimas.)
● Variable a la que apunta ANY.
● Variable a la que apunta VARIANT.
Para poder comparar entre sí dos variables del tipo de datos ARRAY cuando se selecciona
VARIANT, deben cumplirse los siguientes requisitos:
● Los elementos deben tener el mismo tipo de datos en cada caso.
● Los dos ARRAY deben tener la misma dimensión.
● Todas las dimensiones deben tener el mismo número de elementos. Los límites concretos
de ARRAY no tienen que coincidir necesariamente.

1110

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Nota
ARRAY of BOOL
Si se comparan entre sí dos operandos del tipo de datos ARRAY of BOOL, se ha seleccionado
el tipo de datos VARIANT en la lista desplegable y el número de elementos no es divisible entre
8, se comparan también los bits de relleno. Esto puede influir en el resultado de la comparación.
Si un elemento de las estructuras que desea comparar es un STRING/WSTRING no válido,
una indicación no válida de hora o fecha o bien un número en coma flotante no válido, el
resultado de la comparación devuelve el estado lógico "0" en RLO (resultado lógico).
La tabla siguiente muestra un ejemplo de comparación de estructuras:
<Operando1>
Variable del tipo de da‐
tos A <Tipo de datos
PLC>

<Operando2>
Valor de la va‐
riable

Variable del tipo de
datos A <Tipo de da‐
tos PLC>

RLO de la ins‐
trucción
Valor de la varia‐
ble

BOOL

FALSE

BOOL

FALSE

INT

2

INT

2

<Operando1>
Variable del tipo de da‐
tos A <Tipo de datos
PLC>

<Operando2>
Valor de la va‐
riable

Variable del tipo de
datos B <Tipo de da‐
tos PLC>

RLO de la ins‐
trucción
Valor de la varia‐
ble

BOOL

FALSE

BOOL

TRUE

INT

2

INT

3

<Operando1>
Variable del tipo de da‐
tos A <Tipo de datos
PLC>

Valor de la va‐
riable

1

<Operando2>

RLO de la ins‐
trucción

VARIANT (recibe da‐ Valor de la varia‐
tos de la variable del ble
tipo de datos A)

0

BOOL

FALSE

BOOL

FALSE

INT

2

INT

2

Programación del PLC
Manual de programación y manejo, 11/2019

0

1111

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Diferente":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, secuencias
de caracteres,
temporizadores,
fecha y hora,
ARRAY of <tipo de
datos> con límites
de ARRAY fijos y
variables,
STRUCT, VA‐
RIANT, ANY, tipo
de datos PLC

Primer valor de comparación

IN2

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, secuencias
de caracteres,
temporizadores,
fecha y hora,
ARRAY of <tipo de
datos> con límites
de ARRAY fijos y
variables,
STRUCT, VA‐
RIANT, ANY, tipo
de datos PLC

Segundo valor de compara‐
ción

Como se ha descrito anteriormente, los tipos de datos ARRAY, STRUCT (dentro de un tipo de datos
PLC), VARIANT, ANY y el tipo de datos PLC (UDT) están disponibles a partir de las versiones de
firmware 2.0 y 4.2, respectivamente.

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
!
,17
ಯ7DJB9DOXHಯ
ಯ7DJB9DOXHಯ

,1
,1

ಯ7DJ,QBಯ

ಯ7DJ2XWಯ
6

La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● El operando "TagIn_1" devuelve el estado lógico "1".
● Se cumple la condición de la instrucción de comparación cuando "Tag_Value1" <>
"Tag_Value2".

1112

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

CMP >=: Mayor o igual
Descripción
La instrucción "Mayor o igual" permite consultar si el valor de la entrada IN1 es mayor o igual
que el valor de la entrada IN2. Ambos valores de comparación deben ser del mismo tipo de
datos.
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1". Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".

Comparación de cadenas de caracteres
En una comparación de cadenas de caracteres, los distintos caracteres se comparan según su
codificación (p. ej. 'a' es mayor que 'A'). La comparación se realiza de izquierda a derecha. El
primer carácter diferente es el decisivo para el resultado de la comparación. Si la parte
izquierda de la cadena de caracteres más larga es idéntica a la cadena de caracteres más
corta, la más larga se considera la mayor de ellas.
La tabla siguiente muestra ejemplos de comparación de cadenas de caracteres:
IN1

IN2

RLO de la instrucción

'BB'

'AA'

1

'AAA'

'AA'

1

'Hello World'

'Hello World'

1

'Hello World'

'HelloWorld'

0

'AA'

'aa'

0

'AAA'

'a'

0

También es posible comparar caracteres individuales de una cadena de caracteres. El número
del carácter que se va a comparar se indica entre corchetes al lado del nombre del operando.

Programación del PLC
Manual de programación y manejo, 11/2019

1113

Instrucciones
4.1 Instrucciones
Si se indica "MyString[2]", se compara p. ej. el segundo carácter de la cadena de caracteres
"MyString".
Nota
El estado se sigue mostrando a pesar de que la instrucción está "inactiva"
En las condiciones citadas a continuación se aplica lo siguiente:
● Antes de la instrucción "CMP >=: Mayor o igual" (con tipo de datos STRING, WSTRING o
VARIANT) se consulta una condición (p. ej. un contacto normalmente abierto) en el
segmento.
● "Activar observación" está activado.
● Un nuevo resultado de la condición vuelve a poner el segmento a FALSE. De este modo,
la instrucción "CMP >=: Mayor o igual" está inactiva.
Resultado:
Para la instrucción "CMP >=: Mayor o igual" (tipo de datos STRING, WSTRING o VARIANT)
se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observación" o se desplaza a otro segmento, se mostrará
de nuevo el estado correcto de la instrucción "CMP >=: Mayor o igual" (tipo de datos STRING,
WSTRING o VARIANT). La instrucción "CMP >=: Mayor o igual" se muestra atenuada en el
segmento cuando está inactiva.

Comparación de tiempos, fecha y hora
Al comparar valores de tiempo, el RLO de la instrucción es "1" si el instante de la entrada IN1
es mayor (más reciente) o igual que el instante de la entrada IN2.
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Comparación de variables del tipo de datos WORD con variables del tipo de datos S5TIME
Cuando se compara una variable del tipo de datos WORD con una variable del tipo de datos
S5TIME, ambas variables se convierten al tipo de datos TIME. La variable WORD se interpreta
como un valor S5TIME. En caso de que no fuera posible convertir una de las dos variables, la
comparación no se realizará y el resultado será FALSE. Si la conversión es correcta, la
comparación se realizará en función de la instrucción de comparación seleccionada.

1114

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Mayor o igual":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, secuencias
de caracteres,
temporizadores,
fecha y hora

Primer valor de comparación

IN2

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, secuencias
de caracteres,
temporizadores,
fecha y hora

Segundo valor de compara‐
ción

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
!
,17
ಯ7DJB9DOXHಯ
ಯ7DJB9DOXHಯ

,1
,1

ಯ7DJ,QBಯ

ಯ7DJ2XWಯ
6

La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● El operando "TagIn_1" devuelve el estado lógico "1".
● Se cumple la condición de la instrucción de comparación cuando "Tag_Value1" >=
"Tag_Value2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Ejemplo de detección del nivel de llenado de una zona de almacén (Página 8054)
Ejemplos de programación FUP (Página 8050)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1115

Instrucciones
4.1 Instrucciones

CMP <=: Menor o igual
Descripción
La instrucción "Menor o igual" permite consultar si el valor de la entrada IN1 es menor o igual
que el valor de la entrada IN2. Ambos valores de comparación deben ser del mismo tipo de
datos.
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1". Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".

Comparación de cadenas de caracteres
En una comparación de cadenas de caracteres, los distintos caracteres se comparan según su
codificación (p. ej. 'a' es mayor que 'A'). La comparación se realiza de izquierda a derecha. El
primer carácter diferente es el decisivo para el resultado de la comparación. Si la parte
izquierda de la cadena de caracteres más larga es idéntica a la cadena de caracteres más
corta, la más corta se considera la menor de ellas.
La tabla siguiente muestra ejemplos de comparación de cadenas de caracteres:
IN1

IN2

RLO de la instrucción

'AA'

'aa'

1

'AAA'

'a'

1

'Hello World'

'Hello World'

1

'HelloWorld'

'Hello World'

0

'BB'

'AA'

0

'AAA'

'AA'

0

También es posible comparar caracteres individuales de una cadena de caracteres. El número
del carácter que se va a comparar se indica entre corchetes al lado del nombre del operando.

1116

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si se indica "MyString[2]", se compara p. ej. el segundo carácter de la cadena de caracteres
"MyString".
Nota
El estado se sigue mostrando a pesar de que la instrucción está "inactiva"
En las condiciones citadas a continuación se aplica lo siguiente:
● Antes de la instrucción "CMP <=: Menor o igual" (con tipo de datos STRING, WSTRING o
VARIANT) se consulta una condición (p. ej. un contacto normalmente abierto) en el
segmento.
● "Activar observación" está activado.
● Un nuevo resultado de la condición vuelve a poner el segmento a FALSE. De este modo,
la instrucción "CMP <=: Menor o igual" está inactiva.
Resultado:
Para la instrucción "CMP <=: Menor o igual" (tipo de datos STRING, WSTRING o VARIANT)
se sigue mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observación" o se desplaza a otro segmento, se mostrará
de nuevo el estado correcto de la instrucción "CMP <=: Menor o igual" (tipo de datos STRING,
WSTRING o VARIANT). La instrucción "CMP <=: Menor o igual" se muestra atenuada en el
segmento cuando está inactiva.

Comparación de tiempos, fecha y hora
Al comparar valores de tiempo, el RLO de la instrucción es "1" si el instante de la entrada IN1
es menor (más antiguo) o igual que el instante de la entrada IN2.
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Comparación de variables del tipo de datos WORD con variables del tipo de datos S5TIME
Cuando se compara una variable del tipo de datos WORD con una variable del tipo de datos
S5TIME, ambas variables se convierten al tipo de datos TIME. La variable WORD se interpreta
como un valor S5TIME. En caso de que no fuera posible convertir una de las dos variables, la
comparación no se realizará y el resultado será FALSE. Si la conversión es correcta, la
comparación se realizará en función de la instrucción de comparación seleccionada.

Programación del PLC
Manual de programación y manejo, 11/2019

1117

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Menor o igual":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, secuencias
de caracteres,
temporizadores,
fecha y hora

Primer valor de comparación

IN2

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, secuencias
de caracteres,
temporizadores,
fecha y hora

Segundo valor de compara‐
ción

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

,17
ಯ7DJB9DOXHಯ
ಯ7DJB9DOXHಯ

,1
,1

ಯ7DJ,QBಯ

ಯ7DJ2XWಯ
6

La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● El operando "TagIn_1" devuelve el estado lógico "1".
● Se cumple la condición de la instrucción de comparación cuando "Tag_Value1" <=
"Tag_Value2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

CMP >: Mayor
Descripción
La instrucción "Mayor" permite consultar si el valor de la entrada IN1 es mayor que el valor de
la entrada IN2. Ambos valores de comparación deben ser del mismo tipo de datos.

1118

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1". Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".

Comparación de cadenas de caracteres
En una comparación de cadenas de caracteres, los distintos caracteres se comparan según su
codificación (p. ej. 'a' es mayor que 'A'). La comparación se realiza de izquierda a derecha. El
primer carácter diferente es el decisivo para el resultado de la comparación. Si la parte
izquierda de la cadena de caracteres más larga es idéntica a la cadena de caracteres más
corta, la más larga se considera la mayor de ellas.
La tabla siguiente muestra ejemplos de comparación de cadenas de caracteres:
IN1

IN2

RLO de la instrucción

'BB'

'AA'

1

'AAA'

'AA'

1

'AA'

'aa'

0

'AAA'

'a'

0

También es posible comparar caracteres individuales de una cadena de caracteres. El número
del carácter que se va a comparar se indica entre corchetes al lado del nombre del operando.
Si se indica "MyString[2]", se compara p. ej. el segundo carácter de la cadena de caracteres
"MyString".
Nota
El estado se sigue mostrando a pesar de que la instrucción está "inactiva"
En las condiciones citadas a continuación se aplica lo siguiente:
● Antes de la instrucción "CMP >: Mayor" (con tipo de datos STRING, WSTRING o VARIANT)
se consulta una condición (p. ej. un contacto normalmente abierto) en el segmento.
● "Activar observación" está activado.
● Un nuevo resultado de la condición vuelve a poner el segmento a FALSE. De este modo,
la instrucción "CMP >: Mayor" está inactiva.
Resultado:
Para la instrucción "CMP >: Mayor" (tipo de datos STRING, WSTRING o VARIANT) se sigue
mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observación" o se desplaza a otro segmento, se mostrará
de nuevo el estado correcto de la instrucción "CMP >: Mayor" (tipo de datos STRING,
WSTRING o VARIANT). La instrucción "CMP >: Mayor" se muestra atenuada en el segmento
cuando está inactiva.

Comparación de tiempos, fecha y hora
Al comparar valores de tiempo, el RLO de la instrucción es "1" si el instante de la entrada IN1
es mayor (más reciente) que el instante de la entrada IN2.
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.

Programación del PLC
Manual de programación y manejo, 11/2019

1119

Instrucciones
4.1 Instrucciones
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Comparación de variables del tipo de datos WORD con variables del tipo de datos S5TIME
Cuando se compara una variable del tipo de datos WORD con una variable del tipo de datos
S5TIME, ambas variables se convierten al tipo de datos TIME. La variable WORD se interpreta
como un valor S5TIME. En caso de que no fuera posible convertir una de las dos variables, la
comparación no se realizará y el resultado será FALSE. Si la conversión es correcta, la
comparación se realizará en función de la instrucción de comparación seleccionada.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Mayor":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

Secuencias de
I, Q, M, D, L, P o
bits, enteros, nú‐
constante
meros en coma flo‐
tante, secuencias
de caracteres,
temporizadores,
fecha y hora

Primer valor de comparación

IN2

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, secuencias
de caracteres,
temporizadores,
fecha y hora

Segundo valor de compara‐
ción

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
!
,17
ಯ7DJB9DOXHಯ
ಯ7DJB9DOXHಯ

1120

,1
,1

ಯ7DJ,QBಯ

ಯ7DJ2XWಯ
6

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● El operando "TagIn_1" devuelve el estado lógico "1".
● Se cumple la condición de la instrucción de comparación cuando "Tag_Value1" >
"Tag_Value2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

CMP <: Menor
Descripción
La instrucción "Menor" permite consultar si el valor de la entrada IN1 es menor que el valor de
la entrada IN2. Ambos valores de comparación deben ser del mismo tipo de datos.
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1". Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".

Comparación de cadenas de caracteres
En una comparación de cadenas de caracteres, los distintos caracteres se comparan según su
codificación (p. ej. 'a' es mayor que 'A'). La comparación se realiza de izquierda a derecha. El
primer carácter diferente es el decisivo para el resultado de la comparación. Si la parte
izquierda de la cadena de caracteres más larga es idéntica a la cadena de caracteres más
corta, la más corta se considera la menor de ellas.
La tabla siguiente muestra ejemplos de comparación de cadenas de caracteres:
<Operando1>

<Operando2>

RLO de la instrucción

'AA'

'aa'

1

'AAA'

'a'

1

'BB'

'AA'

0

'AAA'

'AA'

0

También es posible comparar caracteres individuales de una cadena de caracteres. El número
del carácter que se va a comparar se indica entre corchetes al lado del nombre del operando.

Programación del PLC
Manual de programación y manejo, 11/2019

1121

Instrucciones
4.1 Instrucciones
Si se indica "MyString[2]", se compara p. ej. el segundo carácter de la cadena de caracteres
"MyString".
Nota
El estado se sigue mostrando a pesar de que la instrucción está "inactiva"
En las condiciones citadas a continuación se aplica lo siguiente:
● Antes de la instrucción "CMP <: Menor" (con tipo de datos STRING, WSTRING o VARIANT)
se consulta una condición (p. ej. un contacto normalmente abierto) en el segmento.
● "Activar observación" está activado.
● Un nuevo resultado de la condición vuelve a poner el segmento a FALSE. De este modo,
la instrucción "CMP <: Menor" está inactiva.
Resultado:
Para la instrucción "CMP <: Menor" (tipo de datos STRING, WSTRING o VARIANT) se sigue
mostrando el estado anterior en el segmento.
Si se desactiva y vuelve a activar la "observación" o se desplaza a otro segmento, se mostrará
de nuevo el estado correcto de la instrucción "CMP <: Menor" (tipo de datos STRING,
WSTRING o VARIANT). La instrucción "CMP <: Menor" se muestra atenuada en el segmento
cuando está inactiva.

Comparación de tiempos, fecha y hora
Al comparar valores de tiempo, el RLO de la instrucción es "1" si el instante de la entrada IN1
es menor (más antiguo) que el instante de la entrada IN2.
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Comparación de variables del tipo de datos WORD con variables del tipo de datos S5TIME
Cuando se compara una variable del tipo de datos WORD con una variable del tipo de datos
S5TIME, ambas variables se convierten al tipo de datos TIME. La variable WORD se interpreta
como un valor S5TIME. En caso de que no fuera posible convertir una de las dos variables, la
comparación no se realizará y el resultado será FALSE. Si la conversión es correcta, la
comparación se realizará en función de la instrucción de comparación seleccionada.

1122

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Menor":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, secuencias
de caracteres,
temporizadores,
fecha y hora

Primer valor de comparación

IN2

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, secuencias
de caracteres,
temporizadores,
fecha y hora

Segundo valor de compara‐
ción

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

,17
ಯ7DJB9DOXHಯ
ಯ7DJB9DOXHಯ

,1
,1

ಯ7DJ,QBಯ

ಯ7DJ2XWಯ
6

La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● El operando "TagIn_1" devuelve el estado lógico "1".
● Se cumple la condición de la instrucción de comparación cuando "Tag_Value1" <
"Tag_Value2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Ejemplo de detección del nivel de llenado de una zona de almacén (Página 8054)
Ejemplos de programación FUP (Página 8050)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1123

Instrucciones
4.1 Instrucciones

IN_RANGE: Valor dentro del rango
Descripción
La instrucción "Valor dentro del rango" permite consultar si el valor de la entrada VAL está
dentro de un determinado rango de valores.
Los límites del rango de valores se determinan mediante las entradas MIN y MAX. La
instrucción "Valor dentro del rango" compara el valor de la entrada VAL con los valores de las
entradas MIN y MAX y transfiere el resultado a la salida del cuadro. Si el valor de la entrada
VAL cumple la comparación MIN <= VAL o VAL <= MAX, la salida del cuadro devuelve el
estado lógico "1". Si no se cumple la comparación, la salida del cuadro devuelve el estado
lógico "0".
Para ejecutar la función de comparación es necesario que los valores que deben compararse
sean del mismo tipo de datos.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Valor dentro del rango":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MIN

Input

Enteros, números
en coma flotante

I, Q, M, D, L o
constante

Límite inferior del rango de
valores

VAL

Input

Enteros, números
en coma flotante

I, Q, M, D, L o
constante

Valor de comparación

MAX

Input

Enteros, números
en coma flotante

I, Q, M, D, L o
constante

Límite superior del rango de
valores

Salida del
cuadro

Output

BOOL

I, Q, M, D, L

Resultado de la comparación

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ7DJ,QBಯ

! 

ಯ7DJ,QBಯ
ಯ7DJ,QBಯ
,1B5$1*(
5($/
ಯ7DJB0LQಯ
ಯ7DJB9DOXHಯ
ಯ7DJB0D[ಯ

1124

0,1
9$/
0$;

ಯ7DJ2XWಯ

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● Los operandos "TagIn_1" o "TagIn_2" devuelven el estado lógico "1".
● El operando "TagIn_3" devuelve el estado lógico "1".
● El valor del operando "Tag_Value" está dentro del rango de valores especificado por los
valores actuales de los operandos "Tag_Min" y "Tag_Max" (MIN <= VAL o VAL <= MAX).

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

OUT_RANGE: Valor fuera del rango
Descripción
La instrucción "Valor fuera del rango" permite consultar si el valor de la entrada VAL está fuera
de un determinado rango de valores.
Los límites del rango de valores se determinan mediante las entradas MIN y MAX. La
instrucción "Valor fuera del rango" compara el valor de la entrada VAL con los valores de las
entradas MIN y MAX y transfiere el resultado a la salida del cuadro. Si el valor de la entrada
VAL cumple la comparación MIN > VAL o VAL > MAX, la salida del cuadro devuelve el estado
lógico "1". La salida del cuadro también devuelve el estado lógico "1" si un operando indicado
del tipo de datos REAL contiene un valor no válido.
La salida del cuadro devuelve el estado lógico "0" si el valor de la entrada VAL no cumple la
condición MIN > VAL o VAL > MAX.
Para ejecutar la función de comparación es necesario que los valores que deben compararse
sean del mismo tipo de datos.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Valor fuera del rango":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MIN

Input

Enteros, números
en coma flotante

I, Q, M, D, L o
constante

Límite inferior del rango de
valores

VAL

Input

Enteros, números
en coma flotante

I, Q, M, D, L o
constante

Valor de comparación

MAX

Input

Enteros, números
en coma flotante

I, Q, M, D, L o
constante

Límite superior del rango de
valores

Salida del
cuadro

Output

BOOL

I, Q, M, D, L

Resultado de la comparación

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1125

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ7DJ,QBಯ

! 

ಯ7DJ,QBಯ
ಯ7DJ,QBಯ
287B5$1*(
5($/
ಯ7DJB0LQಯ
ಯ7DJB9DOXHಯ
ಯ7DJB0D[ಯ

0,1
9$/
0$;

ಯ7DJ2XWಯ

La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● Los operandos "TagIn_1" y "TagIn_2" devuelven el estado lógico "1".
● El operando "TagIn_3" devuelve el estado lógico "1".
● El valor del operando "Tag_Value" está fuera del rango de valores especificado por los
valores de los operandos "Tag_Min" y "Tag_Max" (MIN > VAL o VAL > MAX).

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

OK: Comprobar validez
Descripción
La instrucción "Comprobar validez" permite consultar si el valor de un operando (<Operando>)
es un número en coma flotante válido. La verificación se realiza en cada ciclo del programa. Si
el valor del operando es un número en coma flotante válido cuando se realiza la consulta, la
salida del cuadro devuelve el estado lógico "1". En todos los demás casos, el estado lógico de
la salida de la instrucción "Comprobar validez" es "0".
La instrucción "Comprobar validez" puede utilizarse en combinación con el mecanismo EN. Si
el cuadro de la instrucción se conecta a una entrada de habilitación EN, ésta se activa
únicamente si la consulta de la validez del valor da un resultado positivo. Esta función garantiza
que una instrucción se active sólo si el valor del operando indicado es un número en coma
flotante válido.

1126

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
El ejemplo siguiente muestra el funcionamiento de la instrucción "Comprobar validez":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L

Valor que se comprueba.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ7DJB9DOXHಯ
2.
ಯ7DJB9DOXHಯ
2.

08/
5($/
(1

ಯ7DJB9DOXHಯ

,1

287

ಯ7DJB9DOXHಯ

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

Si los valores de los operandos "Tag_Value1" y "Tag_Value2" contienen números en coma
flotante válidos, se ejecuta la instrucción "Multiplicar". El valor del operando "Tag_Value1" se
multiplica por el valor del operando "Tag_Value2". El resultado de la multiplicación se escribe
seguidamente en el operando "Tag_Result". Si no se producen errores al ejecutar la
instrucción, el operando "TagOut" adopta el estado lógico "1" en la salida de habilitación ENO.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

NOT_OK: Comprobar invalidez
Descripción
La instrucción "Comprobar invalidez" permite consultar si el valor de un operando
(<Operando>) es un número en coma flotante no válido. La verificación se realiza en cada ciclo
del programa. Si el valor del operando es un número en coma flotante no válido cuando se
realiza la consulta, la salida del cuadro devuelve el estado lógico "1". En los restantes casos,
el estado lógico de la salida del cuadro es "0".

Programación del PLC
Manual de programación y manejo, 11/2019

1127

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Comprobar invalidez":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

Números en coma
flotante

I, Q, M, D, L

Valor que se comprueba.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ7DJ,QB9DOXHಯ
127B2.

029(
(1

287

,1

(12

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

ಯ7DJ,QB9DOXHಯ

Si el valor del operando "TagIn_Value" no es un número en coma flotante válido, no se ejecuta
la instrucción "Copiar valor". El operando "TagOut" adopta el estado lógico "0" en la salida de
habilitación ENO.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

VARIANT
EQ_Type: Comparar si el tipo de datos es IGUAL al tipo de datos de una variable
Descripción
Con la instrucción "Comparar si el tipo de datos es IGUAL al tipo de datos de una variable" se
consulta qué tipo de datos tiene una variable a la que apunta un VARIANT. El tipo de datos de
la variable del parámetro IN1, declarada en la interfaz del bloque, se compara con el tipo de
datos de la variable del parámetro IN2 para determinar si es "Igual".
La variable del parámetro IN1 tiene que ser del tipo de datos VARIANT. La variable del
parámetro IN2 puede ser un tipo de datos simple o un tipo de datos PLC.
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1". Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".

1128

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Comparación de tiempos, fecha y hora
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Comparación de estructuras
Para comparar estructuras está disponible la instrucción "CMP ==". Por norma general no es
posible comparar estructuras anónimas, excepto cuando forman parte del mismo ARRAY.
Encontrará más información sobre la comparación de estructuras aquí: CMP ==: Igual
(Página 1103)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Comparar si el tipo de datos es
IGUAL al tipo de datos de una variable":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

Descripción

S7-1500

IN1

Input

VARIANT

L (puede declararse en las
secciones "Input", "InOut" y
"Temp" de la interfaz del blo‐
que.)

IN2

Input

I, Q, M, D, L
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, fecha y ho‐
ra, secuencias de
caracteres,
ARRAY, tipos de
datos PLC

I, Q, M, D, L,
P

Segundo operan‐
do

OUT

Output

BOOL

I, Q, M, D, L

Resultado de la
comparación

I, Q, M, D, L

Primer operando

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
(4B7\SH
7DJ

,1

ಯ7DJಯ

,1 287

Programación del PLC
Manual de programación y manejo, 11/2019

ಯ7DJ,Qಯ

ಯ7DJ2XWಯ
6

1129

Instrucciones
4.1 Instrucciones
La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● El operando "TagIn" devuelve el estado lógico "1".
● Se cumple la condición de la instrucción de comparación, es decir, el operando #Tag1 es
igual a "Tag2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

NE_Type: Comparar si el tipo de datos es DIFERENTE del tipo de datos de una variable
Descripción
Con la instrucción "Comparar si el tipo de datos es DIFERENTE del tipo de datos de una
variable" se consulta el tipo de datos que no tiene una variable a la que señala un VARIANT.
El tipo de datos de la variable del parámetro IN1, declarada en la interfaz del bloque, se
compara con el tipo de datos de la variable del parámetro IN2 para determinar si es "Diferente".
La variable del parámetro IN1 tiene que ser del tipo de datos VARIANT. La variable del
parámetro IN2 puede ser un tipo de datos simple o un tipo de datos PLC.
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1". Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".

Comparación de tiempos, fecha y hora
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Comparación de estructuras
Para comparar estructuras está disponible la instrucción "CMP <>". Por norma general no es
posible comparar estructuras anónimas, excepto cuando forman parte del mismo ARRAY.
Encontrará más información sobre la comparación de estructuras aquí: CMP <>: Diferente
(Página 1108)

1130

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Comparar si el tipo de datos es
DIFERENTE del tipo de datos de una variable":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

Descripción

S7-1500

IN1

Input

VARIANT

L (puede declararse en las
secciones "Input", "InOut" y
"Temp" de la interfaz del blo‐
que.)

IN2

Input

I, Q, M, D, L
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, fecha y ho‐
ra, secuencias de
caracteres,
ARRAY, tipos de
datos PLC

I, Q, M, D, L,
P

Segundo operan‐
do

OUT

Output

BOOL

I, Q, M, D, L

Resultado de la
comparación

I, Q, M, D, L

Primer operando

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
1(B7\SH
7DJ

,1

ಯ7DJಯ

,1 287

ಯ7DJ,Qಯ

ಯ7DJ2XWಯ
6

La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● El operando "TagIn" devuelve el estado lógico "1".
● Se cumple la condición de la instrucción de comparación, es decir, el operando #Tag1 es
diferente de "Tag2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1131

Instrucciones
4.1 Instrucciones

EQ_ElemType: Comparar si el tipo de datos de un elemento del ARRAY es IGUAL al tipo de datos de
una variable
Descripción
La instrucción "Comparar si el tipo de datos de un elemento del ARRAY es IGUAL al tipo de
datos de una variable" permite saber el tipo de datos que tiene una variable a la que apunta un
VARIANT. El tipo de datos de la variable del parámetro IN1, declarada en la interfaz del bloque,
se compara con el tipo de datos de la variable del parámetro IN2 para determinar si es "Igual".
La variable del parámetro IN1 tiene que ser del tipo de datos VARIANT. La variable del
parámetro IN2 puede ser un tipo de datos simple o un tipo de datos PLC.
Si el tipo de datos de la variable VARIANT es un ARRAY, se compara el tipo de datos de los
elementos del ARRAY.
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1". Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".

Comparación de tiempos, fecha y hora
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Comparación de estructuras
Para comparar estructuras está disponible la instrucción "CMP ==". Por norma general no es
posible comparar estructuras anónimas, excepto cuando forman parte del mismo ARRAY.
Encontrará más información sobre la comparación de estructuras aquí: CMP ==: Igual
(Página 1103)

1132

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Comparar si el tipo de datos de un
elemento del ARRAY es IGUAL al tipo de datos de una variable":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

Descripción

S7-1500

IN1

Input

VARIANT

L (puede declararse en las
secciones "Input", "InOut" y
"Temp" de la interfaz del blo‐
que.)

IN2

Input

I, Q, M, D, L
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, fecha y ho‐
ra, secuencias de
caracteres,
ARRAY, tipos de
datos PLC

I, Q, M, D, L,
P

Segundo operan‐
do

OUT

Output

BOOL

I, Q, M, D, L

Resultado de la
comparación

I, Q, M, D, L

Primer operando

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
(4B(OHP7\SH
7DJ

,1

ಯ7DJಯ

,1

287

ಯ7DJ,Qಯ

ಯ7DJ2XWಯ
6

La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● El operando "TagIn" devuelve el estado lógico "1".
● Se cumple la condición de la instrucción de comparación, es decir, el operando #Tag1 es
igual a "Tag2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1133

Instrucciones
4.1 Instrucciones

NE_ElemType: Comparar si el tipo de datos de un elemento de ARRAY es DIFERENTE del tipo de
datos de una variable
Descripción
La instrucción "Comparar si el tipo de datos de un elemento del ARRAY es DIFERENTE al tipo
de datos de una variable" permite saber qué tipo de datos no tiene una variable a la que apunta
un VARIANT. El tipo de datos de la variable del parámetro IN1, declarada en la interfaz del
bloque, se compara con el tipo de datos de la variable del parámetro IN2 para determinar si es
"Diferente".
La variable del parámetro IN1 tiene que ser del tipo de datos VARIANT. La variable del
parámetro IN2 puede ser un tipo de datos simple o un tipo de datos PLC.
Si el tipo de datos de la variable VARIANT es un ARRAY, se compara el tipo de datos de los
elementos del ARRAY.
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1". Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".

Comparación de tiempos, fecha y hora
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Comparación de estructuras
Para comparar estructuras está disponible la instrucción "CMP <>". Por norma general no es
posible comparar estructuras anónimas, excepto cuando forman parte del mismo ARRAY.
Encontrará más información sobre la comparación de estructuras aquí: CMP <>: Diferente
(Página 1108)

1134

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Comparar si el tipo de datos de un
elemento del ARRAY es DIFERENTE al tipo de datos de una variable":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

Descripción

S7-1500

IN1

Input

VARIANT

L (puede declararse en las
secciones "Input", "InOut" y
"Temp" de la interfaz del blo‐
que.)

IN2

Input

I, Q, M, D, L
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, fecha y ho‐
ra, secuencias de
caracteres,
ARRAY, tipos de
datos PLC

I, Q, M, D, L,
P

Segundo operan‐
do

OUT

Output

BOOL

I, Q, M, D, L

Resultado de la
comparación

I, Q, M, D, L

Primer operando

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
1(B(OHP7\SH
7DJ

,1

ಯ7DJಯ

,1

287

ಯ7DJ,Qಯ

ಯ7DJ2XWಯ
6

La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● El operando "TagIn" devuelve el estado lógico "1".
● Se cumple la condición de la instrucción de comparación, es decir, el operando #Tag1 es
diferente de "Tag2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

IS_NULL: Consultar si es un puntero IGUAL A CERO
Descripción
La instrucción "Consultar si es un puntero IGUAL A CERO" permite saber si VARIANT o la
referencia hace referencia a un puntero CERO y, por tanto, no apunta a un objeto.

Programación del PLC
Manual de programación y manejo, 11/2019

1135

Instrucciones
4.1 Instrucciones
El <operando> debe ser del tipo de datos VARIANT o REF_TO <tipo de datos>.
Nota
La variable VARIANT apunta a un puntero ANY
Si la variable VARIANT apunta a un puntero ANY, la instrucción devuelve siempre el resultado
RLO = "0" aunque el puntero ANY tenga el valor CERO.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar si es un puntero IGUAL
A CERO":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

VARIANT o
REF_TO <tipo de
datos>

L (puede declarar‐ Operando que se compara si
se en las seccio‐
es IGUAL A CERO
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

OUT

Output

BOOL

I, Q, M, D, L

Resultado de la comparación

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
7DJB2SHUDQG
,6B18//
287
ಯ7DJB,Qಯ

ಯ7DJ2XWಯ

ಯ7DJB,Qಯ

La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● Los operandos "Tag_In1" y "Tag_In2" devuelven el estado lógico "1".
● Se cumple la condición de la instrucción de comparación, es decir, el operando
#Tag_Operand no apunta a ningún objeto.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

1136

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

NOT_NULL: Consultar si es un puntero DIFERENTE DE CERO
Descripción
La instrucción "Consultar si es un puntero DIFERENTE DE CERO" permite saber si VARIANT
o la referencia no hace referencia a un puntero CERO y, por tanto, apunta a un objeto.
El <operando> debe ser del tipo de datos VARIANT o REF_TO <tipo de datos>.
Nota
La variable VARIANT apunta a un puntero ANY
Si la variable VARIANT apunta a un puntero ANY, la instrucción devuelve siempre el resultado
RLO = "1" aunque el puntero ANY tenga el valor CERO.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar si es un puntero
DIFERENTE DE CERO":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

VARIANT o
REF_TO <tipo de
datos>

L (puede declarar‐ Operando que se compara si
se en las seccio‐
es DIFERENTE DE CERO
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

OUT

Output

BOOL

I, Q, M, D, L

Resultado de la comparación

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
7DJB2SHUDQG
127B18//
287
ಯ7DJB,Qಯ

ಯ7DJ2XWಯ

ಯ7DJB,Qಯ

La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● Los operandos "Tag_In1" y "Tag_In2" devuelven el estado lógico "1".
● Se cumple la condición de la instrucción de comparación, es decir, el operando
#Tag_Operand apunta a un objeto.

Programación del PLC
Manual de programación y manejo, 11/2019

1137

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

IS_ARRAY: Consultar si es un ARRAY
Descripción
La instrucción "Consultar si es un ARRAY" permite saber si VARIANT apunta a una variable
del tipo de datos ARRAY.
El <operando> debe ser del tipo de datos VARIANT.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar si es un ARRAY":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

VARIANT

L (puede declarar‐ Operando que se consulta si
se en las seccio‐
es un ARRAY
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

OUT

Output

BOOL

I, Q, M, D, L

Resultado de la comparación

Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Nota
Consulta de un bloque de datos ARRAY
Si utiliza la instrucción IS_ARRAY en relación con un ArrayDB y genera el parámetro de
entrada VARIANT con DB_ANY_TO_VARIANT , en un punto cualquiera del programa deberá
utilizarse el ArrayDB en forma de símbolo como parámetro actual de un parámetro formal del
tipo de datos de datos VARIANT. Para que funcione correctamente es suficiente que se haya
descargado el lugar de uso. No es necesario que se ejecute.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
7DJB9$5,$17
7R$UUD\
,6B$55$<
287
ಯ7DJB,Qಯ

ಯ7DJ2XWಯ

ಯ7DJB,Qಯ

1138

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● Los operandos "Tag_In1" y "Tag_In2" devuelven el estado lógico "1".
● Se cumple la condición de la instrucción de comparación, es decir, el operando
#Tag_VARIANTToArray es del tipo de datos ARRAY.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

EQ_TypeOfDB: Comparación de igualdad entre un tipo de datos de un DB direccionado indirectamente
y un tipo de datos
Descripción
La instrucción "Comparación de igualdad entre un tipo de datos de un DB direccionado
indirectamente y un tipo de datos" sirve para consultar el tipo de datos que tiene el bloque de
datos direccionado por la variable del tipo de datos DB_ANY. Se compara el tipo de datos del
DB direccionado a través de la variable del parámetro IN1 con el tipo de datos de otra variable
o bien directamente con un tipo de datos en el parámetro IN2 para determinar si es "Igual".
La variable del parámetro IN1 debe ser del tipo de datos DB_ANY. La variable del parámetro
IN2 puede ser, p. ej., un tipo de datos PLC, un tipo de datos de sistema, un eje o un FB.
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1". Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

Descripción

S7-1500

IN1

Input

DB_ANY

L (puede declararse en las sec‐
ciones "Input", "InOut" y "Temp"
de la interfaz del bloque.)

Primer operan‐
do

IN2

Input

TYPE_ID

I, Q, M, D, L

I, Q, M, D, L, P Segundo ope‐
rando

OUT

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Resultado de
la comparación

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1139

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
(4B7\SH2I'%
,QSXW'%$Q\

,1

72B6SHHG$[LV

,1

ಯ7DJ,Qಯ

ಯ7DJ2XWಯ

287

6

La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● El operando "TagIn" devuelve el estado lógico "1".
● Se cumple la condición de la instrucción de comparación, es decir, el tipo de datos del DB
direccionado por el operando #InputDBAny es igual al tipo de datos TO_SpeedAxis.
La salida "TagOut" no se activa cuando se cumplen las condiciones siguientes:
● El número del bloque de datos es "0".
● El bloque de datos no existe.
● El bloque de datos es un DB de ARRAY.
● El bloque de datos contiene una variable del tipo de datos UDT (tipo de datos PLC).

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Uso del tipo de datos DB_ANY (Página 216)
Principios básicos de FUP (Página 8005)

NE_TypeOfDB: Comparación de desigualdad entre un tipo de datos de un DB direccionado
indirectamente y un tipo de datos
Descripción
La instrucción "Comparación de desigualdad entre un tipo de datos de un DB direccionado
indirectamente y un tipo de datos" sirve para consultar el tipo de datos que no tiene el bloque
de datos direccionado por la variable del tipo de datos DB_ANY. Se compara el tipo de datos
del DB direccionado a través de la variable del parámetro IN1 con el tipo de datos de otra
variable o bien directamente con el tipo de datos del parámetro IN2 para determinar si es
"Diferente".
La variable del parámetro IN1 debe ser del tipo de datos DB_ANY. La variable del parámetro
IN2 puede ser, p. ej., un tipo de datos PLC, un tipo de datos de sistema, un eje o un FB.
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1". Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".

1140

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

Descripción

S7-1500

IN1

Input

DB_ANY

L (puede declararse en las sec‐
ciones "Input", "InOut" y "Temp"
de la interfaz del bloque.)

Primer operan‐
do

IN2

Input

TYPE_ID

I, Q, M, D, L

I, Q, M, D, L, P Segundo ope‐
rando

OUT

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Resultado de
la comparación

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
1(B7\SH2I'%
,QSXW'%$Q\

,1

72B6SHHG$[LV

,1

ಯ7DJ,Qಯ

ಯ7DJ2XWಯ

287

6

La salida "TagOut" se activa cuando se cumplen las condiciones siguientes:
● El operando "TagIn" devuelve el estado lógico "1".
● Se cumple la condición de la instrucción de comparación, es decir, el tipo de datos del DB
direccionado por el operando #InputDBAny es diferente del tipo de datos TO_SpeedAxis.
La salida "TagOut" no se activa cuando se cumplen las condiciones siguientes:
● El número del bloque de datos es "0".
● El bloque de datos no existe.
● El bloque de datos es un DB de ARRAY.
● El bloque de datos contiene una variable del tipo de datos UDT (tipo de datos PLC).

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Uso del tipo de datos DB_ANY (Página 216)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1141

Instrucciones
4.1 Instrucciones

Funciones matemáticas
CALCULATE: Calcular
Descripción
La instrucción "Calcular" permite deifnir y ejecutar una expresión para calcular operaciones
matemáticas o combinaciones lógicas complejas en función del tipo de datos seleccionado.
El tipo de datos de la instrucción se selecciona en la lista desplegable "???" del cuadro de la
instrucción. Dependiendo del tipo de datos seleccionado se puede combinar la funcionalidad
de determinadas instrucciones para ejecutar un cálculo complejo. La expresión que debe
calcularse se indica en un cuadro de diálogo que se abre con el símbolo de "calculadora"
situado en el margen superior derecho del cuadro de la instrucción. La expresión puede
contener los nombres de los parámetros de entrada y la sintaxis de las instrucciones. No está
permitido indicar nombres o direcciones de operandos.
El cuadro de la instrucción contiene en estado básico al menos 2 entradas (IN1 e IN2). El
número de entradas es ampliable. Las entradas insertadas se numeran en orden ascendente
en el cuadro.
Los valores de las entradas se utilizan para ejecutar la expresión indicada. No obstante, no es
necesario utilizar en la expresión todas las entradas definidas. El resultado de la instrucción se
transfiere a la salida del cuadro OUT.
Nota
Cuando una de las operaciones matemáticas falla en la expresión, no se transfieren resultados
a la salida OUT y la salida de habilitación ENO devuelve el estado lógico "1".
Si en la expresión se utilizan entradas que no están disponibles en el cuadro, estas se insertan
automáticamente. Para ello, es indispensable que la numeración de las entradas nuevas que
deben definirse en la expresión no contenga huecos. Por ejemplo, es posible no utilizar la
entrada IN4 en la expresión si la entrada IN3 no está definida.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El resultado final o intermedio de la instrucción "Calcular" está fuera del rango permitido
para el tipo de datos indicado en la salida OUT.
● Un número en coma flotante tiene un valor no válido.
● Se ha producido un error al ejecutar una de las instrucciones indicadas en la expresión.

1142

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra las instrucciones que pueden combinarse y ejecutarse en la
expresión de la instrucción "Calcular" en función del tipo de datos seleccionado:
Tipo de datos

Instrucción

Secuencias de bits AND: Operación lógica Y

Enteros

Números en coma
flotante

Sintaxis

Ejemplo

AND

IN1 AND IN2 OR
IN3

OR: Operación lógica O

OR

XOR: Operación lógica O-exclusiva

XOR

INV: Generar complemento a 1

NOT

SWAP: Cambiar disposición

SWAP

1)

ADD: Sumar

+

(IN1 + IN2) * IN3;

SUB: Restar

-

MUL: Multiplicar

*

(ABS(IN2)) *
(ABS(IN1))

DIV: Dividir

/

MOD: Obtener resto de división

MOD

INV: Generar complemento a 1

NOT

NEG: Generar complemento a dos

-(in1)

ABS: Calcular valor absoluto

ABS( )

ADD: Sumar

+

SUB: Restar

-

MUL: Multiplicar

*

DIV: Dividir

/

EXPT: Elevar a potencia

**

ABS: Calcular valor absoluto

ABS( )

SQR: Calcular cuadrado

SQR( )

SQRT: Calcular raíz cuadrada

SQRT( )

LN: Calcular logaritmo natural

LN( )

EXP: Calcular valor exponencial

EXP( )

FRAC: Determinar decimales

FRAC( )

SIN: Calcular valor de seno

SIN( )

COS: Calcular valor de coseno

COS( )

TAN: Calcular valor de tangente

TAN( )

ASIN: Calcular valor de arcoseno

ASIN( )

ACOS: Calcular valor de arcocoseno

ACOS( )

ATAN: Calcular valor de arcotangente

ATAN( )

NEG: Generar complemento a dos

-(in1)

TRUNC: Truncar a entero

TRUNC( )

ROUND: Redondear número

ROUND( )

((SIN(IN2) *
SIN(IN2) +
(SIN(IN3) *
SIN(IN3)) / IN3));
(SQR(SIN(IN2))
+
(SQR(COS(IN3))
/ IN2))

CEIL: Redondear número en coma flotan‐ CEIL( )
te al siguiente entero superior
FLOOR: Redondear número en coma flo‐ FLOOR( )
tante al siguiente entero inferior
1)

No es posible para el tipo de datos BYTE.

Programación del PLC
Manual de programación y manejo, 11/2019

1143

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Calcular":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

Descripción

S7-1500

EN

Input

BOOL

I, Q, M, D, L o I, Q, M, D,
constante
L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

IN1

Input

I, Q, M, D, L,
Secuencias de
bits, enteros, nú‐ P o constan‐
meros en coma te
flotante

I, Q, M, D,
Primera entrada dispo‐
L, P o cons‐ nible
tante

IN2

Input

I, Q, M, D, L,
Secuencias de
bits, enteros, nú‐ P o constan‐
meros en coma te
flotante

I, Q, M, D,
Segunda entrada dis‐
L, P o cons‐ ponible
tante

INn

Input

I, Q, M, D, L,
Secuencias de
bits, enteros, nú‐ P o constan‐
meros en coma te
flotante

I, Q, M, D,
Entradas insertadas
L, P o cons‐ adicionalmente
tante

OUT

Output

I, Q, M, D, L,
Secuencias de
bits, enteros, nú‐ P
meros en coma
flotante

I, Q, M, D,
L, P

I, Q, M, D, L Salida de habilitación

Salida a la que se
transfiere el resultado
final.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
&$/&8/$7(
,17
ಯ7DJB,QSXWಯ

(1
287

,1,1 ,1 ,1

ಯ7DJB9DOXHBಯ

,1

ಯ7DJB9DOXHBಯ

,1

ಯ7DJB9DOXHBಯ

,1

287

ಯ7DJB9DOXHBಯ

,1

(12

ಯ7DJB5HVXOWಯ

ಯ7DJB2XWSXWಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:

1144

Parámetro

Operando

Valor

IN1

Tag_Value_1

4

IN2

Tag_Value_2

4

IN3

Tag_Value_3

3

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Operando

Valor

IN4

Tag_Value_4

2

OUT

Tag_Result

12

Si la entrada "Tag_Input" devuelve el estado lógico "1", se ejecuta la instrucción. El valor del
operando "Tag_Value_1" se suma al valor del operando "Tag_Value_2". La suma se multiplica
por el valor del operando "Tag_Value_3". El producto se divide por el valor del operando
"Tag_Value_4". El cociente se transfiere como resultado final al operando "Tag_Result" de la
salida OUT de la instrucción. Si no ocurren errores al ejecutar las distintas instrucciones, la
salida de habilitación ENO y el operando "Tag_Output" se ponen a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Ejemplo de cálculo de una ecuación (Página 8058)
Principios básicos de FUP (Página 8005)

ADD: Sumar
Descripción
La instrucción "Sumar" permite sumar el valor de la entrada IN1 al valor de la entrada IN2 y
consultar la suma en la salida OUT (OUT := IN1+IN2).
El cuadro de la instrucción contiene en estado estacionario mín. 2 entradas (IN1 e IN2). El
número de entradas es ampliable. Las entradas insertadas se numeran en orden ascendente
en el cuadro. Al ejecutar la instrucción se suman los valores de todos los parámetros de
entrada disponibles. La suma se guarda en la salida OUT.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El resultado de la instrucción está fuera del rango permitido para el tipo de datos indicado
en la salida OUT.
● Un número en coma flotante tiene un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Sumar":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500
I, Q, M, D, L,
T, C o cons‐
tante

EN

Input

BOOL

I, Q, M, D, L
o constante

ENO

Output

BOOL

I, Q, M, D, L I, Q, M, D, L

Programación del PLC
Manual de programación y manejo, 11/2019

Descripción
Entrada de habilita‐
ción
Salida de habilitación

1145

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

Descripción

S7-1500

IN1

Input

Enteros, números
en coma flotante

I, Q, M, D,
I, Q, M, D, L, Primer sumando
L, P o cons‐ P o constan‐
tante
te

IN2

Input

Enteros, números
en coma flotante

I, Q, M, D,
I, Q, M, D, L, Segundo sumando
L, P o cons‐ P o constan‐
tante
te

INn

Input

Enteros, números
en coma flotante

I, Q, M, D,
I, Q, M, D, L, Valores de entrada
L, P o cons‐ P o constan‐ opcionales que se
tante
te
suman.

OUT

Output

Enteros, números
en coma flotante

I, Q, M, D,
L, P

I, Q, M, D, L,
P

Suma

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
$''
,17

ಯ7DJ,Qಯ

(1

ಯ7DJB9DOXHಯ

,1

287

ಯ7DJB9DOXHಯ

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El valor del
operando "Tag_Value1" se suma al valor del operando "Tag_Value2". El resultado de la suma
se almacena en el operando "Tag_Result". Si no ocurren errores al ejecutar la instrucción, la
salida de habilitación ENO devuelve el estado lógico "1" y se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

SUB: Restar
Descripción
La instrucción "Restar" permite restar el valor de la entrada IN2 al valor de la entrada IN1 y
consultar el resultado en la salida OUT (OUT := IN1-IN2).

1146

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El resultado de la instrucción está fuera del rango permitido para el tipo de datos indicado
en la salida OUT.
● Un número en coma flotante tiene un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Restar":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500
I, Q, M, D, L,
T, C o cons‐
tante

Descripción

EN

Input

BOOL

I, Q, M, D, L
o constante

ENO

Output

BOOL

I, Q, M, D, L I, Q, M, D, L

Salida de habilita‐
ción

IN1

Input

Enteros, números
en coma flotante

I, Q, M, D,
I, Q, M, D, L,
L, P o cons‐ P o constan‐
tante
te

Minuendo

IN2

Input

Enteros, números
en coma flotante

I, Q, M, D,
I, Q, M, D, L,
L, P o cons‐ P o constan‐
tante
te

Sustraendo

OUT

Output

Enteros, números
en coma flotante

I, Q, M, D,
L, P

Diferencia

I, Q, M, D, L,
P

Entrada de habilita‐
ción

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
68%
,17

ಯ7DJ,Qಯ

(1

ಯ7DJB9DOXHಯ

,1

287

ಯ7DJB9DOXHಯ

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El valor del
operando "Tag_Value2" se resta del valor del operando "Tag_Value1". El resultado de la resta
se almacena en el operando "Tag_Result". Si no ocurren errores al ejecutar la instrucción, la
salida de habilitación ENO devuelve el estado lógico "1" y se activa la salida "TagOut".

Programación del PLC
Manual de programación y manejo, 11/2019

1147

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

MUL: Multiplicar
Descripción
La instrucción "Multiplicar" permite multiplicar el valor de la entrada IN1 con el valor de la
entrada IN2 y consultar el producto en la salida OUT (OUT := IN1*IN2).
El cuadro de la instrucción contiene en estado estacionario mín. 2 entradas (IN1 e IN2). El
número de entradas es ampliable. Las entradas insertadas se numeran en orden ascendente
en el cuadro. Al ejecutar la instrucción se multiplican los valores de todos los parámetros de
entrada disponibles. El producto se guarda en la salida OUT.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El resultado está fuera del rango permitido para el tipo de datos indicado en la salida OUT.
● Un número en coma flotante tiene un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Multiplicar":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

EN

Input

BOOL

Descripción

S7-1500

I, Q, M, D, L I, Q, M, D, L, Entrada de habilita‐
o constante T, C o cons‐ ción
tante

ENO

Output

BOOL

I, Q, M, D, L I, Q, M, D, L Salida de habilitación

IN1

Input

Enteros, números
en coma flotante

I, Q, M, D, I, Q, M, D, L, Multiplicando
L, P o cons‐ P o constan‐
tante
te

IN2

Input

Enteros, números
en coma flotante

I, Q, M, D, I, Q, M, D, L, Multiplicador
L, P o cons‐ P o constan‐
tante
te

INn

Input

Enteros, números
en coma flotante

I, Q, M, D, I, Q, M, D, L, Valores de entrada
L, P o cons‐ P o constan‐ opcionales que se
tante
te
multiplican.

OUT

Output

Enteros, números
en coma flotante

I, Q, M, D,
L, P

I, Q, M, D, L, Producto
P

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.

1148

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
08/
5($/

ಯ7DJ,Qಯ

(1

ಯ7DJB9DOXHಯ

,1

287

ಯ7DJB9DOXHಯ

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ
6

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El valor del
operando "Tag_Value1" se multiplica por el valor del operando "Tag_Value2". El resultado de
la multiplicación se almacena en el operando "Tag_Result". Si no ocurren errores al ejecutar
la instrucción, la salida de habilitación ENO devuelve el estado lógico "1" y se activa la salida
"TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

DIV: Dividir
Descripción
La instrucción "Dividir" permite dividir el valor de la entrada IN1 por el valor de la entrada IN2
y consultar el cociente en la salida OUT (OUT := IN1/IN2).
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El resultado de la instrucción está fuera del rango permitido para el tipo de datos indicado
en la salida OUT.
● Un número en coma flotante tiene un valor no válido.

Programación del PLC
Manual de programación y manejo, 11/2019

1149

Instrucciones
4.1 Instrucciones

Nota
División por el valor "0"
La división de un dividendo (IN1) por un divisor (IN2) con el valor "0" pone la salida de
habilitación (ENO) al estado lógico "TRUE".
El valor del cociente (OUT) se ve influido por el tipo de datos al realizar la división por "0":
● El tipo de datos es INT o LREAL: El valor del cociente (OUT) es "0".
● El tipo de datos es REAL: El valor del cociente (OUT) es el valor máximo (2143289344).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Dividir":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

S7-1200

S7-1500

EN

Input

BOOL

I, Q, M, D,
L o cons‐
tante

I, Q, M, D, L, Entrada de habilitación
T, C o cons‐
tante

ENO

Output

BOOL

I, Q, M, D,
L

I, Q, M, D, L Salida de habilitación

IN1

Input

Enteros, números
en coma flotante

I, Q, M, D,
L, P o
constante

I, Q, M, D, L, Dividendo
P o constan‐
te

IN2

Input

Enteros, números
en coma flotante

I, Q, M, D,
L, P o
constante

I, Q, M, D, L, Divisor
P o constan‐
te

OUT

Output

Enteros, números
en coma flotante

I, Q, M, D,
L, P

I, Q, M, D, L,
P

Valor del cociente

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
',9
5($/

ಯ7DJ,Qಯ

(1

ಯ7DJB9DOXHಯ

,1

287

ಯ7DJB9DOXHಯ

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ
6

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El valor del
operando "Tag_Value1" se divide por el valor del operando "Tag_Value2". El resultado de la

1150

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
división se almacena en el operando "Tag_Result". Si no ocurren errores al ejecutar la
instrucción, la salida de habilitación ENO devuelve el estado lógico "1" y se activa la salida
"TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

MOD: Obtener resto de división
Descripción
La instrucción "Obtener resto de división" permite dividir el valor de la entrada IN1 por el valor
de la entrada IN2 y consultar el resto de la división en la salida OUT.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Obtener resto de división":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D,
L o cons‐
tante

I, Q, M, D,
L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D,
L

I, Q, M, D, L Salida de habilitación

IN1

Input

Enteros

I, Q, M, D,
L, P o
constante

I, Q, M, D,
Dividendo
L, P o cons‐
tante

IN2

Input

Enteros

I, Q, M, D,
L, P o
constante

I, Q, M, D,
Divisor
L, P o cons‐
tante

OUT

Output

Enteros

I, Q, M, D,
L, P

I, Q, M, D,
L, P

Resto de división

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1151

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
02'
',17

ಯ7DJ,Qಯ

(1

ಯ7DJB9DOXHಯ

,1

287

ಯ7DJB9DOXHಯ

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ
6

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El valor del
operando "Tag_Value1" se divide por el valor del operando "Tag_Value2". El resto de la
división se almacena en el operando "Tag_Result". Si no ocurren errores al ejecutar la
instrucción, la salida de habilitación ENO devuelve el estado lógico "1" y se activa la salida
"TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

NEG: Generar complemento a dos
Descripción
La instrucción "Generar complemento a dos" permite cambiar el signo del valor de la entrada
IN y consultar el resultado en la salida OUT. Por ejemplo, si la entrada IN tiene un valor positivo,
se deposita el equivalente negativo de este valor en la salida OUT.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El resultado de la instrucción está fuera del rango permitido para el tipo de datos indicado
en la salida OUT.
● Un número en coma flotante tiene un valor no válido.

1152

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Generar complemento a dos":
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

Descripción

S7-1500

EN

Input

BOOL

BOOL

I, Q, M,
I, Q, M, D,
D, L o
L, T, C o
constante constante

Entrada de habilita‐
ción

ENO

Output

BOOL

BOOL

I, Q, M,
D, L

IN

Input

SINT,
INT,
DINT, nú‐
meros en
coma flo‐
tante

SINT,
INT,
DINT,
LINT, nú‐
meros en
coma flo‐
tante

I, Q, M,
I, Q, M, D,
Valor de entrada
D, L, P o L, P o cons‐
constante tante

OUT

Output

SINT,
INT,
DINT, nú‐
meros en
coma flo‐
tante

SINT,
INT,
DINT,
LINT, nú‐
meros en
coma flo‐
tante

I, Q, M,
D, L, P

I, Q, M, D, L Salida de habilita‐
ción

I, Q, M, D,
L, P

Complemento a
dos del valor de en‐
trada

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
1(*
5($/
ಯ7DJ,Qಯ
ಯ7DJ,QB9DOXHಯ

(1

287

,1

(12

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El signo del valor
de la entrada "TagIn_Value" cambia y el resultado se almacena en la salida "TagOut_Value".
Si no ocurren errores al ejecutar la instrucción, la salida de habilitación ENO devuelve el estado
lógico "1" y se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)
Programación del PLC
Manual de programación y manejo, 11/2019

1153

Instrucciones
4.1 Instrucciones

INC: Incrementar
Descripción
La instrucción "Incrementar" permite cambiar el valor del operando del parámetro IN/OUT al
siguiente valor superior y consultar el resultado.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Un número en coma flotante tiene un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Incrementar":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D,
L o cons‐
tante

I, Q, M, D, L, Entrada de habilitación
T, C o cons‐
tante

ENO

Output

BOOL

I, Q, M, D,
L

I, Q, M, D, L

Salida de habilitación

IN/OUT

InOut

Enteros

I, Q, M, D,
L

I, Q, M, D, L

Valor que se incremen‐
ta.

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ7DJ,QBಯ
ಯ7DJ,QBಯ
ಯ7DJB,Q2XWಯ

,1&
,17
(1
,1287

ಯ7DJ2XWಯ
(12

Si los operandos "TagIn_1" y "TagIn_2" devuelven el estado lógico "1", el valor del operando
"Tag_InOut" se incrementa en uno y se activa la salida "TagOut".

1154

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

DEC: Decrementar
Descripción
La instrucción "Decrementar" permite cambiar el valor del operando del parámetro IN/OUT al
siguiente valor inferior y consultar el resultado.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Un número en coma flotante tiene un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Decrementar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

S7-1200 S7-1500
EN

Input

BOOL

I, Q, M, I, Q, M, D, L, Entrada de habilitación
D, L o
T, C o cons‐
constan‐ tante
te

ENO

Output

BOOL

I, Q, M,
D, L

I, Q, M, D, L Salida de habilitación

IN/OUT

InOut

Enteros

I, Q, M,
D, L

I, Q, M, D, L Valor que se decremen‐
ta.

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ7DJ,QBಯ
ಯ7DJ,QBಯ
ಯ7DJB,Q2XWಯ

Programación del PLC
Manual de programación y manejo, 11/2019

'(&
,17
(1
,1287

ಯ7DJ2XWಯ
(12

1155

Instrucciones
4.1 Instrucciones
Si los operandos "TagIn_1" y "TagIn_2" devuelven el estado lógico "1", el valor del operando
"Tag_InOut" se decrementa en uno y se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

ABS: Calcular valor absoluto
Descripción
La instrucción "Calcular valor absoluto" permite calcular el valor absoluto del valor indicado en
la entrada IN. El resultado de la instrucción se devuelve en la salida OUT y se puede consultar
allí.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Un número en coma flotante tiene un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Calcular valor absoluto":
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

IN

Input

SINT, INT,
DINT, núme‐
ros en coma
flotante

SINT, INT,
DINT, LINT,
números en
coma flotan‐
te

I, Q, M, D, L, I, Q, M, D, L, Valor de en‐
P o constan‐ P o constan‐ trada
te
te

OUT

Output

SINT, INT,
DINT, núme‐
ros en coma
flotante

SINT, INT,
DINT, LINT,
números en
coma flotan‐
te

I, Q, M, D, L,
P

I, Q, M, D, L,
P

Valor abso‐
luto del valor
de entrada

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1156

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
$%6
5($/
ಯ7DJ,Qಯ
ಯ7DJ,QB9DOXHಯ

(1

287

,1

(12

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

TagIn_Value

-6.234

OUT

TagOut_Value

6.234

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
calcula el valor absoluto del valor de la entrada "TagIn_Value" y deposita el resultado en la
salida "TagOut_Value". Si no ocurren errores al ejecutar la instrucción, se activa la salida
"TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

MIN: Determinar mínimo
Descripción
La instrucción "Determinar mínimo" compara los valores de las entradas disponibles y escribe
el valor menor en la salida OUT. El número de entradas se puede ampliar en el cuadro de la
instrucción mediante entradas adicionales. Las entradas se numeran de forma ascendente en
el cuadro.
En estado básico, la instrucción contiene mín. dos entradas (IN1 e IN2) y hasta un máx. de 100
entradas.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● La conversión implícita de los tipos de datos falla durante la ejecución de la instrucción.
● Un número en coma flotante tiene un valor no válido.

Programación del PLC
Manual de programación y manejo, 11/2019

1157

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Determinar mínimo":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

S7-1200

S7-1500
I, Q, M, D, L, Entrada de habilita‐
T, C o cons‐ ción
tante

EN

Input

BOOL

I, Q, M, D, L
o constante

ENO

Output

BOOL

I, Q, M, D, L I, Q, M, D, L

IN1

Input

Enteros, números
en coma flotante,
DTL, DT

I, Q, M, D,
I, Q, M, D, L, Primer valor de entra‐
L, P o cons‐ P o constan‐ da
tante
te

IN2

Input

Enteros, números
en coma flotante,
DTL, DT

I, Q, M, D,
I, Q, M, D, L, Segundo valor de en‐
L, P o cons‐ P o constan‐ trada
tante
te

INn

Input

Enteros, números
en coma flotante,
DTL, DT

I, Q, M, D,
I, Q, M, D, L, Entradas insertadas
L, P o cons‐ P o constan‐ adicionalmente cu‐
tante
te
yos valores se com‐
paran

OUT

Output

Enteros, números
en coma flotante,
DTL, DT

I, Q, M, D,
L, P

I, Q, M, D, L,
P

Salida de habilitación

Resultado

Si la verificación CEI no está activada, también es posible utilizar variables del tipo de datos TIME,
LTIME, TOD, LTOD, DATE y LDT seleccionando como tipo de datos de la instrucción un número entero
o una secuencia de bits de igual longitud. (P. ej. en lugar de TIME => DINT, UDINT o DWORD = 32 bits)

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ7DJ,QBಯ
ಯ7DJ,QBಯ

0,1
,17
(1

ಯ7DJ,QB9DOXHಯ

,1

ಯ7DJ,QB9DOXHಯ

,1

287

ಯ7DJ,QB9DOXHಯ

,1

(12

ಯ7DJ2XWB9DOXHಯ

ಯ7DJ2XWಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

1158

Operando

Valor

IN1

TagIn_Value1

12222

IN2

TagIn_Value2

14444

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Operando

Valor

IN3

TagIn_Value3

13333

OUT

TagOut_Value

12222

Si los operandos "TagIn_1" y "TagIn_2" tienen el estado lógico "1", se ejecuta la instrucción. La
instrucción compara los valores de los operandos indicados y copia el valor menor
("TagIn_Value1") en la salida "TagOut_Value". Si no ocurren errores al ejecutar la instrucción,
se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

MAX: Determinar máximo
Descripción
La instrucción "Determinar máximo" compara los valores de las entradas disponibles y escribe
el valor mayor en la salida OUT. El número de entradas se puede ampliar en el cuadro de la
instrucción mediante entradas adicionales. Las entradas se numeran de forma ascendente en
el cuadro.
En estado básico, la instrucción contiene mín. dos entradas (IN1 e IN2) y hasta un máx. de 100
entradas.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● La conversión implícita de los tipos de datos falla durante la ejecución de la instrucción.
● Un número en coma flotante tiene un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Determinar máximo":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

S7-1200

S7-1500
I, Q, M, D, L, Entrada de habilita‐
T, C o cons‐ ción
tante

EN

Input

BOOL

I, Q, M, D, L
o constante

ENO

Output

BOOL

I, Q, M, D, L I, Q, M, D, L

IN1

Input

Enteros, números
en coma flotante,
DTL, DT

I, Q, M, D,
I, Q, M, D, L, Primer valor de entra‐
L, P o cons‐ P o constan‐ da
tante
te

Programación del PLC
Manual de programación y manejo, 11/2019

Salida de habilitación

1159

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

Descripción

S7-1500

IN2

Input

Enteros, números
en coma flotante,
DTL, DT

I, Q, M, D,
I, Q, M, D, L, Segundo valor de en‐
L, P o cons‐ P o constan‐ trada
tante
te

INn

Input

Enteros, números
en coma flotante,
DTL, DT

I, Q, M, D,
I, Q, M, D, L, Entradas insertadas
L, P o cons‐ P o constan‐ adicionalmente cu‐
tante
te
yos valores se com‐
paran.

OUT

Output

Enteros, números
en coma flotante,
DTL, DT

I, Q, M, D,
L, P

I, Q, M, D, L,
P

Resultado

Si la verificación CEI no está activada, también es posible utilizar variables del tipo de datos TIME,
LTIME, TOD, LTOD, DATE y LDT seleccionando como tipo de datos de la instrucción un número entero
o una secuencia de bits de igual longitud. (P. ej. en lugar de TIME => DINT, UDINT o DWORD = 32 bits)

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ7DJ,QBಯ
ಯ7DJ,QBಯ

0$;
,17
(1

ಯ7DJ,QB9DOXHಯ

,1

ಯ7DJ,QB9DOXHಯ

,1

287

ಯ7DJ,QB9DOXHಯ

,1

(12

ಯ7DJ2XWB9DOXHಯ

ಯ7DJ2XWಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN1

TagIn_Value1

12222

IN2

TagIn_Value2

14444

IN3

TagIn_Value3

13333

OUT

TagOut_Value

14444

Si los operandos "TagIn_1" y "TagIn_2" tienen el estado lógico "1", se ejecuta la instrucción. La
instrucción compara los valores de los operandos indicados y copia el valor mayor
("TagIn_Value2") en la salida "TagOut_Value". Si no ocurren errores al ejecutar la instrucción,
se activa la salida "TagOut".

1160

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

LIMIT: Ajustar valor límite
Descripción
La instrucción "Ajustar valor límite" limita el valor de la entrada IN a los valores de las entradas
MN y MX. Si el valor de la entrada IN cumple la condición MN <= IN <= MX, se copia en la salida
OUT. Si no se cumple la condición y el valor de entrada IN es menor que el límite inferior MN,
la salida OUT adopta el valor de la entrada MN. Si el límite superior MX se rebasa por exceso,
la salida OUT adopta el valor de la entrada MX.
Si el valor de la entrada MN es mayor que el de la entrada MX, el resultado será el valor
indicado en el parámetro IN y la salida de habilitación ENO será "0".
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Las variables indicadas no son del mismo tipo de datos.
● Un operando tiene un valor no válido.
● El valor de la entrada MN es mayor que el valor de la entrada MX.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Ajustar valor límite":
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

MN

Input

Enteros,
números
en coma
flotante,
TIME,
TOD, DA‐
TE, DTL,
DT

Enteros, nú‐ I, Q, M, D, L,
meros en co‐ P o constan‐
ma flotante, te
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DTL, DT

I, Q, M, D, L,
P o constan‐
te

Límite infe‐
rior

Programación del PLC
Manual de programación y manejo, 11/2019

1161

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memoria
S7-1200

Descripción

S7-1500

IN

Input

Enteros,
números
en coma
flotante,
TIME,
TOD, DA‐
TE, DTL,
DT

Enteros, nú‐ I, Q, M, D, L,
meros en co‐ P o constan‐
ma flotante, te
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DTL, DT

I, Q, M, D, L,
P o constan‐
te

Valor de en‐
trada

MX

Input

Enteros,
números
en coma
flotante,
TIME,
TOD, DA‐
TE, DTL,
DT

Enteros, nú‐ I, Q, M, D, L,
meros en co‐ P o constan‐
ma flotante, te
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DTL, DT

I, Q, M, D, L,
P o constan‐
te

Límite supe‐
rior

OUT

Output

Enteros,
números
en coma
flotante,
TIME,
TOD, DA‐
TE, DTL,
DT

Enteros, nú‐ I, Q, M, D, L,
meros en co‐ P
ma flotante,
TIME, LTI‐
ME, TOD,
LTOD, DA‐
TE, LDT,
DTL, DT

I, Q, M, D, L,
P

Resultado

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar cuando la verificación CEI está
desactivada.

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
/,0,7

ಯ7DJ,QBಯ

,17
ಯ7DJ,QBಯ
ಯ7DJB01ಯ
ಯ7DJB9DOXHಯ
ಯ7DJB0;ಯ

1162

(1

287

01

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

,1
0;

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

MN

Tag_MN

12000

IN

Tag_Value

8000

MX

Tag_MX

16000

OUT

Tag_Result

12000

Si los operandos "TagIn_1" y "TagIn_2" tienen el estado lógico "1", se ejecuta la instrucción. El
valor del operando "Tag_Value" se compara con los valores de los operandos "Tag_MN" y
"Tag_MX". Puesto que el valor del operando "Tag_Value" es menor que el valor límite inferior,
el valor del operando "Tag_MN" se copia en la salida "Tag_Result". Si no ocurren errores al
ejecutar la instrucción, se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

SQR: Calcular cuadrado
Descripción
La instrucción "Calcular cuadrado" permite elevar al cuadrado el valor de la entrada IN
correspondiente a un número en coma flotante y escribir el resultado en la salida OUT.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El valor de la entrada IN no es un número en coma flotante válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Calcular cuadrado":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L, Entrada de habilita‐
T, C o cons‐ ción
tante

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Programación del PLC
Manual de programación y manejo, 11/2019

Salida de habilita‐
ción

1163

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

Descripción

S7-1500

IN

Input

Números en coma
flotante

I, Q, M, D, L, I, Q, M, D, L, Valor de entrada
P o constan‐ P o constan‐
te
te

OUT

Output

Números en coma
flotante

I, Q, M, D, L,
P

I, Q, M, D, L,
P

Cuadrado del valor
de entrada

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
645
5($/
ಯ7DJ,Qಯ

(1

287

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

ಯ7DJB9DOXHಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

Tag_Value

5.0

OUT

Tag_Result

25.0

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
eleva al cuadrado el valor del operando "Tag_Value" y deposita el resultado en la salida
"Tag_Result". Si no ocurren errores al ejecutar la instrucción, se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

SQRT: Calcular raíz cuadrada
Descripción
La instrucción "Calcular raíz cuadrada" permite extraer la raíz cuadrada al valor de la entrada
IN correspondiente a un número en coma flotante y escribir el resultado en la salida OUT. La
instrucción da un resultado positivo si el valor de entrada es mayor que cero. En los valores de
entrada menores que cero, la salida OUT devuelve un número en coma flotante no válido. Si
el valor de la entrada IN es "0", el resultado también es "0".

1164

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El valor de la entrada IN no es un número en coma flotante válido.
● El valor de la entrada IN es negativo.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Calcular raíz cuadrada":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500
I, Q, M, D, L,
T, C o cons‐
tante

Descripción

EN

Input

BOOL

I, Q, M, D, L
o constante

Entrada de habilita‐
ción

ENO

Output

BOOL

I, Q, M, D, L I, Q, M, D, L

IN

Input

Números en coma
flotante

I, Q, M, D, L, I, Q, M, D, L, Valor de entrada
P o constan‐ P o constan‐
te
te

OUT

Output

Números en coma
flotante

I, Q, M, D, L I, Q, M, D, L

Salida de habilita‐
ción

Raíz cuadrada del
valor de entrada

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
6457
5($/
ಯ7DJ,Qಯ

(1

287

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

ಯ7DJB9DOXHಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

Tag_Value

25.0

OUT

Tag_Result

5.0

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
extrae la raíz cuadrada del valor del operando "Tag_Value" y deposita el resultado en la salida
"Tag_Result". Si no ocurren errores al ejecutar la instrucción, se activa la salida "TagOut".

Programación del PLC
Manual de programación y manejo, 11/2019

1165

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

LN: Calcular logaritmo natural
Descripción
La instrucción "Calcular logaritmo natural" permite calcular el logaritmo natural en base e (e =
2,718282) del valor de la entrada IN. El resultado se deposita en la salida OUT y se puede
consultar allí. La instrucción da un resultado positivo si el valor de entrada es mayor que cero.
En los valores de entrada menores que cero, la salida OUT devuelve un número en coma
flotante no válido.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El valor de la entrada IN no es un número en coma flotante válido.
● El valor de la entrada IN es negativo.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Calcular logaritmo natural":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L, Entrada de habilita‐
T, C o cons‐ ción
tante

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L Salida de habilitación

IN

Input

Números en coma
flotante

I, Q, M, D, L, I, Q, M, D, L, Valor de entrada
P o constan‐ P o constan‐
te
te

OUT

Output

Números en coma
flotante

I, Q, M, D, L,
P

I, Q, M, D, L, Logaritmo natural
P
del valor de entrada

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1166

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
/1
5($/
ಯ7DJ,Qಯ

(1

287

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

ಯ7DJB9DOXHಯ

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
calcula el logaritmo natural del valor de la entrada "Tag_Value" y deposita el resultado en la
salida "Tag_Result". Si no ocurren errores al ejecutar la instrucción, se activa la salida
"TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

EXP: Calcular valor exponencial
Descripción
La instrucción "Calcular valor exponencial" permite calcular la potencia en base e (e =
2,718282) del valor indicado en la entrada IN. El resultado se emite en la salida OUT y se
puede consultar allí (OUT = eIN).
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El valor de la entrada IN no es un número en coma flotante válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Calcular valor exponencial":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de habilita‐
ción

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habilita‐
ción

Programación del PLC
Manual de programación y manejo, 11/2019

1167

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

Descripción

S7-1500

IN

Input

Números en coma
flotante

I, Q, M, D, L, I, Q, M, D, L,
P o constan‐ P o constan‐
te
te

Valor de entrada

OUT

Output

Números en coma
flotante

I, Q, M, D, L,
P

Valor exponencial
del valor de entrada
IN

I, Q, M, D, L,
P

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
(;3
5($/
ಯ7DJ,Qಯ

(1

287

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

ಯ7DJB9DOXHಯ

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
calcula la potencia en base e del valor del operando "Tag_Value" y deposita el resultado en la
salida "Tag_Result". Si no ocurren errores al ejecutar la instrucción, se activa la salida
"TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

SIN: Calcular valor de seno
Descripción
La instrucción "Calcular valor de seno" permite calcular el seno de un ángulo. El tamaño del
ángulo se indica en radianes en la entrada IN. El resultado de la instrucción se devuelve en la
salida OUT y se puede consultar allí.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El valor de la entrada IN no es un número en coma flotante válido.

1168

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Calcular valor de seno":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN

Input

Números en
coma flotante

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Tamaño del
ángulo en ra‐
dianes

OUT

Output

Números en
coma flotante

I, Q, M, D, L, P I, Q, M, D, L, P Seno del ángu‐
lo indicado

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
6,1
5($/
ಯ7DJ,Qಯ

(1

287

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

ಯ7DJB9DOXHಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

Tag_Value

+1.570796 (π/2)

OUT

Tag_Result

1.0

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
calcula el seno del ángulo indicado en la entrada "Tag_Value" y deposita el resultado en la
salida "Tag_Result". Si no ocurren errores al ejecutar la instrucción, se activa la salida
"TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1169

Instrucciones
4.1 Instrucciones

COS: Calcular valor de coseno
Descripción
La instrucción "Calcular valor de coseno" permite calcular el coseno de un ángulo. El tamaño
del ángulo se indica en radianes en la entrada IN. El resultado de la instrucción se devuelve en
la salida OUT y se puede consultar allí.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El valor de la entrada IN no es un número en coma flotante válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Calcular valor de coseno":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN

Input

Números en
coma flotante

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Tamaño del
ángulo en ra‐
dianes

OUT

Output

Números en
coma flotante

I, Q, M, D, L, P I, Q, M, D, L, P Coseno del án‐
gulo indicado

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
&26
5($/
ಯ7DJ,Qಯ

(1

287

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

ಯ7DJB9DOXHಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:

1170

Parámetro

Operando

Valor

IN

Tag_Value

+1.570796 (π/2)

OUT

Tag_Result

0

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
calcula el coseno del ángulo indicado en la entrada "Tag_Value" y deposita el resultado en la
salida "Tag_Result". Si no ocurren errores al ejecutar la instrucción, se activa la salida
"TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

TAN: Calcular valor de tangente
Descripción
La instrucción "Calcular valor de tangente" permite calcular la tangente de un ángulo. El
tamaño del ángulo se indica en radianes en la entrada IN. El resultado de la instrucción se
devuelve en la salida OUT y se puede consultar allí.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El valor de la entrada IN no es un número en coma flotante válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Calcular valor de tangente":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN

Input

Números en
coma flotante

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Tamaño del
ángulo en ra‐
dianes

OUT

Output

Números en
coma flotante

I, Q, M, D, L, P I, Q, M, D, L, P Tangente del
ángulo indica‐
do

En la lista desplegable "<???>" del cuadro de la instrucción se puede seleccionar el tipo de
datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1171

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
7$1
5($/
ಯ7DJ,Qಯ

(1

287

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

ಯ7DJB9DOXHಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

Tag_Value

+3,141593 (π)

OUT

Tag_Result

0

Cuando el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción "Calcular
valor de tangente". La instrucción calcula la tangente del ángulo indicado en la entrada
"Tag_Value" y deposita el resultado en la salida "Tag_Result". Si no ocurren errores al ejecutar
la instrucción, se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

ASIN: Calcular valor de arcoseno
Descripción
La instrucción "Calcular valor de arcoseno" permite calcular a partir del valor de seno
especificado en la entrada IN el tamaño del ángulo que equivale a este valor. En la entrada IN
solo se pueden indicar números en coma flotante válidos, comprendidos en un rango de
valores entre -1 y +1. El tamaño del ángulo calculado se deposita en radianes en la salida OUT
y puede estar comprendido entre -π/2 y +π/2.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El valor de la entrada IN no es un número en coma flotante válido.
● El valor de la entrada IN está fuera del rango de valores permitido (-1 hasta +1).

1172

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Calcular valor de arcoseno":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN

Input

Números en
coma flotante

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valor de seno

OUT

Output

Números en
coma flotante

I, Q, M, D, L, P I, Q, M, D, L, P Tamaño del
ángulo en ra‐
dianes

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
$6,1
5($/
ಯ7DJ,Qಯ

(1

287

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

ಯ7DJB9DOXHಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

Tag_Value

1.0

OUT

Tag_Result

+1.570796 (π/2)

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
calcula el tamaño del ángulo que equivale al valor de seno de la entrada "Tag_Value". El
resultado de la instrucción se deposita en la salida "Tag_Result". Si no ocurren errores al
ejecutar la instrucción, se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1173

Instrucciones
4.1 Instrucciones

ACOS: Calcular valor de arcocoseno
Descripción
La instrucción "Calcular valor de arcocoseno" permite calcular a partir del valor de coseno
indicado en la entrada IN el tamaño del ángulo que equivale a este valor. En la entrada IN solo
se pueden indicar números en coma flotante válidos, comprendidos en un rango de valores
entre -1 y +1. El tamaño del ángulo calculado se deposita en radianes en la salida OUT y puede
estar comprendido entre 0 y +π.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El valor de la entrada IN no es un número en coma flotante válido.
● El valor de la entrada IN está fuera del rango de valores permitido (-1 hasta +1).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Calcular valor de arcocoseno":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN

Input

Números en
coma flotante

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valor de cose‐
no

OUT

Output

Números en
coma flotante

I, Q, M, D, L, P I, Q, M, D, L, P Tamaño del
ángulo en ra‐
dianes

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
$&26
5($/
ಯ7DJ,Qಯ

(1

287

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

ಯ7DJB9DOXHಯ

1174

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

Tag_Value

0

OUT

Tag_Result

+1.570796 (π/2)

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
calcula el tamaño del ángulo que equivale al valor de coseno de la entrada "Tag_Value". El
resultado de la instrucción se deposita en la salida "Tag_Result". Si no ocurren errores al
ejecutar la instrucción, se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

ATAN: Calcular valor de arcotangente
Descripción
La instrucción "Calcular valor de arcotangente" permite calcular a partir del valor de tangente
indicado en la entrada IN el tamaño del ángulo que corresponde a este valor. En la entrada IN
solo se pueden indicar números en coma flotante válidos (o -NaN/+NaN). El tamaño del ángulo
calculado se deposita en radianes en la salida OUT y puede estar comprendido entre -π/2 y
+π/2.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El valor de la entrada IN no es un número en coma flotante válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Calcular valor de arcotangente":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500
I, Q, M, D,
L, T, C o
constante

Descripción

EN

Input

BOOL

I, Q, M, D,
L o cons‐
tante

ENO

Output

BOOL

I, Q, M, D, L I, Q, M, D, L Salida de habilitación

IN

Input

Números en coma
flotante

Valor de tangente
I, Q, M, D, I, Q, M, D,
L, P o cons‐ L, P o cons‐
tante
tante

OUT

Output

Números en coma
flotante

I, Q, M, D,
L, P

Programación del PLC
Manual de programación y manejo, 11/2019

I, Q, M, D,
L, P

Entrada de habilita‐
ción

Tamaño del ángulo en
radianes

1175

Instrucciones
4.1 Instrucciones
En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
$7$1
5($/
ಯ7DJ,Qಯ

(1

287

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

ಯ7DJB9DOXHಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

Tag_Value

1.0

OUT

Tag_Result

+0,785398 (π/4)

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
calcula el tamaño del ángulo que corresponde al valor de tangente de la entrada "Tag_Value".
El resultado de la instrucción se deposita en la salida "Tag_Result". Si no ocurren errores al
ejecutar la instrucción, se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Números en coma flotante no válidos (Página 263)
Principios básicos de FUP (Página 8005)

FRAC: Determinar decimales
Descripción
La instrucción "Determinar decimales" permite determinar los decimales del valor de la entrada
IN. El resultado de la consulta se deposita en la salida OUT y se puede consultar allí. Si la
entrada IN lleva, p. ej., el valor 123,4567, la salida OUT proporciona el valor 0,4567.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Al ejecutar la instrucción se producen errores, p. ej. la entrada no tiene un número en coma
flotante válido).

1176

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Determinar decimales":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN

Input

Números en
coma flotante

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valor de entra‐
da cuyos deci‐
males se deter‐
minan.

OUT

Output

Números en
coma flotante

I, Q, M, D, L, P I, Q, M, D, L, P Decimales del
valor de la en‐
trada IN

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ7DJ,QBಯ
ಯ7DJ,QBಯ
ಯ7DJB9DOXHಯ

)5$&
5($/
(1

287

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

Tag_Value

2.555

OUT

Tag_Result

0.555

Si los operandos "TagIn_1" y "TagIn_2" devuelven el estado lógico "1", se inicia la instrucción.
Los decimales del valor del operando "Tag_Value" se copian en el operando "Tag_Result". Si
no ocurren errores al ejecutar la instrucción, la salida de habilitación ENO devuelve el estado
lógico "1" y se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1177

Instrucciones
4.1 Instrucciones

EXPT: Elevar a potencia
Descripción
La instrucción "Elevar a potencia" permite elevar el valor de la entrada IN1 a la potencia del
valor de la entrada IN2. El resultado de la instrucción se devuelve en la salida OUT y se puede
consultar allí (OUT = IN1IN2).
La entrada IN1 solo puede tener asignados números en coma flotante válidos. A la entrada IN2
también se pueden asignar números enteros.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Al ejecutar la instrucción ocurren errores, p. ej. se produce un rebase por exceso.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Elevar a potencia":
Parámetro
EN

Declaración
Input

Tipo de datos

Área de memoria
S7-1200

S7-1500

BOOL

I, Q, M, D,
L o cons‐
tante

I, Q, M, D, L,
T, C o cons‐
tante

Descripción
Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L I, Q, M, D, L

Salida de habilitación

IN1

Input

Números en
coma flotante

I, Q, M, D,
L, P o
constante

I, Q, M, D, L,
P o constan‐
te

Valor base

IN2

Input

Enteros, nú‐
meros en co‐
ma flotante

I, Q, M, D,
L, P o
constante

I, Q, M, D, L,
P o constan‐
te

Valor del exponente

OUT

Output

Números en
coma flotante

I, Q, M, D,
L, P

I, Q, M, D, L,
P

Resultado

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1178

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ7DJ,QBಯ
5($/

ಯ7DJ,QBಯ

(;37

5($/

(1

ಯ7DJB9DOXHಯ

,1

287

ಯ7DJB9DOXHಯ

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

Cuando los operandos "TagIn_1" y "TagIn_2" devuelven el estado lógico "1", se inicia la
instrucción "Elevar a potencia". El valor del operando "Tag_Value1" se eleva a la potencia del
valor del operando "Tag_Value2". El resultado se deposita en la salida "Tag_Result". Si no
ocurren errores al ejecutar la instrucción, la salida de habilitación ENO devuelve el estado
lógico "1" y se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

Transferencia
MOVE: Copiar valor
Descripción
La instrucción "Copiar valor" transfiere el contenido del operando de la entrada IN al operando
de la salida OUT1. La transferencia se efectúa siempre por orden ascendente de direcciones.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El tipo de datos del parámetro IN no puede convertirse al tipo de datos indicado en el
parámetro OUT1.
La tabla siguiente muestra las posibles transferencias para la familia de CPU S7-1200:
Origen (IN)

Destino (OUT1)
Con verificación CEI

Sin verificación CEI

BYTE

BYTE, WORD, DWORD

BYTE, WORD, DWORD, SINT, USINT, INT, UINT,
DINT, UDINT, TIME, DATE ,TOD, CHAR

WORD

WORD, DWORD

BYTE, WORD, DWORD, SINT, USINT, INT, UINT,
DINT, UDINT, TIME, DATE, TOD, CHAR

Programación del PLC
Manual de programación y manejo, 11/2019

1179

Instrucciones
4.1 Instrucciones
Origen (IN)

1180

Destino (OUT1)
Con verificación CEI

Sin verificación CEI

DWORD

DWORD

BYTE, WORD, DWORD, SINT, USINT, INT, UINT,
DINT, UDINT, REAL, TIME, DATE, TOD, CHAR

SINT

SINT

BYTE, WORD, DWORD, SINT, USINT, INT, UINT,
DINT, UDINT, TIME, DATE, TOD

USINT

USINT, UINT, UDINT

BYTE, WORD, DWORD, SINT, USINT, INT, UINT,
DINT, UDINT, TIME, DATE, TOD

INT

INT

BYTE, WORD, DWORD, SINT, USINT, INT, UINT,
DINT, UDINT, TIME, DATE, TOD

UINT

UINT, UDINT

BYTE, WORD, DWORD, SINT, USINT, INT, UINT,
DINT, UDINT, TIME, DATE, TOD

DINT

DINT

BYTE, WORD, DWORD, SINT, USINT, INT, UINT,
DINT, UDINT, TIME, DATE, TOD

UDINT

UDINT

BYTE, WORD, DWORD, SINT, USINT, INT, UINT,
DINT, UDINT, TIME, DATE, TOD

REAL

REAL

DWORD, REAL

LREAL

LREAL

LREAL

TIME

TIME

BYTE, WORD, DWORD, SINT, USINT, INT, UINT,
DINT, UDINT, TIME

DATE

DATE

BYTE, WORD, DWORD, SINT, USINT, INT, UINT,
DINT, UDINT, DATE

TOD

TOD

BYTE, WORD, DWORD, SINT, USINT, INT, UINT,
DINT, UDINT, TOD

DTL

DTL

DTL

CHAR

CHAR

BYTE, WORD, DWORD, CHAR, carácter de una ca‐
dena1)

WCHAR

WCHAR

BYTE, WORD, DWORD, CHAR, WCHAR, carácter
de una cadena1)

Carácter de
una cadena1)

Carácter de una cadena

CHAR, WCHAR, carácter de una cadena

ARRAY2)

ARRAY

ARRAY

STRUCT

STRUCT

STRUCT

Tipo de datos
PLC (UDT)

Tipo de datos PLC (UDT)

Tipo de datos PLC (UDT)

IEC_TIMER

IEC_TIMER

IEC_TIMER

IEC_SCOUN‐
TER

IEC_SCOUNTER

IEC_SCOUNTER

IEC_USCOUN‐
TER

IEC_USCOUNTER

IEC_USCOUNTER

IEC_COUNTER IEC_COUNTER

IEC_COUNTER

IEC_UCOUN‐
TER

IEC_UCOUNTER

IEC_UCOUNTER

IEC_DCOUN‐
TER

IEC_DCOUNTER

IEC_DCOUNTER

IEC_UDCOUN‐
TER

IEC_UDCOUNTER

IEC_UDCOUNTER

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra las posibles transferencias para la familia de CPU S7-1500:
Origen (IN)

Destino (OUT1)
Con verificación CEI

Sin verificación CEI

BYTE

BYTE, WORD, DWORD,
LWORD

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, TIME, LTIME,
LDT, DATE ,TOD, LTOD, CHAR

WORD

WORD, DWORD, LWORD

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, S5TIME, TIME,
LTIME, LDT, DATE, TOD, LTOD, CHAR

DWORD

DWORD, LWORD

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, REAL, TIME, LTI‐
ME, LDT, DATE, TOD, LTOD, CHAR

LWORD

LWORD

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, LREAL, TIME,
LTIME, LDT, DATE, TOD, LTOD, CHAR

SINT

SINT

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, TIME, LTIME,
LDT, DATE, TOD, LTOD

USINT

USINT, UINT, UDINT,
ULINT

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, TIME, LTIME,
LDT, DATE, TOD, LTOD

INT

INT

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, TIME, LTIME,
LDT, DATE, TOD, LTOD

UINT

UINT, UDINT, ULINT

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, TIME, LTIME,
LDT, DATE, TOD. LTOD

DINT

DINT

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, TIME, LTIME,
LDT, DATE, TOD, LTOD

UDINT

UDINT, ULINT

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, TIME, LTIME,
LDT, DATE, TOD, LTOD

LINT

LINT

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, TIME, LTIME,
LDT, DATE, TOD, LTOD

ULINT

ULINT

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, TIME, LTIME,
LDT, DATE, TOD, LTOD

REAL

REAL

DWORD, REAL

LREAL

LREAL

LWORD, LREAL

S5TIME

S5TIME

WORD, S5TIME

TIME

TIME

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, TIME

LTIME

LTIME

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, LTIME

DATE

DATE

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, DATE

DT

DT

DT

Programación del PLC
Manual de programación y manejo, 11/2019

1181

Instrucciones
4.1 Instrucciones
Origen (IN)

Destino (OUT1)
Con verificación CEI

Sin verificación CEI

LDT

LDT

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, LDT

TOD

TOD

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, TOD

LTOD

LTOD

BYTE, WORD, DWORD, LWORD, SINT, USINT, INT,
UINT, DINT, UDINT, LINT, ULINT, LTOD

DTL

DTL

DTL

CHAR

CHAR

BYTE, WORD, DWORD, LWORD, CHAR, carácter
de una cadena1)

WCHAR

WCHAR

BYTE, WORD, DWORD, LWORD, CHAR, WCHAR,
carácter de una cadena1)

Carácter de
una cadena1)

Carácter de una cadena

CHAR, WCHAR, carácter de una cadena

ARRAY2)

ARRAY

ARRAY

STRUCT

STRUCT

STRUCT

COUNTER

COUNTER, WORD, INT

WORD, DWORD, INT, UINT, DINT, UDINT

TIMER

TIMER, WORD, INT

WORD, DWORD, INT, UINT, DINT, UDINT

Tipo de datos
PLC (UDT)

Tipo de datos PLC (UDT)

Tipo de datos PLC (UDT)

IEC_TIMER

IEC_TIMER

IEC_TIMER

IEC_LTIMER

IEC_LTIMER

IEC_LTIMER

IEC_SCOUN‐
TER

IEC_SCOUNTER

IEC_SCOUNTER

IEC_USCOUN‐
TER

IEC_USCOUNTER

IEC_USCOUNTER

IEC_COUNTER IEC_COUNTER

IEC_COUNTER

IEC_UCOUN‐
TER

IEC_UCOUNTER

IEC_UCOUNTER

IEC_DCOUN‐
TER

IEC_DCOUNTER

IEC_DCOUNTER

IEC_UDCOUN‐
TER

IEC_UDCOUNTER

IEC_UDCOUNTER

IEC_LCOUN‐
TER

IEC_LCOUNTER

IEC_LCOUNTER

IEC_ULCOUN‐
TER

IEC_ULCOUNTER

IEC_ULCOUNTER

REF()

No se realiza ninguna conversión del tipo de datos. La variable transferida debe
coincidir exactamente con el tipo de datos de destino.

La instrucción "Copiar valor" también permite transferir caracteres individuales de una
cadena a operandos del tipo de datos CHAR o WCHAR. El número del carácter que se va a
transferir se indica entre corchetes al lado del nombre del operando. Si se indica "MyString[2]",
se transfiere p. ej. el segundo carácter de la cadena de caracteres "MyString". Asimismo, es
posible transferir operandos del tipo de datos CHAR o WCHAR a caracteres individuales de
una cadena de caracteres. También es posible reemplazar un carácter específico de una
cadena de caracteres por el carácter de otra cadena de caracteres.
1)

1182

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Solo es posible transferir matrices enteras (ARRAY) si los elementos de matriz de los
operandos de la entrada IN y de la salida OUT1 son del mismo tipo de datos.

2)

Si la longitud de bits del tipo de datos de la entrada IN supera la longitud de bits del tipo de datos
de la salida OUT1, se pierden los bits más significativos del valor de origen. Si la longitud de
bit del tipo de datos de la entrada IN es inferior a la longitud de bit del tipo de datos de la salida
OUT1, se sobrescriben con ceros los bits más significativos del valor de destino.
El cuadro de la instrucción contiene en estado inicial 1 salida (OUT1). El número de salidas es
ampliable. Las salidas insertadas se numeran en orden ascendente en el cuadro. Al ejecutar
la instrucción se transfiere el contenido del operando de la entrada IN a todas las salidas
disponibles. El cuadro de la instrucción no se puede ampliar si se transfieren tipos de datos
estructurados (DTL, STRUCT, ARRAY) o caracteres de una cadena.
Para copiar operandos del tipo de datos ARRAY pueden utilizarse también las instrucciones
"Copiar área" (MOVE_BLK) y "Copiar área sin interrupciones" (UMOVE_BLK). Los operandos
del tipo de datos STRING o WSTRING se pueden copiar con la instrucción "Desplazar cadena
de caracteres" (S_MOVE).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Copiar valor":
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

Programación del PLC
Manual de programación y manejo, 11/2019

1183

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memoria
S7-1200

Descripción

S7-1500

IN

Input

Secuencias
de bits, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, fe‐
cha y hora,
CHAR,
WCHAR,
STRUCT,
ARRAY, ti‐
pos de datos
IEC, tipo de
datos PLC
(UDT)

Secuencias I, Q, M, D, L
de bits, ente‐ o constante
ros, núme‐
ros en coma
flotante,
tiempos, fe‐
cha y hora,
CHAR,
WCHAR,
STRUCT,
ARRAY, TI‐
MER,
COUNTER,
tipos de da‐
tos IEC, tipo
de datos
PLC (UDT)

I, Q, M, D, L
o constante

Elemento
con el que
se sobrescri‐
be la direc‐
ción de des‐
tino.

OUT1

Output

Secuencias
de bits, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, fe‐
cha y hora,
CHAR,
WCHAR,
STRUCT,
ARRAY, ti‐
pos de datos
IEC, tipo de
datos PLC
(UDT)

Secuencias I, Q, M, D, L
de bits, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, fe‐
cha y hora,
CHAR,
WCHAR,
STRUCT,
ARRAY, TI‐
MER,
COUNTER,
tipos de da‐
tos IEC, tipo
de datos
PLC (UDT)

I, Q, M, D, L

Dirección de
destino

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
029(
ಯ7DJ,Qಯ

(1

287

,1

(12

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

ಯ7DJ,QB9DOXHಯ

1184

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

TagIn_Value

0011 1111 1010 1111

OUT1

TagOut_Value

0011 1111 1010 1111

Si el operando "TagIn" devuelve el estado lógico TRUE se ejecuta la instrucción. La instrucción
copia los contenidos del operando "TagIn_Value" al operando "TagOut_Value". Si no se
producen errores al ejecutar la instrucción, la salida de habilitación ENO y "TagOut" adoptan
el estado lógico TRUE.
Nota
Encontrará más información sobre la instrucción MOVE en el Siemens Industry Online
Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Quitar entradas y salidas de una instrucción (Página 8039)
MOVE_BLK: Copiar área (Página 1196)
UMOVE_BLK: Copiar área sin interrupciones (Página 1202)
S_MOVE: Desplazar cadena de caracteres (Página 2271)
Insertar elementos FUP (Página 8017)
Editar elementos FUP (Página 8034)
Cablear operandos en instrucciones FUP (Página 8041)
Insertar entradas y salidas adicionales en los elementos FUP (Página 8038)

Deserialize: Deserializar
Descripción
La instrucción "Deserializar" reconvierte la forma de representación secuencial de un tipo de
datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> y rellena todo su contenido.
El área de memoria en la que se encuentra la forma de representación secuencial de un tipo
de datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> debe ser del tipo de datos ARRAY
of BYTE o ARRAY of CHAR y tener declarado el acceso estándar en la versión 1.0. A partir de
la versión 2.0 se permiten también áreas de memoria optimizadas. La capacidad del área de
memoria estándar es de 64 KB. Antes de la conversión asegúrese de que hay suficiente
Programación del PLC
Manual de programación y manejo, 11/2019

1185

Instrucciones
4.1 Instrucciones
memoria disponible. Si el área de memoria se ha rellenado utilizando la instrucción "Serializar"
y se han insertado bytes de relleno, estos no se tendrán en cuenta en la conversión.
Se recomienda definir a "0" el límite inferior del ARRAY, ya que entonces el índice dentro del
ARRAY se corresponde con el valor del parámetro POS, p. ej. ARRAY[0] = POS 0. La
descripción y el ejemplo que sigue más abajo se basan en estos fundamentos.
Esta instrucción reconvierte paso a paso a su estado original varias formas de representación
secuenciales de datos convertidos.
Para reconvertir una sola forma de representación secuencial de un tipo de datos PLC (UDT),
STRUCT o ARRAY of <tipo de datos> también se puede utilizar directamente la instrucción
"TRCV: Recibir datos a través de la conexión".

Tamaño del área de memoria
Debido a las reglas de alineación, no se insertan bytes de relleno en las estructuras sencillas
del área de memoria optimizada. Por consiguiente, una estructura del área de memoria
optimizada es más pequeña que en el área de memoria estándar. Los ARRAY de estructuras
y las estructuras anidadas tienen bytes de relleno. Por lo general no es posible saber de
antemano en qué área de memoria requiere más espacio una estructura compuesta.
Válido para las CPU de la serie S7-1500:
En un bloque con la propiedad "Acceso optimizado al bloque", el BOOL tiene una longitud de
1 byte. Esto hace que una estructura, que básicamente está formada por el tipo de datos
BOOL, sea mayor en el área de memoria optimizada que en el área de memoria estándar. Las
estructuras compuestas con un porcentaje reducido de tipos de datos BOOL son menores en
el área de memoria optimizada que en el área de memoria estándar.
Nota
Serialización de varias estructuras en una CPU-S7-1200
Si desea serializar varias estructuras en un búfer de una CPU-S7-1200 y establecer
comunicación con ellas (p. ej., con un sistema de control o una CPU-S7-1500), deberá
comprobar si el valor de retorno (índice del parámetro POS) es par. Si este no es el caso,
deberá incrementar el valor de retorno en 1 antes de serializar la segunda estructura, ya que
la primera estructura no se rellena con un byte de relleno.
Ejemplo:
Estructura compuesta por 1 DWORD y 1 BYTE
La dirección inicial para la siguiente estructura serializada en el búfer es 5. Añada +1 para que
la dirección inicial sea un número par.

Área de memoria optimizada
Para deserializar estructuras de mayor tamaño, el área de memoria para la representación
secuencial puede declararse también con acceso optimizado a partir de la versión de firmware
>= 4.2 de las CPU de la serie S7-1200 y a partir de la versión de firmware >= 2.0 de las CPU
de la serie S7-1500. El contenido de la representación secuencial no cambia, igual que en un
área de memoria estándar. El acceso a los bytes del ARRAY solo es posible simbólicamente.

1186

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Deserializar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

SRC_ARRA
Y

Input

ARRAY[*] of
BYTE 1)

I, Q, D, interfaz de
bloque de un FB
(son posibles las
secciones Input,
Output, Static y
Temp).

ARRAY of BYTE o ARRAY of
CHAR, en el que se guarda el
flujo de datos que debe dese‐
rializarse.

o bien
Array of CHAR

S7-1500:

Para obtener el máximo ren‐
ningún dato de pe‐ dimiento, no transfiera valo‐
riferia
res a este parámetro con un
puntero VARIANT.

DEST_VA‐
RIABLE

InOut

Todos los tipos de
datos

I, Q, D, interfaz de
bloque de un FB,

Variable, en la que se escri‐
birán los datos deserializa‐
ningún dato de pe‐ dos.
riferia
S7-1500:
Para obtener el máximo ren‐
dimiento, no transfiera valo‐
res a este parámetro con un
puntero VARIANT.

POS

InOut

DINT

I, Q, M, D, L

El operando del parámetro
POS almacena el índice del
primer byte tras el número de
bytes que ocupan los datos
de cliente convertidos. El pa‐
rámetro POS se calcula ba‐
sado en cero.

RET_VAL

Output

INT

I, Q, M, D, L

Información de error

Posible con CPU de la serie S7-1200 a partir de la versión de firmware >= 4.2 y con CPU de la serie
S7-1500 a partir de la versión de firmware >= 2.0
1)

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B0

Las áreas de memoria de los parámetros SRC_ARRAY y DEST_VARIABLE se solapan.

8136

La variable del parámetro SRC_ARRAY no está en un bloque con acceso estándar.

8150

El tipo de datos VARIANT del parámetro SRC_ARRAY contiene un puntero IGUAL A
CERO.

8151

El parámetro SRC_ARRAY no tiene una referencia válida.

8153

En el parámetro SRC_ARRAY no hay suficiente espacio de memoria disponible.

Programación del PLC
Manual de programación y manejo, 11/2019

1187

Instrucciones
4.1 Instrucciones
Código de
error*
(W#16#...)

Explicación

8154

Tipo de datos no válido en el parámetro SRC_ARRAY

8250

En el parámetro DEST_ARRAY se ha transferido un puntero CERO.

8251

El parámetro DEST_VARIABLE no tiene una referencia válida.

8382

El valor del parámetro POS se encuentra fuera de los valores límite del array.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 4.2 (S7-1200) y 2.0 (S7-1500):
El código de error siguiente tiene un significado distinto:
Código de
error*
(W#16#...)

Explicación

8136

El acceso al área de memoria en el parámetro SRC_ARRAY no es válido.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 2.8 (S7-1500):
El rendimiento de la instrucción "Deserializar" (versión 2.1) mejora si no se transfieren valores
a los parámetros SRC_ARRAY y DEST_VARIABLE con un puntero VARIANT, sino con un tipo
de datos concreto.
Tenga en cuenta que el comportamiento erróneo de la instrucción cambia en este caso. En
determinados escenarios de error, la CPU no devuelve códigos de error, sino que pasa a
STOP con un error de acceso. Para evitar que esto ocurra, utilice el tratamiento de errores local
con las instrucciones "GET_ERROR" y "GET_ERR_ID".

Ejemplo
La tabla siguiente muestra la declaración de los operandos:

1188

Operando

Tipo de datos

Declaración

DeliverPos

INT

En la sección "Input" de la inter‐
faz del bloque de un FB o una FC

BufferPos

DINT

Error

INT

En la sección "Temp" de la inter‐
faz del bloque de un FB o una FC

Label

STRING[4]

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La siguiente tabla muestra la declaración de los tipos de datos PLC:
Nombre de los tipos de datos
PLC

Nombre

Tipo de datos

Article

Number

DINT

Declaration

STRING

Colli

INT

Title

INT

First name

STRING[10]

Surname

STRING[10]

Client

La tabla siguiente muestra la declaración de los bloques de datos:
Nombre de los bloques de datos Nombre

Tipo de datos

Target

Client

"Client" (tipo de datos PLC)

Article

Array[0..10] of "Article" (tipo de
datos PLC)

Bill

Array[0..10] of INT

Field

Array[0..294] of BYTE

Buffer

El siguiente ejemplo muestra el funcionamiento de la instrucción:
Segmento 1:
029(



(1

(12

,1

287

'HVHULDOL]H
(1
%XIIHU3RV

ಯ%XIIHUಯ)LHOG
%XIIHU3RV

65&B$55$<
326

(12
5(7B9$/
'(67B9$5,$%/(

(UURU
ಯ7DUJHWಯ&OLHQW

La instrucción "Copiar valor" copia el valor "0" en el operando #BufferPos. La instrucción
"Deserializar" deserializa la forma de representación secuencial de los datos de cliente de la
variable "Buffer" y los escribe en la variable "Target". El operando #BufferPos almacena el
índice del primer byte tras el número de bytes que ocupan los datos de cliente convertidos.
Segmento 2:

Programación del PLC
Manual de programación y manejo, 11/2019

1189

Instrucciones
4.1 Instrucciones
'HVHULDOL]H
ಯ%XIIHUಯ
)LHOG
%XIIHU3RV

(12

(1
65&B$55$<
326

5(7B9$/

(UURU

'(67B9$5,$%/(

/DEHO

675,1*
DUWL
/DEHO

'HVHULDOL]H

,1
,1
ಯ%XIIHUಯ)LHOG
%XIIHU3RV

675,1*
5HFK
/DEHO

(12

(1

5(7B9$/

65&B$55$<

'(67B9$5,$%/(

326

'HVHULDOL]H

,1
,1

(1
ಯ%XIIHUಯ)LHOG
%XIIHU3RV

65&B$55$<
326

(12
5(7B9$/
'(67B9$5,$%/(

La instrucción "Deserializar" deserializa la forma de representación secuencial del separador
(depositado después de los datos de cliente en la forma de representación secuencial) de la
variable "Buffer" y escribe los caracteres en el operando #Label. Los caracteres se comparan
en relación con "arti" y "Bill" mediante instrucciones de comparación. Si la comparación en
relación con "arti" = TRUE, se trata de datos de artículo que se deserializan y se escriben en
la variable "Target". Si la comparación en relación con "Bill" = TRUE, se trata de datos de
cálculo que se deserializan y se escriben en la variable "Target".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de VARIANT (Página 335)
Principios básicos de los tipos de datos PLC (UDT) (Página 283)
Estructura de una variable ARRAY (Página 298)
Estructura de una variable STRUCT (Página 290)
Estructura de una variable STRING (Página 277)
Bytes de relleno cuando se usan tipos de datos estructurados (Página 143)
Principios básicos de FUP (Página 8005)

1190

(

ಯ7
$U
>

Programación del PLC
Manual de programación y manejo, 11/2019

(UURU

ಯ7DUJHWಯ
%LOO>'HOLYHU3

Instrucciones
4.1 Instrucciones

Serialize: Serializar
Descripción
Mediante la instrucción "Serializar" se convierten varios tipos de datos PLC (UDT), STRUCT
o ARRAY of <tipo de datos> a una forma de representación secuencial sin que se pierdan
partes de su estructura.
La instrucción permite guardar temporalmente varios datos estructurados del programa en un
búfer, ubicado preferentemente en un bloque de datos global, y enviarlos a otra CPU. El área
de memoria en la que se depositen los datos convertidos debe ser del tipo de datos ARRAY of
BYTE o ARRAY of CHAR y tener declarado el acceso estándar en la versión 1.0. A partir de
la versión 2.0 se permiten también datos optimizados. Los datos de relleno del área de datos
del origen no están definidos en el ARRAY de destino. Pueden ser tanto bytes o bits de relleno
de un área de datos (p. ej., ARRAY, STRUCT o tipo de datos PLC (UDT)) como los caracteres
de una cadena que no se utilicen en ese momento.
La capacidad del área de memoria estándar es de 64 KB. Las estructuras mayores que 64 KB
según las reglas para áreas de memoria estándar no pueden serializarse si el operando del
parámetro DEST_ARRAY está en un área de memoria estándar.
Se recomienda definir a "0" el límite inferior del ARRAY, ya que entonces el índice dentro del
ARRAY se corresponde con el valor del parámetro POS, p. ej. ARRAY[0] = POS 0. La
descripción y el ejemplo que sigue más abajo se basan en estos fundamentos.
El operando del parámetro POS contiene la información sobre el número de bytes que ocupan
los datos convertidos.
Para enviar un solo tipo de datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> se puede
llamar directamente la instrucción "TSEND: Enviar datos a través de la conexión".
Nota
Comparación de estructuras
Para comparar estructuras no es necesario serializarlas antes. En su lugar, utilice las
instrucciones "CMP".
Encontrará más información en el capítulo "Comparación".

Tamaño del área de memoria
Debido a las reglas de alineación, no se insertan bytes de relleno en las estructuras sencillas
del área de memoria optimizada. Por consiguiente, una estructura del área de memoria
optimizada es más pequeña que en el área de memoria estándar. Los ARRAY de estructuras
y las estructuras anidadas tienen bytes de relleno. Por lo general no es posible saber de
antemano en qué área de memoria requiere más espacio una estructura compuesta.
Válido para las CPU de la serie S7-1500:
En un bloque con la propiedad "Acceso optimizado al bloque", la longitud del BOOL depende
del tipo de datos que sigue. Por ejemplo, si lo que sigue es un BYTE, el BOOL tiene una
longitud de 1 byte. Si lo que sigue es WORD, el BOOL tiene una longitud de 2 bytes. Esto hace
que una estructura, que básicamente está formada por el tipo de datos BOOL, sea mayor en
el área de memoria optimizada que en el área de memoria estándar. Las estructuras

Programación del PLC
Manual de programación y manejo, 11/2019

1191

Instrucciones
4.1 Instrucciones
compuestas con un porcentaje reducido de tipos de datos BOOL son menores en el área de
memoria optimizada que en el área de memoria estándar.
Por eso se recomienda que el área de datos de origen para la serialización empiece con tipos
de datos grandes y termine con elementos booleanos. De este modo se reduce
considerablemente el relleno con bits de relleno.
Nota
Serialización de varias estructuras en una CPU-S7-1200
Si desea serializar varias estructuras en un búfer de una CPU-S7-1200 y establecer
comunicación con ellas (p. ej., con un sistema de control o una CPU-S7-1500), deberá
comprobar si el valor de retorno (índice del parámetro POS) es par. Si este no es el caso,
deberá incrementar el valor de retorno en 1 antes de serializar la segunda estructura, ya que
la primera estructura no se rellena con un byte de relleno.
Ejemplo:
Estructura compuesta por 1 DWORD y 1 BYTE
La dirección inicial para la siguiente estructura serializada en el búfer es 5. Añada +1 para que
la dirección inicial sea un número par.

Área de memoria optimizada
Para serializar estructuras de mayor tamaño, el área de memoria puede declararse también
con acceso optimizado a partir de la versión de firmware >= 4.2 de las CPU de la serie S7-1200
y a partir de la versión de firmware >= 2.0 de las CPU de la serie S7-1500. La representación
secuencial no cambia, igual que en un área de memoria estándar.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Serializar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

Todos los tipos de
datos

D, interfaz de blo‐
que de un FB, no
datos de periferia

Variable que se serializará.

D, interfaz de blo‐
que de un FB (son
posibles las sec‐
ciones Input, Out‐
put, Static y Temp)

Array en el que se guarda el
flujo de datos generado.

SRC_VARIA‐ Input
BLE

DEST_ARRA InOut
Y

ARRAY of BYTE o
ARRAY of CHAR

S7-1500:
Para obtener el máximo ren‐
dimiento, no transfiera valo‐
res a este parámetro con un
puntero VARIANT.

S7-1500:

Para obtener el máximo ren‐
dimiento, no transfiera valo‐
ningún dato de pe‐ res a este parámetro con un
riferia
puntero VARIANT.

1192

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

POS

InOut

DINT

I, Q, M, D, L

El operando del parámetro
POS almacena el índice del
primer byte tras el número to‐
tal de bytes que han ocupado
los datos de cliente converti‐
dos. El parámetro POS se
calcula basado en cero.

RET_VAL

Output

INT

I, Q, M, D, L

Información de error

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B0

Las áreas de memoria de los parámetros SRC_VARIABLE y DEST_ARRAY se solapan.

8150

El tipo de datos VARIANT del parámetro SRC_VARIABLE contiene un puntero IGUAL A
CERO.

8151

El parámetro SRC_VARIABLE no tiene una referencia válida.

8236

La variable del parámetro SRC_ARRAY no está en un bloque con acceso estándar.

8250

En el parámetro DEST_ARRAY se ha transferido un puntero NULL.

8251

El parámetro DEST_ARRAY no tiene una referencia válida.

8253

La variable del parámetro DEST_ARRAY no ofrece suficiente espacio de memoria para
el contenido de la variable del parámetro SRC_VARIABLE. El valor de entrada de la
variable del parámetro POS reduce el espacio de memoria disponible. El valor de entrada
del parámetro POS determina en qué posición de la variable se comienza en el parámetro
DEST_ARRAY.

8254

Tipo de datos no válido en el parámetro DEST_ARRAY

8382

El valor del parámetro POS se encuentra fuera de los valores límite del array.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 4.2 (S7-1200) y 2.0 (S7-1500):
El código de error siguiente tiene un significado distinto:
Código de
error*
(W#16#...)

Explicación

8236

El acceso al área de memoria en el parámetro DEST_ARRAY no es válido.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 2.8 (S7-1500):

Programación del PLC
Manual de programación y manejo, 11/2019

1193

Instrucciones
4.1 Instrucciones
El rendimiento de la instrucción "Serializar" (versión 2.1) mejora si no se transfieren valores a
los parámetros SRC_VARIABLE y DEST_ARRAY con un puntero VARIANT, sino con un tipo
de datos concreto.
Tenga en cuenta que el comportamiento erróneo de la instrucción cambia en este caso. En
determinados escenarios de error, la CPU no devuelve códigos de error, sino que pasa a
STOP con un error de acceso. Para evitar que esto ocurra, utilice el tratamiento de errores local
con las instrucciones "GET_ERROR" y "GET_ERR_ID".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
Segmento 1:
029(



6HULDOL]H

(1

(12

,1

287

(12

(1
%XIIHU3RV

ಯ6RXUFHಯ&OLHQW

5(7B9$/

65&B9$5,$%/(

'(67B$55$<

326

%XIIHU3RV

(UURU
ಯ%XIIHUಯ)LHOG

La instrucción "Copiar valor" copia el valor "0" en el operando #BufferPos. La instrucción
"Deserializar" serializa los datos de cliente de la variable "Source" y los escribe, en
representación secuencial, en la variable "Buffer". El índice del siguiente byte no escrito del
operando "Buffer".Field se almacena en el operando #BufferPos.
Segmento 2:
6B029(

ಭDUWLಫ

(1

(12

,1

287

6HULDOL]H
(12

(1
/DEHO

/DEHO
%XIIHU3RV

65&B9$5,$%/(

5(7B9$/
'(67B$55$<

326

(UURU
ಯ%XIIHUಯ)LHOG

Para facilitar la posterior deserialización de la forma de representación secuencial, ahora se
inserta una especie de separador. La instrucción "Desplazar cadena de caracteres" copia los
caracteres "arti" en el operando #Label. La instrucción "Serializar" escribe estos caracteres,
tras los datos de cliente, en la variable "Buffer". Se incrementa correspondientemente el valor
del operando "#BufferPos".
Segmento 3:
6HULDOL]H
(1
ಯ6RXUFHಯ
$UWLFOH>'HOLYHU3RV@
%XIIHU3RV

65&B9$5,$%/(
326

(12
5(7B9$/
'(67B$55$<

(UURU
ಯ%XIIHUಯ)LHOG

La instrucción "Serializar" serializa los datos de un determinado artículo, que se calcula en
tiempo de ejecución, de la variable "Source", y los escribe en forma de representación
secuencial después de los caracteres "arti" en la variable "Buffer".

1194

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra la declaración de los operandos:
Operando

Tipo de datos

Declaración

DeliverPos

INT

En la sección "Input" de la inter‐
faz del bloque

BufferPos

DINT

En la sección "Temp" de la inter‐
faz del bloque

Error

INT

En la sección "Temp" de la inter‐
faz del bloque

Label

STRING[4]

En la sección "Temp" de la inter‐
faz del bloque

La siguiente tabla muestra la declaración de los tipos de datos PLC:
Nombre de los tipos de datos
PLC

Nombre

Tipo de datos

Article

Number

DINT

Declaration

STRING

Colli

INT

Title

INT

First name

STRING[10]

Surname

STRING[10]

Client

La tabla siguiente muestra la declaración de los bloques de datos:
Nombre de los bloques de datos Nombre

Tipo de datos

Source

Client

"Client" (tipo de datos PLC)

Article

Array[0..10] of "Article" (tipo de
datos PLC)

Field

Array[0..294] of BYTE

Buffer

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de VARIANT (Página 335)
Principios básicos de los tipos de datos PLC (UDT) (Página 283)
Estructura de una variable ARRAY (Página 298)
Estructura de una variable STRUCT (Página 290)
Estructura de una variable STRING (Página 277)
Bytes de relleno cuando se usan tipos de datos estructurados (Página 143)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1195

Instrucciones
4.1 Instrucciones

MOVE_BLK: Copiar área
Descripción
La instrucción "Copiar área" permite copiar los contenidos de un área de memoria (área de
origen) en un área de memoria diferente (área de destino). El número de elementos que se
copian en el área de destino se determina con el parámetro COUNT. El ancho del elemento de
la entrada IN define el ancho de los elementos que deben copiarse.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Se copian más datos de los que están disponibles en la entrada IN o en la salida OUT.
Si se copia un ARRAY of BOOL, en caso de desbordamiento la salida de habilitación ENO
permanece a "1" hasta que se rebasa el límite de byte de la estructura ARRAY. Si el valor de
la entrada COUNT rebasa el límite del byte de la estructura ARRAY, la salida de habilitación
ENO se pone a "0".
Nota
Uso de ARRAYs
La instrucción copia el contenido a partir del elemento definido n elementos (n = depende del
valor del parámetro COUNT) desde el área de origen al área de destino, comenzando por el
índice especificado.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Copiar área":

1196

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

S7-1200

S7-1500

S7-1200

S7-1500

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

IN 1)

Input

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD

Números bi‐ D, L
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD, LTOD

D, L

Primer ele‐
mento del
área de ori‐
gen que se
copia

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1500

S7-1200

I, Q, M, D, L, I, Q, M, D, L, Número de
P o constan‐ P o constan‐ elementos
te
te
que se co‐
pian del
área de ori‐
gen al área
de destino

COUNT

Input

USINT,
UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

OUT 1)

Output

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD

Números bi‐ D, L
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD, LTOD

1)

Descripción

S7-1200

S7-1500

D, L

Primer ele‐
mento del
área de des‐
tino en la
que se co‐
pian los con‐
tenidos del
área de ori‐
gen

Los tipos de datos indicados solamente pueden utilizarse como elementos de una estructura ARRAY.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ7DJ,QBಯ
ಯ7DJ,QBಯ
DBDUUD\>@

029(B%/.
(1
,1

287

EBDUUD\>@
ಯ7DJ2XWಯ

ಯ7DJB&RXQWಯ

&2817 (12

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

a_array[2]

El operando "a_array" es del tipo
de datos ARRAY [0..5] of INT.
Consta de 6 elementos del tipo
de datos INT.

COUNT

Tag_Count

3

OUT

b_array[1]

El operando "b_array" es del tipo
de datos ARRAY [0..6] of INT.
Consta de 7 elementos del tipo
de datos INT.

Si los operandos "TagIn_1" y "TagIn_2" devuelven el estado lógico "1", se ejecuta la
instrucción. La instrucción selecciona a partir del tercer elemento tres elementos INT de la
variable #a_array y copia su contenido en la variable de salida #b_array, comenzando por el

Programación del PLC
Manual de programación y manejo, 11/2019

1197

Instrucciones
4.1 Instrucciones
segundo elemento. Si no ocurren errores al ejecutar la instrucción, la salida de habilitación
ENO devuelve el estado lógico "1" y se activa la salida "TagOut".
Nota
Encontrará más información sobre la instrucción MOVE_BLK en el Siemens Industry Online
Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Insertar elementos FUP (Página 8017)
Editar elementos FUP (Página 8034)
Cablear operandos en instrucciones FUP (Página 8041)

MOVE_BLK_VARIANT: Copiar área
Descripción
La instrucción "Copiar área" copia los contenidos de un área de memoria (área de origen) en
un área de memoria diferente (área de destino). Se pueden copiar elementos de un ARRAY o
un ARRAY completo en otro ARRAY del mismo tipo de datos. El tamaño (número de
elementos) de los ARRAY de origen y de destino puede diferir. Se pueden copiar varios
elementos dentro de un mismo ARRAY o bien copiar elementos individuales.
El número de elementos que deben copiarse no puede rebasar el área de origen o destino
seleccionado.
Cuando se utiliza la instrucción no es necesario conocer el ARRAY en el momento de crear el
bloque, puesto que el origen y el destino se transfieren vía VARIANT.
El recuento en los parámetros SRC_INDEX y DEST_INDEX comienza siempre por el límite
inferior "0", independientemente de la declaración posterior del ARRAY.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Se copian más datos de los que hay disponibles.

1198

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Copiar área":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

SRC

Input

VARIANT (que
apunta a un
ARRAY o a un ele‐
mento individual
del ARRAY),
ARRAY of <tipo de
datos>

L (puede declarar‐ El área de origen de la que se
se en las seccio‐
copia
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

COUNT

Input

UDINT

I, Q, M, D, L o
constante

2)

Número de elementos que
se copian
Asigne al parámetro COUNT
el valor "1" si en el parámetro
SRC o en el parámetro DEST
no hay indicado ningún
ARRAY.

SRC_INDEX

Input

DINT

I, Q, M, D, L o
constante

Define el primer elemento
que se copia:
● El parámetro
SRC_INDEX se calcula
basado en cero. Si en el
parámetro SRC hay
indicado un ARRAY, el
entero del parámetro
SRC_INDEX indica el
primer elemento del área
de origen de la que debe
copiarse. Esto es así
independientemente de
los límites declarados del
ARRAY.
● Si en el parámetro SRC
no hay indicado ningún
ARRAY o solo un
elemento individual de un
ARRAY, asigne el valor
"0" al parámetro
SRC_INDEX.

Programación del PLC
Manual de programación y manejo, 11/2019

1199

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

DEST_IN‐
DEX

Input

DINT

I, Q, M, D, L o
constante

Define el inicio del área de
memoria de destino:
● El parámetro
DEST_INDEX se calcula
basado en cero. Si en el
parámetro DEST hay
indicado un ARRAY, el
entero del parámetro
DEST_INDEX indica el
primer elemento del área
de destino en la que debe
copiarse. Esto es así
independientemente de
los límites declarados del
ARRAY.
● Si en el parámetro DEST
no hay indicado ningún
ARRAY, asigne el valor
"0" al parámetro
DEST_INDEX.

DEST

Output 1)

VARIANT

L (puede declarar‐ Área de destino a la que se
se en las seccio‐
copia el contenido del área
nes "Input",
de origen.
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

INT

I, Q, M, D, L

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

1) El parámetro DEST está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.
2) En el parámetro SRC, los tipos de datos BOOL y ARRAY of BOOL no están permitidos.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)

1200

0000

Ningún error

80B4

Los tipos de datos no coinciden. En lugar de un ARRAY of Struct utilice un ARRAY of tipo
de datos PLC (UDT).

8151

No es posible acceder al parámetro SRC.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*

Explicación

(W#16#...)
8152

El operando del parámetro SRC no está tipificado.

8153

Error de creación de código en el parámetro SRC

8154

El operando del parámetro SRC es del tipo de datos BOOL.

8281

Valor no válido en el parámetro COUNT

8382

El valor del parámetro SRC_INDEX es menor que CERO.

8383

El valor del parámetro SRC_INDEX se encuentra fuera del límite superior del ARRAY.

8482

El valor del parámetro DEST_INDEX se encuentra fuera de los límites del ARRAY.

8483

El ARRAY al que señala el parámetro DEST es demasiado pequeño para los datos que
deben copiarse.

8534

El parámetro DEST está protegido contra escritura

8551

No es posible acceder al parámetro DEST.

8552

El operando del parámetro DEST no está tipificado.

8553

Error de creación de código en el parámetro DEST

8554

El operando del parámetro DEST es del tipo de datos BOOL.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
029(B%/.B9$5,$17
ಯ7DJ,Qಯ
6UF)LHOG
ಯ7DJB&RXQWಯ

(1

ಯ7DJ2XWಯ

(12

65&
&2817

ಯ7DJB6UFB,QGH[ಯ

65&B,1'(;

ಯ7DJB'HVWB,QGH[ಯ

'(67B,1'(;

5(7B9$/
'(67

ಯ7DJB5HVXOWಯ
'HVW)LHOG

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Declaración en la inter‐
faz del bloque

Operando

Valor

SRC

Input

#SrcField

El operando local
#SrcField utiliza un tipo
de datos PLC todavía
desconocido en el mo‐
mento de programar el
bloque. (ARRAY[0..10]
of "MOVE_UDT"

COUNT

Input

Tag_Count

2

SRC_INDEX

Input

Tag_Src_Index

3

Programación del PLC
Manual de programación y manejo, 11/2019

1201

Instrucciones
4.1 Instrucciones
Parámetro

Declaración en la inter‐
faz del bloque

Operando

Valor

DEST_INDEX

Input

Tag_Dest_Index

3

DEST

InOut

#DestField

El operando local
#DestField utiliza un ti‐
po de datos PLC toda‐
vía desconocido en el
momento de programar
el bloque.
(ARRAY[10..20] of "MO‐
VE_UDT"

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. En el área de
destino se copian dos elementos del área de origen, empezando por el cuarto elemento del
ARRAY[0..10] of MOVE_UDT. Las copias se insertan en el ARRAY[10..20] of MOVE_UDT a
partir del cuarto elemento. Si no se producen errores al ejecutar la instrucción, la salida de
habilitación ENO devuelve el estado lógico TRUE y la salida "TagOut" se activa.
Nota
Encontrará más información sobre la instrucción MOVE_BLK_VARIANT en el Siemens
Industry Online Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
VariantGet: Leer valor de una variable VARIANT (Página 1246)
Ejemplo de movimiento de datos (Página 344)
Principios básicos de VARIANT (Página 335)
Principios básicos de FUP (Página 8005)

UMOVE_BLK: Copiar área sin interrupciones
Descripción
La instrucción "Copiar área sin interrupciones" copia sin interrupciones los contenidos de un
área de memoria (área de origen) en un área de memoria diferente (área de destino). El
número de elementos que se copian en el área de destino se determina con el parámetro
COUNT. El ancho del elemento de la entrada IN define el ancho de los elementos que deben
copiarse.

1202

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
Nota
La operación de copia no debe ser interrumpida por otras actividades del sistema operativo.
Por este motivo, los tiempos de reacción a alarmas de la CPU podrían aumentar al ejecutar la
instrucción "Copiar área sin interrupciones".
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Se copian más datos de los que están disponibles en la entrada IN o en la salida OUT.
Si se copia un ARRAY of BOOL, en caso de desbordamiento la salida de habilitación ENO
permanece a "1" hasta que se rebasa el límite de byte de la estructura ARRAY. Si el valor de
la entrada COUNT rebasa el límite del byte de la estructura ARRAY, la salida de habilitación
ENO se pone a "0".
Nota
Uso de ARRAYs
La instrucción copia el contenido a partir del elemento definido n elementos (n = depende del
valor del parámetro COUNT) desde el área de origen al área de destino, comenzando por el
índice especificado.
La instrucción "Copiar área sin interrupciones" permite copiar 16 KB como máximo. A este
respecto deben tenerse en cuenta las limitaciones específicas de la CPU.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Copiar área sin interrupciones":
Parámetro

Declaración

S7-1200

S7-1500

S7-1200

S7-1500

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

IN 1)

Input

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD

Números bi‐ D, L
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD, LTOD

D, L

Primer ele‐
mento del
área de ori‐
gen que se
copia

Programación del PLC
Manual de programación y manejo, 11/2019

Tipo de datos

Área de memoria

Descripción

1203

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1500

S7-1200

I, Q, M, D, L, I, Q, M, D, L, Número de
P o constan‐ P o constan‐ elementos
te
te
que se co‐
pian del
área de ori‐
gen al área
de destino

COUNT

Input

USINT,
UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

OUT 1)

Output

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD

Números bi‐ D, L
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD, LTOD

1)

Descripción

S7-1200

S7-1500

D, L

Primer ele‐
mento del
área de des‐
tino en la
que se co‐
pian los con‐
tenidos del
área de ori‐
gen

Los tipos de datos indicados solamente pueden utilizarse como elementos de una estructura Array.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ7DJ,QBಯ
ಯ7DJ,QBಯ
DBDUUD\>@

8029(B%/.
(1
,1

287

EBDUUD\>@
ಯ7DJ2XWಯ

ಯ7DJB&RXQWಯ

&2817 (12

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

a_array[2]

El operando "a_array" es del tipo
de datos ARRAY[0..5] of INT.
Consta de 6 elementos del tipo
de datos INT.

COUNT

Tag_Count

3

OUT

b_array[1]

El operando "b_array" es del tipo
de datos ARRAY[0..6] of INT.
Consta de 7 elementos del tipo
de datos INT.

Si los operandos "TagIn_1" y "TagIn_2" devuelven el estado lógico "1", se ejecuta la
instrucción. La instrucción selecciona a partir del tercer elemento tres elementos INT de la
variable #a_array y copia su contenido en la variable de salida #b_array, comenzando por el
segundo elemento. La operación de copia no debe ser interrumpida por otras actividades del

1204

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
sistema operativo. Si no ocurren errores al ejecutar la instrucción, la salida de habilitación ENO
devuelve el estado lógico "1" y se activa la salida "TagOut".
Nota
Encontrará más información sobre la instrucción UMOVE_BLK en el Siemens Industry Online
Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Insertar elementos FUP (Página 8017)
Editar elementos FUP (Página 8034)
Cablear operandos en instrucciones FUP (Página 8041)

FILL_BLK: Rellenar área
Descripción
La instrucción "Rellenar área" permite rellenar un área de memoria (área de destino) con el
valor de la entrada IN. El área de destino se rellena a partir de la dirección indicada en la salida
OUT. El número de repeticiones de copia se determina mediante el parámetro COUNT. Al
ejecutar la instrucción, el valor de la entrada IN se copia en el área de destino el número de
veces especificado por el valor del parámetro COUNT.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Como máximo se modifican tantos elementos como tiene el ARRAY o la estructura. Si se
copian más datos que los elementos disponibles en la salida OUT, el resultado no será el
deseado.
Si se copia un ARRAY of BOOL, en caso de desbordamiento la salida de habilitación ENO
permanece a "1" hasta que se rebasa el límite de byte de la estructura ARRAY. Si el valor de

Programación del PLC
Manual de programación y manejo, 11/2019

1205

Instrucciones
4.1 Instrucciones
la entrada COUNT rebasa el límite del byte de la estructura ARRAY, la salida de habilitación
ENO se pone a "0".
Nota
Uso de ARRAYs
La instrucción lee en el área de origen el contenido del elemento seleccionado y lo copia n
veces (n = depende del valor del parámetro COUNT) en el área de destino, comenzado a partir
del índice especificado.

Rellenar estructuras
Además de los elementos de un ARRAY, también es posible rellenar varios elementos de una
estructura (STRUCT, tipo de datos PLC) con el mismo valor. La estructura cuyos elementos
deben rellenarse puede contener únicamente elementos individuales del mismo tipo de datos
elemental. No obstante, la estructura propiamente dicha puede estar incrustada en otra
estructura.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Rellenar área":
Parámetro

1206

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D,
L o cons‐
tante

I, Q, M, D, L, Entrada de ha‐
T, C o cons‐ bilitación
tante

ENO

Output

BOOL

BOOL

I, Q, M, D,
L

I, Q, M, D, L Salida de habi‐
litación

IN

Input

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, TOD,
CHAR,
WCHAR

Números bi‐ I, Q, M, D,
narios, ente‐ L, P o
ros, núme‐
constante
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD, LTOD

I, Q, M, D, L, Elemento con
P o constan‐ el que se relle‐
te
na el área de
destino

COUNT

Input

USINT,
UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

I, Q, M, D, L, Número de re‐
P o constan‐ peticiones de
te
copia

OUT

Output

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, TOD,
CHAR,
WCHAR

Números bi‐ D, L
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD, LTOD

I, Q, M, D,
L, P o
constante

D, L

Dirección del
área de desti‐
no a partir de
la cual se relle‐
na

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
El siguiente ejemplo muestra el funcionamiento de la instrucción cuando debe rellenarse un
ARRAY:
ಯ7DJ,QBಯ
),//B%/.

ಯ7DJ,QBಯ

(1
)LOO9DOXH

,1

287

7DUJHW$UHD>@
ಯ7DJ2XWಯ

ಯ7DJB&RXQWಯ

&2817 (12

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

FillValue

El operando es del tipo de datos
INT.

COUNT

Tag_Count

3

OUT

TargetArea

El operando TargetArea es del
tipo de datos ARRAY[1..5] of
INT. Consta de 5 elementos del
tipo de datos INT.

Si los operandos "TagIn_1" y "TagIn_2" devuelven el estado lógico "1", se ejecuta la
instrucción. La instrucción copia tres veces el valor del operando #FillValue en la variable de
salida #TargetArea, empezando por el primer elemento. Si no se producen errores al ejecutar
la instrucción, el operando "TagOut" adopta el estado lógico "1" en la salida de habilitación
ENO.

Ejemplos con una estructura
Los siguientes ejemplos muestran el funcionamiento de la instrucción cuando debe rellenarse
una estructura.
Cree un bloque de datos global con los elementos siguientes:
Data_block_1

Tipo de datos

MyStruct1

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

MyStruct2

Programación del PLC
Manual de programación y manejo, 11/2019

STRUCT

1207

Instrucciones
4.1 Instrucciones
Data_block_1

Tipo de datos

SubArray

ARRAY[1..2] of STRUCT

SubArray[1]

STRUCT

NestedStruct

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

SubArray[2]

STRUCT

Nes‐
tedStruct

STRUCT
Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

Cree el código de programa siguiente para direccionar la variable MyStruct1:
),//B%/.
(1



287

ಯ'DWDBEORFNBಯ
0\6WUXFW
0HPEHUB

(12

ಯ7DJ2XWಯ

,1
&2817

Cree el código de programa siguiente para direccionar la variable MyStruct2:
),//B%/.
(1



287

ಯ'DWDBEORFNBಯ0\6WUXFW
6XE$UUD\>@1HVWHG6WUXFW
0HPEHUB

(12

ಯ7DJ2XWಯ

,1
&2817

En ambos ejemplos, el valor 10 del parámetro IN se copia dos veces en el operando del
parámetro OUT, empezando por el elemento Member_2. Esto significa que el valor 10 se copia
tanto en el elemento Member_2 como en el Member_3. Los otros dos elementos, Member_1
y Member_4, no cambian. Si no se producen errores al ejecutar la instrucción, el operando
"TagOut" adopta el estado lógico "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

1208

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

UFILL_BLK: Rellenar área sin interrupciones
Descripción
La instrucción "Rellenar área sin interrupciones" rellena sin interrupciones un área de memoria
(área de destino) con el valor de la entrada IN. El área de destino se rellena a partir de la
dirección indicada en la salida OUT. El número de repeticiones de copia se determina
mediante el parámetro COUNT. Al ejecutar la instrucción, el valor de la entrada IN se copia en
el área de destino el número de veces especificado por el valor del parámetro COUNT.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
Nota
La operación de copia no debe ser interrumpida por otras actividades del sistema operativo.
Por este motivo, los tiempos de reacción a alarmas de la CPU podrían aumentar al ejecutar la
instrucción "Rellenar área sin interrupciones".
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Como máximo se modifican tantos elementos como tiene el ARRAY o la estructura. Si se
copian más datos que los elementos disponibles en la salida OUT, el resultado no será el
deseado.
Si se copia un ARRAY of BOOL, en caso de desbordamiento la salida de habilitación ENO
permanece a "1" hasta que se rebasa el límite de byte de la estructura ARRAY. Si el valor de
la entrada COUNT rebasa el límite del byte de la estructura ARRAY, la salida de habilitación
ENO se pone a "0".
Nota
Uso de ARRAYs
La instrucción lee en el área de origen el contenido del elemento seleccionado y lo copia n
veces (n = depende del valor del parámetro COUNT) en el área de destino, comenzado a partir
del índice especificado.
La instrucción "Rellenar área sin interrupciones" permite copiar 16 KB como máximo. A este
respecto deben tenerse en cuenta las limitaciones específicas de la CPU.

Rellenar estructuras
Además de los elementos de un ARRAY, también es posible rellenar varios elementos de una
estructura (STRUCT, tipo de datos PLC) con el mismo valor. La estructura cuyos elementos
deben rellenarse puede contener únicamente elementos individuales del mismo tipo de datos
elemental. No obstante, la estructura propiamente dicha puede estar incrustada en otra
estructura.

Programación del PLC
Manual de programación y manejo, 11/2019

1209

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Rellenar área sin interrupciones":
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

IN

Input

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD

Números bi‐ I, Q, M, D, L, I, Q, M, D, L,
narios, ente‐ P o constan‐ P o constan‐
ros, núme‐
te
te
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD, LTOD

Elemento
con el que
se rellena el
área de des‐
tino

COUNT

Input

USINT,
UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

OUT

Output

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD

Números bi‐ D, L
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, CHAR,
WCHAR,
TOD, LTOD

I, Q, M, D, L, I, Q, M, D, L, Número de
P o constan‐ P o constan‐ repeticiones
te
te
de copia
D, L

Dirección
del área de
destino a
partir de la
cual se relle‐
na

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
El siguiente ejemplo muestra el funcionamiento de la instrucción cuando debe rellenarse un
ARRAY:
ಯ7DJ,QBಯ
8),//B%/.

ಯ7DJ,QBಯ

(1
)LOO9DOXH

,1

287

7DUJHW$UHD>@
ಯ7DJ2XWಯ

ಯ7DJB&RXQWಯ

1210

&2817 (12

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

FillValue

El operando es del tipo de datos
INT.

COUNT

Tag_Count

3

OUT

TargetArea

El operando TargetArea es del
tipo de datos ARRAY[1..5] of
INT. Consta de 5 elementos del
tipo de datos INT.

Si los operandos "TagIn_1" y "TagIn_2" devuelven el estado lógico "1", se ejecuta la
instrucción. La instrucción copia tres veces el valor del operando #FillValue en la variable de
salida #TargetArea, empezando por el primer elemento. La operación de copia no debe ser
interrumpida por otras actividades del sistema operativo. Si no se producen errores al ejecutar
la instrucción, el operando "TagOut" adopta el estado lógico "1" en la salida de habilitación
ENO.

Ejemplos con una estructura
Los siguientes ejemplos muestran el funcionamiento de la instrucción cuando debe rellenarse
una estructura.
Cree un bloque de datos global con los elementos siguientes:
Data_block_1

Tipo de datos

MyStruct1

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

MyStruct2

STRUCT

SubArray

ARRAY[1..2] of STRUCT

SubArray[1]

STRUCT

NestedStruct

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

SubArray[2]

STRUCT

Nes‐
tedStruct

STRUCT
Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

Cree el código de programa siguiente para direccionar la variable MyStruct1:

Programación del PLC
Manual de programación y manejo, 11/2019

1211

Instrucciones
4.1 Instrucciones
8),//B%/.
(1



287

ಯ'DWDBEORFNBಯ
0\6WUXFW
0HPEHUB

(12

ಯ7DJ2XWಯ

,1
&2817

Cree el código de programa siguiente para direccionar la variable MyStruct2:
8),//B%/.
(1



287

ಯ'DWDBEORFNBಯ0\6WUXFW
6XE$UUD\>@1HVWHG6WUXFW
0HPEHUB

(12

ಯ7DJ2XWಯ

,1
&2817

En ambos ejemplos, el valor 10 del parámetro IN se copia dos veces en el operando del
parámetro OUT, empezando por el elemento Member_2. Esto significa que el valor 10 se copia
tanto en el elemento Member_2 como en el Member_3. Los otros dos elementos, Member_1
y Member_4, no cambian. Si no se producen errores al ejecutar la instrucción, el operando
"TagOut" adopta el estado lógico "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

SCATTER: Dispersión de una secuencia de bits en bits individuales
Descripción
La instrucción "Dispersión de una secuencia de bits en bits individuales" descompone una
variable del tipo de datos BYTE, WORD, DWORD o LWORD en bits individuales y los guarda
en un ARRAY of BOOL, un STRUCT anónimo o un tipo de datos PLC con elementos
booleanos exclusivamente.
Nota
ARRAY of BOOL multidimensional
En la instrucción "Dispersión de una secuencia de bits en bits individuales" no está permitido
utilizar un ARRAY of BOOL multidimensional.

1212

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Nota
Longitud del ARRAY, del STRUCT o del tipo de datos PLC
El ARRAY, el STRUCT anónimo o el tipo de datos PLC deben tener tantos elementos como se
especifique en la secuencia de bits.
Es decir, en el tipo de datos BYTE, p. ej., el ARRAY, el STRUCT o el tipo de datos PLC deben
tener exactamente 8 elementos (WORD = 16, DWORD = 32 y LWORD = 64).
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1200 a partir de la versión de firmware
>4.2 y en las CPU de la serie S7-1500 a partir de la versión de firmware 2.1.
De este modo es posible, p. ej., descomponer una palabra de estado y leer y modificar por
índice el estado de los bits individuales. Mediante GATHER pueden juntarse nuevamente los
bits en una secuencia de bits.
La salida de habilitación ENO devuelve el estado lógico "0" si se cumple una de las siguientes
condiciones:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El ARRAY, STRUCT o tipo de datos PLC no proporciona suficientes elementos BOOL.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐ Descripción
ria

EN

Input

BOOL

BOOL

I, Q, M, D, L o
constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

Salida de habili‐
tación

Programación del PLC
Manual de programación y manejo, 11/2019

1213

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

IN

Tipo de datos

Input

OUT

Output

S7-1200

S7-1500

BYTE, WORD,
DWORD

BYTE,
WORD,
DWORD,
LWORD

ARRAY[*] of
BOOL,
STRUCT o tipo
de datos PLC
*: 8, 16, 32 o 64
elementos

Área de memo‐ Descripción
ria
I, Q, M, D, L

Secuencia de
bits que se des‐
compone.
Los valores no
pueden encon‐
trarse en el
área de perife‐
ria o en el DB
de un objeto
tecnológico.

ARRAY[*] of I, Q, M, D, L
BOOL,
STRUCT o
tipo de datos
PLC
*: 8, 16, 32 o
64 elemen‐
tos

ARRAY,
STRUCT o tipo
de datos PLC
en el/los que se
guardan los
bits individuales

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

Enable

Input

BOOL

SourceWord

WORD

EnableOut

Output

DestinationArray

BOOL
ARRAY[0..15] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucción:
6&$77(5
:25'
(QDEOH
6RXUFH:RUG

(1

287

,1

(12

'HVWLQDWLRQ$UUD\
(QDEOH2XW

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:

1214

Parámetro

Operando

Tipo de datos

IN

SourceWORD

WORD (16 bits)

OUT

DestinationArray

El operando "DestinationArray"
es del tipo de datos
ARRAY[0..15] of BOOL. Consta
de 16 elementos y, por tanto, tie‐
ne el mismo tamaño que la
WORD que se debe descompo‐
ner.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si el operando #Enable devuelve el estado lógico "1" en la entrada de habilitación EN, se
ejecuta la instrucción. El operando #SourceWord del tipo de datos WORD se descompone en
sus bits individuales (16) y se asigna a los distintos elementos del operando #DestinationArray.
Si ocurre un error durante la ejecución de la instrucción, el operando #EnableOut devuelve el
estado lógico "0" en la salida de habilitación ENO.

Ejemplo con un tipo de datos PLC (UDT)
Cree el siguiente tipo de datos PLC "myBits":

Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

Enable

Input

BOOL

SourceWord

WORD

EnableOut

Output

DestinationUDT

BOOL
"myBits"

El siguiente ejemplo muestra el funcionamiento de la instrucción:
6&$77(5
:25'
(QDEOH
6RXUFH:RUG

(1

287

,1

(12

Programación del PLC
Manual de programación y manejo, 11/2019

'HVWLQDWLRQ8'7
(QDEOH2XW

1215

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceWord

WORD (16 bits)

OUT

DestinationUDT

El operando "DestinationUDT"
es del tipo de datos PLC (UDT).
Consta de 16 elementos y, por
tanto, tiene el mismo tamaño
que la WORD que se debe des‐
componer.

Si el operando #Enable devuelve el estado lógico "1" en la entrada de habilitación EN, se
ejecuta la instrucción. El operando #SourceWord del tipo de datos WORD se descompone en
sus bits individuales (16) y se asigna a los distintos elementos del operando #DestinationUDT.
Si ocurre un error durante la ejecución de la instrucción, el operando #EnableOut devuelve el
estado lógico "0" en la salida de habilitación ENO.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

1216

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

SCATTER_BLK: Dispersión de elementos de un ARRAY of secuencia de bits en bits individuales
Descripción
La instrucción "Dispersión de elementos de un ARRAY of secuencia de bits en bits
individuales" descompone uno o varios elementos de un ARRAY of BYTE, WORD, DWORD
o LWORD en bits individuales y los guarda en un ARRAY of BOOL, un STRUCT anónimo o un
tipo de datos PLC con elementos booleanos exclusivamente. En el parámetro COUNT_IN se
introduce el número de elementos del ARRAY de origen que deben dispersarse. El ARRAY de
origen en el parámetro IN puede tener más elementos que los indicados en el parámetro
COUNT_IN. El ARRAY of BOOL, el STRUCT anónimo o el tipo de datos PLC deben tener
suficientes elementos para poder guardar los bits de la secuencia de bits descompuesta. El
área de memoria de destino también puede ser mayor.
Nota
ARRAY of BOOL multidimensional
Si el ARRAY es un ARRAY of BOOL multidimensional, se cuentan también los bits de relleno
de las dimensiones contenidas, aunque no se hayan declarado explícitamente.
Ejemplo 1: un ARRAY[1..10,0..4,1..2] of BOOL recibe el mismo tratamiento que un
ARRAY[1..10,0..4,1..8] of BOOL o que un ARRAY[0..399] of BOOL.
Ejemplo 2: En el parámetro IN hay un ARRAY[0..5] of WORD (sourceArrayWord[2])
interconectado. El parámetro COUNT_IN tiene el valor "3". En el parámetro OUT hay un
ARRAY[0..1,0..5,0..7] of BOOL (destinationArrayBool[0,0,0]) interconectado. Tanto el array
del parámetro IN como el del parámetro OUT tienen 96 bits de tamaño. El ARRAY of WORD
se descompone en 48 bits individuales.
Nota
Si el límite inferior del ARRAY de destino no es "0", cabe considerar lo siguiente:
Por motivos de rendimiento, el índice debe comenzar siempre en un límite de BYTE, WORD,
DWORD o LWORD. Esto significa que debe calcularse el índice partiendo del límite inferior del
ARRAY. Como base para el cálculo se utiliza la siguiente fórmula:
Índice válido = límite inferior del ARRAY + n(número de secuencias de bits) * número de bits
de la secuencia de bits deseada
Para un ARRAY[-2..45] of BOOL y la secuencia de bits WORD, el cálculo es el siguiente:
● Índice válido (-2) = -2 + 0 * 16
● Índice válido (14) = -2 + 1 * 16
● Índice válido (30) = -2 + 2 * 16
Ver un ejemplo más adelante.
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1200 a partir de la versión de firmware
>4.2 y en las CPU de la serie S7-1500 a partir de la versión de firmware 2.1.

Programación del PLC
Manual de programación y manejo, 11/2019

1217

Instrucciones
4.1 Instrucciones
De este modo es posible, p. ej., descomponer palabras de estado y leer y modificar por índice
el estado de los bits individuales. Mediante GATHER pueden juntarse nuevamente los bits en
una secuencia de bits.
La salida de habilitación ENO devuelve el estado lógico "0" si se cumple una de las siguientes
condiciones:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El ARRAY de origen tiene menos elementos que los que se especifican en el parámetro
COUNT_IN.
● El índice del ARRAY de destino no empieza en un límite de BYTE, WORD, DWORD o
LWORD. En este caso no se escribe ningún resultado en el ARRAY of BOOL.
● El ARRAY[*] of BOOL, el STRUCT o el tipo de datos PLC no proporcionan el número
necesario de elementos.
– CPU S7-1500: en este caso se descomponen tantas secuencias de bits como sea
posible y se escriben en el ARRAY of BOOL, STRUCT anónimo o tipo de datos PLC. El
resto de secuencias de bits no se tiene en cuenta.
– CPU S7-1200: no se efectúa ninguna copia.
Nota
CPU S7-1200: Salida de habilitación ENO = 0
Si la salida de habilitación ENO devuelve el estado lógico "0", no se escribirán datos en el
parámetro de salida OUT.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:

1218

Parámetro

Declaración

Tipo de datos

Área de memo‐ Descripción
ria

S7-1200

S7-1500

EN

Input

BOOL

BOOL

I, Q, M, D, L o
constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

Salida de habili‐
tación

IN

Input

Elemento de un
ARRAY[*] of
<secuencia de
bits>

Elemento de
un
ARRAY[*] of
<secuencia
de bits>

I, Q, M, D, L

ARRAY of <se‐
cuencia de
bits> que se
descompone.
Los valores no
pueden encon‐
trarse en el
área de perife‐
ria o en el DB
de un objeto
tecnológico.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

COUNT_IN

Tipo de datos

Input

S7-1200

S7-1500

USINT, UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

Área de memo‐ Descripción
ria
I, Q, M, D, L

Contador del
número de ele‐
mentos del
ARRAY de ori‐
gen que deben
descomponer‐
se.
El valor no pue‐
de encontrarse
en el área de
periferia o en el
DB de un obje‐
to tecnológico.

OUT

Output

Elemento de un
ARRAY[*] of
BOOL,
STRUCT o tipo
de datos PLC

Elemento de I, Q, M, D, L
un
ARRAY[*] of
BOOL,
STRUCT o
tipo de datos
PLC

ARRAY,
STRUCT o tipo
de datos PLC
en el/los que se
guardan los
bits individuales

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar la secuencia de
bits deseada.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo de un ARRAY de destino con el límite inferior de "0"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

Enable

Input

BOOL

SourceArrayWord

ARRAY[0..5] of WORD

CounterInput

UDINT

EnableOut

Output

DestinationArrayBool

BOOL
ARRAY[0..95] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucción:
6&$77(5B%/.
:25'
(QDEOH
6RXUFH$UUD\:RUG>@
&RXQWHU,QSXW

Programación del PLC
Manual de programación y manejo, 11/2019

(1

287

,1

(12

'HVWLQDWLRQ$UUD\%RRO>@
(QDEOH2XW

&2817B,1

1219

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayWord[2]

ARRAY[0..5] of WORD (Pueden
dispersarse 96 bits.)

COUNT_IN

CounterInput = 3

UDINT3 (deben descomponerse
3 WORD o 48 bits. Esto significa
que en el ARRAY de destino de‐
be haber al menos 48 bits).

OUT

DestinationArrayBool[0]

El operando "DestinationArray‐
Bool" es del tipo de datos
ARRAY[0..95] of BOOL. Hay por
tanto 96 elementos BOOL dispo‐
nibles.

Si el operando #Enable devuelve el estado lógico "1" en la entrada de habilitación EN, se
ejecuta la instrucción. La 3.ª, 4.ª y 5.ª WORD del operando #SourceArrayWord se
descomponen en sus bits individuales (48) y se asignan a los distintos elementos del operando
#DestinationArrayBool a partir del 1.er elemento. Si ocurre un error durante la ejecución de la
instrucción, el operando #EnableOut devuelve el estado lógico "0" en la salida de habilitación
ENO.

Ejemplo de ARRAY de destino con el límite inferior de "-2"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

Enable

Input

BOOL

SourceArrayWord

ARRAY[0..5] of WORD

CounterInput

UDINT

EnableOut

Output

DestinationArrayBool

BOOL
ARRAY[-2..93] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucción:
6&$77(5B%/.
:25'
(QDEOH
6RXUFH$UUD\:RUG>@
&RXQWHU,QSXW

1220

(1

287

,1

(12

'HVWLQDWLRQ$UUD\%RRO>@
(QDEOH2XW

&2817B,1

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayWord[2]

ARRAY[0..5] of WORD (Pueden
dispersarse 96 bits.)

COUNT_IN

CounterInput = 3

UDINT3 (deben descomponerse
3 WORD o 48 bits. Esto significa
que en el ARRAY de destino de‐
be haber al menos 48 bits).

OUT

DestinationArrayBool[14]

El operando "DestinationArray‐
Bool" es del tipo de datos
ARRAY[-2..93] of BOOL. Hay
por tanto 96 elementos BOOL
disponibles.

Si el operando #Enable devuelve el estado lógico "1" en la entrada de habilitación EN, se
ejecuta la instrucción. La 3.ª, 4.ª y 5.ª WORD del operando #SourceArrayWord se descompone
en sus bits individuales (48) y a partir del 16.º elemento se asignan a los distintos elementos
del operando #DestinationArrayBool. Si ocurre un error durante la ejecución de la instrucción,
el operando #EnableOut devuelve el estado lógico "0" en la salida de habilitación ENO. Los 32
bits restantes no se escriben.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

GATHER: Recopilación de bits individuales en una secuencia de bits
Descripción
La instrucción "Recopilación de bits individuales en una secuencia de bits" recompone los bits
de un ARRAY of BOOL, un STRUCT anónimo o un tipo de datos PLC en una secuencia de bits
con elementos booleanos exclusivamente. La secuencia de bits se guarda en una variable del
tipo de datos BYTE, WORD, DWORD o LWORD.
Nota
ARRAY of BOOL multidimensional
En la instrucción "Recopilación de bits individuales en una secuencia de bits" no está permitido
utilizar un ARRAY of BOOL multidimensional.

Programación del PLC
Manual de programación y manejo, 11/2019

1221

Instrucciones
4.1 Instrucciones
Nota
Longitud del ARRAY, del STRUCT o del tipo de datos PLC
El ARRAY, el STRUCT o el tipo de datos PLC deben tener tantos elementos como se
especifique en la secuencia de bits.
Es decir, en el tipo de datos BYTE, p. ej., el ARRAY, el STRUCT anónimo o el tipo de datos PLC
deben tener exactamente 8 elementos (WORD = 16, DWORD = 32 y LWORD = 64).
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1200 a partir de la versión de firmware
>4.2 y en las CPU de la serie S7-1500 a partir de la versión de firmware 2.1.
La salida de habilitación ENO devuelve el estado lógico "0" si se cumple una de las siguientes
condiciones:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El ARRAY, STRUCT o tipo de datos PLC (UDT) tiene más o menos elementos BOOL que
lo que especifica la secuencia de bits. En este caso no se transfieren los elementos BOOL.
● Hay menos bits que el número de bits necesario.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

1222

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memo‐ Descripción
ria

EN

Input

BOOL

BOOL

I, Q, M, D, L o
constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

Salida de habili‐
tación

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

IN

Tipo de datos

Input

S7-1500

ARRAY[*] of
BOOL,
STRUCT o tipo
de datos PLC

ARRAY[*] of I, Q, M, D, L
BOOL,
STRUCT o
tipo de datos
PLC

*: 8, 16, 32 o 64
elementos

OUT

Output

Área de memo‐ Descripción
ria

S7-1200

BYTE, WORD,
DWORD

*: 8, 16, 32 o
64 elemen‐
tos

BYTE,
WORD,
DWORD,
LWORD

ARRAY,
STRUCT o tipo
de datos PLC
cuyos bits se re‐
componen en
una secuencia
de bits.
Los valores no
pueden encon‐
trarse en el
área de perife‐
ria o en el DB
de un objeto
tecnológico.

I, Q, M, D, L

Secuencia de
bits recopilada
que está guar‐
dada en una va‐
riable

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar la secuencia de
bits deseada.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

Enable

Input

BOOL

SourceArray

ARRAY[0..15] of BOOL

EnableOut

Output

DestinationWord

BOOL
WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
*$7+(5
:25'
(QDEOH
6RXUFH$UUD\

(1

287

,1

(12

Programación del PLC
Manual de programación y manejo, 11/2019

'HVWLQDWLRQ:RUG
(QDEOH2XW

1223

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operando
concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArray

El operando "SourceArray" es
del tipo de datos ARRAY[0..15]
of BOOL. Consta de 16 elemen‐
tos y, por tanto, tiene el mismo
tamaño que la WORD en la que
se deben recomponer los bits.

OUT

DestinationWord

WORD (16 bits)

Si el operando #Enable devuelve el estado lógico "1" en la entrada de habilitación EN, se
ejecuta la instrucción. Los bits del operando #SourceArray se recopilan en una WORD. Si
ocurre un error durante la ejecución de la instrucción, el operando #EnableOut devuelve el
estado lógico "0" en la salida de habilitación ENO.

Ejemplo con un tipo de datos PLC (UDT)
Cree el siguiente tipo de datos PLC "myBits":

Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

Enable

Input

BOOL

SourceUDT
EnableOut
DestinationWord

"myBits"
Output

BOOL
WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:

1224

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
*$7+(5
:25'
(QDEOH
6RXUFH8'7

(1

287

,1

(12

'HVWLQDWLRQ:RUG
(QDEOH2XW

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operando
concretos:
Parámetro

Operando

Tipo de datos

IN

SourceUDT

El operando "SourceUDT" es del
tipo de datos PLC (UDT). Consta
de 16 elementos y, por tanto, tie‐
ne el mismo tamaño que la
WORD en la que se deben re‐
componer los bits.

OUT

DestinationWord

WORD (16 bits)

Si el operando #Enable devuelve el estado lógico "1" en la entrada de habilitación EN, se
ejecuta la instrucción. Los bits del operando #SourceUDT se recomponen en una WORD. Si
ocurre un error durante la ejecución de la instrucción, el operando #EnableOut devuelve el
estado lógico "0" en la salida de habilitación ENO.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1225

Instrucciones
4.1 Instrucciones

GATHER_BLK: Recopilación de bits individuales en varios elementos de un ARRAY of secuencia de bits
Descripción
La instrucción "Recopilación de bits individuales en varios elementos de un ARRAY of
secuencia de bits" recompone los bits de un ARRAY of BOOL, un STRUCT anónimo o un tipo
de datos PLC con elementos booleanos exclusivamente en uno o varios elementos de un
ARRAY of <secuencia de bits>. En el parámetro COUNT_OUT se introduce el número de
elementos del ARRAY de destino que deben escribirse. Al hacerlo se especifica
implícitamente cuántos elementos del ARRAY of BOOL, del STRUCT anónimo o del tipo de
datos PLC se necesitan. El ARRAY de destino en el parámetro OUT puede tener más
elementos que los indicados en el parámetro COUNT_OUT. El ARRAY of <secuencia de bits>
debe tener suficientes elementos para poder guardar los bits que deben recopilarse. El
ARRAY de destino también puede ser mayor.
Nota
ARRAY of BOOL multidimensional
Si el ARRAY es un ARRAY of BOOL multidimensional, se cuentan también los bits de relleno
de las dimensiones contenidas, aunque no se hayan declarado explícitamente.
Ejemplo 1: un ARRAY[1..10,0..4,1..2] of BOOL recibe el mismo tratamiento que un
ARRAY[1..10,0..4,1..8] of BOOL o que un ARRAY[0..399] of BOOL.
Ejemplo 2: En el parámetro OUT hay un ARRAY[0..5] of WORD (sourceArrayWord[2])
interconectado. El parámetro COUNT_IN tiene el valor "3". En el parámetro IN hay un
ARRAY[0..1,0..5,0..7] of BOOL (destinationArrayBool[0,0,0]) interconectado. Tanto el array
del parámetro IN como el del parámetro OUT tienen 96 bits de tamaño. A partir del ARRAY of
BOOL se recomponen 48 bits individuales.
Nota
Si el límite inferior del ARRAY de origen no es "0", cabe considerar lo siguiente:
Por motivos de rendimiento, el índice debe comenzar siempre en un límite de BYTE, WORD,
DWORD o LWORD. Esto significa que debe calcularse el índice partiendo del límite inferior del
ARRAY. Como base para el cálculo se utiliza la siguiente fórmula:
Índice válido = límite inferior del ARRAY + n(número de secuencias de bits) * número de bits
de la secuencia de bits deseada
Para un ARRAY[-2..45] of BOOL y la secuencia de bits WORD, el cálculo es el siguiente:
● Índice válido (-2) = -2 + 0 * 16
● Índice válido (14) = -2 + 1 * 16
● Índice válido (30) = -2 + 2 * 16
Ver un ejemplo más adelante.
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1200 a partir de la versión de firmware
>4.2 y en las CPU de la serie S7-1500 a partir de la versión de firmware 2.1.

1226

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La salida de habilitación ENO devuelve el estado lógico "0" si se cumple una de las siguientes
condiciones:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El índice del ARRAY de origen no empieza en un límite de BYTE, WORD, DWORD o
LWORD. En este caso no se escribe ningún resultado en el ARRAY of <secuencia de bits>.
● El ARRAY[*] of <secuencia de bits> no proporciona el número necesario de elementos.
– CPU S7-1500: en este caso se juntan tantas secuencias de bits como sea posible y se
escriben en el ARRAY of <secuencia de bits>. El resto de los bits no se tiene en cuenta.
– CPU S7-1200: no se efectúa ninguna copia.
Nota
CPU S7-1200: Salida de habilitación ENO = 0
Si la salida de habilitación ENO devuelve el estado lógico "0", no se escribirán datos en el
parámetro de salida OUT.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memo‐ Descripción
ria

S7-1200

S7-1500

EN

Input

BOOL

BOOL

I, Q, M, D, L o
constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

Salida de habili‐
tación

IN

Input

Elemento de un
ARRAY[*] of
BOOL,
STRUCT o tipo
de datos PLC

Elemento de I, Q, M, D, L
un
ARRAY[*] of
BOOL,
STRUCT o
tipo de datos
PLC

ARRAY of
BOOL,
STRUCT o tipo
de datos PLC
cuyos bits se re‐
componen
(ARRAY de ori‐
gen).
Los valores no
pueden encon‐
trarse en el
área de perife‐
ria o en el DB
de un objeto
tecnológico.

Programación del PLC
Manual de programación y manejo, 11/2019

1227

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

COUNT_OUT

Tipo de datos

Input

S7-1200

S7-1500

USINT, UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

Área de memo‐ Descripción
ria
I, Q, M, D, L

Contador del
número de ele‐
mentos del
ARRAY de des‐
tino que deben
escribirse.
El valor no pue‐
de encontrarse
en el área de
periferia o en el
DB de un obje‐
to tecnológico.

OUT

Output

Elemento de un
ARRAY[*] of
<secuencia de
bits>

Elemento de
un
ARRAY[*] of
<secuencia
de bits>

I, Q, M, D, L

ARRAY de <se‐
cuencia de
bits> en el que
se guardan los
bits (ARRAY de
destino)

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar la secuencia de
bits deseada.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo de ARRAY de origen con el límite inferior de "0"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

Enable

Input

BOOL

SourceArrayBool

ARRAY[0..95] of BOOL

CounterOutput

UDINT

EnableOut

Output

DestinationArrayWord

BOOL
ARRAY[0..5] of WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
*$7+(5B%/.
:25'
(QDEOH
6RXUFH$UUD\%RRO>@
&RXQWHU2XWSXW

1228

(1

287

,1

(12

'HVWLQDWLRQ$UUD\:RUG>@
(QDEOH2XW

&2817B287

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayBool[0]

El operando "SourceArrayBool"
es del tipo de datos
ARRAY[0..95] of BOOL. Hay por
tanto 96 elementos BOOL dispo‐
nibles que pueden volver a reco‐
pilarse en palabras.

COUNT_OUT

CounterOutput = 3

UDINT3 (deben escribirse 3 pa‐
labras. Esto significa que en el
ARRAY de origen debe haber 48
bits).

OUT

DestinationArrayWord[2]

El operando "DestinationArray‐
Word" es del tipo de datos
ARRAY[0..5] of WORD. Hay 6
elementos WORD disponibles.

Si el operando #Enable devuelve el estado lógico "1" en la entrada de habilitación EN, se
ejecuta la instrucción. A partir del 1.er elemento del operando #SourceArrayBool se
recomponen 48 bits en el operando #DestinationArrayWord. En el ARRAY de destino se
empieza a partir del 3.er elemento. Esto significa que los primeros 16 bits se escriben en la 3.ª
palabra, los segundos 16 bits en la 4.ª palabra y los terceros 16 bits en la 5.ª palabra del
ARRAY de destino. Si ocurre un error durante la ejecución de la instrucción, el operando
#EnableOut devuelve el estado lógico "0" en la salida de habilitación ENO.

Ejemplo de ARRAY de origen con el límite inferior de "-2"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

Enable

Input

BOOL

SourceArrayBool

ARRAY[-2..93] of BOOL

CounterOutput

UDINT

EnableOut

Output

DestinationArrayWord

BOOL
ARRAY[0..5] of WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
*$7+(5B%/.
:25'
(QDEOH
6RXUFH$UUD\%RRO>@
&RXQWHU2XWSXW

Programación del PLC
Manual de programación y manejo, 11/2019

(1

287

,1

(12

'HVWLQDWLRQ$UUD\:RUG>@
(QDEOH2XW

&2817B287

1229

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayBool[14]

El operando "SourceArrayBool"
es del tipo de datos
ARRAY[-2..93] of BOOL. Dado
que se empieza a partir del 16.º
elemento, hay solo 80 elemen‐
tos BOOL disponibles que pue‐
dan volver a recopilarse en pala‐
bras.

COUNT_OUT

CounterOutput = 3

UDINT3 (deben escribirse 3 pa‐
labras. Esto significa que en el
ARRAY de origen debe haber 48
bits).

OUT

DestinationArrayWord[2]

El operando "DestinationArray‐
Word" es del tipo de datos
ARRAY[0..5] of WORD. Hay 6
elementos WORD disponibles.

Si el operando #Enable devuelve el estado lógico "1" en la entrada de habilitación EN, se
ejecuta la instrucción. A partir del 16.º elemento del operando #SourceArrayBool se recopilan
48 bits en el operando #DestinationArrayWord. En el ARRAY de destino se empieza a partir del
3.er elemento. Esto significa que los primeros 16 bits del ARRAY de origen no se tienen en
cuenta. Los segundos 16 bits se escriben en la 3.ª palabra, los terceros 16 bits en la 4.ª palabra
y los cuartos 16 bits en la 5.ª palabra del ARRAY de destino. Los 64 bits restantes del ARRAY
de origen tampoco se tienen en cuenta. Si ocurre un error durante la ejecución de la
instrucción, el operando #EnableOut devuelve el estado lógico "0" en la salida de habilitación
ENO.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

AssignmentAttempt: Intento de asignación de VARIANT a una referencia
Descripción
La instrucción "AssignmentAttempt" intenta asignar una variable VARIANT a una variable de
referencia. El tipo de datos de una variable de referencia se define en el momento de la
declaración, mientras que el tipo de datos de una variable VARIANT se determina en tiempo
de ejecución. En las variables de referencia no está permitida la conversión implícita del tipo
de datos. Para asignar un tipo de datos al otro se utiliza el intento de asignación.
En el intento de asignación, se comprueba en tiempo de ejecución si la variable VARIANT es
del tipo de datos correcto. Si es así, se ejecuta la asignación. Una vez ejecutada
correctamente, en la variable de destino hay una referencia válida; en caso contrario, hay
CERO.

1230

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

EN

Input

BOOL

Entrada de habili‐
tación

ENO

Output

BOOL

Salida de habilita‐
ción

SRC

Input

VARIANT

● Interfaz de
bloque de una
FC:
Input, Output,
InOut, Temp

Descripción

Puntero hacia la
variable origen cu‐
ya dirección se ha
leído

● Interfaz de
bloque de un
FB:
Input, Output,
Temp
DST

Output

Referencia a:
● Secuencias de
bits, excepto
BOOL,
● Enteros,
● Números en
coma flotante,
● Cadenas de
caracteres,

● Interfaz de
bloque de una
FC:
Input, Output,
Temp, Return

Referencia a la
que se transfiere
la dirección de la
variable de origen

● Interfaz de
bloque de un
FB:
Temp

● Tipos de datos
PLC (UDT),
● Tipos de datos
de sistema
(SDT),
● ARRAYs de
los tipos de
datos citados

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1231

Instrucciones
4.1 Instrucciones

Reglas
Para el intento de asignación se aplican las siguientes reglas: Las variables VARIANT que no
satisfacen estas reglas devuelven el valor "NULL" en tiempo de ejecución.
● VARIANT debe señalar a una dirección de un área de memoria optimizada.
● VARIANT no puede señalar a una dirección de un área de memoria temporal.
● Si desea asignar un VARIANT a una referencia a un ARRAY, se aplican las siguientes
reglas:
– La variable VARIANT debe señalar a un ARRAY cuyos límites coincidan exactamente
con los de la referencia declarada. Una variable VARIANT que señala a un ARRAY [0..9]
no concuerda con una variable REF_TO ARRAY[1..10].
– Además, los bloques que forman el valor de la variable VARIANT deben compilarse una
vez en una CPU de la serie S7-1500, con firmware de la versión V2.5.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
En la interfaz del bloque se han declarado la VARIANT "myVariant" y la variable de referencia
"myReference".

En el código de programa se intenta asignar "myVariant" a la variable de referencia
"myReference". Si en tiempo de ejecución "myVariant" tiene el tipo de datos "Int", en
"myReference" hay una referencia válida a la variable de destino de VARIANT; en caso
contrario, hay CERO. Si la asignación se ha realizado correctamente, la salida de habilitación
"ENO" devuelve el estado lógico "1" y se puede escribir el valor "10" en la variable de destino.

1232

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Intento de asignación de VARIANT a una referencia (Página 325)
Principios básicos de las referencias (Página 310)
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)
Sample Library for Instructions (Página 615)

SWAP: Cambiar disposición
Descripción
La instrucción "Cambiar disposición" permite cambiar la disposición de los bytes de la entrada
IN y consultar el resultado en la salida OUT.
La figura siguiente muestra cómo se cambian los bytes de un operando del tipo de datos
DWORD utilizando la instrucción "Cambiar disposición":


,1

 

 
 

 

 

 


 



 

 

 

 

 

 



Programación del PLC
Manual de programación y manejo, 11/2019


 

 



 

 


 


 



 
 

 






287

 



 


 

 



 




 

 

 


 


 

 

 



1233

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Cambiar disposición":
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

IN

Input

WORD,
DWORD

WORD,
DWORD,
LWORD

I, Q, M, D, L, I, Q, M, D, L, Operando
P o constan‐ P o constan‐ cuyos bytes
te
te
se intercam‐
bian.

OUT

Output

WORD,
DWORD

WORD,
DWORD,
LWORD

I, Q, M, D, L,
P

I, Q, M, D, L,
P

Resultado

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

ಯ7DJ,Qಯ
ಯ7DJ,QB9DOXHಯ

6:$3
:25'
287
(1

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

,1

(12

6

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

TagIn_Value

0000 1111 0101 0101

OUT

TagOut_Value

0101 0101 0000 1111

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La disposición
de los bytes se cambia y se deposita en el operando "TagOut_Value".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

1234

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

DB ARRAY
ReadFromArrayDB: Leer en un bloque de datos ARRAY
Descripción
La instrucción "Leer en un bloque de datos ARRAY" lee el elemento de un bloque de datos del
tipo ARRAY-DB al que hace referencia el índice y escribe el valor en el área de destino.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".
La salida de habilitación ENO devuelve el estado lógico FALSE cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico FALSE.
● Se produce un error al ejecutar la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Leer en un bloque de datos
ARRAY":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

DB

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
lee

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB que se lee.
Puede ser una constante,
una variable global o un valor
indexado.

VALUE

Output 1)

VARIANT

L (puede declarar‐ Valor que se lee y se devuel‐
se en las seccio‐
ve
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

1) El parámetro VALUE está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1235

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

80B5

La operación de copia se ha cancelado.

8132

El bloque de datos no existe, es demasiado corto, está protegido contra escritura o está
en la memoria de carga.

8135

El bloque de datos de ARRAY contiene valores no válidos.

8154

El bloque de datos es de un tipo incorrecto.

8282

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8450

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8452

Error de creación de código

8453

Hay dos posibles causas de error:
● El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque
de datos ARRAY.
● Ninguna de las dos variables se encuentra en un área de memoria con acceso
optimizado. Encontrará más información sobre los tipos de acceso al área de memoria
aquí: Fundamentos del acceso a bloques (Página 54)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
5HDG)URP$UUD\'%
ಯ7DJ,QBಯ

(1

ಯ$UUD\'%ಯ

'%



1236

,1'(;

5(7B9$/
9$/8(

ಯ7DJ5HWB9DOಯ
ಯ7DUJHW)LHOGಯ ಯ7DJ2XWಯ

(12

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
Array [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

TargetField

El operando "TargetField" es
una variable global del tipo de
datos INT.

Si el operando "TagIn1" devuelve el estado lógico "1", se ejecuta la instrucción. El segundo
elemento se lee en el "ArrayDB" y se escribe en el operando "TargetField". Si no se producen
errores al ejecutar la instrucción, la salida de habilitación ENO devuelve el estado lógico TRUE
y la salida "TagOut" se activa.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Principios básicos de VARIANT (Página 335)
Principios básicos de FUP (Página 8005)

WriteToArrayDB: Escribir en un bloque de datos ARRAY
Descripción
La instrucción "Escribir en un bloque de datos ARRAY" escribe el elemento al que hace
referencia el índice en un bloque de datos del tipo ARRAY-DB.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".
La salida de habilitación ENO devuelve el estado lógico FALSE cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico FALSE.
● Se produce un error al ejecutar la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

1237

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Escribir en un bloque de datos
ARRAY":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

DB

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
escribe

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB en el que se
escribe. Puede ser una cons‐
tante, una variable global o
un valor indexado.

VALUE

Input

VARIANT

L (puede declarar‐ Valor que se escribe
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)

1238

0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

80B5

La operación de copia se ha cancelado.

8132

El bloque de datos no existe, es demasiado corto o está en la memoria de carga.

8134

El bloque de datos está protegido contra escritura.

8135

El bloque de datos no es un bloque de datos de ARRAY.

8154

El bloque de datos es de un tipo incorrecto.

8282

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8350

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8352

Error de creación de código

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*

Explicación

(W#16#...)
8353

Hay dos posibles causas de error:
● El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque
de datos ARRAY.
● Ninguna de las dos variables se encuentra en un área de memoria con acceso
optimizado. Encontrará más información sobre los tipos de acceso al área de memoria
aquí: Fundamentos del acceso a bloques (Página 54)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
:ULWH7R$UUD\'%
ಯ7DJ,QBಯ

(1

ಯ$UUD\'%ಯ

'%


ಯ6RXUFH)LHOGಯ

,1'(;

5(7B9$/

9$/8(

(12

ಯ7DJ5HWB9DOಯ ಯ7DJ2XWಯ

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
Array [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

SourceField

El operando "SourceField" es
una variable global del tipo de
datos INT.

Si el operando "TagIn1" devuelve el estado lógico "1", se ejecuta la instrucción. El valor del
operando "SourceField" se escribe en el segundo elemento del DB de ARRAY. Si no se
producen errores al ejecutar la instrucción, la salida de habilitación ENO devuelve el estado
lógico TRUE y la salida "TagOut" se activa.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Ejemplo de uso de bloques de datos ARRAY (Página 43)

Programación del PLC
Manual de programación y manejo, 11/2019

1239

Instrucciones
4.1 Instrucciones
Principios básicos de VARIANT (Página 335)
Principios básicos de FUP (Página 8005)

ReadFromArrayDBL: Leer en un bloque de datos ARRAY de la memoria de carga
Descripción
La instrucción "Leer en un bloque de datos ARRAY de la memoria de carga" lee el elemento
de un bloque de datos del tipo ARRAY-DB de la memoria de carga al que hace referencia el
índice y lo escribe en el área de destino.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".
Si el bloque de datos ARRAY se ha marcado con el atributo de bloque "Depositar sólo en la
memoria de carga", se guarda únicamente en la memoria de carga.
Si en el parámetro REQ se detecta un flanco de señal ascendente, se ejecuta la instrucción.
El parámetro BUSY devuelve el estado lógico "1". Si en el parámetro BUSY se detecta un
flanco de señal descendente, finaliza la instrucción. Durante un ciclo del programa, el
parámetro DONE tiene el estado lógico "1" y durante este ciclo se emite el valor leído en el
parámetro VALUE. En los demás ciclos del programa, el valor del parámetro VALUE no se
modifica.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Se produce un error al ejecutar la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Leer en un bloque de datos
ARRAY de la memoria de carga":

1240

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

REQ

Input

BOOL

I, Q, M, D, L o
constante

REQ = "1": Comenzar la lec‐
tura del DB de array

DB 1)

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
lee

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB que se lee.
Puede ser una constante,
una variable global o un valor
indexado.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

VALUE 1)

InOut

VARIANT

D (elemento de un
bloque de datos
global)

Puntero al bloque de datos
de la memoria de trabajo que
se lee y cuyo valor se escribe.

L (puede declarar‐ No está permitido utilizar
constantes locales o varia‐
se en las seccio‐
bles de la sección TEMP.
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)
BUSY

Output

BOOL

I, Q, M, D, L

BUSY = "1": La lectura del
DB de array todavía no ha fi‐
nalizado

DONE

Output

BOOL

I, Q, M, D, L

DONE = "1": La instrucción
se ha ejecutado correcta‐
mente

ERROR

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro ERROR devuel‐
ve un código de error cuando
ocurre un error durante la eje‐
cución de la instrucción.

1)

Los bloques de datos deben crearse con la propiedad de bloque "Optimizado".

Parámetro ERROR
La tabla siguiente muestra el significado de los valores del parámetro ERROR:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8230

El número del bloque de datos es incorrecto.

8231

El bloque de datos no existe.

8232

El bloque de datos es demasiado corto o no está en la memoria de carga.

8235

El bloque de datos no es un DB de ARRAY.

8254

El bloque de datos es de un tipo incorrecto.

8382

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8750

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8751

Error de creación de código

8752

Error de creación de código

8753

El tamaño del parámetro s no coincide con la longitud de elemento del bloque de datos
ARRAY.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Programación del PLC
Manual de programación y manejo, 11/2019

1241

Instrucciones
4.1 Instrucciones
Encontrará la descripción de los códigos de error activados por las instrucciones "READ_DBL"
y "WRIT_DBL" en las descripciones de las instrucciones correspondientes.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ5HDG)URP$UUD\'%/B'%ಯ
5HDG)URP$UUD\'%/
ಯ7DJ,QBಯ
ಯ7DJ5HTಯ
ಯ$UUD\'%ಯ

ಯ7DUJHW)LHOGಯ

(1
5(4

%86<

ಯ7DJ%XV\ಯ

'%

'21(

ಯ7DJ'RQHಯ

,1'(;

(5525

ಯ7DJ(UURUಯ

9$/8(

(12

ಯ7DJ2XWಯ

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

REQ

TagReq

BOOL

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
ARRAY [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

TargetField

El operando "TargetField" es
una variable global del tipo de
datos INT.

BUSY

TagBusy

BOOL

DONE

TagDone

BOOL

Si el operando "TagIn1" devuelve el estado lógico "1" y en el operando "TagReq" se registra un
flanco de señal ascendente, la instrucción se ejecuta. El segundo elemento se lee en el
"ArrayDB" y se devuelve en el parámetro "VALUE". En cuanto se detecta un flanco de señal
descendente en el operando "TagBusy", finaliza la instrucción y el valor del parámetro VALUE
ya no se modifica. Si no se producen errores al ejecutar la instrucción, la salida de habilitación
ENO devuelve el estado lógico TRUE y la salida "TagOut" se activa. Después de ejecutar la
instrucción, el operando "TagDone" tiene el estado lógico TRUE.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
WRIT_DBL: Escribir en un bloque de datos de la memoria de carga (Página 2923)
READ_DBL: Leer de un bloque de datos de la memoria de carga (Página 2919)
Ejemplo de uso de bloques de datos ARRAY (Página 43)

1242

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Principios básicos de VARIANT (Página 335)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)
Principios básicos de FUP (Página 8005)

WriteToArrayDBL: Escribir en un bloque de datos ARRAY de la memoria de carga
Descripción
La instrucción "Escribir en un bloque de datos ARRAY de la memoria de carga" escribe el
elemento al que hace referencia el índice en un bloque de datos del tipo ARRAY-DB de la
memoria de carga.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".
Si el bloque de datos ARRAY se ha marcado con el atributo de bloque "Depositar sólo en la
memoria de carga", se guarda únicamente en la memoria de carga.
Si en el parámetro REQ se detecta un flanco de señal ascendente, se ejecuta la instrucción.
El parámetro BUSY devuelve el estado lógico "1". Si en el parámetro BUSY se detecta un
flanco de señal descendente, finaliza la instrucción y el valor del parámetro VALUE se escribe
en el bloque de datos. Durante un ciclo del programa, el parámetro DONE tiene el estado
lógico "1".
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Se produce un error al ejecutar la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Escribir en un bloque de datos
ARRAY de la memoria de carga":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

REQ

Input

BOOL

I, Q, M, D, L o
constante

REQ = "1": Comenzar a es‐
cribir en el DB de array

DB 1)

Input

DB_ANY

I, Q, M, D, L

Bloque de datos ARRAY en
el que se escribe

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB en el que se
escribe. Puede ser una cons‐
tante, una variable global o
un valor indexado.

Programación del PLC
Manual de programación y manejo, 11/2019

1243

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

VALUE 1)

Input

VARIANT

D (elemento de un
bloque de datos
global)

Puntero al bloque de datos
de la memoria de trabajo que
se lee y cuyo valor se escribe.

L (puede declarar‐ No está permitido utilizar
constantes locales o varia‐
se en las seccio‐
bles de la sección TEMP.
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)
BUSY

Output

BOOL

I, Q, M, D, L

BUSY = "1": Todavía no se
ha terminado de escribir en el
DB de array

DONE

Output

BOOL

I, Q, M, D, L

DONE = "1": La instrucción
se ha ejecutado correcta‐
mente

ERROR

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro ERROR devuel‐
ve un código de error cuando
ocurre un error durante la eje‐
cución de la instrucción.

1)

Los bloques de datos deben crearse con la propiedad de bloque "Optimizado".

Parámetro ERROR
La tabla siguiente muestra el significado de los valores del parámetro ERROR:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8230

El número del bloque de datos es incorrecto.

8231

El bloque de datos no existe.

8232

El bloque de datos es demasiado corto o no está en la memoria de carga.

8234

El bloque de datos está protegido contra escritura.

8235

El bloque de datos no es un DB de ARRAY.

8254

El bloque de datos es de un tipo incorrecto.

8382

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8450

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8751

Error de creación de código

8752

Error de creación de código

8753

El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque de
datos ARRAY.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

1244

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará la descripción de los códigos de error activados por las instrucciones "READ_DBL"
y "WRIT_DBL" en las descripciones de las instrucciones correspondientes.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ:ULWH7R$UUD\'%/B'%ಯ
:ULWH7R$UUD\'%/
ಯ7DJ,QBಯ

(1

ಯ7DJ5HTಯ

5(4

%86<

ಯ7DJ%XV\ಯ

'%

'21(

ಯ7DJ'RQHಯ

,1'(;

(5525

ಯ7DJ(UURUಯ

9$/8(

(12

ಯ$UUD\'%ಯ

ಯ6RXUFH)LHOGಯ

ಯ7DJ2XWಯ

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

REQ

TagReq

BOOL

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
ARRAY [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

SourceField

El operando "SourceField" es
una variable global del tipo de
datos INT.

BUSY

TagBusy

BOOL

DONE

TagDone

BOOL

Si el operando "TagIn1" devuelve el estado lógico "1" y en el operando "TagReq" se registra un
flanco de señal ascendente, la instrucción se ejecuta. En cuanto se detecta un flanco
descendente en el operando "TagBusy", la instrucción finaliza y el valor del parámetro VALUE
se escribe en el segundo elemento del "ArrayDB". Si no se producen errores al ejecutar la
instrucción, la salida de habilitación ENO devuelve el estado lógico TRUE y la salida "TagOut"
se activa. Después de ejecutar la instrucción, el operando "TagDone" tiene el estado lógico
TRUE.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
WRIT_DBL: Escribir en un bloque de datos de la memoria de carga (Página 2923)
READ_DBL: Leer de un bloque de datos de la memoria de carga (Página 2919)
Ejemplo de uso de bloques de datos ARRAY (Página 43)

Programación del PLC
Manual de programación y manejo, 11/2019

1245

Instrucciones
4.1 Instrucciones
Principios básicos de VARIANT (Página 335)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)
Principios básicos de FUP (Página 8005)

VARIANT
VariantGet: Leer valor de una variable VARIANT
Descripción
Con la instrucción "Leer valor de una variable VARIANT" se lee el valor de la variable a la que
apunta VARIANT en el parámetro SRC y se escribe este valor en la variable del parámetro
DST.
El parámetro SRC es del tipo de datos VARIANT. En el parámetro DST se puede indicar
cualquier tipo de datos excepto VARIANT.
El tipo de datos de la variable indicada en el parámetro DST debe coincidir con el tipo de datos
al que apunta VARIANT.
Nota
Para copiar estructuras y ARRAY también se puede utilizar la instrucción
"MOVE_BLK_VARIANT: Copiar área". Encontrará más información al respecto en "Consulte
también".
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Los tipos de datos no coinciden. (No se transmiten valores.)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Leer valor de una variable
VARIANT":
Parámetro

1246

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L o Entrada de habili‐
constante
tación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habilita‐
ción

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

SRC

Input

VARIANT

DST

Output

I, Q, M, D, L
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, tiempos, fe‐
cha y hora, se‐
cuencias de carac‐
teres, elementos
de ARRAY, tipos
de datos PLC

Descripción

S7-1500

L (puede declararse en las
secciones "Input", "InOut" y
"Temp" de la interfaz del blo‐
que.)
I, Q, M, D, L,
P

Variable que se
lee

Resultado de la
instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
9DULDQW*HW
ಯ7DJ,Qಯ
7DJ,QB6RXUFH

(1

(12

ಯ7DJ2XWಯ

65&

'67

ಯ7DJ2XWB'HVWಯ

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El valor de la
variable a la que señala VARIANT en el operando "#TagIn_Source" se lee y se escribe en el
operando "TagOut_Dest".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de VARIANT (Página 335)
MOVE_BLK_VARIANT: Copiar área (Página 1198)
Principios básicos de FUP (Página 8005)

VariantPut: Escribir valor en una variable VARIANT
Descripción
La instrucción "Escribir valor en una variable VARIANT" escribe el valor de la variable indicada
en el parámetro SRC en la memoria del parámetro DST al que apunta VARIANT.

Programación del PLC
Manual de programación y manejo, 11/2019

1247

Instrucciones
4.1 Instrucciones
El parámetro DST es del tipo de datos VARIANT. En el parámetro SRC se puede indicar
cualquier tipo de datos excepto VARIANT.
El tipo de datos de la variable del parámetro SRC debe coincidir con el tipo de datos al que
apunta VARIANT.
Nota
Para copiar estructuras y ARRAY también se puede utilizar la instrucción
"MOVE_BLK_VARIANT: Copiar área". Encontrará más información al respecto en "Consulte
también".
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Los tipos de datos no coinciden. (No se transmiten valores.)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Escribir valor en una variable
VARIANT":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L
o constante

Entrada de habili‐
tación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habilita‐
ción

SRC

Input

I, Q, M, D, L
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, tiempos, fe‐
cha y hora, se‐
cuencias de carac‐
teres, elementos
de ARRAY, tipos
de datos PLC

I, Q, M, D, L,
P

Variable que se
lee

DST

Input

VARIANT

L (puede declararse en las
secciones "Input", "InOut" y
"Temp" de la interfaz del blo‐
que.)

Resultado de la
instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1248

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
9DULDQW3XW
ಯ7DJ,Qಯ

(1

ಯ7DJ,QB6RXUFHಯ

65&

7DJ,QB'HVW

'67

(12

ಯ7DJ2XWಯ

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El valor del
operando "TagIn_Source" se escribe en la variable a la que apunta VARIANT en el operando
#TagIn_Dest.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de VARIANT (Página 335)
MOVE_BLK_VARIANT: Copiar área (Página 1198)
Principios básicos de FUP (Página 8005)

CountOfElements: Consultar número de elementos de ARRAY
Descripción
La instrucción "Consultar número de elementos de ARRAY" permite saber el número de
elementos de ARRAY que tiene una variable a la que apunta VARIANT.
Si el ARRAY es unidimensional, el resultado se devuelve como número de elementos ARRAY.
(La diferencia entre el límite superior e inferior + 1). Si el ARRAY es multidimensional, el
resultado se devuelve como cantidad de todas las dimensiones.
Si desea consultar los elementos de un DB de ARRAY deberá utilizar las instrucciones
"ReadFromArrayDB" o "WriteFromArrayDB", puesto que estas permiten una evaluación de
errores más precisa para el número de elementos.
Nota
Instancias
El puntero VARIANT no puede señalar a ninguna instancia y, por lo tanto, tampoco a ninguna
multiinstancia o ARRAY of multiinstancias.

Programación del PLC
Manual de programación y manejo, 11/2019

1249

Instrucciones
4.1 Instrucciones
Nota
ARRAY en un bloque de datos
Si desea consultar el número de elementos de un ARRAY que se encuentra en un bloque de
datos, en este no debe estar activado el atributo de bloque "Bloque de datos protegido contra
escritura en el dispositivo". De lo contrario, el parámetro RET_VAL devuelve el resultado "0",
independientemente de cuántos elementos contenga el ARRAY.
El resultado también es "0" si la variable VARIANT no es ARRAY.
Si VARIANT apunta a un ARRAY of BOOL, se cuentan también los elementos de relleno. (P.
ej. con un ARRAY[0..1] of BOOL se devuelve 8.)
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● La variable VARIANT no es un ARRAY. (El resultado es "0".)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar número de elementos
de ARRAY":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

IN

Input

VARIANT

L (puede declarar‐ Variable que se consulta
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

UDINT

I, Q, M, D, L

Resultado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
&RXQW2I(OHPHQWV
ಯ7DJ,Qಯ
7DJ,QB6RXUFH

(1
,1

(12
5(7B9$/

ಯ7DJ2XWಯ
ಯ7DJ2XWB5HW9DOಯ

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El número de
elementos de ARRAY de la variable a la que apunta VARIANT en el operando #TagIn_Source
se lee y se devuelve en el operando "TagOut_RetVal".

1250

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Principios básicos del ARRAY (Página 293)
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de VARIANT (Página 335)
Principios básicos de FUP (Página 8005)

ARRAY[*]
LOWER_BOUND: Leer límite inferior del ARRAY
Descripción
En la interfaz de un bloque de función o de una función se pueden declarar variables del tipo
de datos ARRAY[*]. Para estas variables locales pueden leerse los límites del ARRAY. En el
parámetro DIM debe indicarse la dimensión deseada.
Para leer el límite inferior variable del ARRAY está disponible la instrucción "Leer límite inferior
del ARRAY".
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● La dimensión indicada en la entrada DIM no existe.
Nota
Disponibilidad de la instrucción
La instrucción está disponible en las CPU de la serie S7-1200 a partir de la versión de firmware
>= 4.2 y en las CPU de la serie S7-1500 a partir de la versión de firmware >= 2.0.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Leer límite inferior del ARRAY":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

ARR

Input

ARRAY[*]

FB => sección
InOut

ARRAY cuyo límite inferior
variable debe leerse.

FC => sección In‐
put y InOut

Programación del PLC
Manual de programación y manejo, 11/2019

1251

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

DIM

Input

UDINT

I, Q, M, D, L, P o
constante

Dimensión del ARRAY cuyo
límite inferior variable debe
leerse.

OUT

Output

DINT

I, Q, M, D, L, P

Resultado

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
/2:(5B%281'
ಯ(QDEOHB6WDUWಯ

(1

$55$<B$

$55



',0

(12

ಯ(QDEOHB2XWಯ

287

ಯ5HVXOWಯ

Si el operando "Enable_Start" devuelve el estado lógico "1", se ejecuta la instrucción. Esta lee
el límite inferior variable del ARRAY #ARRAY_A a partir de la segunda dimensión. Si no se
producen errores al ejecutar la instrucción, el resultado se escribe en el operando "Result" y se
activa el operando "Enable_Out".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos del ARRAY (Página 293)
Principios básicos de FUP (Página 8005)

UPPER_BOUND: Leer límite superior de ARRAY
Descripción
En la interfaz de un bloque de función o de una función se pueden declarar variables del tipo
de datos ARRAY[*]. Para estas variables locales pueden leerse los límites del ARRAY. En el
parámetro DIM debe indicarse la dimensión deseada.
Para leer el límite superior variable del ARRAY está disponible la instrucción "Leer límite
superior de ARRAY".
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● La dimensión indicada en la entrada DIM no existe.

1252

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Nota
Disponibilidad de la instrucción
La instrucción está disponible en las CPU de la serie S7-1200 a partir de la versión de firmware
>= 4.2 y en las CPU de la serie S7-1500 a partir de la versión de firmware >= 2.0.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Leer límite superior de ARRAY":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

ARR

Input

ARRAY[*]

FB => sección
InOut

ARRAY cuyo límite superior
variable debe leerse.

FC => sección In‐
put y InOut
DIM

Input

UDINT

I, Q, M, D, L, P o
constante

Dimensión del ARRAY cuyo
límite superior variable debe
leerse.

OUT

Output

DINT

I, Q, M, D, L, P

Resultado

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
833(5B%281'
ಯ(QDEOHB6WDUWಯ

(1

$55$<B$

$55



',0

(12

ಯ(QDEOHB2XWಯ

287

ಯ5HVXOWಯ

Si el operando "Enable_Start" devuelve el estado lógico "1", se ejecuta la instrucción. Esta lee
el límite superior variable del ARRAY #ARRAY_A a partir de la segunda dimensión. Si no se
producen errores al ejecutar la instrucción, el resultado se escribe en el operando "Result" y se
activa el operando "Enable_Out".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos del ARRAY (Página 293)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1253

Instrucciones
4.1 Instrucciones

Legacy
FieldRead: Leer campo
Descripción
La instrucción "Leer campo" permite leer un componente determinado del campo indicado en
el parámetro MEMBER y transferir su contenido a la variable del parámetro VALUE. El índice
del elemento que se lee se define en el parámetro INDEX. En el parámetro MEMBER se indica
el primer elemento del campo que se lee.
Los tipos de datos del componente de campo indicado en el parámetro MEMBER, del índice
y de la variable del parámetro VALUE deben coincidir con el tipo de datos de la instrucción
"Leer campo", puesto que no es posible una conversión implícita.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El elemento indicado en el parámetro INDEX no está definido en el campo especificado en
el parámetro MEMBER.
● Durante la ejecución ocurren errores, p. ej. se produce un rebase por exceso.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Leer campo":
Parámetro

1254

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

INDEX

Input

DINT

DINT

I, Q, M, D, L, I, Q, M, D, L, Índice del
P o constan‐ P o constan‐ elemento cu‐
yo conteni‐
te
te
do se lee

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de memoria
S7-1200

Descripción

S7-1500

MEMBER

Input

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, TOD,
CHAR y
WCHAR co‐
mo elemen‐
tos de una
variable
ARRAY

Números bi‐ D, L
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, TOD,
LTOD,
CHAR y
WCHAR co‐
mo elemen‐
tos de una
variable
ARRAY

D, L

Primer ele‐
mento del
campo que
se lee

VALUE

Output

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, TOD,
CHAR,
WCHAR

Números bi‐ I, Q, M, D, L,
narios, ente‐ P
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, TOD,
LTOD,
CHAR,
WCHAR

I, Q, M, D, L,
P

Operando al
que se trans‐
fiere el con‐
tenido del
elemento

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
)LHOG5HDG
5($/
ಯ7DJ,Qಯ
DBLQGH[
ಯ'%Bಯ
0DLQB)LHOG>@

Programación del PLC
Manual de programación y manejo, 11/2019

(1
,1'(;

9$/8(

DBUHDO
ಯ7DJ2XWಯ

0(0%(5

(12

1255

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Variable

Valor

INDEX

a_index

4

MEMBER

"DB_1".Main_Field[-10]

Primer elemento del campo
"Main_Field[-10..10] of REAL" en el bloque de
datos "DB_1"

VALUE

a_real

Elemento con índice 4 del campo
"Main_Field[-10..10] of REAL"

El elemento con índice 4 se lee del campo "Main_Field[-10...10] of REAL" y se escribe en la
variable "a_real". El elemento que se lee está definido por el valor del parámetro INDEX.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

FieldWrite: Escribir campo
Descripción
La instrucción "Escribir campo" transfiere el contenido de la variable de la entrada VALUE a un
elemento determinado del campo especificado en la salida MEMBER. El índice del elemento
que se escribe se define con el valor de la entrada INDEX. En la salida MEMBER se indica el
primer elemento del campo en el que se escribe.
Los tipos de datos del componente de campo indicado en el parámetro MEMBER, del índice
y de la variable del parámetro VALUE deben coincidir con el tipo de datos de la instrucción
"Leer campo", puesto que no es posible una conversión implícita.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El elemento indicado en la entrada INDEX no está definido en el campo especificado en la
salida MEMBER.
● Durante la ejecución ocurren errores, p. ej. se produce un rebase por exceso.

1256

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Escribir campo":
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

INDEX

Input

DINT

DINT

I, Q, M, D, L, I, Q, M, D, L, Índice del
P o constan‐ P o constan‐ elemento en
el que se es‐
te
te
cribe el con‐
tenido de
VALUE.

VALUE

Input

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, TOD,
CHAR,
WCHAR

Números bi‐ I, Q, M, D, L, I, Q, M, D, L, Operando
narios, ente‐ P o constan‐ P o constan‐ cuyo conte‐
ros, núme‐
te
te
nido se copia
ros en coma
flotante,
tiempos, DA‐
TE, TOD,
LTOD,
CHAR,
WCHAR

MEMBER

Output

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, TOD,
CHAR y
WCHAR co‐
mo elemen‐
tos de una
variable
ARRAY

Números bi‐ D, L
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos, DA‐
TE, TOD,
LTOD,
CHAR y
WCHAR co‐
mo elemen‐
tos de una
variable
ARRAY

D, L

Primer ele‐
mento del
campo en el
que se escri‐
be el conte‐
nido de VA‐
LUE.

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1257

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
)LHOG:ULWH
5($/
ಯ7DJ,Qಯ

(1

DBLQGH[

,1'(;

DBUHDO

9$/8(

0(0%(5

ಯ'%Bಯ
0DLQB)LHOG>@
ಯ7DJ2XWಯ

(12

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

INDEX

a_index

4

VALUE

a_real

10.54

MEMBER

"DB_1".Main_Field[-10]

Primer elemento del campo
"Main_Field[-10..10] of REAL" en el bloque de
datos "DB_1"

El valor "10.54" de la variable "a_real" se escribe en el componente con el índice 4 del campo
"Main_Field[-10 ... 10] of REAL". El índice del elemento de campo al que se transfiere el
contenido de la variable "a_real" está definido por el valor de la entrada INDEX.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

BLKMOV: Copiar área
Descripción
La instrucción "Copiar área" permite copiar los contenidos de un área de memoria (área de
origen) en un área de memoria diferente (área de destino). La operación de copia se realiza por
orden ascendente de direcciones. Las áreas de origen y destino se definen mediante
VARIANT.
Nota
Las variables de la instrucción sólo se pueden usar en áreas de memoria en las que no esté
activado el atributo "Acceso optimizado al bloque". Esto es válido para bloques de datos (DB),
bloques de organización (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucción se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable también se puede usar en áreas de memoria "con acceso
optimizado al bloque".

1258

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La figura siguiente muestra el principio de la operación de copia:

'%'%:

$

%

'%'%:

&

'

'%'%:

(

)

'%'%:

*

+

&RSLDU
/DFRSLDVHHIHFW¼DHQ
VHQWLGRDVFHQGHQWHGH
ODVGLUHFFLRQHV

0:

$

%

0:

&

'

0:

(

)

0:

*

+

UHDGHPHPRULD

Coherencia de los datos de origen y destino
Tenga en cuenta que al ejecutar la instrucción "Copiar área" no se modifican los datos de
origen. De lo contrario no está garantizada la coherencia de los datos de destino.

Posibilidad de interrupción
No hay limitaciones en cuanto a la profundidad de anidamiento.

Áreas de memoria
La instrucción "Copiar área" permite copiar las siguientes áreas de memoria:
● Áreas de un bloque de datos
● Marcas
● Memoria imagen de proceso de las entradas
● Memoria imagen de proceso de las salidas

Reglas generales para copiar
Las áreas de origen y destino no deben solaparse. Si las áreas de origen y destino son de
diferente longitud, se copia solo hasta la longitud del área más pequeña.
Si el área de origen es más pequeña que el área de destino, el área de origen se copiará por
completo en el área de destino. Los restantes bytes del área de destino permanecen
inalterados.

Programación del PLC
Manual de programación y manejo, 11/2019

1259

Instrucciones
4.1 Instrucciones
Si el área de destino es más pequeña que el área de origen, se escribirá en toda el área de
destino. Los restantes bytes del área de origen se ignoran.
Al copiar un área del tipo de datos BOOL, la variable debe direccionarse de forma absoluta y
la longitud indicada del área debe ser un múltiplo de 8, pues de lo contrario no se ejecutará la
instrucción.

Reglas para copiar cadenas de caracteres
La instrucción "Copiar área" permite copiar asimismo áreas de origen y destino del tipo de
datos STRING. Si solo el área de origen es del tipo de datos STRING, se copiarán los
caracteres que realmente contiene la cadena de caracteres. La información sobre la longitud
real y máxima también se escribe en el área de destino. Si tanto el área de origen como el área
de destino son del tipo de datos STRING, la longitud actual de la cadena de caracteres en el
área de destino se pone al número de caracteres realmente copiados.
Si se desea copiar información sobre la longitud máxima y real de una cadena de caracteres,
las áreas de los parámetros SRCBLK y DSTBLK deben indicarse en bytes.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Copiar área":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

SRCBLK

Input

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria que se copia (área de ori‐
gen).

RET_VAL

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

DSTBLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria en la que se copia (área
de destino).

1) El parámetro DSTBLK está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:

1260

Código de
error*
(W#16#...)

Explicación

0000

Ningún error

8092

El área de origen o destino está solo en la memoria de carga.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*
(W#16#...)

Explicación

8152

En el parámetro SRCBLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

8352

En el parámetro DSTBLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
Información
de error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
%/.029
9DULDQW
ಯ7DJ,Qಯ
30%<7(

(1
65&%/.

5(7B9$/
'67%/.

ಯ7DJB5HW9DOಯ
3'%'%;%<7(
ಯ7DJ2XWಯ

(12

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
copia 10 bytes a partir de MB100 y los escribe en el DB1. Si ocurre un error durante la
operación de copia, el respectivo código de error se indica en la variable "Tag_RetVal".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1307)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1261

Instrucciones
4.1 Instrucciones

UBLKMOV: Copiar área sin interrupciones
Descripción
La instrucción "Copiar área sin interrupciones" permite copiar los contenidos de un área de
memoria (área de origen) en un área de memoria diferente (área de destino). La operación de
copia se realiza por orden ascendente de direcciones. Las áreas de origen y destino se definen
mediante VARIANT.
La operación de copia no debe ser interrumpida por otras actividades del sistema operativo.
Ello puede aumentar el tiempo de reacción a alarmas de la CPU durante la ejecución de la
instrucción "Copiar área sin interrupciones".
Nota
Las variables de la instrucción sólo se pueden usar en áreas de memoria en las que no esté
activado el atributo "Acceso optimizado al bloque". Esto es válido para bloques de datos (DB),
bloques de organización (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucción se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable también se puede usar en áreas de memoria "con acceso
optimizado al bloque".

Áreas de memoria
La instrucción "Copiar área sin interrupciones" permite copiar las siguientes áreas de memoria:
● Áreas de un bloque de datos
● Marcas
● Memoria imagen de proceso de las entradas
● Memoria imagen de proceso de las salidas

Reglas generales para copiar
Al ejecutar la instrucción "Copiar área sin interrupciones" no pueden solaparse las áreas de
origen y destino. Si el área de origen es más pequeña que el área de destino, el área de origen
se copiará por completo en el área de destino. Los restantes bytes del área de destino
permanecen inalterados.
Si el área de destino es más pequeña que el área de origen, se escribirá en toda el área de
destino. Los restantes bytes del área de origen se ignoran.
Si un área de origen o destino definida como parámetro formal es menor que un área de origen
o destino indicada en los parámetros SRCBLK o DSTBLK, no se transferirán datos.
Al copiar un área del tipo de datos BOOL, la variable debe direccionarse de forma absoluta y
la longitud indicada del área debe ser un múltiplo de 8, pues de lo contrario no se ejecutará la
instrucción.
La instrucción "Copiar área sin interrupciones" permite copiar 16 KB como máximo. A este
respecto deben tenerse en cuenta las limitaciones específicas de la CPU.

1262

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Reglas para copiar cadenas de caracteres
La instrucción "Copiar área sin interrupciones" permite copiar asimismo áreas de origen y
destino del tipo de datos STRING. Si solo el área de origen es del tipo de datos STRING, se
copiarán los caracteres que realmente contiene la cadena de caracteres. La información sobre
la longitud real y máxima no se escribe en el área de destino. Si tanto el área de origen como
el área de destino son del tipo de datos STRING, la longitud actual de la cadena de caracteres
en el área de destino se pone al número de caracteres realmente copiados. Si se copian áreas
del tipo de datos STRING, debe indicarse "1" como longitud del área.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Copiar área sin interrupciones":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

SRCBLK

Input

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria que se copia (área de ori‐
gen).

RET_VAL

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

DSTBLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria en la que se copia (área
de destino).

1) El parámetro DSTBLK está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error
(W#16#....)

Explicación

0000

Ningún error

8091

El área de origen o destino está solo en la memoria de carga.

8152

En el parámetro SRCBLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

8352

En el parámetro DSTBLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

Programación del PLC
Manual de programación y manejo, 11/2019

1263

Instrucciones
4.1 Instrucciones
Código de
error
(W#16#....)

Explicación

Información
de error ge‐
neral

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
8%/.029
9DULDQW
ಯ7DJ,Qಯ
30%<7(

(1
65&%/.

5(7B9$/
'67%/.

ಯ7DJB5HW9DOಯ
3'%'%;%<7(
ಯ7DJ2XWಯ

(12

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
copia 10 bytes a partir de MB100 y los escribe en el DB1. Si ocurre un error durante la
operación de copia, el respectivo código de error se indica en la variable "Tag_RetVal".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1307)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de FUP (Página 8005)

FILL: Rellenar área
Descripción
La instrucción "Rellenar área" rellena un área de memoria (área de destino) con el contenido
de un área de memoria diferente (área de origen). La instrucción "Rellenar área" copia el
contenido del área de origen en el área de destino las veces necesarias hasta que el área de
destino quede escrita por completo. La operación de copia se realiza por orden ascendente de
direcciones.

1264

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Las áreas de origen y destino se definen mediante VARIANT.
Nota
Las variables de la instrucción sólo se pueden usar en áreas de memoria en las que no esté
activado el atributo "Acceso optimizado al bloque". Esto es válido para bloques de datos (DB),
bloques de organización (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucción se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable también se puede usar en áreas de memoria "con acceso
optimizado al bloque".
Para los bloques con el atributo "Acceso optimizado al bloque" puede utilizarse la instrucción
"FILL_BLK: Rellenar área".
La figura siguiente muestra el principio de la operación de copia:
),//

%9$/

$

%

0:

$

%

0:

&

'

0:

&

'

0:

(

)

0:

(

)

0:

*

+

0:

*

+

0:

$

%

0:

&

'

0:

(

)

0:

*

+

0:

$

%

0:

&

'

0:

%/.

Coherencia de los datos de origen y destino
Tenga en cuenta que al ejecutar la instrucción "Rellenar área" no se modifican los datos de
origen, pues de lo contrario no se podría garantizar la coherencia de los datos de destino.

Áreas de memoria
La instrucción "Rellenar área" permite copiar las siguientes áreas de memoria:
● Áreas de un bloque de datos
● Marcas

Programación del PLC
Manual de programación y manejo, 11/2019

1265

Instrucciones
4.1 Instrucciones
● Memoria imagen de proceso de las entradas
● Memoria imagen de proceso de las salidas

Reglas generales para copiar
Las áreas de origen y destino no deben solaparse. Aunque el área de destino que se debe
inicializar no sea múltiplo entero de la longitud del parámetro de entrada BVAL, el área de
destino se rellenará igualmente hasta el último byte.
Si el área de destino que se debe rellenar es menor que el área de origen, sólo se copiarán los
datos que quepan en el área de destino.
Si el área de origen o destino realmente existente es menor que el tamaño del área de memoria
parametrizada para el área de origen o destino (parámetros BVAL, BLK), los datos no se
transfieren.
Si el puntero ANY (origen o destino) es del tipo de datos BOOL, debe direccionarse de forma
absoluta y la longitud indicada del área debe ser un múltiplo de 8, pues de lo contrario no se
ejecutará la instrucción.
Si el área de destino es del tipo de datos STRING, la instrucción escribe la cadena de
caracteres completa, incluida la información de administración.

Reglas para copiar estructuras
Al transferir una estructura a modo de parámetro de entrada, tenga en cuenta que la longitud
de una estructura se rige siempre por un número par de bytes. Si se declara una estructura con
un número impar de bytes, la estructura necesitará un byte adicional de espacio en memoria.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Rellenar área":
Parámetro

Declaración

Tipo de datos

EN

Input

BOOL

Área de memoria
I, Q, M, D, L, T, C o
constante

Descripción
Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

BVAL

Input

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria (área de origen) con cuyo
contenido se rellena el área
de destino en el parámetro
BLK.

RET_VAL

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

1266

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

BLK

Output 1)

VARIANT

Área de memoria
I, Q, M, D, L, P

Descripción
Indicación del área de memo‐
ria que se rellena con el con‐
tenido del área de origen.

1) El parámetro BLK está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

8092

El área de origen o destino está solo en la memoria de carga.

8152

En el parámetro BVAL no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

8352

En el parámetro BLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

Información
Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
de error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
),//
9DULDQW
ಯ7DJ,Qಯ
30:25'

(1
%9$/

5(7B9$/
%/.

ಯ7DJB5HW9DOಯ
30:25'
ಯ7DJ2XWಯ

(12

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
copia el área de origen de MW14 a MW20 y rellena el área de destino de MW100 a MW118 con
el contenido de las 4 palabras contenidas en el área de memoria del parámetro BVAL.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Programación del PLC
Manual de programación y manejo, 11/2019

1267

Instrucciones
4.1 Instrucciones
GET_ERR_ID: Consultar ID de error localmente (Página 1307)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de FUP (Página 8005)

Conversión
CONVERT: Convertir valor
Descripción
La instrucción "Convertir valor" lee el contenido del parámetro IN y lo convierte según los tipos
de datos parametrizados en el cuadro de la instrucción. El valor convertido se deposita en la
salida OUT.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Durante la ejecución ocurren errores, p. ej. se produce un rebase por exceso.

Opciones de conversión de secuencias de bits
En el cuadro de la instrucción no se pueden seleccionar las secuencias de bits BYTE y WORD.
Sin embargo es posible indicar un operando del tipo de datos DWORD o LWORD en un
parámetro de la instrucción si coinciden la longitud del operando de entrada y la del operando
de salida. En tal caso, el operando del tipo de datos de una secuencia de bits se interpreta
conforme al tipo de datos del parámetro de entrada o salida y se convierte implícitamente. El
tipo de datos DWORD se interpreta, p. ej., como DINT/UDINT, y LWORD como LINT/ULINT.
Estas opciones de conversión también están disponibles estando activada la verificación CEI.
Nota
Para las CPU de las series S7-1500 se aplica: Los tipos de datos DWORD y LWORD sólo se
pueden convertir a o desde el tipo de datos REAL o LREAL.
El patrón de bits del valor de origen se transfiere sin cambios y justificado a la derecha al tipo
de datos de destino. Si no se producen errores durante la conversión, el estado de señal de la
salida de habilitación ENO = 1; si se produce un error durante la ejecución, el estado de señal
de la salida de habilitación ENO = 0.

1268

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Convertir valor":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de habili‐
tación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habilita‐
ción

IN

Input

I, Q, M, D, L, I, Q, M, D, L,
Secuencias de
P o constante P o constan‐
bits, enteros, nú‐
te
meros en coma flo‐
tante, CHAR,
WCHAR, BCD16,
BCD32

Valor que se con‐
vierte.

OUT

Output

I, Q, M, D, L, P I, Q, M, D, L,
Secuencias de
P
bits, enteros, nú‐
meros en coma flo‐
tante, CHAR,
WCHAR, BCD16,
BCD32

Resultado de la
conversión

En las listas desplegables "???" del cuadro de la instrucción se pueden seleccionar los tipos
de datos de la instrucción.

Ejemplo
El ejemplo siguiente muestra la conversión de un entero (16 bits) a otro entero (32 bits):
&219
,17
ಯ7DJ,Qಯ
ಯ,QSXWB,17ಯ

WR

',17

(1

(12

,1

287

ಯ7DJ2XWಯ

ಯ2XWSXWB',17ಯ

El ejemplo siguiente muestra la conversión de un byte (8 bits) al entero SINT (8 bits):
&219
6,17 WR
ಯ7DJ,Qಯ
ಯ,QSXWB%<7(ಯ

6,17

(1

(12

,1

287

ಯ7DJ2XWಯ

ಯ2XWSXWB6,17ಯ

El ejemplo siguiente muestra la conversión de un byte (8 bits) a un entero sin signo USINT (8
bits):

Programación del PLC
Manual de programación y manejo, 11/2019

1269

Instrucciones
4.1 Instrucciones
&219
86,17 WR 86,17
ಯ7DJ,Qಯ
ಯ,QSXWB%<7(ಯ

(1

(12

,1

287

ಯ7DJ2XWಯ

ಯ2XWSXWB86,17ಯ

Las conversiones son posibles porque los operandos tienen la misma longitud.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Conversión de los tipos de datos en el S7-1200 (Página 506)
Principios básicos de FUP (Página 8005)

ROUND: Redondear número
Descripción
La instrucción "Redondear número" permite redondear el valor de la entrada IN al siguiente
número entero. La instrucción interpreta el valor de la entrada IN como número en coma
flotante y lo convierte al número entero más próximo. Si el valor de entrada se encuentra entre
dos números, se convierte el número par. El resultado de la instrucción se devuelve en la salida
OUT y se puede consultar allí.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Durante la ejecución ocurren errores, p. ej. se produce un rebase por exceso.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Redondear número":

1270

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

S7-1200

S7-1500

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN

Input

Números en
coma flotante

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valor de entra‐
da que se re‐
dondea.

OUT

Output

Enteros, núme‐ I, Q, M, D, L, P I, Q, M, D, L, P Resultado del
ros en coma
redondeo
flotante

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En las listas desplegables "???" del cuadro de la instrucción se pueden seleccionar los tipos
de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
5281'
5($/ WR ',17
ಯ7DJ,Qಯ

(1

287

,1

(12

ಯ7DJ,QB9DOXHಯ

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

IN

TagIn_Value

1.50000000

Valor
-1.50000000

OUT

TagOut_Value

2

-2

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El número en
coma flotante de la entrada "TagIn_Value" se redondea al número entero par más próximo y
se deposita en la salida "TagOut_Value". Si no ocurren errores al ejecutar la instrucción, se
activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Conversiones explícitas (Página 529)
Principios básicos de FUP (Página 8005)

CEIL: Redondear un número en coma flotante al siguiente entero superior
Descripción
La instrucción "Redondear un número en coma flotante al siguiente entero superior" permite
redondear el valor de la entrada IN al siguiente número entero superior. La instrucción
interpreta el valor de la entrada IN como número en coma flotante y lo convierte en el siguiente
número entero superior. El resultado de la instrucción se devuelve en la salida OUT y se puede
consultar allí. El valor de salida puede ser mayor o igual al valor de entrada.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Durante la ejecución ocurren errores, p. ej. se produce un rebase por exceso.

Programación del PLC
Manual de programación y manejo, 11/2019

1271

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Redondear un número en coma
flotante al siguiente entero superior":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

S7-1200

S7-1500

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN

Input

Números en
coma flotante

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valor de entra‐
da como núme‐
ro en coma flo‐
tante

OUT

Output

Enteros, núme‐ I, Q, M, D, L, P I, Q, M, D, L, P Resultado con
ros en coma
el siguiente en‐
flotante
tero superior

En las listas desplegables "???" del cuadro de la instrucción se pueden seleccionar los tipos
de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
&(,/
5($/
ಯ7DJ,Qಯ
ಯ7DJ,QB9DOXHಯ

WR

',17

(1

287

,1

(12

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

TagIn_Value

0.50000000

-0.50000000

OUT

TagOut_Value

1

0

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El número en
coma flotante de la entrada "TagIn_Value" se redondea al siguiente número entero superior y
se devuelve en la salida "TagOut_Value". Si no ocurren errores al ejecutar la instrucción, se
activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)

1272

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Conversiones explícitas (Página 529)
Principios básicos de FUP (Página 8005)

FLOOR: Redondear un número en coma flotante al siguiente entero inferior
Descripción
La instrucción "Redondear un número en coma flotante al siguiente entero inferior" permite
redondear el valor de la entrada IN al siguiente número entero inferior. La instrucción interpreta
el valor de la entrada IN como número en coma flotante y lo convierte en el siguiente número
entero inferior. El resultado de la instrucción se deposita en la salida OUT y se puede consultar
allí. El valor de salida puede ser menor o igual al valor de entrada.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Durante la ejecución ocurren errores, p. ej. se produce un rebase por exceso.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Redondear un número en coma
flotante al siguiente entero inferior":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN

Input

Números en
coma flotante

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valor de entra‐
da como núme‐
ro en coma flo‐
tante

OUT

Output

Enteros, núme‐ I, Q, M, D, L, P I, Q, M, D, L, P Resultado con
ros en coma
el siguiente en‐
flotante
tero inferior

En las listas desplegables "???" del cuadro de la instrucción se pueden seleccionar los tipos
de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1273

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

5($/
ಯ7DJ,Qಯ
ಯ7DJ,QB9DOXHಯ

)/225
WR ',17

(1

287

,1

(12

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

TagIn_Value

0.50000000

-0.50000000

OUT

TagOut_Value

0

-1

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El número en
coma flotante de la entrada "TagIn_Value" se redondea al número entero inferior más próximo
y se deposita en la salida "TagOut_Value". Si no ocurren errores al ejecutar la instrucción, se
activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Conversiones explícitas (Página 529)
Principios básicos de FUP (Página 8005)

TRUNC: Truncar a entero
Descripción
La instrucción "Truncar a entero" permite generar un valor entero a partir del valor de la entrada
IN. El valor de la entrada IN se interpreta como número en coma flotante. La instrucción
selecciona solo la parte entera del número en coma flotante y la deposita sin decimales en la
salida OUT.
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● Durante la ejecución ocurren errores, p. ej. se produce un rebase por exceso.

1274

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Truncar a entero":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

IN

Input

Números en coma
flotante

I, Q, M, D, L o
constante

Valor de entrada como núme‐
ro en coma flotante

OUT

Output

Enteros, números
en coma flotante

I, Q, M, D, L

Resultado con la parte ente‐
ra del número en coma flo‐
tante

En las listas desplegables "???" del cuadro de la instrucción se pueden seleccionar los tipos
de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

5($/
ಯ7DJ,Qಯ

7581&
WR ',17

(1

287

,1

(12

ಯ7DJ,QB9DOXHಯ

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

IN

TagIn_Value

1.50000000

Valor
-1.50000000

OUT

TagOut_Value

1

-1

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La parte entera
del número en coma flotante de la entrada "TagIn_Value" se convierte en un número entero y
se deposita en la salida "TagOut_Value". Si no ocurren errores al ejecutar la instrucción, se
activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Conversiones explícitas (Página 529)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1275

Instrucciones
4.1 Instrucciones

SCALE_X: Escalar
Descripción
La instrucción "Escalar" escala el valor de la entrada VALUE mapeándolo en un determinado
rango de valores. Al ejecutar la instrucción "Escalar", el número en coma flotante de la entrada
VALUE se escala al rango de valores definido por los parámetros MIN y MAX. El resultado de
la escala es un número entero que se deposita en la salida OUT.
La figura siguiente muestra un ejemplo de cómo pueden escalarse los valores:

0$;
287
0,1



9$/8(

La instrucción "Escalar" utiliza la siguiente ecuación:
OUT = [VALUE ∗ (MAX – MIN)] + MIN
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El valor de la entrada MIN es mayor o igual al valor de la entrada MAX.
● El valor de un número en coma flotante indicado está fuera del rango de los números
normalizados según IEEE-754.
● Ocurre un rebase por exceso.
● El valor de la entrada VALUE es NaN (Not a number = resultado de una operación
aritmética no válida).
Nota
Encontrará más información sobre la conversión de valores analógicos en el manual de
producto correspondiente.

1276

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Escalar":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habili‐
tación

MIN

Input

Enteros, núme‐ I, Q, M, D, L
ros en coma flo‐ o constante
tante

I, Q, M, D, L o
constante

Límite inferior
del rango de va‐
lores

VALUE

Input

Números en co‐ I, Q, M, D, L
ma flotante
o constante

I, Q, M, D, L o
constante

Valor que se es‐
cala.
Si se indica una
constante, esta
debe declarar‐
se.

MAX

Input

Enteros, núme‐ I, Q, M, D, L
ros en coma flo‐ o constante
tante

I, Q, M, D, L o
constante

Límite superior
del rango de va‐
lores

OUT

Output

Enteros, núme‐ I, Q, M, D, L
ros en coma flo‐
tante

I, Q, M, D, L

Resultado de la
escala

En las listas desplegables "???" del cuadro de la instrucción se pueden seleccionar los tipos
de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Encontrará más información sobre la declaración de constantes en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
6&$/(B;
5($/
ಯ7DJ,Qಯ
ಯ7DJB0,1ಯ

WR

',17

(1
0,1

ಯ7DJB9DOXHಯ

9$/8(

287

ಯ7DJB0$;ಯ

0$;

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

Programación del PLC
Manual de programación y manejo, 11/2019

6

1277

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

MIN

Tag_MIN

10

VALUE

Tag_Value

0.5

MAX

Tag_MAX

30

OUT

Tag_Result

20

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El valor de la
entrada "Tag_Value" se escala al rango de valores definido por los valores de las entradas
"Tag_MIN" y "Tag_MAX". El resultado se deposita en la salida "Tag_Result". Si no se producen
errores al ejecutar la instrucción, la salida de habilitación ENO devuelve el estado lógico "1" y
se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

NORM_X: Normalizar
Descripción
La instrucción "Normalizar" normaliza el valor de la variable de la entrada VALUE
representándolo en una escala lineal. Los parámetros MIN y MAX sirven para definir los límites
del rango de valores que se refleja en la escala. En función de la posición del valor que se debe
normalizar en este rango de valores, se calcula el resultado y se deposita como número en
coma flotante en la salida OUT. Si el valor que se debe normalizar es igual al valor de la entrada
MIN, la salida OUT devuelve el valor "0.0". Si el valor que se debe normalizar es igual al valor
de la entrada MAX, la salida OUT devuelve el valor "1.0".
La figura siguiente muestra un ejemplo de cómo pueden normalizarse los valores:

1278

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones


287

0,1

0$;
9$/8(

La instrucción "Normalizar" utiliza la siguiente ecuación:
OUT = (VALUE – MIN) / (MAX – MIN)
La salida de habilitación ENO devuelve el estado lógico "0" cuando se cumple una de las
condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El valor de la entrada MIN es mayor o igual al valor de la entrada MAX.
● El valor de un número en coma flotante indicado está fuera del rango de los números
normalizados según IEEE-754.
● El valor de la entrada VALUE es NaN (resultado de una operación aritmética no válida).
Nota
Encontrará más información sobre la conversión de valores analógicos en el manual de
producto correspondiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Normalizar":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habili‐
tación

Programación del PLC
Manual de programación y manejo, 11/2019

1279

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

Descripción

S7-1500

MIN 1)

Input

Enteros, núme‐ I, Q, M, D, L
ros en coma flo‐ o constante
tante

I, Q, M, D, L o
constante

Límite inferior
del rango de va‐
lores

VALUE 1)

Input

Enteros, núme‐ I, Q, M, D, L
ros en coma flo‐ o constante
tante

I, Q, M, D, L o
constante

Valor que se
normaliza.

MAX 1)

Input

Enteros, núme‐ I, Q, M, D, L
ros en coma flo‐ o constante
tante

I, Q, M, D, L o
constante

Límite superior
del rango de va‐
lores

OUT

Output

Números en co‐ I, Q, M, D, L
ma flotante

I, Q, M, D, L

Resultado de la
normalización

1)

Si se utilizan constantes en estos tres parámetros, basta con declarar una de ellas.

En las listas desplegables "???" del cuadro de la instrucción se pueden seleccionar los tipos
de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Encontrará más información sobre la declaración de constantes en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
1250B;
',17
ಯ7DJ,Qಯ
ಯ7DJB0,1ಯ

WR

5($/

(1
0,1

ಯ7DJB9DOXHಯ

9$/8(

287

ಯ7DJB0$;ಯ

0$;

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ
6

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

MIN

Tag_MIN

10

VALUE

Tag_Value

20

MAX

Tag_MAX

30

OUT

Tag_Result

0.5

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El valor de la
entrada "Tag_Value" se asigna al rango de valores definido por los valores de las entradas
"Tag_MIN" y "Tag_MAX". El valor de la variable de la entrada "Tag_Value" se normaliza
conforme al rango de valores definido. El resultado se deposita como número en coma flotante
en la salida "Tag_Result". Si no se producen errores al ejecutar la instrucción, la salida de
habilitación ENO devuelve el estado lógico "1" y se activa la salida "TagOut".

1280

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

Legacy
SCALE: Escalar
Descripción
La instrucción "Escalar" convierte el entero del parámetro IN en un número en coma flotante
que se escala en unidades físicas entre un límite inferior y uno superior. Los límites inferior y
superior del rango de valores en el que se escala el valor de entrada se definen mediante los
parámetros LO_LIM y HI_LIM. El resultado de la instrucción se devuelve en el parámetro OUT.
La instrucción "Escalar" utiliza la siguiente ecuación:
OUT = [((FLOAT (IN) – K1)/(K2–K1)) ∗ (HI_LIM–LO_LIM)] + LO_LIM
El estado lógico del parámetro BIPOLAR determina los valores de las constantes "K1" y "K2".
El parámetro BIPOLAR puede tener los siguientes estados lógicos:
● Estado lógico "1": se presupone que el valor del parámetro IN es bipolar y está comprendido
en un rango de valores entre -27648 y 27648. En este caso, la constante "K1" tiene el valor
-27648,0, y la constante "K2", el valor +27648,0.
● Estado lógico "0": se presupone que el valor del parámetro IN es unipolar y está
comprendido en un rango de valores entre 0 y 27648. En este caso, la constante "K1" tiene
el valor 0,0, y la constante "K2", el valor +27648,0.
Si el valor del parámetro IN es mayor que el de la constante "K2", el resultado de la instrucción
se pone al valor del límite superior (HI_LIM) y se emite un error.
Si el valor del parámetro IN es menor que el de la constante "K1", el resultado de la instrucción
se pone al valor del límite inferior (LO_LIM) y se emite un error.
Si el límite inferior indicado es mayor que el límite superior (LO_LIM > HI_LIM), el resultado se
escala inversamente proporcional al valor de entrada.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Escalar":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

Programación del PLC
Manual de programación y manejo, 11/2019

1281

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

IN

Input

INT

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valor de entra‐
da que se es‐
cala.

HI_LIM

Input

REAL

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valor límite su‐
perior

LO_LIM

Input

REAL

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valor límite in‐
ferior

BIPOLAR

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L o
constante

Indica si el va‐
lor del paráme‐
tro IN se inter‐
preta como bi‐
polar o unipo‐
lar. El paráme‐
tro puede
adoptar los va‐
lores siguien‐
tes:
1: Bipolar
0: Unipolar

OUT

Output

REAL

I, Q, M, D, L, P I, Q, M, D, L, P Resultado de
la instrucción

RET_VAL

Output

WORD

I, Q, M, D, L, P I, Q, M, D, L, P Información de
error

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

0008

El valor del parámetro IN es mayor que el de la constante "K2" o menor que el de la
constante "K1".

Información
de error ge‐
neral

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

1282

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
6&$/(
ಯ7DJ,Qಯ
ಯ7DJB,QSXW9DOXHಯ

(1
,1

ಯ7DJB+LJK/LPLWಯ

+,B/,0

5(7B9$/

ಯ7DJB/RZ/LPLWಯ

/2B/,0

287

ಯ7DJB%LSRODUಯ

%,32/$5

ಯ7DJB(UURU&RGHಯ
ಯ7DJB2XWSXW9DOXHಯ
ಯ7DJ2XWಯ

(12

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

Tag_InputValue

22

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

OUT

Tag_OutputValue

50.03978588

RET_VAL

Tag_ErrorCode

W#16#0000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1307)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de FUP (Página 8005)

UNSCALE: Desescalar
Descripción
La instrucción "Desescalar" desescala el número en coma flotante del parámetro IN en
unidades físicas entre un valor límite inferior y un valor límite superior y lo convierte en un
número entero. Los límites inferior y superior del rango de valores en el que se desescala el
valor de entrada se definen mediante los parámetros LO_LIM y HI_LIM. El resultado de la
instrucción se devuelve en el parámetro OUT.
La instrucción "Desescalar" utiliza la siguiente ecuación:
OUT = [ ((IN–LO_LIM)/(HI_LIM–LO_LIM)) ∗ (K2–K1) ] + K1

Programación del PLC
Manual de programación y manejo, 11/2019

1283

Instrucciones
4.1 Instrucciones
El estado lógico del parámetro BIPOLAR determina los valores de las constantes "K1" y "K2".
El parámetro BIPOLAR puede tener los siguientes estados lógicos:
● Estado lógico "1": se presupone que el valor del parámetro IN es bipolar y está comprendido
en un rango de valores entre -27648 y 27648. En este caso, la constante "K1" tiene el valor
-27648,0, y la constante "K2", el valor +27648,0.
● Estado lógico "0": se presupone que el valor del parámetro IN es unipolar y está
comprendido en un rango de valores entre 0 y 27648. En este caso, la constante "K1" tiene
el valor 0,0, y la constante "K2", el valor +27648,0.
Si el valor del parámetro IN no se encuentra dentro de los límites definidos por HI_LIM y
LO_LIM, se emite un error. El resultado se ajusta al límite más próximo.
Si el límite inferior indicado es mayor que el límite superior (LO_LIM > HI_LIM), el resultado se
escala de forma inversamente proporcional al valor de entrada.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Desescalar":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Input

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN

Input

REAL

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valor de entra‐
da que se de‐
sescala en un
valor entero.

HI_LIM

Input

REAL

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valor límite su‐
perior

LO_LIM

Input

REAL

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valor límite in‐
ferior

BIPOLAR

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L o
constante

Indica si el va‐
lor del paráme‐
tro IN se inter‐
preta como bi‐
polar o unipo‐
lar. El paráme‐
tro puede
adoptar los va‐
lores siguien‐
tes:
1: Bipolar
0: Unipolar

1284

OUT

Output

INT

I, Q, M, D, L, P I, Q, M, D, L, P Resultado de
la instrucción

RET_VAL

Output

WORD

I, Q, M, D, L, P I, Q, M, D, L, P Información de
error

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

0008

El valor del parámetro IN es mayor que el del límite superior (HI_LIM) o menor que el del
límite inferior (LO_LIM).

Información
de error ge‐
neral

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización aquí: Cambiar
formatos de visualización en el estado del programa (Página 8529)

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
816&$/(
ಯ7DJ,Qಯ
ಯ7DJB,QSXW9DOXHಯ

(1
,1

ಯ7DJB+LJK/LPLWಯ

+,B/,0

5(7B9$/

ಯ7DJB/RZ/LPLWಯ

/2B/,0

287

ಯ7DJB%LSRODUಯ

%,32/$5

ಯ7DJB(UURU&RGHಯ
ಯ7DJB2XWSXW9DOXHಯ
ಯ7DJ2XWಯ

(12

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

Tag_InputValue

50.03978588

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

OUT

Tag_OutputValue

22

RET_VAL

Tag_ErrorCode

W#16#0000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
GET_ERR_ID: Consultar ID de error localmente (Página 1307)

Programación del PLC
Manual de programación y manejo, 11/2019

1285

Instrucciones
4.1 Instrucciones
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de FUP (Página 8005)

Control del programa
JMP: Saltar si RLO = 1
Descripción
La instrucción "Saltar si RLO = 1" permite interrumpir la ejecución lineal del programa y
continuarla en un segmento diferente. El segmento de destino tiene que marcarse con una
etiqueta (LABEL). El nombre de la etiqueta se indica en el comodín situado encima del cuadro
de la instrucción.
La etiqueta indicada debe encontrarse en el mismo bloque en el que se ejecuta la instrucción.
Su nombre debe ser unívoco en el bloque. En un segmento no se puede utilizar más de una
bobina de salto.
Si el resultado lógico (RLO) de la entrada de la instrucción es "1", se ejecuta el salto al
segmento identificado por la etiqueta indicada. El salto puede realizarse hacia números de
segmento superiores o inferiores.
Si no se cumple la condición en la entrada de la instrucción (RLO = 0), la ejecución del
programa continúa en el segmento siguiente.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
6HJPHQWR

&$6
ಯ7DJ,QBಯ

6HJPHQWR

-03
ಯ7DJ2XWBಯ

ಯ7DJ,QBಯ

5

6HJPHQWR
&$6
ಯ7DJ2XWBಯ
ಯ7DJ,QBಯ

5

Si el operando "TagIn_1" devuelve el estado lógico "1", se ejecuta la instrucción. Por este
motivo, se interrumpe la ejecución lineal del programa y se prosigue en el segmento 3,
marcado por la etiqueta CAS1. Si la entrada "TagIn_3" devuelve el estado lógico "1", se
desactiva la salida "TagOut_3".

1286

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

JMPN: Saltar si RLO = 0
Descripción
La instrucción "Saltar si RLO = 0" permite interrumpir la ejecución lineal del programa y
continuarla en un segmento diferente, si el resultado lógico de la entrada de la instrucción es
"0". El segmento de destino tiene que marcarse con una etiqueta (LABEL). El nombre de la
etiqueta se indica en el comodín situado encima del cuadro de la instrucción.
La etiqueta indicada debe encontrarse en el mismo bloque en el que se ejecuta la instrucción.
Su nombre debe ser unívoco en el bloque. En un segmento no se puede utilizar más de una
bobina de salto.
Si el resultado lógico (RLO) de la entrada de la instrucción es "0", se ejecuta el salto al
segmento identificado por la etiqueta indicada. El salto puede realizarse hacia números de
segmento superiores o inferiores.
Si el RLO de la entrada de la instrucción es "1", la ejecución del programa continúa en el
segmento siguiente.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
6HJPHQWR

&$6
ಯ7DJ,QBಯ

6HJPHQWR

-031
ಯ7DJ2XWBಯ

ಯ7DJ,QBಯ

5

6HJPHQWR
&$6
ಯ7DJ2XWBಯ
ಯ7DJ,QBಯ

5

Si el operando "TagIn_1" devuelve el estado lógico "0", se ejecuta la instrucción. Por este
motivo, se interrumpe la ejecución lineal del programa y se prosigue en el segmento 3,
marcado por la etiqueta CAS1. Si la entrada "TagIn_3" devuelve el estado lógico "1", se
desactiva la salida "TagOut_3".

Programación del PLC
Manual de programación y manejo, 11/2019

1287

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

LABEL: Etiqueta
Descripción
La etiqueta de salto marca un segmento de destino en el que se debe continuar la ejecución
del programa tras ejecutar una instrucción de salto.
La etiqueta y la instrucción en la que se indica la etiqueta como destino del salto deben
encontrarse en el mismo bloque. El nombre de una etiqueta debe ser unívoca en el bloque.
Puede declarar un máximo de 32 etiquetas en caso de utilizar una CPU S7-1200 y un máximo
de 256 etiquetas en caso de utilizar una CPU S7-1500.
En un segmento solo se puede colocar una etiqueta. A toda etiqueta se puede acceder desde
distintas posiciones.
Para la etiqueta deben observarse las siguientes reglas gramaticales:
● Letras (a-z, A-Z)
● Una combinación de letras y números. Es importante observar el orden, es decir, primero
las letras y después los números (a - z, A - Z, 0 - 9).
● No pueden utilizarse caracteres especiales o una combinación de letras y números en
orden inverso, es decir, primero los números y después las letras (0 - 9, a - z, A - Z).

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
6HJPHQWR

&$6
ಯ7DJ,QBಯ

6HJPHQWR

-03
ಯ7DJ2XWBಯ

ಯ7DJ,QBಯ

5

6HJPHQWR
&$6
ಯ7DJ2XWBಯ
ಯ7DJ,QBಯ

5

Si el operando "TagIn_1" devuelve el estado lógico "1", se ejecuta la instrucción. Por este
motivo, se interrumpe la ejecución lineal del programa y se prosigue en el segmento 3,
marcado por la etiqueta CAS1. Si la entrada "TagIn_3" devuelve el estado lógico "1", se
desactiva la salida "TagOut_3".

1288

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

JMP_LIST: Definir lista de saltos
Descripción
La instrucción "Definir lista de saltos" permite definir varios saltos condicionados y continuar la
ejecución del programa en un segmento determinado en función del valor del parámetro K.
Los saltos se definen mediante etiquetas (LABEL) que se indican en las salidas del cuadro de
la instrucción. El número de salidas del cuadro de la instrucción se puede ampliar. Puede
declarar un máximo de 32 salidas en caso de utilizar una CPU S7-1200 y un máximo de 256
salidas en caso de utilizar una CPU S7-1500.
La numeración de las salidas comienza por el valor "0" y continúa en orden ascendente con
cada nueva salida. En las salidas de la instrucción únicamente se pueden indicar etiquetas. No
está permitido indicar instrucciones u operandos.
Con el valor del parámetro K se indica el número de la salida y a la vez la etiqueta en la que
debe continuarse la ejecución del programa. Si el valor del parámetro K es mayor que el
número de salidas disponibles, la ejecución del programa continúa en el siguiente segmento
del bloque.
La instrucción "Definir lista de saltos" se ejecuta solo si el estado lógico de la entrada de
habilitación EN es "1".

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Definir lista de saltos":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, L, D o
constante

Entrada de habilitación

K

Input

UINT

I, Q, M, L, D o
constante

Indica el número de la salida
y a la vez el salto que se eje‐
cuta.

DEST0

-

-

-

Primera etiqueta

DEST1

-

-

-

Segunda etiqueta

DESTn

-

-

-

Etiquetas opcionales

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1289

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
-03B/,67
ಯ7DJB,QSXWಯ

(1

ಯ7DJB9DOXHಯ

.

'(67

/$%(/

'(67

/$%(/

'(67

/$%(/

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando/etiqueta

Valor

K

Tag_Value

1

DEST0

LABEL0

Salto al segmento que está mar‐
cado con la etiqueta "LABEL0".

DEST1

LABEL1

Salto al segmento que está mar‐
cado con la etiqueta "LABEL1".

DEST2

LABEL2

Salto al segmento que está mar‐
cado con la etiqueta "LABEL2".

Si el operando "Tag_Input" devuelve el estado lógico "1", se ejecuta la instrucción. La
ejecución del programa continúa conforme al valor del operando "Tag_Value" en el segmento
que está marcado con la etiqueta "LABEL1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

SWITCH: Distribuidor de saltos
Descripción
La instrucción "Distribuidor de saltos" permite definir varios saltos de programa que se
ejecutarán en función del resultado de una o varias instrucciones de comparación.
El valor que se va a comparar se especifica en el parámetro K. Este valor se compara con los
valores que devuelven las distintas entradas. El tipo de comparación se selecciona
individualmente para cada entrada. La disponibilidad de las diferentes instrucciones de
comparación depende del tipo de datos de la instrucción.

1290

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra las instrucciones de comparación disponibles en función del tipo de
datos elegido:
Tipo de datos
S7-1200

Instrucción

Sintaxis

S7-1500

Secuencias de bits Secuencias de bits Igual
Enteros, números Enteros, números
en coma flotante, en coma flotante,
TIME, DATE, TOD TIME, LTIME, DA‐
TE, TOD, LTOD,
LDT

==

Diferente

<>

Igual

==

Diferente

<>

Mayor o igual

>=

Menor o igual

<=

Mayor

>

Menor

<

El tipo de datos de la instrucción se selecciona en la lista desplegable "???" del cuadro de la
instrucción. Si selecciona una instrucción de comparación sin que esté definido el tipo de datos
de la instrucción, en la lista desplegable "???" solo aparecerán los tipos de datos permitidos
para la instrucción de comparación seleccionada.
La ejecución de la instrucción comienza por la primera comparación y se sigue ejecutando
hasta que se cumpla una condición de comparación. Cuando se cumple una condición de
comparación, no se tienen en cuenta las siguientes condiciones de comparación. Si no se
cumple ninguna de las condiciones de comparación indicadas, el salto se ejecuta en la salida
ELSE. Si en la salida ELSE no hay definida ninguna etiqueta, no se interrumpe la ejecución
lineal del programa, sino que continúa en el segmento siguiente.
El cuadro de la instrucción contiene en estado estacionario mín. 2 salidas (DEST0 y DEST1).
El número de salidas es ampliable. La numeración de las salidas comienza por el valor "0" y
continúa en orden ascendente con cada nueva salida. Indique etiquetas (LABEL) en las
salidas de la instrucción. No está permitido indicar instrucciones u operandos en las salidas de
la instrucción.
Por cada salida adicional se inserta automáticamente una entrada. El salto programado en una
salida se ejecuta cuando se cumple la condición de comparación de la entrada
correspondiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Distribuidor de saltos":
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de me‐ Descripción
moria

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

Entrada de habilita‐
ción

K

Input

UINT

UINT

I, Q, M, D, L
o constante

Indica el valor que
se compara.

Programación del PLC
Manual de programación y manejo, 11/2019

1291

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos
S7-1200

S7-1500

Área de me‐ Descripción
moria

<Valores de
compara‐
ción>

Input

Secuencias de
bits, enteros,
números en co‐
ma flotante, TI‐
ME, DATE,
TOD

Secuencias de
bits, enteros,
números en
coma flotante,
TIME, LTIME,
DATE, TOD,
LTOD, LDT

I, Q, M, D, L
o constante

Valores de entrada
con los que se com‐
para el valor del pa‐
rámetro K.

DEST0

-

-

-

-

Primera etiqueta

DEST1

-

-

-

-

Segunda etiqueta

DEST(n)

-

-

-

-

Etiquetas opciona‐
les:
● S7-1200: n = de
2 a 32
● S7-1500: n = de
2 a 256

ELSE

-

-

-

-

Salto de programa
que se ejecuta cuan‐
do no se cumple nin‐
guna de las condicio‐
nes de comparación.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
6:,7&+
8,17
ಯ7DJB,QSXWಯ

(1

ಯ7DJB9DOXHಯ

.

ಯ7DJB9DOXHBಯ

'(67

/$%(/

ಯ7DJB9DOXHBಯ

!

'(67

/$%(/

ಯ7DJB9DOXHBಯ



'(67

/$%(/

(/6(

/$%(/

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:

1292

Parámetro

Operando/etiqueta

Valor

K

Tag_Value

23

==

Tag_Value_1

20

>

Tag_Value_2

21

<

Tag_Value_3

19

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Operando/etiqueta

Valor

DEST0

LABEL0

Salto a la etiqueta "LABEL0" si el
valor del parámetro K es igual a
20.

DEST1

LABEL1

Salto a la etiqueta "LABEL1" si el
valor del parámetro K es mayor
que 21.

DEST2

LABEL2

Salto a la etiqueta "LABEL2" si el
valor del parámetro K es menor
que 19.

ELSE

LABEL3

Salto a la etiqueta "LABEL3" si
no se cumple ninguna de las con‐
diciones de comparación.

Si el operando "Tag_Input" cambia al estado lógico "1", se ejecuta la instrucción. La ejecución
del programa continúa en el segmento que está marcado con la etiqueta "LABEL1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

RET: Retroceder
Descripción
La instrucción "Retroceder" finaliza la ejecución de un bloque de programa de forma
condicionada o absoluta. El estado lógico del valor de retorno (operando) se calcula al salir del
bloque de programa en la salida de habilitación ENO del bloque de programa invocante.
Hay tres formas posibles de terminar la ejecución de un bloque de programa:
Finalización del bloque de
programa

Significado

Sin llamada de la instruc‐
ción

Tras ejecutar el último segmento, se abandona el bloque de programa. La
salida de habilitación ENO del bloque de programa invocante adopta el
estado lógico "1".

Si se cumple la operación lógica precedente, la ejecución del programa
Llamada de la instrucción
con operación lógica prece‐ finaliza en el bloque de programa llamado actualmente y se abandona el
dente (ver ejemplo)
bloque (finalización condicionada del bloque de programa). La ejecución
del programa continúa en el bloque de programa invocante (p. ej., en un
OB) tras la llamada del bloque de programa. La salida de habilitación
ENO del bloque de programa invocante se corresponde con el operando.
El bloque de programa se abandona de forma incondicionada (finaliza‐
Llamada de la instrucción
sin operación lógica previa, ción absoluta del bloque de programa). La salida de habilitación ENO del
o la instrucción está conec‐ bloque de programa invocante se corresponde con el operando.
tada directamente a la ba‐
rra colectora izquierda

Programación del PLC
Manual de programación y manejo, 11/2019

1293

Instrucciones
4.1 Instrucciones
Cuando se finaliza un bloque de organización (OB), el sistema de niveles de ejecución
selecciona otro bloque de programa para luego iniciarlo o seguir ejecutándolo:
● Si se finaliza el OB de ciclo de programa, este se reinicia.
● Si se finaliza un OB que ha interrumpido otro bloque de programa (p. ej., un OB de alarma),
se sigue ejecutando el bloque de programa interrumpido (p. ej., OB de ciclo de programa).
Nota
Instrucción RET en relación con JMP y JMPN
Si en un segmento ya se utiliza la instrucción de salto "JMP: Saltar si RLO = 1" o "JMPN: Saltar
si RLO = 0", no se utilizará la instrucción "RET: Retroceder". En un segmento no se puede
utilizar más de una bobina de salto.

Posibles ajustes del valor de retorno (operando)
El valor de retorno de la instrucción puede adoptar los valores siguientes:
● Ret (RLO, corresponde al resultado de la operación lógica RLO. Se devuelve el estado
lógico "1" en la salida de habilitación ENO del bloque de programa invocante, pues la
instrucción RET solo se ejecuta como instrucción condicionada cuando la condición es
TRUE).
● Ret True o Ret False (el correspondiente valor de la constante TRUE o FALSE se devuelve
en el bloque de programa invocante).
● Ret Value (el valor de la variable booleana <operando> se devuelve en el bloque de
programa invocante).
Para ajustar el valor de retorno de la instrucción, haga clic en el pequeño triángulo amarillo de
la instrucción y elija el valor deseado en la lista desplegable.
La tabla siguiente muestra el estado del bloque de programa invocante cuando la instrucción
está programada en un segmento del bloque de programa llamado:
RLO
1

Valor de retorno

ENO del bloque de programa invocante

RLO

1

TRUE

1

FALSE

0

<Operando>

<Operando>

Variable booleana con las áreas
de memoria posibles I, Q, M, D, L,
TyC
0

RLO
TRUE
FALSE

La ejecución del programa continúa en el
siguiente segmento del bloque de programa
llamado.

<Operando>

1294

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
ಯ7DJ,QBಯ

! 

ಯ7DJ,QBಯ

)$/6(
5(7

Si uno de los operandos "TagIn_1" o "TagIn_2" devuelve el estado lógico "1", se ejecuta la
instrucción. La ejecución del programa se finaliza en el bloque de programa llamado y continúa
en el bloque de programa que efectúa la llamada. La salida de habilitación ENO del bloque de
programa que efectúa la llamada se pone al estado lógico "0".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Ejemplo del mecanismo EN/ENO en FUP (Página 161)
Principios básicos de FUP (Página 8005)

Control del tiempo de ejecución
ENDIS_PW: Limitar y habilitar legitimación de la contraseña
Descripción
La instrucción "Limitar y habilitar legitimación de la contraseña" permite definir si las
contraseñas configuradas para la CPU están legitimadas o no. Con ello, se pueden impedir
conexiones legitimadas, aun conociendo la contraseña correcta.
Si la instrucción se ejecuta y el parámetro REQ tiene el estado lógico "0", en los parámetros de
salida se muestra el estado ajustado en ese momento. Si se han realizado cambios en los
parámetros de entrada, estos no se transfieren a los parámetros de salida.
Si se ejecuta la instrucción y el parámetro REQ tiene el estado lógico "1", se aplica el estado
lógico de los parámetros de entrada (F_PWD, FULL_PWD, R_PWD, HMI_PWD):
● Si se tiene el estado lógico "0", no está permitida la legitimación por contraseña.
● Si se tiene el estado lógico "1", se puede utilizar la contraseña.
Es posible permitir o prohibir individualmente el bloqueo o la habilitación de las contraseñas.
Por ejemplo, pueden prohibirse todas las contraseñas excepto la contraseña de seguridad
positiva. Esto permite limitar las posibilidades de acceso a un reducido grupo de usuarios. Los
parámetros de salida (F_PWD_ON, FULL_PWD_ON, R_PWD_ON, HMI_PWD_ON) siempre
muestran el estado actual del uso de contraseñas, independientemente del parámetro REQ.
Las contraseñas no configuradas deben tener en la entrada el estado lógico TRUE y devolver
el estado lógico TRUE en la salida. La contraseña de seguridad positiva (fail-safe) solo se
puede parametrizar para una CPU F y por eso en una CPU estándar debe interconectarse
siempre con el estado lógico TRUE. Si la instrucción devuelve un error, la llamada permanece
sin efecto, es decir, el bloqueo anterior sigue en vigor.

Programación del PLC
Manual de programación y manejo, 11/2019

1295

Instrucciones
4.1 Instrucciones
Las contraseñas bloqueadas pueden volver a habilitarse en las condiciones siguientes:
● Se ha restablecido la configuración de fábrica de la CPU.
● El panel frontal de la CPU S7-1500 soporta un cuadro de diálogo que permite navegar al
menú adecuado y volver a habilitar las contraseñas.
● Cuando se llama la instrucción "Limitar y habilitar legitimación de la contraseña", el
parámetro de entrada de la contraseña deseada tiene el estado lógico "1".
● Ponga el selector de modo a STOP. La restricción de la legitimación de contraseña se
activa de nuevo en cuanto se mueve el selector nuevamente a RUN.
● La inserción de una tarjeta de memoria vacía (tarjeta de transferencia o tarjeta de
programa) en una CPU S7-1200.
● La transición de POWER OFF-POWER ON desactiva la protección en la CPU S7-1200. La
instrucción "Limitar y habilitar legitimación de la contraseña" debe volverse a llamar en el
programa (por ejemplo en el OB de arranque).
Nota
Si la contraseña HMI no está habilitada, la instrucción "Limitar y habilitar legitimación de la
contraseña" bloquea el acceso de los sistemas HMI.
Nota
Las conexiones ya existentes y legitimadas conservan sus derechos de acceso y no pueden
limitarse con la instrucción "Limitar y habilitar legitimación de la contraseña".

Impedir el bloqueo no intencionado en una CPU S7-1500
Los ajustes pueden realizarse en el panel frontal de la CPU, que guarda el último ajuste en
cada caso.
Para impedir un bloqueo no intencionado, en una CPU S7-1500 es posible desactivar la
protección moviendo el selector de modo a STOP. La protección se activa automáticamente
después de mover el selector de modo a RUN sin que tenga que volver a llamarse la
instrucción "Limitar y habilitar legitimación de la contraseña" o deban realizarse otras acciones
en el panel frontal.

Impedir el bloqueo no intencionado en una CPU S7-1200
Como la CPU S7-1200 no dispone de selector de modo, la protección se desactiva con
POWER OFF-POWER ON. De este modo es posible y recomendable impedir el bloqueo no
intencionado con ayuda de determinadas secuencias en el programa.
Para ello, programe un control de tiempo, ya sea mediante un OB de alarma cíclica o un
temporizador en el Main OB (OB 1). De este modo, tras una transición de POWER OFFPOWER ON y la consiguiente desactivación de la protección, se puede volver a llamar
rápidamente la instrucción "Limitar y habilitar legitimación de la contraseña" en el OB
correspondiente (por ejemplo OB 1 u OB 35). Para que la ventana temporal en la que la
instrucción no está activa y en la que por tanto no existen limitaciones en la legitimación de la

1296

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
contraseña sea lo más pequeña posible, llame la instrucción en el OB de arranque (OB 100).
Este procedimiento ofrece la mayor protección posible contra accesos no autorizados.
Si se ha producido un bloqueo no intencionado puede omitirse la llamada en el OB de arranque
(por ejemplo mediante la consulta de un parámetro de entrada) y se dispondrá del tiempo
configurado (por ejemplo de 10 segundos a 1 minuto) para establecer una conexión con la
CPU antes de que el bloqueo vuelva a activarse.
Si no se ha previsto ningún temporizador en el código del programa y se produce un bloqueo,
inserte en la CPU una tarjeta de transferencia o una tarjeta de programa vacía. La tarjeta de
transferencia o la tarjeta de programa vacía borra la memoria de carga interna de la CPU.
Después deberá cargarse nuevamente el programa de usuario de STEP 7 en la CPU.

Procedimiento en caso de pérdida de contraseña en una CPU S7-1200
Si ha perdido la contraseña de una CPU S7-1200 protegida por contraseña, borre el programa
protegido por contraseña con una tarjeta de transferencia o una tarjeta de programa vacía. La
tarjeta de transferencia o la tarjeta de programa vacía borra la memoria de carga interna de la
CPU. A continuación, puede transferir un nuevo programa de usuario de STEP 7 Basic a la
CPU.
ADVERTENCIA
Inserción de una tarjeta de transferencia vacía
Cuando se inserta una tarjeta de transferencia en una CPU en funcionamiento, la CPU pasa
a STOP. En estados operativos no seguros, los controladores pueden fallar y, con ello,
provocar un funcionamiento incontrolado de los dispositivos que se controlan. El resultado es
un funcionamiento impredecible del sistema de automatización que puede provocar lesiones
mortales o graves, así como daños materiales.
El contenido de la tarjeta de transferencia se encuentra en la memoria de carga interna
después de su extracción. Compruebe aquí que la tarjeta no contenga ningún programa.
ADVERTENCIA
Inserción de una tarjeta de programa vacía
Cuando se inserta una tarjeta de programa en una CPU en funcionamiento, la CPU pasa a
STOP. En estados operativos no seguros, los controladores pueden fallar y, con ello,
provocar un funcionamiento incontrolado de los dispositivos que se controlan. El resultado es
un funcionamiento impredecible del sistema de automatización que puede provocar lesiones
mortales o graves, así como daños materiales.
Asegúrese de que la tarjeta de programa esté vacía. La memoria de carga interna se copiará
en la tarjeta de programa vacía. Después de retirar la tarjeta de programa previamente vacía,
la memoria de carga interna quedará vacía.
Debe retirarse la tarjeta de transferencia o la tarjeta de programa antes de poner la CPU en
RUN.

Programación del PLC
Manual de programación y manejo, 11/2019

1297

Instrucciones
4.1 Instrucciones

Efectos del uso de contraseñas en los modos de operación
La siguiente tabla muestra qué efectos tiene el uso de contraseñas en los modos de operación
y en las respectivas acciones del usuario mediante la instrucción "Limitar y habilitar
legitimación de la contraseña".
Acción

Protección por contraseña mediante la instruc‐
ción

Estado básico después de

No activado

● Selector de modo en STOP

(sin limitaciones)

● Restablecimiento manual de la memoria (PG,
interruptor, cambio de MC (Motion Control))
● Restablecimiento de la configuración de fábrica
Estado básico tras conexión (POWER ON)

● CPU S7-1200:
El bloqueo está desactivado y la
instrucción tiene que volverse a ejecutar
en el programa (por ejemplo en el OB de
arranque).
● CPU S7-1500:
Activada (si antes de la desconexión
(POWER OFF) había un bloqueo activo)
La posibilidad de no permitir contraseñas
es remanente.

Activado
Transición del estado operativo RUN/ARRANQUE/
PARADA -> STOP (mediante finalización de la ins‐
Las contraseñas siguen sin poder utilizarse.
trucción, un error o comunicación) o STOP -> ARRAN‐
QUE/RUN/PARADA

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Limitar y habilitar legitimación de
la contraseña":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

REQ

Input

BOOL

I, Q, M, D, L o
constante

Si el parámetro REQ tiene el
estado lógico "0", se consulta
el estado lógico ajustado ac‐
tualmente para las contrase‐
ñas.

F_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura/escritura
incluido failsafe
● F_PWD = "0": No permitir
contraseña
● F_PWD = "1": Permitir
contraseña

1298

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

FULL_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura/escritura
● FULL_PWD = "0": No
permitir contraseña
● FULL_PWD = "1":
Permitir contraseña

R_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura
● R_PWD = "0": No permitir
contraseña
● R_PWD = "1": Permitir
contraseña

HMI_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso a la HMI
● HMI_PWD = "0": No
permitir contraseña
● HMI_PWD = "1": Permitir
contraseña

F_PWD_ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura/
escritura incluido failsafe
● F_PWD_ON = "0":
Contraseña no permitida
● F_PWD_ON = "1":
Contraseña permitida

FULL_PWD_
ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura/
escritura
● FULL_PWD_ON = "0":
Contraseña no permitida
● FULL_PWD_ON = "1":
Contraseña permitida

R_PWD_ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura
● R_PWD_ON = "0":
Contraseña no permitida
● R_PWD_ON = "1":
Contraseña permitida

HMI_PWD_O Output
N

BOOL

I, Q, M, D, L

Estado del acceso a la HMI
● HMI_PWD_ON = "0":
Contraseña no permitida
● HMI_PWD_ON = "1":
Contraseña permitida

RET_VAL

Output

WORD

I, Q, M, D, L

Información de error

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1299

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

8090

No se soporta la instrucción "Limitar y habilitar legitimación de la contraseña".

80D0

La contraseña de seguridad (fail-safe) no está configurada. En las CPU estándar, el
estado lógico tiene que ser TRUE.

80D1

El acceso de lectura/escritura no está configurado

80D2

El acceso de lectura no está configurado

80D3

El acceso HMI no está configurado

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de FUP (Página 8005)

Sistemas de PC
SHUT_DOWN: Apagar sistema de destino
Descripción
Con la instrucción "SHUT_DOWN: Apagar sistema de destino" se apaga el sistema de
automatización basado en PC y se rearranca el controlador por software S7 CPU 150xS o
Windows en el sistema de automatización basado en PC.
Encontrará la instrucción en la Task Card "Instrucciones", sección Instrucciones básicas >
Control del programa > Control del tiempo de ejecución.
Un reinicio puede ser útil en las situaciones siguientes, p. ej.:
● Un SAI industrial (sistema de alimentación ininterrumpida) notifica un fallo de tensión
mediante una entrada digital.
● Windows no responde o presenta una "pantalla azul".
● En el programa de usuario se llaman demasiados OB de error.

1300

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Apagar sistema de destino":
Parámetro

Declaración

Tipo de
datos

Área de memoria

Descripción

MODE

Input

UINT

I, Q, M, D, L o constan‐ MODE = 1: apagar CPU 150xS y Windows
te
La CPU pasa a STOP y guarda los datos remanentes. Se‐
guidamente se apagan la CPU y Windows. El sistema debe
rearrancarse manualmente.
MODE = 2: rearrancar CPU 150xS
La CPU pasa a STOP y guarda los datos remanentes. A
continuación la CPU se apaga y se reinicia.
MODE = 3: Reiniciar Windows. La CPU permanece en RUN.
Windows se reinicia (desde TIA Portal V14, el MODE 3 solo
está autorizado en caso de compatibilidad descendente. Se
recomienda usar MODE 4 o MODE 5).
MODE = 4: Windows se apaga correctamente y se reinicia.
La CPU permanece en RUN.
MODE = 5: Reiniciar Windows. (comparable al MODE 3;
excepción: MODE 5 solo debe usarse si se ha caído Win‐
dows).

COM‐
MENT

Input

STRING

I, Q, M, D, L

Con Mode = 1, 3 y 4 es posible indicar el motivo del reinicio.
El motivo se mostrará en el registro de eventos de Windows.

Ret_Val

Return

WORD

Q, M, D, L

Ret_Val = 0: ningún error
Ret_Val = 8090: el valor transferido a MODE no se soporta.
Ret_Val = 8091: Windows no responde a la llamada de la
instrucción Shut_Down (solo válido para Mode 3 y 4).
Ret_Val = 8092: Si aparece este error diríjase al SIMATIC
Customer Support (solo válido para Mode 3 y 4).

RE_TRIGR: Reiniciar tiempo de vigilancia del ciclo
Descripción
La instrucción "Reiniciar tiempo de vigilancia del ciclo" reinicia el tiempo de vigilancia del ciclo
de la CPU. El tiempo de vigilancia del ciclo se reinicia entonces con la duración ajustada en la
configuración de la CPU.
La instrucción se ejecuta correctamente durante un intervalo de tiempo (10 veces el ciclo
máximo del programa), independientemente del número de llamadas. Transcurrido ese
tiempo, el ciclo del programa ya no puede prolongarse.

Programación del PLC
Manual de programación y manejo, 11/2019

1301

Instrucciones
4.1 Instrucciones

Llamada de la instrucción
Se aplican las siguientes condiciones de llamada:
● En las CPU de la serie S7-1200:
En las versiones de firmware < 2.2 solo es posible llamar la instrucción en un bloque de
organización cíclico de la prioridad 1. Equivale a la prioridad más baja de todos los bloques
de organización. Si la instrucción se llama desde un bloque de organización de prioridad
superior, no se ejecuta y el resultado (bit BR, salida de habilitación ENO) es siempre "0".
En las versiones de firmware >= 2.2 puede llamarse la instrucción en todos los bloques de
organización, independientemente de la prioridad.
● En las CPU de la serie S7-1500:
La instrucción puede llamarse en todos los bloques de organización, independientemente
de la prioridad.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

STP: Finalizar programa
Descripción
La instrucción "Finalizar programa" conmuta la CPU al estado operativo STOP, con lo que se
finaliza la ejecución del programa. Los efectos al conmutar de RUN a STOP dependen de la
configuración de la CPU.
Si el resultado lógico (RLO) de la entrada de la instrucción es "1", la CPU pasa al estado
operativo STOP y se finaliza el procesamiento del programa. El estado lógico de la salida de
la instrucción no se evalúa.
Si el RLO de la entrada de la instrucción es "0", la instrucción no se ejecuta.

Parámetro
La instrucción "Finalizar programa" no tiene parámetros.

1302

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de FUP (Página 8005)

GET_ERROR: Consultar error localmente
Descripción
La instrucción "Consultar error localmente" consulta si se han producido errores en un bloque
de programa. Suele tratarse de un error de programación o de acceso. Si el sistema notifica
errores durante la ejecución del bloque de programa, en el operando de la salida ERROR se
guarda información detallada acerca del primer error de ejecución ocurrido desde la última vez
que se ejecutó la instrucción.
En la salida ERROR solo pueden especificarse operandos del tipo de datos de sistema
"ErrorStruct". El tipo de datos de sistema "ErrorStruct" especifica la estructura exacta con la
que debe guardarse la información acerca del error que ha ocurrido. Con ayuda de otras
instrucciones se puede evaluar esta estructura y programar la reacción correspondiente. Si se
producen varios errores en el bloque de programa, la instrucción emitirá información sobre el
siguiente error ocurrido solo tras haberse solucionado el primer error.
Nota
Salida ERROR
La salida ERROR se modifica solo si existe información de error. Para poner a "0" la salida
después del tratamiento de errores, dispone de las siguientes posibilidades:
● Declare la variable en la sección "Temp" de la interfaz del bloque.
● Ponga a "0" la variable antes de llamar la instrucción.
● Consulte la salida de habilitación ENO.
La salida de habilitación ENO se activa únicamente si la entrada de habilitación EN devuelve
el estado lógico "1" y existe información de error. Si no se cumple una de estas condiciones,
el procesamiento ulterior del programa no se verá afectado por la instrucción.
Nota
Activación del tratamiento local de errores
En cuanto se inserta la instrucción en el código de un bloque de programa, se activa el
tratamiento local de errores y se ignoran las reacciones preajustadas del sistema si se
producen errores.

Posibilidades del tratamiento de errores
Aquí encontrará un resumen de las posibilidades del tratamiento de errores: Sinopsis de los
mecanismos para el tratamiento de errores (Página 149)

Programación del PLC
Manual de programación y manejo, 11/2019

1303

Instrucciones
4.1 Instrucciones
Aquí encontrará un ejemplo exhaustivo del tratamiento local de errores con varias
posibilidades de tratamiento:Ejemplo de tratamiento de errores de ejecución del programa
(Página 180)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar error localmente":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

ERROR

Output

ErrorStruct

D, L

Información de error

Tipo de datos "ErrorStruct"
El tipo de datos "ErrorStruct" se puede insertar en un bloque de datos global o en la interfaz del
bloque. También se puede insertar el tipo de datos varias veces si cada vez se asigna un
nombre distinto para la estructura de datos. La estructura de datos y el nombre de los distintos
elementos de la estructura no se pueden modificar. Si guarda la información del error en un
bloque de datos global, se podrá leer desde otro bloque de programa.
La tabla siguiente muestra la estructura del tipo de datos "ErrorStruct":
Componente de estructura

Tipo de datos

Descripción

ERROR_ID

WORD

ID de error

FLAGS

BYTE

Muestra si el error se ha producido durante
la llamada de un bloque de programa.
16#01: error durante la llamada de un blo‐
que de programa
16#00: no hay errores durante la llamada
de un bloque de programa

REACTION

BYTE

Reacción predeterminada:
0: ignorar (error de escritura)
1: continuar con el valor sustitutivo "0"
(error de lectura)
2: omitir instrucción (error de sistema)

CODE_ADDRESS
BLOCK_TYPE

CREF

Información sobre la dirección y el tipo del
bloque de programa

BYTE

Tipo de bloque de programa en el que se
ha producido el error:
1: bloque de organización (OB)
2: función (FC)
3: bloque de función (FB)

MODE

1304

CB_NUMBER

UINT

Número del bloque lógico

OFFSET

UDINT

Referencia a la memoria interna

BYTE

Información sobre la dirección de un ope‐
rando

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Componente de estructura

Tipo de datos

Descripción

OPERAND_NUMBER

UINT

Número de operando del comando de la
máquina

POINTER_NUMBER_LOCA‐
TION

UINT

(A) Puntero interno

SLOT_NUMBER_SCOPE

UINT

(B) Área de almacenamiento en la memo‐
ria interna

DATA_ADDRESS

NREF

Información sobre la dirección de un ope‐
rando

BYTE

(C) Área de memoria:

AREA

L: 16#40...16#7F, 16#86, 16#87, 16#8E,
16#8F, 16#C0...16#FF
I: 16#81
Q: 16#82
M: 16#83
DB: 16#40, 16#84, 16#85, 16#8A, 16#8B
PI: 16#01
PQ: 16#02
Objetos tecnológicos: 16#04
DB_NUMBER

UINT

(D) Número del bloque de datos

OFFSET

UDINT

(E) Dirección relativa del operando

Componente de estructura "ERROR_ID"
La tabla siguiente muestra los valores que pueden devolverse en el componente de estructura
"ERROR_ID":
ID*
(hexadecimal)

ID*
(decimal)

Descripción

0

0

Ningún error

2503

9475

Puntero no válido

2520

9504

STRING no válido

2522

9506

Error de lectura: operando fuera del rango válido

2523

9507

Error de escritura: operando fuera del rango válido

2524

9508

Error de lectura: operando no válido

2525

9509

Error de escritura: operando no válido

2528

9512

Error de lectura: alineación de datos

2529

9513

Error de escritura: alineación de datos

252C

9516

Puntero no válido

2530

9520

Error de escritura: bloque de datos

2533

9523

Referencia usada no válida

2538

9528

Error de acceso: el DB no existe

2539

9529

Error de acceso: se ha utilizado un DB incorrecto

253A

9530

El bloque de datos global no existe

253C

9532

Indicación errónea o la función no existe

253D

9533

La función de sistema no existe

Programación del PLC
Manual de programación y manejo, 11/2019

1305

Instrucciones
4.1 Instrucciones
ID*
(hexadecimal)

ID*
(decimal)

Descripción

253E

9534

Indicación errónea o el bloque de función no existe

253F

9535

El bloque de sistema no existe

2550

9552

Error de acceso: el DB no existe

2551

9553

Error de acceso: se ha utilizado un DB incorrecto

2575

9589

Error en la profundidad de anidamiento del programa

2576

9590

Error en la distribución de datos locales

2577

9591

La propiedad de bloque "Alimentación de parámetros a través de
registros" no está activada.

25A0

9632

Error interno en TP

25A1

9633

Variable protegida contra escritura

25A2

9634

Valor numérico no válido de la variable

2942

10562

Error de lectura: entrada

2943

10563

Error de escritura: salida

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
!
5HDO
)LHOG>LQGH[@

,1



,1

08/
$XWR 5HDO
(1

)LHOG>LQGH[@

,1

287



,1

(12

7DJ2XW

7DJ2XWB(QDEOHG

*(7B(5525
(5525
(1

(UURU

(12

%<7(

(UURUB5($&7,21

,1



,1

7DJ2XWB(QDEOHG
5

Se ha producido un error al acceder a la variable #Field[#index]. La salida de habilitación ENO
de la instrucción "Multiplicar" y el operando #TagOut_Enabled devuelven el estado lógico "1"
a pesar del error de lectura/escritura, y la multiplicación se realiza con el valor "0.0". En este
caso de error, es recomendable programar la instrucción "Consultar error localmente" después
de la instrucción "Multiplicar" para interceptar el error. La información de error que devuelve la
instrucción "Consultar error localmente" se evalúa mediante la instrucción de comparación

1306

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
"Igual". Si el componente de estructura #Error.REACTION tiene el valor "1", se trata de un error
de lectura/escritura y la salida #TagOut_Enabled se desactiva de nuevo.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Uso de las instrucciones GET_ERROR y GET_ERR_ID (Página 178)
Insertar elementos FUP (Página 8017)
Editar elementos FUP (Página 8034)
Cablear operandos en instrucciones FUP (Página 8041)

GET_ERR_ID: Consultar ID de error localmente
Descripción
La instrucción "Consultar ID de error localmente" consulta si se han producido errores en un
bloque. Suele tratarse de un error de acceso. Si al ejecutar el bloque el sistema notifica errores
de ejecución desde que se ejecutó la instrucción por última vez, la ID de error del primer error
ocurrido se guarda en la variable de la salida ID.
En la salida ID solo pueden especificarse operandos del tipo de datos "WORD". Si se producen
varios errores en el bloque, la instrucción soluciona el primer error ocurrido, y solo entonces la
instrucción emite la ID de error del siguiente error ocurrido.
Nota
La salida ID se modifica solo si existe información de error. Para poner a "0" la salida después
del tratamiento de errores, dispone de las siguientes posibilidades:
● Declare la variable en la sección "Temp" de la interfaz del bloque.
● Ponga a "0" la variable antes de llamar la instrucción.
● Consulte la salida de habilitación ENO.
La salida de habilitación ENO de la instrucción "Consultar ID de error localmente" se activa
únicamente si la entrada de habilitación EN devuelve el estado lógico "1" y existe información
de error. Si no se cumple alguna de estas condiciones, la ejecución ulterior del programa no se
ve afectada por la instrucción "Consultar ID de error localmente".
Encontrará un ejemplo sobre cómo utilizar la instrucción en combinación con otras
posibilidades de tratamiento de errores, en "Consulte también".
Nota
La instrucción "Consultar ID de error localmente" activa el tratamiento local de errores dentro
del bloque. Si en la lógica de un bloque se ha insertado la instrucción "Consultar ID de error
localmente", se ignoran las reacciones predeterminadas del sistema al ocurrir errores.

Programación del PLC
Manual de programación y manejo, 11/2019

1307

Instrucciones
4.1 Instrucciones

Posibilidades del tratamiento de errores
Aquí encontrará un resumen de las posibilidades del tratamiento de errores: Sinopsis de los
mecanismos para el tratamiento de errores (Página 149)
Aquí encontrará un ejemplo exhaustivo del tratamiento local de errores con varias
posibilidades de tratamiento: Ejemplo de tratamiento de errores de ejecución del programa
(Página 180)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar ID de error localmente":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

ID

Output

WORD

I, Q, M, D, L

ID de error

Parámetro ID
La tabla siguiente muestra los valores que pueden depositarse en el parámetro ID:

1308

ID*
(hexadecimal)

ID*
(decimal)

Descripción

0

0

Ningún error

2503

9475

Puntero no válido

2520

9504

STRING no válido

2522

9506

Error de lectura: operando fuera del rango válido

2523

9507

Error de escritura: operando fuera del rango válido

2524

9508

Error de lectura: operando no válido

2525

9509

Error de escritura: operando no válido

2528

9512

Error de lectura: alineación de datos

2529

9513

Error de escritura: alineación de datos

252C

9516

Puntero no válido

2530

9520

Error de escritura: bloque de datos

2533

9523

Referencia usada no válida

2538

9528

Error de acceso: el DB no existe

2539

9529

Error de acceso: se ha utilizado un DB incorrecto

253A

9530

El bloque de datos global no existe

253C

9532

Indicación errónea o la función no existe

253D

9533

La función de sistema no existe

253E

9534

Indicación errónea o el bloque de función no existe

253F

9535

El bloque de sistema no existe

2550

9552

Error de acceso: el DB no existe

2551

9553

Error de acceso: se ha utilizado un DB incorrecto

2575

9589

Error en la profundidad de anidamiento del programa

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
ID*
(hexadecimal)

ID*
(decimal)

Descripción

2576

9590

Error en la distribución de datos locales

2577

9591

La propiedad de bloque "Alimentación de parámetros a través de
registros" no está activada.

25A0

9632

Error interno en TP

25A1

9633

Variable protegida contra escritura

25A2

9634

Valor numérico no válido de la variable

2942

10562

Error de lectura: entrada

2943

10563

Error de escritura: salida

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
!
5HDO
)LHOG>LQGH[@

,1



,1

08/
$XWR 5HDO
(1

)LHOG>LQGH[@

,1

287



,1

(12

7DJ2XW

7DJ2XWB(QDEOHG

*(7B(55B,'
,'
(1

7DJ,'

(12

,17
7DJ,'

,1



,1

029(



(1

287

,1

(12

7DJ2XW

Se ha producido un error al acceder a la variable #Field[#index]. La salida de habilitación ENO
de la instrucción "Multiplicar" y el operando #TagOut_Enabled devuelven el estado lógico "1"
a pesar del error de lectura/escritura, y la multiplicación se realiza con el valor "0.0". En este
caso de error, es recomendable programar la instrucción "Consultar ID de error localmente"
después de la instrucción "Multiplicar" para interceptar el error. La información de error que
devuelve la instrucción "Consultar ID de error localmente" se evalúa mediante la instrucción de
comparación "Igual". Si el operando #TagID devuelve la ID 2522, se trata de un error de lectura/
escritura, y se escribe el valor "100.0" en la salida #TagOut.

Programación del PLC
Manual de programación y manejo, 11/2019

1309

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Uso de las instrucciones GET_ERROR y GET_ERR_ID (Página 178)
Insertar elementos FUP (Página 8017)
Editar elementos FUP (Página 8034)
Cablear operandos en instrucciones FUP (Página 8041)

INIT_RD: Inicializar todos los datos remanentes
Descripción
La instrucción "Inicializar todos los datos remanentes" permite inicializar todos los datos
remanentes de todos los bloques de datos, marcas y temporizadores y contadores SIMATIC
al mismo tiempo. La instrucción solo puede ejecutarse dentro de un OB de arranque, puesto
que su ejecución excedería el tiempo de ciclo de programa.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Inicializar todos los datos
remanentes":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

REQ

Input

BOOL

I, Q, M, D, L, T, C o
constante

Si la entrada REQ devuelve
el estado lógico "1", se inicia‐
lizan todos los datos rema‐
nentes.

RET_VAL

Output

INT

I, Q, M, D, L

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1310

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B5

No puede ejecutarse la instrucción porque no ha sido programada dentro de un OB de
arranque.

Informa‐
Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
ción de
error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
,1,7B5'
ಯ7DJ2XWಯ
ಯ7DJ,QBಯ
ಯ7DJB5(4ಯ

(1
5(4

(12
5(7B9$/

ಯ7DJB5HVXOWಯ

Si los operandos "TagIn_1" y "Tag_REQ" devuelven el estado lógico "1", se ejecuta la
instrucción. Se inicializan todos los datos remanentes de todos los bloques de datos, marcas
y temporizadores y contadores SIMATIC. Si no ocurren errores al ejecutar la instrucción, la
salida de habilitación ENO devuelve el estado lógico "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1307)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1311

Instrucciones
4.1 Instrucciones

WAIT: Programar retardo
Descripción
La instrucción "Programar retardo" permite detener la ejecución del programa durante un
periodo predeterminado. El periodo se indica en microsegundos en el parámetro WT de la
instrucción.
Es posible programar tiempos de retardo de -32768 a +32767 microsegundos (μs). El tiempo
de retardo mínimo depende de la CPU utilizada y equivale al tiempo de ejecución de la
instrucción.
La ejecución de la instrucción puede verse interrumpida por eventos de prioridad superior y no
arrojará información de error.
Nota
Tiempo de retardo negativo
Si indica un tiempo de retardo negativo en el parámetro WT, la salida de habilitación ENO, o
el RLO y el bit BR arrojan el estado lógico FALSE. Un tiempo de retardo negativo no afecta a
la CPU. En KOP y FUP no se ejecutan las siguientes instrucciones vinculadas a la salida de
habilitación ENO.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Programar retardo":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

WT

Input

INT

I, Q, M, D, L, P o
constante

Tiempo de retardo en micro‐
segundos (μs)

Ejemplo de cómo influir en el tiempo de retardo previsto
En el ejemplo siguiente se ve la influencia del tiempo de retardo de la instrucción "WAIT" en
diferentes escenarios.
La figura siguiente ilustra los escenarios esquemáticamente:

1312

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
6HQG&ORFN

&DVR 
2%

PV

:$,7  PV
7'HOD\ PV

7&RGH PV

7'HOD\ PV

7&RGH PV

7'HOD\ PV

7&RGH PV

75H PV

&DVR
2%GHDODUPD

75H PV

&DVR
2%GHDODUPD

7&RGH PV

&DVR
2%GHDODUPD
72Y PV
6HQG&ORFN 7LHPSRGHFLFORGHHPLVLµQGHOD&38
7'HOD\ 7LHPSRGHUHWDUGRGHO2%GHDODUPD
7&RGH 7LHPSRGHHMHFXFLµQGHOSURJUDPD
75H 7LHPSRUHVWDQWH
72Y 7LHPSRHQHOTXHVHSURORQJDHOWLHPSRGHFLFORGHHPLVLµQ
(O2%FRQODLQVWUXFFLµQ:$,7WDPEL«QIRUPDSDUWHGHORVFDVRV\\GHEH
WHQHUVHHQFXHQWD

Tiempo restante = intervalo entre el final del tiempo de retardo previsto (mediante "WAIT") y la
finalización del OB de alarma
Tiempo de prolongación = intervalo entre la finalización del OB de alarma y el final del tiempo
de retardo previsto (mediante "WAIT")
Caso 1:
La instrucción "WAIT" se llama en un OB1. La instrucción "WAIT" puede verse interrumpida por
OB o procesos de mayor prioridad (p. ej. System Threads). Sin embargo, el tiempo de retardo
de la instrucción "WAIT" no se ha modificado ni se ha aplazado.
Casos 2 y 3:
El procesamiento del programa en el OB1 prosigue tras un retardo de 20 ms. Este retardo se
calcula con la llamada de la instrucción "WAIT" en el OB1 (consulte OB1 con WAIT). En esos
20 ms, un OB de alarma puede ejecutar su propio código de programa. El tiempo de ciclo de
emisión de la CPU no cambia.

Programación del PLC
Manual de programación y manejo, 11/2019

1313

Instrucciones
4.1 Instrucciones
Caso 4:
El procesamiento del programa en el OB1 prosigue tras finalizar el proceso de mayor prioridad.
Los 20 ms de retardo en el OB1 han transcurrido, pero el proceso de mayor prioridad todavía
no ha finalizado. El tiempo de ciclo de emisión de la CPU aumenta.
Nota
Secuencia de ejecución de procesos del sistema o de comunicación (System Threads)
Los threads del sistema suelen utilizar la prioridad "15". También hay threads del sistema con
una prioridad mayor que "26", pero estos procesos suponen una carga menor para la CPU. Los
threads del sistema no se muestran en la figura.
Medición del tiempo de ejecución del OB1 utilizando la instrucción "RT_INFO":
Caso 2: 20 ms - 8 ms - System Threads = <12 ms. Tiempo de ciclo de emisión: ~20 ms.
Caso 3: 20 ms - 11 ms - System Threads - <9 ms. Tiempo de ciclo de emisión: ~20 ms.
Caso 4: 20 ms - 15 ms - System Threads - <7 ms. Tiempo de ciclo de emisión: ~22 ms.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

RUNTIME: Medir tiempo de ejecución
Descripción
La instrucción "Medir tiempo de ejecución" permite medir el tiempo de ejecución de todo el
programa, bloques individuales o secuencias de comandos.
Si desea medir el tiempo de ejecución de todo el programa, efectúe la llamada de la instrucción
"Medir tiempo de ejecución" en el OB1. El punto inicial para medir el tiempo de ejecución se
determina con la primera llamada y la salida RET_VAL devuelve el tiempo de ejecución del
programa tras la segunda llamada. El tiempo de ejecución medido incluye toda clase de
procesos de la CPU que se hayan producido durante la ejecución del programa, como, p. ej.,
interrupciones a causa de eventos o comunicaciones de mayor prioridad. La instrucción "Medir
tiempo de ejecución" lee un contador interno de la CPU y escribe su valor en el parámetro de
entrada/salida MEM. La instrucción calcula el tiempo de ejecución actual del programa según
la frecuencia interna del contador, y la escribe en la salida RET_VAL.
Si desea medir el tiempo de ejecución de bloques o secuencias de comandos individuales,
necesita tres segmentos diferentes. Efectúe la llamada de la instrucción "Medir tiempo de
ejecución" en un segmento individual dentro del programa. Al efectuar esta primera llamada de
la instrucción se establece el punto inicial para medir el tiempo de ejecución. A continuación,
llame el bloque de programa o la secuencia de comando que desee en el siguiente segmento.
Efectúe la llamada de la instrucción "Medir tiempo de ejecución" por segunda vez en otro
segmento diferente y asigne al parámetro de entrada/salida MEM la misma memoria que en la
primera llamada de la instrucción. En el tercer segmento, la instrucción "Medir tiempo de

1314

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
ejecución" lee un contador interno de la CPU, calcula el tiempo de ejecución actual del bloque
de programa o secuencia de comando según la frecuencia interna del contador y lo escribe en
la salida RET_VAL.
La instrucción "Medir tiempo de ejecución" utiliza un contador interno de alta frecuencia para
calcular el tiempo. Cuando el contador se desborda, la instrucción devuelve valores <= 0.0. En
las CPU S7-1200 con versión de firmware < V4.2, esto puede suceder hasta una vez por
minuto. Estos valores de runtime deben ignorarse.
Nota
Puesto que el orden de las instrucciones de una secuencia de comandos se modifica mediante
la compilación optimizada del programa, no es posible determinar el tiempo de ejecución de
una secuencia de comandos con exactitud.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Medir tiempo de ejecución":
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

MEM

InOut

LREAL

I, Q, M, D, L

El contenido está previsto
únicamente para fines inter‐
nos.

RET_VAL

Output

LREAL

I, Q, M, D, L

Devuelve el tiempo de ejecu‐
ción medido en segundos

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción mediante el cálculo del tiempo
de ejecución de un bloque de programa:
Segmento 1:
5817,0(
ಯ7DJ,Qಯ
ಯ7DJ0HPRU\ಯ

(1

(12

0(0

5(7B9$/

ಯ7DJ5HVXOWಯ

Segmento 2:
'%
ಯ%HVWBEHIRUHBGDWHB'%ಯ
)%
ಯ%HVWBEHIRUHBGDWHಯ

(1

Programación del PLC
Manual de programación y manejo, 11/2019

(12

1315

Instrucciones
4.1 Instrucciones
Segmento 3:
5817,0(
ಯ7DJ,Qಯ
ಯ7DJ0HPRU\ಯ

(1
0(0

(12
5(7B9$/

ಯ7DJ5HVXOWB5XQWLPHಯ

Si el operando "TagIn1" devuelve el estado lógico "1" en el segmento 1, se ejecuta la
instrucción. Con la primera llamada de la instrucción se determina el punto inicial para la
medición del tiempo de ejecución, y se guarda como referencia en una memora intermedia del
operando "TagMemory" para la segunda llamada de la instrucción.
En el segmento 2 se llama el bloque de programa FB1 "Best_before_date".
Si el bloque de programa FB1 se ha procesado y el operando "TagIn1" devuelve el estado
lógico "1", la instrucción se ejecuta en el segmento 3. La segunda llamada de la instrucción
calcula el tiempo de ejecución del bloque de programa y escribe el resultado en la salida
RET_VAL.
Encontrará un ejemplo detallado de cómo medir el tiempo de ciclo total de un programa en el
Siemens Industry Online Support, en la ID de artículo: 87668055 (https://
support.industry.siemens.com/cs/ww/es/view/87668055)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

Operaciones lógicas con palabras
AND: Operación lógica Y
Descripción
La instrucción "Operación lógica Y" permite combinar el valor de la entrada IN1 con el valor de
la entrada IN2 de bit en bit mediante una Y lógica y consultar el resultado en la salida OUT.
Al ejecutar la instrucción, el bit 0 del valor de la entrada IN1 se combina con el bit 0 del valor
de la entrada IN2 mediante una Y lógica. El resultado se deposita en el bit 0 de la salida OUT.
La misma combinación lógica se realiza para todos los demás bits de los valores indicados.
El cuadro de la instrucción contiene en estado estacionario mín. 2 entradas (IN1 e IN2). El
número de entradas es ampliable. Las entradas insertadas se numeran en orden ascendente
en el cuadro. Al ejecutar la instrucción se combinan mediante una Y lógica los valores de todos
los parámetros de entrada disponibles. El resultado se deposita en la salida OUT.

1316

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El estado lógico del bit de resultado es "1" solo si el estado lógico de los dos bits que deben
combinarse lógicamente también es "1". Si el estado lógico de uno de los bits que deben
combinarse lógicamente es "0", se desactivará el bit de resultado correspondiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica Y":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN1

Input

Secuencias de
bits

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Primer valor de
la operación ló‐
gica

IN2

Input

Secuencias de
bits

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Segundo valor
de la opera‐
ción lógica

INn

Input

Secuencias de
bits

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valores de en‐
trada opciona‐
les

OUT

Output

Secuencias de
bits

I, Q, M, D, L, P I, Q, M, D, L, P Resultado de
la instrucción

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
$1'
:25'
ಯ7DJ,Qಯ

(1

ಯ7DJB9DOXHಯ

,1

287

ಯ7DJB9DOXHಯ

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN1

Tag_Value1

0101 0101 0101 0101

IN2

Tag_Value2

0000 0000 0000 1111

OUT

Tag_Result

0000 0000 0000 0101

Programación del PLC
Manual de programación y manejo, 11/2019

1317

Instrucciones
4.1 Instrucciones
Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El valor del
operando "Tag_Value1" se combina con el valor del operando "Tag_Value2" mediante una Y
lógica. El resultado se obtiene de bit en bit y se deposita en el operando "Tag_Result". La salida
de habilitación ENO y la salida "TagOut" adoptan el estado lógico "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

OR: Operación lógica O
Descripción
La instrucción "Operación lógica O" permite combinar el valor de la entrada IN1 con el valor de
la entrada IN2 de bit en bit mediante una O lógica y consultar el resultado en la salida OUT.
Al ejecutar la instrucción, el bit 0 del valor de la entrada IN1 se combina con el bit 0 del valor
de la entrada IN2 mediante una O lógica. El resultado se deposita en el bit 0 de la salida OUT.
La misma combinación lógica se realiza para todos los bits de la variable indicada.
El cuadro de la instrucción contiene en estado estacionario mín. 2 entradas (IN1 e IN2). El
número de entradas del cuadro de la instrucción se puede ampliar. Las entradas insertadas se
numeran en orden ascendente en el cuadro. Al ejecutar la instrucción se combinan mediante
una O lógica los valores de todos los parámetros de entrada disponibles. El resultado se
deposita en la salida OUT.
El estado lógico del bit de resultado es "1" si el estado lógico de como mínimo uno de los dos
bits que deben combinarse lógicamente también es "1". Si el estado lógico de ambos bits que
deben combinarse lógicamente es "0", se desactivará el bit de resultado correspondiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica O":
Parámetro

1318

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN1

Input

Secuencias de
bits

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Primer valor de
la operación ló‐
gica

IN2

Input

Secuencias de
bits

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Segundo valor
de la opera‐
ción lógica

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500
I, Q, M, D, L, P
o constante

Descripción

INn

Input

Secuencias de
bits

I, Q, M, D, L, P
o constante

Valores de en‐
trada opciona‐
les

OUT

Output

Secuencias de
bits

I, Q, M, D, L, P I, Q, M, D, L, P Resultado de
la instrucción

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
25
:25'
ಯ7DJ,Qಯ

(1

ಯ7DJB9DOXHಯ

,1

287

ಯ7DJB9DOXHಯ

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN1

Tag_Value1

0101 0101 0101 0101

IN2

Tag_Value2

0000 0000 0000 1111

OUT

Tag_Result

0101 0101 0101 1111

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El valor del
operando "Tag_Value1" se combina con el valor del operando "Tag_Value2" mediante una O
lógica. El resultado se obtiene de bit en bit y se deposita en el operando "Tag_Result". La salida
de habilitación ENO y la salida "TagOut" adoptan el estado lógico "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1319

Instrucciones
4.1 Instrucciones

XOR: Operación lógica O-exclusiva
Descripción
La instrucción "Operación lógica O-exclusiva" permite combinar el valor de la entrada IN1 con
el valor de la entrada IN2 de bit en bit mediante una O-exclusiva lógica y consultar el resultado
en la salida OUT.
Al ejecutar la instrucción, el bit 0 del valor de la entrada IN1 se combina con el bit 0 del valor
de la entrada IN2 mediante una O exclusiva lógica. El resultado se deposita en el bit 0 de la
salida OUT. La misma combinación lógica se realiza para todos los demás bits del valor
indicado.
El cuadro de la instrucción contiene en estado estacionario mín. 2 entradas (IN1 e IN2). El
número de entradas del cuadro de la instrucción se puede ampliar. Las entradas insertadas se
numeran en orden ascendente en el cuadro. Al ejecutar la instrucción se combinan los valores
de todos los parámetros de entrada disponibles mediante una O exclusiva lógica. El resultado
se deposita en la salida OUT.
El estado lógico del bit de resultado es "1" si el estado lógico de uno de los dos bits que deben
combinarse lógicamente también es "1". Si el estado lógico de ambos bits que deben
combinarse lógicamente es "1" o "0", se desactivará el bit de resultado correspondiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica O-exclusiva":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN1

Input

Secuencias de
bits

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Primer valor de
la operación ló‐
gica

IN2

Input

Secuencias de
bits

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Segundo valor
de la opera‐
ción lógica

INn

Input

Secuencias de
bits

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valores de en‐
trada opciona‐
les

OUT

Output

Secuencias de
bits

I, Q, M, D, L, P I, Q, M, D, L, P Resultado de
la instrucción

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1320

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
;25
:25'
ಯ7DJ,Qಯ

(1

ಯ7DJB9DOXHಯ

,1

287

ಯ7DJB9DOXHಯ

,1

(12

ಯ7DJB5HVXOWಯ
ಯ7DJ2XWಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN1

Tag_Value1

0101 0101 0101 0101

IN2

Tag_Value2

0000 0000 0000 1111

OUT

Tag_Result

0101 0101 0101 1010

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El valor del
operando "Tag_Value1" se combina con el valor del operando "Tag_Value2" mediante una Oexclusiva. El resultado se obtiene de bit en bit y se deposita en el operando "Tag_Result". La
salida de habilitación ENO y la salida "TagOut" adoptan el estado lógico "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

INVERT: Complemento a 1
Descripción
La instrucción "Complemento a 1" permite invertir el estado lógico de los bits de la entrada IN.
Al ejecutar la instrucción, el valor de la entrada IN se combina con una operación lógica Oexclusiva utilizando una plantilla hexadecimal (W#16#FFFF para números de 16 bits o
DW#16#FFFF FFFF para números de 32 bits). Esto invierte el estado lógico de los distintos
bits y deposita el resultado en la salida OUT.

Programación del PLC
Manual de programación y manejo, 11/2019

1321

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Complemento a 1":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de habilita‐
ción

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habilita‐
ción

IN

Input

Secuencias de
bits, enteros

I, Q, M, D, L,
P o constan‐
te

I, Q, M, D, L, Valor de entrada
P o constante

OUT

Output

Secuencias de
bits, enteros

I, Q, M, D, L,
P

I, Q, M, D, L,
P

Complemento a 1
del valor de la en‐
trada IN

En la lista desplegable "<???>" del cuadro de la instrucción se puede seleccionar el tipo de
datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
,19
ಯ7DJ,Qಯ
ಯ7DJ,QB9DOXHಯ

,17
(1

287

,1

(12

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

TagIn_Value

W#16#000F

W#16#7E

OUT

TagOut_Value

W#16#FFF0

W#16#81

Cuando el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción
"Complemento a 1". La instrucción invierte el estado lógico de los distintos bits de la entrada
"TagIn_Value" y escribe el resultado en la salida "TagOut_Value". La salida de habilitación
ENO y la salida "TagOut" adoptan el estado lógico "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

1322

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

DECO: Descodificar
Descripción
La instrucción "Descodificar" permite activar en el valor de salida un bit especificado por el
valor de entrada.
La instrucción "Descodificar" lee el valor de la entrada IN y activa el bit del valor de salida, cuya
posición de bit equivale al valor leído. Los demás bits del valor de salida se rellenan con ceros.
Si el valor de la entrada IN es mayor que 31, se ejecuta una instrucción modulo 32.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Descodificar":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN

Input

UINT

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Posición del bit
que se activa
en el valor de
salida.

OUT

Output

Secuencias de
bits

I, Q, M, D, L, P I, Q, M, D, L, P Valor de salida

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
'(&2
8,17

WR

':25'

ಯ7DJ,Qಯ

(1

287

ಯ7DJ,QB9DOXHಯ

,1

(12

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

La figura siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
ಯ7DJ,QB9DOXHಯ 

ಯ7DJ2XWB9DOXHಯ

Programación del PLC
Manual de programación y manejo, 11/2019

 



 

1323

Instrucciones
4.1 Instrucciones
Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
lee el número de bit "3" del valor del operando "TagIn_Value" de la entrada y activa el tercer bit
del valor del operando "TagOut_Value" de la salida.
Si no ocurren errores al ejecutar la instrucción, la salida ENO devuelve el estado lógico "1" y
se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

ENCO: Codificar
Descripción
La instrucción "Codificar" lee el número del bit menos significativo en el valor de entrada y lo
emite en la salida OUT.
La instrucción "Codificar" selecciona el bit menos significativo del valor de la entrada IN y
escribe su número de bit en la variable de la salida OUT.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Codificar":
Parámetro

Declaración

Tipo de datos

Área de memoria
S7-1200

S7-1500

Descripción

EN

Input

BOOL

I, Q, M, D, L o
constante

I, Q, M, D, L, T,
C o constante

Entrada de ha‐
bilitación

ENO

Output

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de habi‐
litación

IN

Input

Secuencias de
bits

I, Q, M, D, L, P
o constante

I, Q, M, D, L, P
o constante

Valor de entra‐
da

OUT

Output

INT

I, Q, M, D, L, P I, Q, M, D, L, P Valor de salida

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1324

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
(1&2
':25'
ಯ7DJ,Qಯ
ಯ7DJ,QB9DOXHಯ

(1

287

,1

(12

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

La figura siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:

ಯ7DJ,QB9DOXHಯ
ಯ7DJ2XWB9DOXHಯ

 



 


Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. La instrucción
selecciona la posición de bit "3" como bit menos significativo del valor de la entrada
"TagIn_Value" y escribe el valor "3" en la variable de la salida "TagOut_Value".
Si no ocurren errores al ejecutar la instrucción, la salida de habilitación ENO devuelve el estado
lógico "1" y se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

SEL: Seleccionar
Descripción
La instrucción "Seleccionar" selecciona, en función de un estado lógico del interruptor (entrada
G), una de las entradas IN0 o IN1 y copia su contenido en la salida OUT. Si la entrada G tiene
el estado lógico "0", se copia el valor de la entrada IN0. Si la entrada G tiene el estado lógico
"1", se copia el valor de la entrada IN1 en la salida OUT.
La instrucción solo se puede ejecutar si el estado lógico de la entrada de habilitación EN es "1"
y las variables de todos los parámetros son del mismo tipo de datos.

Programación del PLC
Manual de programación y manejo, 11/2019

1325

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Seleccionar":
Parámetro

Declara‐
ción

S7-1200

Tipo de datos
S7-1500

S7-1200

Área de memoria
S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D,
L o cons‐
tante

I, Q, M, D, L o Entrada de habilita‐
constante
ción

ENO

Output

BOOL

BOOL

I, Q, M, D,
L

I, Q, M, D, L

Salida de habilita‐
ción

G

Input

BOOL

BOOL

I, Q, M, D,
L o cons‐
tante

I, Q, M, D, L,
T, C o cons‐
tante

Interruptor

IN0

Input

Secuen‐
cias de
bits, ente‐
ros, núme‐
ros en co‐
ma flotan‐
te, tiem‐
pos, TOD,
DATE,
CHAR,
WCHAR

Secuencias I, Q, M, D,
de bits, en‐ L, P o
teros, núme‐ constante
ros en coma
flotante,
tiempos,
TOD,
LTOD, DA‐
TE, LDT,
CHAR,
WCHAR

I, Q, M, D, L, Primer valor de en‐
P o constante trada

IN1

Input

Secuen‐
cias de
bits, ente‐
ros, núme‐
ros en co‐
ma flotan‐
te, tiem‐
pos, TOD,
DATE,
CHAR,
WCHAR

Secuencias I, Q, M, D,
de bits, en‐ L, P o
teros, núme‐ constante
ros en coma
flotante,
tiempos,
TOD,
LTOD, DA‐
TE, LDT,
CHAR,
WCHAR

I, Q, M, D, L, Segundo valor de
P o constante entrada

OUT

Output

Secuen‐
cias de
bits, ente‐
ros, núme‐
ros en co‐
ma flotan‐
te, tiem‐
pos, TOD,
DATE,
CHAR,
WCHAR

Secuencias I, Q, M, D,
de bits, en‐ L, P
teros, núme‐
ros en coma
flotante,
tiempos,
TOD,
LTOD, DA‐
TE, LDT,
CHAR,
WCHAR

I, Q, M, D, L,
P

Resultado

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1326

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
6(/
:25'
ಯ7DJ,Qಯ
ಯ7DJ,QB*ಯ

(1
*

ಯ7DJ2XWಯ

ಯ7DJ,QB9DOXHಯ

,1

(12

ಯ7DJ,QB9DOXHಯ

,1

287

ಯ7DJ2XWB9DOXHಯ

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

G

TagIn_G

0

1

IN0

TagIn_Value0

W#16#0000

W#16#4C

IN1

TagIn_Value1

W#16#FFFF

W#16#5E

OUT

TagOut_Value

W#16#0000

W#16#5E

Si el operando "TagIn" tiene el estado lógico "1", se ejecuta la instrucción. Dependiendo del
estado lógico de la entrada "TagIn_G", se selecciona el valor de la entrada "TagIn_Value0" o
"TagIn_Value1" y se copia en la salida "TagOut_Value". Si no se producen errores al ejecutar
la instrucción, la salida de habilitación ENO devuelve el estado lógico "1" y se activa la salida
"TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

MUX: Multiplexar
Descripción
La instrucción "Multiplexar" permite copiar el contenido de una entrada seleccionada en la
salida OUT. El cuadro de la instrucción contiene en estado básico mín. 2 entradas (IN0 e IN1).
El número de entradas seleccionables en el cuadro de la instrucción se puede ampliar. Se
puede declarar un máximo de 32 entradas.
Las entradas se numeran automáticamente en el cuadro. La numeración comienza por IN0 y
continúa en orden ascendente con cada nueva entrada. El parámetro K determina la entrada
cuyo contenido se copia en la salida OUT. Si el valor del parámetro K es mayor que el número
de entradas disponibles, el contenido del parámetro ELSE se copia en la salida OUT y a la
salida de habilitación ENO se le asigna el estado lógico "0".
La instrucción "Multiplexar" solo se puede ejecutar si las variables de todas las entradas y de
la salida OUT tienen el mismo tipo de datos. El parámetro K es una excepción, ya que para este
solo pueden indicarse números enteros.
Programación del PLC
Manual de programación y manejo, 11/2019

1327

Instrucciones
4.1 Instrucciones
La salida de habilitación ENO se desactiva si se cumple una de las condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● La entrada del parámetro K está fuera del rango de entradas disponibles. Esta reacción es
independiente de que se utilice o no la entrada ELSE. El valor de la salida OUT no varía.
● Se producen errores al ejecutar la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Multiplexar":
Parámetro

Declarar

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

K

Input

Enteros

Enteros

I, Q, M, D, L, I, Q, M, D, L, Indica la en‐
P o constan‐ P o constan‐ trada cuyo
te
te
contenido
se copia.
● Si K = 0
=>
parámetr
o IN0
● Si K = 1
=>
parámetr
o IN1,
etc.

1328

IN0

Input

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, DATE

Números bi‐ I, Q, M, D, L, I, Q, M, D, L, Primer valor
narios, ente‐ P o constan‐ P o constan‐ de entrada
ros, núme‐
te
te
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, LTOD,
DATE, LDT

IN1

Input

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, DATE

Números bi‐ I, Q, M, D, L, I, Q, M, D, L, Segundo va‐
narios, ente‐ P o constan‐ P o constan‐ lor de entra‐
ros, núme‐
te
te
da
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, LTOD,
DATE, LDT

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declarar

Tipo de datos
S7-1200

S7-1500

Área de memoria
S7-1200

Descripción

S7-1500

INn

Input

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, DATE

Números bi‐ I, Q, M, D, L, I, Q, M, D, L, Valores de
narios, ente‐ P o constan‐ P o constan‐ entrada op‐
ros, núme‐
te
te
cionales
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, LTOD,
DATE, LDT

ELSE

Input

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, DATE

Números bi‐ I, Q, M, D, L, I, Q, M, D, L, Indica el va‐
narios, ente‐ P o constan‐ P o constan‐ lor que se
ros, núme‐
te
te
copia si K > n
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, LTOD,
DATE, LDT

OUT

Output

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, DATE

Números bi‐ I, Q, M, D, L,
narios, ente‐ P
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, LTOD,
DATE, LDT

I, Q, M, D, L,
P

Salida en la
que se copia
el valor

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
08;
':25'
ಯ7DJB,QSXWಯ

(1

ಯ7DJB1XPEHUಯ

.

ಯ7DJB9DOXHBಯ

,1

ಯ7DJB9DOXHBಯ

,1

ಯ7DJB9DOXHBಯ

(/6(

Programación del PLC
Manual de programación y manejo, 11/2019

287

ಯ7DJB5HVXOWಯ
ಯ7DJB2XWSXWಯ

(12

6

1329

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

K

Tag_Number

Valor
1

IN0

Tag_ValueI_0

DW#16#00000000

IN1

Tag_Value_1

DW#16#003E4A7D

ELSE

Tag_Value_2

DW#16#FFFF0000

OUT

Tag_Result

DW#16#003E4A7D

Si el operando "Tag_Input" devuelve el estado lógico "1", se ejecuta la instrucción. De acuerdo
con el valor del operando "Tag_Number", se copia el valor de la entrada "Tag_Value_1" y se
asigna al operando de la salida "Tag_Result". Si no se producen errores al ejecutar la
instrucción, se activan las salidas ENO y "Tag_Output".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

DEMUX: Desmultiplexar
Descripción
La instrucción "Desmultiplexar" permite copiar el contenido de la entrada IN en una salida
seleccionada. El cuadro de la instrucción contiene en estado estacionario mín. 2 salidas
(OUT0 y OUT1). El número de salidas seleccionables del cuadro de la instrucción se puede
ampliar. Las salidas se numeran automáticamente en el cuadro. La numeración comienza por
OUT0 y continúa en orden ascendente con cada nueva salida. El parámetro K permite
determinar la salida en la que se copia el contenido de la entrada IN. Las demás salidas no
cambian. Si el valor del parámetro K es mayor que el número de salidas disponibles, el
contenido de la entrada IN se copia en el parámetro ELSE y a la salida de habilitación ENO se
le asigna el estado lógico "0".
La instrucción "Desmultiplexar" solo se puede ejecutar si las variables de la entrada IN y las de
todas las salidas son del mismo tipo de datos. El parámetro K es una excepción, ya que en el
mismo sólo pueden indicarse números enteros.
La salida de habilitación ENO se desactiva si se cumple una de las condiciones siguientes:
● La entrada de habilitación EN devuelve el estado lógico "0".
● El valor del parámetro K es mayor que el número de salidas disponibles.
● Se producen errores al ejecutar la instrucción.

1330

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Desmultiplexar":
Parámetro Declara‐
ción

S7-1200

Tipo de datos
S7-1500

S7-1200

Área de memoria
S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D,
L o cons‐
tante

I, Q, M, D,
Entrada de habili‐
L, T o cons‐ tación
tante

ENO

Output

BOOL

BOOL

I, Q, M, D, L I, Q, M, D, L Salida de habilita‐
ción

K

Input

Enteros

Enteros

Indica la salida en
I, Q, M, D, I, Q, M, D,
L, P o cons‐ L, P o cons‐ la que se copia el
tante
tante
valor de entrada
(IN).
● Si K = 0 =>
parámetro
OUT0
● Si K = 1 =>
parámetro
OUT1, etc.

IN

Input

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, DATE

Valor de entrada
Números bi‐ I, Q, M, D, I, Q, M, D,
narios, ente‐ L, P o cons‐ L, P o cons‐
tante
tante
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD,
LTOD, DA‐
TE, LDT

OUT0

Output

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, DATE

Números bi‐ I, Q, M, D,
narios, ente‐ L, P
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD,
LTOD, DA‐
TE, LDT

I, Q, M, D,
L, P

Primera salida

OUT1

Output

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, DATE

Números bi‐ I, Q, M, D,
narios, ente‐ L, P
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD,
LTOD, DA‐
TE, LDT

I, Q, M, D,
L, P

Segunda salida

Programación del PLC
Manual de programación y manejo, 11/2019

1331

Instrucciones
4.1 Instrucciones
Parámetro Declara‐
ción

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

Descripción

S7-1500

OUTn

Output

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, DATE

Números bi‐ I, Q, M, D,
narios, ente‐ L, P
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD,
LTOD, DA‐
TE, LDT

I, Q, M, D,
L, P

Salidas opciona‐
les

ELSE

Output

Números bi‐
narios, ente‐
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD, DATE

Números bi‐ I, Q, M, D,
narios, ente‐ L, P
ros, núme‐
ros en coma
flotante,
tiempos,
CHAR,
WCHAR,
TOD,
LTOD, DA‐
TE, LDT

I, Q, M, D,
L, P

Salida en la que
se copia el valor
de entrada (IN)
con K > n.

En la lista desplegable "<???>" del cuadro de la instrucción se puede seleccionar el tipo de
datos de la instrucción.
Encontrará más información sobre los tipos de datos disponibles en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
'(08;
':25'
ಯ7DJB,QSXWಯ
ಯ7DJB1XPEHUಯ
ಯ7DJB9DOXHಯ

(1

287

ಯ7DJB2XWSXWBಯ

.

287

ಯ7DJB2XWSXWBಯ

,1

(/6(

ಯ7DJB2XWSXWBಯ
ಯ7DJB2XWSXWಯ

(12

6

Las tablas siguientes muestran el funcionamiento de la instrucción con valores de operandos
concretos:
Tabla 4-3

1332

Valores de entrada de la instrucción "Desmultiplexar" antes de ejecutar el segmento

Parámetro

Operando

K

Tag_Number

1

4

IN

Tag_Value

DW#16#FFFFFFFF

DW#16#003E4A7D

Valores

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tabla 4-4

Valores de salida de la instrucción "Desmultiplexar" tras ejecutar el segmento

Parámetro

Operando

Valores

OUT0

Tag_Output_0

Sin cambios

Sin cambios

OUT1

Tag_Output_1

DW#16#FFFFFFFF

Sin cambios

ELSE

Tag_Output_2

Sin cambios

DW#16#003E4A7D

Cuando la entrada "Tag_Input" devuelve el estado lógico "1", se ejecuta la instrucción
"Desmultiplexar". Según el valor del operando "Tag_Number", se copia el valor de la entrada
IN en la salida correspondiente.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

Desplazamiento y rotación
SHR: Desplazar a la derecha
Descripción
La instrucción "Desplazar a la derecha" permite desplazar el contenido del operando de la
entrada IN de bit en bit hacia la derecha y consultar el resultado en la salida OUT. La entrada
N determina el número de bits que debe desplazarse el valor indicado.
Si el valor de la entrada N es "0", el valor de la entrada IN se copia sin modificaciones en el
operando de la salida OUT.
Si el valor de la entrada N es mayor que el número de bits disponibles, el valor del operando
de la entrada IN se desplaza hacia la derecha las posiciones de bit disponibles.
En los valores sin signo, se rellenan con ceros los bits que quedan libres en el área izquierda
del operando al realizar el desplazamiento. Si el valor indicado lleva signo, las posiciones libres
se ocupan con el estado lógico del bit de signo.
La figura siguiente muestra cómo el contenido de un operando del tipo de datos Integer se
desplaza cuatro posiciones de bit hacia la derecha:

Programación del PLC
Manual de programación y manejo, 11/2019

1333

Instrucciones
4.1 Instrucciones


,1



1

%LW
GHVLJQR

287



 













































SRVLFLRQHV

























(VWRVFXDWURELWV
VHSLHUGHQ

/RVELWVTXHTXHGDQOLEUHV
VHUHOOHQDQFRQHOHVWDGROµJLFR
GHOELWGHVLJQR

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Desplazar a la derecha":
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

IN

Input

Secuen‐
cias de
bits, ente‐
ros

Secuencias I, Q, M, D, L
de bits, ente‐ o constante
ros

I, Q, M, D, L
o constante

Valor que se
desplaza

N

Input

USINT,
UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

I, Q, M, D, L
o constante

I, Q, M, D, L
o constante

Número de
posiciones
de bit que se
desplaza el
valor

OUT

Output

Secuen‐
cias de
bits, ente‐
ros

Secuencias I, Q, M, D, L
de bits, ente‐
ros

I, Q, M, D, L

Resultado
de la instruc‐
ción

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1334

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
6+5
:25'
ಯ7DJ,Qಯ

(1

ಯ7DJ,QB9DOXHಯ

,1

287

ಯ7DJB1XPEHUಯ

1

(12

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ
6

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

TagIn_Value

0011 1111 1010 1111

N

Tag_Number

3

OUT

TagOut_Value

0000 0111 1111 0101

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El contenido del
operando "TagIn_Value" se desplaza tres posiciones de bit hacia la derecha. El resultado se
emite en la salida "TagOut_Value". Si no se producen errores al ejecutar la instrucción, la
salida de habilitación ENO devuelve el estado lógico "1" y se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

SHL: Desplazar a la izquierda
Descripción
La instrucción "Desplazar a la izquierda" permite desplazar el contenido del operando de la
entrada IN de bit en bit hacia la izquierda y consultar el resultado en la salida OUT. La entrada
N determina el número de bits que debe desplazarse el valor indicado.
Si el valor de la entrada N es "0", el valor de la entrada IN se copia sin modificaciones en el
operando de la salida OUT.
Si el valor de la entrada N es mayor que el número de bits disponibles, el valor del operando
de la entrada IN se desplaza hacia la izquierda las posiciones de bit disponibles.
Los bits que quedan libres en el área derecha del operando al realizar el desplazamiento se
rellenan con ceros.
La figura siguiente muestra cómo el contenido de un operando del tipo de datos WORD se
desplaza seis posiciones de bit hacia la izquierda:

Programación del PLC
Manual de programación y manejo, 11/2019

1335

Instrucciones
4.1 Instrucciones


,1



 










1

287






















SRVLFLRQHV

     

































/RVELWVTXHTXHGDQ
OLEUHVVHUHOOHQDQ
FRQFHURV

(VWRVVHLVELWV
VHSLHUGHQ

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Desplazar a la izquierda":
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

IN

Input

Secuen‐
cias de
bits, ente‐
ros

Secuencias I, Q, M, D, L
de bits, ente‐ o constante
ros

I, Q, M, D, L
o constante

Valor que se
desplaza.

N

Input

USINT,
UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

I, Q, M, D, L
o constante

I, Q, M, D, L
o constante

Número de
bits que se
desplaza el
valor.

OUT

Output

Secuen‐
cias de
bits, ente‐
ros

Secuencias I, Q, M, D, L
de bits, ente‐
ros

I, Q, M, D, L

Resultado
de la instruc‐
ción

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1336

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
6+/
:25'
ಯ7DJ,Qಯ

(1

ಯ7DJ,QB9DOXHಯ

,1

ಯ7DJB1XPEHUಯ

1

287

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

(12

6

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

TagIn_Value

0011 1111 1010 1111

N

Tag_Number

4

OUT

TagOut_Value

1111 1010 1111 0000

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El contenido del
operando "TagIn_Value" se desplaza cuatro posiciones de bit hacia la izquierda. El resultado
se emite en la salida "TagOut_Value". Si no se producen errores al ejecutar la instrucción, la
salida de habilitación ENO devuelve el estado lógico "1" y se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

ROR: Rotar a la derecha
Descripción
La instrucción "Rotar a la derecha" permite rotar el contenido del operando de la entrada IN de
bit en bit hacia la derecha y consultar el resultado en la salida OUT. La entrada N determina el
número de bits que debe rotarse el valor indicado. Los bits que quedan libres al realizar la
rotación en el lado izquierdo se rellenan con los bits desplazados hacia fuera dispersos del lado
derecho.
Si el valor de la entrada N es "0", el valor de la entrada IN se copia sin modificaciones en el
operando de la salida OUT.
Si el valor del parámetro N es mayor que el número de bits disponibles, el valor del operando
en la entrada IN rota de todos modos el número indicado de posiciones de bit.
La figura siguiente muestra cómo el contenido de un operando del tipo de datos DWORD rota
tres posiciones hacia la derecha:

Programación del PLC
Manual de programación y manejo, 11/2019

1337

Instrucciones
4.1 Instrucciones


,1

 



       

1

SRVLFLRQHV

287

        
(OHVWDGROµJLFRGHORVWUHV
ELWVGHVSOD]DGRVVHLQVHUWD
HQODVSRVLFLRQHVTXHTXHGDQOLEUHV

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Rotar a la derecha":
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

IN

Input

Secuencias
de bits, en‐
teros

Secuen‐
cias de
bits, ente‐
ros

I, Q, M, D, L
o constante

I, Q, M, D, L
o constante

Valor que se
rota

N

Input

USINT,
UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

I, Q, M, D, L
o constante

I, Q, M, D, L
o constante

Número de
posiciones
de bit que ro‐
ta el valor

OUT

Output

Secuencias
de bits, en‐
teros

Secuen‐
cias de
bits, ente‐
ros

I, Q, M, D, L

I, Q, M, D, L

Resultado
de la instruc‐
ción

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1338

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
525
:25'
ಯ7DJ,Qಯ

(1

ಯ7DJ,QB9DOXHಯ

,1

ಯ7DJB1XPEHUಯ

1

287

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

(12

6

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

TagIn_Value

0000 1111 1001 0101

N

Tag_Number

5

OUT

TagOut_Value

1010 1000 0111 1100

Si el operando "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El contenido del
operando "TagIn_Value" se rota cinco posiciones de bit hacia la derecha. El resultado se emite
en la salida "TagOut_Value". Si no se producen errores al ejecutar la instrucción, la salida de
habilitación ENO devuelve el estado lógico "1" y se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

ROL: Rotar a la izquierda
Descripción
La instrucción "Rotar a la izquierda" permite rotar el contenido del operando de la entrada IN
de bit en bit hacia la izquierda y consultar el resultado en la salida OUT. La entrada N determina
el número de bits que debe rotarse el valor indicado. Los bits que quedan libres al realizar la
rotación en el lado derecho se rellenan con los bits desplazados hacia fuera dispersos del lado
izquierdo.
Si el valor de la entrada N es "0", el valor de la entrada IN se copia en el operando de la salida
OUT.
Si el valor del parámetro N es mayor que el número de bits disponibles, el valor del operando
en la entrada IN rota de todos modos el número indicado de posiciones de bit.
La figura siguiente muestra cómo el contenido de un operando del tipo de datos DWORD rota
tres posiciones hacia la izquierda:

Programación del PLC
Manual de programación y manejo, 11/2019

1339

Instrucciones
4.1 Instrucciones


,1

 

       

1

287



SRVLFLRQHV

        
(OHVWDGROµJLFRGHORVWUHV
ELWVGHVSOD]DGRVVHLQVHUWDHQODV
SRVLFLRQHVTXHKDQTXHGDGROLEUHV

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Rotar a la izquierda":
Parámetro

Declaración

Tipo de datos

Área de memoria

S7-1200

S7-1500

S7-1200

S7-1500

Descripción

EN

Input

BOOL

BOOL

I, Q, M, D, L
o constante

I, Q, M, D, L,
T, C o cons‐
tante

Entrada de
habilitación

ENO

Output

BOOL

BOOL

I, Q, M, D, L

I, Q, M, D, L

Salida de ha‐
bilitación

IN

Input

Secuen‐
cias de
bits, ente‐
ros

Secuencias
de bits, en‐
teros

I, Q, M, D, L
o constante

I, Q, M, D, L
o constante

Valor que se
rota.

N

Input

USINT,
UINT,
UDINT

USINT,
UINT,
UDINT,
ULINT

I, Q, M, D, L
o constante

I, Q, M, D, L
o constante

Número de
bits que rota
el valor.

OUT

Output

Secuen‐
cias de
bits, ente‐
ros

Secuencias
de bits, en‐
teros

I, Q, M, D, L

I, Q, M, D, L

Resultado
de la instruc‐
ción

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar el tipo de datos
de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1340

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
52/
':25'
ಯ7DJ,Qಯ

(1

ಯ7DJ,QB9DOXHಯ

,1

ಯ7DJB1XPEHUಯ

1

287

ಯ7DJ2XWB9DOXHಯ
ಯ7DJ2XWಯ

(12

6

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

TagIn_Value

1010 1000 1111 0110

N

Tag_Number

5

OUT

TagOut_Value

0001 1110 1101 0101

Si la entrada "TagIn" devuelve el estado lógico "1", se ejecuta la instrucción. El contenido del
operando "TagIn_Value" se rota cinco posiciones de bit hacia la izquierda. El resultado se
emite en la salida "TagOut_Value". Si no se producen errores al ejecutar la instrucción, la
salida de habilitación ENO devuelve el estado lógico "1" y se activa la salida "TagOut".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

Legacy
DRUM: Materializar circuito secuencial sucesivo
Descripción
La instrucción "Materializar circuito secuencial sucesivo" ocupa los bits de salida programados
(OUT1 a OUT16) y la palabra de salida (OUT_WORD) con los valores programados del
parámetro OUT_VAL del paso respectivo. El paso en cuestión debe cumplir las condiciones de
la máscara de habilitación programada en el parámetro S_MASK mientras la instrucción
permanece en dicho paso. La instrucción pasa al paso siguiente cuando el evento de éste es
verdadero y una vez transcurrido el tiempo programado para el paso actual, o bien cuando el
valor del parámetro JOG cambia de "0" a "1". La instrucción se desactiva cuando el estado
lógico del parámetro RESET cambia a "1". Con ello, el paso actual se iguala al paso
predeterminado (DSP).
El tiempo de permanencia en un paso se calcula multiplicando la base de tiempo
predeterminada (DTBP) por el valor de contaje predeterminado (S_PRESET) para cada paso.
Al comienzo de un nuevo paso, este valor calculado se carga en el parámetro DCC, que

Programación del PLC
Manual de programación y manejo, 11/2019

1341

Instrucciones
4.1 Instrucciones
contiene el tiempo restante para el paso actual. Por ejemplo, si el valor del parámetro DTBP es
"2" y el valor predeterminado para el primer paso es "100" (100 ms), el parámetro DCC
devolverá el valor "200" (200 ms).
Un paso puede programarse con un valor de tiempo, con un evento o con ambos. Los pasos
programados con un bit de evento y el valor de tiempo "0" pasan al siguiente paso en cuanto
el estado lógico del bit de evento es "1". Los pasos programados solo con un valor de tiempo
empiezan a contar el tiempo inmediatamente. Los pasos programados con un bit de evento y
un valor de tiempo mayor que "0" empiezan a contar el tiempo en cuanto el estado lógico del
bit de evento es "1". Los bits de evento se inicializan con el estado lógico "1".
Si el circuito secuencial sucesivo se encuentra en el último paso programado (LST_STEP) y ha
transcurrido el tiempo para dicho paso, el estado lógico del parámetro Q se pone a "1". De lo
contrario, se pone a "0". Si está activado el parámetro Q, la instrucción permanece en el paso
hasta la desactivación.
En la máscara configurable (S_MASK) es posible seleccionar los distintos bits de la palabra de
salida (OUT_WORD) y activar o desactivar los bits de salida (OUT1 a OUT16) mediante los
valores de salida (OUT_VAL). Si un bit de la máscara configurable tiene el estado lógico "1",
el valor OUT_VAL activa o desactiva el bit correspondiente. Si el estado lógico de un bit de la
máscara configurable es "0", no cambia el bit respectivo. Todos los bits de la máscara
configurable de todos los 16 pasos se inicializan con el estado lógico "1".
El bit de salida del parámetro OUT1 equivale al bit menos significativo de la palabra de salida
(OUT_WORD). El bit de salida del parámetro OUT16 equivale al bit más significativo de la
palabra de salida (OUT_WORD).

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Materializar circuito secuencial
sucesivo":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

RESET

Input

BOOL

I, Q, M, D, L o
constante

El estado lógico "1" indica
una condición de desactiva‐
ción.

JOG

Input

BOOL

I, Q, M, D, L o
constante

Si el estado lógico cambia de
"0" a "1", la instrucción pasa
al siguiente paso.

DRUM_EN

Input

BOOL

I, Q, M, D, L o
constante

El estado lógico "1" permite
que el circuito secuencial su‐
cesivo siga contando según
el evento y los criterios de
tiempo.

LST_STEP

Input

BYTE

I, Q, M, D, L o
constante

Número máximo de etapas
(p. ej.: LST_STEP = 16#08;
son posibles 8 etapas como
máximo.)

EVENT(i),

Input

BOOL

I, Q, M, D, L o
constante

Bit de evento (i);

1 ≤ i ≤ 16

1342

El estado lógico inicial es "1".

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OUT(j),

Output

BOOL

I, Q, M, D, L

Bit de salida (j)

Q

Output

BOOL

I, Q, M, D, L

El estado lógico "1" indica
que ha transcurrido el tiempo
del último paso.

OUT_WORD

Output

WORD

I, Q, M, D, L, P

Dirección de palabra en la
que el circuito secuencial su‐
cesivo escribe los valores de
salida.

ERR_CODE

Output

WORD

I, Q, M, D, L, P

Información de error

JOG_HIS

Static

BOOL

I, Q, M, D, L o
constante

Bit de evolución del paráme‐
tro JOG

EOD

Static

BOOL

I, Q, M, D, L o
constante

El estado lógico "1" indica
que ha transcurrido el tiempo
del último paso.

DSP

Static

BYTE

I, Q, M, D, L, P o
constante

Paso predeterminado del cir‐
cuito secuencial sucesivo

DSC

Static

BYTE

I, Q, M, D, L, P o
constante

Paso actual del circuito se‐
cuencial sucesivo

DCC

Static

DWORD

I, Q, M, D, L, P o
constante

Valor de contaje actual del
circuito secuencial sucesivo

DTBP

Static

WORD

I, Q, M, D, L, P o
constante

Base de tiempo predetermi‐
nada del circuito secuencial
sucesivo

PrevTime

Static

TIME

I, Q, M, D, L o
constante

Hora de sistema anterior

S_PRESET

Static

ARRAY[1..16] of
WORD

I, Q, M, D, L o
constante

Valor de contaje predetermi‐
nado para cada paso [1 a 16];
1 ciclo de reloj = 1 ms.

OUT_VAL

Static

ARRAY[1..16,
0..15] of BOOL

I, Q, M, D, L o
constante

Valores de salida para cada
etapa [1 a 16, 0 a 15].

S_MASK

Static

ARRAY[1..16,
0..15] of BOOL

I, Q, M, D, L o
constante

Máscara configurable para
cada etapa [1 a 16, 0 a 15].
Los estados lógicos iniciales
son "1".

1 ≤ j ≤ 16

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
ERR_CO‐
DE*

Explicación

W#16#000
0

Ningún error

W#16#000
B

El valor del parámetro LST_STEP es menor que 1 o mayor que 16.

W#16#000
C

El valor del parámetro DSC es menor que 1 o mayor que el valor del parámetro
LST_STEP.

Programación del PLC
Manual de programación y manejo, 11/2019

1343

Instrucciones
4.1 Instrucciones
ERR_CO‐
DE*

Explicación

W#16#000
D

El valor del parámetro DSP es menor que 1 o mayor que el valor de LST_STEP.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
En el ejemplo siguiente, la instrucción pasa del paso 1 al paso 2. Los bits de salida (OUT1 a
OUT16) y la palabra de salida (OUT_WORD) se activan según la máscara configurada para el
paso 2 y los valores del parámetro OUT_VAL.
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.
ಯ'580B'%ಯ
'580
ಯ7DJ,Qಯ
ಯ7DJB5HVHWಯ
ಯ7DJB,QSXWB-2*ಯ
ಯ7DJB'580B(1ಯ
ಯ/DVW6WHSಯ
ಯ0\(YHQWಯ

(12

(1
5(6(7
-2*
'580B(1
/67B67(3
(9(17

287
4
287B:25'
(55B&2'(

ಯ7DJ2XWಯ
ಯ0\2XWSXWಯ
ಯ7DJB2XWSXWB4ಯ
ಯ7DJB2XWSXWB:25'ಯ
ಯ7DJB(UURU&RGHಯ

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para asignar valores a los parámetros de
entrada:
Parámetro

1344

Operando

Dirección

Valor

RESET

Tag_Reset

M0.0

FALSE

JOG

Tag_Input_JOG

M0.1

FALSE

DRUM_EN

Tag_Input_DrumEN

M0.2

TRUE

LST_STEP

Tag_Number_LastStep

MB1

B#16#08

EVENT2

MyTag_Event_2

M20.0

FALSE

EVENT4

MyTag_Event_4

M20.1

FALSE

EVENT6

MyTag_Event_6

M20.2

FALSE

EVENT8

MyTag_Event_8

M20.3

FALSE

EVENT10

MyTag_Event_10

M20.4

FALSE

EVENT12

MyTag_Event_12

M20.5

FALSE

EVENT14

MyTag_Event_14

M20.6

FALSE

EVENT16

MyTag_Event_16

M20.7

FALSE

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
En el bloque de datos de instancia "DRUM_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

JOG_HIS

DBX12.0

FALSE

EOD

DBX12.1

FALSE

DSP

DBB13

W#16#0001

DSC

DBB14

W#16#0001

DCC

DBD16

DW#16#0000000A

DTBP

DBW20

W#16#0001

S_PRESET[1]

DBW26

W#16#0064

S_PRESET[2]

DBW28

W#16#00C8

OUT_VAL[1,0]

DBX58.0

TRUE

OUT_VAL[1,1]

DBX58.1

TRUE

OUT_VAL[1,2]

DBX58.2

TRUE

OUT_VAL[1,3]

DBX58.3

TRUE

OUT_VAL[1,4]

DBX58.4

TRUE

OUT_VAL[1,5]

DBX58.5

TRUE

OUT_VAL[1,6]

DBX58.6

TRUE

OUT_VAL[1,7]

DBX58.7

TRUE

OUT_VAL[1,8]

DBX59.0

TRUE

OUT_VAL[1,9]

DBX59.1

TRUE

OUT_VAL[1,10]

DBX59.2

TRUE

OUT_VAL[1,11]

DBX59.3

TRUE

OUT_VAL[1,12]

DBX59.4

TRUE

OUT_VAL[1,13]

DBX59.5

TRUE

OUT_VAL[1,14]

DBX59.6

TRUE

OUT_VAL[1,15]

DBX59.7

TRUE

OUT_VAL[2,0]

DBX60.0

FALSE

OUT_VAL[2,1]

DBX60.1

FALSE

OUT_VAL[2,2]

DBX60.2

FALSE

OUT_VAL[2,3]

DBX60.3

FALSE

OUT_VAL[2,4]

DBX60.4

FALSE

OUT_VAL[2,5]

DBX60.5

FALSE

OUT_VAL[2,6]

DBX60.6

FALSE

OUT_VAL[2,7]

DBX60.7

FALSE

OUT_VAL[2,8]

DBX61.0

FALSE

OUT_VAL[2,9]

DBX61.1

FALSE

OUT_VAL[2,10]

DBX61.2

FALSE

OUT_VAL[2,11]

DBX61.3

FALSE

OUT_VAL[2,12]

DBX61.4

FALSE

OUT_VAL[2,13]

DBX61.5

FALSE

OUT_VAL[2,14]

DBX61.6

FALSE

OUT_VAL[2,15]

DBX61.7

FALSE

Programación del PLC
Manual de programación y manejo, 11/2019

1345

Instrucciones
4.1 Instrucciones
Parámetro

Dirección

Valor

S_MASK[2,0]

DBX92.0

FALSE

S_MASK[2,1]

DBX92.1

TRUE

S_MASK[2,2]

DBX92.2

TRUE

S_MASK[2,3]

DBX92.3

TRUE

S_MASK[2,4]

DBX92.4

TRUE

S_MASK[2,5]

DBX92.5

FALSE

S_MASK[2,6]

DBX92.6

TRUE

S_MASK[2,7]

DBX92.7

TRUE

S_MASK[2,8]

DBX93.0

FALSE

S_MASK[2,9]

DBX93.1

FALSE

S_MASK[2,10]

DBX93.2

TRUE

S_MASK[2,11]

DBX93.3

TRUE

S_MASK[2,12]

DBX93.4

TRUE

S_MASK[2,13]

DBX93.5

TRUE

S_MASK[2,14]

DBX93.6

FALSE

S_MASK[2,15]

DBX93.7

TRUE

Los parámetros de salida tienen los valores siguientes antes de ejecutarse la instrucción:

1346

Parámetro

Operando

Dirección

Valor

Q

Tag_Output_Q

M6.0

FALSE

OUTWORD

Tag_OutputWord

MW8

W#16#FFFF

OUT1

MyTag_Output_1

M4.0

TRUE

OUT2

MyTag_Output_2

M4.1

TRUE

OUT3

MyTag_Output_3

M4.2

TRUE

OUT4

MyTag_Output_4

M4.3

TRUE

OUT5

MyTag_Output_5

M4.4

TRUE

OUT6

MyTag_Output_6

M4.5

TRUE

OUT7

MyTag_Output_7

M4.6

TRUE

OUT8

MyTag_Output_8

M4.7

TRUE

OUT9

MyTag_Output_9

M5.0

TRUE

OUT10

MyTag_Output_10

M5.1

TRUE

OUT11

MyTag_Output_11

M5.2

TRUE

OUT12

MyTag_Output_12

M5.3

TRUE

OUT13

MyTag_Output_13

M5.4

TRUE

OUT14

MyTag_Output_14

M5.5

TRUE

OUT15

MyTag_Output_15

M5.6

TRUE

OUT16

MyTag_Output_16

M5.7

TRUE

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Dirección

Valor

OUT1

MyTag_Output_1

M4.0

TRUE

OUT2

MyTag_Output_2

M4.1

FALSE

OUT3

MyTag_Output_3

M4.2

FALSE

OUT4

MyTag_Output_4

M4.3

FALSE

OUT5

MyTag_Output_5

M4.4

FALSE

OUT6

MyTag_Output_6

M4.5

TRUE

OUT7

MyTag_Output_7

M4.6

FALSE

OUT8

MyTag_Output_8

M4.7

FALSE

OUT9

MyTag_Output_9

M5.0

TRUE

OUT10

MyTag_Output_10

M5.1

TRUE

OUT11

MyTag_Output_11

M5.2

FALSE

OUT12

MyTag_Output_12

M5.3

FALSE

OUT13

MyTag_Output_13

M5.4

FALSE

OUT14

MyTag_Output_14

M5.5

FALSE

OUT15

MyTag_Output_15

M5.6

TRUE

OUT16

MyTag_Output_16

M5.7

FALSE

Q

Tag_Output_Q

M6.0

FALSE

OUTWORD

Tag_OutputWord

MW8

W#16#4321

ERR_CODE

Tag_ErrorCode

MW10

W#16#0000

Los siguientes valores se modifican en el bloque de datos de instancia "DRUM_DB" de la
instrucción después de su ejecución:
Parámetro

Dirección

Valor

JOG_HIS

DBX12.0

FALSE

EOD

DBX12.1

FALSE

DSC

DBB14

W#16#0002

DCC

DBD16

DW#16#000000C8

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1347

Instrucciones
4.1 Instrucciones

DCAT: Alarma de tiempo para control discreto
Descripción
La instrucción "Alarma de tiempo para control discreto" acumula el tiempo desde el instante en
el que el parámetro CMD da la orden de abrir o cerrar. El tiempo se acumula hasta excederse
el tiempo predeterminado (PT) o hasta recibir la notificación de que el dispositivo se ha cerrado
o abierto dentro del tiempo prescrito (O_FB o C_FB). Si se excede el tiempo predeterminado
antes de recibirse la notificación de que se ha abierto o cerrado el dispositivo, se activa la
alarma correspondiente. Si el estado lógico de la entrada de la orden cambia antes del tiempo
predeterminado, se reinicia el tiempo.
La instrucción "Alarma de tiempo para control discreto" tiene las reacciones siguientes en las
condiciones de entrada:
● Si el estado lógico del parámetro CMD cambia de "0" a "1", esto tiene los efectos siguientes
en los estados lógicos de los parámetros Q, CMD_HIS, ET (solo si ET < PT), OA y CA:
– Los parámetros Q y CMD_HIS se ponen a "1"
– Los parámetros ET, OA y CA se ponen a "0"
● Si el estado lógico del parámetro CMD cambia de "1" a "0", los parámetros Q, ET (solo si
ET < PT), OA, CA y CMD_HIS se ponen a "0".
● Si los parámetros CMD y CMD_HIS tienen el estado lógico "1" y el parámetro O_FB se pone
a "0", la diferencia de tiempo (ms) desde la última ejecución de la instrucción se suma al
valor del parámetro ET. Si el valor del parámetro ET excede el del parámetro PT, el estado
lógico del parámetro OA se pone a "1". Si el valor del parámetro ET no excede el del
parámetro PT, el estado lógico del parámetro OA se pone a "0". El valor del parámetro
CMD_HIS se pone al del parámetro CMD.
● Si los estados lógicos de los parámetros CMD, CMD_HIS y O_FB están a "1" y el parámetro
C_FB devuelve el valor "0", el estado lógico del parámetro OA se pone a "0". El valor del
parámetro ET se pone al del parámetro PT. Si el estado lógico del parámetro O_FB cambia
a "0", se activa la alarma en la siguiente ejecución de la instrucción. El valor del parámetro
CMD_HIS se pone al del parámetro CMD.
● Si los parámetros CMD, CMD_HIS y C_FB devuelven el estado lógico "0", la diferencia de
tiempo (ms) desde la última ejecución de la instrucción se suma al valor del parámetro ET.
Si el valor del parámetro ET excede el del parámetro PT, el estado lógico del parámetro CA
se pone a "1". Si no se excede el valor del parámetro PT, el parámetro CA devuelve el
estado lógico "0". El valor del parámetro CMD_HIS se pone al del parámetro CMD.
● Si los parámetros CMD, CMD_HIS y O_FB devuelven el estado lógico "0" y el parámetro
C_FB está a "1", el parámetro CA se pone a "0". El valor del parámetro ET se pone al del
parámetro PT. Si el estado lógico del parámetro C_FB cambia a "0", se activa la alarma en
la siguiente ejecución de la instrucción. El valor del parámetro CMD_HIS se pone al del
parámetro CMD.
● Si los parámetros O_FB y C_FB devuelven simultáneamente el estado lógico "1", los
estados lógicos de ambas salidas de alarma se ponen a "1".
La instrucción "Alarma de tiempo para control discreto" no devuelve información de error.

1348

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Alarma de tiempo para control
discreto":
Parámetro

Declaración

Tipo de datos

Área de memoria Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C
o constante

Entrada de habi‐
litación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habili‐
tación

CMD

Input

BOOL

I, Q, M, D, L o
constante

El estado lógico
"0" da la orden
de "Cerrar".
El estado lógico
"1" da la orden
de "Abrir".

O_FB

Input

BOOL

I, Q, M, D, L o
constante

Entrada de res‐
puesta al abrir

C_FB

Input

BOOL

I, Q, M, D, L o
constante

Entrada de res‐
puesta al cerrar

Q

Output

BOOL

I, Q, M, D, L

Indica el estado
del parámetro
CMD

OA

Output

BOOL

I, Q, M, D, L

Salida de alarma
al abrir

CA

Output

BOOL

I, Q, M, D, L

Salida de alarma
al cerrar

ET

Static

DINT

D, L o constante

Tiempo actual
transcurrido; un
ciclo de reloj = 1
ms.

PT

Static

DINT

D, L o constante

Valor de tiempo
predeterminado;
un ciclo de reloj
= 1 ms.

PREV_TIME

Static

DWORD

D, L o constante

Hora de sistema
anterior

CMD_HIS

Static

BOOL

D, L o constante

Bit de evolución
de CMD

Ejemplo
En el ejemplo siguiente, el parámetro CMD cambia de "0" a "1". Una vez ejecutada la
instrucción, el parámetro Q se pone a "1" y las dos salidas de alarma OA y CA se ponen a "0".
El parámetro CMD_HIS del bloque de datos de instancia se pone a "1" y el parámetro ET se
pone a "0".
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

Programación del PLC
Manual de programación y manejo, 11/2019

1349

Instrucciones
4.1 Instrucciones
ಯ'&$7B'%ಯ
'&$7
ಯ7DJ,Qಯ

(1

4

ಯ7DJB2XWSXWB4ಯ

ಯ7DJB,QSXWB&0'ಯ

&0'

2$

ಯ7DJB2XWSXWB2$ಯ

ಯ7DJB,QSXWB2B)%ಯ

2B)%

&$

ಯ7DJB2XWSXWB&$ಯ

ಯ7DJB,QSXWB&B)%ಯ

&B)%

(12

ಯ7DJ2XWಯ

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.
Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada y salida:
Parámetro

Operando

Valor

CMD

Tag_Input_CMD

TRUE

O_FB

Tag_Input_O_FB

FALSE

C_FB

Tag_Input_C_FB

FALSE

Q

Tag_Output_Q

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

En el bloque de datos de instancia "DCAT_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

ET

DBD4

L#12

PT

DBD8

L#222

CMD_HIS

DBX16.0

FALSE

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

Q

Tag_Output_Q

TRUE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

En el bloque de datos de instancia "DCAT_DB" de la instrucción se guardan los siguientes
valores:

1350

Parámetro

Dirección

Valor

ET

DBD4

L#0

CMD_HIS

DBX16.0

TRUE

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

MCAT: Alarma de tiempo para control del motor
Descripción
La instrucción "Alarma de tiempo para control del motor" acumula el tiempo desde el instante
en el que se activa una de las entradas de comando (abrir o cerrar). El tiempo se acumula hasta
que se excede el tiempo predeterminado o hasta que la entrada de realimentación
correspondiente indica que el dispositivo ha ejecutado la operación solicitada dentro del
tiempo prescrito. Si se excede el tiempo predeterminado antes de recibir respuesta, se dispara
la alarma correspondiente.
La instrucción "Alarma de tiempo para control del motor" no devuelve información de error.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Alarma de tiempo para control del
motor":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

O_CMD

Input

BOOL

I, Q, M, D, L o
constante

Entrada del comando "Abrir"

C_CMD

Input

BOOL

I, Q, M, D, L o
constante

Entrada del comando "Ce‐
rrar"

S_CMD

Input

BOOL

I, Q, M, D, L o
constante

Entrada del comando "Parar"

O_FB

Input

BOOL

I, Q, M, D, L o
constante

Entrada de respuesta al abrir

C_FB

Input

BOOL

I, Q, M, D, L o
constante

Entrada de respuesta al ce‐
rrar

OO

Output

BOOL

I, Q, M, D, L

Salida "Abrir"

CO

Output

BOOL

I, Q, M, D, L

Salida "Cerrar"

OA

Output

BOOL

I, Q, M, D, L

Salida de alarma al abrir

CA

Output

BOOL

I, Q, M, D, L

Salida de alarma al cerrar

Q

Output

BOOL

I, Q, M, D, L

El estado lógico "0" indica
una condición de error.

ET

Static

DINT

D, L o constante

Tiempo actual transcurrido;
un ciclo de reloj = 1 ms

PT

Static

DINT

D, L o constante

Valor de tiempo predetermi‐
nado; un ciclo de reloj = 1 ms

Programación del PLC
Manual de programación y manejo, 11/2019

1351

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

PREV_TIME

Static

DWORD

D, L o constante

Hora de sistema anterior

O_HIS

Static

BOOL

D, L o constante

Bit de evolución "Abrir"

C_HIS

Static

BOOL

D, L o constante

Bit de evolución "Cerrar"

Ejecución de la instrucción "Alarma de tiempo para control del motor"
La tabla siguiente muestra las reacciones de la instrucción "Alarma de tiempo para control del
motor" a las distintas condiciones de entrada:
Parámetros de entrada
O_C
MD

Parámetros de salida

ET

O_H
IS

C_H
IS

C_C
MD

S_C
MD

O_F
B

C_F
B

OO

CO

OA

CA

ET

O_H
IS

C_HI Q
S

Estado

X

1

1

X

X

X

X

X

0

0

1

1

PT

0

0

0

Alarma

X

X

X

X

X

X

1

1

0

0

1

1

PT

0

0

0

Alarma

X

X

X

X

X

1

X

X

0

0

0

0

X

0

0

1

Stop

X

X

X

1

1

X

X

X

0

0

0

0

X

0

0

1

Stop

X

0

X

1

0

0

X

X

1

0

0

0

0

1

0

1

Empezar a
abrir

<PT

1

0

X

0

0

0

X

1

0

0

0

INC

1

0

1

Abrir

X

1

0

X

0

0

1

0

0

0

0

0

PT

1

0

1

Abierto

>=
PT

1

0

X

0

0

0

X

0

0

1

0

PT

1

0

0

Abrir alarma

X

X

0

0

1

0

X

X

0

1

0

0

0

0

1

1

Empezar a
cerrar

< PT 0

1

0

X

0

X

0

0

1

0

0

INC

0

1

1

Cerrar

X

0

1

0

X

0

0

1

0

0

0

0

PT

0

1

1

Cerrado

>=
PT

0

1

0

X

0

X

0

0

0

0

1

PT

0

1

0

Cerrar alar‐
ma

X

0

0

0

0

0

X

X

0

0

0

0

X

0

0

1

Parado

Leyenda:
INC

Sumar a ET la diferencia de tiempo (en ms) desde la última ejecución del FB

PT

PT se pone al mismo valor que ET

X

No aplicable

< PT

ET < PT

>= PT

ET >= PT

Si los parámetros de entrada O_HIS y C_HIS tienen el estado lógico "1", se ponen inmediatamente al estado lógico "0". En
este caso se aplica la última fila de la tabla mencionada más arriba (X). Puesto que por este motivo no es posible comprobar
si los parámetros de entrada O_HIS y C_HIS tienen el estado lógico "1", en este caso se asigna el siguiente valor a los
parámetros de salida:
OO = FALSE
CO = FALSE
OA = FALSE
CA = FALSE
ET = PT
Q = TRUE

1352

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.
ಯ0&$7B'%ಯ
0&$7
(1

22

ಯ7DJB2XWSXW2SHQಯ

ಯ7DJB,QSXWB2B&0'ಯ

2B&0'

&2

ಯ7DJB2XWSXW&ORVHGಯ

ಯ7DJB,QSXWB&B&0'ಯ

&B&0'

2$

ಯ7DJB2XWSXWB2$ಯ

ಯ7DJB,QSXWB6B&0'ಯ

6B&0'

&$

ಯ7DJB2XWSXWB&$ಯ

4

ಯ7DJB2XWSXWB4ಯ

ಯ7DJ,Qಯ

ಯ7DJB,QSXWB2B)%ಯ

2B)%

ಯ7DJB,QSXWB&B)%ಯ

&B)%

ಯ7DJ2XWಯ
(12

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.
Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada y salida:
Parámetro

Operando

Valor

O_CMD

Tag_Input_O_CMD

TRUE

C_CMD

Tag_Input_C_CMD

FALSE

S_CMD

Tag_Input_S_CMD

FALSE

O_FB

Tag_Input_O_FB

FALSE

C_FB

Tag_Input_C_FB

FALSE

OO

Tag_OutputOpen

FALSE

CO

Tag_OutputClosed

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Q

Tag_Output_Q

FALSE

En el bloque de datos de instancia "MCAT_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

ET

DBD4

L#2

PT

DBD8

L#22

Programación del PLC
Manual de programación y manejo, 11/2019

1353

Instrucciones
4.1 Instrucciones
Parámetro

Dirección

Valor

O_HIS

DBX16.0

TRUE

C_HIS

DBX16.1

FALSE

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

OO

Tag_OutputOpen

TRUE

CO

Tag_OutputClosed

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Q

Tag_Output_Q

TRUE

En el bloque de datos de instancia "MCAT_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

ET

DBD4

L#0

O_HIS

DBX16.0

TRUE

CMD_HIS

DBX16.1

FALSE

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

IMC: Comparar bits de entrada con bits de una máscara
Descripción
La instrucción "Comparar bits de entrada con bits de una máscara" compara el estado lógico
de hasta 16 bits de entrada programados (IN_BIT0 a IN_BIT15) con el bit correspondiente de
una máscara. Es posible programar como máximo 16 pasos con máscaras. El valor del
parámetro IN_BIT0 se compara con el valor de la máscara CMP_VAL[x,0], siendo "x" el
número del paso. El número del paso de la máscara utilizada para la comparación se define en
el parámetro CMP_STEP. De esta misma manera se comparan todos los valores
programados. Los bits de entrada no programados o los bits no programados de la máscara
tienen el estado lógico predeterminado FALSE.
Si se encuentra una coincidencia al realizar la comparación, el estado lógico del parámetro
OUT se pone a "1". De lo contrario, el parámetro OUT se pone a "0".
Si el valor del parámetro CMP_STEP es mayor que 15, no se ejecuta la instrucción. En el
parámetro ERR_CODE se emite un mensaje de error.

1354

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Comparar bits de entrada con bits
de una máscara":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

IN_BIT0

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 0 se compa‐
ra con el bit 0 de la máscara.

IN_BIT1

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 1 se compa‐
ra con el bit 1 de la máscara.

IN_BIT2

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 2 se compa‐
ra con el bit 2 de la máscara.

IN_BIT3

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 3 se compa‐
ra con el bit 3 de la máscara.

IN_BIT4

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 4 se compa‐
ra con el bit 4 de la máscara.

IN_BIT5

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 5 se compa‐
ra con el bit 5 de la máscara.

IN_BIT6

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 6 se compa‐
ra con el bit 6 de la máscara.

IN_BIT7

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 7 se compa‐
ra con el bit 7 de la máscara.

IN_BIT8

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 8 se compa‐
ra con el bit 8 de la máscara.

IN_BIT9

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 9 se compa‐
ra con el bit 9 de la máscara.

IN_BIT10

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 10 se com‐
para con el bit 10 de la más‐
cara.

IN_BIT11

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 11 se com‐
para con el bit 11 de la más‐
cara.

IN_BIT12

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 12 se com‐
para con el bit 12 de la más‐
cara.

IN_BIT13

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 13 se com‐
para con el bit 13 de la más‐
cara.

IN_BIT14

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 14 se com‐
para con el bit 14 de la más‐
cara.

IN_BIT15

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 15 se com‐
para con el bit 15 de la más‐
cara.

CMP_STEP

Input

BYTE

I, Q, M, D, L, P o
constante

Número de paso de la más‐
cara con la que se compara.

Programación del PLC
Manual de programación y manejo, 11/2019

1355

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OUT

Output

BOOL

I, Q, M, D, L

El estado lógico "1" indica
que se ha encontrado una
coincidencia.
El estado lógico "0" indica
que no se ha encontrado nin‐
guna coincidencia.

ERR_CODE

Output

WORD

I, Q, M, D, L, P

Información de error

CMP_VAL

Static

ARRAY OF
WORD

I, Q, M, D, L o
constante

Máscaras de comparación [0
a 15, 0 a 15]: El primer núme‐
ro del índice es el número del
paso y, el segundo, el núme‐
ro de bit de la máscara.

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

000A

El valor del parámetro CMP_STEP es mayor que 15.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de FUP (Página 8005)

1356

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

SMC: Barrido de matriz
Descripción
La instrucción "Barrido de matriz" compara el estado lógico de hasta 16 bits de entrada
programados (IN_BIT0 a IN_BIT15) con los bits correspondientes de las máscaras de
comparación de cada paso. La ejecución empieza por el paso 1 y continúa hasta el último paso
programado (LAST) o hasta que se encuentre una correspondencia. El bit de entrada del
parámetro IN_BIT0 se compara con el valor de la máscara CMP_VAL[x,0], siendo "x" el
número de paso. De esta misma manera se comparan todos los valores programados. Si se
encuentra una correspondencia, el estado lógico del parámetro OUT se pone a "1" y el número
de paso se escribe con la máscara correspondiente en el parámetro OUT_STEP. Los bits de
entrada no programados o los bits no programados de la máscara tienen el estado lógico
predeterminado FALSE. Si varios pasos tienen una máscara equivalente, se indica sólo la
primera correspondencia encontrada en el parámetro OUT_STEP. Si no se encuentra ninguna
correspondencia, el estado lógico del parámetro OUT se pone a "0". En este caso, el valor del
parámetro OUT_STEP excede en "1" el valor del parámetro LAST.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Barrido de matriz":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

IN_BIT0

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 0 se compa‐
ra con el bit 0 de la máscara.

IN_BIT1

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 1 se compa‐
ra con el bit 1 de la máscara.

IN_BIT2

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 2 se compa‐
ra con el bit 2 de la máscara.

IN_BIT3

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 3 se compa‐
ra con el bit 3 de la máscara.

IN_BIT4

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 4 se compa‐
ra con el bit 4 de la máscara.

IN_BIT5

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 5 se compa‐
ra con el bit 5 de la máscara.

IN_BIT6

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 6 se compa‐
ra con el bit 6 de la máscara.

IN_BIT7

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 7 se compa‐
ra con el bit 7 de la máscara.

IN_BIT8

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 8 se compa‐
ra con el bit 8 de la máscara.

IN_BIT9

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 9 se compa‐
ra con el bit 9 de la máscara.

IN_BIT10

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 10 se com‐
para con el bit 10 de la más‐
cara.

Programación del PLC
Manual de programación y manejo, 11/2019

1357

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN_BIT11

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 11 se com‐
para con el bit 11 de la más‐
cara.

IN_BIT12

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 12 se com‐
para con el bit 12 de la más‐
cara.

IN_BIT13

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 13 se com‐
para con el bit 13 de la más‐
cara.

IN_BIT14

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 14 se com‐
para con el bit 14 de la más‐
cara.

IN_BIT15

Input

BOOL

I, Q, M, D, L o
constante

El bit de entrada 15 se com‐
para con el bit 15 de la más‐
cara.

OUT

Output

BOOL

I, Q, M, D, L

El estado lógico "1" indica
que se ha encontrado una
coincidencia.
El estado lógico "0" indica
que no se ha encontrado nin‐
guna coincidencia.

1358

ERR_CODE

Output

WORD

I, Q, M, D, L, P

Información de error

OUT_STEP

Output

BYTE

I, Q, M, D, L, P

Contiene el número de paso
con la máscara correspon‐
diente o el número de paso
que excede en "1" el valor del
parámetro LAST, si no se ha
encontrado ninguna corres‐
pondencia.

LAST

Static

BYTE

I, Q, M, D, L, P o
constante

Indica el número del último
paso en que se tiene que
buscar una máscara corres‐
pondiente.

CMP_VAL

Static

ARRAY OF
WORD

I, Q, M, D, L o
constante

Máscaras de comparación [0
a 15, 0 a 15]: El primer núme‐
ro del índice es el número del
paso y, el segundo, el núme‐
ro de bit de la máscara.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

000E

El valor del parámetro LAST es mayor que 15.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de FUP (Página 8005)

LEAD_LAG: Algoritmo Lead y Lag
Descripción
La instrucción "Algoritmo Lead y Lag" procesa señales con una variable analógica. El valor de
la ganancia en el parámetro GAIN debe ser mayor que cero. El resultado de la instrucción
"Algoritmo Lead y Lag" se calcula con la siguiente ecuación:
287

/*B7,0(
/'B7,0(6$03/(B7
/'B7,0(
,1*$,1
35(9B287*$,1
/*B7,0(6$03/(B7
/*B7,0(6$03/(B7
/*B7,0(6$03/(B7

35(9B,1

La instrucción "Algoritmo Lead y Lag" solo devuelve resultados relevantes cuando se ejecuta
en ciclos de programa fijos. Deben indicarse las mismas unidades en los parámetros
LD_TIME, LG_TIME y SAMPLE_T. Si LG_TIME > 4 + SAMPLE_T, la instrucción se aproxima
a la siguiente función:
OUT = GAIN * ((1 + LD_TIME * s) / (1 + LG_TIME * s)) * IN
Si el valor del parámetro GAIN es menor o igual a cero, no se realiza el cálculo y el parámetro
ERR_CODE devuelve una información de error.
La instrucción "Algoritmo Lead y Lag" puede utilizarse junto con bucles para la compensación
en el control anticipativo. La instrucción comprende dos operaciones. La operación "Lead"
desplaza la fase de la salida OUT, anticipándose la salida a la entrada. En cambio, la operación
"Lag" desplaza la salida, de manera que la salida sigue a la entrada. Puesto que la operación
"Lag" equivale a una integración, puede utilizarse para suprimir perturbaciones o como filtro
pasa bajo. La operación "Lead" equivale a una acción diferencial, por lo que puede utilizarse
como un filtro de paso alto. La combinación de ambas operaciones (Lead y Lag) hace que la
fase de salida siga a la entrada a bajas frecuencias y se le anticipe a altas frecuencias. Por este

Programación del PLC
Manual de programación y manejo, 11/2019

1359

Instrucciones
4.1 Instrucciones
motivo, la instrucción "Algoritmo Lead y Lag" puede utilizarse como si fuera un filtro de paso de
banda.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Algoritmo Lead y Lag":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

IN

Input

REAL

I, Q, M, D, L, P o
constante

Valor de entrada del tiempo
de muestreo actual (tiempo
de ciclo) que se procesa.

SAMPLE_T

Input

INT

I, Q, M, D, L, P o
constante

Tiempo de muestreo

OUT

Output

REAL

I, Q, M, D, L, P

Resultado de la instrucción

ERR_CODE

Output

WORD

I, Q, M, D, L, P

Información de error

LD_TIME

Static

REAL

I, Q, M, D, L, P o
constante

Tiempo de anticipación en la
misma unidad que el tiempo
de muestreo.

LG_TIME

Static

REAL

I, Q, M, D, L, P o
constante

Tiempo de seguimiento en la
misma unidad que el tiempo
de muestreo.

GAIN

Static

REAL

I, Q, M, D, L, P o
constante

Ganancia en % / % (relación
del cambio en la salida con
respecto al cambio en la en‐
trada como estado constan‐
te).

PREV_IN

Static

REAL

I, Q, M, D, L, P o
constante

Entrada anterior

PREV_OUT

Static

REAL

I, Q, M, D, L, P o
constante

Salida anterior

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

0009

El valor del parámetro GAIN es menor o igual a cero.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

1360

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.
ಯ/($'B/$*B'%ಯ
/($'B/$*
ಯ7DJ,Qಯ
ಯ7DJB,QSXWಯ
ಯ7DJB,QSXWB6$03/(B7ಯ

287

(1
,1

(55B&2'(

6$03/(B7

(12

ಯ7DJB2XWSXWB5HVXOWಯ
ಯ7DJB(UURU&RGHಯ
ಯ7DJ2XWಯ

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.
Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada:
Parámetro

Operando

Valor

IN

Tag_Input

2.0

SAMPLE_T

Tag_InputSampleTime

10

En el bloque de datos de instancia "LEAD_LAG_DB" de la instrucción se guardan los
siguientes valores:
Parámetro

Dirección

Valor

LD_TIME

DBD12

2.0

LG_TIME

DBD16

2.0

GAIN

DBD20

1.0

PREV_IN

DBD24

6.0

PREV_OUT

DBD28

6.0

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

OUT

Tag_Output_Result

2.0

Programación del PLC
Manual de programación y manejo, 11/2019

1361

Instrucciones
4.1 Instrucciones
Los siguientes valores se guardan en el bloque de datos de instancia LEAD_LAD_DB de la
instrucción:
Parámetro

Operando

Valor

PREV_IN

DBD24

2.0

PREV_OUT

DBD28

2.0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de FUP (Página 8005)

SEG: Generar patrón de bits para el display de 7 segmentos
Descripción
La instrucción "Generar patrón de bits para el display de 7 segmentos" permite convertir cada
una de las cuatro cifras hexadecimales de la palabra de origen indicada (IN) en un patrón de
bits equivalente para un display de 7 segmentos. El resultado de la instrucción se devuelve en
la palabra doble del parámetro OUT.
Entre las cifras hexadecimales y la ocupación de los 7 segmentos (a, b, c, d, e, f, g) existe la
siguiente relación:

1362

Cifra de en‐
trada

Ocupación de los
segmentos

Display

(binaria)

‑gfedcba

0000

00111111

0

0001

00000110

1

0010

01011011

2

0011

01001111

3

0100

01100110

4

0101

01101101

5

0110

01111101

6

0111

00000111

7

1000

01111111

8

1001

01100111

9

1010

01110111

A

1011

01111100

B

1100

00111001

C

1101

01011110

D

1110

01111001

E

1111

01110001

F

Display de siete segmentos

(hexadecimal)
D
I

E
J

H

F
G

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Generar patrón de bits para el
display de 7 segmentos":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

IN

Input

WORD

I, Q, M, D, L, P o
constante

Palabra de origen con cuatro
cifras hexadecimales

OUT

Output

DWORD

I, Q, M, D, L, P

Patrón de bits para el display
de 7 segmentos

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
6(*
ಯ7DJ,Qಯ
ಯ7DJB,QSXWಯ

(1

287

ಯ7DJB2XWSXWಯ

,1

(12

ಯ7DJ2XWಯ

La tabla siguiente muestra el funcionamiento de la instrucción con valores concretos:
Parámetro

Operando

Valor

Hexadecimal

Binario

IN

Tag_Input

W#16#1234

0001 0010 0011 0100

OUT

Tag_Output

DW#16065B4F66

00000110 01011011 01001111
01100110
Visualización: 1234

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Principios básicos de FUP (Página 8005)

Programación del PLC
Manual de programación y manejo, 11/2019

1363

Instrucciones
4.1 Instrucciones

BCDCPL: Generar complemento a diez
Descripción
La instrucción "Generar complemento a diez" crea el complemento a diez de un número BCD
de siete dígitos que se indica en el parámetro IN. La instrucción realiza el cálculo con la
siguiente fórmula matemática:
10000000 (como BCD)
– Valor BCD de 7 dígitos
---------------------------------------Complemento a diez (como BCD)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Generar complemento a diez":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

IN

Input

Secuencias de bits I, Q, M, D, L, P o
constante

Número BCD de 7 dígitos

ERR_CODE

Output

DWORD

Resultado de la instrucción

I, Q, M, D, L, P

Salida de habilitación

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
%&'&3/
ಯ7DJ,Qಯ
ಯ7DJB,QSXWಯ

(1
,1

(55B&2'(
(12

ಯ7DJB2XWSXWಯ
ಯ7DJ2XWಯ

La tabla siguiente muestra el funcionamiento de la instrucción con valores concretos:
Parámetro

Operando

Valor*

IN

Tag_Input

DW#16#01234567

ERR_CODE

Tag_Output

DW#16#08765433

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

1364

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de FUP (Página 8005)

BITSUM: Contar número de bits activados
Descripción
La instrucción "Contar número de bits activados" permite contar el número de bits de un
operando que tienen el estado lógico "1". El operando cuyos bits se cuentan se especifica en
el parámetro IN. El resultado de la instrucción se devuelve en el parámetro RET_VAL.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Contar número de bits activados":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

EN

Input

BOOL

I, Q, M, D, L, T, C o
constante

Entrada de habilitación

ENO

Output

BOOL

I, Q, M, D, L

Salida de habilitación

IN

Input

DWORD

I, Q, M, D, L, P o
constante

Operando cuyos bits activa‐
dos se cuentan.

RET_VAL

Output

INT

I, Q, M, D, L, P

Número de bits activados

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
%,7680
ಯ7DJ,Qಯ
ಯ7DJB,QSXWಯ

(1
,1

5(7B9$/
(12

ಯ7DJB2XWSXWಯ
ಯ7DJ2XWಯ

La tabla siguiente muestra el funcionamiento de la instrucción con valores concretos:
Parámetro

Operando

Valor*

IN

Tag_Input

DW#16#12345678

RET_VAL

Tag_Output

W#16#000D (13 bits)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Programación del PLC
Manual de programación y manejo, 11/2019

1365

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos del mecanismo EN/ENO (Página 152)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de FUP (Página 8005)

4.1.3.3

AWL

Operaciones lógicas con bits
R_TRIG: Detectar flanco de señal ascendente
Descripción
La instrucción "Detectar flanco de señal ascendente" permite detectar un cambio de estado de
"0" a "1" en la entrada CLK. La instrucción compara el valor actual de la entrada CLK con el
estado de la consulta anterior (marca de flanco), que está almacenada en la instancia indicada.
Cuando la instrucción detecta un cambio de estado de "0" a "1" en la entrada CLK, en la salida
Q se genera un flanco de señal ascendente, es decir, que la señal tiene el valor TRUE o "1"
exactamente durante un ciclo.
En todos los demás casos, el estado lógico de la salida de la instrucción es "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Detectar flanco de señal
ascendente":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

CLK

Input

BOOL

I, Q, M, D, L o
constante

Señal entrante cuyo flanco
se consulta.

Q

Output

BOOL

I, Q, M, D, L

Resultado de la evaluación
de flancos

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL R_TRIG, "R_TRIG_DB"

// Se llama la instrucción.

CLK := "TagIn"

// Se detecta un flanco de señal ascendente.

Q := "TagOut"

// Estado lógico "1" con flanco de señal ascendente.

En la variable "R_TRIG_DB" se guarda el estado anterior de la variable en la entrada CLK. Si
en el operando "TagIn" se detecta un cambio del estado lógico de "0" a "1", la salida "TagOut"
devuelve el estado lógico "1" durante un ciclo.

1366

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

F_TRIG: Detectar flanco de señal descendente
Descripción
La instrucción "Detectar flanco de señal descendente" permite detectar un cambio de estado
de "1" a "0" en la entrada CLK. La instrucción compara el valor actual de la entrada CLK con
el estado de la consulta anterior (marca de flanco), que está almacenada en la instancia
indicada. Cuando la instrucción detecta un cambio de estado de "1" a "0" en la entrada CLK,
en la salida Q se genera un flanco de señal descendente, es decir, que la señal tiene el valor
TRUE o "1" exactamente durante un ciclo.
En todos los demás casos, el estado lógico de la salida de la instrucción es "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Detectar flanco de señal
descendente":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

CLK

Input

BOOL

I, Q, M, D, L o
constante

Señal entrante cu‐
yo flanco se con‐
sulta.

Q

Output

BOOL

I, Q, M, D, L

Resultado de la
evaluación de flan‐
cos

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL F_TRIG, "F_TRIG_DB"

// Se llama la instrucción.

CLK := "TagIn"

// Se detecta un flanco de señal descendente.

Q := "TagOut"

// Estado lógico "1" con flanco de señal descendente.

En la variable "F_TRIG_DB" se guarda el estado anterior de la variable en la entrada CLK. Si
en el operando "TagIn" se detecta un cambio del estado lógico de "1" a "0", la salida "TagOut"
devuelve el estado lógico "1" durante un ciclo.

Programación del PLC
Manual de programación y manejo, 11/2019

1367

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Temporizadores
TP: Impulso
Descripción
La instrucción "Impulso" activa la salida Q por un tiempo programado. La instrucción se inicia
cuando el resultado lógico (RLO) del parámetro IN cambia de "0" a "1" (flanco de señal
ascendente). Cuando se inicia la instrucción, se empieza a contar el tiempo programado PT.
El parámetro Q se activa por el tiempo PT, independientemente de cómo evolucione la señal
de entrada. Durante el tiempo PT, la detección de un nuevo flanco de señal ascendente en la
entrada IN no influye en el estado lógico de la salida Q.
El valor de tiempo actual se puede consultar en la salida ET. Este valor de tiempo empieza a
partir de T#0s y termina al alcanzarse el valor del tiempo PT. Una vez alcanzado este tiempo
PT y si el estado lógico de la entrada IN es "0", se desactiva la salida ET. Si en el programa no
se llama la instrucción porque, p. ej., esta se omite, la salida ET devuelve un valor constante
en cuanto transcurre este tiempo.
El sistema operativo inicializa las instancias de la instrucción "Impulso" cuando se efectúa un
arranque en frío. Si alguna instancia de la instrucción debe estar inicializada tras un rearranque
completo (en caliente), las instancias que se deben inicializar se deben llamar en un OB de
arranque con el valor "0" en el parámetro PT. Si un bloque diferente contiene instancias de la
instrucción "Impulso", estas pueden inicializarse p. ej. inicializando el bloque de nivel superior.
En el código del programa, la instrucción "Impulso" se debe llamar con la instrucción "Llamar
bloque" (CALL).
Tras seleccionar el tipo de datos en la lista desplegable "???", el cuadro de diálogo "Opciones
de llamada" se abre automáticamente.
A cada llamada de la instrucción "Impulso" debe asignársele un temporizador CEI, en el que
se guarden los datos de instancia. El temporizador CEI es una estructura del tipo de datos
IEC_TIMER, IEC_LTIMER, TP_TIME o TP_LTIME que se puede declarar como se indica a
continuación:
● Declaración de un bloque de datos del tipo de datos de sistema IEC_TIMER o IEC_LTIMER
(p. ej., "MyIEC_TIMER")
● Declaración como variable local del tipo TP_TIME o TP_LTIME en la sección "Static" de un
bloque (p. ej., #MyTP_TIMER)

1368

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Actualización de los valores actuales en los datos de instancia
Los datos de instancia de "Impulso" se actualizan siguiendo las reglas indicadas a
continuación:
● Entrada IN
La instrucción "Impulso" compara el RLO actual con el RLO de la consulta anterior, que está
almacenado en el parámetro IN de los datos de instancia. Si la instrucción detecta un
cambio del RLO de "0" a "1", significa que hay un flanco de señal ascendente y se empieza
a medir el tiempo. Una vez procesada la instrucción "Impulso", el valor del parámetro IN se
actualiza en los datos de instancia y se utiliza como marca de flancos para la siguiente
consulta.
Tenga en cuenta que la evaluación de flancos falla cuando el valor actual del parámetro IN
es escrito o inicializado por otras funciones.
● Entrada PT
El valor de la entrada PT se escribe en el parámetro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
● Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
– Al llamar la instrucción, si las salidas ET o Q están interconectadas.
O bien:
– Al acceder a Q o ET.
Si las salidas no están interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucción se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan parámetros internos de la
instrucción "Impulso". Tenga en cuenta que la medición de tiempo falla cuando los valores
actuales de la instrucción son escritos o inicializados por otras funciones.

Programación del PLC
Manual de programación y manejo, 11/2019

1369

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está midiendo el
tiempo, se interfiere en la función del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse daños materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Impulso":

1370

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de arranque

PT

Input

TIME, LTIME

I, Q, M, D, L, P o
constante

Duración del impulso.
El valor del parámetro PT de‐
be ser positivo.

Q

Output

BOOL

I, Q, M, D, L, P

Salida de impulso

ET

Output

TIME, LTIME

I, Q, M, D, L, P

Valor de tiempo actual

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el comportamiento de la instrucción "Impulso" tras el arranque:
,1

4

37

37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL TP, "TP_DB"

// Se llama la instrucción. El bloque de datos "TP_DB"
se asigna a la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := "Tag_Start"

// Cuando se produce un flanco de señal ascendente en
el operando, se ejecuta la instrucción.

PT := "Tag_PresetTIME"

// Duración del impulso

Q := "Tag_Output"

// El operando se activa durante el periodo determinado por el operando "Tag_PresetTIME".

ET := "Tag_ElapsedTIME"

// Valor de tiempo actual

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Programación del PLC
Manual de programación y manejo, 11/2019

1371

Instrucciones
4.1 Instrucciones

TON: Retardo al conectar
Descripción
La instrucción "Retardo al conectar" retarda la activación de la salida Q por el tiempo
programado PT. La instrucción se inicia cuando el resultado lógico (RLO) del parámetro IN
cambia de "0" a "1" (flanco de señal ascendente). Cuando se inicia la instrucción, se empieza
a contar el tiempo programado PT. Una vez transcurrido el tiempo PT, el parámetro Q devuelve
el estado lógico "1". El parámetro Q permanecerá activado mientras la entrada de arranque IN
esté puesta a "1". Cuando el estado lógico de la entrada de arranque cambia de "1" a "0", se
desactiva el parámetro Q. La función de temporización se reinicia al detectarse un nuevo
flanco de señal ascendente en la entrada de arranque.
El valor de tiempo actual se puede consultar en la salida ET. Este valor de tiempo empieza a
partir de T#0s y termina al alcanzarse el valor del tiempo PT. El parámetro ET se inicializa en
cuanto el estado lógico de la entrada IN cambia a "0". Si en el programa no se llama la
instrucción porque, p. ej., esta se omite, la salida ET devuelve un valor constante en cuanto ha
transcurrido el tiempo PT.
En la lógica del programa, la instrucción "Retardo al conectar" se debe llamar con la instrucción
"Llamar bloque" (CALL).
Tras seleccionar el tipo de datos en la lista desplegable "???", el cuadro de diálogo "Opciones
de llamada" se abre automáticamente.
A cada llamada de la instrucción "Retardo al conectar" debe asignársele un temporizador CEI,
en el que se guarden los datos de instancia. El temporizador CEI es una estructura del tipo de
datos IEC_TIMER, IEC_LTIMER, TON_TIME o TON_LTIME que se puede declarar como se
indica a continuación:
● Declaración de un bloque de datos del tipo de datos de sistema IEC_TIMER o IEC_LTIMER
(p. ej., "MyIEC_TIMER")
● Declaración como variable local del tipo TON_TIME o TON_LTIME en la sección "Static" de
un bloque (p. ej., #MyTON_TIMER)

1372

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Actualización de los valores actuales en los datos de instancia
Los datos de instancia de "Retardo al conectar" se actualizan siguiendo las reglas indicadas a
continuación:
● Entrada IN
La instrucción "Retardo al conectar" compara el RLO actual con el RLO de la consulta
anterior, que está almacenado en el parámetro IN de los datos de instancia. Si la instrucción
detecta un cambio del RLO de "0" a "1", significa que hay un flanco de señal ascendente y
se empieza a medir el tiempo. Una vez procesada la instrucción "Retardo al conectar", el
valor del parámetro IN se actualiza en los datos de instancia y se utiliza como marca de
flancos para la siguiente consulta.
Tenga en cuenta que la evaluación de flancos falla cuando el valor actual del parámetro IN
es escrito o inicializado por otras funciones.
● Entrada PT
El valor de la entrada PT se escribe en el parámetro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
● Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
– Al llamar la instrucción, si las salidas ET o Q están interconectadas.
O bien:
– Al acceder a Q o ET.
Si las salidas no están interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucción se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan parámetros internos de la
instrucción "Retardo al conectar". Tenga en cuenta que la medición de tiempo falla cuando
los valores actuales de la instrucción son escritos o inicializados por otras funciones.

Programación del PLC
Manual de programación y manejo, 11/2019

1373

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está midiendo el
tiempo, se interfiere en la función del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse daños materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Retardo al conectar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de arranque

PT

Input

TIME, LTIME

I, Q, M, D, L, P o
constante

Tiempo del retardo al conec‐
tar
El valor del parámetro PT de‐
be ser positivo.

1374

Q

Output

BOOL

I, Q, M, D, L, P

Estado lógico que se retarda
por el tiempo PT.

ET

Output

TIME, LTIME

I, Q, M, D, L, P

Valor de tiempo actual

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el comportamiento de la instrucción "Retardo al conectar" tras el
arranque:
,1

4

37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL "TON", "TON_DB"

// Se llama la instrucción. El bloque de datos
"TON_DB" se asigna a la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := "Tag_Start"

// Cuando se produce un flanco de señal ascendente en
el operando, se ejecuta la instrucción.

PT := "Tag_PresetTIME"

// Indica el tiempo en el que se retarda el flanco de
señal ascendente en el parámetro IN.

Q := "Tag_Output"

// El operando se activa una vez transcurrido el tiempo PT especificado por la variable "Tag_PresetTIME".
// El parámetro Q permanecerá activado mientras la variable "Tag_Start" siga a "1".
// Cuando el estado lógico de la entrada de arranque
cambie de "1" a "0", se desactivará el operando en el
parámetro Q.

ET := "Tag_ElapsedTIME"

// Valor de tiempo actual

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)

Programación del PLC
Manual de programación y manejo, 11/2019

1375

Instrucciones
4.1 Instrucciones
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

TOF: Retardo al desconectar
Descripción
La instrucción "Retardo al desconectar" retarda la desactivación de la salida Q por el tiempo
programado PT. El parámetro Q se activa cuando el resultado lógico (RLO) del parámetro IN
cambia de "1" a "0" (flanco de señal descendente). Cuando el estado lógico del parámetro IN
cambia nuevamente a "1", el tiempo programado PT deja de contar. El parámetro Q
permanecerá activado mientras transcurra el tiempo PT. Una vez transcurrido el tiempo PT se
inicializa el parámetro Q. Si el estado lógico del parámetro IN cambia a "1" antes de que
transcurra el tiempo PT, se inicializa el temporizador. El estado lógico del parámetro Q
permanece a "1".
El valor de tiempo actual se puede consultar en el parámetro ET. Este valor de tiempo empieza
a partir de T#0s y termina al alcanzarse el valor del tiempo PT. Una vez transcurrido el tiempo
PT, el parámetro ET permanece al valor actual hasta que el parámetro IN vuelva a cambiar a
"1". Si el estado lógico de la entrada IN cambia a "1" antes de transcurrir el tiempo PT, la salida
ET adopta el valor T#0s. Si en el programa no se llama la instrucción porque, p. ej., esta se
omite, la salida ET devuelve un valor constante en cuanto transcurre este tiempo.
En la lógica del programa, la instrucción "Retardo al desconectar" se debe llamar con la
instrucción "Llamar bloque" (CALL).
Tras seleccionar el tipo de datos en la lista desplegable "???", el cuadro de diálogo "Opciones
de llamada" se abre automáticamente.
A cada llamada de la instrucción "Retardo al desconectar" debe asignársele un temporizador
CEI, en el que se guarden los datos de instancia. El temporizador CEI es una estructura del tipo
de datos IEC_TIMER, IEC_LTIMER, TOF_TIME o TOF_LTIME que se puede declarar como se
indica a continuación:
● Declaración de un bloque de datos del tipo de datos de sistema IEC_TIMER o IEC_LTIMER
(p. ej., "MyIEC_TIMER")
● Declaración como variable local del tipo TOF_TIME o TOF_LTIME en la sección "Static" de
un bloque (p. ej., #MyTOF_TIMER)
El sistema operativo inicializa las instancias de la instrucción "Retardo al desconectar" cuando
se realiza un arranque en frío. Si alguna instancia de la instrucción debe estar inicializada tras
un rearranque completo (en caliente), las instancias que se deben inicializar se deben llamar
en un OB de arranque con el valor "0" en el parámetro PT. Si un bloque diferente contiene
instancias de la instrucción "Retardo al desconectar", estas pueden inicializarse p. ej.
inicializando el bloque de nivel superior.

1376

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Actualización de los valores actuales en los datos de instancia
Los datos de instancia de "Retardo al desconectar" se actualizan siguiendo las reglas
indicadas a continuación:
● Entrada IN
La instrucción "Arrancar temporizador como retardo a la desconexión" compara el RLO
actual con el RLO de la consulta anterior, que está almacenado en el parámetro "IN" de los
datos de instancia. Si la instrucción detecta un cambio del RLO de "1" a "0", significa que
hay un flanco de señal descendente y se empieza a contar el tiempo. Una vez procesada
la instrucción "Arrancar temporizador como retardo a la desconexión", el valor del
parámetro IN se actualiza en los datos de instancia y se utiliza como marca de flancos para
la siguiente consulta.
Tenga en cuenta que la evaluación de flancos falla cuando el valor actual del parámetro "IN"
es escrito o inicializado por otras funciones.
● Entrada PT
El valor de la entrada PT se escribe en el parámetro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
● Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
– Al llamar la instrucción, si las salidas ET o Q están interconectadas.
O bien:
– Al acceder a Q o ET.
Si las salidas no están interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucción se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan parámetros internos de la
instrucción "Arrancar temporizador como retardo a la desconexión". Tenga en cuenta que
la medición de tiempo falla cuando los valores actuales de la instrucción son escritos o
inicializados por otras funciones.

Programación del PLC
Manual de programación y manejo, 11/2019

1377

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está midiendo el
tiempo, se interfiere en la función del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse daños materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Retardo al desconectar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de arranque

PT

Input

TIME, LTIME

I, Q, M, D, L, P o
constante

Tiempo del retardo al desco‐
nectar
El valor del parámetro PT de‐
be ser positivo.

1378

Q

Output

BOOL

I, Q, M, D, L, P

Estado lógico que se retarda
por el tiempo PT.

ET

Output

TIME, LTIME

I, Q, M, D, L, P

Valor de tiempo actual

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el comportamiento de la instrucción "Retardo al desconectar" tras
el arranque:
,1

4
37

37

(7
37

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL TOF, "TOF_DB"

// Se llama la instrucción. El bloque de datos
"TOF_DB" se asigna a la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := "Tag_Start"

// Cuando se produce un flanco de señal ascendente en
el operando, se ejecuta la instrucción.

PT := "Tag_PresetTIME"

// Indica el tiempo en el que se retarda el flanco de
señal descendente en el parámetro IN.

Q := "Tag_Output"

// El operando se activa cuando la instrucción se inicia debido a un flanco de señal ascendente en el parámetro IN.
// Si el estado lógico del parámetro IN cambia de "1"
a "0", el operando "Tag_Output" permanecerá activado
mientras transcurra el tiempo predeterminado por la
variable "Tag_PresetTIME".
// Una vez transcurrido el tiempo del parámetro PT, se
desactiva el operando.

ET := "Tag_ElapsedTIME"

Programación del PLC
Manual de programación y manejo, 11/2019

// Valor de tiempo actual

1379

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

TONR: Acumulador de tiempo
Descripción
La instrucción "Acumulador de tiempo" acumula valores de tiempo dentro de un periodo
definido por el parámetro PT. Cuando el estado lógico de la entrada IN cambia de "0" a "1"
(flanco de señal ascendente), se mide el tiempo y se empieza a contar el tiempo PT. Mientras
transcurre el tiempo PT se van acumulando los valores de tiempo que se leen cuando el estado
lógico de la entrada IN es "1". El tiempo acumulado se deposita en la salida ET y se puede
consultar allí. Una vez se ha alcanzado el tiempo PT, la salida Q devuelve el estado lógico "1".
El parámetro Q permanece a "1" aunque el estado lógico del parámetro IN cambie de "1" a "0"
(flanco de señal descendente).
La entrada R desactiva las salidas ET y Q independientemente del estado lógico de la entrada
de arranque.
La instrucción "Acumulador de tiempo" se puede colocar dentro o al final del segmento. Dicha
instrucción requiere una operación lógica precedente.
En la lógica del programa, la instrucción "Acumulador de tiempo" se debe llamar con la
instrucción "Llamar bloque" (CALL).
A cada llamada de la instrucción "Acumulador de tiempo" debe asignársele un temporizador
CEI, en el que se guarden los datos de instancia. El temporizador CEI es una estructura del tipo
de datos IEC_TIMER, IEC_LTIMER, TONR_TIME o TONR_LTIME que se puede declarar
como se indica a continuación:
● Declaración de un bloque de datos del tipo de datos de sistema IEC_TIMER o IEC_LTIMER
(p. ej., "MyIEC_TIMER")
● Declaración como variable local del tipo TONR_TIME o TONR_LTIME en la sección "Static"
de un bloque (p. ej., #MyTONR_TIMER)
Tras seleccionar el tipo de datos en la lista desplegable "???", el cuadro de diálogo "Opciones
de llamada" se abre automáticamente.

1380

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Actualización de los valores actuales en los datos de instancia
Los datos de instancia de "Acumulador de tiempo" se actualizan siguiendo las reglas indicadas
a continuación:
● Entrada IN
La instrucción "Acumulador de tiempo" compara el RLO actual con el RLO de la consulta
anterior, que está almacenado en el parámetro "IN" de los datos de instancia. Si la
instrucción detecta un cambio del RLO de "0" a "1", significa que hay un flanco de señal
ascendente y se reanuda la medición de tiempo. Si la instrucción detecta un cambio de "1"
a "0" en el RLO, significa que hay un flanco de señal descendente y la medición de tiempo
se interrumpe. Una vez procesada la instrucción "Acumulador de tiempo", el valor del
parámetro IN se actualiza en los datos de instancia y se utiliza como marca de flancos para
la siguiente consulta.
Tenga en cuenta que la evaluación de flancos falla cuando el valor actual del parámetro IN
es escrito o inicializado por otras funciones.
● Entrada PT
El valor de la entrada PT se escribe en el parámetro PT de los datos de instancia cuando
se produce un cambio de flanco en la entrada IN.
● Entrada R
La señal "1" en la entrada R inicializa la medición de tiempo y la bloquea. Los flancos en la
entrada IN se ignoran. La señal "0" en la entrada R habilita de nuevo la medición de tiempo.
● Salidas Q y ET
Los valores actuales de las salidas Q y ET se actualizan en los casos siguientes:
– Al llamar la instrucción, si las salidas ET o Q están interconectadas.
O bien:
– Al acceder a Q o ET.
Si las salidas no están interconectadas y tampoco se consultan, el valor de tiempo actual
de las salidas Q y ET no se actualiza. Las salidas tampoco se actualizan aunque la
instrucción se omita en el programa.
Para calcular los valores de tiempo de Q y ET se utilizan parámetros internos de la
instrucción "Acumulador de tiempo". Tenga en cuenta que la medición de tiempo falla
cuando los valores actuales de la instrucción son escritos o inicializados por otras
funciones.

Programación del PLC
Manual de programación y manejo, 11/2019

1381

Instrucciones
4.1 Instrucciones

PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está midiendo el
tiempo, se interfiere en la función del temporizador CEI. Esto puede provocar incoherencias
entre el programa y el proceso real. Como consecuencia pueden producirse daños materiales
y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Acumulador de tiempo":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de arranque

R

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de reset

PT

Input

TIME, LTIME

I, Q, M, D, L, P o
constante

Tiempo máximo de lectura
del tiempo
El valor del parámetro PT de‐
be ser positivo.

1382

Q

Output

BOOL

I, Q, M, D, L, P

Salida que se activa una vez
transcurrido el tiempo PT.

ET

Output

TIME, LTIME

I, Q, M, D, L, P

Tiempo acumulado

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Cronograma de impulsos
La figura siguiente muestra el cronograma de impulsos de la instrucción "Acumulador de
tiempo":
,1

5

4

37

(7

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL TONR, "TONR_DB"

// Se llama la instrucción. El bloque de datos
"TONR_DB" se asigna a la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := "Tag_Start"

// Cuando se produce un flanco de señal ascendente en
el operando, se ejecuta la instrucción y se inicia el
tiempo de la entrada PT.
Mientras transcurre el tiempo PT se van acumulando los
valores de tiempo que se leen cuando el estado lógico
de la entrada IN es "1".

R := "Tag_Reset"

// La entrada R desactiva las salidas ET y Q independientemente del estado lógico de la entrada de arranque.

PT := "Tag_PresetTIME"

// Indica el tiempo durante el cual se acumularán los
valores de tiempo.

Programación del PLC
Manual de programación y manejo, 11/2019

1383

Instrucciones
4.1 Instrucciones
AWL

Explicación

Q := "Tag_Output"

// El operando se activa cuando se alcanza el tiempo
PT.
// El parámetro Q permanece a "1" aunque el estado lógico del parámetro IN cambie de "1" a "0" (flanco de
señal descendente).

ET := "Tag_ElapsedTIME"

// El tiempo acumulado se devuelve en la salida ET y
se puede consultar allí.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

RESET_TIMER: Inicializar temporizador
Descripción
La instrucción "Inicializar temporizador" permite poner a "0" un temporizador CEI. Los
componentes de estructura del temporizador en el bloque de datos indicado se ponen a "0".
La instrucción no afecta al RLO. En el parámetro TIMER se asigna a la instrucción "Inicializar
temporizador" un temporizador CEI declarado en el programa.

1384

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Actualización de los valores actuales
Los datos de la instrucción se actualizan únicamente al efectuar una llamada de la instrucción,
y no cada vez que se accede al temporizador CEI asignado. La consulta de datos es igual a la
llamada de instrucción únicamente hasta la siguiente llamada de instrucción.
PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está ejecutando
el temporizador, se interfiere en la función del temporizador CEI. Esto puede provocar
incoherencias entre el programa y el proceso real. Como consecuencia pueden producirse
daños materiales y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Inicializar temporizador":
Parámetro

Declaración

TIMER

Output

Tipo de datos

Área de memoria

IEC_TIMER,
D, L
IEC_LTIMER,
TP_TIME, TP_LTI‐
ME, TON_TIME,
TON_LTIME,
TOF_TIME,
TOF_LTIME,
TONR_TIME,
TONR_LTIME

Descripción
Temporizador CEI que se ini‐
cializa

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

1385

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL TON, "TON_DB"

// Se llama la instrucción. El bloque de datos de instancia "TON_DB" se asigna a la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := "Tag_Start"

// Cuando se produce un flanco de señal ascendente en
el operando "Tag_Start", se ejecuta la instrucción.

PT := "Tag_PresetTIME"

// El temporizador CEI depositado en el bloque de datos de instancia "TON_DB" arranca con el tiempo especificado por el operando "Tag_PresetTIME".

Q := "Tag_Output"

// El operando "Tag_Output" se activa una vez transcurrido el tiempo PT especificado por el operando
"Tag_PresetTIME".
// El parámetro Q permanecerá activado mientras el
operando "Tag_Start" tenga el estado lógico "1".
// Cuando el estado lógico de la entrada de arranque
cambie de "1" a "0", se desactivará el operando en el
parámetro Q.

ET := "Tag_ElapsedTIME"

// Valor de tiempo actual

A "Tag_Input_1"

// Cuando el operando "Tag_Input_1" y

A "Tag_Input_2"

// el operando "Tag_Input_2" devuelven el estado lógico "1",

CALL RESET_TIMER

// se llama la instrucción "Inicializar temporizador".
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

TIMER := "TON_DB"

// El temporizador CEI se inicializa

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

1386

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

PRESET_TIMER: Cargar tiempo
Descripción
La instrucción "Cargar tiempo" permite ajustar el tiempo de un temporizador CEI. La
instrucción se ejecuta en cada ciclo. La instrucción escribe el tiempo indicado en la estructura
del temporizador CEI indicado.
A la instrucción "Cargar tiempo" debe asignársele un temporizador CEI declarado en el
programa.
Nota
Si el temporizador CEI indicado se ejecuta mientras se ejecuta la instrucción, esta sobrescribe
el tiempo actual del temporizador CEI indicado. Esto puede modificar el estado del
temporizador CEI.

Actualización de los valores actuales
La actualización de los datos de la instrucción se lleva a cabo cuando se llama la instrucción
y cada vez que se accede al temporizador CEI asignado. La consulta de Q o ET (p. ej.
"MyTimer".Q y "MyTimer".ET) actualiza la estructura de IEC_TIMER.
PELIGRO
Peligro al reinicializar los valores actuales
Si se reinicializan los valores actuales de un temporizador CEI mientras se está ejecutando
el temporizador, se interfiere en la función del temporizador CEI. Esto puede provocar
incoherencias entre el programa y el proceso real. Como consecuencia pueden producirse
daños materiales y personales graves.
Las funciones siguientes pueden provocar la reinicialización de los valores actuales:
● Cargar el bloque con reinicialización
● Cargar instantáneas como valores actuales
● Forzar valores actuales de forma normal o permanente
● La instrucción "WRIT_DBL"
Antes de ejecutar estas funciones, tome las medidas siguientes:
● Asegúrese de que la instalación se encuentra en un estado seguro antes de sobrescribir
los valores actuales.
● Asegúrese de que el temporizador CEI ha finalizado antes de inicializar los valores
actuales.
● Si los valores actuales se sobrescriben con una instantánea, asegúrese de que la
instantánea se haya generado en un instante en que la instalación estaba en un estado
seguro.
● Asegúrese de que el programa no está leyendo ni escribiendo los datos afectados durante
la transferencia.

Programación del PLC
Manual de programación y manejo, 11/2019

1387

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Cargar tiempo":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Tiempo>

Input

TIME, LTIME

I, Q, M, D, L o
constante

Tiempo que cuenta el tempo‐
rizador CEI

<Temporiza‐
dor CEI>

Output

IEC_TIMER,
D, L
IEC_LTIMER,
TP_TIME, TP_LTI‐
ME, TON_TIME,
TON_LTIME,
TOF_TIME,
TOF_LTIME,
TONR_TIME,
TONR_LTIME

Temporizador CEI cuyo tiem‐
po se ajusta

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL TON, "TON_DB"

// Se llama la instrucción. El bloque de datos de instancia "TON_DB" se asigna a la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := "Tag_Start"

// Cuando se produce un flanco de señal ascendente en
el operando "Tag_Start", se ejecuta la instrucción.

PT := "Tag_PresetTIME"

// El temporizador CEI depositado en el bloque de datos de instancia "TON_DB" arranca con el tiempo especificado por el operando "Tag_PresetTIME".

Q := "Tag_Output"

// El operando "Tag_Output" se activa una vez transcurrido el tiempo PT especificado por el operando
"Tag_PresetTIME".
// El parámetro Q permanecerá activado mientras el
operando "Tag_Start" tenga el estado lógico "1".
// Cuando el estado lógico de la entrada de arranque
cambie de "1" a "0", se desactivará el operando en el
parámetro Q.

ET := "Tag_ElapsedTIME"

// Valor de tiempo actual

A "Tag_Input_1"

// Cuando el operando "Tag_Input_1" y

A "Tag_Input_2"

// el operando "Tag_Input_2" devuelven el estado lógico "1",

CALL PRESET_TIMER

// se llama la instrucción "Cargar tiempo".
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

1388

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

PT := "Tag_PresetTIME_new"

// La instrucción escribe el tiempo "Tag_PresetTIME_new" en el bloque de datos de instancia "TON_DB" y
sobrescribe a la vez el valor de tiempo del operando
"Tag_PresetTIME" en el bloque de datos de instancia.
Esto puede modificar el estado lógico del estado del
temporizador en la siguiente consulta o al acceder a
"MyTimer".Q o "MyTimer".ET.

TIMER := "TON_DB"

// El temporizador CEI se inicializa

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Contadores
CTU: Contador ascendente
Descripción
La instrucción "Contador ascendente" incrementa el valor del parámetro CV. Cuando el estado
lógico del parámetro CU cambia de "0" a "1" (flanco de señal ascendente), se ejecuta la
instrucción y el valor de contaje actual del parámetro CV se incrementa en uno. El valor de
contaje se incrementa cada vez que se detecta un flanco de señal ascendente, hasta alcanzar
el valor límite superior del tipo de datos indicado en la salida CV. Cuando se alcanza el valor
límite superior, el estado lógico del parámetro CU deja de tener efecto en la instrucción.
El estado del contador se puede consultar en el parámetro Q. El estado lógico del parámetro
Q es determinado por el parámetro PV. Si el valor de contaje actual es mayor o igual al valor
del parámetro PV, el parámetro Q adopta el estado lógico "1". En los restantes casos, el estado
lógico del parámetro Q es "0".
El valor del parámetro CV se pone a cero cuando el estado lógico del parámetro R cambia a
"1". Mientras el parámetro R tenga el estado lógico "1", el estado lógico del parámetro CU no
tendrá efecto alguno en la instrucción.
En la lógica del programa, la instrucción "Contador ascendente" se debe llamar con la
instrucción "Llamar bloque" (CALL).
Nota
Utilice el contador en una sola posición del programa para evitar fallos de contaje.

Programación del PLC
Manual de programación y manejo, 11/2019

1389

Instrucciones
4.1 Instrucciones
A cada llamada de la instrucción "Contador ascendente" debe asignársele un contador CEI, en
el que se guarden los datos de la instrucción. Un contador CEI es una estructura con uno de
los tipos de datos siguientes:
El sistema operativo inicializa las instancias de la instrucción "Contador ascendente" cuando
se realiza un arranque en frío. Si deben inicializarse instancias de la instrucción tras un
rearranque completo (en caliente), las instancias por inicializar deben llamarse en un OB de
arranque con el valor "1" en el parámetro R de la instrucción. Si un bloque diferente contiene
instancias de la instrucción "Contador ascendente", estas pueden resetearse p. ej.
inicializando el bloque de nivel superior.

Bloque de datos de instancia del tipo de datos de sistema IEC_<Contador> (Shared DB/Instancia
individual)
El tipo de datos de sistema del bloque de datos de instancia se deriva del tipo de datos de la
instrucción:
Tipo de datos de la instrucción

Tipo de datos de sistema del bloque de datos de
instancia (Shared DB)

SINT / USINT

IEC_SCOUNTER / IEC_USCOUNTER

INT / UINT

IEC_COUNTER / IEC_UCOUNTER

DINT / UDINT

IEC_DCOUNTER / IEC_UDCOUNTER

LINT / ULINT

IEC_LCOUNTER / IEC_ULCOUNTER

Si el contador CEI se crea como instancia individual, el bloque de datos de instancia se crea
de forma estándar con "acceso optimizado al bloque" y las distintas variables se declaran
remanentes.
Encontrará más información sobre la configuración de la remanencia en un bloque de datos de
instancia en "Consulte también".

Variable local (multiinstancia)
El tipo de datos de la variable local se deriva del tipo de datos de la instrucción:
Tipo de datos de la instrucción

Tipo de datos de la variable local

SINT / USINT

CTU_SINT / CTU_USINT / IEC_SCOUNTER /
IEC_USCOUNTER

INT / UINT

CTU_INT / CTU_UINT / IEC_COUNTER /
IEC_UCOUNTER

DINT / UDINT

CTU_DINT / CTU_UDINT / IEC_DCOUNTER /
IEC_UDCOUNTER

LINT / ULINT

CTU_LINT / CTU_ULINT / IEC_LCOUNTER /
IEC_ULCOUNTER

Si el contador CEI se crea como multiinstancia en un bloque de función con "acceso
optimizado al bloque", esta se declara remanente en la interfaz del bloque.

1390

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Declarar contador CEI
Tras seleccionar el tipo de datos en la lista desplegable "???", el cuadro de diálogo "Opciones
de llamada" se abre automáticamente. A continuación, puede declarar el contador CEI del
siguiente modo:
● Instancia individual: Declaración de un bloque de datos de instancia del tipo de datos de
sistema IEC_<nombre_del_contador> (p. ej., "MyIEC_COUNTER")
● Multiinstancia: Declaración como variable local del tipo CTU_<tipo de datos> o
IEC_<contador> en la sección "Static" de un bloque (p. ej., #MyCTU_COUNTER)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Contador ascendente":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

CU

Input

BOOL

I, Q, M, D, L o
constante

Entrada de contaje

R

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de reset

PV

Input

Enteros

I, Q, M, D, L, P o
constante

Valor con el que se activa la
salida Q.

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL CTU, "CTU_DB"

// Se llama la instrucción. El bloque de datos
"CTU_DB" se asigna a la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

CU := "Tag_StartCTU"

// Cuando el estado lógico del operando "Tag_StartCTU"
cambia de "0" a "1", se ejecuta la instrucción y el
valor actual del operando "Tag_CounterValue" se incrementa en uno.
// El valor de contaje sigue incrementando hasta alcanzar el valor límite superior de INT = 32767.

R := "Tag_ResetCounter"

// Cuando el estado lógico del operando "Tag_ResetCounter" cambia a "1", el operando "Tag_CounterValue"
se pone a "0".

PV := "Tag_PresetValue"

// El operando determina a partir de qué valor debe
activarse el operando del parámetro Q.

Q := "Tag_CounterStatus"

// El operando permanece activado mientras el valor de
contaje actual sea mayor o igual al valor del parámetro PV.

CV := "Tag_CounterValue"

// Valor de contaje actual

Programación del PLC
Manual de programación y manejo, 11/2019

1391

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Ajustar la remanencia en un bloque de datos de instancia (Página 7855)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

CTD: Contador descendente
Descripción
La instrucción "Contador descendente" decrementa el valor del parámetro CV. Cuando el
estado lógico del parámetro CD cambia de "0" a "1" (flanco de señal ascendente), se ejecuta
la instrucción y el valor de contaje actual del parámetro CV se decrementa en uno. Cada vez
que se detecta un flanco de señal ascendente, el valor de contaje se decrementa hasta
alcanzar el valor límite inferior del tipo de datos indicado. Cuando se alcanza el valor límite
inferior, el estado lógico del parámetro CD deja de tener efecto en la instrucción.
El estado del contador se puede consultar en el parámetro Q. Si el valor de contaje actual es
menor o igual a cero, el parámetro Q adopta el estado lógico "1". En los restantes casos, el
estado lógico del parámetro Q es "0".
El valor del parámetro CV se pone al valor del parámetro PV cuando el estado lógico del
parámetro LD cambia a "1". Mientras el parámetro LD tenga el estado lógico "1", el estado
lógico del parámetro CD no tendrá efecto alguno en la instrucción.
En la lógica del programa, la instrucción "Contador descendente" se debe llamar con la
instrucción "Llamar bloque" (CALL).
Nota
Utilice el contador en una sola posición del programa para evitar fallos de contaje.
A cada llamada de la instrucción "Contador descendente" debe asignársele un contador CEI,
en el que se guarden los datos de la instrucción. Un contador CEI es una estructura con uno
de los tipos de datos siguientes:
El sistema operativo inicializa las instancias de la instrucción "Contador descendente" cuando
se realiza un arranque en frío. Si deben inicializarse instancias de la instrucción tras un
rearranque completo (en caliente), las instancias por inicializar deben llamarse en un OB de
arranque con el valor "1" en el parámetro LD de la instrucción. En el parámetro PV se indica en
este caso el valor inicial deseado para el parámetro CV. Si un bloque diferente contiene
instancias de la instrucción "Contador descendente", estas pueden resetearse p. ej.
inicializando el bloque de nivel superior.

1392

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Bloque de datos de instancia del tipo de datos de sistema IEC_<Contador> (Shared DB/Instancia
individual)
El tipo de datos de sistema del bloque de datos de instancia se deriva del tipo de datos de la
instrucción:
Tipo de datos de la instrucción

Tipo de datos de sistema del bloque de datos de
instancia (Shared DB)

SINT / USINT

IEC_SCOUNTER / IEC_USCOUNTER

INT / UINT

IEC_COUNTER / IEC_UCOUNTER

DINT / UDINT

IEC_DCOUNTER / IEC_UDCOUNTER

LINT / ULINT

IEC_LCOUNTER / IEC_ULCOUNTER

Si el contador CEI se crea como instancia individual, el bloque de datos de instancia se crea
de forma estándar con "acceso optimizado al bloque" y las distintas variables se declaran
remanentes.
Encontrará más información sobre la configuración de la remanencia en un bloque de datos de
instancia en "Consulte también".

Variable local (multiinstancia)
El tipo de datos de la variable local se deriva del tipo de datos de la instrucción:
Tipo de datos de la instrucción

Tipo de datos de la variable local

SINT / USINT

CTD_SINT / CTD_USINT / IEC_SCOUNTER /
IEC_USCOUNTER

INT / UINT

CTD_INT / CTD_UINT / IEC_COUNTER /
IEC_UCOUNTER

DINT / UDINT

CTD_DINT / CTD_UDINT / IEC_DCOUNTER /
IEC_UDCOUNTER

LINT / ULINT

CTD_LINT / CTD_ULINT / IEC_LCOUNTER /
IEC_ULCOUNTER

Si el contador CEI se crea como multiinstancia en un bloque de función con "acceso
optimizado al bloque", esta se declara remanente en la interfaz del bloque.

Declarar contador CEI
Tras seleccionar el tipo de datos en la lista desplegable "???", el cuadro de diálogo "Opciones
de llamada" se abre automáticamente. A continuación, puede declarar el contador CEI del
siguiente modo:
● Instancia individual: Declaración de un bloque de datos de instancia del tipo de datos de
sistema IEC_<nombre_del_contador> (p. ej., "MyIEC_COUNTER")
● Multiinstancia: Declaración como variable local del tipo CTD_<Tipo de datos> o
IEC_<Contador> en la sección "Static" de un bloque (p. ej., #MyCTD_COUNTER)

Programación del PLC
Manual de programación y manejo, 11/2019

1393

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Contador descendente":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

CD

Input

BOOL

I, Q, M, D, L o
constante

Entrada de contaje

LD

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de carga

PV

Input

Enteros

I, Q, M, D, L, P o
constante

Valor al que se pone la salida
CV cuando LD = 1.

Q

Output

BOOL

I, Q, M, D, L

Estado del contador

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL CTD, "CTD_DB"

// Se llama la instrucción. El bloque de datos
"CTD_DB" se asigna a la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

CD := "Tag_StartCTD"

// Cuando el estado lógico del operando "Tag_StartCTD"
cambia de "0" a "1", se ejecuta la instrucción y el
valor actual del operando "Tag_CounterValue" se decrementa en uno.
// El valor de contaje del parámetro CV se sigue decrementando hasta alcanzar el valor límite inferior de
INT = -32768.

LD := "Tag_LoadPV"

// Cuando el estado lógico del operando "Tag_LoadPV"
cambia a "1", el operando "Tag_CounterValue" se pone
al valor del operando "Tag_PresetValue".

PV := "Tag_PresetValue"

// Indica el valor al que se pone el contador cuando
el estado lógico del parámetro LD es "1".

Q := "Tag_CounterStatus"

// El operando se activa si el valor de contaje actual
es menor o igual a cero.

CV := "Tag_CounterValue"

// Valor de contaje actual

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Ajustar la remanencia en un bloque de datos de instancia (Página 7855)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

1394

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CTUD: Contador ascendente - descendente
Descripción
La instrucción "Contador ascendente - descendente" incrementa y decrementa el valor de
contaje del parámetro CV. Cuando el estado lógico del parámetro CU cambia de "0" a "1"
(flanco de señal ascendente), el valor de contaje actual se incrementa en uno y se deposita en
el parámetro CV. Cuando el estado lógico del parámetro CD cambia de "0" a "1" (flanco de
señal ascendente), el valor de contaje del parámetro CV se decrementa en uno. Si en un ciclo
del programa se detecta un flanco de señal ascendente en las entradas CU y CD, el valor de
contaje actual no cambia en el parámetro CV.
El valor de contaje se puede seguir incrementando hasta alcanzar el valor límite superior del
tipo de datos indicado en el parámetro CV. Una vez alcanzado el valor límite superior, el valor
de contaje no se incrementa más aunque se detecte un flanco de señal ascendente. Cuando
se alcanza el valor límite inferior del tipo de datos indicado, ya no se decrementa el valor de
contaje.
Cuando el estado lógico del parámetro LD cambia a "1", el valor de contaje del parámetro CV
se pone al valor del parámetro PV. Mientras el parámetro LD tenga el estado lógico "1", el
estado lógico de las entradas CU y CD no tendrá efecto alguno en la instrucción.
El valor de contaje se pone a cero cuando el estado lógico del parámetro R cambia a "1".
Mientras el estado lógico del parámetro R sea "1", un cambio del estado lógico de los
parámetros CU, CD y LD no tendrá efecto alguno en la instrucción "Contador ascendente descendente".
El estado del contador ascendente se puede consultar en el parámetro QU. Si el valor de
contaje actual es mayor o igual al valor del parámetro PV, el parámetro QU adopta el estado
lógico "1". En los restantes casos, el estado lógico del parámetro QU es "0". En el parámetro
PV también se puede indicar una constante.
El estado del contador descendente se puede consultar en el parámetro QD. Si el valor de
contaje actual es menor o igual a cero, el parámetro QD adopta el estado lógico "1". En los
restantes casos, el estado lógico del parámetro QD es "0".
En la lógica del programa, la instrucción "Contador ascendente - descendente" se debe llamar
con la instrucción "Llamar bloque" (CALL).
Nota
Utilice el contador en una sola posición del programa para evitar fallos de contaje.
A cada llamada de la instrucción "Contador ascendente - descendente" debe asignársele un
contador CEI en el que se guarden los datos de la instrucción. Un contador CEI es una
estructura con uno de los tipos de datos siguientes:
El sistema operativo inicializa las instancias de la instrucción "Contador ascendente descendente" cuando se realiza un arranque en frío. Si deben inicializarse instancias tras un
rearranque completo (en caliente), las instancias por inicializar deben llamarse en un OB de
arranque con los siguientes valores de parámetros:
● Si se utiliza como contador ascendente, el valor del parámetro R debe ponerse a "1".
● Si se utiliza como contador descendente, el valor del parámetro LD debe ponerse a "1". En
el parámetro PV debe indicarse en este caso el valor inicial deseado del parámetro CV.

Programación del PLC
Manual de programación y manejo, 11/2019

1395

Instrucciones
4.1 Instrucciones
Si un bloque diferente contiene instancias de la instrucción "Contador ascendente descendente", estas pueden resetearse p. ej. inicializando el bloque de nivel superior.

Bloque de datos de instancia del tipo de datos de sistema IEC_<Contador> (Shared DB/Instancia
individual)
El tipo de datos de sistema del bloque de datos de instancia se deriva del tipo de datos de la
instrucción:
Tipo de datos de la instrucción

Tipo de datos de sistema del bloque de datos de
instancia (Shared DB)

SINT / USINT

IEC_SCOUNTER / IEC_USCOUNTER

INT / UINT

IEC_COUNTER / IEC_UCOUNTER

DINT / UDINT

IEC_DCOUNTER / IEC_UDCOUNTER

LINT / ULINT

IEC_LCOUNTER / IEC_ULCOUNTER

Si el contador CEI se crea como instancia individual, el bloque de datos de instancia se crea
de forma estándar con "acceso optimizado al bloque" y las distintas variables se declaran
remanentes.
Encontrará más información sobre la configuración de la remanencia en un bloque de datos de
instancia en "Consulte también".

Variable local (multiinstancia)
El tipo de datos de la variable local se deriva del tipo de datos de la instrucción:
Tipo de datos de la instrucción

Tipo de datos de la variable local

SINT / USINT

CTUD_SINT / CTUD_USINT / IEC_SCOUNTER /
IEC_USCOUNTER

INT / UINT

CTUD_INT / CTUD_UINT / IEC_COUNTER /
IEC_UCOUNTER

DINT / UDINT

CTUD_DINT / CTUD_UDINT / IEC_DCOUNTER /
IEC_UDCOUNTER

LINT / ULINT

CTUD_LINT / CTUD_ULINT / IEC_LCOUNTER /
IEC_ULCOUNTER

Si el contador CEI se crea como multiinstancia en un bloque de función con "acceso
optimizado al bloque", esta se declara remanente en la interfaz del bloque.

Declarar contador CEI
Tras seleccionar el tipo de datos en la lista desplegable "???", el cuadro de diálogo "Opciones
de llamada" se abre automáticamente. A continuación, puede declarar el contador CEI del
siguiente modo:
● Instancia individual: Declaración de un bloque de datos de instancia del tipo de datos de
sistema IEC_<nombre_del_contador> (p. ej., "MyIEC_COUNTER")
● Multiinstancia: Declaración como variable local del tipo CTUD_<tipo de datos> o
IEC_<contador> en la sección "Static" de un bloque (p. ej., #MyCTUD_COUNTER)

1396

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Contador ascendente descendente":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

CU

Input

BOOL

I, Q, M, D, L o
constante

Entrada de contaje ascen‐
dente

CD

Input

BOOL

I, Q, M, D, L o
constante

Entrada de contaje descen‐
dente

R

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de reset

LD

Input

BOOL

I, Q, M, D, L, P o
constante

Entrada de carga

PV

Input

Enteros

I, Q, M, D, L, P o
constante

Valor con el que se activa la
salida QU. / Valor al que se
pone la salida CV cuando LD
= 1.

QU

Output

BOOL

I, Q, M, D, L

Estado del contador ascen‐
dente

QD

Output

BOOL

I, Q, M, D, L

Estado del contador descen‐
dente

CV

Output

Enteros, CHAR,
WCHAR, DATE

I, Q, M, D, L, P

Valor de contaje actual

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL CTUD, "CTUD_DB"

// Se llama la instrucción. El bloque de datos
"CTUD_DB" se asigna a la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

CU := "Tag_StartCTU"

// Cuando el estado lógico del operando "Tag_StartCTU"
cambia de "0" a "1", se ejecuta la instrucción y el
valor actual del operando "Tag_CounterValue" se incrementa en uno.
// Si se detecta un flanco de señal ascendente en el
parámetro CU, el valor de contaje se sigue incrementando hasta alcanzar el valor límite superior de INT =
32767.

CD := "Tag_StartCTD"

// Cuando el estado lógico del operando "Tag_StartCTD"
cambia de "0" a "1", se ejecuta la instrucción y el
valor actual del operando "Tag_CounterValue" se decrementa en uno.
// El valor de contaje del parámetro CV se sigue decrementando hasta alcanzar el valor límite inferior de
-32768.

Programación del PLC
Manual de programación y manejo, 11/2019

1397

Instrucciones
4.1 Instrucciones
AWL

Explicación

R := "Tag_ResetCounter"

// Cuando el estado lógico del operando "Tag_ResetCounter" cambia a "1", el operando "Tag_CounterValue"
se pone a "0".

LD := "Tag_LoadPV"

// Cuando el estado lógico del operando "Tag_LoadPV"
cambia a "1", el operando "Tag_CounterValue" se pone
al valor del operando "Tag_PresetValue".

PV := "Tag_PresetValue"

// Indica el valor al que se pone el contador cuando
el estado lógico del parámetro LD es "1".

QU := "Tag_CounterStatus"

// El operando permanece activado mientras el valor de
contaje actual sea mayor o igual al valor del parámetro PV.

QD := "Tag_CounterStatus"

// El operando se activa si el valor de contaje actual
es menor o igual a cero.

CV := "Tag_CounterValue"

// Valor de contaje actual

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Ajustar la remanencia en un bloque de datos de instancia (Página 7855)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

Comparación
CompType: Comparar variables de tipo de datos estructurado
Descripción
La instrucción "Comparar variables de tipo de datos estructurado" permite consultar si el
primer valor de comparación de una variable estructurada (IN1) es igual o diferente del
segundo valor de comparación de otra variable estructurada (IN2).
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1" en el parámetro OUT. Si la condición de la comparación no se cumple, la instrucción
devuelve el RLO "0".

Comparación de números en coma flotante
Si se comparan números en coma flotante, los operandos que comparar deben ser del mismo
tipo de datos, independientemente del ajuste de la verificación CEI.
Los patrones de bits especiales de números en coma flotante no válidos (NaN) que se generan
en caso de resultados indefinidos (p. ej. raíz de -1) no pueden compararse. Es decir, si uno de
los dos operandos tiene el valor NaN, tanto la instrucción "CompType EQ" como "CompType
NE" darán como resultado FALSE.

1398

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Comparación de cadenas de caracteres
En una comparación de cadenas de caracteres, los distintos caracteres se comparan según su
codificación (p. ej. 'a' es mayor que 'A'). La comparación se realiza de izquierda a derecha. El
primer carácter diferente es el decisivo para el resultado de la comparación.
La tabla siguiente muestra ejemplos de comparación de igualdad de cadenas de caracteres:
<Operando1>

<Operando2>

RLO de la instrucción

'AA'

'AA'

1

'Hello World'

'HelloWorld'

0

'AA'

'aa'

0

'aa'

'aaa'

0

La tabla siguiente muestra ejemplos de comparación de no igualdad de cadenas de caracteres:
<Operando1>

<Operando2>

RLO de la instrucción

'AA'

'aa'

1

'Hello World'

'HelloWorld'

1

'AA'

'AA'

0

'aa'

'aaa'

1

También es posible comparar caracteres individuales de una cadena de caracteres. El número
del carácter que se va a comparar se indica entre corchetes al lado del nombre del operando.
Si se indica "MyString[2]", se compara p. ej. el segundo carácter de la cadena de caracteres
"MyString".

Comparación de tiempos, fecha y hora
Los patrones de bits de temporizadores, fechas y horas no válidos, p. ej.
DT#2015-13-33-25:62:99.999_999_999, no pueden compararse. Es decir, si uno de los dos
operandos tiene un valor no válido, tanto la instrucción "CompType EQ" como "CompType NE"
darán como resultado FALSE.
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Programación del PLC
Manual de programación y manejo, 11/2019

1399

Instrucciones
4.1 Instrucciones

Comparación de estructuras
Nota
Disponibilidad de la comparación de estructuras
La posibilidad de comparar estructuras está disponible en las CPU de la serie S7-1500 a partir
de la versión de firmware >= 2.0.
Es posible comparar entre sí los valores de dos operandos estructurados cuando las dos
variables tienen el mismo tipo de datos de estructura. Si se comparan estructuras, los
operandos que comparar deben ser del mismo tipo de datos, independientemente del ajuste
de la verificación CEI. Esto no es aplicable a comparaciones en las que uno de los dos
operandos es un VARIANT o un ANY. Si el tipo de datos se desconoce en el momento de crear
el programa, puede emplearse VARIANT. En este caso, será posible también comparar el
operando con una variable estructurada de cualquier tipo de datos. También pueden
compararse entre sí dos variables del tipo de datos VARIANT o ANY.
Son posibles los siguientes tipos de datos:
● Tipo de datos PLC
● STRUCT (la estructura del tipo de datos STRUCT debe estar contenida en un tipo de datos
PLC (UDT) o las dos estructuras que van a compararse son dos elementos de un ARRAY
of STRUCT. No se permiten las estructuras anónimas.)
● Variable a la que apunta ANY.
● Variable a la que apunta VARIANT.
Para poder comparar entre sí dos variables del tipo de datos ARRAY deben cumplirse los
siguientes requisitos:
● Los elementos deben tener el mismo tipo de datos en cada caso.
● Los dos ARRAY deben tener la misma dimensión.
● Todas las dimensiones deben tener el mismo número de elementos. Los límites concretos
de ARRAY no tienen que coincidir necesariamente.
La tabla siguiente muestra ejemplos de la comparación de "Igual" de estructuras:
<Operando1>
Variable del tipo de da‐
tos A <Tipo de datos
PLC>

1400

<Operando2>
Valor de la va‐
riable

RLO de la ins‐
trucción

Variable del tipo de
datos A <Tipo de da‐
tos PLC>

Valor de la varia‐
ble

BOOL

FALSE

BOOL

FALSE

INT

2

INT

2

1

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

<Operando1>
Variable del tipo de da‐
tos A <Tipo de datos
PLC>

<Operando2>
Valor de la va‐
riable

Variable del tipo de
datos B <Tipo de da‐
tos PLC>

RLO de la ins‐
trucción
Valor de la varia‐
ble

BOOL

FALSE

BOOL

TRUE

INT

2

INT

3

<Operando1>
Variable del tipo de da‐
tos A <Tipo de datos
PLC>

Valor de la va‐
riable

0

<Operando2>

RLO de la ins‐
trucción

VARIANT (recibe da‐ Valor de la varia‐
tos de la variable del ble
tipo de datos A)

1

BOOL

FALSE

BOOL

FALSE

INT

2

INT

2

La tabla siguiente muestra ejemplos de la comparación de "Diferente" de estructuras:
<Operando1>
Variable del tipo de da‐
tos A <Tipo de datos
PLC>

<Operando2>
Valor de la va‐
riable

Variable del tipo de
datos A <Tipo de da‐
tos PLC>

RLO de la ins‐
trucción
Valor de la varia‐
ble

BOOL

FALSE

BOOL

FALSE

INT

2

INT

2

<Operando1>
Variable del tipo de da‐
tos A <Tipo de datos
PLC>

<Operando2>
Valor de la va‐
riable

Variable del tipo de
datos B <Tipo de da‐
tos PLC>

RLO de la ins‐
trucción
Valor de la varia‐
ble

BOOL

FALSE

BOOL

TRUE

INT

2

INT

3

<Operando1>
Variable del tipo de da‐
tos A <Tipo de datos
PLC>

Valor de la va‐
riable

1

<Operando2>

RLO de la ins‐
trucción

VARIANT (recibe da‐ Valor de la varia‐
tos de la variable del ble
tipo de datos A)

0

BOOL

FALSE

BOOL

FALSE

INT

2

INT

2

Programación del PLC
Manual de programación y manejo, 11/2019

0

1401

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Comparar variables de tipo de
datos estructurado":
Parámetro

Declaración

Tipo de datos

Área de memoria

IN1

Input

Números binarios, I, Q, M, D, L, P
enteros, números
en coma flotante,
secuencias de ca‐
racteres, tempori‐
zadores, fecha y
hora, ARRAY of
<tipo de datos>
con límites de
ARRAY fijos y va‐
riables, STRUCT,
VARIANT, ANY, ti‐
po de datos PLC

Primer valor de comparación

IN2

Input

Números binarios, I, Q, M, D, L, P
enteros, números
en coma flotante,
secuencias de ca‐
racteres, tempori‐
zadores, fecha y
hora, ARRAY of
<tipo de datos>
con límites de
ARRAY fijos y va‐
riables, STRUCT,
VARIANT, ANY, ti‐
po de datos PLC

Segundo valor de compara‐
ción

OUT

Output

BOOL

Resultado de la instrucción

I, Q, M, D, L

Descripción

Como se ha descrito anteriormente, los tipos de datos ARRAY, STRUCT (dentro de un tipo de datos
PLC), VARIANT, ANY y el tipo de datos PLC (UDT) están disponibles a partir de la versión de firmware
2.0.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL CompType

// Se llama la instrucción.
// Seleccione la función deseada. Puede ser "EQ" o
"NE" en la lista desplegable.

1402

IN1 := "Tag_Operand1"

// Primer valor de comparación

IN2 := "Tag_Operand2"

// Segundo valor de comparación

OUT := "Tag_Result"

// La salida "Tag_Result" devuelve el estado lógico
"1" si se cumple la condición de la instrucción de
comparación. Es decir, el operando "Tag_Operand1"
es igual a "Tag_Operand2".

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de VARIANT (Página 335)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

VARIANT
EQ_Type: Comparar si el tipo de datos es IGUAL al tipo de datos de una variable
Descripción
Con la instrucción "Comparar si el tipo de datos es IGUAL al tipo de datos de una variable" se
consulta de qué tipo de datos es la variable a la que apunta VARIANT. El tipo de datos de la
variable del parámetro IN1, declarada en la interfaz del bloque, se compara con el tipo de datos
de la variable del parámetro IN2 para determinar si es "Igual".
La variable del parámetro IN1 tiene que ser del tipo de datos VARIANT. La variable del
parámetro IN2 puede ser un tipo de datos simple o un tipo de datos PLC.

Comparación de tiempos, fecha y hora
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Comparación de estructuras
Para comparar estructuras está disponible la instrucción "CompType". Por norma general no
es posible comparar estructuras anónimas, excepto cuando forman parte del mismo ARRAY.
Encontrará más información sobre la comparación de estructuras aquí: CompType: Comparar
variables de tipo de datos estructurado (Página 1398)

Programación del PLC
Manual de programación y manejo, 11/2019

1403

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Comparar si el tipo de datos es
IGUAL al tipo de datos de una variable":
Parámetro

Declaración

Tipo de datos

Área de memoria

IN1

Input

VARIANT

L (puede declarar‐ Primer operando
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

IN2

Input

Números binarios, I, Q, M, D, L, P
enteros, números
en coma flotante,
temporizadores,
fecha y hora, se‐
cuencias de carac‐
teres, ARRAY, ti‐
pos de datos PLC

Segundo operando

RET_VAL

Output

BOOL

Resultado de la instrucción

I, Q, M, D, L

Descripción

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL EQ_Type

// Se llama a la instrucción.

IN1 := #Tag_Operand1

// Primer operando que se va a comparar

IN2 := "Tag_Operand2"

// Segundo operando que se va a comparar

RET_VAL := "Tag_Result"

// La salida "Tag_Result" devuelve el estado lógico "1" si se cumple la condición de la instrucción de comparación. Es decir, el operando
#Tag_Operand1 es igual a "Tag_Operand2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de VARIANT (Página 335)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

1404

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

NE_Type: Comparar si el tipo de datos es DIFERENTE del tipo de datos de una variable
Descripción
Con la instrucción "Comparar si el tipo de datos es DIFERENTE del tipo de datos de una
variable" se consulta el tipo de datos que no tiene una variable a la que señala un VARIANT.
El tipo de datos de la variable del parámetro IN1, declarada en la interfaz del bloque, se
compara con el tipo de datos de la variable del parámetro IN2 para determinar si es "Diferente".
La variable del parámetro IN1 tiene que ser del tipo de datos VARIANT. La variable del
parámetro IN2 puede ser un tipo de datos simple o un tipo de datos PLC.

Comparación de tiempos, fecha y hora
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Comparación de estructuras
Para comparar estructuras está disponible la instrucción "CompType". Por norma general no
es posible comparar estructuras anónimas, excepto cuando forman parte del mismo ARRAY.
Encontrará más información sobre la comparación de estructuras aquí: CompType: Comparar
variables de tipo de datos estructurado (Página 1398)

Programación del PLC
Manual de programación y manejo, 11/2019

1405

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Comparar si el tipo de datos es
DIFERENTE del tipo de datos de una variable":
Parámetro

Declaración

Tipo de datos

Área de memoria

IN1

Input

VARIANT

L (puede declarar‐ Primer operando
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

IN2

Input

Números binarios, I, Q, M, D, L, P
enteros, números
en coma flotante,
temporizadores,
fecha y hora, se‐
cuencias de carac‐
teres, ARRAY, ti‐
pos de datos PLC

Segundo operando

RET_VAL

Output

BOOL

Resultado de la instrucción

I, Q, M, D, L

Descripción

Resultado
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL NE_Type

// Se llama a la instrucción.

IN1 := #Tag_Operand1

// Primer operando que se va a comparar

IN2 := "Tag_Operand2"

// Segundo operando que se va a comparar

RET_VAL := "Tag_Result"

// La salida "Tag_Result" devuelve el estado lógico "1" si se cumple la condición de la instrucción
de comparación. Es decir, el operando #Tag_Operand1 es diferente de "Tag_Operand2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de VARIANT (Página 335)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

1406

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

EQ_ElemType: Comparar si el tipo de datos de un elemento del ARRAY es IGUAL al tipo de datos de
una variable
Descripción
Con la instrucción "Comparar si el tipo de datos de un elemento del ARRAY es IGUAL al tipo
de datos de una variable" se consulta de qué tipo de datos es la variable a la que apunta
VARIANT. El tipo de datos de la variable del parámetro IN1, declarada en la interfaz del bloque,
se compara con el tipo de datos de la variable del parámetro IN2 para determinar si es "Igual".
La variable del parámetro IN1 tiene que ser del tipo de datos VARIANT. La variable del
parámetro IN2 puede ser un tipo de datos simple o un tipo de datos PLC.
Si el tipo de datos de la variable VARIANT es un ARRAY, se compara el tipo de datos de los
elementos del ARRAY.

Comparación de tiempos, fecha y hora
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Comparación de estructuras
Para comparar estructuras está disponible la instrucción "CompType". Por norma general no
es posible comparar estructuras anónimas, excepto cuando forman parte del mismo ARRAY.
Encontrará más información sobre la comparación de estructuras aquí: CompType: Comparar
variables de tipo de datos estructurado (Página 1398)

Programación del PLC
Manual de programación y manejo, 11/2019

1407

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Comparar si el tipo de datos de un
elemento del ARRAY es IGUAL al tipo de datos de una variable":
Parámetro

Declaración

Tipo de datos

Área de memoria

IN1

Input

VARIANT

L (puede declarar‐ Primer operando
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

IN2

Input

Números binarios, I, Q, M, D, L, P
enteros, números
en coma flotante,
temporizadores,
fecha y hora, se‐
cuencias de carac‐
teres, ARRAY, ti‐
pos de datos PLC

Segundo operando

RET_VAL

Output

BOOL

Resultado de la instrucción

I, Q, M, D, L

Descripción

Resultado
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL EQ_ElemType

// Se llama a la instrucción.

IN1 := #Tag_Operand1

// Primer operando que se va a comparar

IN2 := "Tag_Operand2"

// Segundo operando que se va a comparar

RET_VAL := "Tag_Result"

// La salida "Tag_Result" devuelve el estado
lógico "1" si se cumple la condición de la
instrucción de comparación. Es decir, el operando #Tag_Operand1 es igual a "Tag_Operand2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de VARIANT (Página 335)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

1408

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

NE_ElemType: Comparar si el tipo de datos de un elemento del ARRAY es DIFERENTE del tipo de
datos de una variable
Descripción
Con la instrucción "Comparar si el tipo de datos de un elemento del ARRAY es DIFERENTE
al tipo de datos de una variable " se consulta de qué tipo de datos no es la variable a la que
apunta VARIANT. El tipo de datos de la variable del parámetro IN1, declarada en la interfaz del
bloque, se compara con el tipo de datos de la variable del parámetro IN2 para determinar si es
"Diferente".
La variable del parámetro IN1 tiene que ser del tipo de datos VARIANT. La variable del
parámetro IN2 puede ser un tipo de datos simple o un tipo de datos PLC.
Si el tipo de datos de la variable VARIANT es un ARRAY, se compara el tipo de datos de los
elementos del ARRAY.

Comparación de tiempos, fecha y hora
No es posible comparar directamente todos los tiempos entre sí, como p. ej. S5TIME. En este
caso se convierten implícitamente a otro tiempo para poder compararlos, p. ej. a TIME.
Para comparar fechas y horas de diferentes tipos de datos entre sí, el valor del tipo de datos
de fecha u hora más pequeño se convierte implícitamente al mayor. De ese modo se
comparan, por ejemplo, ambos tipos de datos de fecha y hora DATE y DTL sobre la base de
DTL.
Si se produce un error en las conversiones implícitas, la comparación da como resultado
FALSE.

Comparación de estructuras
Para comparar estructuras está disponible la instrucción "CompType". Por norma general no
es posible comparar estructuras anónimas, excepto cuando forman parte del mismo ARRAY.
Encontrará más información sobre la comparación de estructuras aquí: CompType: Comparar
variables de tipo de datos estructurado (Página 1398)

Programación del PLC
Manual de programación y manejo, 11/2019

1409

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Comparar si el tipo de datos de un
elemento del ARRAY es DIFERENTE al tipo de datos de una variable":
Parámetro

Declaración

Tipo de datos

Área de memoria

IN1

Input

VARIANT

L (puede declarar‐ Primer operando
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

IN2

Input

Números binarios, I, Q, M, D, L, P
enteros, números
en coma flotante,
temporizadores,
fecha y hora, se‐
cuencias de carac‐
teres, ARRAY, ti‐
pos de datos PLC

Segundo operando

RET_VAL

Output

BOOL

Resultado de la instrucción

I, Q, M, D, L

Descripción

Resultado
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL NE_ElemType

// Se llama a la instrucción.

IN1 := #Tag_Operand1

// Primer operando que se va a comparar

IN2 := "Tag_Operand2"

// Segundo operando que se va a comparar

RET_VAL := "Tag_Result"

// La salida "Tag_Result" devuelve el estado lógico "1" si se cumple la condición de la instrucción de comparación. Es decir, el operando
#Tag_Operand1 es diferente de "Tag_Operand2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de VARIANT (Página 335)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

IS_NULL: Consultar si es un puntero IGUAL A CERO
Descripción
La instrucción "Consultar si es un puntero IGUAL A CERO" permite saber si VARIANT o la
referencia hace referencia a un puntero CERO y, por tanto, no apunta a un objeto.

1410

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La variable del parámetro OPERAND tiene que ser del tipo de datos VARIANT o REF_TO <tipo
de datos>.
Nota
La variable VARIANT apunta a un puntero ANY
Si la variable VARIANT apunta a un puntero ANY, la instrucción devuelve siempre el resultado
RLO = "0" aunque el puntero ANY tenga el valor CERO.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar si es un puntero IGUAL
A CERO":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OPERAND

Input

VARIANT o
REF_TO <tipo de
datos>

L (puede declarar‐ Operando que se compara si
se en las seccio‐
es IGUAL A CERO
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

BOOL

I, Q, M, D, L

Resultado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL IS_NULL

// Se llama a la instrucción.

OPERAND := #Tag_Operand

// Operando que se va a comparar

RET_VAL := "Tag_Result"

// La salida "Tag_Result" devuelve el estado lógico "1" si se cumple la condición de la instrucción de comparación. Es decir, el operando
#Tag_Operand no apunta a ningún objeto.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de VARIANT (Página 335)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

Programación del PLC
Manual de programación y manejo, 11/2019

1411

Instrucciones
4.1 Instrucciones

NOT_NULL: Consultar si es un puntero DIFERENTE DE CERO
Descripción
La instrucción "Consultar si es un puntero DIFERENTE DE CERO" permite saber si VARIANT
o la referencia no hace referencia a un puntero CERO y, por tanto, apunta a un objeto.
La variable del parámetro OPERAND tiene que ser del tipo de datos VARIANT o REF_TO <tipo
de datos>.
Nota
La variable VARIANT apunta a un puntero ANY
Si la variable VARIANT apunta a un puntero ANY, la instrucción devuelve siempre el resultado
RLO = "1" aunque el puntero ANY tenga el valor CERO.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar si es un puntero
DIFERENTE DE CERO":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OPERAND

Input

VARIANT o
REF_TO <tipo de
datos>

L (puede declarar‐ Operando que se compara si
se en las seccio‐
es DIFERENTE DE CERO
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

BOOL

I, Q, M, D, L

Resultado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL NOT_NULL

// Se llama a la instrucción.

OPERAND := #Tag_Operand

// Operando que se va a comparar

RET_VAL := "Tag_Result"

// La salida "Tag_Result" devuelve el estado lógico "1" si se cumple la condición de la instrucción de comparación. Es decir, el operando
#Tag_Operand apunta a un objeto.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de VARIANT (Página 335)

1412

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

IS_ARRAY: Consultar si es un ARRAY
Descripción
La instrucción "Consultar si es un ARRAY" permite saber si VARIANT apunta a una variable
del tipo de datos ARRAY.
La variable del parámetro OPERAND es del tipo de datos VARIANT. El resultado de la consulta
se devuelve en el parámetro RET_VAL.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar si es un ARRAY":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OPERAND

Input

VARIANT

L (puede declarar‐ Operando que se consulta si
se en las seccio‐
es un ARRAY
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

BOOL

I, Q, M, D, L

Resultado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Nota
Consulta de un bloque de datos ARRAY
Si utiliza la instrucción IS_ARRAY en relación con un ArrayDB y genera el parámetro de
entrada VARIANT con DB_ANY_TO_VARIANT , en un punto cualquiera del programa deberá
utilizarse el ArrayDB en forma de símbolo como parámetro actual de un parámetro formal del
tipo de datos de datos VARIANT. Para que funcione correctamente es suficiente que se haya
descargado el lugar de uso. No es necesario que se ejecute.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL IS_ARRAY

// Se llama a la instrucción.

OPERAND := #Tag_Input

// Operando sobre el que debe consultarse
si es ARRAY

Programación del PLC
Manual de programación y manejo, 11/2019

1413

Instrucciones
4.1 Instrucciones
AWL

Explicación

RET_VAL := "Tag_Result"

// La salida "Tag_Result" devuelve el estado lógico "1" si se cumple la condición
de la instrucción de comparación. Es decir, si el VARIANT en el operando #Tag_Input apunta a un ARRAY.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de VARIANT (Página 335)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

EQ_TypeOfDB: Comparación de igualdad entre un tipo de datos de un DB direccionado indirectamente
y un tipo de datos
Descripción
La instrucción "Comparación de igualdad entre un tipo de datos de un DB direccionado
indirectamente y un tipo de datos" sirve para consultar el tipo de datos que tiene el bloque de
datos direccionado por la variable del tipo de datos DB_ANY. Se compara el tipo de datos del
DB direccionado a través de la variable del parámetro IN1 con el tipo de datos de otra variable
o bien directamente con un tipo de datos en el parámetro IN2 para determinar si es "Igual".
La variable del parámetro IN1 debe ser del tipo de datos DB_ANY. La variable del parámetro
IN2 puede ser, p. ej., un tipo de datos PLC, un tipo de datos de sistema, un eje o un FB.
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1". Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

DB_ANY

L (puede declarar‐ Primer operando
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

IN2

Input

TYPE_ID

I, Q, M, D, L, P

Segundo operan‐
do

RET_VAL

Output

BOOL

I, Q, M, D, L

Resultado de la
comparación

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1414

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL EQ_TypeOfDB

// Llamada de la instrucción

IN1 := #InputDBAny

// Operando que debe consultarse si es
DB_ANY

IN2 := TO_SpeedAxis

// Se cumple la condición de la instrucción de comparación cuando el tipo de datos del DB direccionado por el operando
#InputDBAny es igual al tipo de datos
TO_SpeedAxis.

RET_VAL := "TagOut"

// Resultado de la comparación

La salida "TagOut" no se activa cuando se cumplen las condiciones siguientes:
● El número del bloque de datos es "0".
● El bloque de datos no existe.
● El bloque de datos es un DB de ARRAY.
● El bloque de datos contiene una variable del tipo de datos UDT (tipo de datos PLC).

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Uso del tipo de datos DB_ANY (Página 216)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

NE_TypeOfDB: Comparación de desigualdad entre un tipo de datos de un DB direccionado
indirectamente y un tipo de datos
Descripción
La instrucción "Comparación de desigualdad entre un tipo de datos de un DB direccionado
indirectamente y un tipo de datos" sirve para consultar el tipo de datos que no tiene el bloque
de datos direccionado por la variable del tipo de datos DB_ANY. Se compara el tipo de datos
del DB direccionado a través de la variable del parámetro IN1 con el tipo de datos de otra
variable o bien directamente con el tipo de datos del parámetro IN2 para determinar si es
"Diferente".
La variable del parámetro IN1 debe ser del tipo de datos DB_ANY. La variable del parámetro
IN2 puede ser, p. ej., un tipo de datos PLC, un tipo de datos de sistema, un eje o un FB.
Si se cumple la condición de la comparación, la instrucción devuelve el resultado lógico (RLO)
"1". Si la condición de la comparación no se cumple, la instrucción devuelve el RLO "0".

Programación del PLC
Manual de programación y manejo, 11/2019

1415

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

DB_ANY

L (puede declarar‐ Primer operando
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

IN2

Input

TYPE_ID

I, Q, M, D, L, P

Segundo operan‐
do

RET_VAL

Output

BOOL

I, Q, M, D, L

Resultado de la
comparación

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL NE_TypeOfDB

// Llamada de la instrucción

IN1 := #InputDBAny

// Operando que debe consultarse si es
DB_ANY

IN2 := TO_SpeedAxis

// Se cumple la condición de la instrucción de comparación cuando el tipo de datos del DB direccionado por el operando
#InputDBAny es diferente del tipo de datos TO_SpeedAxis.

RET_VAL := "TagOut"

// Resultado de la comparación

La salida "TagOut" no se activa cuando se cumplen las condiciones siguientes:
● El número del bloque de datos es "0".
● El bloque de datos no existe.
● El bloque de datos es un DB de ARRAY.
● El bloque de datos contiene una variable del tipo de datos UDT (tipo de datos PLC).

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Uso del tipo de datos DB_ANY (Página 216)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

1416

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Funciones matemáticas
MIN: Determinar mínimo
Descripción
La instrucción "Determinar mínimo" compara los valores de las entradas IN1, IN2 e IN3 y
escribe el valor menor en la salida OUT. Para poder ejecutar la instrucción, es imprescindible
que las variables de todas las entradas sean del mismo tipo de datos.
El valor del parámetro OUT no es válido si se cumple una de las siguientes condiciones:
● Las variables indicadas no son del mismo tipo de datos.
● Un número en coma flotante tiene un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Determinar mínimo":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

Enteros, números
en coma flotante

I, Q, M, D, L, P o
constante

Primer valor de entrada

IN2

Input

Enteros, números
en coma flotante

I, Q, M, D, L, P o
constante

Segundo valor de entrada

IN3

Input

Enteros, números
en coma flotante

I, Q, M, D, L, P o
constante

Tercer valor de entrada

OUT

Output

Enteros, números
en coma flotante

I, Q, M, D, L, P

Resultado

Si la verificación CEI no está activada, también es posible utilizar variables del tipo de datos TIME,
LTIME, TOD, LTOD, DATE y LDT seleccionando como tipo de datos de la instrucción un número entero
o una secuencia de bits de igual longitud. (P. ej. en lugar de TIME => DINT, UDINT o DWORD = 32 bits)

En la lista desplegable "???" puede seleccionar el tipo de datos para los parámetros INn y OUT.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL MIN

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN1 := "TagIn_Value1"

// Primer valor de entrada que se compara.

IN2 := "TagIn_Value2"

// Segundo valor de entrada que se compara.

IN3 := "TagIn_Value3"

// Tercer valor de entrada que se compara.

OUT := "Tag_Minimum"

// El operando "Tag_Minimum" se describe con el valor
del operando "TagIn_Value1", ya que este tiene el valor más bajo.

Programación del PLC
Manual de programación y manejo, 11/2019

1417

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN1

TagIn_Value1

12222

IN2

TagIn_Value2

14444

IN3

TagIn_Value3

13333

OUT

Tag_Minimum

12222

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

MAX: Determinar máximo
Descripción
La instrucción "Determinar máximo" compara los valores de las entradas IN1, IN2 e IN3 y
escribe el valor mayor en la salida OUT. Para poder ejecutar la instrucción, es imprescindible
que las variables de todas las entradas sean del mismo tipo de datos.
El valor de la salida OUT no es válido si se cumple una de las siguientes condiciones:
● Las variables indicadas no son del mismo tipo de datos.
● Un número en coma flotante tiene un valor no válido.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Determinar máximo":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN1

Input

Enteros, números
en coma flotante

I, Q, M, D, L, P o
constante

Primer valor de entrada

IN2

Input

Enteros, números
en coma flotante

I, Q, M, D, L, P o
constante

Segundo valor de entrada

IN3

Input

Enteros, números
en coma flotante

I, Q, M, D, L, P o
constante

Tercer valor de entrada

OUT

Output

Enteros, números
en coma flotante

I, Q, M, D, L, P

Resultado

Si la verificación CEI no está activada, también es posible utilizar variables del tipo de datos TIME,
LTIME, TOD, LTOD, DATE y LDT seleccionando como tipo de datos de la instrucción un número entero
o una secuencia de bits de igual longitud. (P. ej. en lugar de TIME => DINT, UDINT o DWORD = 32 bits)

En la lista desplegable "???" puede seleccionar el tipo de datos para los parámetros INn y OUT.

1418

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL MAX

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN1 := "TagIn_Value1"

// Primer valor de entrada que se compara.

IN2 := "TagIn_Value2"

// Segundo valor de entrada que se compara.

IN3 := "TagIn_Value3"

// Tercer valor de entrada que se compara.

OUT := "Tag_Maximum"

// El operando "Tag_Maximum" se describe con el valor
del operando "TagIn_Value2", ya que este tiene el valor más grande.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN1

TagIn_Value1

12222

IN2

TagIn_Value2

14444

IN3

TagIn_Value3

13333

OUT

Tag_Maximum

14444

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

LIMIT: Ajustar valor límite
Descripción
La instrucción "Ajustar valor límite" limita el valor de la entrada IN a los valores de las entradas
MN y MX. Si el valor de la entrada IN cumple la condición MN <= IN <= MX, se copia en la salida
OUT. Si no se cumple la condición y el valor de entrada IN es menor que el límite inferior MN,
la salida OUT adopta el valor de la entrada MN. Si el límite superior MX se rebasa por exceso,
la salida OUT adopta el valor de la entrada MX.
Para poder ejecutar la instrucción, todas las variables de las entradas deben ser del mismo tipo
de datos.
Si el valor de la entrada MN es mayor que el de la entrada MX, el resultado será el valor
indicado en el parámetro IN.

Programación del PLC
Manual de programación y manejo, 11/2019

1419

Instrucciones
4.1 Instrucciones
El valor de la salida OUT no es válido si se cumple una de las siguientes condiciones:
● Las variables indicadas no son del mismo tipo de datos.
● Un operando tiene un valor no válido.
● El valor del parámetro MN es mayor que el valor del parámetro MX.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Ajustar valor límite":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MN

Input

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P o
constante

Límite inferior

IN

Input

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P o
constante

Valor de entrada

MX

Input

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P o
constante

Límite superior

OUT

Output

Enteros, números
en coma flotante,
TIME, LTIME,
TOD, LTOD, DA‐
TE, LDT

I, Q, M, D, L, P

Resultado

Los tipos de datos TOD, LTOD, DATE y LDT solo se pueden utilizar cuando la verificación CEI está
desactivada.

En la lista desplegable "???" puede seleccionar el tipo de datos para los parámetros MN, IN,
MX y OUT.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL LIMIT

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

1420

MN := "Tag_LowLimit"

// Límite inferior

IN := "Tag_InputValue"

// Valor de entrada

MX := "Tag_HighLimit"

// Límite superior

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

OUT := "Tag_Result"

// El operando "Tag_Result" se describe con el valor
del operando "Tag_LowLimit", ya que el valor del operando "Tag_InputValue" se encuentra fuera del área límite definida.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

MN

Tag_LowLimit

12000

IN

Tag_InputValue

8000

MX

Tag_HighLimit

16000

OUT

Tag_Result

12000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Consulta y activación de los bits de estado en AWL (Página 199)
Bases de AWL (Página 8065)

Transferencia
MOVE: Copiar valor
Descripción
La instrucción "Copiar valor" transfiere el contenido del operando de la entrada IN al operando
de la salida OUT. El tipo de datos de los operandos en la entrada IN y en la salida OUT debe
ser idéntico.
La tabla siguiente muestra las posibles transferencias:
Origen (IN)

Destino (OUT)

BYTE

BYTE

WORD

WORD

DWORD

DWORD

LWORD

LWORD

SINT

SINT

USINT

USINT

INT

INT

UINT

UINT

DINT

DINT

UDINT

UDINT

LINT

LINT

ULINT

ULINT

Programación del PLC
Manual de programación y manejo, 11/2019

1421

Instrucciones
4.1 Instrucciones
Origen (IN)

Destino (OUT)

REAL

REAL

LREAL

LREAL

S5TIME

S5TIME

TIME

TIME

LTIME

LTIME

DATE

DATE

DT

DT

LDT

LDT

TOD

TOD

LTOD

LTOD

DTL

DTL

CHAR

CHAR

WCHAR
Carácter de una cadena

WCHAR
1)

Carácter de una cadena

ARRAY

ARRAY

STRUCT

STRUCT

Tipo de datos PLC (UDT)

Tipo de datos PLC (UDT)

IEC_TIMER

IEC_TIMER

IEC_LTIMER

IEC_LTIMER

IEC_SCOUNTER

IEC_SCOUNTER

IEC_USCOUNTER

IEC_USCOUNTER

IEC_COUNTER

IEC_COUNTER

IEC_UCOUNTER

IEC_UCOUNTER

IEC_DCOUNTER

IEC_DCOUNTER

IEC_UDCOUNTER

IEC_UDCOUNTER

IEC_LCOUNTER

IEC_LCOUNTER

IEC_ULCOUNTER

IEC_ULCOUNTER

DB_ANY

DB_ANY

REF()

No se realiza ninguna conversión del tipo de datos. La variable
transferida debe coincidir exactamente con el tipo de datos de
destino.

La instrucción "Copiar valor" también permite transferir caracteres individuales de una
cadena a operandos del tipo de datos CHAR o WCHAR. El número del carácter que se va a
transferir se indica entre corchetes al lado del nombre del operando. Si se indica "MyString[2]",
se transfiere p. ej. el segundo carácter de la cadena de caracteres "MyString". Asimismo, es
posible transferir operandos del tipo de datos CHAR a caracteres individuales de una cadena
de caracteres. También es posible reemplazar un carácter específico de una cadena de
caracteres por el carácter de otra cadena de caracteres.
1)

Para copiar operandos del tipo de datos ARRAY pueden utilizarse también las instrucciones
"Copiar área" (MOVE_BLK) y "Copiar área sin interrupciones" (UMOVE_BLK) y "Copiar área"
(MOVE_BLK_VARIANT). Los operandos del tipo de datos STRING se pueden copiar con la
instrucción "Desplazar cadena de caracteres" (S_MOVE).

1422

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Copiar valor":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

I, Q, M, D, L o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, fecha y ho‐
ra, secuencias de
caracteres,
ARRAY, tipos de
datos CEI, tipo de
datos PLC (UDT),
DB_ANY

Elemento con el que se so‐
brescribe la dirección de des‐
tino

OUT

Output

I, Q, M, D, L
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, fecha y ho‐
ra, secuencias de
caracteres,
ARRAY, tipos de
datos CEI, tipo de
datos PLC (UDT),
DB_ANY

Dirección de destino

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL MOVE

// Se llama la instrucción.

IN := "TagIn_LREAL"

// Se copia el contenido del operando "TagIn_LREAL".

OUT := "TagOut_LREAL"

// Y se transfiere al operando "TagOut_LREAL".

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Valor

IN

TagIn_LREAL

1,23456789098e55

OUT

TagOut_LREAL

1,23456789098e55

Programación del PLC
Manual de programación y manejo, 11/2019

1423

Instrucciones
4.1 Instrucciones

Nota
Encontrará más información sobre la instrucción MOVE en el Siemens Industry Online
Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

Deserialize: Deserializar
Descripción
La instrucción "Deserializar" reconvierte la forma de representación secuencial de un tipo de
datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> y rellena todo su contenido.
El área de memoria en la que se encuentra la forma de representación secuencial de un tipo
de datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> debe ser del tipo de datos ARRAY
of BYTE o ARRAY of CHAR y tener declarado el acceso estándar en la versión 1.0. A partir de
la versión 2.0 se permiten también áreas de memoria optimizadas. La capacidad del área de
memoria estándar es de 64 KB. Antes de la conversión asegúrese de que hay suficiente
memoria disponible. Si el área de memoria se ha rellenado utilizando la instrucción "Serializar"
y se han insertado bytes de relleno, estos no se tendrán en cuenta en la conversión.
Se recomienda definir a "0" el límite inferior del ARRAY, ya que entonces el índice dentro del
ARRAY se corresponde con el valor del parámetro POS, p. ej. ARRAY[0] = POS 0. La
descripción y el ejemplo que sigue más abajo se basan en estos fundamentos.
Esta instrucción reconvierte paso a paso a su estado original varias formas de representación
secuenciales de datos convertidos.
Para reconvertir una sola forma de representación secuencial de un tipo de datos PLC (UDT),
STRUCT o ARRAY of <tipo de datos> también se puede utilizar directamente la instrucción
"TRCV: Recibir datos a través de la conexión".

Tamaño del área de memoria
Debido a las reglas de alineación, no se insertan bytes de relleno en las estructuras sencillas
del área de memoria optimizada. Por consiguiente, una estructura del área de memoria
optimizada es más pequeña que en el área de memoria estándar. Los ARRAY de estructuras
y las estructuras anidadas tienen bytes de relleno. Por lo general no es posible saber de
antemano en qué área de memoria requiere más espacio una estructura compuesta.

1424

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Válido para las CPU de la serie S7-1500:
En un bloque con la propiedad "Acceso optimizado al bloque", el BOOL tiene una longitud de
1 byte. Esto hace que una estructura, que básicamente está formada por el tipo de datos
BOOL, sea mayor en el área de memoria optimizada que en el área de memoria estándar. Las
estructuras compuestas con un porcentaje reducido de tipos de datos BOOL son menores en
el área de memoria optimizada que en el área de memoria estándar.

Área de memoria optimizada
Para deserializar estructuras de mayor tamaño, el área de memoria para la representación
secuencial puede declararse también con acceso optimizado a partir de la versión de firmware
>= 4.2 de las CPU de la serie S7-1200 y a partir de la versión de firmware >= 2.0 de las CPU
de la serie S7-1500. El contenido de la representación secuencial no cambia, igual que en un
área de memoria estándar. El acceso a los bytes del ARRAY solo es posible simbólicamente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Deserializar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRC_ARRA
Y

Input

ARRAY[*] of
BYTE 1)

I, Q, D, interfaz de
bloque de un FB
(son posibles las
secciones Input,
Output, Static y
Temp).

ARRAY of BYTE o ARRAY of
CHAR, en el que se guarda el
flujo de datos que debe dese‐
rializarse.

o bien
ARRAY of CHAR

S7-1500:

Para obtener el máximo ren‐
ningún dato de pe‐ dimiento, no transfiera valo‐
riferia
res a este parámetro con un
puntero VARIANT.
DEST_VA‐
RIABLE

InOut

Todos los tipos de
datos

I, Q, D, interfaz de
bloque de un FB.

Variable, en la que se escri‐
birán los datos deserializa‐
ningún dato de pe‐ dos.
riferia
S7-1500:
Para obtener el máximo ren‐
dimiento, no transfiera valo‐
res a este parámetro con un
puntero VARIANT.

POS

InOut

DINT

I, Q, M, D, L

El operando del parámetro
POS almacena el índice del
primer byte tras el número de
bytes que ocupan los datos
de cliente convertidos. El pa‐
rámetro POS se calcula ba‐
sado en cero.

RET_VAL

Output

INT

I, Q, M, D, L

Información de error

Posible con CPU de la serie S7-1200 a partir de la versión de firmware >= 4.2 y con CPU de la serie
S7-1500 a partir de la versión de firmware >= 2.0
1)

Programación del PLC
Manual de programación y manejo, 11/2019

1425

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B0

Las áreas de memoria de los parámetros SRC_ARRAY y DEST_VARIABLE se solapan.

8136

La variable del parámetro SRC_ARRAY no está en un bloque con acceso estándar.

8150

El tipo de datos VARIANT del parámetro SRC_ARRAY contiene un puntero IGUAL A
CERO.

8151

El parámetro SRC_ARRAY no tiene una referencia válida.

8153

En el parámetro SRC_ARRAY no hay suficiente espacio de memoria disponible.

8154

Tipo de datos no válido en el parámetro SRC_ARRAY

8250

En el parámetro DEST_ARRAY se ha transferido un puntero CERO.

8251

El parámetro DEST_VARIABLE no tiene una referencia válida.

8382

El valor del parámetro POS se encuentra fuera de los valores límite del array.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 4.2 (S7-1200) y 2.0 (S7-1500):
El código de error siguiente tiene un significado distinto:
Código de
error*
(W#16#...)

Explicación

8136

El acceso al área de memoria en el parámetro SRC_ARRAY no es válido.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 2.8 (S7-1500):
El rendimiento de la instrucción "Deserializar" (versión 2.1) mejora si no se transfieren valores
a los parámetros SRC_ARRAY y DEST_VARIABLE con un puntero VARIANT, sino con un tipo
de datos concreto.
Tenga en cuenta que el comportamiento erróneo de la instrucción cambia en este caso. En
determinados escenarios de error, la CPU no devuelve códigos de error, sino que pasa a
STOP con un error de acceso. Para evitar que esto ocurra, utilice el tratamiento de errores local
con las instrucciones "GET_ERROR" y "GET_ERR_ID".

1426

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
La tabla siguiente muestra la declaración de los operandos:
Operando

Tipo de datos

Declaración

DeliverPos

INT

En la sección "Input" de la inter‐
faz del bloque de un FB o una FC

BufferPos

DINT

En la sección "Temp" de la inter‐
faz del bloque de un FB o una FC

Error

INT

Label

STRING[4]

cmp

BOOL

La siguiente tabla muestra la declaración de los tipos de datos PLC:
Nombre de los tipos de datos
PLC

Nombre

Tipo de datos

Article

Number

DINT

Declaration

STRING

Colli

INT

Title

INT

First name

STRING[10]

Surname

STRING[10]

Client

La tabla siguiente muestra la declaración de los bloques de datos:
Nombre de los bloques de datos Nombre

Tipo de datos

Target

Client

"Client" (tipo de datos PLC)

Article

Array[0..10] of "Article" (tipo de
datos PLC)

Bill

Array[0..10] of INT

Field

Array[0..294] of BYTE

Buffer

El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Significado

L 0

// El valor "0" se carga en el acumulador
1.

T #BufferPos

// El valor "0" se transfiere al operando
#BufferPos.

CALL Deserialize

// Se llama la instrucción.

SRC_ARRAY := "Buffer".Field

// Se deserializan los datos de cliente
de la variable "Buffer".

RET_VAL := #Error

// Información de error

DEST_VARIABLE := "Target".Client

// Los datos de cliente deserializados se
escriben en la variable "Target".

POS := #BufferPos

El operando #BufferPos almacena el índice
del primer byte tras el número de bytes
que ocupan los datos de cliente convertidos.

Programación del PLC
Manual de programación y manejo, 11/2019

1427

Instrucciones
4.1 Instrucciones
AWL

Significado

AN BR
JC end

// Si ocurre un error durante la ejecución de la instrucción, la ejecución del
programa salta al final.

CALL Deserialize

// Se llama la instrucción.

SRC_ARRAY := "Buffer".Field

// Se deserializa el separador de la variable "Buffer". El separador se ha insertado en forma de caracteres 'arti' o
'Bill' para poder diferenciar mejor los
datos de cliente.

RET_VAL := #Error

// Información de error

DEST_VARIABLE := #Label

// Los caracteres deserializados del separador se escriben en el operando #Label.

POS := #BufferPos

// El número de bytes que ocupan los caracteres convertidos se guarda en el operando #BufferPos.

AN BR
JC end

// Si ocurre un error durante la ejecución de la instrucción, la ejecución del
programa salta al final.

CALL S_COMP

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de
la lista desplegable "???".

IN1 := 'arti'
IN2 := #Label

// Compara los caracteres 'arti' con los
caracteres que se han guardado en el operando #Label.

OUT := #cmp

// Resultado de la instrucción

A #cmp

// Si la comparación devuelve el estado
lógico "0", significa que en el operando
#Label no se encuentran los caracteres
'arti', y la ejecución del programa salta
a la etiqueta "noarticle".

JCN noarticle

CALL Deserialize

// Si el resultado de la comparación =
"1", se llama la instrucción.

SRC_ARRAY := "Buffer".Field

// Los datos de artículo se deserializan.

RET_VAL := #Error

// Información de error

DEST_VARIABLE := "Target".Article[#DeliverPos]

// Los datos de artículo deserializados
se escriben en la variable "Target".

POS := #BufferPos

// El número de bytes que ocupan los datos de artículo convertidos se guarda en
el operando #BufferPos.

AN BR

// Si no se ha producido ningún error durante la ejecución, se alcanza el fin de
bloque.

JC end
BE

1428

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Significado

noarticle: NOP 0

// Si la comparación de si es 'arti' ha
sido = "0", el programa se sigue ejecutando.

CALL S_COMP

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de
la lista desplegable "???".

IN1 := 'Bill'
IN2 := #Label

// Compara los caracteres 'Bill' con los
caracteres que se han guardado en el operando #Label.

OUT := #cmp

// Resultado de la instrucción

A #cmp

// Si la comparación devuelve el estado
lógico "1", significa que en el operando
#Label se encuentran los caracteres
'Bill', y el programa se sigue ejecutando.

JCN end

CALL Deserialize

// Si el resultado de la comparación =
"1", se llama la instrucción.

SRC_ARRAY := "Buffer".Field

// Los datos de cálculo se deserializan.

RET_VAL := #Error

// Información de error

DEST_VARIABLE := "Target".Bill[#DeliverPos]

// Los datos de cliente deserializados se
escriben en la variable "Target".

POS := #BufferPos

// El número de bytes que ocupan los datos de artículo convertidos se guarda en
el operando #BufferPos.

AN BR

// Si no se ha producido ningún error durante la ejecución, se alcanza el fin de
bloque.

JC end
BE
end: CLR

// En caso de error, se salta a la etiqueta "end".

SAVE

// El RLO se guarda en el bit BR.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de VARIANT (Página 335)
Principios básicos de los tipos de datos PLC (UDT) (Página 283)
Estructura de una variable ARRAY (Página 298)

Programación del PLC
Manual de programación y manejo, 11/2019

1429

Instrucciones
4.1 Instrucciones
Estructura de una variable STRUCT (Página 290)
Estructura de una variable STRING (Página 277)
Bytes de relleno cuando se usan tipos de datos estructurados (Página 143)
Bases de AWL (Página 8065)

Serialize: Serializar
Descripción
Mediante la instrucción "Serializar" se convierten varios tipos de datos PLC (UDT), STRUCT
o ARRAY of <tipo de datos> a una forma de representación secuencial sin que se pierdan
partes de su estructura.
La instrucción permite guardar temporalmente varios datos estructurados del programa en un
búfer, ubicado preferentemente en un bloque de datos global, y enviarlos a otra CPU. El área
de memoria en la que se depositen los datos convertidos debe ser del tipo de datos ARRAY of
BYTE o ARRAY of CHAR y tener declarado el acceso estándar en la versión 1.0. A partir de
la versión 2.0 se permiten también datos optimizados. Los datos de relleno del área de datos
del origen no están definidos en el ARRAY de destino. Pueden ser tanto bytes o bits de relleno
de un área de datos (p. ej., ARRAY, STRUCT o tipo de datos PLC (UDT)) como los caracteres
de una cadena que no se utilicen en ese momento.
La capacidad del área de memoria estándar es de 64 KB. Las estructuras mayores que 64 KB
según las reglas para áreas de memoria estándar no pueden serializarse si el operando del
parámetro DEST_ARRAY está en un área de memoria estándar.
Se recomienda definir a "0" el límite inferior del ARRAY, ya que entonces el índice dentro del
ARRAY se corresponde con el valor del parámetro POS, p. ej. ARRAY[0] = POS 0. La
descripción y el ejemplo que sigue más abajo se basan en estos fundamentos.
El operando del parámetro POS contiene la información sobre el número de bytes que ocupan
los datos convertidos.
Para enviar un solo tipo de datos PLC (UDT), STRUCT o ARRAY of <tipo de datos> se puede
llamar directamente la instrucción "TSEND: Enviar datos a través de la conexión".

Tamaño del área de memoria
Debido a las reglas de alineación, no se insertan bytes de relleno en las estructuras sencillas
del área de memoria optimizada. Por consiguiente, una estructura del área de memoria
optimizada es más pequeña que en el área de memoria estándar. Los ARRAY de estructuras
y las estructuras anidadas tienen bytes de relleno. Por lo general no es posible saber de
antemano en qué área de memoria requiere más espacio una estructura compuesta.
Válido para las CPU de la serie S7-1500:
En un bloque con la propiedad "Acceso optimizado al bloque", la longitud del BOOL depende
del tipo de datos que sigue. Por ejemplo, si lo que sigue es un BYTE, el BOOL tiene una
longitud de 1 byte. Si lo que sigue es WORD, el BOOL tiene una longitud de 2 bytes. Esto hace
que una estructura, que básicamente está formada por el tipo de datos BOOL, sea mayor en
el área de memoria optimizada que en el área de memoria estándar. Las estructuras

1430

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
compuestas con un porcentaje reducido de tipos de datos BOOL son menores en el área de
memoria optimizada que en el área de memoria estándar.
Por eso se recomienda que el área de datos de origen para la serialización empiece con tipos
de datos grandes y termine con elementos booleanos. De este modo se reduce
considerablemente el relleno con bits de relleno.

Área de memoria optimizada
Para serializar estructuras de mayor tamaño, el área de memoria puede declararse también
con acceso optimizado a partir de la versión de firmware >= 4.2 de las CPU de la serie S7-1200
y a partir de la versión de firmware >= 2.0 de las CPU de la serie S7-1500. La representación
secuencial no cambia, igual que en un área de memoria estándar.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Serializar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRC_VARIA‐ Input
BLE

Todos los tipos de
datos

I, Q, D, interfaz de Variable que se serializará.
bloque de un FB,
S7-1500:
ningún dato de pe‐
Para obtener el máximo ren‐
riferia
dimiento, no transfiera valo‐
res a este parámetro con un
puntero VARIANT.

DEST_ARRA InOut
Y

ARRAY of BYTE o
ARRAY of CHAR

I, Q, D, interfaz de
bloque de un FB
(son posibles las
secciones Input,
Output, Static y
Temp).

Array en el que se guarda el
flujo de datos generado.
S7-1500:

Para obtener el máximo ren‐
dimiento, no transfiera valo‐
res a este parámetro con un
ningún dato de pe‐ puntero VARIANT.
riferia
POS

InOut

DINT

I, Q, M, D, L

El operando del parámetro
POS almacena el índice del
primer byte tras el número to‐
tal de bytes que han ocupado
los datos de cliente converti‐
dos. El parámetro POS se
calcula basado en cero.

RET_VAL

Output

INT

I, Q, M, D, L

Información de error

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B0

Las áreas de memoria de los parámetros SRC_VARIABLE y DEST_ARRAY se solapan.

Programación del PLC
Manual de programación y manejo, 11/2019

1431

Instrucciones
4.1 Instrucciones
Código de
error*
(W#16#...)

Explicación

8150

El tipo de datos VARIANT del parámetro SRC_VARIABLE contiene un puntero IGUAL A
CERO.

8151

El parámetro SRC_VARIABLE no tiene una referencia válida.

8236

La variable del parámetro SRC_ARRAY no está en un bloque con acceso estándar.

8250

En el parámetro DEST_ARRAY se ha transferido un puntero CERO.

8251

El parámetro DEST_ARRAY no tiene una referencia válida.

8253

La variable del parámetro DEST_ARRAY no ofrece suficiente espacio de memoria para
el contenido de la variable del parámetro SRC_VARIABLE. El valor de entrada de la
variable del parámetro POS reduce el espacio de memoria disponible. El valor de entrada
del parámetro POS determina en qué posición de la variable se comienza en el parámetro
DEST_ARRAY.

8254

Tipo de datos no válido en el parámetro DEST_ARRAY

8382

El valor del parámetro POS se encuentra fuera de los valores límite del array.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 4.2 (S7-1200) y 2.0 (S7-1500):
El código de error siguiente tiene un significado distinto:
Código de
error*
(W#16#...)

Explicación

8236

El acceso al área de memoria en el parámetro DEST_ARRAY no es válido.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Particularidades a partir de la versión de firmware 2.8 (S7-1500):
El rendimiento de la instrucción "Serializar" (versión 2.1) mejora si no se transfieren valores a
los parámetros SRC_VARIABLE y DEST_ARRAY con un puntero VARIANT, sino con un tipo
de datos concreto.
Tenga en cuenta que el comportamiento erróneo de la instrucción cambia en este caso. En
determinados escenarios de error, la CPU no devuelve códigos de error, sino que pasa a
STOP con un error de acceso. Para evitar que esto ocurra, utilice el tratamiento de errores local
con las instrucciones "GET_ERROR" y "GET_ERR_ID".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1432

AWL

Explicación

L 0

// El valor "0" se carga en el acumulador 1.

T #BufferPos

// El valor "0" se transfiere al operando
#BufferPos.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

CALL Serialize

// Se llama la instrucción.

SRC_VARIABLE := "Source".Client

// Se serializan los datos de cliente de la
variable "Source".

RET_VAL := #Error

// Información de error

DEST_ARRAY := "Buffer".Field

// La representación secuencial se escribe en
la variable "Buffer".

POS := #BufferPos

// El índice del siguiente byte no escrito del
operando "Buffer".Field se guarda en el operando #BufferPos.

CALL S_MOVE

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la
lista desplegable "???".

IN := 'arti'
OUT := #Label

// Los caracteres 'arti' se copian en el operando #Label.

CALL Serialize

// Se llama la instrucción.

SRC_VARIABLE := #Label

// Los caracteres se serializan.

RET_VAL := #Error

// Información de error

DEST_ARRAY := "Buffer".Field

// La representación secuencial se escribe,
tras los datos de cliente, en la variable
"Buffer".Field.

POS := #BufferPos

Se incrementa correspondientemente el valor
del operando "#BufferPos".

CALL Serialize

// Se llama la instrucción.

SRC_VARIABLE := "Source".Article[#De- // Se serializan los datos de un determinado
liverPos]
artículo de la variable "Source".
RET_VAL := #Error

// Información de error

DEST_ARRAY := "Buffer".Field

// La representación secuencial se escribe,
tras el carácter 'arti', en la variable "Buffer".

POS := #BufferPos

// Número de bytes

La tabla siguiente muestra la declaración de los operandos:
Operando

Tipo de datos

Declaración

DeliverPos

INT

En la sección "Input" de la inter‐
faz del bloque

BufferPos

DINT

En la sección "Temp" de la inter‐
faz del bloque

Error

INT

En la sección "Temp" de la inter‐
faz del bloque

Label

STRING[4]

En la sección "Temp" de la inter‐
faz del bloque

Programación del PLC
Manual de programación y manejo, 11/2019

1433

Instrucciones
4.1 Instrucciones
La siguiente tabla muestra la declaración de los tipos de datos PLC:
Nombre de los tipos de datos
PLC

Nombre

Tipo de datos

Article

Number

DINT

Declaration

STRING

Colli

INT

Title

INT

First name

STRING[10]

Surname

STRING[10]

Client

La tabla siguiente muestra la declaración de los bloques de datos:
Nombre de los bloques de datos Nombre

Tipo de datos

Source

Client

"Client" (tipo de datos PLC)

Article

Array[0..10] of "Article" (tipo de
datos PLC)

Field

Array[0..294] of BYTE

Buffer

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de VARIANT (Página 335)
Principios básicos de los tipos de datos PLC (UDT) (Página 283)
Estructura de una variable ARRAY (Página 298)
Estructura de una variable STRUCT (Página 290)
Estructura de una variable STRING (Página 277)
Bytes de relleno cuando se usan tipos de datos estructurados (Página 143)
Bases de AWL (Página 8065)

MOVE_BLK: Copiar área
Descripción
La instrucción "Copiar área" copia los contenidos de un área de memoria (área de origen) en
un área de memoria diferente (área de destino). El número de elementos que se copian en el
área de destino se determina con el parámetro COUNT. El ancho del elemento del parámetro
IN define el ancho de los elementos que deben copiarse.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.

1434

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El valor de la salida OUT no es válido si se copian más datos de los que están disponibles en
el parámetro IN o en el parámetro OUT.
Nota
Uso de ARRAYs
La instrucción copia el contenido a partir del elemento definido n elementos (n = depende del
valor del parámetro COUNT) desde el área de origen al área de destino, comenzando por el
índice especificado.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Copiar área":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

D, L

Primer elemento del área de
origen que se copia

COUNT

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P o
constante

Número de elementos que
se copian del área de origen
al área de destino

OUT 1)

Output

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

D, L

Primer elemento del área de
destino en la que se copian
los contenidos del área de
origen

1)

1)

Los tipos de datos indicados solamente pueden utilizarse como elementos de una estructura Array.

En las listas desplegables "???" puede seleccionar los tipos de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL MOVE_BLK

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := #a_array[2]

// Primer elemento desde el que se copia.

COUNT := "Tag_Count"

// Número de elementos que se copian al área de destino.

OUT := #b_array[1]

// Primer elemento en el que se copia.

Programación del PLC
Manual de programación y manejo, 11/2019

1435

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

a_array[2]

El operando "a_array" es del tipo
de datos ARRAY[0..5] of INT.
Consta de 6 elementos del tipo
de datos INT.

COUNT

Tag_Count

3

OUT

b_array[1]

El operando "b_array" es del tipo
de datos ARRAY[0..6] of INT.
Consta de 7 elementos del tipo
de datos INT.

La instrucción selecciona a partir del tercer elemento tres elementos INT de la variable
#a_array y copia su contenido en la variable de salida #b_array, comenzando por el segundo
elemento.
Nota
Encontrará más información sobre la instrucción MOVE_BLK en el Siemens Industry Online
Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

MOVE_BLK_VARIANT: Copiar área
Descripción
La instrucción "Copiar área" copia los contenidos de un área de memoria (área de origen) en
un área de memoria diferente (área de destino). Se pueden copiar elementos de un ARRAY o
un ARRAY completo en otro ARRAY del mismo tipo de datos. El tamaño (número de
elementos) de los ARRAY de origen y de destino puede diferir. Se pueden copiar varios
elementos dentro de un mismo ARRAY o bien copiar elementos individuales.
El número de elementos que deben copiarse no puede rebasar el área de origen o destino
seleccionado.
Cuando se utiliza la instrucción no es necesario conocer el ARRAY en el momento de crear el
bloque, puesto que el origen y el destino se transfieren vía VARIANT.

1436

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El recuento en los parámetros SRC_INDEX y DEST_INDEX comienza siempre por el límite
inferior "0", independientemente de la declaración posterior del ARRAY.
La instrucción no se ejecuta si se copian más datos de los que están disponibles.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Copiar área":
Parámetros

Declaración

Tipo de datos

Área de memoria

SRC

Input

VARIANT (que
apunta a un
ARRAY o a un ele‐
mento individual
del ARRAY),
ARRAY of <tipo de
datos>

L (puede declarar‐ El área de origen de la que se
se en las seccio‐
copia
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

COUNT

Input

UDINT

I, Q, M, D, L o
constante

2)

Descripción

Número de elementos que
se copian
Asigne al parámetro COUNT
el valor "1" si en el parámetro
SRC o en el parámetro DEST
no hay indicado ningún
ARRAY.

SRC_INDEX

Input

DINT

I, Q, M, D, L o
constante

Define el primer elemento
que se copia:
● El parámetro
SRC_INDEX se calcula
basado en cero. Si en el
parámetro SRC hay
indicado un ARRAY, el
entero del parámetro
SRC_INDEX indica el
primer elemento del área
de origen de la que debe
copiarse. Esto es así
independientemente de
los límites declarados del
ARRAY.
● Si en el parámetro SRC
no hay indicado ningún
ARRAY o solo un
elemento individual de un
ARRAY, asigne el valor
"0" al parámetro
SRC_INDEX.

Programación del PLC
Manual de programación y manejo, 11/2019

1437

Instrucciones
4.1 Instrucciones
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

DEST_IN‐
DEX

Input

DINT

I, Q, M, D, L o
constante

Define el inicio del área de
memoria de destino:
● El parámetro
DEST_INDEX se calcula
basado en cero. Si en el
parámetro DEST hay
indicado un ARRAY, el
entero del parámetro
DEST_INDEX indica el
primer elemento del área
de destino en la que debe
copiarse. Esto es así
independientemente de
los límites declarados del
ARRAY.
● Si en el parámetro DEST
no hay indicado ningún
ARRAY, asigne el valor
"0" al parámetro
DEST_INDEX.

DEST

Output 1)

VARIANT

L (puede declarar‐ Área de destino a la que se
se en las seccio‐
copia el contenido del área
nes "Input",
de origen.
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

INT

I, Q, M, D, L

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

1) El parámetro DEST está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.
2) En el parámetro SRC, los tipos de datos BOOL y ARRAY of BOOL no están permitidos.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)

1438

0000

Ningún error

80B4

Los tipos de datos no coinciden. En lugar de un ARRAY of Struct utilice un ARRAY of tipo
de datos PLC (UDT).

8151

No es posible acceder al parámetro SRC.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*

Explicación

(W#16#...)
8152

El operando del parámetro SRC no está tipificado.

8153

Error de creación de código en el parámetro SRC

8154

El operando del parámetro SRC es del tipo de datos BOOL.

8281

Valor no válido en el parámetro COUNT

8382

El valor del parámetro SRC_INDEX es menor que CERO.

8383

El valor del parámetro SRC_INDEX se encuentra fuera del límite superior del ARRAY.

8482

El valor del parámetro DEST_INDEX se encuentra fuera de los límites del ARRAY.

8483

El ARRAY al que señala el parámetro DEST es demasiado pequeño para los datos que
deben copiarse.

8534

El parámetro DEST está protegido contra escritura

8551

No es posible acceder al parámetro DEST.

8552

El operando del parámetro DEST no está tipificado.

8553

Error de creación de código en el parámetro DEST

8554

El operando del parámetro DEST es del tipo de datos BOOL.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL MOVE_BLK_VARIANT

// Se llama a la instrucción.

SRC := #SrcField

// Primer elemento que se copia

COUNT := "Tag_Count"

// Número de elementos que se copian al área
de destino.

SRC_INDEX := "Tag_Src_Index"

// Primer elemento del parámetro SRC que se
copia

DEST_INDEX := "Tag_Dest_Index"

// Primer elemento del parámetro DEST que se
copia

DEST := #DestField

// Primer elemento del área de origen que se
copia.

RET_VAL := "Tag_Result"

// Información de error

Programación del PLC
Manual de programación y manejo, 11/2019

1439

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetros

Declaración en la inter‐
faz del bloque

Operando

Valor

SRC

Input

#SrcField

El operando local
#SrcField utiliza un tipo
de datos PLC todavía
desconocido en el mo‐
mento de programar el
bloque. (ARRAY[0..10]
of "MOVE_UDT"

COUNT

Input

Tag_Count

2

SRC_INDEX

Input

Tag_Src_Index

3

DEST_INDEX

Input

Tag_Dest_Index

3

DEST

InOut

#DestField

El operando local
#DestField utiliza un ti‐
po de datos PLC toda‐
vía desconocido en el
momento de programar
el bloque.
(ARRAY[10..20] of "MO‐
VE_UDT"

En el área de destino se copian dos elementos del área de origen, empezando por el cuarto
elemento del ARRAY[0..10] of MOVE_UDT. Las copias se insertan en el ARRAY[10..20] of
MOVE_UDT a partir del cuarto elemento.
Nota
Encontrará más información sobre la instrucción MOVE_BLK_VARIANT en el Siemens
Industry Online Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Principios básicos de VARIANT (Página 335)
Bases de AWL (Página 8065)

1440

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

UMOVE_BLK: Copiar área sin interrupciones
Descripción
La instrucción "Copiar área sin interrupciones" copia sin interrupciones los contenidos de un
área de memoria (área de origen) en un área de memoria diferente (área de destino). El
número de elementos que se copian en el área de destino se determina con el parámetro
COUNT. El ancho del elemento de la entrada IN define el ancho de los elementos que deben
copiarse.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
Nota
La operación de copia no debe ser interrumpida por otras actividades del sistema operativo.
Por este motivo, los tiempos de reacción a alarmas de la CPU podrían aumentar al ejecutar la
instrucción "Copiar área sin interrupciones".
El valor de la salida OUT no es válido si se copian más datos de los que están disponibles en
el parámetro IN o en el parámetro OUT.
La instrucción "Copiar área sin interrupciones" permite copiar 16 KB como máximo. A este
respecto deben tenerse en cuenta las limitaciones específicas de la CPU.
Nota
Uso de ARRAYs
La instrucción copia el contenido a partir del elemento definido n elementos (n = depende del
valor del parámetro COUNT) desde el área de origen al área de destino, comenzando por el
índice especificado.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Copiar área sin interrupciones":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN 1)

Input

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

D, L

Primer elemento del área de
origen que se copia

COUNT

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P o
constante

Número de elementos que
se copian del área de origen
al área de destino

Programación del PLC
Manual de programación y manejo, 11/2019

1441

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OUT 1)

Output

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

D, L

Primer elemento del área de
destino en la que se copian
los contenidos del área de
origen

1)

Los tipos de datos indicados solamente pueden utilizarse como elementos de una estructura Array.

En las listas desplegables "???" puede seleccionar los tipos de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL UMOVE_BLK

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := #a_array[2]

// Primer elemento desde el que se copia.

COUNT := "Tag_Count"

// Número de elementos que se copian al área de destino.

OUT := #b_array[1]

// Primer elemento en el que se copia.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

a_array[2]

El operando "a_array" es del tipo
de datos ARRAY[0..5] of INT.
Consta de 6 elementos del tipo
de datos INT.

COUNT

Tag_Count

3

OUT

b_array[1]

El operando "b_array" es del tipo
de datos ARRAY[0..6] of INT.
Consta de 7 elementos del tipo
de datos INT.

La instrucción selecciona a partir del tercer elemento tres elementos INT de la variable
#a_array y copia su contenido en la variable de salida #b_array, comenzando por el segundo

1442

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
elemento. La operación de copia no debe ser interrumpida por otras actividades del sistema
operativo.
Nota
Encontrará más información sobre la instrucción UMOVE_BLK en el Siemens Industry Online
Support, en el artículo siguiente:
¿Cómo se copian áreas de memoria y datos estructurados entre dos bloques de datos en
STEP 7 (TIA Portal)?
https://support.industry.siemens.com/cs/ww/es/view/42603881 (https://
support.industry.siemens.com/cs/ww/es/view/42603881)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

FILL_BLK: Rellenar área
Descripción
La instrucción "Rellenar área" permite rellenar un área de memoria (área de destino) con el
valor de la entrada IN. El área de destino se rellena a partir de la dirección indicada en la salida
OUT. El número de repeticiones de copia se determina mediante el parámetro COUNT. Al
ejecutar la instrucción, el valor de la entrada IN se copia en el área de destino el número de
veces especificado por el valor del parámetro COUNT.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
Como máximo se modifican tantos elementos como tiene el ARRAY o la estructura. Si se
copian más datos que los elementos disponibles en la salida OUT, el resultado no será el
deseado.
Nota
Uso de ARRAYs
La instrucción lee en el área de origen el contenido del elemento seleccionado y lo copia n
veces (n = depende del valor del parámetro COUNT) en el área de destino, comenzado a partir
del índice especificado.

Programación del PLC
Manual de programación y manejo, 11/2019

1443

Instrucciones
4.1 Instrucciones

Rellenar estructuras
Además de los elementos de un ARRAY, también es posible rellenar varios elementos de una
estructura (STRUCT, tipo de datos PLC) con el mismo valor. La estructura cuyos elementos
deben rellenarse puede contener únicamente elementos individuales del mismo tipo de datos
elemental. No obstante, la estructura propiamente dicha puede estar incrustada en otra
estructura.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Rellenar área":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

I, Q, M, D, L, P o
constante

Elemento con el que se relle‐
na el área de destino

COUNT

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P o
constante

Número de repeticiones de
copia

OUT

Output

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

D, L

Dirección del área de destino
a partir de la cual se rellena

En las listas desplegables "???" puede seleccionar los tipos de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
El siguiente ejemplo muestra el funcionamiento de la instrucción cuando debe rellenarse un
ARRAY:
AWL

Explicación

CALL FILL_BLK

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

1444

IN := #FillValue

// Valor que se va a copiar

COUNT := "Tag_Count"

// Número de repeticiones de copia

OUT := #TargetArea[1]

// El área de destino se rellena a partir del primer
elemento del ARRAY #TargetArea[1..5] of INT

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

FillValue

El operando es del tipo de datos
INT.

COUNT

Tag_Count

3

OUT

TargetArea

El operando TargetArea es del
tipo de datos ARRAY[1..5] of
INT. Consta de 5 elementos del
tipo de datos INT.

La instrucción copia tres veces el valor del operando #FillValue en la variable de salida
#TargetArea, empezando por el primer elemento.

Ejemplos con una estructura
Los siguientes ejemplos muestran el funcionamiento de la instrucción cuando debe rellenarse
una estructura.
Cree un bloque de datos global con los elementos siguientes:
Data_block_1

Tipo de datos

MyStruct1

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

MyStruct2

STRUCT

SubArray

ARRAY[1..2] of STRUCT

SubArray[1]

STRUCT

NestedStruct

INT

Member_2

INT

Member_3

INT

Member_4

INT

SubArray[2]

STRUCT

Nes‐
tedStruct

Programación del PLC
Manual de programación y manejo, 11/2019

STRUCT

Member_1

STRUCT
Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

1445

Instrucciones
4.1 Instrucciones
Cree el código de programa siguiente para direccionar la variable MyStruct1:
AWL

Explicación

CALL FILL_BLK

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := 10

// Valor que se va a copiar

COUNT := 2

// Número de repeticiones de copia

OUT := "Data_block_1".MyStruct1.Member_2

// La estructura se rellena a partir de Member_2. Esto
significa que Member_1 y Member_4 no cambian.

Cree el código de programa siguiente para direccionar la variable MyStruct2:
AWL

Explicación

CALL FILL_BLK

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := 10

// Valor que se va a copiar

COUNT := 2

// Número de repeticiones de copia

OUT := "Data_block_1".MyStruct2.

// La estructura se rellena a partir de Member_2. Esto
significa que Member_1 y Member_4 no cambian.

SubArray[1].Member_2

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

UFILL_BLK: Rellenar área sin interrupciones
Descripción
La instrucción "Rellenar área sin interrupciones" rellena sin interrupciones un área de memoria
(área de destino) con el valor de la entrada IN. El área de destino se rellena a partir de la
dirección indicada en la salida OUT. El número de repeticiones de copia se determina
mediante el parámetro COUNT. Al ejecutar la instrucción, el valor de la entrada IN se copia en
el área de destino el número de veces especificado por el valor del parámetro COUNT.
Para poder ejecutar la instrucción, el área de origen y el área de destino deben ser del mismo
tipo de datos.
Nota
La operación de copia no debe ser interrumpida por otras actividades del sistema operativo.
Por este motivo, los tiempos de reacción a alarmas de la CPU podrían aumentar al ejecutar la
instrucción "Rellenar área sin interrupciones".

1446

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Como máximo se modifican tantos elementos como tiene el ARRAY o la estructura. Si se
copian más datos que los elementos disponibles en la salida OUT, el resultado no será el
deseado.
Nota
Uso de ARRAYs
La instrucción lee en el área de origen el contenido del elemento seleccionado y lo copia n
veces (n = depende del valor del parámetro COUNT) en el área de destino, comenzado a partir
del índice especificado.
La instrucción "Rellenar área sin interrupciones" permite copiar 16 KB como máximo. A este
respecto deben tenerse en cuenta las limitaciones específicas de la CPU.

Rellenar estructuras
Además de los elementos de un ARRAY, también es posible rellenar varios elementos de una
estructura (STRUCT, tipo de datos PLC) con el mismo valor. La estructura cuyos elementos
deben rellenarse puede contener únicamente elementos individuales del mismo tipo de datos
elemental. No obstante, la estructura propiamente dicha puede estar incrustada en otra
estructura.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Rellenar área sin interrupciones":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

I, Q, M, D, L, P o
constante

Elemento con el que se relle‐
na el área de destino

COUNT

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L, P o
constante

Número de repeticiones de
copia

OUT

Output

Números binarios,
enteros, números
en coma flotante,
temporizadores,
TOD, LTOD, DA‐
TE, CHAR,
WCHAR

D, L

Dirección del área de destino
a partir de la cual se rellena

En las listas desplegables "???" puede seleccionar los tipos de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1447

Instrucciones
4.1 Instrucciones

Ejemplo con un ARRAY
El siguiente ejemplo muestra el funcionamiento de la instrucción cuando debe rellenarse un
ARRAY:
AWL

Explicación

CALL UFILL_BLK

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := #FillValue

// Valor que se va a copiar

COUNT := "Tag_Count"

// Número de repeticiones de copia

OUT := #TargetArea[1]

// El área de destino se rellena a partir del primer
elemento del ARRAY #TargetArea[1..5] of INT

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

IN

FillValue

El operando es del tipo de datos
INT.

COUNT

Tag_Count

3

OUT

TargetArea

El operando TargetArea es del
tipo de datos ARRAY[1..5] of
INT. Consta de 5 elementos del
tipo de datos INT.

La instrucción copia tres veces el valor del operando #FillValue en la variable de salida
#TargetArea, empezando por el primer elemento. La operación de copia no debe ser
interrumpida por otras actividades del sistema operativo.

Ejemplos con una estructura
Los siguientes ejemplos muestran el funcionamiento de la instrucción cuando debe rellenarse
una estructura.
Cree un bloque de datos global con los elementos siguientes:
Data_block_1

Tipo de datos

MyStruct1

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

MyStruct2

1448

STRUCT

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Data_block_1

Tipo de datos

SubArray

ARRAY[1..2] of STRUCT

SubArray[1]

STRUCT

NestedStruct

STRUCT

Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

SubArray[2]

STRUCT

Nes‐
tedStruct

STRUCT
Member_1

INT

Member_2

INT

Member_3

INT

Member_4

INT

Cree el código de programa siguiente para direccionar la variable MyStruct1:
AWL

Explicación

CALL UFILL_BLK

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := 10

// Valor que se va a copiar

COUNT := 2

// Número de repeticiones de copia

OUT := "Data_block_1".MyStruct1.Member_2

// La estructura se rellena a partir de Member_2. Esto
significa que Member_1 y Member_4 no cambian.

Cree el código de programa siguiente para direccionar la variable MyStruct2:
AWL

Explicación

CALL UFILL_BLK

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := 10

// Valor que se va a copiar

COUNT := 2

// Número de repeticiones de copia

OUT := "Data_block_1".MyStruct2.

// La estructura se rellena a partir de Member_2. Esto
significa que Member_1 y Member_4 no cambian.

SubArray[1].Member_2

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

Programación del PLC
Manual de programación y manejo, 11/2019

1449

Instrucciones
4.1 Instrucciones

SCATTER: Dispersión de una secuencia de bits en bits individuales
Descripción
La instrucción "Dispersión de una secuencia de bits en bits individuales" descompone una
variable del tipo de datos BYTE, WORD, DWORD o LWORD en bits individuales y los guarda
en un ARRAY of BOOL, un STRUCT anónimo o un tipo de datos PLC con elementos
booleanos exclusivamente.
Nota
ARRAY of BOOL multidimensional
En la instrucción "Dispersión de una secuencia de bits en bits individuales" no está permitido
utilizar un ARRAY of BOOL multidimensional.
Nota
Longitud del ARRAY, del STRUCT o del tipo de datos PLC
El ARRAY, el STRUCT anónimo o el tipo de datos PLC deben tener tantos elementos como se
especifique en la secuencia de bits.
Es decir, en el tipo de datos BYTE, p. ej., el ARRAY, el STRUCT o el tipo de datos PLC deben
tener exactamente 8 elementos (WORD = 16, DWORD = 32 y LWORD = 64).
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1500 a partir de la versión de firmware
2.1.
De este modo es posible, p. ej., descomponer una palabra de estado y leer y modificar por
índice el estado de los bits individuales. Mediante GATHER pueden juntarse nuevamente los
bits en una secuencia de bits.

1450

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

IN

Input

Tipo de datos

Área de memoria

BYTE, WORD,
I, Q, M, D, L
DWORD, LWORD

Descripción
Secuencia de bits
que se descompo‐
ne.
Los valores no
pueden encontrar‐
se en el área de
periferia o en el
DB de un objeto
tecnológico.

OUT

Output

ARRAY[*] of
BOOL, STRUCT o
tipo de datos PLC

I, Q, M, D, L

*: 8, 16, 32 o 64
elementos

ARRAY, STRUCT
o tipo de datos
PLC en el/los que
se guardan los bits
individuales

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceWord

Input

WORD

DestinationArray

Output

ARRAY[0..15] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL
CALL SCATTER

// Llamada de la instrucción
// Seleccione el tipo de datos deseado de
la lista desplegable "???".

IN := #SourceWord

// El operando #SourceWord del tipo de datos WORD se descompone en sus bits individuales (16) y se asigna a los distintos
elementos del operando #DestinationArray.

OUT := #DestinationArray

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceWord

WORD (16 bits)

OUT

DestinationArray

El operando "DestinationArray"
es del tipo de datos
ARRAY[0..15] of BOOL. Consta
de 16 elementos y, por tanto, tie‐
ne el mismo tamaño que la
WORD que se debe descompo‐
ner.

Programación del PLC
Manual de programación y manejo, 11/2019

1451

Instrucciones
4.1 Instrucciones

Ejemplo con un tipo de datos PLC (UDT)
Cree el siguiente tipo de datos PLC "myBits":

Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceWord

Input

WORD

DestinationUDT

Output

"myBits"

El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL
CALL SCATTER

// Llamada de la instrucción
// Seleccione el tipo de datos deseado de
la lista desplegable "???".

IN := #SourceWord

// El operando #SourceWord del tipo de datos WORD se descompone en sus bits individuales (16) y se asigna a los distintos
elementos del operando #DestinationUDT.

OUT := #DestinationUDT

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:

1452

Parámetro

Operando

Tipo de datos

IN

SourceWord

WORD (16 bits)

OUT

DestinationUDT

El operando "DestinationUDT"
es del tipo de datos PLC (UDT).
Consta de 16 elementos y, por
tanto, tiene el mismo tamaño
que la WORD que se debe des‐
componer.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

SCATTER_BLK: Dispersión de elementos de un ARRAY of secuencia de bits en bits individuales
Descripción
La instrucción "Dispersión de elementos de un ARRAY of secuencia de bits en bits
individuales" descompone uno o varios elementos de un ARRAY of BYTE, WORD, DWORD
o LWORD en bits individuales y los guarda en un ARRAY of BOOL, un STRUCT anónimo o un
tipo de datos PLC con elementos booleanos exclusivamente. En el parámetro COUNT_IN se
introduce el número de elementos del ARRAY de origen que deben dispersarse. El ARRAY de
origen en el parámetro IN puede tener más elementos que los indicados en el parámetro
COUNT_IN. El ARRAY of BOOL, el STRUCT anónimo o el tipo de datos PLC deben tener
suficientes elementos para poder guardar los bits de la secuencia de bits descompuesta. El
área de memoria de destino también puede ser mayor.
Nota
ARRAY of BOOL multidimensional
Si el ARRAY es un ARRAY of BOOL multidimensional, se cuentan también los bits de relleno
de las dimensiones contenidas, aunque no se hayan declarado explícitamente.
Ejemplo 1: un ARRAY[1..10,0..4,1..2] of BOOL recibe el mismo tratamiento que un
ARRAY[1..10,0..4,1..8] of BOOL o que un ARRAY[0..399] of BOOL.
Ejemplo 2: En el parámetro IN hay un ARRAY[0..5] of WORD (sourceArrayWord[2])
interconectado. El parámetro COUNT_IN tiene el valor "3". En el parámetro OUT hay un
ARRAY[0..1,0..5,0..7] of BOOL (destinationArrayBool[0,0,0]) interconectado. Tanto el array
del parámetro IN como el del parámetro OUT tienen 96 bits de tamaño. El ARRAY of WORD
se descompone en 48 bits individuales.
Nota
Si el límite inferior del ARRAY de destino no es "0", cabe considerar lo siguiente:
Por motivos de rendimiento, el índice debe comenzar siempre en un límite de BYTE, WORD
o DWORD. Esto significa que debe calcularse el índice partiendo del límite inferior del ARRAY.
Como base para el cálculo se utiliza la siguiente fórmula:
Índice válido = límite inferior del ARRAY + n(número de secuencias de bits) * número de bits
de la secuencia de bits deseada
Para un ARRAY[-2..45] of BOOL y la secuencia de bits WORD, el cálculo es el siguiente:
● Índice válido (-2) = -2 + 0 * 16
● Índice válido (14) = -2 + 1 * 16
● Índice válido (30) = -2 + 2 * 16
Ver un ejemplo más adelante.

Programación del PLC
Manual de programación y manejo, 11/2019

1453

Instrucciones
4.1 Instrucciones
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1500 a partir de la versión de firmware
2.1.
De este modo es posible, p. ej., descomponer palabras de estado y leer y modificar por índice
el estado de los bits individuales. Mediante GATHER pueden juntarse nuevamente los bits en
una secuencia de bits.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

IN

Input

Tipo de datos
Elemento de un
ARRAY[*] of <se‐
cuencia de bits>

Área de memoria

Descripción

I, Q, M, D, L

ARRAY of <se‐
cuencia de bits>
que se descompo‐
ne.
Los valores no
pueden encontrar‐
se en el área de
periferia o en el
DB de un objeto
tecnológico.

COUNT_IN

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L

Contador del nú‐
mero de elemen‐
tos del ARRAY de
origen que deben
descomponerse.
El valor no puede
encontrarse en el
área de periferia o
en el DB de un ob‐
jeto tecnológico.

OUT

Output

Elemento de un
ARRAY[*] of
BOOL, STRUCT o
tipo de datos PLC

I, Q, M, D, L

ARRAY, STRUCT
o tipo de datos
PLC en el/los que
se guardan los bits
individuales

En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar la secuencia de
bits deseada.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1454

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo de un ARRAY de destino con el límite inferior de "0"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArrayWord

Input

ARRAY[0..5] of WORD

CounterInput
DestinationArrayBool

UDINT
Output

ARRAY[0..95] of BOOL

El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL
CALL SCATTER_BLK

// Llamada de la instrucción
// Seleccione el tipo de datos deseado de
la lista desplegable "???".

IN := #SourceArrayWord[2]

// La 3.ª, 4.ª y 5.ª WORD del operando
#SourceArrayWord se descompone en sus
bits individuales (48).

COUNT_IN := #CounterInput

// Se descomponen 3 palabras

OUT := DestinationArrayBool[0]

// Y a partir del 1.er elemento se asignan a los distintos elementos del operando #DestinationArrayBool.

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayWord

ARRAY[0..5] of WORD (Pueden
dispersarse 96 bits.)

COUNT_IN

CounterInput = 3

UDINT3 (deben descomponerse
3 WORD o 48 bits. Esto significa
que en el ARRAY de destino de‐
be haber al menos 48 bits).

OUT

DestinationArrayBool[0]

El operando "DestinationArray‐
Bool" es del tipo de datos
ARRAY[0..95] of BOOL. Hay por
tanto 96 elementos BOOL dispo‐
nibles.

Ejemplo de ARRAY de destino con el límite inferior de "-2"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArrayWord

Input

ARRAY[0..5] of WORD

CounterInput
DestinationArrayBool

Programación del PLC
Manual de programación y manejo, 11/2019

UDINT
Output

ARRAY[-2..93] of BOOL

1455

Instrucciones
4.1 Instrucciones
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL
CALL SCATTER_BLK

// Llamada de la instrucción
// Seleccione el tipo de datos deseado de
la lista desplegable "???".

IN := #SourceArrayWord[2]

// La 3.ª, 4.ª y 5.ª WORD del operando
#SourceArrayWord se descompone en sus
bits individuales (48).

COUNT_IN := #CounterInput

// Se descomponen 3 palabras

OUT := DestinationArrayBool[14]

A partir del 16.º elemento se asignan a
los distintos elementos del operando #DestinationArrayBool.

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayWord[2]

ARRAY[0..5] of WORD (Pueden
dispersarse 96 bits.)

COUNT_IN

CounterInput = 3

UDINT3 (deben descomponerse
3 WORD o 48 bits. Esto significa
que en el ARRAY de destino de‐
be haber al menos 48 bits).

OUT

DestinationArrayBool[14]

El operando "DestinationArray‐
Bool" es del tipo de datos
ARRAY[-2..93] of BOOL. Hay
por tanto 96 elementos BOOL
disponibles.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

1456

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

GATHER: Recopilación de bits individuales en una secuencia de bits
Descripción
La instrucción "Recopilación de bits individuales en una secuencia de bits" recompone los bits
de un ARRAY of BOOL, un STRUCT anónimo o un tipo de datos PLC en una secuencia de bits
con elementos booleanos exclusivamente. La secuencia de bits se guarda en una variable del
tipo de datos BYTE, WORD, DWORD o LWORD.
Nota
ARRAY of BOOL multidimensional
En la instrucción "Recopilación de bits individuales en una secuencia de bits" no está permitido
utilizar un ARRAY of BOOL multidimensional.
Nota
Longitud del ARRAY, del STRUCT o del tipo de datos PLC
El ARRAY, el STRUCT o el tipo de datos PLC deben tener tantos elementos como se
especifique en la secuencia de bits.
Es decir, en el tipo de datos BYTE, p. ej., el ARRAY, el STRUCT anónimo o el tipo de datos PLC
deben tener exactamente 8 elementos (WORD = 16, DWORD = 32 y LWORD = 64).
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1500 a partir de la versión de firmware
2.1.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

IN

Input

Tipo de datos
ARRAY[*] of
BOOL, STRUCT o
tipo de datos PLC

Área de memoria

Descripción

I, Q, M, D, L

ARRAY, STRUCT
o tipo de datos
PLC cuyos bits se
recomponen en
una secuencia de
bits.

*: 8, 16, 32 o 64
elementos

Los valores no
pueden encontrar‐
se en el área de
periferia o en el
DB de un objeto
tecnológico.
OUT

Programación del PLC
Manual de programación y manejo, 11/2019

Output

BYTE, WORD,
I, Q, M, D, L
DWORD, LWORD

Secuencia de bits
recopilada que es‐
tá guardada en
una variable

1457

Instrucciones
4.1 Instrucciones
En la lista desplegable "???" del cuadro de la instrucción se puede seleccionar la secuencia de
bits deseada.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo con un ARRAY
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArray

Input

ARRAY[0..15] of BOOL

DestinationWord

Output

WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL
CALL GATHER

// Llamada de la instrucción
// Seleccione el tipo de datos deseado de
la lista desplegable "???".

IN := #SourceArray

// Los bits del operando #SourceArray se
recopilan en una WORD.

OUT := #DestinationWord

// Los 16 bits recompuestos se guardan en
el operando #DestinationWord.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operando
concretos:

1458

Parámetro

Operando

Tipo de datos

IN

SourceArray

El operando "SourceArray" es
del tipo de datos ARRAY[0..15]
of BOOL. Consta de 16 elemen‐
tos y, por tanto, tiene el mismo
tamaño que la WORD en la que
se deben recomponer los bits.

OUT

DestinationWord

WORD (16 bits)

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo con un tipo de datos PLC (UDT)
Cree el siguiente tipo de datos PLC "myBits":

Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceUDT

Input

"myBits"

DestinationWord

Output

WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL
CALL GATHER

// Llamada de la instrucción
// Seleccione el tipo de datos deseado de
la lista desplegable "???".

IN := #SourceUDT

// Los bits del operando #SourceUDT se recomponen en una WORD.

OUT := #DestinationWord

// Los 16 bits recompuestos se guardan en
el operando #DestinationWord.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operando
concretos:
Parámetro

Operando

Tipo de datos

IN

SourceUDT

El operando "SourceUDT" es del
tipo de datos PLC (UDT). Consta
de 16 elementos y, por tanto, tie‐
ne el mismo tamaño que la
WORD en la que se deben re‐
componer los bits.

OUT

DestinationWord

WORD (16 bits)

Programación del PLC
Manual de programación y manejo, 11/2019

1459

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

GATHER_BLK: Recopilación de bits individuales en varios elementos de un ARRAY of secuencia de bits
Descripción
La instrucción "Recopilación de bits individuales en varios elementos de un ARRAY of
secuencia de bits" recompone los bits de un ARRAY of BOOL, un STRUCT anónimo o un tipo
de datos PLC con elementos booleanos exclusivamente en uno o varios elementos de un
ARRAY of <secuencia de bits>. En el parámetro COUNT_OUT se introduce el número de
elementos del ARRAY de destino que deben escribirse. Al hacerlo se especifica
implícitamente cuántos elementos del ARRAY of BOOL, del STRUCT anónimo o del tipo de
datos PLC se necesitan. El ARRAY de destino en el parámetro OUT puede tener más
elementos que los indicados en el parámetro COUNT_OUT. El ARRAY of <secuencia de bits>
debe tener suficientes elementos para poder guardar los bits que deben recopilarse. El
ARRAY de destino también puede ser mayor.
Nota
ARRAY of BOOL multidimensional
Si el ARRAY es un ARRAY of BOOL multidimensional, se cuentan también los bits de relleno
de las dimensiones contenidas, aunque no se hayan declarado explícitamente.
Ejemplo 1: un ARRAY[1..10,0..4,1..2] of BOOL recibe el mismo tratamiento que un
ARRAY[1..10,0..4,1..8] of BOOL o que un ARRAY[0..399] of BOOL.
Ejemplo 2: En el parámetro OUT hay un ARRAY[0..5] of WORD (sourceArrayWord[2])
interconectado. El parámetro COUNT_IN tiene el valor "3". En el parámetro IN hay un
ARRAY[0..1,0..5,0..7] of BOOL (destinationArrayBool[0,0,0]) interconectado. Tanto el array
del parámetro IN como el del parámetro OUT tienen 96 bits de tamaño. A partir del ARRAY of
BOOL se recomponen 48 bits individuales.

1460

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Nota
Si el límite inferior del ARRAY de origen no es "0", cabe considerar lo siguiente:
Por motivos de rendimiento, el índice debe comenzar siempre en un límite de BYTE, WORD
o DWORD. Esto significa que debe calcularse el índice partiendo del límite inferior del ARRAY.
Como base para el cálculo se utiliza la siguiente fórmula:
Índice válido = límite inferior del ARRAY + n(número de secuencias de bits) * número de bits
de la secuencia de bits deseada
Para un ARRAY[-2..45] of BOOL y la secuencia de bits WORD, el cálculo es el siguiente:
● Índice válido (-2) = -2 + 0 * 16
● Índice válido (14) = -2 + 1 * 16
● Índice válido (30) = -2 + 2 * 16
Ver un ejemplo más adelante.
Nota
Disponibilidad de la instrucción
La instrucción puede utilizarse en las CPU de la serie S7-1500 a partir de la versión de firmware
2.1.

Programación del PLC
Manual de programación y manejo, 11/2019

1461

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

IN

Input

Tipo de datos
Elemento de un
ARRAY[*] of
BOOL, STRUCT o
tipo de datos PLC

Área de memoria

Descripción

I, Q, M, D, L

ARRAY of BOOL,
STRUCT o tipo de
datos PLC cuyos
bits se recompo‐
nen (ARRAY de
origen).
Los valores no
pueden encontrar‐
se en el área de
periferia o en el
DB de un objeto
tecnológico.

COUNT_OUT

Input

USINT, UINT,
UDINT, ULINT

I, Q, M, D, L

Contador del nú‐
mero de elemen‐
tos del ARRAY de
destino que deben
escribirse.
El valor no puede
encontrarse en el
área de periferia o
en el DB de un ob‐
jeto tecnológico.

OUT

Output

Elemento de un
ARRAY[*] of <se‐
cuencia de bits>

I, Q, M, D, L

ARRAY de <se‐
cuencia de bits>
en el que se guar‐
dan los bits
(ARRAY de desti‐
no)

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo de ARRAY de origen con el límite inferior de "0"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArrayBool

Input

ARRAY[0..95] of BOOL

CounterOutput
DestinationArrayWord

UDINT
Output

ARRAY[0..5] of WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL
CALL GATHER_BLK

// Llamada de la instrucción
// Seleccione el tipo de datos deseado de
la lista desplegable "???".

1462

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL
IN := SourceArrayBool[0]

// A partir del 1.er elemento del operando #SourceArrayBool se recomponen 48 bits
en el operando #DestinationArrayWord.

COUNT_OUT := #CounterOutput

// Se recopilan 3 palabras

OUT := DestinationArrayWord[2]

// En el ARRAY de destino se empieza a
partir del 3.er elemento. Esto significa
que los primeros 16 bits se escriben en
la 3.ª palabra, los segundos 16 bits en
la 4.ª palabra y los terceros 16 bits en
la 5.ª palabra del ARRAY de destino.

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayBool[0]

El operando "SourceArrayBool"
es del tipo de datos
ARRAY[0..95] of BOOL. Hay por
tanto 96 elementos BOOL dispo‐
nibles que pueden volver a reco‐
pilarse en palabras.

COUNT_OUT

CounterOutput = 3

UDINT3 (deben escribirse 3 pa‐
labras. Esto significa que en el
ARRAY de origen debe haber 48
bits).

OUT

DestinationArrayWord[2]

El operando "DestinationArray‐
Word" es del tipo de datos
ARRAY[0..5] of WORD. Hay 6
elementos WORD disponibles.

Ejemplo de ARRAY de origen con el límite inferior de "-2"
Cree las siguientes variables en la interfaz del bloque:
Variable

Sección

Tipo de datos

SourceArrayBool

Input

ARRAY[-2..93] of BOOL

CounterOutput
DestinationArrayWord

UDINT
Output

ARRAY[0..5] of WORD

El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL
CALL GATHER_BLK

// Llamada de la instrucción
// Seleccione el tipo de datos deseado de
la lista desplegable "???".

IN := SourceArrayBool[14]

// A partir del 16.º elemento del operando #SourceArrayBool se recopilan 48 bits
en el operando #DestinationArrayWord.

COUNT_OUT := #CounterOutput

// Se recopilan 3 palabras

Programación del PLC
Manual de programación y manejo, 11/2019

1463

Instrucciones
4.1 Instrucciones
AWL
OUT := DestinationArrayWord[2]

// En el ARRAY de destino se empieza a
partir del 3.er elemento. Esto significa
que los primeros 16 bits del ARRAY de origen no se tienen en cuenta. Los segundos
16 bits se escriben en la 3.ª palabra,
los terceros 16 bits en la 4.ª palabra y
los cuartos 16 bits en la 5.ª palabra del
ARRAY de destino. Los 64 bits restantes
del ARRAY de origen tampoco se tienen en
cuenta.

La tabla siguiente muestra cómo funciona la instrucción con valores de operandos concretos:
Parámetro

Operando

Tipo de datos

IN

SourceArrayBool[14]

El operando "SourceArrayBool"
es del tipo de datos
ARRAY[-2..93] of BOOL. Dado
que se empieza a partir del 16.º
elemento, hay solo 80 elemen‐
tos BOOL disponibles que pue‐
dan volver a recopilarse en pala‐
bras.

COUNT_OUT

CounterOutput = 3

UDINT3 (deben escribirse 3 pa‐
labras. Esto significa que en el
ARRAY de origen debe haber 48
bits).

OUT

DestinationArrayWord[2]

El operando "DestinationArray‐
Word" es del tipo de datos
ARRAY[0..5] of WORD. Hay 6
elementos WORD disponibles.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

AssignmentAttempt: Intento de asignación de VARIANT a una referencia
Descripción
La instrucción "AssignmentAttempt" intenta asignar una variable VARIANT a una variable de
referencia. El tipo de datos de una variable de referencia se define en el momento de la
declaración, mientras que el tipo de datos de una variable VARIANT se determina en tiempo
de ejecución. En las variables de referencia no está permitida la conversión implícita del tipo
de datos. Para asignar un tipo de datos al otro se utiliza el intento de asignación.
En el intento de asignación, se comprueba en tiempo de ejecución si la variable VARIANT es
del tipo de datos correcto. Si es así, se ejecuta la asignación. Una vez ejecutada

1464

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
correctamente, en la variable de destino hay una referencia válida; en caso contrario, hay
CERO.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción:
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRC

Input

VARIANT

● Interfaz de
bloque de una
FC:
Input, Output,
InOut, Temp

Puntero hacia la
variable origen cu‐
ya dirección se ha
leído

● Interfaz de
bloque de un
FB:
Input, Output,
Temp
DST

Output

Referencia a:
● Secuencias de
bits, excepto
BOOL,
● Enteros,
● Números en
coma flotante,
● Cadenas de
caracteres,

● Interfaz de
bloque de una
FC:
Input, Output,
Temp

Referencia a la
que se transfiere
la dirección de la
variable de origen

● Interfaz de
bloque de un
FB:
Temp

● Tipos de datos
PLC (UDT),
● Tipos de datos
de sistema
(SDT),
● ARRAYs de
los tipos de
datos citados

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1465

Instrucciones
4.1 Instrucciones

Reglas
Para el intento de asignación se aplican las siguientes reglas: Las variables VARIANT que no
satisfacen estas reglas devuelven el valor "NULL" en tiempo de ejecución.
● VARIANT debe señalar a una dirección de un área de memoria optimizada.
● VARIANT no puede señalar a una dirección de un área de memoria temporal.
● Si desea asignar un VARIANT a una referencia a un ARRAY, se aplican las siguientes
reglas:
– La variable VARIANT debe señalar a un ARRAY cuyos límites coincidan exactamente
con los de la referencia declarada. Una variable VARIANT que señala a un ARRAY [0..9]
no concuerda con una variable REF_TO ARRAY[1..10].
– Además, los bloques que forman el valor de la variable VARIANT deben compilarse una
vez en una CPU de la serie S7-1500, con firmware de la versión V2.5.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
En la interfaz del bloque se han declarado la VARIANT "myVariant" y la variable de referencia
"myReference".

En el código de programa se intenta asignar "myVariant" a la variable de referencia
"myReference". Si en tiempo de ejecución "myVariant" tiene el tipo de datos "Int", en
"myReference" hay una referencia válida a la variable de destino de VARIANT; en caso
contrario, hay CERO. Si la consulta realizada a continuación a "NOT_NULL" es "TRUE",
significa que la asignación se ha efectuado correctamente y se puede escribir el parámetro de
salida "Tag_Out".

1466

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Principios básicos de las referencias (Página 310)
Intento de asignación de VARIANT a una referencia (Página 325)
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

DB ARRAY
ReadFromArrayDB: Leer en un bloque de datos ARRAY
Descripción
La instrucción "Leer en un bloque de datos ARRAY" lee el elemento de un bloque de datos del
tipo ARRAY-DB al que hace referencia el índice y escribe el valor en el área de destino.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Leer en un bloque de datos
ARRAY":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

DB

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
lee

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB que se lee.
Puede ser una constante,
una variable global o un valor
indexado.

VALUE

Output 1)

VARIANT

L (puede declarar‐ Valor que se lee y se devuel‐
se en las seccio‐
ve
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

1) El parámetro VALUE está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Programación del PLC
Manual de programación y manejo, 11/2019

1467

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

80B5

La operación de copia se ha cancelado.

8132

El bloque de datos no existe, es demasiado corto, está protegido contra escritura o está
en la memoria de carga.

8135

El bloque de datos de ARRAY contiene valores no válidos.

8154

El bloque de datos es de un tipo incorrecto.

8282

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8450

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8452

Error de creación de código

8453

Hay dos posibles causas de error:
● El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque
de datos ARRAY.
● Ninguna de las dos variables se encuentra en un área de memoria con acceso
optimizado. Encontrará más información sobre los tipos de acceso al área de memoria
aquí: Fundamentos del acceso a bloques (Página 54)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1468

AWL

Explicación

CALL ReadFromArrayDB

// Llamada de la instrucción

DB := "ArrayDB"

// El bloque de datos en el que se lee.

INDEX := "ArrayDB".THIS[2]

// el segundo elemento se lee en el bloque de datos.

RET_VAL := "TagRet_Val"

// Información de error

VALUE := "TargetField"

// El valor leído se devuelve en el parámetro VALUE.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetros

Operando

Valor

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
Array [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

TargetField

El operando "TargetField" es
una variable global del tipo de
datos INT.

El segundo elemento se lee en el "ArrayDB" y se escribe en el operando "TargetField".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Bases de AWL (Página 8065)

WriteToArrayDB: Escribir en un bloque de datos ARRAY
Descripción
La instrucción "Escribir en un bloque de datos ARRAY" escribe el elemento al que hace
referencia el índice en un bloque de datos del tipo ARRAY-DB.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Escribir en un bloque de datos
ARRAY":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

DB

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
escribe

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB en el que se
escribe. Puede ser una cons‐
tante, una variable global o
un valor indexado.

Programación del PLC
Manual de programación y manejo, 11/2019

1469

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

VALUE

Input

VARIANT

L (puede declarar‐ Valor que se escribe
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

Descripción

RET_VAL

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

80B5

La operación de copia se ha cancelado.

8132

El bloque de datos no existe, es demasiado corto o está en la memoria de carga.

8134

El bloque de datos está protegido contra escritura.

8135

El bloque de datos no es un bloque de datos de ARRAY.

8154

El bloque de datos es de un tipo incorrecto.

8282

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8350

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8352

Error de creación de código

8353

Hay dos posibles causas de error:
● El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque
de datos ARRAY.
● Ninguna de las dos variables se encuentra en un área de memoria con acceso
optimizado. Encontrará más información sobre los tipos de acceso al área de memoria
aquí: Fundamentos del acceso a bloques (Página 54)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

1470

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL WriteToArrayDB

// Llamada de la instrucción

DB := "ArrayDB"

// Bloque de datos en el que se escribe.

INDEX := 2

// El valor se escribe en el elemento [2]
del bloque de datos.

RET_VAL := "TagRet_Val"

// Información de error

VALUE := "SourceField"

// El valor que se escribe en el bloque de
datos.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
Array [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

SourceField

El operando "SourceField" es
una variable global del tipo de
datos INT.

El valor del operando "SourceField" se escribe en el segundo elemento del DB de ARRAY.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Bases de AWL (Página 8065)

ReadFromArrayDBL: Leer en un bloque de datos ARRAY de la memoria de carga
Descripción
La instrucción "Leer en un bloque de datos ARRAY de la memoria de carga" lee el elemento
de un bloque de datos del tipo ARRAY-DB de la memoria de carga al que hace referencia el
índice y lo escribe en el área de destino.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".
Si el bloque de datos ARRAY se ha marcado con el atributo de bloque "Depositar sólo en la
memoria de carga", se guarda únicamente en la memoria de carga.

Programación del PLC
Manual de programación y manejo, 11/2019

1471

Instrucciones
4.1 Instrucciones
Si en el parámetro REQ se detecta un flanco de señal ascendente, se ejecuta la instrucción.
El parámetro BUSY devuelve el estado lógico "1". Si en el parámetro BUSY se detecta un
flanco de señal descendente, finaliza la instrucción. Durante un ciclo del programa, el
parámetro DONE tiene el estado lógico "1" y durante este ciclo se emite el valor leído en el
parámetro VALUE. En los demás ciclos del programa, el valor del parámetro VALUE no se
modifica.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Leer en un bloque de datos
ARRAY de la memoria de carga":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o
constante

REQ = "1": Comenzar la lec‐
tura del DB de array

DB 1)

Input

DB_ANY

I, Q, M, D, L

Bloque de datos en el que se
lee

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB que se lee.
Puede ser una constante,
una variable global o un valor
indexado.

VALUE 1)

InOut

VARIANT

D (elemento de un
bloque de datos
global)

Puntero al bloque de datos
de la memoria de trabajo que
se lee y cuyo valor se escribe.

L (puede declarar‐ No está permitido utilizar
constantes locales o varia‐
se en las seccio‐
bles de la sección TEMP.
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)
BUSY

Output

BOOL

I, Q, M, D, L

BUSY = "1": La lectura del
DB de array todavía no ha fi‐
nalizado

DONE

Output

BOOL

I, Q, M, D, L

DONE = "1": La instrucción
se ha ejecutado correcta‐
mente

ERROR

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro ERROR devuel‐
ve un código de error cuando
ocurre un error durante la eje‐
cución de la instrucción.

1)

1472

Los bloques de datos deben crearse con la propiedad de bloque "Optimizado".

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro ERROR
La tabla siguiente muestra el significado de los valores del parámetro ERROR:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8230

El número del bloque de datos es incorrecto.

8231

El bloque de datos no existe.

8232

El bloque de datos es demasiado corto o no está en la memoria de carga.

8235

El bloque de datos no es un DB de ARRAY.

8254

El bloque de datos es de un tipo incorrecto.

8382

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8750

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8751

Error de creación de código

8752

Error de creación de código

8753

El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque de
datos ARRAY.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Encontrará la descripción de los códigos de error activados por las instrucciones "READ_DBL"
y "WRIT_DBL" en las descripciones de las instrucciones correspondientes.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL ReadFromArrayDBL, "ReadFromArrayDBL_DB"

// Llamada de la instrucción

REQ := "TagReg"

// Cuando se produce un flanco de señal
ascendente, se ejecuta la instrucción.

DB := "ArrayDB"

// El bloque de datos en el que se lee.

INDEX := 2

// El elemento [2] se lee en el bloque de
datos.

VALUE := "TargetField"

// El valor leído se devuelve en el parámetro VALUE.

BUSY := "TagBusy"

// Indica si la instrucción aún está en
ejecución.

DONE := "TagDone"

// Indica si la ejecución ha finalizado.

ERROR := "TagError"

// Información de error

Programación del PLC
Manual de programación y manejo, 11/2019

1473

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

REQ

TagReq

BOOL

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
ARRAY [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

TargetField

El operando "TargetField" es
una variable global del tipo de
datos INT.

BUSY

TagBusy

BOOL

DONE

TagDone

BOOL

Si en el operando "TagReq" se detecta un flanco de señal ascendente, se ejecuta la
instrucción. El segundo elemento se lee en el "ArrayDB" y se devuelve en el parámetro
"VALUE". En cuanto se detecta un flanco de señal descendente en el operando "TagBusy",
finaliza la instrucción y el valor del parámetro VALUE ya no se modifica. Después de ejecutar
la instrucción, el operando "TagDone" tiene el estado lógico TRUE.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
READ_DBL: Leer de un bloque de datos de la memoria de carga (Página 2919)
WRIT_DBL: Escribir en un bloque de datos de la memoria de carga (Página 2923)
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)
Bases de AWL (Página 8065)

WriteToArrayDBL: Escribir en un bloque de datos ARRAY de la memoria de carga
Descripción
La instrucción "Escribir en un bloque de datos ARRAY de la memoria de carga" escribe el
elemento al que hace referencia el índice en un bloque de datos del tipo ARRAY-DB de la
memoria de carga.
Un bloque de datos ARRAY es un bloque de datos que consta exactamente de un ARRAY of
<tipo de datos>. Los elementos del ARRAY pueden ser del tipo de datos PLC o de cualquier
otro tipo de datos simple. El contaje del ARRAY comienza siempre por el límite inferior "0".
Si el bloque de datos ARRAY se ha marcado con el atributo de bloque "Depositar sólo en la
memoria de carga", se guarda únicamente en la memoria de carga.

1474

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Si en el parámetro REQ se detecta un flanco de señal ascendente, se ejecuta la instrucción.
El parámetro BUSY devuelve el estado lógico "1". Si en el parámetro BUSY se detecta un
flanco de señal descendente, finaliza la instrucción y el valor del parámetro VALUE se escribe
en el bloque de datos. Durante un ciclo del programa, el parámetro DONE tiene el estado
lógico "1".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Escribir en un bloque de datos
ARRAY de la memoria de carga":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o
constante

REQ = "1": Comenzar a es‐
cribir en el DB de ARRAY

DB 1)

Input

DB_ANY

I, Q, M, D, L

Bloque de datos ARRAY en
el que se escribe

INDEX

Input

DINT

I, Q, M, D, L, P o
constante

Elemento del DB en el que se
escribe. Puede ser una cons‐
tante, una variable global o
un valor indexado.

VALUE 1)

Input

VARIANT

D (elemento de un
bloque de datos
global)

Puntero al bloque de datos
de la memoria de trabajo que
se lee y cuyo valor se escribe.

L (puede declarar‐ No está permitido utilizar
constantes locales o varia‐
se en las seccio‐
bles de la sección TEMP.
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)
BUSY

Output

BOOL

I, Q, M, D, L

BUSY = "1": Todavía no se
ha terminado de escribir en el
DB de ARRAY

DONE

Output

BOOL

I, Q, M, D, L

DONE = "1": La instrucción
se ha ejecutado correcta‐
mente

ERROR

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro ERROR devuel‐
ve un código de error cuando
ocurre un error durante la eje‐
cución de la instrucción.

1)

Los bloques de datos deben crearse con la propiedad de bloque "Optimizado".

Programación del PLC
Manual de programación y manejo, 11/2019

1475

Instrucciones
4.1 Instrucciones

Parámetro ERROR
La tabla siguiente muestra el significado de los valores del parámetro ERROR:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8230

El número del bloque de datos es incorrecto.

8231

El bloque de datos no existe.

8232

El bloque de datos es demasiado corto o no está en la memoria de carga.

8234

El bloque de datos está protegido contra escritura.

8235

El bloque de datos no es un DB de ARRAY.

8254

El bloque de datos es de un tipo incorrecto.

8382

El valor del parámetro INDEX se encuentra fuera de los valores límite del ARRAY.

8450

El tipo de datos VARIANT del parámetro VALUE devuelve el valor "0".

8751

Error de creación de código

8752

Error de creación de código

8753

El tamaño del parámetro VALUE no coincide con la longitud del elemento en el bloque de
datos ARRAY.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Encontrará la descripción de los códigos de error activados por las instrucciones "READ_DBL"
y "WRIT_DBL" en las descripciones de las instrucciones correspondientes.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1476

AWL

Explicación

CALL WriteToArrayDBL, "WriteToArrayDBL_DB"

// Llamada de la instrucción

REQ := "TagReg"

// Cuando se produce un flanco de señal
ascendente, se ejecuta la instrucción.

DB := "ArrayDB"

// El bloque de datos en el que se lee.

INDEX := 2

// El elemento [2] se lee en el bloque de
datos.

VALUE := "SourceField"

// El valor leído se devuelve en el parámetro VALUE.

BUSY := "TagBusy"

// Indica si la instrucción aún está en
ejecución.

DONE := "TagDone"

// Indica si la ejecución ha finalizado.

ERROR := "TagError"

// Información de error

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

REQ

TagReq

BOOL

DB

ArrayDB

El operando "ArrayDB" es un
ARRAY-DB del tipo de datos
ARRAY [0..10] of INT.

INDEX

2

Segundo elemento del
"ArrayDB"

VALUE

SourceField

El operando "SourceField" es
una variable global del tipo de
datos INT.

BUSY

TagBusy

BOOL

DONE

TagDone

BOOL

Si en el operando "TagReq" se detecta un flanco de señal ascendente, se ejecuta la
instrucción. En cuanto se detecta un flanco descendente en el operando "TagBusy", la
instrucción finaliza y el valor del parámetro VALUE se escribe en el segundo elemento del
"ArrayDB". Después de ejecutar la instrucción, el operando "TagDone" tiene el estado lógico
TRUE.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
READ_DBL: Leer de un bloque de datos de la memoria de carga (Página 2919)
WRIT_DBL: Escribir en un bloque de datos de la memoria de carga (Página 2923)
Ejemplo de uso de bloques de datos ARRAY (Página 43)
Diferencia entre las instrucciones que funcionan síncronamente y las que funcionan
asíncronamente (Página 618)
Bases de AWL (Página 8065)

Acceso de lectura/escritura
PEEK: Leer dirección de memoria
Descripción
La instrucción "Leer dirección de memoria" permite leer una dirección de memoria de un área
de memoria estándar sin indicar un tipo de datos.

Programación del PLC
Manual de programación y manejo, 11/2019

1477

Instrucciones
4.1 Instrucciones

Uso del área de memoria 16#84: DB
Si como área de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
código del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso:

CALL PEEK
AREA := 16#84
DBNUMBER := 1
BYTEOFFSET := 2
RET_VAL := #Peeker
JBI end
L 16#ffff
T #Peeker
end: NOP 0

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Leer dirección de memoria":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

AREA

Input

BYTE

I, Q, M, D

Pueden seleccionarse las si‐
guientes áreas:
● 16#81: Input
● 16#82: Output
● 16#83: Marcas
● 16#84: DB
● 16#1: Entrada de periferia

DBNUMBER

Input

DINT, DB_ANY

I, Q, M, D

Número del bloque de datos
si AREA = DB, de lo contrario
"0"

BYTEOFF‐
SET

Input

DINT

I, Q, M, D

Dirección en la que se lee

RET_VAL

Output

Solo se utilizan los 16 bits
menos significativos.
Secuencias de bits I, Q, M, D

Resultado de la instrucción

En las listas desplegables "???" puede seleccionar los tipos de datos de la instrucción.
Nota
Si se lee la dirección de memoria en las áreas Input, Output o Marcas, se debe suministrar el
valor "0" al parámetro DBNUMBER, ya que de lo contrario la instrucción será errónea.

1478

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL PEEK

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

AREA := "Tag_Area"

// Área del bloque de datos seleccionada

DBNUMBER := "Tag_DBNumber"

// Número del bloque de datos

BYTEOFFSET := "Tag_Byte"

// Dirección en la que se lee

RET_VAL := "Tag_Result"

// Resultado

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

AREA

Tag_Area

16#84

DBNUMBER

Tag_DBNumber

5

BYTEOFFSET

Tag_Byte

20

RET_VAL

Tag_Result

Valor del byte "20"

La instrucción lee el valor de la dirección "20" del operando "Tag_Byte" del bloque de datos "5"
y devuelve el resultado en el operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

PEEK_BOOL: Leer bit de memoria
Descripción
La instrucción "Leer bit de memoria" permite leer un bit de memoria de un área de memoria
estándar sin indicar un tipo de datos.

Uso del área de memoria 16#84: DB
Si como área de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
código del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso:

CALL PEEK_BOOL
AREA := 16#84
DBNUMBER := 1

Programación del PLC
Manual de programación y manejo, 11/2019

1479

Instrucciones
4.1 Instrucciones

BYTEOFFSET := 2
BITOFFSET := 1
RET_VAL := #Peeker_BOOL
JBI end
L 16#ffff
T #Peeker_BOOL
end: NOP 0

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Leer bit de memoria":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

AREA

Input

BYTE

I, Q, M, D

Pueden seleccionarse las si‐
guientes áreas:
● 16#81: Input
● 16#82: Output
● 16#83: Marcas
● 16#84: DB
● 16#1: Entrada de periferia

DBNUMBER

Input

DINT, DB_ANY

I, Q, M, D

Número del bloque de datos
si AREA = DB, de lo contrario
"0"

BYTEOFF‐
SET

Input

DINT

I, Q, M, D

BITOFFSET

Input

INT

I, Q, M, D

Bit en el que se lee

RET_VAL

Output

BOOL

I, Q, M, D

Resultado de la instrucción

Dirección en la que se lee
Solo se utilizan los 16 bits
menos significativos.

En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Nota
Si se lee el bit de memoria en las áreas Input, Output o Marcas, se debe suministrar el valor "0"
al parámetro DBNUMBER, ya que de lo contrario la instrucción será errónea.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL PEEK_BOOL

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

AREA := "Tag_Area"

1480

// Área del bloque de datos seleccionada

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

DBNUMBER := "Tag_DBNumber"

// Número del bloque de datos

BYTEOFFSET := "Tag_Byte"

// Dirección en la que se lee

BITOFFSET := "Tag_Bit"

// Bit en el que se lee

RET_VAL := "Tag_Result"

// Resultado

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

AREA

Tag_Area

16#84

DBNUMBER

Tag_DBNumber

5

BYTEOFFSET

Tag_Byte

20

BITOFFSET

Tag_Bit

3

RET_VAL

Tag_Result

3

La instrucción lee el valor del bit de memoria "3" del operando "Tag_Bit" del bloque de datos
"5" del byte "20" y devuelve el resultado en el operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

POKE: Escribir dirección de memoria
Descripción
La instrucción "Escribir dirección de memoria" permite escribir una dirección de memoria en un
área de memoria estándar sin indicar un tipo de datos.

Uso del área de memoria 16#84: DB
Si como área de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
código del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso.

Programación del PLC
Manual de programación y manejo, 11/2019

1481

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Escribir dirección de memoria":
Parámetro

Declaración

AREA

Input

Tipo de datos
BYTE

Área de memoria

Descripción

I, Q, M, D

Pueden seleccionarse las si‐
guientes áreas:
● 16#81: Input
● 16#82: Output
● 16#83: Marcas
● 16#84: DB
● 16#2: Salida de periferia

DBNUMBER

Input

DINT, DB_ANY

I, Q, M, D

BYTEOFF‐
SET

Input

DINT

I, Q, M, D

VALUE

Input

Número del bloque de datos
si AREA = DB, de lo contrario
"0"
Dirección que se escribe
Solo se utilizan los 16 bits
menos significativos.

Secuencias de bits I, Q, M, D

Valor que se escribe

En las listas desplegables "???" puede seleccionar los tipos de datos de la instrucción.
Nota
Si se escribe la dirección de memoria en las áreas Input, Output o Marcas, se debe suministrar
el valor "0" al parámetro DBNUMBER, ya que de lo contrario la instrucción será errónea.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL POKE

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

AREA := "Tag_Area"

// Área del bloque de datos seleccionada

DBNUMBER := "Tag_DBNumber"

// Número del bloque de datos

BYTEOFFSET := "Tag_Byte"

// Dirección en la que se lee

VALUE := "Tag_Value"

// Valor que se escribe.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

1482

Operando

Valor

AREA

Tag_Area

16#84

DBNUMBER

Tag_DBNumber

5

BYTEOFFSET

Tag_Byte

20

VALUE

Tag_Value

16#11

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucción sobrescribe la dirección de memoria "20" en el bloque de datos "5" con el valor
"16#11".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

POKE_BOOL: Escribir bit de memoria
Descripción
La instrucción "Escribir bit de memoria" permite escribir un bit de memoria en un área de
memoria estándar sin indicar un tipo de datos.

Uso del área de memoria 16#84: DB
Si como área de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
código del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Escribir bit de memoria":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

AREA

Input

BYTE

I, Q, M, D

Pueden seleccionarse las si‐
guientes áreas:
● 16#81: Input
● 16#82: Output
● 16#83: Marcas
● 16#84: DB
● 16#2: Salida de periferia

DBNUMBER

Input

DINT, DB_ANY

I, Q, M, D

Número del bloque de datos
si AREA = DB, de lo contrario
"0"

BYTEOFF‐
SET

Input

DINT

I, Q, M, D

Dirección que se escribe

BITOFFSET

Input

INT

I, Q, M, D

Bit que se escribe

VALUE

Input

BOOL

I, Q, M, D

Valor que se escribe

Solo se utilizan los 16 bits
menos significativos.

Programación del PLC
Manual de programación y manejo, 11/2019

1483

Instrucciones
4.1 Instrucciones
En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Nota
Si se escribe el bit de memoria en las áreas Input, Output o Marcas, se debe suministrar el valor
"0" al parámetro DBNUMBER, ya que de lo contrario la instrucción será errónea.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL POKE_BOOL

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

AREA := "Tag_Area"

// Área del bloque de datos seleccionada

DBNUMBER := "Tag_DBNumber"

// Número del bloque de datos

BYTEOFFSET := "Tag_Byte"

// Dirección en la que se lee.

BITOFFSET := "Tag_Bit"

// Bit en el que se lee.

VALUE := "Tag_Value"

// Valor que se escribe.

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

AREA

Tag_Area

16#84

DBNUMBER

Tag_DBNumber

5

BYTEOFFSET

Tag_Byte

20

BITOFFSET

Tag_Bit

3

VALUE

Tag_Value

M0.0

La instrucción sobrescribe el bit de memoria "3" en el bloque de datos "5" en el byte "20" con
el valor "M0.0".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

POKE_BLK: Escribir área de memoria
Descripción
La instrucción "Escribir área de memoria" permite escribir un área de memoria en un área de
memoria estándar diferente sin indicar un tipo de datos.

1484

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Uso del área de memoria 16#84: DB
Si como área de memoria se utiliza un bloque de datos que no se conoce a la hora de crear el
código del programa, existe la posibilidad de utilizar el mecanismo EN/ENO para detectar
posibles errores de acceso.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Escribir área de memoria":
Parámetros

Declaración

Tipo de datos

Área de memoria

Descripción

AREA_SRC

Input

BYTE

I, Q, M, D

Las siguientes áreas pue‐
den seleccionarse en el
área de memoria de origen:
● 16#81: Input
● 16#82: Output
● 16#83: Marcas
● 16#84: DB

DBNUM‐
BER_SRC

Input

DINT, DB_ANY 1)

I, Q, M, D

Número del bloque de datos
en el área de memoria de
origen, si AREA = DB, de lo
contrario "0"

BYTEOFF‐
SET_SRC

Input

DINT

I, Q, M, D

Dirección en el área de me‐
moria de origen, en la que
se escribe
Solo se utilizan los 16 bits
menos significativos.

AREA_DEST

Input

BYTE

I, Q, M, D

Las siguientes áreas pue‐
den seleccionarse en el
área de memoria de destino:
● 16#81: Input
● 16#82: Output
● 16#83: Marcas
● 16#84: DB

DBNUM‐
BER_DEST

Input

DINT, DB_ANY

1)

I, Q, M, D

Número del bloque de datos
en el área de memoria de
destino, si AREA = DB, de lo
contrario "0"
Solo se utilizan los 16 bits
menos significativos.

BYTEOFF‐
SET_DEST

Input

DINT

I, Q, M, D

Dirección en el área de me‐
moria de destino, en la que
se escribe
Solo se utilizan los 16 bits
menos significativos.

COUNT

Input

DINT

I, Q, M, D

Número de bytes que se co‐
pian

Los tipos de datos de los parámetros DBNUMBER_SRC y DBNUMBER_DEST deben ser idénticos.
Es decir, las dos variables deben ser bien del tipo de datos DINT bien del tipo de datos DB_ANY.

1)

Programación del PLC
Manual de programación y manejo, 11/2019

1485

Instrucciones
4.1 Instrucciones
En la lista desplegable "???" puede seleccionar el tipo de datos de la instrucción.
Nota
Si se escribe la dirección de memoria en las áreas Input, Output o Marcas, se debe suministrar
el valor "0" al parámetro DBNUMBER, ya que de lo contrario la instrucción será errónea.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL POKE_BLK

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

AREA_SRC := "Tag_Source_Area" // Área del bloque de datos seleccionada en el área de
memoria de origen
DBNUMBER_SRC := "Tag_Source_DBNumber"

// Número del bloque de datos en el área de memoria de
origen

BYTEOFFSET_SRC := "Tag_Source_Byte"

// Dirección del área de memoria de origen en la que
se lee

AREA_DEST := "Tag_Source_Area"

// Área del bloque de datos seleccionada en el área de
memoria de destino

DBNUMBER_DEST := "Tag_Source_DBNumber"

// Número del bloque de datos en el área de memoria de
destino

BYTEOFFSET_DEST := "Tag_Sour- // Dirección del área de memoria de destino en la que
ce_Byte"
se lee
COUNT := "Tag_Count"

// Número de bytes copiados

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

AREA_SRC

Tag_Source_Area

16#84

DBNUMBER_SRC

Tag_Source_DBNumber

5

BYTEOFFSET_SRC

Tag_Source_Byte

20

AREA_DEST

Tag_Destination_Area

16#83

DBNUMBER_DEST

Tag_Destination_DBNumber

0

BYTEOFFSET_DEST

Tag_Destination_Byte

30

COUNT

Tag_Count

100

La instrucción escribe 100 bytes del bloque de datos "5" comenzando por la dirección "20" en
el área de memoria Marcas comenzado por la dirección "30".

1486

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

READ_LITTLE: Leer datos en formato Little-Endian
Descripción
La instrucción "Leer datos en formato Little-Endian" permite leer datos de un área de memoria
y escribirlos en una única variable en el orden de bytes Little-Endian. En el formato LittleEndian, primero se guarda el byte con los bits menos significativos, es decir, en la dirección de
memoria más baja.
Los parámetros SRC_ARRAY y DEST_VARIABLE son del tipo de datos VARIANT. No
obstante, hay algunas restricciones en cuanto al tipo de datos con el que pueden
interconectarse los parámetros. El VARIANT del parámetro DEST_VARIABLE debe apuntar a
un tipo de datos simple. El VARIANT del parámetro SRC_ARRAY apunta a un área de
memoria que se lee, y debe ser un ARRAY of BYTE.
En los parámetros SRC_ARRAY y DEST_VARIABLE también es posible utilizar un parámetro
actual con un índice de ARRAY variable.
El operando del parámetro POS determina la posición del área de memoria en la que se inicia
la lectura.
Nota
Leer variable del tipo de datos VARIANT o BOOL
Para leer una variable a la que apunta un VARIANT se pueden utilizar las instrucciones
"Serializar" o "Deserializar".
Para leer una variable del tipo de datos BOOL se puede utilizar un "acceso slice".

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Leer datos en formato LittleEndian":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRC_ARRA
Y

Input

ARRAY of BYTE

I, Q, M, D, L

Área de memoria de la que
se lee

OUT

Output

INT

I, Q, M, D, L

Información de error

Programación del PLC
Manual de programación y manejo, 11/2019

1487

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

DEST_VA‐
RIABLE

Output

I, Q, M, D, L
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, LDT, TOD,
LTOD, DATE,
CHAR, WCHAR,
BCD16, BCD32

Área de memoria

Valor leído

POS

InOut

DINT

Determina la posición en la
que se inicia la lectura. El pa‐
rámetro POS se calcula ba‐
sado en cero.

I, Q, M, D, L

Descripción

Parámetro OUT
La tabla siguiente muestra el significado de los valores del parámetro OUT:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B4

El tipo de datos del parámetro SRC_ARRAY no es un ARRAY of BYTE.

8382

El valor del parámetro POS se encuentra fuera de los valores límite del ARRAY.

8383

El valor del parámetro POS se encuentra dentro de los valores límite del ARRAY, pero el
tamaño del área de memoria excede el límite superior del ARRAY.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL READ_LITTLE

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista desplegable "???".

1488

SRC_ARRAY := #SourceField

// El entero 1_295_788_826 se lee desde el área de memoria #SourceField.

OUT := "Tag_Error"

// Información de error

DEST_VARIABLE := #DINTVariable

// El entero se escribe en formato Little Endian en el
operando #DINTVariable. El tipo de datos del parámetro
DEST_VARIABLE indica cuántos bytes se leen.

POS := #TagPos

// En el operando #TagPos se guarda el número 4.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

SRC_ARRAY

#SourceField

ARRAY[0..3] of BYTE

DEST_VARIABLE

#DINTVariable

1295788826

POS

#TagPos

0 => 4

:= 16#1A, 16#2B, 16#3C, 16#4D
16#4D3C2B1A

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

WRITE_LITTLE: Escribir datos en formato Little-Endian
Descripción
La instrucción "Escribir datos en formato Little-Endian" permite escribir los datos de una única
variable de la orden de bytes Little-Endian en un área de memoria. En el formato Little-Endian,
primero se guarda el byte con los bits menos significativos, es decir, en la dirección de memoria
más baja.
Los parámetros SRC_VARIABLE y DEST_ARRAY son del tipo de datos VARIANT. No
obstante, hay algunas restricciones en cuanto al tipo de datos con el que pueden
interconectarse los parámetros. El VARIANT del parámetro SRC_VARIABLE debe apuntar a
un tipo de datos simple. El VARIANT del parámetro DEST_ARRAY apunta a un área de
memoria en la que se escriben los datos, y debe ser un ARRAY of BYTE.
En los parámetros SRC_ARRAY y DEST_VARIABLE también es posible utilizar un parámetro
actual con un índice de ARRAY variable.
El operando del parámetro POS determina la posición del área de memoria en la que se inicia
la escritura.
Nota
Escribir variable del tipo de datos VARIANT o BOOL
Para escribir una variable a la que apunta un VARIANT se pueden utilizar las instrucciones
"Serializar" o "Deserializar".
Para escribir una variable del tipo de datos BOOL se puede utilizar un "acceso slice".

Programación del PLC
Manual de programación y manejo, 11/2019

1489

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Escribir datos en formato LittleEndian":
Parámetro

Declaración

Tipo de datos

Área de memoria

SRC_VARIA‐ Input
BLE

I, Q, M, D, L
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, LDT, TOD,
LTOD, DATE,
CHAR, WCHAR,
BCD16, BCD32

OUT

Output

Descripción
Variable cuyos datos se es‐
criben

INT

I, Q, M, D, L

Información de error

DEST_ARRA InOut
Y

ARRAY of BYTE

I, Q, M, D, L

Área de memoria en la que
se escriben los datos

POS

DINT

I, Q, M, D, L

Determina la posición en la
que se inicia la escritura. El
parámetro POS se calcula
basado en cero.

InOut

Parámetro OUT
La tabla siguiente muestra el significado de los valores del parámetro OUT:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B4

El tipo de datos del parámetro SRC_ARRAY no es un ARRAY of BYTE.

8382

El valor del parámetro POS se encuentra fuera de los valores límite del ARRAY.

8383

El valor del parámetro POS se encuentra dentro de los valores límite del ARRAY, pero el
tamaño del área de memoria excede el límite superior del ARRAY.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL WRITE_LITTLE

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista desplegable "???".

SRC_VARIABLE := #DINTVaria- // El entero 1_295_788_826 del operando #DINTVariable
ble
se escribe en formato Little Endian en el área de memoria #TargetField. El tipo de datos del parámetro SRC_VARIABLE indica cuántos bytes se escriben.

1490

OUT := "Tag_Error"

// Información de error

DEST_ARRAY := #TargetField

// Área de memoria

POS := #TagPos

// En el operando #TagPos se guarda el número 4.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

SRC_VARIABLE

#DINTVariable

1295788826

DEST_ARRAY

#TargetField

ARRAY[0..10] of BYTE

POS

#TagPos

0 => 4

16#4D3C2B1A
= 16#1A, 16#2B, 16#3C, 16#4D

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

READ_BIG: Leer datos en formato Big-Endian
Descripción
La instrucción "Leer datos en formato Big-Endian" permite leer datos de un área de memoria
y escribirlos en una única variable en el orden de bytes Big-Endian. En el formato Big-Endian,
primero se guarda el byte con los bits más significativos, es decir, en la dirección de memoria
más baja.
Los parámetros SRC_ARRAY y DEST_VARIABLE son del tipo de datos VARIANT. No
obstante, hay algunas restricciones en cuanto al tipo de datos con el que pueden
interconectarse los parámetros. El VARIANT del parámetro DEST_VARIABLE debe apuntar a
un tipo de datos simple. El VARIANT del parámetro SRC_ARRAY apunta a un área de
memoria que se lee, y debe ser un ARRAY of BYTE.
En los parámetros SRC_ARRAY y DEST_VARIABLE también es posible utilizar un parámetro
actual con un índice de ARRAY variable.
El operando del parámetro POS determina la posición del área de memoria en la que se inicia
la lectura.
Nota
Leer variable del tipo de datos VARIANT o BOOL
Para leer una variable a la que apunta un VARIANT se pueden utilizar las instrucciones
"Serializar" o "Deserializar".
Para leer una variable del tipo de datos BOOL se puede utilizar un "acceso slice".

Programación del PLC
Manual de programación y manejo, 11/2019

1491

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Leer datos en formato Big-Endian":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRC_ARRA
Y

Input

ARRAY of BYTE

I, Q, M, D, L

Área de memoria de la que
se lee

OUT

Output

INT

I, Q, M, D, L

Información de error

DEST_VA‐
RIABLE

Output

I, Q, M, D, L
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, LDT, TOD,
LTOD, DATE,
CHAR, WCHAR,
BCD16, BCD32

Valor leído

POS

InOut

DINT

Determina la posición en la
que se inicia la lectura. El pa‐
rámetro POS se calcula ba‐
sado en cero.

I, Q, M, D, L

Parámetro OUT
La tabla siguiente muestra el significado de los valores del parámetro OUT:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B4

El tipo de datos del parámetro SRC_ARRAY no es un ARRAY of BYTE.

8382

El valor del parámetro POS se encuentra fuera de los valores límite del ARRAY.

8383

El valor del parámetro POS se encuentra dentro de los valores límite del ARRAY, pero el
tamaño del área de memoria excede el límite superior del ARRAY.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL READ_BIG

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista desplegable "???".

1492

SRC_ARRAY := #SourceField

// El entero 439_041_101 se lee desde el área de memoria
#SourceField.

OUT := "Tag_Error"

// Información de error

DEST_VARIABLE := #DINTVariable

// El entero se escribe en formato Big Endian en el operando #DINTVariable. El tipo de datos del parámetro
DEST_VARIABLE indica cuántos bytes se leen.

POS := #TagPos

// En el operando #TagPos se guarda el número 4.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

SRC_ARRAY

#SourceField

ARRAY[0..10] of BYTE

DEST_VARIABLE

#DINTVariable

439041101

POS

#TagPos

0 => 4

:= 16#1A, 16#2B, 16#3C, 16#4D
16#1A2B3C4D

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

WRITE_BIG: Escribir datos en formato Big-Endian
Descripción
La instrucción "Escribir datos en formato Big-Endian" permite escribir los datos de una única
variable de la orden de bytes Big-Endian en un área de memoria. En el formato Big-Endian,
primero se guarda el byte con los bits más significativos, es decir, en la dirección de memoria
más baja.
Los parámetros SRC_VARIABLE y DEST_ARRAY son del tipo de datos VARIANT. No
obstante, hay algunas restricciones en cuanto al tipo de datos con el que pueden
interconectarse los parámetros. El VARIANT del parámetro SRC_VARIABLE debe apuntar a
un tipo de datos simple. El VARIANT del parámetro DEST_ARRAY apunta a un área de
memoria en la que se escriben los datos, y debe ser un ARRAY of BYTE.
En los parámetros SRC_ARRAY y DEST_VARIABLE también es posible utilizar un parámetro
actual con un índice de ARRAY variable.
El operando del parámetro POS determina la posición del área de memoria en la que se inicia
la escritura.
Nota
Escribir variable del tipo de datos VARIANT o BOOL
Para escribir una variable a la que apunta un VARIANT se pueden utilizar las instrucciones
"Serializar" o "Deserializar".
Para escribir una variable del tipo de datos BOOL se puede utilizar un "acceso slice".

Programación del PLC
Manual de programación y manejo, 11/2019

1493

Instrucciones
4.1 Instrucciones

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Escribir datos en formato BigEndian":
Parámetro

Declaración

Tipo de datos

Área de memoria

SRC_VARIA‐ Input
BLE

I, Q, M, D, L
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, LDT, TOD,
LTOD, DATE,
CHAR, WCHAR,
BCD16, BCD32

OUT

Output

Descripción
Variable cuyos datos se es‐
criben

INT

I, Q, M, D, L

Información de error

DEST_ARRA InOut
Y

ARRAY of BYTE

I, Q, M, D, L

Área de memoria en la que
se escriben los datos

POS

DINT

I, Q, M, D, L

Determina la posición en la
que se inicia la escritura. El
parámetro POS se calcula
basado en cero.

InOut

Parámetro OUT
La tabla siguiente muestra el significado de los valores del parámetro OUT:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B4

El tipo de datos del parámetro SRC_ARRAY no es un ARRAY of BYTE.

8382

El valor del parámetro POS se encuentra fuera de los valores límite del ARRAY.

8383

El valor del parámetro POS se encuentra dentro de los valores límite del ARRAY, pero el
tamaño del área de memoria excede el límite superior del ARRAY.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL WRITE_BIG

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista desplegable "???".

SRC_VARIABLE := #DINTVaria- // El entero 439_041_101 del operando #DINTVariable se
ble
escribe en formato Big Endian en el área de memoria #TargetField. El tipo de datos del parámetro SRC_VARIABLE
indica cuántos bytes se escriben.

1494

OUT := "Tag_Error"

// Información de error

DEST_ARRAY := #TargetField

// Área de memoria

POS := #TagPos

// En el operando #TagPos se guarda el número 4.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Operando

Valor

SRC_VARIABLE

#DINTVariable

439041101

DEST_ARRAY

#TargetField

ARRAY[0..10] of BYTE

POS

#TagPos

0 => 4

16#1A2B3C4D
= 16#1A, 16#2B, 16#3C, 16#4D

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

VARIANT
VariantGet: Leer valor de una variable VARIANT
Descripción
Con la instrucción "Leer valor de una variable VARIANT" se lee el valor de la variable a la que
apunta VARIANT en el parámetro SRC y se escribe este valor en la variable del parámetro
DST.
El parámetro SRC es del tipo de datos VARIANT. En el parámetro DST se puede indicar
cualquier tipo de datos excepto VARIANT.
El tipo de datos de la variable indicada en el parámetro DST debe coincidir con el tipo de datos
al que apunta VARIANT.
Nota
Para copiar estructuras y ARRAY también se puede utilizar la instrucción
"MOVE_BLK_VARIANT: Copiar área". Encontrará más información al respecto en "Consulte
también".

Programación del PLC
Manual de programación y manejo, 11/2019

1495

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Leer valor de una variable
VARIANT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRC

Input

VARIANT

L (puede declarar‐ Variable que se lee
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

DST

Output

I, Q, M, D, L, P
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, tiempos, fe‐
cha y hora, se‐
cuencias de carac‐
teres, elementos
de ARRAY, tipos
de datos PLC

Resultado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL VariantGet

// Se llama la instrucción

SRC := #TagIn_Source

// El valor de la variable al que señala VARIANT en
el operando #TagIn_Source se lee.

DST := "TagOut_Dest"

// El contenido de la variable se escribe en el operando "TagOut_Dest".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de VARIANT (Página 335)
Bases de AWL (Página 8065)

VariantPut: Escribir valor en una variable VARIANT
Descripción
La instrucción "Escribir valor en una variable VARIANT" escribe el valor de la variable indicada
en el parámetro SRC en la memoria del parámetro DST al que apunta VARIANT.

1496

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El parámetro DST es del tipo de datos VARIANT. En el parámetro SRC se puede indicar
cualquier tipo de datos excepto VARIANT.
El tipo de datos de la variable del parámetro SRC debe coincidir con el tipo de datos al que
apunta VARIANT.
Nota
Para copiar estructuras y ARRAY también se puede utilizar la instrucción
"MOVE_BLK_VARIANT: Copiar área". Encontrará más información al respecto en "Consulte
también".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Escribir valor en una variable
VARIANT":
Parámetro

Declaración

Tipo de datos

Área de memoria

SRC

Input

Secuencias de
I, Q, M, D, L, P
bits, enteros, nú‐
meros en coma flo‐
tante, tiempos, fe‐
cha y hora, se‐
cuencias de carac‐
teres, elementos
de ARRAY, tipos
de datos PLC

DST

Input

VARIANT

Descripción
Variable que se lee

L (puede declarar‐ Resultado de la instrucción
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL VariantPut

// Se llama a la instrucción.

SRC := "TagIn_Source"

// Se lee el valor del operando "TagIn_Source"...

DST := #TagIn_Dest

// y se escribe en la variable a la que señala VARIANT en el operando #TagIn_Dest.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)

Programación del PLC
Manual de programación y manejo, 11/2019

1497

Instrucciones
4.1 Instrucciones
Principios básicos de VARIANT (Página 335)
MOVE_BLK_VARIANT: Copiar área (Página 1436)
Bases de AWL (Página 8065)

CountOfElements: Consultar número de elementos de ARRAY
Descripción
La instrucción "Consultar número de elementos de ARRAY" permite saber el número de
elementos de ARRAY que tiene una variable a la que apunta VARIANT.
Si el ARRAY es unidimensional, el resultado se devuelve como número de elementos ARRAY.
(La diferencia entre el límite superior e inferior + 1). Si el ARRAY es multidimensional, el
resultado se devuelve como cantidad de todas las dimensiones.
Si desea consultar los elementos de un DB de ARRAY deberá utilizar las instrucciones
"ReadFromArrayDB" o "WriteFromArrayDB", puesto que estas permiten una evaluación de
errores más precisa para el número de elementos.
Nota
Instancias
El puntero VARIANT no puede señalar a ninguna instancia y, por lo tanto, tampoco a ninguna
multiinstancia o ARRAY of multiinstancias.
Nota
ARRAY en un bloque de datos
Si desea consultar el número de elementos de un ARRAY que se encuentra en un bloque de
datos, en este no debe estar activado el atributo de bloque "Bloque de datos protegido contra
escritura en el dispositivo". De lo contrario, el parámetro RET_VAL devuelve el resultado "0",
independientemente de cuántos elementos contenga el ARRAY.
El resultado también es "0" si la variable VARIANT no es ARRAY.
Si VARIANT apunta a un ARRAY of BOOL, se cuentan también los elementos de relleno. (P.
ej. con un ARRAY[0..1] of BOOL se devuelve 8.)

1498

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar número de elementos
de ARRAY":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

VARIANT

L (puede declarar‐ Variable que se consulta
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

RET_VAL

Output

UDINT

I, Q, M, D, L

Resultado de la instrucción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL CountOfElements

// Se llama a la instrucción.

IN := #TagIn_Source

// El número de elementos de ARRAY de la
variable a la que señala VARIANT en el
operando #TagIn_Source se lee...

RET_VAL := "TagOut_RetVal"

// y se emite en el operando "TagOut_RetVal".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de VARIANT (Página 335)
Bases de AWL (Página 8065)

ARRAY[*]
LOWER_BOUND: Leer límite inferior del ARRAY
Descripción
En la interfaz de un bloque de función o de una función se pueden declarar variables del tipo
de datos ARRAY[*]. Para estas variables locales pueden leerse los límites del ARRAY. En el
parámetro DIM debe indicarse la dimensión deseada.

Programación del PLC
Manual de programación y manejo, 11/2019

1499

Instrucciones
4.1 Instrucciones
Para leer el límite inferior variable del ARRAY está disponible la instrucción "Leer límite inferior
del ARRAY".
Nota
Disponibilidad de la instrucción
La instrucción está disponible en las CPU de la serie S7-1500 a partir de la versión de firmware
>= 2.0.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Leer límite inferior del ARRAY":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ARR

Input

ARRAY[*]

FB => sección
InOut

ARRAY cuyo límite inferior
variable debe leerse.

FC => sección In‐
put y InOut
DIM

Input

UDINT

I, Q, M, D, L, P o
constante

Dimensión del ARRAY cuyo
límite inferior variable debe
leerse.

OUT

Output

DINT

I, Q, M, D, L, P

Resultado

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL LOWER_BOUND

// Se llama la instrucción.

ARR := #ARRAY_A

// Debe leerse el límite inferior variable del ARRAY #ARRAY_A.

DIM := 2

// Debe leerse el límite inferior variable de la segunda dimensión.

OUT := "Result"

// Resultado de la instrucción

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos del ARRAY (Página 293)
Bases de AWL (Página 8065)

1500

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

UPPER_BOUND: Leer límite superior de ARRAY
Descripción
En la interfaz de un bloque de función o de una función se pueden declarar variables del tipo
de datos ARRAY[*]. Para estas variables locales pueden leerse los límites del ARRAY. En el
parámetro DIM debe indicarse la dimensión deseada.
Para leer el límite superior variable del ARRAY está disponible la instrucción "Leer límite
superior de ARRAY".
Nota
Disponibilidad de la instrucción
La instrucción está disponible en las CPU de la serie S7-1500 a partir de la versión de firmware
>= 2.0.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Leer límite superior de ARRAY":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

ARR

Input

ARRAY[*]

FB => sección
InOut

ARRAY cuyo límite superior
variable debe leerse.

FC => sección In‐
put y InOut
DIM

Input

UDINT

I, Q, M, D, L, P o
constante

Dimensión del ARRAY cuyo
límite superior variable debe
leerse.

OUT

Output

DINT

I, Q, M, D, L, P

Resultado

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL UPPER_BOUND

// Se llama la instrucción.

ARR := #ARRAY_A

// Debe leerse el límite superior variable del ARRAY #ARRAY_A.

DIM := 2

// Debe leerse el límite superior variable de la segunda dimensión.

OUT := "Result"

// Resultado de la instrucción

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)

Programación del PLC
Manual de programación y manejo, 11/2019

1501

Instrucciones
4.1 Instrucciones
Principios básicos del ARRAY (Página 293)
Bases de AWL (Página 8065)

Legacy
BLKMOV: Copiar área
Descripción
La instrucción "Copiar área" permite copiar los contenidos de un área de memoria (área de
origen) en un área de memoria diferente (área de destino). La operación de copia se realiza por
orden ascendente de direcciones. Las áreas de origen y destino se definen mediante
VARIANT.
Nota
Las variables de la instrucción sólo se pueden usar en áreas de memoria en las que no esté
activado el atributo "Acceso optimizado al bloque". Esto es válido para bloques de datos (DB),
bloques de organización (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucción se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable también se puede usar en áreas de memoria "con acceso
optimizado al bloque".
La figura siguiente muestra el principio de la operación de copia:

'%'%:

$

%

'%'%:

&

'

'%'%:

(

)

'%'%:

*

+

&RSLDU
/DFRSLDVHHIHFW¼DHQ
VHQWLGRDVFHQGHQWHGH
ODVGLUHFFLRQHV

0:

$

%

0:

&

'

0:

(

)

0:

*

+

UHDGHPHPRULD

1502

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Coherencia de los datos de origen y destino
Tenga en cuenta que al ejecutar la instrucción "Copiar área" no se modifican los datos de
origen. De lo contrario no está garantizada la coherencia de los datos de destino.

Posibilidad de interrupción
No hay limitaciones en cuanto a la profundidad de anidamiento.

Áreas de memoria
La instrucción "Copiar área" permite copiar las siguientes áreas de memoria:
● Áreas de un bloque de datos
● Marcas
● Memoria imagen de proceso de las entradas
● Memoria imagen de proceso de las salidas

Reglas generales para copiar
Las áreas de origen y destino no deben solaparse. Si las áreas de origen y destino son de
diferente longitud, se copia solo hasta la longitud del área más pequeña.
Si el área de origen es más pequeña que el área de destino, el área de origen se copiará por
completo en el área de destino. Los restantes bytes del área de destino permanecen
inalterados.
Si el área de destino es más pequeña que el área de origen, se escribirá en toda el área de
destino. Los restantes bytes del área de origen se ignoran.
Al copiar un área del tipo de datos BOOL, la variable debe direccionarse de forma absoluta y
la longitud indicada del área debe ser un múltiplo de 8, pues de lo contrario no se ejecutará la
instrucción.

Reglas para copiar cadenas de caracteres
La instrucción "Copiar área" permite copiar asimismo áreas de origen y destino del tipo de
datos STRING. Si solo el área de origen es del tipo de datos STRING, se copiarán los
caracteres que realmente contiene la cadena de caracteres. La información sobre la longitud
real y máxima también se escribe en el área de destino. Si tanto el área de origen como el área
de destino son del tipo de datos STRING, la longitud actual de la cadena de caracteres en el
área de destino se pone al número de caracteres realmente copiados.
Si se desea copiar información sobre la longitud máxima y real de una cadena de caracteres,
las áreas de los parámetros SRCBLK y DSTBLK deben indicarse en bytes.

Programación del PLC
Manual de programación y manejo, 11/2019

1503

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Copiar área":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRCBLK

Input

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria que se copia (área de ori‐
gen).

RET_VAL

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

DSTBLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria en la que se copia (área
de destino).

1) El parámetro DSTBLK está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

8092

El área de origen o destino está solo en la memoria de carga.

8152

En el parámetro SRCBLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

8352

En el parámetro DSTBLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
Información
de error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1504

AWL

Explicación

CALL BLKMOV

// Se llama la instrucción "Copiar área".

SRCBLK := P#M100.0 BYTE 10

// Se copian 10 bytes a partir de MB100.

RET_VAL := "Tag_ErrorCode"

// Si ocurre un error durante la operación de copia,
el respectivo código de error se deposita en la variable "Tag_ErrorCode".

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

DSTBLK := P#M200.0 BYTE 10

// Los bytes copiados se escriben en los 10 bytes a
partir de MB200.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1537)
Bases de AWL (Página 8065)

UBLKMOV: Copiar área sin interrupciones
Descripción
La instrucción "Copiar área sin interrupciones" permite copiar los contenidos de un área de
memoria (área de origen) en un área de memoria diferente (área de destino). La operación de
copia se realiza por orden ascendente de direcciones. Las áreas de origen y destino se definen
mediante VARIANT.
La operación de copia no debe ser interrumpida por otras actividades del sistema operativo.
Ello puede aumentar el tiempo de reacción a alarmas de la CPU durante la ejecución de la
instrucción "Copiar área sin interrupciones".
Nota
Las variables de la instrucción sólo se pueden usar en áreas de memoria en las que no esté
activado el atributo "Acceso optimizado al bloque". Esto es válido para bloques de datos (DB),
bloques de organización (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucción se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable también se puede usar en áreas de memoria "con acceso
optimizado al bloque".

Áreas de memoria
La instrucción "Copiar área sin interrupciones" permite copiar las siguientes áreas de memoria:
● Áreas de un bloque de datos
● Marcas
● Memoria imagen de proceso de las entradas
● Memoria imagen de proceso de las salidas

Programación del PLC
Manual de programación y manejo, 11/2019

1505

Instrucciones
4.1 Instrucciones

Reglas generales para copiar
Al ejecutar la instrucción "Copiar área sin interrupciones" no pueden solaparse las áreas de
origen y destino. Si el área de origen es más pequeña que el área de destino, el área de origen
se copiará por completo en el área de destino. Los restantes bytes del área de destino
permanecen inalterados.
Si el área de destino es más pequeña que el área de origen, se escribirá en toda el área de
destino. Los restantes bytes del área de origen se ignoran.
Si un área de origen o destino definida como parámetro formal es menor que un área de origen
o destino indicada en los parámetros SRCBLK o DSTBLK, no se transferirán datos.
Al copiar un área del tipo de datos BOOL, la variable debe direccionarse de forma absoluta y
la longitud indicada del área debe ser un múltiplo de 8, pues de lo contrario no se ejecutará la
instrucción.
La instrucción "Copiar área sin interrupciones" permite copiar 16 KB como máximo. A este
respecto deben tenerse en cuenta las limitaciones específicas de la CPU.

Reglas para copiar cadenas de caracteres
La instrucción "Copiar área sin interrupciones" permite copiar asimismo áreas de origen y
destino del tipo de datos STRING. Si solo el área de origen es del tipo de datos STRING, se
copiarán los caracteres que realmente contiene la cadena de caracteres. La información sobre
la longitud real y máxima no se escribe en el área de destino. Si tanto el área de origen como
el área de destino son del tipo de datos STRING, la longitud actual de la cadena de caracteres
en el área de destino se pone al número de caracteres realmente copiados. Si se copian áreas
del tipo de datos STRING, debe indicarse "1" como longitud del área.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Copiar área sin interrupciones":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

SRCBLK

Input

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria que se copia (área de ori‐
gen).

RET_VAL

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

DSTBLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria en la que se copia (área
de destino).

1) El parámetro DSTBLK está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

1506

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

8091

El área de origen o destino está solo en la memoria de carga.

8152

En el parámetro SRCBLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

8352

En el parámetro DSTBLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
Información
de error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL UBLKMOV

// Se llama la instrucción "Copiar área sin interrupciones".

SRCBLK := P#M100.0 BYTE 10

// Se copian 10 bytes a partir de MB100.

RET_VAL := "Tag_ErrorCode"

// Si ocurre un error durante la operación de copia,
el respectivo código de error se deposita en la variable "Tag_ErrorCode".

DSTBLK := P#M200.0 BYTE 10

// Los bytes copiados se escriben en los 10 bytes a
partir de MB200.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1537)
Bases de AWL (Página 8065)

Programación del PLC
Manual de programación y manejo, 11/2019

1507

Instrucciones
4.1 Instrucciones

FILL: Rellenar área
Descripción
La instrucción "Rellenar área" rellena un área de memoria (área de destino) con el contenido
de un área de memoria diferente (área de origen). La instrucción "Rellenar área" copia el
contenido del área de origen en el área de destino las veces necesarias hasta que el área de
destino quede escrita por completo. La operación de copia se realiza por orden ascendente de
direcciones.
Las áreas de origen y destino se definen mediante VARIANT.
Nota
Las variables de la instrucción sólo se pueden usar en áreas de memoria en las que no esté
activado el atributo "Acceso optimizado al bloque". Esto es válido para bloques de datos (DB),
bloques de organización (OB), funciones (FC), marcas (M), entradas (I) y salidas (Q).
Sin embargo, si una variable de la instrucción se ha declarado con el ajuste de remanencia
"Ajustar en IDB", la variable también se puede usar en áreas de memoria "con acceso
optimizado al bloque".
Para los bloques con el atributo "Acceso optimizado al bloque" puede utilizarse la instrucción
"FILL_BLK: Rellenar área".
La figura siguiente muestra el principio de la operación de copia:
),//

%9$/

$

%

0:

$

%

0:

&

'

0:

&

'

0:

(

)

0:

(

)

0:

*

+

0:

*

+

0:

$

%

0:

&

'

0:

(

)

0:

*

+

0:

$

%

0:

&

'

0:

%/.

Ejemplo: el contenido del área MW100 a MW118 debe inicializarse con el contenido de las
palabras de marcas MW14 a MW20.

1508

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Coherencia de los datos de origen y destino
Tenga en cuenta que al ejecutar la instrucción "Rellenar área" no se modifican los datos de
origen, pues de lo contrario no se podría garantizar la coherencia de los datos de destino.

Áreas de memoria
La instrucción "Rellenar área" permite copiar las siguientes áreas de memoria:
● Áreas de un bloque de datos
● Marcas
● Memoria imagen de proceso de las entradas
● Memoria imagen de proceso de las salidas

Reglas generales para copiar
Las áreas de origen y destino no deben solaparse. Aunque el área de destino que se debe
inicializar no sea múltiplo entero de la longitud del parámetro de entrada BVAL, el área de
destino se rellenará igualmente hasta el último byte.
Si el área de destino que se debe rellenar es menor que el área de origen, sólo se copiarán los
datos que quepan en el área de destino.
Si el área de origen o destino realmente existente es menor que el tamaño del área de memoria
parametrizada para el área de origen o destino (parámetros BVAL, BLK), los datos no se
transfieren.
Si el puntero ANY (origen o destino) es del tipo de datos BOOL, debe direccionarse de forma
absoluta y la longitud indicada del área debe ser un múltiplo de 8, pues de lo contrario no se
ejecutará la instrucción.
Si el área de destino es del tipo de datos STRING, la instrucción escribe la cadena de
caracteres completa, incluida la información de administración.

Reglas para copiar estructuras
Al transferir una estructura a modo de parámetro de entrada, tenga en cuenta que la longitud
de una estructura se rige siempre por un número par de bytes. Si se declara una estructura con
un número impar de bytes, la estructura necesitará un byte adicional de espacio en memoria.

Programación del PLC
Manual de programación y manejo, 11/2019

1509

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Rellenar área":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

BVAL

Input

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria (área de origen) con cuyo
contenido se rellena el área
de destino en el parámetro
BLK.

RET_VAL

Output

INT

I, Q, M, D, L, P

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

BLK

Output 1)

VARIANT

I, Q, M, D, L, P

Indicación del área de memo‐
ria que se rellena con el con‐
tenido del área de origen.

1) El parámetro BLK está declarado como Output, ya que los datos desembocan en la variable. Sin
embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

8092

El área de origen o destino está solo en la memoria de carga.

8152

En el parámetro BVAL no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

8352

En el parámetro BLK no están permitidos los tipos de datos WSTRING, WCHAR,
BOOL, ARRAY of STRING, ARRAY of WSTRING y ARRAY of WCHAR.

Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
Información
de error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1510

AWL

Explicación

CALL FILL

// Se llama la instrucción "Rellenar área".

BVAL := P#M14.0 WORD 4

// Se copia el área de MW14 a MW20.

RET_VAL := "Tag_ErrorCode"

// Información de error

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

BLK := P#M100.0 WORD 10

// El área de memoria de MW100 a MW118 se rellena con
el contenido de las 4 palabras contenidas en el área
de memoria del parámetro BVAL.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1537)
Bases de AWL (Página 8065)

Conversión
SCALE_X: Escalar
Descripción
La instrucción "Escalar" escala el valor de la entrada VALUE mapeándolo en un determinado
rango de valores. Al ejecutar la instrucción "Escalar", el número en coma flotante de la entrada
VALUE se escala al rango de valores definido por los parámetros MIN y MAX. El resultado de
la escala es un número entero que se deposita en la salida RET_VAL.
La figura siguiente muestra un ejemplo de cómo pueden escalarse los valores:

0$;
287
0,1



9$/8(

La instrucción "Escalar" utiliza la siguiente ecuación:

Programación del PLC
Manual de programación y manejo, 11/2019

1511

Instrucciones
4.1 Instrucciones
OUT = [VALUE ∗ (MAX – MIN)] + MIN
Nota
Encontrará más información sobre la conversión de valores analógicos en el manual de
producto correspondiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Escalar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MIN

Input

Enteros, números
en coma flotante

I, Q, M, D, L o
constante

Límite inferior del rango de
valores

VALUE

Input

Números en coma
flotante

I, Q, M, D, L o
constante

Valor que se escala.
Si se indica una constante,
esta debe declararse.

MAX

Input

Enteros, números
en coma flotante

I, Q, M, D, L o
constante

Límite superior del rango de
valores

RET_VAL

Output

Enteros, números
en coma flotante

I, Q, M, D, L

Resultado de la escala

En las listas desplegables "???" puede seleccionar los tipos de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Encontrará más información sobre la declaración de constantes en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL SCALE_X

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

MIN := "Tag_Minimum"

// Valor límite inferior

VALUE := "Tag_Value"

// Valor en coma flotante

MAX := "Tag_Maximum"

// Valor límite superior

RET_VAL := "Tag_Result"

// Resultado de la instrucción

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

1512

Operando

Valor

MIN

Tag_Minimum

10

VALUE

Tag_Value

0.5

MAX

Tag_Maximum

30

OUT

Tag_Result

20

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El valor de la entrada "Tag_Value" se escala al rango de valores definido por los valores de las
entradas "Tag_Minimum" y "Tag_Maximum". El resultado se deposita en la salida
"Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Declarar constantes globales (Página 7910)
Bases de AWL (Página 8065)

NORM_X: Normalizar
Descripción
La instrucción "Normalizar" normaliza el valor de la variable de la entrada VALUE
representándolo en una escala lineal. Los parámetros MIN y MAX sirven para definir los límites
de un rango de valores que se refleja en la escala. En función de la posición del valor que se
debe normalizar en este rango de valores, el resultado se calcula y se deposita como número
en coma flotante en la salida RET_VAL. Si el valor que se debe normalizar es igual al valor de
la entrada MIN, la salida OUT devuelve el valor "0.0". Si el valor que se debe normalizar es
igual al de la entrada MAX, la salida OUT devuelve el valor "1.0".
La figura siguiente muestra un ejemplo de cómo pueden normalizarse los valores:


287

0,1

0$;
9$/8(

La instrucción "Normalizar" utiliza la siguiente ecuación:

Programación del PLC
Manual de programación y manejo, 11/2019

1513

Instrucciones
4.1 Instrucciones
OUT = (VALUE – MIN) / (MAX – MIN)
Nota
Encontrará más información sobre la conversión de valores analógicos en el manual de
producto correspondiente.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Normalizar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

MIN

Input

Enteros, números
en coma flotante

I, Q, M, D, L

Límite inferior del rango de
valores

VALUE 1)

Input

Enteros, números
en coma flotante

I, Q, M, D, L

Valor que se normaliza

MAX 1)

Input

Enteros, números
en coma flotante

I, Q, M, D, L

Límite superior del rango de
valores

RET_VAL

Output

Números en coma
flotante

I, Q, M, D, L

Resultado de la normaliza‐
ción

1)

1)

Si se utilizan constantes en estos tres parámetros, basta con declarar una de ellas.

En las listas desplegables "???" puede seleccionar los tipos de datos de la instrucción.
Encontrará más información sobre los tipos de datos válidos en "Consulte también".
Encontrará más información sobre la declaración de constantes en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL NORM_X

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

MIN := "Tag_Minimum"

// Valor límite inferior

VALUE := "Tag_Value"

// Valor en coma flotante

MAX := "Tag_Maximum"

// Valor límite superior

RET_VAL := "Tag_Result"

// Resultado de la instrucción

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:

1514

Parámetro

Operando

Valor

MIN

Tag_Minimum

10

VALUE

Tag_Value

20

MAX

Tag_Maximum

30

RET_VAL

Tag_Result

0.5

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El valor de la entrada "Tag_Value" se asigna al rango de valores definido por los valores de las
entradas "Tag_Minimum" y "Tag_Maximum". El valor de la variable de la entrada "Tag_Value"
se normaliza conforme al rango de valores definido. El resultado se deposita como número en
coma flotante en la salida "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Declarar constantes globales (Página 7910)
Bases de AWL (Página 8065)

VARIANT
VARIANT_TO_DB_ANY: Convertir VARIANT en DB_ANY
Descripción
La instrucción "Convertir VARIANT en DB_ANY" consulta el número de bloque de datos que
direcciona el operando indicado en el parámetro IN. Se puede tratar de un bloque de datos de
instancia o de un bloque de datos ARRAY. El operando del parámetro IN es del tipo de datos
VARIANT, por lo que al escribir el programa no se necesita saber qué tipo de datos tiene el
bloque de datos, cuyo número debe consultarse. El número del bloque de datos se lee en
tiempo de ejecución y se escribe en el operando indicado en el parámetro RET_VAL.

Requisitos
Si se cumplen los requisitos, se ejecuta la instrucción. Si no se cumplen los requisitos, se
devuelve "0" como número del bloque de datos.
La variable de salida...

referencia...

Posibilidades de conversión

VARIANT

... un bloque de datos que puede
ser un bloque de datos de ins‐
tancia de un tipo de datos PLC o
de un tipo de datos del sistema
(SDT).

Es posible convertir la variable
de salida a un número del bloque
de datos.

VARIANT

... un bloque de datos que es un
DB de ARRAY.

Es posible convertir la variable
de salida a un número del bloque
de datos.

Programación del PLC
Manual de programación y manejo, 11/2019

1515

Instrucciones
4.1 Instrucciones
La variable de salida...

referencia...

Posibilidades de conversión

VARIANT

... una variable con un tipo de
datos simple.

No es posible convertir la varia‐
ble de salida a un número del
bloque de datos, puesto que un
bloque de datos nunca consta
solamente de un tipo de datos
simple.

VARIANT

... una estructura de un bloque
de datos.

No es posible convertir la varia‐
ble de salida a un número del
bloque de datos, puesto que so‐
lo se trata de una parte del blo‐
que de datos.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Convertir VARIANT en DB_ANY":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

VARIANT

L (puede declarar‐
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

Variable que se lee. (Valor de
función de la instrucción
"DB_ANY_TO_VARIANT")
En el parámetro IN puede
emplearse una variable local
o global.

RET_VAL

Output

DB_ANY

I, Q, M, D, L

Resultado: número de DB

ERR

Output

INT

I, Q, M, D, L

Información de error

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro ERR
La tabla siguiente muestra el significado de los valores del parámetro ERR:
Código de
error*

Explicación

(W#16#...)

1516

0000

Ningún error

252C

El tipo de datos VARIANT del parámetro IN devuelve el valor "0" y la CPU pasa al estado
operativo STOP.

80B4

El tipo de datos del elemento, guardado en el bloque de datos ARRAY, no concuerda con
el tipo de datos del elemento transferido en VARIANT.

8130

El parámetro IN es del tipo de datos ANY.

8131

El bloque de datos no existe, es demasiado corto o está en la memoria de carga.

8132

El bloque de datos es demasiado corto y no es un bloque de datos ARRAY.

8150

El tipo de datos VARIANT del parámetro IN devuelve el valor "0". Para recibir este men‐
saje de error, la propiedad de bloque "Tratamiento local de errores en el bloque" debe
estar activada. En caso contrario, la CPU pasa al estado operativo STOP y devuelve el
código de error 16#252C.

8153

El tipo de datos VARIANT del parámetro IN no apunta al principio de un bloque de datos
ARRAY o bien la longitud del VARIANT no concuerda con la del bloque de datos.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Código de
error*

Explicación

(W#16#...)
8154

El bloque de datos es de un tipo incorrecto.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL VARIANT_TO_DB_ANY

// Se llama a la instrucción.

IN := #tempVARIANT

// Se lee el número de un bloque de datos
indicado en el operando tempVARIANT. Puesto que el operando es del tipo de datos
VARIANT, en el momento de la elaboración
del programa aún no es necesario saber de
qué tipo de datos es la variable.

RET_VAL := "OutputDBNumber"

// El número se escribe en la variable
"OutputDBNumber", que es del tipo de datos DB_ANY.

ERR := "Tag_Error"

// Información de error

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Declaración en la inter‐
faz del bloque

Operando

Valor

IN

Input

tempVARIANT

-

RET_VAL

Output

OutputDBNumber

11

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de VARIANT (Página 335)
Uso del tipo de datos DB_ANY (Página 216)
Bases de AWL (Página 8065)

Programación del PLC
Manual de programación y manejo, 11/2019

1517

Instrucciones
4.1 Instrucciones

DB_ANY_TO_VARIANT: Convertir DB_ANY en VARIANT
Descripción
La instrucción "Convertir DB_ANY en VARIANT" permite generar, a partir de un bloque de
datos, una variable VARIANT que cumple los requisitos abajo indicados. El operando del
parámetro IN es del tipo de datos DB_ANY, por lo que al escribir el programa no es necesario
conocer el bloque de datos. El número del bloque de datos se lee en tiempo de ejecución.

Requisitos
Si se cumplen los requisitos, se ejecuta la instrucción. Si no se cumplen los requisitos o el
bloque de datos no existe, se devuelve el valor NULL en el parámetro RET_VAL. Los demás
accesos con la variable RET_VAL dan error.
La variable de entrada del tipo
de datos...

referencia...

Posibilidades de conversión

DB_ANY

... un bloque de datos que puede
ser un bloque de datos de ins‐
tancia de un tipo de datos PLC o
de un tipo de datos del sistema
(SDT).

La conversión es posible

DB_ANY

... un bloque de datos que es un
DB de ARRAY.

La conversión es posible

DB_ANY

... un bloque de datos que puede
ser un bloque de datos de ins‐
tancia de un bloque de función o
un bloque de datos global.

La conversión no es posible

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Convertir DB_ANY en VARIANT":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

DB_ANY

I, Q, M, D, L

Bloque de datos cuyo núme‐
ro se lee. En el parámetro IN
puede emplearse una varia‐
ble local o global.

RET_VAL

Output 1)

VARIANT

L (puede declarar‐ Número del bloque de datos
se en las seccio‐
nes "Input",
"InOut" y "Temp"
de la interfaz del
bloque.)

ERR

Output

INT

I, Q, M, D, L

Información de error

1) El parámetro RET_VAL está declarado como Output, ya que los datos desembocan en la variable.
Sin embargo, la propia variable debe declararse como InOut en la interfaz del bloque.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

1518

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro ERR
La tabla siguiente muestra el significado de los valores del parámetro ERR:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

8130

El número del bloque de datos es "0".

8131

El bloque de datos no existe, es demasiado corto o está en la memoria de carga.

8132

El bloque de datos es demasiado corto y no es un bloque de datos ARRAY.

8134

El bloque de datos está protegido contra escritura.

8154

El bloque de datos es de un tipo incorrecto.

8155

El bloque de datos es de un tipo de datos desconocido. 1)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".
1)

La causa del código de error #8155 es la siguiente:

Se ha declarado un tipo de datos PLC (UDT1) y a continuación se crea un bloque de datos
(DB2) del tipo de datos "UDT1". En la tabla de variables hay una variable (3) del tipo de datos
DB_ANY. En un bloque de programa (4) se llamó entonces la instrucción
"DB_ANY_TO_VARIANT" y se le asignó la variable (3) en el parámetro IN. Al ejecutar la
instrucción "DB_ANY_TO_VARIANT", se emite el código de error 16#8155.
Para resolver el código de error, haga lo siguiente:
1. Cree una función (FC5) y declare una variable del tipo de datos VARIANT en la interfaz
InOut.
2. Cree otra función (FC6) y en ella llame FC5.
3. En FC6, en la interfaz Temp, cree una variable (7) del tipo de datos "UDT1".
4. Asigne a la interfaz InOut de FC5 la variable (7).
5. Compile y cargue los dos bloques (FC5 y FC6) en la CPU. No hace falta que llame estos
bloques (FC5 y FC6) en el programa de usuario.
Resultado:
El código de error 16#8155 no se emite, puesto que el programa de usuario ya conoce el tipo
de datos.
Este proceso no es necesario si después de llamar la instrucción "DB_ANY_TO_VARIANT",
llama una de las dos instrucciones "VariantGet" o "VariantPut".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL DB_ANY_TO_VARIANT

// Se llama a la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

1519

Instrucciones
4.1 Instrucciones
AWL

Explicación

IN := "InputDB"

// El número de un bloque de datos cualquiera indicado en el operando "InputDB" se utiliza para generar una variable del tipo de
datos VARIANT que direcciona el bloque de
datos. Puesto que el operando del parámetro
IN es del tipo de datos DB_ANY, al escribir
el programa aún no es necesario saber qué
bloque de datos se utilizará en tiempo de
ejecución, ni tampoco el nombre y el número
del bloque de datos.

RET_VAL := #tempVARIANT

// Puesto que el operando del parámetro
RET_VAL es del tipo de datos VARIANT, al escribir el programa aún no es necesario saber
de qué tipo de datos es el bloque de datos.

ERR := "Tag_Error"

// Información de error

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Parámetro

Declaración en la inter‐
faz del bloque

Operando

Valor

IN

Input

InputDB

11

RET_VAL

Temp

tempVARIANT

-

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Principios básicos de VARIANT (Página 335)
Uso del tipo de datos DB_ANY (Página 216)
Bases de AWL (Página 8065)

Legacy
SCALE: Escalar
Descripción
La instrucción "Escalar" convierte el entero del parámetro IN en un número en coma flotante
que se escala en unidades físicas entre un límite inferior y uno superior. Los límites inferior y
superior del rango de valores en el que se escala el valor de entrada se definen mediante los
parámetros LO_LIM y HI_LIM. El resultado de la instrucción se devuelve en el parámetro OUT.
La instrucción "Escalar" utiliza la siguiente ecuación:
OUT = [((FLOAT (IN) – K1)/(K2–K1)) ∗ (HI_LIM–LO_LIM)] + LO_LIM

1520

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El estado lógico del parámetro BIPOLAR determina los valores de las constantes "K1" y "K2".
El parámetro BIPOLAR puede tener los siguientes estados lógicos:
● Estado lógico "1": se presupone que el valor del parámetro IN es bipolar y está comprendido
en un rango de valores entre -27648 y 27648. En este caso, la constante "K1" tiene el valor
-27648,0, y la constante "K2", el valor +27648,0.
● Estado lógico "0": se presupone que el valor del parámetro IN es unipolar y está
comprendido en un rango de valores entre 0 y 27648. En este caso, la constante "K1" tiene
el valor 0,0, y la constante "K2", el valor +27648,0.
Si el valor del parámetro IN es mayor que el de la constante "K2", el resultado de la instrucción
se pone al valor del límite superior (HI_LIM) y se emite un error.
Si el valor del parámetro IN es menor que el de la constante "K1", el resultado de la instrucción
se pone al valor del límite inferior (LO_LIM) y se emite un error.
Si el límite inferior indicado es mayor que el límite superior (LO_LIM > HI_LIM), el resultado se
escala de forma inversamente proporcional al valor de entrada.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Escalar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

INT

I, Q, M, D, L, P o
constante

Valor de entrada que se es‐
cala

HI_LIM

Input

REAL

I, Q, M, D, L, P o
constante

Valor límite superior

LO_LIM

Input

REAL

I, Q, M, D, L, P o
constante

Valor límite inferior

BIPOLAR

Input

BOOL

I, Q, M, D, L o
constante

Indica si el valor del paráme‐
tro IN se interpreta como bi‐
polar o unipolar. El paráme‐
tro puede adoptar los valores
siguientes:
1: Bipolar
0: Unipolar

RET_VAL

Output

WORD

I, Q, M, D, L, P

Información de error

OUT

Output

REAL

I, Q, M, D, L, P

Resultado de la instrucción

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

0008

El valor del parámetro IN es mayor que el de la constante "K2" o menor que el de la
constante "K1".

Programación del PLC
Manual de programación y manejo, 11/2019

1521

Instrucciones
4.1 Instrucciones
Código de
error*
(W#16#...)

Explicación

Informa‐
Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
ción de
error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL SCALE

// Se llama la instrucción.

IN := "Tag_InputValue"

// Indica el valor que se convierte y escala.

HI_LIM := "Tag_HighLimit"

// Valor límite superior

LO_LIM := "Tag_LowLimit"

// Valor límite inferior

BIPOLAR := "Tag_Bipolar"

// Indica si el valor del parámetro IN se interpreta
como bipolar o unipolar.

RET_VAL := "Tag_ErrorCode"

// Información de error

OUT := "Tag_OutputValue"

// Resultado de la instrucción

La tabla siguiente muestra los valores de los distintos operandos antes de ejecutar la
instrucción:
Parámetro

Operando

Valor

IN

Tag_InputValue

22

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

RET_VAL

Tag_ErrorCode

W#16#0000

OUT

Tag_OutputValue

0.0

La tabla siguiente muestra los valores de los distintos operandos después de ejecutar la
instrucción:

1522

Parámetro

Operando

Valor

IN

Tag_InputValue

22

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

RET_VAL

Tag_ErrorCode

W#16#0000

OUT

Tag_OutputValue

50.03978588

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1537)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Bases de AWL (Página 8065)

UNSCALE: Desescalar
Descripción
La instrucción "Desescalar" desescala el número en coma flotante del parámetro IN en
unidades físicas entre un valor límite inferior y un valor límite superior y lo convierte en un
número entero. Los límites inferior y superior del rango de valores en el que se desescala el
valor de entrada se definen mediante los parámetros LO_LIM y HI_LIM. El resultado de la
instrucción se devuelve en el parámetro OUT.
La instrucción "Desescalar" utiliza la siguiente ecuación:
OUT = [((IN–LO_LIM)/(HI_LIM–LO_LIM)) ∗ (K2–K1) ] + K1
El estado lógico del parámetro BIPOLAR determina los valores de las constantes "K1" y "K2".
El parámetro BIPOLAR puede tener los siguientes estados lógicos:
● Estado lógico "1": se presupone que el valor del parámetro IN es bipolar y está comprendido
en un rango de valores entre -27648 y 27648. En este caso, la constante "K1" tiene el valor
-27648,0, y la constante "K2", el valor +27648,0.
● Estado lógico "0": se presupone que el valor del parámetro IN es unipolar y está
comprendido en un rango de valores entre 0 y 27648. En este caso, la constante "K1" tiene
el valor 0,0, y la constante "K2", el valor +27648,0.
Si el valor del parámetro IN no se encuentra dentro de los límites definidos por HI_LIM y
LO_LIM, se emite un error. El resultado se ajusta al límite más próximo.
Si el límite inferior indicado es mayor que el límite superior (LO_LIM > HI_LIM), el resultado se
escala de forma inversamente proporcional al valor de entrada.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Desescalar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

REAL

I, Q, M, D, L, P o
constante

Valor de entrada que se de‐
sescala en un valor entero

HI_LIM

Input

REAL

I, Q, M, D, L, P o
constante

Valor límite superior

LO_LIM

Input

REAL

I, Q, M, D, L, P o
constante

Valor límite inferior

Programación del PLC
Manual de programación y manejo, 11/2019

1523

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

BIPOLAR

Input

BOOL

I, Q, M, D, L o
constante

Indica si el valor del paráme‐
tro IN se interpreta como bi‐
polar o unipolar. El paráme‐
tro puede adoptar los valores
siguientes:
1: Bipolar
0: Unipolar

RET_VAL

Output

WORD

I, Q, M, D, L, P

Información de error

OUT

Output

INT

I, Q, M, D, L, P

Resultado de la instrucción

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de Explicación
error
(W#16#....)
0000

Ningún error

0008

El valor del parámetro IN es mayor que el del límite superior (HI_LIM) o menor que el del
límite inferior (LO_LIM).

Informa‐
Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
ción de
error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización aquí: Cambiar
formatos de visualización en el estado del programa (Página 8529)

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL UNSCALE

// Se llama la instrucción.

IN := "Tag_InputValue"

// Indica el valor que se desescala.

HI_LIM := "Tag_HighLimit"

// Valor límite superior

LO_LIM := "Tag_LowLimit"

// Valor límite inferior

BIPOLAR := "Tag_Bipolar"

// Indica si el valor del parámetro IN se interpreta
como bipolar o unipolar.

RET_VAL := "Tag_ErrorCode"

// Información de error

OUT := "Tag_OutputValue"

// Resultado de la instrucción

La tabla siguiente muestra los valores de los distintos operandos antes de ejecutar la
instrucción:

1524

Parámetro

Operando

Valor

IN

Tag_InputValue

50.03978588

HI_LIM

Tag_HighLimit

100.0

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Operando

Valor

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

RET_VAL

Tag_ErrorCode

W#16#0000

OUT

Tag_OutputValue

0.0

La tabla siguiente muestra los valores de los distintos operandos después de ejecutar la
instrucción:
Parámetro

Operando

Valor

IN

Tag_InputValue

50.03978588

HI_LIM

Tag_HighLimit

100.0

LO_LIM

Tag_LowLimit

0.0

BIPOLAR

Tag_Bipolar

1

RET_VAL

Tag_ErrorCode

W#16#0000

OUT

Tag_OutputValue

22

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
GET_ERR_ID: Consultar ID de error localmente (Página 1537)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Bases de AWL (Página 8065)

Control del programa
Control del tiempo de ejecución
ENDIS_PW: Limitar y habilitar legitimación de la contraseña
Descripción
La instrucción "Limitar y habilitar legitimación de la contraseña" permite definir si las
contraseñas configuradas para la CPU están legitimadas o no. Con ello, se pueden impedir
conexiones legitimadas, aun conociendo la contraseña correcta.
Si se llama la instrucción y el parámetro REQ tiene el estado lógico "0", en los parámetros de
salida se muestra el estado ajustado en ese momento. Si se han realizado cambios en los
parámetros de entrada, estos no se transfieren a los parámetros de salida.

Programación del PLC
Manual de programación y manejo, 11/2019

1525

Instrucciones
4.1 Instrucciones
Si se ejecuta la instrucción y el parámetro REQ tiene el estado lógico "1", se aplica el estado
lógico de los parámetros de entrada (F_PWD, FULL_PWD, R_PWD, HMI_PWD):
● Con el estado lógico "0", no está permitida la legitimación por contraseña.
● Con el estado lógico "1" se puede utilizar la contraseña.
Es posible permitir o prohibir individualmente el bloqueo o la habilitación de las contraseñas.
Por ejemplo, pueden prohibirse todas las contraseñas excepto la contraseña de seguridad
positiva. Esto permite limitar las posibilidades de acceso a un reducido grupo de usuarios. Los
parámetros de salida (F_PWD_ON, FULL_PWD_ON, R_PWD_ON, HMI_PWD_ON) siempre
muestran el estado actual del uso de contraseñas, independientemente del parámetro REQ.
Las contraseñas no configuradas deben tener el estado lógico TRUE en la entrada y devolver
el estado lógico TRUE en la salida. La contraseña de seguridad solo puede parametrizarse
para una CPU F y por eso en una CPU estándar debe interconectarse siempre con el estado
lógico TRUE. Si la instrucción devuelve un error, la llamada permanece sin efecto, es decir, el
bloqueo anterior sigue en vigor.
Las contraseñas bloqueadas pueden volver a habilitarse en las condiciones siguientes:
● Se ha restablecido la configuración de fábrica de la CPU.
● El panel frontal de la CPU S7-1500 soporta un cuadro de diálogo que permite navegar al
menú adecuado y volver a habilitar las contraseñas.
● Cuando se llama la instrucción "Limitar y habilitar legitimación de la contraseña", el
parámetro de entrada de la contraseña deseada tiene el estado lógico "1".
● Ponga el selector de modo a STOP. La restricción de la legitimación de contraseña se
activa de nuevo en cuanto se mueve el selector nuevamente a RUN.
● La inserción de una tarjeta de memoria vacía (tarjeta de transferencia o tarjeta de
programa) en una CPU S7-1200.
● La transición de POWER OFF-POWER ON desactiva la protección en la CPU S7-1200. La
instrucción "Limitar y habilitar legitimación de la contraseña" debe volverse a llamar en el
programa (por ejemplo en el OB de arranque).
Nota
Si la contraseña HMI no está habilitada, la instrucción "Limitar y habilitar legitimación de la
contraseña" bloquea el acceso de los sistemas HMI.
Nota
Las conexiones ya existentes y legitimadas conservan sus derechos de acceso y no pueden
limitarse con la instrucción "Limitar y habilitar legitimación de la contraseña".

Impedir el bloqueo no intencionado en una CPU S7-1500
Los ajustes pueden realizarse en el panel frontal de la CPU, que guarda el último ajuste en
cada caso.
Para impedir un bloqueo no intencionado, en una CPU S7-1500 es posible desactivar la
protección moviendo el selector de modo a STOP. La protección se activa automáticamente
después de mover el selector de modo a RUN sin que tenga que volver a llamarse la

1526

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
instrucción "Limitar y habilitar legitimación de la contraseña" o deban realizarse otras acciones
en el panel frontal.

Impedir el bloqueo no intencionado en una CPU S7-1200
Como la CPU S7-1200 no dispone de selector de modo, la protección se desactiva con
POWER OFF-POWER ON. De este modo es posible y recomendable impedir el bloqueo no
intencionado con ayuda de determinadas secuencias en el programa.
Para ello, programe un control de tiempo, ya sea mediante un OB de alarma cíclica o un
temporizador en el Main OB (OB 1). De este modo, tras una transición de POWER OFFPOWER ON y la consiguiente desactivación de la protección, se puede volver a llamar
rápidamente la instrucción "Limitar y habilitar legitimación de la contraseña" en el OB
correspondiente (por ejemplo OB 1 u OB 35). Para que la ventana temporal en la que la
instrucción no está activa y en la que por tanto no existen limitaciones en la legitimación de la
contraseña sea lo más pequeña posible, llame la instrucción en el OB de arranque (OB 100).
Este procedimiento ofrece la mayor protección posible contra accesos no autorizados.
Si se ha producido un bloqueo no intencionado, puede omitirse la llamada en el OB de
arranque (por ejemplo mediante consulta de un parámetro de entrada) y se dispondrá del
tiempo configurado (por ejemplo de 10 segundos a 1 minuto) para establecer una conexión con
la CPU antes de que el bloqueo vuelva a activarse.
Si no se ha previsto ningún temporizador en el código del programa y se produce un bloqueo,
inserte en la CPU una tarjeta de transferencia o una tarjeta de programa vacía. La tarjeta de
transferencia o la tarjeta de programa vacía borra la memoria de carga interna de la CPU.
Después deberá cargarse nuevamente el programa de usuario de STEP 7 en la CPU.

Procedimiento en caso de pérdida de contraseña en una CPU S7-1200
Si ha perdido la contraseña de una CPU S7-1200 protegida por contraseña, borre el programa
protegido por contraseña con una tarjeta de transferencia o una tarjeta de programa vacía. La
tarjeta de transferencia o la tarjeta de programa vacía borra la memoria de carga interna de la
CPU. A continuación, puede transferir un nuevo programa de usuario de STEP 7 Basic a la
CPU.
ADVERTENCIA
Inserción de una tarjeta de transferencia vacía
Cuando se inserta una tarjeta de transferencia en una CPU en funcionamiento, la CPU pasa
a STOP. En caso de estados operativos no seguros, los controladores pueden fallar y, con
ello, provocar un funcionamiento descontrolado de los dispositivos que se controlan. El
resultado es un funcionamiento impredecible del sistema de automatización, que puede
provocar lesiones mortales o graves, así como daños materiales.
El contenido de la tarjeta de transferencia se encuentra en la memoria de carga interna
después de su extracción. Compruebe aquí que la tarjeta no contenga ningún programa.

Programación del PLC
Manual de programación y manejo, 11/2019

1527

Instrucciones
4.1 Instrucciones
ADVERTENCIA
Inserción de una tarjeta de programa vacía
Cuando se inserta una tarjeta de programa en una CPU en funcionamiento, la CPU pasa a
STOP. En caso de estados operativos no seguros, los controladores pueden fallar y, con ello,
provocar un funcionamiento descontrolado de los dispositivos que se controlan. El resultado
es un funcionamiento impredecible del sistema de automatización, que puede provocar
lesiones mortales o graves, así como daños materiales.
Asegúrese de que la tarjeta de programa esté vacía. La memoria de carga interna se copiará
en la tarjeta de programa vacía. Después de retirar la tarjeta de programa previamente vacía,
la memoria de carga interna quedará vacía.
Debe retirarse la tarjeta de transferencia o la tarjeta de programa antes de poner la CPU en
RUN.

Efectos del uso de contraseñas en los modos de operación
La siguiente tabla muestra qué efectos tiene el uso de contraseñas en los modos de operación
y en las respectivas acciones del usuario mediante la instrucción "Limitar y habilitar
legitimación de la contraseña".
Acción

Protección por contraseña mediante la instruc‐
ción

Estado básico después de

No activado

● Selector de modo en STOP

(sin limitaciones)

● Restablecimiento manual de la memoria (PG,
interruptor, cambio de MC (Motion Control))
● Restablecimiento de la configuración de fábrica
Estado básico tras conexión (POWER ON)

● CPU S7-1200:
El bloqueo está desactivado y la
instrucción tiene que volverse a ejecutar
en el programa (por ejemplo en el OB de
arranque).
● CPU S7-1500:
Activada (si antes de la desconexión
(POWER OFF) había un bloqueo activo)
La posibilidad de no permitir contraseñas
es remanente.

Activado
Transición del estado operativo RUN/ARRANQUE/
PARADA -> STOP (mediante finalización de la ins‐
Las contraseñas siguen sin poder utilizarse.
trucción, un error o comunicación) o STOP -> ARRAN‐
QUE/RUN/PARADA

1528

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Limitar y habilitar legitimación de
la contraseña":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o
constante

Si el parámetro REQ tiene el
estado lógico "0", se consulta
el estado lógico ajustado ac‐
tualmente para las contrase‐
ñas.

F_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura/escritura
incluido failsafe
● F_PWD = "0": No permitir
contraseña
● F_PWD = "1": Permitir
contraseña

FULL_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura/escritura
● FULL_PWD = "0": No
permitir contraseña
● FULL_PWD = "1":
Permitir contraseña

R_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso de lectura
● R_PWD = "0": No permitir
contraseña
● R_PWD = "1": Permitir
contraseña

HMI_PWD

Input

BOOL

I, Q, M, D, L o
constante

Acceso a la HMI
● HMI_PWD = "0": No
permitir contraseña
● HMI_PWD = "1": Permitir
contraseña

F_PWD_ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura/
escritura incluido failsafe
● F_PWD_ON = "0":
Contraseña no permitida
● F_PWD_ON = "1":
Contraseña permitida

FULL_PWD_
ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura/
escritura
● FULL_PWD_ON = "0":
Contraseña no permitida
● FULL_PWD_ON = "1":
Contraseña permitida

Programación del PLC
Manual de programación y manejo, 11/2019

1529

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

R_PWD_ON

Output

BOOL

I, Q, M, D, L

Estado del acceso de lectura
● R_PWD_ON = "0":
Contraseña no permitida
● R_PWD_ON = "1":
Contraseña permitida

HMI_PWD_O Output
N

BOOL

I, Q, M, D, L

Estado del acceso a la HMI
● HMI_PWD_ON = "0":
Contraseña no permitida
● HMI_PWD_ON = "1":
Contraseña permitida

RET_VAL

Output

WORD

I, Q, M, D, L

Información de error

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*

Explicación

(W#16#...)
0000

Ningún error

8090

No se soporta la instrucción "Limitar y habilitar legitimación de la contraseña".

80D0

La contraseña de seguridad no está configurada. En las CPU estándar, el estado lógico
tiene que ser TRUE.

80D1

El acceso de lectura/escritura no está configurado

80D2

El acceso de lectura no está configurado

80D3

El acceso HMI no está configurado

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Bases de AWL (Página 8065)
Declarar constantes globales (Página 7908)

1530

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Sistemas de PC
SHUT_DOWN: Apagar sistema de destino
Descripción
Con la instrucción "SHUT_DOWN: Apagar sistema de destino" se apaga el sistema de
automatización basado en PC y se rearranca el controlador por software S7 CPU 150xS o
Windows en el sistema de automatización basado en PC.
Encontrará la instrucción en la Task Card "Instrucciones", sección Instrucciones básicas >
Control del programa > Control del tiempo de ejecución.
Un reinicio puede ser útil en las situaciones siguientes, p. ej.:
● Un SAI industrial (sistema de alimentación ininterrumpida) notifica un fallo de tensión
mediante una entrada digital.
● Windows no responde o presenta una "pantalla azul".
● En el programa de usuario se llaman demasiados OB de error.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Apagar sistema de destino":
Parámetro

Declaración

Tipo de
datos

Área de memoria

Descripción

MODE

Input

UINT

I, Q, M, D, L o constan‐ MODE = 1: apagar CPU 150xS y Windows
te
La CPU pasa a STOP y guarda los datos remanentes. Se‐
guidamente se apagan la CPU y Windows. El sistema debe
rearrancarse manualmente.
MODE = 2: rearrancar CPU 150xS
La CPU pasa a STOP y guarda los datos remanentes. A
continuación la CPU se apaga y se reinicia.
MODE = 3: Reiniciar Windows. La CPU permanece en RUN.
Windows se reinicia (desde TIA Portal V14, el MODE 3 solo
está autorizado en caso de compatibilidad descendente. Se
recomienda usar MODE 4 o MODE 5).
MODE = 4: Windows se apaga correctamente y se reinicia.
La CPU permanece en RUN.
MODE = 5: Reiniciar Windows. (comparable al MODE 3;
excepción: MODE 5 solo debe usarse si se ha caído Win‐
dows).

COM‐
MENT

Input

STRING

I, Q, M, D, L

Con Mode = 1, 3 y 4 es posible indicar el motivo del reinicio.
El motivo se mostrará en el registro de eventos de Windows.

Ret_Val

Return

WORD

Q, M, D, L

Ret_Val = 0: ningún error
Ret_Val = 8090: el valor transferido a MODE no se soporta.
Ret_Val = 8091: Windows no responde a la llamada de la
instrucción Shut_Down (solo válido para Mode 3 y 4).
Ret_Val = 8092: Si aparece este error diríjase al SIMATIC
Customer Support (solo válido para Mode 3 y 4).

Programación del PLC
Manual de programación y manejo, 11/2019

1531

Instrucciones
4.1 Instrucciones

RE_TRIGR: Reiniciar tiempo de vigilancia del ciclo
Descripción
La instrucción "Reiniciar tiempo de vigilancia del ciclo" reinicia el tiempo de vigilancia del ciclo
de la CPU. El tiempo de vigilancia del ciclo se reinicia entonces con la duración ajustada en la
configuración de la CPU.
La instrucción se ejecuta correctamente durante un intervalo de tiempo (10 veces el ciclo
máximo del programa), independientemente del número de llamadas. Transcurrido ese
tiempo, el ciclo del programa ya no puede prolongarse.

Llamada de la instrucción
La instrucción puede llamarse en todos los bloques de organización, independientemente de
la prioridad.

Parámetros
La instrucción "Reiniciar tiempo de vigilancia del ciclo" no tiene parámetros y no devuelve
información de error.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

STP: Finalizar programa
Descripción
La instrucción "Finalizar programa" conmuta la CPU al estado operativo STOP, con lo que se
finaliza la ejecución del programa. Los efectos al conmutar de RUN a STOP dependen de la
configuración de la CPU.

Parámetros
La instrucción "Finalizar programa" no tiene parámetros y no devuelve información de error.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

1532

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

GET_ERROR: Consultar error localmente
Descripción
La instrucción "Consultar error localmente" consulta si se han producido errores en un bloque
de programa. Suele tratarse de un error de programación o de acceso. Si el sistema notifica
errores durante la ejecución del bloque de programa, en el operando de la salida OUT se
guarda información detallada acerca del primer error de ejecución ocurrido desde la última vez
que se ejecutó la instrucción.
En la salida OUT solo pueden indicarse operandos del tipo de datos de sistema "ErrorStruct".
El tipo de datos de sistema "ErrorStruct" especifica la estructura exacta con la que debe
guardarse la información acerca del error que ha ocurrido. Con ayuda de otras instrucciones
se puede evaluar esta estructura y programar la reacción correspondiente. Si se producen
varios errores en el bloque de programa, la instrucción devolverá información sobre el
siguiente error ocurrido solo tras haberse solucionado el primer error.
Nota
Salida OUT
La salida OUT solo se modifica si hay una información de error. Para volver a poner la salida
a "0" tras tratar un error existen las siguientes posibilidades:
● Declare la variable en la sección "Temp" de la interfaz de bloque.
● Ponga la variable de nuevo a "0" antes de llamar la instrucción.
Nota
Activación del tratamiento local de errores
En cuanto se inserta la instrucción en el código de un bloque de programa, se activa el
tratamiento local de errores y se ignoran las reacciones preajustadas del sistema cuando se
producen errores.

Posibilidades del tratamiento de errores
Este apartado ofrece una visión general de las posibilidades del tratamiento de
errores: Sinopsis de los mecanismos para el tratamiento de errores (Página 149)
Encontrará un ejemplo detallado del tratamiento local de errores que ofrece varias opciones de
tratamiento aquí: Ejemplo de tratamiento de errores de ejecución del programa (Página 180)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar error localmente":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

OUT

Output

ErrorStruct

D, L

Información de error

Programación del PLC
Manual de programación y manejo, 11/2019

1533

Instrucciones
4.1 Instrucciones

Tipo de datos "ErrorStruct"
El tipo de datos "ErrorStruct" se puede insertar en un bloque de datos global o en la interfaz del
bloque. También se puede insertar el tipo de datos varias veces siempre que se asigne cada
vez un nombre distinto para la estructura de datos. La estructura de datos y el nombre de los
distintos elementos de la estructura no se pueden modificar. Si guarda la información del error
en un bloque de datos global, se podrá leer desde otro bloque de programa.
La tabla siguiente muestra la estructura del tipo de datos "ErrorStruct":
Componente de estructura

Tipo de datos

Descripción

ERROR_ID

WORD

ID de error

FLAGS

BYTE

Muestra si el error se ha producido durante
la llamada de un bloque de programa.
16#01: error durante la llamada de un blo‐
que de programa
16#00: no hay errores durante la llamada
de un bloque de programa

REACTION

BYTE

Reacción predeterminada:
0: ignorar (error de escritura)
1: continuar con el valor sustitutivo "0"
(error de lectura)
2: omitir instrucción (error de sistema)

CODE_ADDRESS
BLOCK_TYPE

CREF

Información sobre la dirección y el tipo del
bloque de programa

BYTE

Tipo de bloque de programa en el que se
ha producido el error:
1: bloque de organización (OB)
2: función (FC)
3: bloque de función (FB)

1534

CB_NUMBER

UINT

Número del bloque lógico

OFFSET

UDINT

Referencia a la memoria interna

MODE

BYTE

Información sobre la dirección de un ope‐
rando

OPERAND_NUMBER

UINT

Número de operando del comando de la
máquina

POINTER_NUMBER_LOCA‐
TION

UINT

(A) Puntero interno

SLOT_NUMBER_SCOPE

UINT

(B) Área de almacenamiento en la memo‐
ria interna

DATA_ADDRESS

NREF

Información sobre la dirección de un ope‐
rando

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Componente de estructura
AREA

Tipo de datos

Descripción

BYTE

(C) Área de memoria:
L: 16#40...16#7F, 16#86, 16#87, 16#8E,
16#8F, 16#C0...16#FF
I: 16#81
Q: 16#82
M: 16#83
DB: 16#40, 16#84, 16#85, 16#8A, 16#8B
PI: 16#01
PQ: 16#02
Objetos tecnológicos: 16#04

DB_NUMBER

UINT

(D) Número del bloque de datos

OFFSET

UDINT

(E) Dirección relativa del operando

Componente de estructura "ERROR_ID"
La tabla siguiente muestra los valores que pueden devolverse en el componente de estructura
"ERROR_ID":
ID*
(hexadecimal)

ID*
(decimal)

Descripción

0

0

Ningún error

2503

9475

Puntero no válido

2520

9504

STRING no válido

2522

9506

Error de lectura: operando fuera del rango válido

2523

9507

Error de escritura: operando fuera del rango válido

2524

9508

Error de lectura: operando no válido

2525

9509

Error de escritura: operando no válido

2528

9512

Error de lectura: alineación de datos

2529

9513

Error de escritura: alineación de datos

252C

9516

Puntero no válido

2530

9520

Error de escritura: Bloque de datos

2533

9523

Referencia usada no válida

2538

9528

Error de acceso: el DB no existe

2539

9529

Error de acceso: se ha utilizado un DB incorrecto

253A

9530

El bloque de datos global no existe

253C

9532

Indicación errónea o la función no existe

253D

9533

La función de sistema no existe

253E

9534

Indicación errónea o el bloque de función no existe

253F

9535

El bloque de sistema no existe

2550

9552

Error de acceso: el DB no existe

2551

9553

Error de acceso: se ha utilizado un DB incorrecto

2575

9589

Error en la profundidad de anidamiento del programa

2576

9590

Error en la distribución de datos locales

Programación del PLC
Manual de programación y manejo, 11/2019

1535

Instrucciones
4.1 Instrucciones
ID*
(hexadecimal)

ID*
(decimal)

Descripción

2577

9591

La propiedad de bloque "Alimentación de parámetros a través de
registros" no está activada.

25A0

9632

Error interno en TP

25A1

9633

Variable protegida contra escritura

25A2

9634

Valor numérico no válido de la variable

2942

10562

Error de lectura: entrada

2943

10563

Error de escritura: salida

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

LABEL: L #Field[#index]

// Acceso a la variable #Field[#index]

L 40.5

// Cargar valor 40.5

*R

// Multiplicar el valor de la variable por el valor 40.5.

T #TagOut

// Transferir el producto al operando #TagOut.

CALL GET_ERROR

// Se llama la instrucción.

OUT := #Error

// En caso de error se guarda información detallada en
el operando #Error.

T #Error.REACTION

// Se lee el componente de estructura #Error.REACTION.

L 1

// Cargar valor 1

==I

// El valor del componente de estructura se compara con
el valor 1.

JC LABEL

// Si la comparación de ambos valores es positiva, la
ejecución del programa retrocede a la etiqueta de salto
LABEL.

Se ha producido un error al acceder a la variable #Field[#index]. A pesar del error de lectura y
acceso, el operando #TagOut devuelve el estado lógico "1" y la multiplicación se realiza con el
valor "0.0". Si se produce este error se recomienda programar la instrucción "Consultar error
localmente" tras la multiplicación para capturar el error. La información de error suministrada
por la instrucción "Consultar error localmente" se evalúa con una comparación. Si el
componente de estructura #Error.REACTION tiene el valor "1", se trata de un error de lectura/
acceso y la ejecución del programa comienza de nuevo en la etiqueta de salto LABEL.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)

1536

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Uso de las instrucciones GET_ERROR y GET_ERR_ID (Página 178)
Bases de AWL (Página 8065)

GET_ERR_ID: Consultar ID de error localmente
Descripción
La instrucción "Consultar ID de error localmente" consulta si se han producido errores en un
bloque. Suele tratarse de un error de acceso. Si al ejecutar el bloque el sistema notifica errores
de ejecución desde que se ejecutó la instrucción por última vez, la ID de error del primer error
ocurrido se guarda en la variable de la salida RET_VAL.
En la salida RET_VAL solo pueden especificarse operandos del tipo de datos "WORD". Si se
producen varios errores en el bloque, la instrucción soluciona el primer error ocurrido, y solo
entonces la instrucción emite la ID de error del siguiente error ocurrido.
Nota
La salida RET_VAL solo se modifica si hay una información de error. Para volver a poner la
salida a "0" tras tratar un error existen las siguientes posibilidades:
● Declare la variable en la sección "Temp" de la interfaz de bloque.
● Ponga la variable de nuevo a "0" antes de llamar la instrucción.
La salida de la instrucción "Consultar ID de error localmente" se activa únicamente si existe
una información de error. Si no se cumple esta condición, el procesamiento ulterior del
programa no se ve afectado por la instrucción "Consultar ID de error localmente".
Encontrará un ejemplo sobre cómo utilizar la instrucción en combinación con otras
posibilidades de tratamiento de errores, en "Consulte también".
Nota
La instrucción "Consultar ID de error localmente" activa el tratamiento local de errores dentro
del bloque. Si en la lógica de un bloque se ha insertado la instrucción "Consultar ID de error
localmente", se ignoran las reacciones predeterminadas del sistema al ocurrir errores.

Posibilidades del tratamiento de errores
Este apartado ofrece una visión general de las posibilidades del tratamiento de
errores: Sinopsis de los mecanismos para el tratamiento de errores (Página 149)
Encontrará un ejemplo detallado del tratamiento local de errores que ofrece varias opciones de
tratamiento aquí: Ejemplo de tratamiento de errores de ejecución del programa (Página 180)

Programación del PLC
Manual de programación y manejo, 11/2019

1537

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar ID de error localmente":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RET_VAL

Output

WORD

I, Q, M, D, L

ID de error

Parámetro RET_VAL
La tabla siguiente muestra los valores que pueden depositarse en el parámetro RET_VAL:
RET_VAL*
(hexadecimal)

RET_VAL*
(decimal)

Descripción

0

0

Ningún error

2503

9475

Puntero no válido

2520

9504

STRING no válido

2522

9506

Error de lectura: operando fuera del rango válido

2523

9507

Error de escritura: operando fuera del rango válido

2524

9508

Error de lectura: operando no válido

2525

9509

Error de escritura: operando no válido

2528

9512

Error de lectura: alineación de datos

2529

9513

Error de escritura: alineación de datos

252C

9516

Puntero no válido

2530

9520

Error de escritura: Bloque de datos

2533

9523

Referencia usada no válida

2538

9528

Error de acceso: el DB no existe

2539

9529

Error de acceso: se ha utilizado un DB incorrecto

253A

9530

El bloque de datos global no existe

253C

9532

Indicación errónea o la función no existe

253D

9533

La función de sistema no existe

253E

9534

Indicación errónea o el bloque de función no existe

253F

9535

El bloque de sistema no existe

2550

9552

Error de acceso: el DB no existe

2551

9553

Error de acceso: se ha utilizado un DB incorrecto

2575

9589

Error en la profundidad de anidamiento del programa

2576

9590

Error en la distribución de datos locales

2577

9591

La propiedad de bloque "Alimentación de parámetros a través de
registros" no está activada.

25A0

9632

Error interno en TP

25A1

9633

Variable protegida contra escritura

25A2

9634

Valor numérico no válido de la variable

2942

10562

Error de lectura: entrada

2943

10563

Error de escritura: salida

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

1538

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L #Field[#index]

// Acceso a la variable #Field[#index]

L 40.5

// Cargar valor 40.5

*R

// Multiplicar el valor de la variable por el valor 40.5.

T #TagOut

// Transferir el producto al operando #TagOut.

CALL GET_ERR_ID

// Se llama la instrucción.

RET_VAL := #TagID

// En caso de error se guarda una ID de error en el operando #TagID.

T #TagID

// Se lee la ID de error en el operando #TagID.

L 16#2522

// Cargar valor 16#2522

==I

// El valor de la ID de error se compara con el valor
16#2522.

CALL MOVE

// Se llama la instrucción.

IN := 100.0

// El valor 100.0 se copia en el operando #TagOut.

OUT := #TagOut

// Salida de la instrucción

Se ha producido un error al acceder a la variable #Field[#index]. A pesar del error de lectura y
acceso, el operando #TagOut devuelve el estado lógico "1" y la multiplicación se realiza con el
valor "0.0". Si se produce este error se recomienda programar la instrucción "Consultar ID de
error localmente" tras la multiplicación para capturar el error. La ID de error suministrada por
la instrucción "Consultar ID de error localmente" se evalúa con una comparación. Si el
operando #TagID devuelve la ID 16#2522, se trata de un error de lectura/acceso y el valor
"100.0" se copia en la salida #TagOut.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Uso de las instrucciones GET_ERROR y GET_ERR_ID (Página 178)
Bases de AWL (Página 8065)

INIT_RD: Inicializar todos los datos remanentes
Descripción
La instrucción "Inicializar todos los datos remanentes" permite inicializar todos los datos
remanentes de todos los bloques de datos, marcas y temporizadores y contadores SIMATIC
al mismo tiempo. La instrucción solo puede ejecutarse dentro de un OB de arranque, puesto
que su ejecución excedería el tiempo de ciclo de programa.

Programación del PLC
Manual de programación y manejo, 11/2019

1539

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Inicializar todos los datos
remanentes":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

REQ

Input

BOOL

I, Q, M, D, L o
constante

Si la entrada REQ devuelve
el estado lógico "1", se inicia‐
lizan todos los datos rema‐
nentes.

RET_VAL

Output

INT

I, Q, M, D, L

Información de error:
El parámetro RET_VAL de‐
vuelve un código de error
cuando ocurre un error du‐
rante la ejecución de la ins‐
trucción.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Parámetro RET_VAL
La tabla siguiente muestra el significado de los valores del parámetro RET_VAL:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

80B5

No puede ejecutarse la instrucción porque no ha sido programada dentro de un OB de
arranque.

Informa‐
Consulte también: "GET_ERR_ID: Consultar ID de error localmente"
ción de
error gene‐
ral
*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL INIT_RD

// Se llama la instrucción.

REQ := "Tag_REQ"

// Si el operando "Tag_REQ" devuelve el estado lógico
"1", se inicializan todos los datos remanentes.

RET_VAL := "Tag_RET_VAL"

// Código de error

Si el operando "Tag_REQ" devuelve el estado lógico "1", se ejecuta la instrucción. Se
inicializan todos los datos remanentes de todos los bloques de datos, marcas y
temporizadores y contadores SIMATIC.

1540

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
GET_ERR_ID: Consultar ID de error localmente (Página 1537)
Evaluación de errores con el parámetro de salida RET_VAL (Página 174)
Bases de AWL (Página 8065)

WAIT: Programar retardo
Descripción
La instrucción "Programar retardo" detiene la ejecución del programa durante un periodo
parametrizado. El periodo se indica en microsegundos en el parámetro WT de la instrucción.
Es posible parametrizar tiempos de retardo de -32768 a 32767 microsegundos (μs). El tiempo
de retardo mínimo depende de la CPU utilizada y equivale al tiempo de ejecución de la
instrucción.
La ejecución de la instrucción puede verse interrumpida por eventos de prioridad superior y no
arrojará información de error.
Nota
Tiempo de retardo negativo
Si indica un tiempo de retardo negativo en el parámetro WT, la salida de habilitación ENO, o
el RLO y el bit BR arrojan el estado lógico FALSE. Un tiempo de retardo negativo no afecta a
la CPU. En KOP y FUP no se ejecutan las siguientes instrucciones vinculadas a la salida de
habilitación ENO.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Programar retardo":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

WT

Input

INT

I, Q, M, D, L, P o
constante

Tiempo de retardo en micro‐
segundos (μs)

Ejemplo de cómo influir en el tiempo de retardo previsto
En el ejemplo siguiente se ve la influencia del tiempo de retardo de la instrucción "WAIT" en
diferentes escenarios.
La figura siguiente ilustra los escenarios esquemáticamente:

Programación del PLC
Manual de programación y manejo, 11/2019

1541

Instrucciones
4.1 Instrucciones
6HQG&ORFN

&DVR 
2%

PV

:$,7  PV
7'HOD\ PV

7&RGH PV

7'HOD\ PV

7&RGH PV

7'HOD\ PV

7&RGH PV

75H PV

&DVR
2%GHDODUPD

75H PV

&DVR
2%GHDODUPD

7&RGH PV

&DVR
2%GHDODUPD
72Y PV
6HQG&ORFN 7LHPSRGHFLFORGHHPLVLµQGHOD&38
7'HOD\ 7LHPSRGHUHWDUGRGHO2%GHDODUPD
7&RGH 7LHPSRGHHMHFXFLµQGHOSURJUDPD
75H 7LHPSRUHVWDQWH
72Y 7LHPSRHQHOTXHVHSURORQJDHOWLHPSRGHFLFORGHHPLVLµQ
(O2%FRQODLQVWUXFFLµQ:$,7WDPEL«QIRUPDSDUWHGHORVFDVRV\\GHEH
WHQHUVHHQFXHQWD

Tiempo restante = intervalo entre el final del tiempo de retardo previsto (mediante "WAIT") y la
finalización del OB de alarma
Tiempo de prolongación = intervalo entre la finalización del OB de alarma y el final del tiempo
de retardo previsto (mediante "WAIT")
Caso 1:
La instrucción "WAIT" se llama en un OB1. La instrucción "WAIT" puede verse interrumpida por
OB o procesos de mayor prioridad (p. ej. System Threads). Sin embargo, el tiempo de retardo
de la instrucción "WAIT" no se ha modificado ni se ha aplazado.
Casos 2 y 3:
El procesamiento del programa en el OB1 prosigue tras un retardo de 20 ms. Este retardo se
calcula con la llamada de la instrucción "WAIT" en el OB1 (consulte OB1 con WAIT). En esos
20 ms, un OB de alarma puede ejecutar su propio código de programa. El tiempo de ciclo de
emisión de la CPU no cambia.

1542

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Caso 4:
El procesamiento del programa en el OB1 prosigue tras finalizar el proceso de mayor prioridad.
Los 20 ms de retardo en el OB1 han transcurrido, pero el proceso de mayor prioridad todavía
no ha finalizado. El tiempo de ciclo de emisión de la CPU aumenta.
Nota
Secuencia de ejecución de procesos del sistema o de comunicación (System Threads)
Los threads del sistema suelen utilizar la prioridad "15". También hay threads del sistema con
una prioridad mayor que "26", pero estos procesos suponen una carga menor para la CPU. Los
threads del sistema no se muestran en la figura.
Medición del tiempo de ejecución del OB1 utilizando la instrucción "RT_INFO":
Caso 2: 20 ms - 8 ms - System Threads = <12 ms. Tiempo de ciclo de emisión: ~20 ms.
Caso 3: 20 ms - 11 ms - System Threads - <9 ms. Tiempo de ciclo de emisión: ~20 ms.
Caso 4: 20 ms - 15 ms - System Threads - <7 ms. Tiempo de ciclo de emisión: ~22 ms.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

RUNTIME: Medir tiempo de ejecución
Descripción
La instrucción "Medir tiempo de ejecución" permite medir el tiempo de ejecución de todo el
programa, bloques individuales o secuencias de comandos.
Si desea medir el tiempo de ejecución de todo el programa, efectúe la llamada de la instrucción
"Medir tiempo de ejecución" en el OB1. El punto inicial para medir el tiempo de ejecución se
determina con la primera llamada y la salida RET_VAL devuelve el tiempo de ejecución del
programa tras la segunda llamada. El tiempo de ejecución medido incluye toda clase de
procesos de la CPU que se hayan producido durante la ejecución del programa, como, p. ej.,
interrupciones a causa de eventos o comunicaciones de mayor prioridad. La instrucción "Medir
tiempo de ejecución" lee un contador interno de la CPU y escribe su valor en el parámetro de
entrada/salida MEM. La instrucción calcula el tiempo de ejecución actual del programa según
la frecuencia interna del contador, y la escribe en la salida RET_VAL.
Si desea medir el tiempo de ejecución de bloques o secuencias de comandos individuales,
necesita tres segmentos diferentes. Efectúe la llamada de la instrucción "Medir tiempo de
ejecución" en un segmento individual dentro del programa. Al efectuar esta primera llamada de
la instrucción se establece el punto inicial para medir el tiempo de ejecución. A continuación,
llame el bloque de programa o la secuencia de comando que desee en el siguiente segmento.
Efectúe la llamada de la instrucción "Medir tiempo de ejecución" por segunda vez en otro
segmento diferente y asigne al parámetro de entrada/salida MEM la misma memoria que en la
primera llamada de la instrucción. En el tercer segmento, la instrucción "Medir tiempo de
Programación del PLC
Manual de programación y manejo, 11/2019

1543

Instrucciones
4.1 Instrucciones
ejecución" lee un contador interno de la CPU, calcula el tiempo de ejecución actual del bloque
de programa o secuencia de comando según la frecuencia interna del contador y lo escribe en
la salida RET_VAL.
Nota
Puesto que el orden de las instrucciones de una secuencia de comandos se modifica mediante
la compilación optimizada del programa, no es posible determinar el tiempo de ejecución de
una secuencia de comandos con exactitud.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Medir tiempo de ejecución":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RET_VAL

Output

LREAL

I, Q, M, D, L

Devuelve el tiempo de ejecu‐
ción medido en segundos

MEM

InOut

LREAL

I, Q, M, D, L

El contenido está previsto
únicamente para fines inter‐
nos.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción mediante el cálculo del tiempo
de ejecución de un bloque de programa:
AWL

Explicación

CALL RUNTIME

// Se llama la instrucción.

RET_VAL := "TagResult"

// Resultado intermedio

MEM := "TagMemory"

// Guarda el punto inicial de la medición del tiempo
de ejecución.

CALL "Best_before_date",
"Best_before_date_DB"

// El bloque "Best_before_date" se llama y se procesa.

CALL RUNTIME

// La instrucción se llama por segunda vez.

RET_VAL := "TagResult"

// Resultado de la instrucción

MEM := "TagMemory"

// Toma el punto inicial de la medición del tiempo de
ejecución como base para calcular el tiempo de ejecución.

Con la primera llamada de la instrucción se determina el punto inicial para la medición del
tiempo de ejecución, y se guarda como referencia en una memora intermedia del operando
"TagMemory" para la segunda llamada de la instrucción.
A continuación se llama el bloque de programa FB1 "Best_before_date".

1544

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Una vez se ha procesado el bloque de programa FB1, la instrucción se ejecuta por segunda
vez. La segunda llamada de la instrucción calcula el tiempo de ejecución del bloque de
programa y escribe el resultado en el operando "TagResult" de la salida RET_VAL.
Encontrará un ejemplo detallado de cómo medir el tiempo de ciclo total de un programa en el
Siemens Industry Online Support, en la ID de artículo: 87668055 (https://
support.industry.siemens.com/cs/ww/es/view/87668055)

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

Operaciones lógicas con palabras
DECO: Descodificar
Descripción
La instrucción "Descodificar" activa un bit predeterminado por el valor de entrada en el valor de
salida.
La instrucción "Descodificar" lee el valor del parámetro IN y activa el bit del parámetro OUT
cuya posición de bit equivale al valor leído. Los demás bits del valor de salida se rellenan con
ceros. Si el valor del parámetro IN es mayor que 31, se ejecuta una operación modulo 32.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Descodificar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

UINT

I, Q, M, D, L, P o
constante

Posición del bit que se activa
en el valor de salida

OUT

Output

Secuencias de bits I, Q, M, D, L, P

Valor de salida

En la lista desplegable "???" puede seleccionar el tipo de datos del parámetro OUT.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL DECO

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

IN := "Tag_Input"

Programación del PLC
Manual de programación y manejo, 11/2019

// Valor de entrada que predetermina el bit que debe
activarse en el valor de salida.

1545

Instrucciones
4.1 Instrucciones
AWL

Explicación

OUT := "Tag_Output"

// Resultado

La figura siguiente muestra el funcionamiento de la instrucción con valores concretos:
7DJB,QSXW




7DJB2XWSXW

 



 

La instrucción lee el número de bit "3" del valor del operando "Tag_Input" de la entrada y activa
el tercer bit del valor del operando "Tag_Output" de la salida.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

ENCO: Codificar
Descripción
La instrucción "Codificar" lee el número del bit menos significativo que está activado en el valor
de entrada y devolverlo en el parámetro OUT.
La instrucción "Codificar" selecciona el bit menos significativo del valor del parámetro IN y
escribe su número de bit en el operando del parámetro OUT. Si el parámetro IN devuelve el
valor DW#16#00000001 o DW#16#00000000, en el parámetro OUT se deposita el valor "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Codificar":
Parámetro

Declaración

Tipo de datos

Área de memoria

IN

Input

Secuencias de bits I, Q, M, D, L, P o
constante

Valor de entrada

OUT

Output

INT

Valor de salida

I, Q, M, D, L, P

Descripción

En la lista desplegable "???" puede seleccionar el tipo de datos del parámetro IN.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL ENCO

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

1546

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

IN := "Tag_Input"

// Valor de entrada cuyo bit activado menos significativo se lee.

OUT := "Tag_Output"

// Número del bit menos significativo que está activado en el valor de entrada

La figura siguiente muestra el funcionamiento de la instrucción con valores concretos:


 



ಯ7DJB,QSXWಯ  
ಯ7DJB2XWSXWಯ 

La instrucción selecciona el bit menos significativo que está activado en la variable "Tag_Input"
y escribe su bit "3" en la variable "Tag_Output".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

SEL: Seleccionar
Descripción
La instrucción "Seleccionar" permite elegir, en función de un interruptor (entrada G), una de las
entradas IN0 o IN1 y copiar su contenido en la salida OUT. Si la entrada G tiene el estado lógico
"0", se copia el valor de la entrada IN0. Si la entrada G tiene el estado lógico "1", se copia el
valor de la entrada IN1 en la salida OUT.
Para poder procesar la instrucción, las variables de todos los parámetros deben ser del mismo
tipo de datos.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Seleccionar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

G

Input

BOOL

I, Q, M, D, L o
constante

Interruptor

IN0

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, CHAR,
WCHAR, TOD,
LTOD, DATE, DT,
LDT

Programación del PLC
Manual de programación y manejo, 11/2019

Primer valor de entrada

1547

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

IN1

Input

I, Q, M, D, L, P o
Secuencias de
constante
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, CHAR,
WCHAR, TOD,
LTOD, DATE, DT,
LDT

Área de memoria

Descripción
Segundo valor de entrada

OUT

Output

I, Q, M, D, L, P
Secuencias de
bits, enteros, nú‐
meros en coma flo‐
tante, temporiza‐
dores, CHAR,
WCHAR, TOD,
LTOD, DATE, DT,
LDT

Resultado

En la lista desplegable "???" puede seleccionar el tipo de datos de los parámetros INn y OUT.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL SEL

// Se llama la instrucción.
// Seleccione el tipo de datos deseado de la lista
desplegable "???".

G := "Tag_Input_G"

// Estado lógico del interruptor

IN0 := "Tag_Input0"

// Primer valor de entrada

IN1 := "Tag_Input1"

// Segundo valor de entrada

OUT := "Tag_Output"

// Valor de la entrada seleccionada

La tabla siguiente muestra el funcionamiento de la instrucción con valores concretos:
Parámetro

Operando

Valor

G

Tag_Input_G

1

IN0

Tag_Input0

W#16#0000

IN1

Tag_Input1

W#16#FFFF

OUT

Tag_Output

W#16#FFFF

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

1548

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Legacy
DRUM: Materializar circuito secuencial sucesivo
Descripción
La instrucción "Materializar circuito secuencial sucesivo" ocupa los bits de salida programados
(OUT1 a OUT16) y la palabra de salida (OUT_WORD) con los valores programados del
parámetro OUT_VAL del paso respectivo. El paso en cuestión debe cumplir las condiciones de
la máscara de habilitación programada en el parámetro S_MASK mientras la instrucción
permanece en dicho paso. La instrucción pasa al paso siguiente cuando el evento de éste es
verdadero y una vez transcurrido el tiempo programado para el paso actual, o bien cuando el
valor del parámetro JOG cambia de "0" a "1". La instrucción se desactiva cuando el estado
lógico del parámetro RESET cambia a "1". Con ello, el paso actual se iguala al paso
predeterminado (DSP).
El tiempo de permanencia en un paso se calcula multiplicando la base de tiempo
predeterminada (DTBP) por el valor de contaje predeterminado (S_PRESET) para cada paso.
Al comienzo de un nuevo paso, este valor calculado se carga en el parámetro DCC, que
contiene el tiempo restante para el paso actual. Por ejemplo, si el valor del parámetro DTBP es
"2" y el valor predeterminado para el primer paso es "100" (100 ms), el parámetro DCC
devolverá el valor "200" (200 ms).
Un paso puede programarse con un valor de tiempo, con un evento o con ambos. Los pasos
programados con un bit de evento y el valor de tiempo "0" pasan al siguiente paso en cuanto
el estado lógico del bit de evento es "1". Los pasos programados solo con un valor de tiempo
empiezan a contar el tiempo inmediatamente. Los pasos programados con un bit de evento y
un valor de tiempo mayor que "0" empiezan a contar el tiempo en cuanto el estado lógico del
bit de evento es "1". Los bits de evento se inicializan con el estado lógico "1".
Si el circuito secuencial sucesivo se encuentra en el último paso programado (LST_STEP) y ha
transcurrido el tiempo para dicho paso, el estado lógico del parámetro Q se pone a "1". De lo
contrario, se pone a "0". Si está activado el parámetro Q, la instrucción permanece en el paso
hasta la desactivación.
En la máscara configurable (S_MASK) es posible seleccionar los distintos bits de la palabra de
salida (OUT_WORD) y activar o desactivar los bits de salida (OUT1 a OUT16) mediante los
valores de salida (OUT_VAL). Si un bit de la máscara configurable tiene el estado lógico "1",
el valor OUT_VAL activa o desactiva el bit correspondiente. Si el estado lógico de un bit de la
máscara configurable es "0", no cambia el bit respectivo. Todos los bits de la máscara
configurable de todos los 16 pasos se inicializan con el estado lógico "1".
El bit de salida del parámetro OUT1 equivale al bit menos significativo de la palabra de salida
(OUT_WORD). El bit de salida del parámetro OUT16 equivale al bit más significativo de la
palabra de salida (OUT_WORD).

Programación del PLC
Manual de programación y manejo, 11/2019

1549

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Materializar circuito secuencial
sucesivo":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

RESET

Input

BOOL

I, Q, M, D, L o
constante

El estado lógico "1" indica
una condición de desactiva‐
ción.

JOG

Input

BOOL

I, Q, M, D, L o
constante

Si el estado lógico cambia de
"0" a "1", la instrucción pasa
al siguiente paso.

DRUM_EN

Input

BOOL

I, Q, M, D, L o
constante

El estado lógico "1" permite
que el circuito secuencial su‐
cesivo siga contando según
el evento y los criterios de
tiempo.

LST_STEP

Input

BYTE

I, Q, M, D, L o
constante

Número máximo de etapas
(p. ej.: LST_STEP = 16#08;
son posibles 8 etapas como
máximo.)

EVENT(i),

Input

BOOL

I, Q, M, D, L o
constante

Bit de evento (i);

Output

BOOL

I, Q, M, D, L

Bit de salida (j)

Q

Output

BOOL

I, Q, M, D, L

El estado lógico "1" indica
que ha transcurrido el tiempo
del último paso.

OUT_WORD

Output

WORD

I, Q, M, D, L, P

Dirección de palabra en la
que el circuito secuencial su‐
cesivo escribe los valores de
salida.

ERR_CODE

Output

WORD

I, Q, M, D, L, P

Información de error

JOG_HIS

Static

BOOL

I, Q, M, D, L o
constante

Bit de evolución del paráme‐
tro JOG

EOD

Static

BOOL

I, Q, M, D, L o
constante

El estado lógico "1" indica
que ha transcurrido el tiempo
del último paso.

DSP

Static

BYTE

I, Q, M, D, L, P o
constante

Primer paso predeterminado
del circuito secuencial suce‐
sivo (1 a 16)

DSC

Static

BYTE

I, Q, M, D, L, P o
constante

Paso actual del circuito se‐
cuencial sucesivo

DCC

Static

DWORD

I, Q, M, D, L, P o
constante

Tiempo de ejecución restan‐
te para el paso actual

DTBP

Static

WORD

I, Q, M, D, L, P o
constante

Base de tiempo predetermi‐
nada del circuito secuencial
sucesivo

PrevTime

Static

TIME

I, Q, M, D, L o
constante

hora de sistema de la llama‐
da anterior

1 ≤ i ≤ 16
OUT(j),

El estado lógico inicial es "1".

1 ≤ j ≤ 16

1550

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

S_PRESET

Static

ARRAY[1..16] of
WORD

I, Q, M, D, L o
constante

Valor de contaje predetermi‐
nado para cada paso [1 a 16];
1 ciclo de reloj = 1 ms.

OUT_VAL

Static

ARRAY[1..16,
0..15] of BOOL

I, Q, M, D, L o
constante

Valores de salida para cada
etapa [1 a 16, 0 a 15].

S_MASK

Static

ARRAY[1..16,
0..15] of BOOL

I, Q, M, D, L o
constante

Máscara configurable para
cada etapa [1 a 16, 0 a 15].
Los estados lógicos iniciales
son "1".

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
ERR_CO‐
DE*

Explicación

W#16#000
0

Ningún error

W#16#000
B

El valor del parámetro LST_STEP es menor que 1 o mayor que 16.

W#16#000
C

El valor del parámetro DSC es menor que 1 o mayor que el valor del parámetro
LST_STEP.

W#16#000
D

El valor del parámetro DSP es menor que 1 o mayor que el valor de LST_STEP.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
En el ejemplo siguiente, la instrucción pasa del paso 1 al paso 2. Los bits de salida (OUT1 a
OUT16) y la palabra de salida (OUT_WORD) se activan según la máscara configurada para el
paso 2 y los valores del parámetro OUT_VAL.
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

AWL

Explicación

CALL DRUM, "DRUM_DB"

// Se llama la instrucción "Materializar circuito secuencial sucesivo" y se crea el bloque de datos de
instancia "DRUM_DB".

RESET := "Tag_Reset"

// Entrada de inicialización

JOG := "Tag_Input_Jog"

// Si se produce un flanco de señal ascendente, la
instrucción pasa al paso siguiente.

Programación del PLC
Manual de programación y manejo, 11/2019

1551

Instrucciones
4.1 Instrucciones
AWL

Explicación

DRUM_EN := "Tag_Input_DrumEN" // El estado lógico "1" permite que el circuito secuencial sucesivo siga contando según el evento y los
criterios de tiempo.
LST_STEP := "Tag_Number_LastStep"

// Número del último paso programado

EVENT1 := "MyTag_Event_1"

// Bit de evento 1

EVENT2 := "MyTag_Event_2"

// Bit de evento 2

EVENT3 := "MyTag_Event_3"

// Bit de evento 3

EVENT4 := "MyTag_Event_4"

// Bit de evento 4

EVENT5 := "MyTag_Event_5"

// Bit de evento 5

EVENT6 := "MyTag_Event_6"

// Bit de evento 6

EVENT7 := "MyTag_Event_7"

// Bit de evento 7

EVENT8 := "MyTag_Event_8"

// Bit de evento 8

EVENT9 := "MyTag_Event_9"

// Bit de evento 9

EVENT10 := "MyTag_Event_10"

// Bit de evento 10

EVENT11 := "MyTag_Event_11"

// Bit de evento 11

EVENT12 := "MyTag_Event_12"

// Bit de evento 12

EVENT13 := "MyTag_Event_13"

// Bit de evento 13

EVENT14 := "MyTag_Event_14"

// Bit de evento 14

EVENT15 := "MyTag_Event_15"

// Bit de evento 15

EVENT16 := "MyTag_Event_16"

// Bit de evento 16

OUT1 := "MyTag_Output_1"

// Bit de salida 1

OUT2 := "MyTag_Output_2"

// Bit de salida 2

OUT3 := "MyTag_Output_3"

// Bit de salida 3

OUT4 := "MyTag_Output_4"

// Bit de salida 4

OUT5 := "MyTag_Output_5"

// Bit de salida 5

OUT6 := "MyTag_Output_6"

// Bit de salida 6

OUT7 := "MyTag_Output_7"

// Bit de salida 7

OUT8 := "MyTag_Output_8"

// Bit de salida 8

OUT9 := "MyTag_Output_9"

// Bit de salida 9

OUT10 := "MyTag_Output_10"

// Bit de salida 10

OUT11 := "MyTag_Output_11"

// Bit de salida 11

OUT12 := "MyTag_Output_12"

// Bit de salida 12

OUT13 := "MyTag_Output_13"

// Bit de salida 13

OUT14 := "MyTag_Output_14"

// Bit de salida 14

OUT15 := "MyTag_Output_15"

// Bit de salida 15

OUT16 := "MyTag_Output_16"

// Bit de salida 16

Q := "Tag_Output_Q"

// El estado lógico "1" indica que ha transcurrido el
tiempo del último paso.

OUT_WORD := "Tag_OutputWord"

// Dirección de palabra en la que el circuito secuencial sucesivo escribe los valores de salida

ERR_CODE := "Tag_ErrorCode"

// Información de error

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

1552

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para asignar valores a los parámetros de
entrada:
Parámetro

Operando

Dirección

Valor

RESET

Tag_Reset

M0.0

FALSE

JOG

Tag_Input_JOG

M0.1

FALSE

DRUM_EN

Tag_Input_DrumEN

M0.2

TRUE

LST_STEP

Tag_Number_LastStep

MB1

B#16#08

EVENT2

MyTag_Event_2

M20.0

FALSE

EVENT4

MyTag_Event_4

M20.1

FALSE

EVENT6

MyTag_Event_6

M20.2

FALSE

EVENT8

MyTag_Event_8

M20.3

FALSE

EVENT10

MyTag_Event_10

M20.4

FALSE

EVENT12

MyTag_Event_12

M20.5

FALSE

EVENT14

MyTag_Event_14

M20.6

FALSE

EVENT16

MyTag_Event_16

M20.7

FALSE

En el bloque de datos de instancia "DRUM_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

JOG_HIS

DBX12.0

FALSE

EOD

DBX12.1

FALSE

DSP

DBB13

W#16#0001

DSC

DBB14

W#16#0001

DCC

DBD16

DW#16#0000000A

DTBP

DBW20

W#16#0001

S_PRESET[1]

DBW26

W#16#0064

S_PRESET[2]

DBW28

W#16#00C8

OUT_VAL[1,0]

DBX58.0

TRUE

OUT_VAL[1,1]

DBX58.1

TRUE

OUT_VAL[1,2]

DBX58.2

TRUE

OUT_VAL[1,3]

DBX58.3

TRUE

OUT_VAL[1,4]

DBX58.4

TRUE

OUT_VAL[1,5]

DBX58.5

TRUE

OUT_VAL[1,6]

DBX58.6

TRUE

OUT_VAL[1,7]

DBX58.7

TRUE

OUT_VAL[1,8]

DBX59.0

TRUE

OUT_VAL[1,9]

DBX59.1

TRUE

OUT_VAL[1,10]

DBX59.2

TRUE

OUT_VAL[1,11]

DBX59.3

TRUE

OUT_VAL[1,12]

DBX59.4

TRUE

OUT_VAL[1,13]

DBX59.5

TRUE

OUT_VAL[1,14]

DBX59.6

TRUE

Programación del PLC
Manual de programación y manejo, 11/2019

1553

Instrucciones
4.1 Instrucciones
Parámetro

Dirección

Valor

OUT_VAL[1,15]

DBX59.7

TRUE

OUT_VAL[2,0]

DBX60.0

FALSE

OUT_VAL[2,1]

DBX60.1

FALSE

OUT_VAL[2,2]

DBX60.2

FALSE

OUT_VAL[2,3]

DBX60.3

FALSE

OUT_VAL[2,4]

DBX60.4

FALSE

OUT_VAL[2,5]

DBX60.5

FALSE

OUT_VAL[2,6]

DBX60.6

FALSE

OUT_VAL[2,7]

DBX60.7

FALSE

OUT_VAL[2,8]

DBX61.0

FALSE

OUT_VAL[2,9]

DBX61.1

FALSE

OUT_VAL[2,10]

DBX61.2

FALSE

OUT_VAL[2,11]

DBX61.3

FALSE

OUT_VAL[2,12]

DBX61.4

FALSE

OUT_VAL[2,13]

DBX61.5

FALSE

OUT_VAL[2,14]

DBX61.6

FALSE

OUT_VAL[2,15]

DBX61.7

FALSE

S_MASK[2,0]

DBX92.0

FALSE

S_MASK[2,1]

DBX92.1

TRUE

S_MASK[2,2]

DBX92.2

TRUE

S_MASK[2,3]

DBX92.3

TRUE

S_MASK[2,4]

DBX92.4

TRUE

S_MASK[2,5]

DBX92.5

FALSE

S_MASK[2,6]

DBX92.6

TRUE

S_MASK[2,7]

DBX92.7

TRUE

S_MASK[2,8]

DBX93.0

FALSE

S_MASK[2,9]

DBX93.1

FALSE

S_MASK[2,10]

DBX93.2

TRUE

S_MASK[2,11]

DBX93.3

TRUE

S_MASK[2,12]

DBX93.4

TRUE

S_MASK[2,13]

DBX93.5

TRUE

S_MASK[2,14]

DBX93.6

FALSE

S_MASK[2,15]

DBX93.7

TRUE

Los parámetros de salida tienen los valores siguientes antes de ejecutarse la instrucción:

1554

Parámetro

Operando

Dirección

Valor

Q

Tag_Output_Q

M6.0

FALSE

OUTWORD

Tag_OutputWord

MW8

W#16#FFFF

OUT1

MyTag_Output_1

M4.0

TRUE

OUT2

MyTag_Output_2

M4.1

TRUE

OUT3

MyTag_Output_3

M4.2

TRUE

OUT4

MyTag_Output_4

M4.3

TRUE

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Operando

Dirección

Valor

OUT5

MyTag_Output_5

M4.4

TRUE

OUT6

MyTag_Output_6

M4.5

TRUE

OUT7

MyTag_Output_7

M4.6

TRUE

OUT8

MyTag_Output_8

M4.7

TRUE

OUT9

MyTag_Output_9

M5.0

TRUE

OUT10

MyTag_Output_10

M5.1

TRUE

OUT11

MyTag_Output_11

M5.2

TRUE

OUT12

MyTag_Output_12

M5.3

TRUE

OUT13

MyTag_Output_13

M5.4

TRUE

OUT14

MyTag_Output_14

M5.5

TRUE

OUT15

MyTag_Output_15

M5.6

TRUE

OUT16

MyTag_Output_16

M5.7

TRUE

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Dirección

Valor

OUT1

MyTag_Output_1

M4.0

TRUE

OUT2

MyTag_Output_2

M4.1

FALSE

OUT3

MyTag_Output_3

M4.2

FALSE

OUT4

MyTag_Output_4

M4.3

FALSE

OUT5

MyTag_Output_5

M4.4

FALSE

OUT6

MyTag_Output_6

M4.5

TRUE

OUT7

MyTag_Output_7

M4.6

FALSE

OUT8

MyTag_Output_8

M4.7

FALSE

OUT9

MyTag_Output_9

M5.0

TRUE

OUT10

MyTag_Output_10

M5.1

TRUE

OUT11

MyTag_Output_11

M5.2

FALSE

OUT12

MyTag_Output_12

M5.3

FALSE

OUT13

MyTag_Output_13

M5.4

FALSE

OUT14

MyTag_Output_14

M5.5

FALSE

OUT15

MyTag_Output_15

M5.6

TRUE

OUT16

MyTag_Output_16

M5.7

FALSE

Q

Tag_Output_Q

M6.0

FALSE

OUTWORD

Tag_OutputWord

MW8

W#16#4321

ERR_CODE

Tag_ErrorCode

MW10

W#16#0000

Programación del PLC
Manual de programación y manejo, 11/2019

1555

Instrucciones
4.1 Instrucciones
Los siguientes valores se modifican en el bloque de datos de instancia "DRUM_DB" de la
instrucción después de su ejecución:
Parámetro

Dirección

Valor

JOG_HIS

DBX12.0

FALSE

EOD

DBX12.1

FALSE

DSC

DBB14

W#16#0002

DCC

DBD16

DW#16#000000C8

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Bases de AWL (Página 8065)

DCAT: Alarma de tiempo para control discreto
Descripción
La instrucción "Alarma de tiempo para control discreto" acumula el tiempo desde el instante en
el que el parámetro CMD da la orden de abrir o cerrar. El tiempo se acumula hasta excederse
el tiempo predeterminado (PT) o hasta recibir la notificación de que el dispositivo se ha cerrado
o abierto dentro del tiempo prescrito (O_FB o C_FB). Si se excede el tiempo predeterminado
antes de recibirse la notificación de que se ha abierto o cerrado el dispositivo, se activa la
alarma correspondiente. Si el estado lógico de la entrada de la orden cambia antes del tiempo
predeterminado, se reinicia el tiempo.
La instrucción "Alarma de tiempo para control discreto" tiene los efectos siguientes en las
condiciones de entrada:
● Si el estado lógico del parámetro CMD cambia de "0" a "1", esto tiene los efectos siguientes
en los estados lógicos de los parámetros Q, CMD_HIS, ET (solo si ET < PT), OA y CA:
– Los parámetros Q y CMD_HIS se ponen a "1".
– Los parámetros ET, OA y CA se ponen a "0".
● Si el estado lógico del parámetro CMD cambia de "1" a "0", los parámetros Q, ET (solo si
ET < PT), OA, CA y CMD_HIS se ponen a "0".
● Si los parámetros CMD y CMD_HIS tienen el estado lógico "1" y el parámetro O_FB se pone
a "0", la diferencia de tiempo (ms) desde la última ejecución de la instrucción se suma al
valor del parámetro ET. Si el valor del parámetro ET excede el del parámetro PT, el estado
lógico del parámetro OA se pone a "1". Si el valor del parámetro ET no excede el del
parámetro PT, el estado lógico del parámetro OA se pone a "0". El valor del parámetro
CMD_HIS se pone al del parámetro CMD.

1556

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
● Si los estados lógicos de los parámetros CMD, CMD_HIS y O_FB están a "1" y el parámetro
C_FB devuelve el valor "0", el estado lógico del parámetro OA se pone a "0". El valor del
parámetro ET se pone al del parámetro PT. Si el estado lógico del parámetro O_FB cambia
a "0", se activa la alarma en la siguiente ejecución de la instrucción. El valor del parámetro
CMD_HIS se pone al del parámetro CMD.
● Si los parámetros CMD, CMD_HIS y C_FB devuelven "0", la diferencia de tiempo (ms)
desde la última ejecución de la instrucción se suma al valor del parámetro ET. Si el valor del
parámetro ET excede el del parámetro PT, el estado lógico del parámetro CA se pone a "1".
Si no se excede el valor del parámetro PT, el parámetro CA devuelve el estado lógico "0".
El valor del parámetro CMD_HIS se pone al del parámetro CMD.
● Si los parámetros CMD, CMD_HIS y O_FB devuelven el estado lógico "0" y el parámetro
C_FB está a "1", el parámetro CA se pone a "0". El valor del parámetro ET se pone al del
parámetro PT. Si el estado lógico del parámetro C_FB cambia a "0", se activa la alarma en
la siguiente ejecución de la instrucción. El valor del parámetro CMD_HIS se pone al del
parámetro CMD.
● Si los parámetros O_FB y C_FB devuelven simultáneamente el estado lógico "1", los
estados lógicos de ambas salidas de alarma se ponen a "1".
La instrucción "Alarma de tiempo para control discreto" no devuelve información de error.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Alarma de tiempo para control
discreto":
Parámetro

Declaración Tipo de da‐ Área de memoria
tos

Descripción

CMD

Input

El estado lógico "0" da la or‐
den de "Cerrar".

BOOL

I, Q, M, D, L o constante

El estado lógico "1" da la or‐
den de "Abrir".
O_FB

Input

BOOL

I, Q, M, D, L o constante

Entrada de realimentación
al abrir

C_FB

Input

BOOL

I, Q, M, D, L o constante

Entrada de realimentación
al cerrar

Q

Output

BOOL

I, Q, M, D, L

Indica el estado del paráme‐
tro CMD

OA

Output

BOOL

I, Q, M, D, L

Salida de alarma al abrir

CA

Output

BOOL

I, Q, M, D, L

Salida de alarma al cerrar

ET

Static

DINT

D, L o constante

Tiempo actual transcurrido;
un ciclo de reloj = 1 ms

PT

Static

DINT

D, L o constante

Valor de tiempo predetermi‐
nado; un ciclo de reloj = 1 ms

PREV_TIME

Static

DWORD

D, L o constante

Hora de sistema anterior

CMD_HIS

Static

BOOL

D, L o constante

Bit de evolución de CMD

Programación del PLC
Manual de programación y manejo, 11/2019

1557

Instrucciones
4.1 Instrucciones

Ejemplo
En el ejemplo siguiente, el parámetro CMD cambia de "0" a "1". Una vez ejecutada la
instrucción, el parámetro Q se pone a "1" y las dos salidas de alarma OA y CA se ponen a "0".
El parámetro CMD_HIS del bloque de datos de instancia se pone a "1" y el parámetro ET se
pone a "0".
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

AWL

Explicación

CALL DCAT, "DCAT_DB"

// Se llama la instrucción "Alarma de tiempo para control discreto" y se crea el bloque de datos instancia
"DCAT_DB".

CMD := "Tag_Input_CMD"

// Abrir o cerrar el dispositivo

O_FB := "Tag_Input_O_FB"

// Realimentación al abrir

C_FB := "Tag_Input_C_FB"

// Realimentación al cerrar

Q := "Tag_Output_Q"

// Indica el estado del parámetro CMD

OA := "Tag_Output_OA"

// Salida de alarma al abrir

CA := "Tag_Output_CA"

// Salida de alarma al cerrar

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada y salida:
Parámetro

Operando

Valor

CMD

Tag_Input_CMD

TRUE

O_FB

Tag_Input_O_FB

FALSE

C_FB

Tag_Input_C_FB

FALSE

Q

Tag_Output_Q

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Los siguientes valores se almacenan en el bloque de datos de instancia "DCAT_DB" de la
instrucción:
Parámetro

1558

Dirección

Valor

ET

DBD4

L#12

PT

DBD8

L#222

CMD_HIS

DBX16.0

FALSE

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

Q

Tag_Output_Q

TRUE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Los siguientes valores se almacenan en el bloque de datos de instancia "DCAT_DB" de la
instrucción:
Parámetro

Dirección

Valor

ET

DBD4

L#0

CMD_HIS

DBX16.0

TRUE

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

MCAT: Alarma de tiempo para control del motor
Descripción
La instrucción "Alarma de tiempo para control del motor" acumula el tiempo desde el instante
en el que se activa una de las entradas de comando (abrir o cerrar). El tiempo se acumula hasta
que se excede el tiempo predeterminado o hasta que la entrada de realimentación
correspondiente indica que el dispositivo ha ejecutado la operación solicitada dentro del
tiempo prescrito. Si se excede el tiempo predeterminado antes de recibir respuesta, se dispara
la alarma correspondiente.

Parámetro
La tabla siguiente muestra los parámetros de la instrucción "Alarma de tiempo para control del
motor":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

O_CMD

Input

BOOL

I, Q, M, D, L o
constante

Entrada del comando "Abrir"

C_CMD

Input

BOOL

I, Q, M, D, L o
constante

Entrada del comando "Ce‐
rrar"

S_CMD

Input

BOOL

I, Q, M, D, L o
constante

Entrada del comando "Parar"

O_FB

Input

BOOL

I, Q, M, D, L o
constante

Entrada de respuesta al abrir

Programación del PLC
Manual de programación y manejo, 11/2019

1559

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

C_FB

Input

BOOL

I, Q, M, D, L o
constante

Entrada de respuesta al ce‐
rrar

OO

Output

BOOL

I, Q, M, D, L

Salida "Abrir"

CO

Output

BOOL

I, Q, M, D, L

Salida "Cerrar"

OA

Output

BOOL

I, Q, M, D, L

Salida de alarma al abrir

CA

Output

BOOL

I, Q, M, D, L

Salida de alarma al cerrar

Q

Output

BOOL

I, Q, M, D, L

El estado lógico "0" indica
una condición de error

ET

Static

DINT

D, L o constante

Tiempo actual transcurrido;
un ciclo de reloj = 1 ms

PT

Static

DINT

D, L o constante

Valor de tiempo predetermi‐
nado; un ciclo de reloj = 1 ms

PREV_TIME

Static

DWORD

D, L o constante

Hora de sistema anterior

O_HIS

Static

BOOL

D, L o constante

Bit de evolución "Abrir"

C_HIS

Static

BOOL

D, L o constante

Bit de evolución "Cerrar"

Ejecución de la instrucción "Alarma de tiempo para control del motor"
La tabla siguiente muestra las reacciones de la instrucción "Alarma de tiempo para control del
motor" a las distintas condiciones de entrada:
Parámetros de entrada

Parámetros de salida

ET

O_H
IS

C_H
IS

O_C
MD

C_C
MD

S_C
MD

O_F
B

C_F
B

OO

CO

OA

CA

ET

O_H
IS

C_HI Q
S

Estado

X

1

1

X

X

X

X

X

0

0

1

1

PT

0

0

Alarma

X

X

X

X

X

X

1

1

0

0

1

1

PT

0

0

0

Alarma

X

X

X

X

X

1

X

X

0

0

0

0

X

0

0

1

Stop

X

X

X

1

1

X

X

X

0

0

0

0

X

0

0

1

Stop

X

0

X

1

0

0

X

X

1

0

0

0

0

1

0

1

Empezar a
abrir

<PT

1

0

X

0

0

0

X

1

0

0

0

INC

1

0

1

Abrir

0

X

1

0

X

0

0

1

0

0

0

0

0

PT

1

0

1

Abierto

>=
PT

1

0

X

0

0

0

X

0

0

1

0

PT

1

0

0

Abrir alarma

X

X

0

0

1

0

X

X

0

1

0

0

0

0

1

1

Empezar a
cerrar

< PT 0

1

0

X

0

X

0

0

1

0

0

INC

0

1

1

Cerrar

X

0

1

0

X

0

0

1

0

0

0

0

PT

0

1

1

Cerrado

>=
PT

0

1

0

X

0

X

0

0

0

0

1

PT

0

1

0

Cerrar alar‐
ma

X

0

0

0

0

0

X

X

0

0

0

0

X

0

0

1

Parado

Leyenda:
INC

Sumar a ET la diferencia de tiempo (en ms) desde la última ejecución del FB

PT

PT se pone al mismo valor que ET

X

No aplicable

1560

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetros de entrada
< PT

ET < PT

>= PT

ET >= PT

Parámetros de salida

Si los parámetros de entrada O_HIS y C_HIS tienen el estado lógico "1", se ponen inmediatamente al estado lógico "0". En
este caso se aplica la última fila de la tabla mencionada más arriba (X). Puesto que por este motivo no es posible comprobar
si los parámetros de entrada O_HIS y C_HIS tienen el estado lógico "1", en este caso se asigna el siguiente valor a los
parámetros de salida:
OO = FALSE
CO = FALSE
OA = FALSE
CA = FALSE
ET = PT
Q = TRUE

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

AWL

Explicación

CALL MCAT, "MCAT_DB"

// Se llama la instrucción "Alarma de tiempo para control del motor" y se crea el bloque de datos de instancia "MCAT_DB".

O_CMD := "Tag_Input_O_CMD"

// Entrada de la orden "Abrir"

C_CMD := "Tag_Input_C_CMD"

// Entrada de la orden "Cerrar"

S_CMD := "Tag_Input_S_CMD"

// Entrada de la orden "Parar"

O_FB := "Tag_Input_O_FB"

// Realimentación al abrir

C_FB := "Tag_Input_C_FB"

// Realimentación al cerrar

OO := "Tag_OutputOpen"

// Salida "Abrir"

CO := "Tag_OutputClosed"

// Salida "Cerrar"

OA := "Tag_Output_OA"

// Salida de alarma al abrir

CA := "Tag_Output_CA"

// Salida de alarma al cerrar

Q := "Tag_Output_Q"

// Información de error

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada y salida:
Parámetro

Operando

Valor

O_CMD

Tag_Input_O_CMD

TRUE

C_CMD

Tag_Input_C_CMD

FALSE

Programación del PLC
Manual de programación y manejo, 11/2019

1561

Instrucciones
4.1 Instrucciones
Parámetro

Operando

Valor

S_CMD

Tag_Input_S_CMD

FALSE

O_FB

Tag_Input_O_FB

FALSE

C_FB

Tag_Input_C_FB

FALSE

OO

Tag_OutputOpen

FALSE

CO

Tag_OutputClosed

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Q

Tag_Output_Q

FALSE

En el bloque de datos de instancia "MCAT_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

ET

DBD4

L#2

PT

DBD8

L#22

O_HIS

DBX16.0

TRUE

C_HIS

DBX16.1

FALSE

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

OO

Tag_OutputOpen

TRUE

CO

Tag_OutputClosed

FALSE

OA

Tag_Output_OA

FALSE

CA

Tag_Output_CA

FALSE

Q

Tag_Output_Q

TRUE

En el bloque de datos de instancia "MCAT_DB" de la instrucción se guardan los siguientes
valores:
Parámetro

Dirección

Valor

ET

DBD4

L#0

O_HIS

DBX16.0

TRUE

CMD_HIS

DBX16.1

FALSE

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

1562

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

IMC: Comparar bits de entrada con bits de una máscara
Descripción
La instrucción "Comparar bits de entrada con bits de una máscara" compara el estado lógico
de hasta 16 bits de entrada programados (IN_BIT0 a IN_BIT15) con el bit correspondiente de
una máscara. Es posible programar como máximo 16 pasos con máscaras. El valor del
parámetro IN_BIT0 se compara con el valor de la máscara CMP_VAL[x,0], siendo "x" el
número del paso. El número del paso de la máscara utilizada para la comparación se define en
el parámetro CMP_STEP. De esta misma manera se comparan todos los valores
programados. Los bits de entrada no programados o los bits no programados de la máscara
tienen el estado lógico predeterminado FALSE.
Si se encuentra una correspondencia al realizar la comparación, el estado lógico del parámetro
OUT se pone a "1". De lo contrario, el parámetro OUT se pone a "0".
Si el valor del parámetro CMP_STEP es mayor que 15, no se ejecuta la instrucción. En el
parámetro ERR_CODE se emite un mensaje de error.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Comparar bits de entrada con bits
de una máscara":
Parámetro

Declaración

Tipo de datos

Área de memoria

IN_BIT0

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 0 se
tante
compara con el bit 0 de
la máscara.

IN_BIT1

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 1 se
tante
compara con el bit 1 de
la máscara.

IN_BIT2

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 2 se
tante
compara con el bit 2 de
la máscara.

IN_BIT3

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 3 se
tante
compara con el bit 3 de
la máscara.

IN_BIT4

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 4 se
tante
compara con el bit 4 de
la máscara.

IN_BIT5

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 5 se
tante
compara con el bit 5 de
la máscara.

IN_BIT6

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 6 se
tante
compara con el bit 6 de
la máscara.

IN_BIT7

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 7 se
tante
compara con el bit 7 de
la máscara.

IN_BIT8

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 8 se
tante
compara con el bit 8 de
la máscara.

Programación del PLC
Manual de programación y manejo, 11/2019

Descripción

1563

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

IN_BIT9

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 9 se
tante
compara con el bit 9 de
la máscara.

Descripción

IN_BIT10

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 10 se
tante
compara con el bit 10
de la máscara.

IN_BIT11

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 11 se
tante
compara con el bit 11
de la máscara.

IN_BIT12

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 12 se
tante
compara con el bit 12
de la máscara.

IN_BIT13

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 13 se
tante
compara con el bit 13
de la máscara.

IN_BIT14

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 14 se
tante
compara con el bit 14
de la máscara.

IN_BIT15

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 15 se
tante
compara con el bit 15
de la máscara.

CMP_STEP

Input

BYTE

I, Q, M, D, L, P o
constante

Número de paso de la
máscara con la que se
compara.

OUT

Output

BOOL

I, Q, M, D, L

El estado lógico "1" in‐
dica que se ha encon‐
trado una correspon‐
dencia.
El estado lógico "0" in‐
dica que no se ha en‐
contrado ninguna co‐
rrespondencia.

1564

ERR_CODE

Output

WORD

I, Q, M, D, L, P

CMP_VAL

Static

ARRAY OF
WORD

I, Q, M, D, L o cons‐ Máscaras de compara‐
tante
ción [0 a 15, 0 a 15]: El
primer número del ín‐
dice es el número del
paso y, el segundo, el
número de bit de la
máscara.

Información de error

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

000A

El valor del parámetro CMP_STEP es mayor que 15.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
En el ejemplo siguiente se comparan todos los 16 bits de entrada con la máscara para el paso
2. El estado lógico del parámetro OUT se pone a TRUE porque los bits de entrada concuerdan
con la máscara para el paso 2.
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

AWL

Explicación

CALL IMC, "IMC_DB"

// Se llama la instrucción "Comparar bits de entrada
con bits de una máscara" y se crea el bloque de datos
instancia "IMC_DB".

IN_BIT0 := "Tag_Input_BIT0"

// Bit de entrada 0

IN_BIT1 := "Tag_Input_BIT1"

// Bit de entrada 1

IN_BIT2 := "Tag_Input_BIT2"

// Bit de entrada 2

IN_BIT3 := "Tag_Input_BIT3"

// Bit de entrada 3

IN_BIT4 := "Tag_Input_BIT4"

// Bit de entrada 4

IN_BIT5 := "Tag_Input_BIT5"

// Bit de entrada 5

IN_BIT6 := "Tag_Input_BIT6"

// Bit de entrada 6

IN_BIT7 := "Tag_Input_BIT7"

// Bit de entrada 7

IN_BIT8 := "Tag_Input_BIT8"

// Bit de entrada 8

IN_BIT9 := "Tag_Input_BIT9"

// Bit de entrada 9

IN_BIT10 := "Tag_Input_BIT10" // Bit de entrada 10
IN_BIT11 := "Tag_Input_BIT11" // Bit de entrada 11
IN_BIT12 := "Tag_Input_BIT12" // Bit de entrada 12
IN_BIT13 := "Tag_Input_BIT13" // Bit de entrada 13
IN_BIT14 := "Tag_Input_BIT14" // Bit de entrada 14
IN_BIT15 := "Tag_Input_BIT15" // Bit de entrada 15
CMP_STEP := "Tag_CMP_STEP"

// Número de paso de la máscara

OUT := "Tag_Output"

// Indica si se ha encontrado una correspondencia.

ERR_CODE := "Tag_ErrorCode"

// Información de error

Programación del PLC
Manual de programación y manejo, 11/2019

1565

Instrucciones
4.1 Instrucciones
Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada y salida:
Parámetro

Operando

Valor

IN_BIT0

Tag_Input_BIT0

TRUE

IN_BIT1

Tag_Input_BIT1

TRUE

IN_BIT2

Tag_Input_BIT2

FALSE

IN_BIT3

Tag_Input_BIT3

TRUE

IN_BIT4

Tag_Input_BIT4

TRUE

IN_BIT5

Tag_Input_BIT5

FALSE

IN_BIT6

Tag_Input_BIT6

TRUE

IN_BIT7

Tag_Input_BIT7

TRUE

IN_BIT8

Tag_Input_BIT8

FALSE

IN_BIT9

Tag_Input_BIT9

TRUE

IN_BIT10

Tag_Input_BIT10

TRUE

IN_BIT11

Tag_Input_BIT11

FALSE

IN_BIT12

Tag_Input_BIT12

TRUE

IN_BIT13

Tag_Input_BIT13

TRUE

IN_BIT14

Tag_Input_BIT14

FALSE

IN_BIT15

Tag_Input_BIT15

TRUE

CMP_STEP

Tag_CMP_STEP

B#16#02

OUT

Tag_Output

FALSE

ERR_CODE

Tag_ErrorCode

W#16#0000

En el bloque de datos de instancia "IMC_DB" de la instrucción están almacenados los
siguientes valores para la máscara del paso 2:
Parámetro

1566

Dirección

Valor

CMP_VAL [2,0]

DBX12.0

TRUE

CMP_VAL [2,1]

DBX12.1

TRUE

CMP_VAL [2,2]

DBX12.2

FALSE

CMP_VAL [2,3]

DBX12.3

TRUE

CMP_VAL [2,4]

DBX12.4

TRUE

CMP_VAL [2,5]

DBX12.5

FALSE

CMP_VAL [2,6]

DBX12.6

TRUE

CMP_VAL [2,7]

DBX12.7

TRUE

CMP_VAL [2,8]

DBX13.0

FALSE

CMP_VAL [2,0]

DBX13.1

TRUE

CMP_VAL [2,10]

DBX13.2

TRUE

CMP_VAL [2,11]

DBX13.3

FALSE

CMP_VAL [2,12]

DBX13.4

TRUE

CMP_VAL [2,13]

DBX13.5

TRUE

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Dirección

Valor

CMP_VAL [2,14]

DBX13.6

FALSE

CMP_VAL [2,15]

DBX13.7

TRUE

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

OUT

Tag_Output

TRUE

ERR_CODE

Tag_ErrorCode

W#16#0000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Bases de AWL (Página 8065)

SMC: Barrido de matriz
Descripción
La instrucción "Barrido de matriz" compara el estado lógico de hasta 16 bits de entrada
programados (IN_BIT0 a IN_BIT15) con los bits correspondientes de las máscaras de
comparación de cada paso. La ejecución empieza por el paso 1 y continúa hasta el último paso
programado (LAST) o hasta que se encuentre una correspondencia. El bit de entrada del
parámetro IN_BIT0 se compara con el valor de la máscara CMP_VAL[x,0], siendo "x" el
número de paso. De esta misma manera se comparan todos los valores programados. Si se
encuentra una correspondencia, el estado lógico del parámetro OUT se pone a "1" y el número
de paso se escribe con la máscara correspondiente en el parámetro OUT_STEP. Los bits de
entrada no programados o los bits no programados de la máscara tienen el estado lógico
predeterminado FALSE. Si varios pasos tienen una máscara equivalente, se indica solo la
primera correspondencia encontrada en el parámetro OUT_STEP. Si no se encuentra ninguna
correspondencia, el estado lógico del parámetro OUT se pone a "0". En este caso, el valor del
parámetro OUT_STEP excede en "1" el valor del parámetro LAST.

Programación del PLC
Manual de programación y manejo, 11/2019

1567

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Barrido de matriz":

1568

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN_BIT0

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 0
tante
se compara con el
bit 0 de la másca‐
ra.

IN_BIT1

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 1
tante
se compara con el
bit 1 de la másca‐
ra.

IN_BIT2

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 2
tante
se compara con el
bit 2 de la másca‐
ra.

IN_BIT3

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 3
tante
se compara con el
bit 3 de la másca‐
ra.

IN_BIT4

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 4
tante
se compara con el
bit 4 de la másca‐
ra.

IN_BIT5

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 5
tante
se compara con el
bit 5 de la másca‐
ra.

IN_BIT6

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 6
tante
se compara con el
bit 6 de la másca‐
ra.

IN_BIT7

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 7
tante
se compara con el
bit 7 de la másca‐
ra.

IN_BIT8

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 8
tante
se compara con el
bit 8 de la másca‐
ra.

IN_BIT9

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada 9
tante
se compara con el
bit 9 de la másca‐
ra.

IN_BIT10

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada
tante
10 se compara
con el bit 10 de la
máscara.

IN_BIT11

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada
tante
11 se compara
con el bit 11 de la
máscara.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Declaración

Tipo de datos

Área de memoria

IN_BIT12

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada
tante
12 se compara
con el bit 12 de la
máscara.

Descripción

IN_BIT13

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada
tante
13 se compara
con el bit 13 de la
máscara.

IN_BIT14

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada
tante
14 se compara
con el bit 14 de la
máscara.

IN_BIT15

Input

BOOL

I, Q, M, D, L o cons‐ El bit de entrada
tante
15 se compara
con el bit 15 de la
máscara.

OUT

Output

BOOL

I, Q, M, D, L

El estado lógico
"1" indica que se
ha encontrado
una correspon‐
dencia.
El estado lógico
"0" indica que no
se ha encontrado
ninguna corres‐
pondencia.

ERR_CODE

Output

WORD

I, Q, M, D, L, P

Información de
error

OUT_STEP

Output

BYTE

I, Q, M, D, L, P

Contiene el núme‐
ro de paso con la
máscara corres‐
pondiente o el nú‐
mero de paso que
excede en "1" el
valor del paráme‐
tro LAST, si no se
ha encontrado nin‐
guna correspon‐
dencia.

LAST

Static

BYTE

I, Q, M, D, L, P o
constante

Indica el número
del último paso en
que se tiene que
buscar una más‐
cara correspon‐
diente.

CMP_VAL

Static

ARRAY OF
WORD

I, Q, M, D, L o cons‐ Máscaras de com‐
tante
paración [0 a 15, 0
a 15]: El primer nú‐
mero del índice es
el número del pa‐
so y, el segundo,
el número de bit
de la máscara.

Programación del PLC
Manual de programación y manejo, 11/2019

1569

Instrucciones
4.1 Instrucciones

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

000E

El valor del parámetro LAST es mayor que 15.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
En el ejemplo siguiente, todos los 16 bits de entrada se comparan con la máscara para los
pasos 0 a 5 hasta que se encuentre una correspondencia. Se consultan únicamente las
máscaras para los pasos 0 a 2, ya que la máscara para el paso 2 se corresponde con el bit de
entrada.
Nota
Los parámetros estáticos pueden inicializarse en el bloque.

AWL

Explicación

CALL SMC, "SMC_DB"

// Se llama la instrucción "Barrido de matriz" y se
crea el bloque de datos instancia "SMC_DB".

IN_BIT0 := "Tag_Input_BIT0"

// Bit de entrada 0

IN_BIT1 := "Tag_Input_BIT1"

// Bit de entrada 1

IN_BIT2 := "Tag_Input_BIT2"

// Bit de entrada 2

IN_BIT3 := "Tag_Input_BIT3"

// Bit de entrada 3

IN_BIT4 := "Tag_Input_BIT4"

// Bit de entrada 4

IN_BIT5 := "Tag_Input_BIT5"

// Bit de entrada 5

IN_BIT6 := "Tag_Input_BIT6"

// Bit de entrada 6

IN_BIT7 := "Tag_Input_BIT7"

// Bit de entrada 7

IN_BIT8 := "Tag_Input_BIT8"

// Bit de entrada 8

IN_BIT9 := "Tag_Input_BIT9"

// Bit de entrada 9

IN_BIT10 := "Tag_Input_BIT10" // Bit de entrada 10
IN_BIT11 := "Tag_Input_BIT11" // Bit de entrada 11
IN_BIT12 := "Tag_Input_BIT12" // Bit de entrada 12
IN_BIT13 := "Tag_Input_BIT13" // Bit de entrada 13
IN_BIT14 := "Tag_Input_BIT14" // Bit de entrada 14
IN_BIT15 := "Tag_Input_BIT15" // Bit de entrada 15
OUT := "Tag_Output"

// Indica si se ha encontrado una correspondencia.

OUT_STEP := "Tag_Output_STEP" // Contiene el número de paso con la máscara correspondiente.
ERR_CODE := "Tag_ErrorCode"

1570

// Información de error

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada y salida:
Parámetro

Operando

Valor

IN_BIT0

Tag_Input_BIT0

TRUE

IN_BIT1

Tag_Input_BIT1

TRUE

IN_BIT2

Tag_Input_BIT2

FALSE

IN_BIT3

Tag_Input_BIT3

TRUE

IN_BIT4

Tag_Input_BIT4

TRUE

IN_BIT5

Tag_Input_BIT5

FALSE

IN_BIT6

Tag_Input_BIT6

TRUE

IN_BIT7

Tag_Input_BIT7

TRUE

IN_BIT8

Tag_Input_BIT8

FALSE

IN_BIT9

Tag_Input_BIT9

TRUE

IN_BIT10

Tag_Input_BIT10

TRUE

IN_BIT11

Tag_Input_BIT11

FALSE

IN_BIT12

Tag_Input_BIT12

TRUE

IN_BIT13

Tag_Input_BIT13

TRUE

IN_BIT14

Tag_Input_BIT14

FALSE

IN_BIT15

Tag_Input_BIT15

TRUE

OUT

Tag_Output

FALSE

OUT_STEP

Tag_Output_STEP

B#16#00

ERR_CODE

Tag_ErrorCode

W#16#0000

En el bloque de datos de instancia "SMC_DB" de la instrucción están almacenados los
siguientes valores para la máscara del paso 2:
Parámetro

Dirección

Valor

CMP_VAL [2,0]

DBX12.0

TRUE

CMP_VAL [2,1]

DBX12.1

TRUE

CMP_VAL [2,2]

DBX12.2

FALSE

CMP_VAL [2,3]

DBX12.3

TRUE

CMP_VAL [2,4]

DBX12.4

TRUE

CMP_VAL [2,5]

DBX12.5

FALSE

CMP_VAL [2,6]

DBX12.6

TRUE

CMP_VAL [2,7]

DBX12.7

TRUE

CMP_VAL [2,8]

DBX13.0

FALSE

CMP_VAL [2,0]

DBX13.1

TRUE

CMP_VAL [2,10]

DBX13.2

TRUE

CMP_VAL [2,11]

DBX13.3

FALSE

CMP_VAL [2,12]

DBX13.4

TRUE

CMP_VAL [2,13]

DBX13.5

TRUE

Programación del PLC
Manual de programación y manejo, 11/2019

1571

Instrucciones
4.1 Instrucciones
Parámetro

Dirección

Valor

CMP_VAL [2,14]

DBX13.6

FALSE

CMP_VAL [2,15]

DBX13.7

TRUE

LAST

DB84

B#16#05

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

OUT

Tag_Output

TRUE

OUT_STEP

Tag_Output_STEP

B#16#02

ERR_CODE

Tag_ErrorCode

W#16#0000

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Bases de AWL (Página 8065)

LEAD_LAG: Algoritmo Lead y Lag
Descripción
La instrucción "Algoritmo Lead y Lag" procesa señales con una variable analógica. El valor de
la ganancia en el parámetro GAIN debe ser mayor que cero. El resultado de la instrucción
"Algoritmo Lead y Lag" se calcula con la siguiente ecuación:
287

/*B7,0(
/'B7,0(6$03/(B7
/'B7,0(
,1*$,1
35(9B287*$,1
/*B7,0(6$03/(B7
/*B7,0(6$03/(B7
/*B7,0(6$03/(B7

35(9B,1

La instrucción "Algoritmo Lead y Lag" solo devuelve resultados relevantes cuando se ejecuta
en ciclos de programa fijos. Deben indicarse las mismas unidades en los parámetros
LD_TIME, LG_TIME y SAMPLE_T. Si LG_TIME > 4 + SAMPLE_T, la instrucción se aproxima
a la siguiente función:
OUT = GAIN * ((1 + LD_TIME * s) / (1 + LG_TIME * s)) * IN
Si el valor del parámetro GAIN es menor o igual a cero, no se realiza el cálculo y el parámetro
ERR_CODE devuelve una información de error.
La instrucción "Algoritmo Lead y Lag" puede utilizarse junto con bucles para la compensación
en el control anticipativo. La instrucción comprende dos operaciones. La operación "Lead"
desplaza la fase de la salida OUT, anticipándose la salida a la entrada. En cambio, la operación
"Lag" desplaza la salida, de manera que la salida sigue a la entrada. Puesto que la operación
"Lag" equivale a una integración, puede utilizarse como supresor de perturbaciones o filtro de

1572

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
paso bajo. La operación "Lead" equivale a una acción diferencial, por lo que puede utilizarse
como un filtro de paso alto. La combinación de ambas operaciones (Lead y Lag) hace que la
fase de salida siga a la entrada a bajas frecuencias y se le anticipe a altas frecuencias. Por este
motivo, la instrucción "Algoritmo Lead y Lag" puede utilizarse como si fuera un filtro de paso de
banda.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Algoritmo Lead y Lag":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

REAL

I, Q, M, D, L, P o
constante

Valor de entrada
del tiempo de
muestreo actual
(tiempo de ciclo)
que se procesa

SAMPLE_T

Input

INT

I, Q, M, D, L, P o
constante

Tiempo de mues‐
treo

OUT

Output

REAL

I, Q, M, D, L, P

Resultado de la
instrucción

ERR_CODE

Output

WORD

I, Q, M, D, L, P

Información de
error

LD_TIME

Static

REAL

I, Q, M, D, L, P o
constante

Tiempo de antici‐
pación en la mis‐
ma unidad que el
tiempo de mues‐
treo.

LG_TIME

Static

REAL

I, Q, M, D, L, P o
constante

Tiempo de segui‐
miento en la mis‐
ma unidad que el
tiempo de mues‐
treo.

GAIN

Static

REAL

I, Q, M, D, L, P o
constante

Ganancia en % /
% (relación del
cambio en la sali‐
da con respecto al
cambio en la entra‐
da como estado
constante).

PREV_IN

Static

REAL

I, Q, M, D, L, P o
constante

Entrada anterior

PREV_OUT

Static

REAL

I, Q, M, D, L, P o
constante

Salida anterior

Programación del PLC
Manual de programación y manejo, 11/2019

1573

Instrucciones
4.1 Instrucciones

Parámetro ERR_CODE
La tabla siguiente muestra el significado de los valores del parámetro ERR_CODE:
Código de
error*
(W#16#...)

Explicación

0000

Ningún error

0009

El valor del parámetro GAIN es menor o igual a cero.

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
Nota
Los parámetros estáticos pueden inicializarse en el bloque de datos.

AWL

Explicación

CALL LEAD_LAG, "LEAD_LAG_DB"

// Se llama la instrucción "Algoritmo Lead y Lag" y se
crea el bloque de datos instancia "LEAD_LAG_DB".

IN := "Tag_Input"

// Valor de entrada del tiempo de muestreo actual
(tiempo de ciclo) que se procesa.

SAMPLE_T := "Tag_Input_SAMPE_T"

// Tiempo de muestreo

OUT := "Tag_Output_Result"

// Resultado de la instrucción

ERR_CODE := "Tag_ErrorCode"

// Información de error

Las tablas siguientes muestran el funcionamiento de la instrucción con valores concretos.

Antes de la ejecución
En este ejemplo se utilizan los siguientes valores para los parámetros de entrada:
Parámetro

Operando

Valor

IN

Tag_Input

2.0

SAMPLE_T

Tag_InputSampleTime

10

Los siguientes valores se almacenan en el bloque de datos de instancia "LEAD_LAG_DB" de
la instrucción:

1574

Parámetro

Dirección

Valor

LD_TIME

DBD12

2.0

LG_TIME

DBD16

2.0

GAIN

DBD20

1.0

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Parámetro

Dirección

Valor

PREV_IN

DBD24

6.0

PREV_OUT

DBD28

6.0

Después de la ejecución
Una vez ejecutada la instrucción, los valores siguientes se escriben en los parámetros de
salida:
Parámetro

Operando

Valor

OUT

Tag_Output_Result

2.0

Los siguientes valores se guardan en el bloque de datos de instancia "LEAD_LAD_DB" de la
instrucción:
Parámetro

Operando

Valor

PREV_IN

DBD24

2.0

PREV_OUT

DBD28

2.0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Bases de AWL (Página 8065)

SEG: Generar patrón de bits para el display de 7 segmentos
Descripción
La instrucción "Generar patrón de bits para el display de 7 segmentos" convierte cada una de
las cuatro cifras hexadecimales de la palabra de origen indicada (IN) en cuatro códigos
equivalentes para un display de 7 segmentos y los escribe en la palabra doble de la salida
(OUT).
La instrucción "Generar patrón de bits para el display de 7 segmentos" no detecta condiciones
de error.
Entre los valores de entrada hexadecimales y los patrones de bits de la salida existe la relación
siguiente:
Cifra
0000
0001
0010

-gfedcba
00111111
00000110
01011011

Programación del PLC
Manual de programación y manejo, 11/2019

Display
0
1
2

Display de siete segmentos

1575

Instrucciones
4.1 Instrucciones
0011
0100
0101
0110
0111
1000
1001
1010
1011
1100
1101
1110
1111

01001111
01100110
01101101
01111101
00000111
01111111
01100111
01110111
01111100
00111001
01011110
01111001
01110001

3
4
5
6
7
8
9
A
B
C
D
E
F

D
I

E
J

H

F
G

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Generar patrón de bits para el
display de 7 segmentos":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

IN

WORD

I, Q, M, D, L, P o
constante

Palabra de origen
con cuatro cifras
hexadecimales.

OUT

OUT

DWORD

I, Q, M, D, L, P

Patrón de bits del
destino con cuatro
bytes.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL SEG

// Se llama la instrucción "Generar patrón de bits para el display de 7 segmentos".

IN := "Tag_Input"

// Palabra de origen

OUT := "Tag_Output"

// Patrón de bits para el display de 7 segmentos

La tabla siguiente muestra el funcionamiento de la instrucción con valores concretos:
Parámetro

Operando

Valor

Hexadecimal

Binario

IN

Tag_Input

W#16#1234

0001 0010 0011 0100

OUT

Tag_Output

DW#16#065B4F66

00000110 01011011 01001111
01100110
Visualización: 1234

1576

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

BCDCPL: Generar complemento a diez
Descripción
La instrucción "Generar complemento a diez" crea el complemento a diez de un número BCD
de siete dígitos que se indica en el parámetro IN. La instrucción realiza el cálculo con la
siguiente fórmula matemática:
10000000 (como BCD)
– Valor BCD de 7 dígitos
---------------------------------------Complemento a diez (como BCD)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Generar complemento a diez":
Parámetro

Declaración

Tipo de datos

Área de memoria

IN

Input

Secuencias de bits I, Q, M, D, L, P o
constante

Número BCD de 7
dígitos

ERR_CODE

Output

DWORD

Resultado de la
instrucción

I, Q, M, D, L, P

Descripción

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL BCDCPL

// Se llama la instrucción.

IN := "Tag_Input"

// Número BCD de 7 dígitos

ERR_CODE := "Tag_Output"

// Complemento a diez del número BCD indicado

La tabla siguiente muestra el funcionamiento de la instrucción con valores concretos:
Parámetro

Operando

Valor*

IN

Tag_Input

DW#16#01234567

ERR_CODE

Tag_Output

DW#16#08765433

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

Programación del PLC
Manual de programación y manejo, 11/2019

1577

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Bases de AWL (Página 8065)

BITSUM: Contar número de bits activados
Descripción
La instrucción "Contar número de bits activados" cuenta el número de bits de un operando que
están puestos al estado lógico "1". El operando cuyos bits se cuentan se especifica en el
parámetro IN. El resultado de la instrucción se devuelve en el parámetro RET_VAL.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Contar número de bits activados":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

IN

Input

DWORD

I, Q, M, D, L, P o
constante

Operando cuyos
bits activados se
cuentan.

RET_VAL

Output

INT

I, Q, M, D, L, P

Número de bits ac‐
tivados

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

CALL BITSUM

// Se llama la instrucción.

IN := "Tag_Input"

// Operando cuyos bits activados se cuentan.

RET_VAL := "Tag_Output"

// Número de bits activados del operando "Tag_Input".

La tabla siguiente muestra el funcionamiento de la instrucción con valores concretos:
Parámetro

Operando

Valor*

IN

Tag_Input

DW#16#12345678

RET_VAL

Tag_Output

W#16#000D (13 bits)

*En el editor de programas, los códigos de error se pueden representar como valores enteros o hexa‐
decimales. Encontrará más información sobre el cambio de los formatos de visualización en "Consulte
también".

1578

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Cambiar formatos de visualización en el estado del programa (Página 8529)
Bases de AWL (Página 8065)

Nemónicos de AWL
Operaciones lógicas con bits
A: Operación lógica Y
Descripción
La instrucción "Operación lógica Y" consulta si el estado lógico de un operando binario es "1"
y combina el resultado lógicamente con Y con el estado lógico del resultado lógico (RLO). En
este caso, el resultado de la consulta es idéntico al estado lógico del operando consultado.
Una vez ejecutada la instrucción, el RLO es "1" si los dos estados lógicos combinados también
son "1". Si uno de los estados lógicos combinados es "0", el RLO será "0" tras ejecutar la
instrucción.
Si se aplica la instrucción varias veces consecutivas, todos los resultados de las consultas
deben ser "1" para que el resultado lógico común también sea "1".
Con la instrucción "Operación lógica Y" también es posible consultar el estado lógico de la
palabra de estado. Para ello se debe indicar el bit de estado en cuestión (==0, <>0, >0, <0, >=0,
<=0, OV, OS, UO, BR) como parámetro de la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica Y":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

BOOL

I, Q, M, D, L, T, C

Operando cuyo estado lógico
se consulta.

Programación del PLC
Manual de programación y manejo, 11/2019

1579

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/

(VTXHPDGHFRQH[LRQHVGHUHO«
%DUUDGHDOLPHQWDFLµQ

$

ಯ7DJB,QSXWBಯ

(VWDGROµJLFR

&RQWDFWR1$

$

ಯ7DJB,QSXWBಯ

(VWDGROµJLFR

&RQWDFWR1$

ಯ7DJB2XWSXWಯ

(VWDGROµJLFR

%RELQD

,QGLFDXQLQWHUUXSWRUFHUUDGR

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)
Ejemplos de programación AWL (Página 8102)

AN: Operación lógica Y negada
Descripción
La instrucción "Operación lógica Y negada" consulta si el estado lógico de un operando binario
es "0" y combinar el resultado lógicamente con Y con el estado lógico del resultado lógico
(RLO). En este caso, el resultado de la consulta es el estado lógico negado del operando
consultado. Si el estado lógico del operando es "0", el resultado de la consulta es "1". Si el
estado lógico del operando es "1", el resultado de la consulta es "0".
Una vez ejecutada la instrucción, el RLO es "1" si el resultado de la consulta y el RLO antes de
ejecutar la instrucción devuelven el estado lógico "1".
Una vez ejecutada la instrucción, el RLO es "0" si el resultado de la consulta o el RLO antes de
ejecutar la instrucción devuelven el estado lógico "0".
Con la instrucción "Operación lógica Y negada" también es posible consultar el estado lógico
de la palabra de estado. Para ello se debe indicar el bit de estado en cuestión (==0, <>0, >0,
<0, >=0, <=0, OV, OS, UO, BR) como parámetro de la instrucción.

1580

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica Y negada":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

BOOL

I, Q, M, D, L, T, C

Operando cuyo estado lógico
se consulta.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/

(VTXHPDGHFRQH[LRQHVGHUHO«
%DUUDGHDOLPHQWDFLµQ

$

ಯ7DJB,QSXWBಯ

(VWDGROµJLFR

&RQWDFWR1$

$1

ಯ7DJB,QSXWBಯ

(VWDGROµJLFR

&RQWDFWR1&

ಯ7DJB2XWSXWಯ

(VWDGROµJLFR

%RELQD

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplos de programación AWL (Página 8102)
Bases de AWL (Página 8065)

O: Operación lógica O
Descripción
La instrucción "Operación lógica O" consulta si el estado lógico de un operando binario es "1"
y combina el resultado lógicamente con O con el estado lógico del resultado lógico (RLO). En
este caso, el resultado de la consulta es idéntico al estado lógico del operando consultado.
Una vez ejecutada la instrucción, el RLO es "1" si uno de los estados lógicos combinados
también es "1". Si los dos estados lógicos combinados son "0", el RLO será "0" tras ejecutar la
instrucción.
Si se aplica la instrucción varias veces consecutivas, basta con que uno de los resultados de
las consultas sea "1" para que el resultado lógico común también sea "1".

Programación del PLC
Manual de programación y manejo, 11/2019

1581

Instrucciones
4.1 Instrucciones
Con la instrucción "Operación lógica O" también es posible consultar el estado lógico de la
palabra de estado. Para ello se debe indicar el bit de estado en cuestión (==0, <>0, >0, <0, >=0,
<=0, OV, OS, UO, BR) como parámetro de la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica O":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

BOOL

I, Q, M, D, L, T, C

Operando cuyo estado lógico
se consulta.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/

(VTXHPDGHFRQH[LRQHVGHUHO«
%DUUDGHDOLPHQWDFLµQ

2

ಯ7DJB,QSXWBಯ

2

ಯ7DJB,QSXWBಯ

ಯ7DJB2XWSXWಯ

(VWDGROµJLFRFRQWDFWR1$
ಯ7DJB,QSXWBಯ

(VWDFROµJLFRFRQWDFWR1$
ಯ7DJB,QSXWBಯ

(VWDGROµJLFR

%RELQD

,QGLFDXQLQWHUUXSWRUFHUUDGR

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplos de programación AWL (Página 8102)
Bases de AWL (Página 8065)

1582

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

ON: Operación lógica O negada
Descripción
La instrucción "Operación lógica O negada" consulta si el estado lógico de un operando binario
es "0" y combina el resultado lógicamente con O con el estado lógico del resultado lógico
(RLO). En este caso, el resultado de la consulta es el estado lógico negado del operando
consultado. Si el estado lógico del operando es "0", el resultado de la consulta es "1". Si el
estado lógico del operando es "1", el resultado de la consulta es "0".
Una vez ejecutada la instrucción, el RLO es "1" si el resultado de la consulta o el RLO antes de
ejecutar la instrucción devuelven el estado lógico "1". Si los dos estados lógicos combinados
son "0", el RLO también será "0" tras ejecutar la instrucción.
Si se aplica la instrucción varias veces consecutivas, basta con que uno de los resultados de
las consultas sea "1" para que el resultado lógico común también sea "1".
Con la instrucción "Operación lógica O negada" también es posible consultar el estado lógico
de la palabra de estado. Para ello se debe indicar el bit de estado en cuestión (==0, <>0, >0,
<0, >=0, <=0, OV, OS, UO, BR) como parámetro de la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica O negada":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

BOOL

I, Q, M, D, L, T, C

Operando cuyo estado lógico
se consulta

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/

(VTXHPDGHFRQH[LRQHVGHUHO«V
%DUUDGHDOLPHQWDFLµQ

2

ಯ7DJB,QSXWBಯ

(VWDGROµJLFR

21

ಯ7DJB,QSXWBಯ

(VWDGROµJLFR

&RQWDFWR
QRUPDOPHQWH
FHUUDGR

(VWDGROµJLFR

%RELQD

ಯ7DJB2XWSXWಯ

Programación del PLC
Manual de programación y manejo, 11/2019

&RQWDFWRQRUPDO
PHQWHDELHUWR

1583

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

X: Operación lógica O-exclusiva
Descripción
La instrucción "Operación lógica O-exclusiva" consulta si el estado lógico de un operando
binario es "1" y combinar el resultado lógicamente con O-exclusiva con el estado lógico del
resultado lógico (RLO). En este caso, el resultado de la consulta es idéntico al estado lógico del
operando consultado. Una vez ejecutada la instrucción, el RLO es "1" si los estados lógicos
combinados entre sí son distintos. El RLO es "0" si ambos estados lógicos son idénticos.
Si, p. ej., el RLO antes de ejecutar la instrucción es "1" y el operando consultado devuelve "1",
el RLO se pone a "0". Si el RLO es "1" y el operando devuelve el estado lógico "0", el RLO tras
ejecutar la instrucción se pondrá a "1".
Si se aplica la instrucción varias veces consecutivas, basta con que uno de los resultados de
las consultas sea "1" para que el RLO común también sea "1". Si todos los resultados son "1"
o "0", el RLO se pone a "0".
Con la instrucción "Operación lógica O-exclusiva" también es posible consultar el estado lógico
de la palabra de estado. Para ello se debe indicar el bit de estado en cuestión (==0, <>0, >0,
<0, >=0, <=0, OV, OS, UO, BR) como parámetro de la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica O-exclusiva":

1584

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

BOOL

I, Q, M, D, L, T, C

Operando cuyo estado lógico
se consulta.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/

(VTXHPDGHFRQH[LRQHVGHUHO«
%DUUDGHDOLPHQWDFLµQ

;

ಯ7DJB,QSXWBಯ

&RQWDFWR

;

ಯ7DJB,QSXWBಯ

&RQWDFWR

ಯ7DJB2XWSXWಯ

%RELQD

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

XN: Operación lógica O-exclusiva negada
Descripción
La instrucción "Operación lógica O-exclusiva negada" consulta si el estado lógico de un
operando binario es "0" y combinar el resultado lógicamente con O con el estado lógico del
resultado lógico (RLO). En este caso, el resultado de la consulta es el estado lógico negado del
operando consultado. Una vez ejecutada la instrucción, el RLO es "1" si los estados lógicos
combinados entre sí son distintos. El RLO es "0" si ambos estados lógicos son idénticos.
Si, p. ej., el estado lógico del operando consultado es "0", el resultado de la consulta es "1". La
combinación lógica con O-exclusiva del resultado de la consulta y un RLO "1" devuelve el
estado lógico "0". La combinación con un RLO "0" devuelve el estado lógico "1".
Con la instrucción "Operación lógica O-exclusiva negada" también es posible consultar el
estado lógico de la palabra de estado. Para ello se debe indicar el bit de estado en cuestión
(==0, <>0, >0, <0, >=0, <=0, OV, OS, UO, BR) como parámetro de la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

1585

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Operación lógica O-exclusiva
negada":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

BOOL

I, Q, M, D, L, T, C

Operando cuyo estado lógico
se consulta.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/

(VTXHPDGHFRQH[LRQHVGHUHO«
%DUUDGHDOLPHQWDFLµQ

;

ಯ7DJB,QSXWBಯ

&RQWDFWR

;1

ಯ7DJB,QSXWBಯ

&RQWDFWR

ಯ7DJB2XWSXWಯ

%RELQD

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

O: Operación lógica O de funciones Y
Descripción
La instrucción "Operación lógica O de funciones Y" ejecuta varias operaciones lógicas Y antes
de una operación lógica O. El resultado global de las operaciones lógicas Y se guarda en una
memoria intermedia y se combina lógicamente con O con las demás consultas de señales.

1586

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/

(VTXHPDGHFRQH[LRQHVGHUHO«
%DUUDGHDOLPHQWDFLµQ

$
$

ಯ7DJB,QSXWBಯ
ಯ7DJB,QSXWBಯ

2
$
$

ಯ7DJB,QSXWBಯ
ಯ7DJB,QSXWBಯ

2

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB2XWSXWಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB2XWSXWಯ

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

A(: Operación lógica Y con abrir paréntesis
Descripción
La instrucción "Operación lógica Y con abrir paréntesis" procesa las instrucciones de una
expresión entre paréntesis antes de una operación lógica Y.
Al ejecutar la instrucción, la CPU guarda el resultado lógico (RLO) actual así como el resultado
binario BR. El RLO guardado se combina lógicamente con Y con el resultado lógico de toda la
expresión entre paréntesis. Si a la expresión entre paréntesis le siguen otras consultas,
también se combinan con la función Y.
Las expresiones entre paréntesis se anidan programando en ellas una instrucción que también
contenga una expresión entre paréntesis. La profundidad de anidamiento está limitada a 7
niveles.

Programación del PLC
Manual de programación y manejo, 11/2019

1587

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/

(VTXHPDGHFRQH[LRQHVGHUHO«
%DUUDGHDOLPHQWDFLµQ

$
2
2

ಯ7DJB,QSXWBಯ
ಯ7DJB,QSXWBಯ

$
2
2

ಯ7DJB,QSXWBಯ
ಯ7DJB,QSXWBಯ

$

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB2XWSXWಯ

ಯ7DJB2XWSXWಯ

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

AN(: Operación lógica Y negada con abrir paréntesis
Descripción
La instrucción "Operación lógica Y negada con abrir paréntesis" procesa las instrucciones de
una expresión entre paréntesis antes de una operación lógica Y y negar el resultado global de
la expresión entre paréntesis.
Al ejecutar la instrucción, la CPU guarda el resultado lógico (RLO) actual así como el resultado
binario BR. Después de procesar las instrucciones que están en la expresión entre paréntesis,
el RLO de toda la expresión entre paréntesis se niega y se combina lógicamente con Y con el
RLO guardado. Si a la expresión entre paréntesis le siguen otras consultas, también se
combinan con la instrucción Y.
Las expresiones entre paréntesis se anidan programando en ellas una instrucción que también
contenga una expresión entre paréntesis. La profundidad de anidamiento está limitada a 7
niveles.

1588

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

AN(

// Principio de la expresión entre paréntesis
// Combinar lógicamente con Y el RLO de la expresión
entre paréntesis y negar el resultado global.

O "Tag_Input_1"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con O con el RLO actual.

O "Tag_Input_2"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con O con el RLO actual.

)

// Fin de la expresión entre paréntesis

AN "Tag_Input_3"

// Consultar si el estado lógico del operando es "0" y
combinar el resultado lógicamente con Y con el RLO actual.

= "Tag_Output"

// Asignar el estado lógico del RLO al operando.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

O(: Operación lógica O con abrir paréntesis
Descripción
La instrucción "Operación lógica O con abrir paréntesis" procesa las instrucciones de una
expresión entre paréntesis antes de una operación lógica O.
Al ejecutar la instrucción, la CPU guarda el resultado lógico (RLO) actual así como el resultado
binario BR. Después de procesar las instrucciones que están en la expresión entre paréntesis,
el RLO guardado se combina lógicamente con O con el RLO de toda la expresión entre
paréntesis. Si a la expresión entre paréntesis le siguen otras consultas, también se combinan
con la instrucción O.
Las expresiones entre paréntesis se anidan programando en ellas una instrucción que también
contenga una expresión entre paréntesis. La profundidad de anidamiento está limitada a 7
niveles.

Programación del PLC
Manual de programación y manejo, 11/2019

1589

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input_1"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

O(

// Principio de la expresión entre paréntesis
// Combinar lógicamente con O el RLO de la expresión
entre paréntesis.

A "Tag_Input_2"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

A "Tag_Input_3"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

)

// Fin de la expresión entre paréntesis

= "Tag_Output"

// Asignar el estado lógico del RLO al operando.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

ON(: Operación lógica O negada con abrir paréntesis
Descripción
La instrucción "Operación lógica O negada con abrir paréntesis" procesa las instrucciones de
una expresión entre paréntesis antes de una operación lógica O y negar el resultado global de
la expresión entre paréntesis.
Al ejecutar la instrucción, la CPU guarda el resultado lógico (RLO) actual así como el resultado
binario BR. Después de procesar las instrucciones que están en la expresión entre paréntesis,
el RLO de la expresión entre paréntesis se niega y se combina lógicamente con O con el RLO
guardado. Si a la expresión entre paréntesis le siguen otras consultas, también se combinan
con la instrucción O.
Las expresiones entre paréntesis se anidan programando en ellas una instrucción que también
contenga una expresión entre paréntesis. La profundidad de anidamiento está limitada a 7
niveles.

1590

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input_1"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

ON(

// Principio de la expresión entre paréntesis
// Combinar lógicamente con O el RLO de la expresión
entre paréntesis y negar el resultado global.

A "Tag_Input_2"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

A "Tag_Input_3"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

)

// Fin de la expresión entre paréntesis

= "Tag_Output"

// Asignar el estado lógico del RLO al operando.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

X(: Operación lógica O-exclusiva con abrir paréntesis
Descripción
La instrucción "Operación lógica O-exclusiva con abrir paréntesis" procesa las instrucciones
de una expresión entre paréntesis antes de una operación lógica O-exclusiva.
Al ejecutar la instrucción, la CPU guarda el resultado lógico (RLO) actual así como el resultado
binario BR. Después de procesar las instrucciones que están en la expresión entre paréntesis,
el RLO guardado se combina lógicamente con O-exclusiva con el RLO de toda la expresión
entre paréntesis. Si a la expresión entre paréntesis le siguen otras consultas, también se
combinan con la función O-exclusiva.
Las expresiones entre paréntesis se anidan programando en ellas una instrucción que también
contenga una expresión entre paréntesis. La profundidad de anidamiento está limitada a 7
niveles.

Programación del PLC
Manual de programación y manejo, 11/2019

1591

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

X(

// Principio de la expresión entre paréntesis
// Combinar lógicamente con O-exclusiva el RLO de la
expresión entre paréntesis.

A "Tag_Input_1"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

A "Tag_Input_2"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

)

// Fin de la expresión entre paréntesis

X "Tag_Input_3"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

= "Tag_Output"

// Asignar el estado lógico del RLO al operando.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

XN(: Operación lógica O-exclusiva negada con abrir paréntesis
Descripción
La instrucción "Operación lógica O-exclusiva negada con abrir paréntesis" procesa las
instrucciones de una expresión entre paréntesis antes de una operación lógica O-exclusiva y
negar el resultado global de la expresión entre paréntesis.
Al ejecutar la instrucción, la CPU guarda el resultado lógico (RLO) actual así como el resultado
binario BR. Después de procesar las instrucciones que están en la expresión entre paréntesis,
el RLO de la expresión entre paréntesis se niega y se combina lógicamente con O-exclusiva
con el RLO guardado. Si a la expresión entre paréntesis le siguen otras consultas, también se
combinan con la función O-exclusiva.
Las expresiones entre paréntesis se anidan programando en ellas una instrucción que también
contenga una expresión entre paréntesis. La profundidad de anidamiento está limitada a 7
niveles.

1592

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

XN(

// Principio de la expresión entre paréntesis
// Combinar lógicamente con O-exclusiva el RLO de la
expresión entre paréntesis y negar el resultado global.

A "Tag_Input_1"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

A "Tag_Input_2"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

)

// Fin de la expresión entre paréntesis

XN "Tag_Input_3"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

= "Tag_Output"

// Asignar el estado lógico del RLO al operando.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

): Cerrar paréntesis
Descripción
La instrucción "Cerrar paréntesis" determina el final de una expresión entre paréntesis. Tras
ejecutar la instrucción, el resultado global de la expresión entre paréntesis se combina
lógicamente con la instrucción que se ha utilizado para abrir la expresión entre paréntesis.
Para abrir una expresión entre paréntesis se utilizan las instrucciones siguientes:
● A(: Operación lógica Y con abrir paréntesis
● AN(: Operación lógica Y negada con abrir paréntesis
● O(: Operación lógica O con abrir paréntesis
● ON(: Operación lógica O negada con abrir paréntesis
● X(: Operación lógica O-exclusiva con abrir paréntesis
● XN(: Operación lógica O-exclusiva negada con abrir paréntesis
Después de la instrucción "Cerrar paréntesis", la CPU pone el resultado binario BR al estado
lógico que tenía antes de la expresión entre paréntesis.

Programación del PLC
Manual de programación y manejo, 11/2019

1593

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/

(VTXHPDGHFRQH[LRQHVGHUHO«
%DUUDGHDOLPHQWDFLµQ

$
2
2

ಯ7DJB,QSXWBಯ
ಯ7DJB,QSXWBಯ

$
2
2

ಯ7DJB,QSXWBಯ
ಯ7DJB,QSXWBಯ

$

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB,QSXWBಯ

ಯ7DJB2XWSXWಯ

ಯ7DJB2XWSXWಯ

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

=: Asignación
Descripción
La instrucción "Asignación" asigna a un operando concreto el estado lógico del resultado
lógico (RLO) guardado en la CPU. Si el RLO tiene el estado lógico "1", se activa el operando.
Si el estado lógico de la entrada es "0", el operando se pone a "0".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Asignación":

1594

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Output

BOOL

I, Q, M, D, L

Operando al que se asigna el
RLO actual.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/
$

(VTXHPDGHFRQH[LRQHVGHUHO«
%DUUDGHDOLPHQWDFLµQ

ಯ7DJB,QSXWಯ
ಱ7DJB2XWSXWಯ

ಯ7DJB,QSXWಯ

'LDJUDPDVGHHVWDGRVOµJLFRV
ಯ7DJB,QSXWಯ




ಯ7DJB2XWSXWಯ






ಯ7DJB2XWSXWಯ

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplos de programación AWL (Página 8102)
Bases de AWL (Página 8065)

R: Desactivar
Descripción
La instrucción "Desactivar" pone a "0" el estado lógico de un operando concreto.
La instrucción solo se ejecuta si el resultado lógico (RLO) actual es "1". Tras ejecutar la
instrucción, el operando indicado se pone a "0". Si el RLO actual es "0", el estado lógico del
operando indicado no cambia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Desactivar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Output

BOOL

I, Q, M, D, L

Operando que se desactiva
si el RLO = "1".

Programación del PLC
Manual de programación y manejo, 11/2019

1595

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input_1"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

A "Tag_Input_2"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

R "Tag_Output"

// Poner el operando a "0" si el RLO = "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplos de programación AWL (Página 8102)
Bases de AWL (Página 8065)

S: Activar
Descripción
La instrucción "Activar" pone a "1" el estado lógico de un operando concreto.
La instrucción solo se ejecuta si el resultado lógico (RLO) actual es "1". Tras ejecutar la
instrucción, el operando indicado se pone a "1". Si el RLO actual es "0", el estado lógico del
operando indicado no cambia.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Activar":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Output

BOOL

I, Q, M, D, L

Operando que se activa si el
RLO = "1".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1596

AWL

Explicación

A "Tag_Input_1"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

A "Tag_Input_2"

// Consultar si el estado lógico del operando es "1" y
combinar el resultado lógicamente con Y con el RLO actual.

S "Tag_Output"

// Poner el operando a "1" si el RLO = "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplos de programación AWL (Página 8102)
Bases de AWL (Página 8065)

NOT: Invertir RLO
Descripción
La instrucción "Invertir RLO" invierte el estado lógico del resultado lógico (RLO). La instrucción
"Invertir RLO" puede aplicarse en cualquier posición, incluso dentro de una operación lógica.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input_1"

// Consultar si el estado lógico del operando "Tag_Input_1" es "1" y combinar el resultado lógicamente con
Y con el RLO actual.

A "Tag_Input_2"

// Consultar si el estado lógico del operando "Tag_Input_2" es "1" y combinar el resultado lógicamente con
Y con el RLO actual.

A "Tag_Input_3"

// Consultar si el estado lógico del operando "Tag_Input_3" es "1" y combinar el resultado lógicamente con
Y con el RLO actual.

NOT

// Invertir el estado lógico del RLO

= "Tag_Output"

// Asignar el estado lógico del RLO al operando
"Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Input_1

1

1

1

0

0

0

1

0

Tag_Input_2

0

1

1

0

1

1

0

1

Tag_Input_3

0

0

1

0

0

1

1

1

Tag_Output

1

1

0

1

1

1

1

1

Programación del PLC
Manual de programación y manejo, 11/2019

1597

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

SET: Poner RLO a 1
Descripción
La instrucción "Poner RLO a 1" pone el resultado lógico (RLO) actual al estado lógico "1".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/

(VWDGROµJLFR

5HVXOWDGROµJLFR 5/2

6(7

ಯ7DJB2XWSXWBಯ
ಯ7DJB2XWSXWBಯ
ಯ7DJB2XWSXWBಯ







&/5

ಯ7DJB2XWSXWBಯ
ಯ7DJB2XWSXWBಯ






Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

CLR: Poner RLO a 0
Descripción
La instrucción "Poner RLO a 0" pone el resultado lógico (RLO) actual al estado lógico "0".

1598

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/

(VWDGROµJLFR

5HVXOWDGROµJLFR 5/2

6(7

ಯ7DJB2XWSXWBಯ
ಯ7DJB2XWSXWBಯ
ಯ7DJB2XWSXWBಯ







&/5

ಯ7DJB2XWSXWBಯ
ಯ7DJB2XWSXWBಯ






Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

SAVE: Guardar RLO en bit BR
Descripción
La instrucción "Guardar RLO en bit BR" guarda el resultado lógico (RLO) en el resultado binario
(BR). Durante la ejecución, la instrucción transfiere el estado lógico del resultado lógico actual
al bit de estado BR. La instrucción trabaja independientemente de las condiciones y no influye
en ningún otro bit de estado.
Nota
Tras aplicar la instrucción "Guardar RLO en bit BR", el bit BR puede ser modificado
nuevamente por instrucciones posteriores del mismo bloque o de bloques de nivel inferior.
La instrucción "Guardar RLO en bit BR" también se utiliza para controlar el estado de ejecución
de un bloque. Si, p. ej., la instrucción "Guardar RLO en bit BR" se aplica al final de un bloque,
el bit BR se pone al estado lógico del resultado lógico actual del bloque.
El bit BR ayuda a la realización del mecanismo EN/ENO en llamadas de bloques. Encontrará
más información al respecto en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1599

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input"

// Consultar si el estado lógico del operando "Tag_Input" es "1".

SAVE

// Transferir el estado lógico del RLO al bit BR.

BEC

// Si el RLO = "1", finalizar el bloque.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

FN: Consultar flanco de señal descendente del RLO
Descripción
La instrucción "Consultar flanco de señal descendente del RLO" permite detectar si el estado
lógico del resultado lógico (RLO) ha cambiado de "1" a "0". La instrucción compara el estado
lógico actual del RLO con el estado lógico de la consulta anterior, que está guardado en la
marca de flancos <Operando>. Si la instrucción detecta un cambio del RLO de "1" a "0",
significa que hay un flanco de señal descendente.
La figura siguiente muestra el cambio del RLO en caso de flanco de señal descendente y
ascendente:
)ODQFRGHVH³DODVFHQGHQWH

)ODQFRGHVH³DOGHVFHQGHQWH

5/2



7HPSRUL]DGRU

El flanco de señal descendente se consulta cada vez que se ejecuta la instrucción. Si se
detecta un flanco de señal descendente, tras la evaluación del flanco el RLO adopta el estado
lógico "1" durante un ciclo del programa. En todos los demás casos, el estado lógico del RLO
es "0".
Nota
Uso de la dirección de la marca de flancos
La dirección de la marca de flancos no se puede utilizar más de una vez en el programa, puesto
que, de lo contrario, se sobrescribe el bit de marcas. Esto influye negativamente en la
evaluación de flancos, de manera que el resultado deja de ser unívoco. El área de memoria de
la marca de flancos debe estar en un bloque de datos (área 'Static' de FB) o en el área de
marcas.

1600

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar flanco de señal
descendente del RLO":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Output

BOOL

I, Q, M, D, L

Marca de flancos en la que
se almacena el RLO de la
consulta anterior.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/

'LDJUDPDVGHHVWDGRVOµJLFRV

ಯ7DJB,QSXWಯ

ಯ7DJB,QSXWಯ




)1 ಯ7DJB(GJHಯ

ಯ7DJB(GJHಯ




ಯ7DJB2XWSXWಯ




$

ಯ7DJB2XWSXWಯ
1|GHFLFORGHO2%



















Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

FP: Consultar flanco de señal ascendente del RLO
Descripción
La instrucción "Consultar flanco de señal ascendente del RLO" permite detectar si el estado
lógico del resultado lógico (RLO) ha cambiado de "0" a "1". La instrucción compara el estado
lógico actual del RLO con el estado lógico de la consulta anterior, que está guardado en la
marca de flancos <Operando>. Si la instrucción detecta un cambio del RLO de "0" a "1",
significa que hay un flanco de señal ascendente.
La figura siguiente muestra el cambio del RLO en caso de flanco de señal descendente y
ascendente:

Programación del PLC
Manual de programación y manejo, 11/2019

1601

Instrucciones
4.1 Instrucciones
)ODQFRGHVH³DODVFHQGHQWH

)ODQFRGHVH³DOGHVFHQGHQWH

5/2



7HPSRUL]DGRU

El flanco de señal ascendente se consulta cada vez que se ejecuta la instrucción. Si se detecta
un flanco de señal ascendente, tras la evaluación del flanco el RLO adopta el estado lógico "1"
durante un ciclo del programa. En todos los demás casos, el estado lógico del RLO es "0".
Nota
Uso de la dirección de la marca de flancos
La dirección de la marca de flancos no se puede utilizar más de una vez en el programa, puesto
que, de lo contrario, se sobrescribe el bit de marcas. Esto influye negativamente en la
evaluación de flancos, de manera que el resultado deja de ser unívoco. El área de memoria de
la marca de flancos debe estar en un bloque de datos (área 'Static' de FB) o en el área de
marcas.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Consultar flanco de señal
ascendente del RLO":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Output

BOOL

I, Q, M, D, L

Marca de flancos en la que
se almacena el RLO de la
consulta anterior.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
3URJUDPD$:/

ಯ7DJB,QSXWಯ

ಯ7DJB,QSXWಯ




)3 ಯ7DJB(GJHಯ

ಯ7DJB(GJHಯ




ಯ7DJB2XWSXWಯ




$

ಯ7DJB2XWSXWಯ
1|GHFLFORGHO2%

1602

'LDJUDPDVGHHVWDGRVOµJLFRV



















Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplos de programación AWL (Página 8102)
Bases de AWL (Página 8065)

Temporizadores
FR: Habilitar temporizador
Descripción
La instrucción "Habilitar temporizador" provoca el rearranque de un temporizador. La
instrucción se ejecuta con un flanco de señal ascendente y desactiva la marca de flancos
interna para arrancar un temporizador. Al procesar una instrucción para arrancar el
temporizador con un resultado lógico "1", el temporizador arranca de nuevo, aunque no haya
ningún flanco de señal ascendente antes de la instrucción de arranque. Si el resultado lógico
es "0" antes de una instrucción de arranque, la desactivación de la marca de flancos interna no
influye en el temporizador.
Un cambio del resultado lógico a "0" antes de la instrucción "Habilitar temporizador" no tiene
repercusión una vez rearrancado el temporizador.
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
Encontrará un ejemplo de la estructura de una célula de temporización en: Consulte también
"L: Cargar valor del temporizador".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Habilitar temporizador":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Temporiza‐
dor>

Input

TIMER

T

Temporizador que se habilita

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Programación del PLC
Manual de programación y manejo, 11/2019

1603

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_EnableInput"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

FR "MyTimer"

// Habilitar temporizador con un flanco de señal ascendente.

A "Tag_StartInput"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

L S5T#10s

// Cargar tiempo (10 s)

SP "MyTimer"

// Arrancar temporizador como impulso cuando haya un
flanco de señal ascendente en el operando "Tag_StartInput" o en el operando "Tag_EnableInput" y el operando "Tag_StartInput" devuelva el estado lógico "1".

A "Tag_Reset"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

R "MyTimer"

// Si el RLO es "1", inicializar temporizador.

A "MyTimer"

// Consultar si el estado del temporizador es "1".

= "Tag_TimerStatus"

// Asignar el estado del temporizador al operando.

L "MyTimer"

// Cargar el valor actual del temporizador en el acumulador 1.

T "Tag_TimerValue"

// Transferir el valor actual del temporizador al operando "Tag_TimerValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
L: Cargar valor del temporizador (Página 1604)
Bases de AWL (Página 8065)

L: Cargar valor del temporizador
Descripción
La instrucción "Cargar valor del temporizador" carga el valor de un temporizador concreto en
el acumulador 1. El valor del temporizador en código dual se carga sin base de tiempo. En lugar
de la base de tiempo se escriben ceros en el acumulador 1.

1604

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Después de la carga, el valor que está en el acumulador 1 equivale a un número positivo del
tipo de datos INT.
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
La figura siguiente muestra, a modo de ejemplo, cómo se carga en valor del temporizador en
el acumulador:
3DODEUDGH
WHPSRUL]DGRUSDUD
HOWHPSRUL]DGRU7
HQODPHPRULD

&RQWHQLGRGHOD
SDODEUDGHUHFKD
GHO
DFXPXODGRU
GHVSX«VGHOD
LQVWUXFFLµQ /7

   

%DVHGHWLHPSR
 PV
 PV
 V
 V

9DORUGHWLHPSR D 
FRGLILFDGRHQELQDULR
/7

   
7RGRVಯಯ





9DORUGHWLHPSR D FRGLILFDGRHQ
ELQDULR

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Cargar valor del temporizador":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Temporiza‐
dor>

Input

TIMER

T

Temporizador cuyo valor ac‐
tual se carga

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_EnableInput"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

FR "MyTimer"

// Habilitar temporizador con un flanco ascendente.

A "Tag_StartInput"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

Programación del PLC
Manual de programación y manejo, 11/2019

1605

Instrucciones
4.1 Instrucciones
AWL

Explicación

L S5T#10s

// Cargar tiempo (10 s)

SP "MyTimer"

// Arrancar temporizador como impulso cuando haya un
flanco ascendente en el operando "Tag_StartInput" o en
el operando "Tag_EnableInput" y el operando "Tag_StartInput" devuelva el estado lógico "1".

A "Tag_Reset"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

R "MyTimer"

// Si el RLO es "1", inicializar temporizador.

A "MyTimer"

// Consultar si el estado del temporizador es "1".

= "Tag_TimerStatus"

// Asignar el estado del temporizador al operando.

L "MyTimer"

// Cargar el valor actual del temporizador en el acumulador 1.

T "Tag_TimerValue"

// Transferir el valor actual del temporizador al operando "Tag_TimerValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

LC: Cargar valor del temporizador codificado en BCD
Descripción
La instrucción "Cargar valor del temporizador codificado en BCD" carga el valor de un
temporizador concreto en código dual en el acumulador 1 en formato BCD. Durante la carga
también se transfiere la base de tiempo al acumulador 1.
Después de la carga, el valor que está en el acumulador 1 equivale a una duración en formato
S5TIME. La palabra izquierda del acumulador 1 se rellena con ceros.
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
La figura siguiente muestra cómo se carga en valor del temporizador en el acumulador:

1606

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

3DODEUDGHWHPSRUL]
DGRUSDUDHO
WHPSRUL]DGRU7
HQODPHPRULD

   

%DVHGHWLHPSR
 PV
 PV
 V
 V



9DORUGHWLHPSR  
HQFRGLILFDFLµQELQDULD
/&7
%LQDULRHQ%&'

&RQWHQLGRGHOD
SDODEUDGHUHFKDGHO  
DFXPXODGRU
   
GHVSX«VGHOD
LQVWUXFFLµQ
 FHQWHQDV
GHFHQDV
/&7


 XQLGDGHV

9DORUGHWLHPSRHQIRUPDWR%&'

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Cargar valor del temporizador
codificado en BCD":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Temporiza‐
dor>

Input

TIMER

T

Temporizador cuyo valor ac‐
tual se carga codificado en
BCD.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_EnableInput"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

FR "MyTimer"

// Habilitar temporizador con un flanco ascendente.

A "Tag_StartInput"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

L S5T#10s

// Cargar tiempo (10 s)

SP "MyTimer"

// Arrancar temporizador como impulso cuando haya un
flanco ascendente en el operando "Tag_StartInput" o en
el operando "Tag_EnableInput" y el operando "Tag_StartInput" devuelva el estado lógico "1".

A "Tag_Reset"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

R "MyTimer"

// Si el RLO es "1", inicializar temporizador.

A "MyTimer"

// Consultar si el estado del temporizador es "1".

= "Tag_TimerStatus"

// Asignar el estado del temporizador al operando.

Programación del PLC
Manual de programación y manejo, 11/2019

1607

Instrucciones
4.1 Instrucciones
AWL

Explicación

LC "MyTimer"

// Cargar el valor actual del temporizador codificado
en BCD en el acumulador 1.

T "Tag_TimerValue"

// Transferir el valor actual del temporizador al operando "Tag_TimerValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
L: Cargar valor del temporizador (Página 1604)
Bases de AWL (Página 8065)

R: Inicializar temporizador
Descripción
La instrucción "Inicializar temporizador" pone a "0" un temporizador concreto. La instrucción se
ejecuta si el resultado lógico (RLO) actual es "1". Mientras el RLO "1" esté pendiente antes de
la instrucción, el temporizador indicado dará el valor "0". La instrucción también pone a "0" el
valor del temporizador y la base de tiempo de la duración programada.
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
Nota
La instrucción "Inicializar temporizador" no desactiva la marca de flancos interna. Para
desactivar la marca de flancos interna debe programarse la instrucción "Habilitar
temporizador" o ejecutarse una instrucción para arrancar el temporizador con el estado lógico
"0".
Encontrará un ejemplo de la estructura de una célula de temporización en: Consulte también
"L: Cargar valor del temporizador".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Inicializar temporizador":

1608

Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Temporiza‐
dor>

Input

TIMER

T

Temporizador que se iniciali‐
za

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Reset"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

R "MyTimer"

// Si el RLO es "1", inicializar temporizador.

A "MyTimer"

// Consultar si el estado del temporizador es "1".

= "Tag_TimerStatus"

// Asignar el estado del temporizador al operando.

L "MyTimer"

// Cargar el valor actual del temporizador en el acumulador 1.

T "Tag_TimerValue"

// Transferir el valor actual del temporizador al operando "Tag_TimerValue".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
L: Cargar valor del temporizador (Página 1604)
Bases de AWL (Página 8065)

SP: Arrancar temporizador como impulso
Descripción
La instrucción "Arrancar temporizador como impulso" arranca un temporizador concreto con
un flanco de señal ascendente. Cuando se registra un flanco de señal ascendente, la
instrucción se ejecuta y el temporizador arranca. El temporizador termina con la duración que
figura en el acumulador 1, mientras el resultado lógico (RLO) antes de la instrucción siga
siendo "1". Si el RLO cambia a "0" antes de finalizar el temporizador, este se detiene. Las
consultas de si el estado del temporizador es "1" dan como resultado "1" mientras el
temporizador está en marcha.
Es posible rearrancar el temporizador con un flanco de señal ascendente antes de la
instrucción "Arrancar temporizador como impulso" o con la ayuda de la instrucción "Habilitar
temporizador". Para ello, es imprescindible que el temporizador no esté desactivado.
La duración en el acumulador 1 se compone de un valor de tiempo y una base de tiempo. Si
se arranca un temporizador concreto con la instrucción "Arrancar temporizador como impulso",
el valor del temporizador se reduce de acuerdo con la base de tiempo. El temporizador cuenta
el tiempo hasta que el valor de contaje decrementa hasta cero.
En el acumulador 1 debe haber una duración válida en formato S5TIME, aunque al procesar
la instrucción no arranque el temporizador. Si el acumulador 1 no tiene ningún valor BCD válido
y el RLO de la operación lógica precedente devuelve el valor "0", el bit de estado OV se pone

Programación del PLC
Manual de programación y manejo, 11/2019

1609

Instrucciones
4.1 Instrucciones
a "1". No se inicia ningún tratamiento de errores síncrono. Si el acumulador 1 tiene un valor
BCD válido, el bit de estado OV se pone a "0".
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
Encontrará un ejemplo de la estructura de una célula de temporización en: Consulte también
"L: Cargar valor del temporizador".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Arrancar temporizador como
impulso":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Temporiza‐
dor>

Input

TIMER

T

Temporizador que arranca
como impulso.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1610

AWL

Explicación

A "Tag_StartInput"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

L S5T#10s

// Cargar tiempo (10 s)

SP "MyTimer"

// Arrancar temporizador como impulso cuando haya un
flanco de señal ascendente en el operando "Tag_StartInput" o en el operando "Tag_EnableInput" y el operando "Tag_StartInput" devuelva el estado lógico "1".

A "Tag_Reset"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

R "MyTimer"

// Inicializar el temporizador si el RLO es "1" y detener el tiempo.

A "MyTimer"

// Consultar si el estado del temporizador es "1".

= "Tag_TimerStatus"

// Asignar el estado del temporizador al operando.

L "MyTimer"

// Cargar el valor actual del temporizador en el acumulador 1.

T "Tag_TimerValue"

// Transferir el valor actual del temporizador al operando "Tag_TimerValue".

LC "MyTimer"

// Cargar el valor actual del temporizador codificado
en BCD en el acumulador 1.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

T "Tag_TimerValue_BCD"

// Transferir el valor del temporizador codificado en
BCD al operando "Tag_TimerValue_BCD".

La figura siguiente muestra el cronograma del ejemplo:
$UUDQFDU

ಯ7DJB6WDUW,QSXWಯ

'HVDFWLYDU

ಯ7DJB5HVHWಯ

7HPSRUL]DGRU
6DOLGD

W
ಯ7DJB7LPHU6WDWXVಯ

&DUJDUWHPSRUL]DGRU
//&
W WLHPSRSURJUDPDGR

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
L: Cargar valor del temporizador (Página 1604)
Bases de AWL (Página 8065)

SE: Arrancar temporizador como impulso prolongado
Descripción
La instrucción "Arrancar temporizador como impulso prolongado" arranca un temporizador
concreto con un flanco de señal ascendente. Cuando se registra un flanco de señal
ascendente, la instrucción se ejecuta y el temporizador arranca. El temporizador termina con
el tiempo que figura en el acumulador 1, aunque el resultado lógico antes de la instrucción
cambie a "0". Las consultas de si el estado del temporizador es "1" dan como resultado "1"
mientras el temporizador está en marcha.
Con cada flanco de señal ascendente, la instrucción rearranca el temporizador con la duración
programada, aunque este todavía no haya terminado.
La duración en el acumulador 1 se compone de un valor de tiempo y una base de tiempo. Si
se arranca un temporizador concreto con la instrucción "Arrancar temporizador como impulso
prolongado", el valor del temporizador decrementa de acuerdo con la base de tiempo. El
temporizador cuenta el tiempo hasta que el valor de contaje decrementa hasta cero.
En el acumulador 1 debe haber una duración válida en formato S5TIME, aunque al procesar
la instrucción no arranque el temporizador. Si el acumulador 1 no tiene ningún valor BCD válido
y el RLO de la operación lógica precedente devuelve el valor "0", el bit de estado OV se pone

Programación del PLC
Manual de programación y manejo, 11/2019

1611

Instrucciones
4.1 Instrucciones
a "1". No se inicia ningún tratamiento de errores síncrono. Si el acumulador 1 tiene un valor
BCD válido, el bit de estado OV se pone a "0".
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
Encontrará un ejemplo de la estructura de una célula de temporización aquí: L: Cargar valor del
temporizador (Página 1604)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Arrancar temporizador como
impulso prolongado":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Temporiza‐
dor>

Input

TIMER

T

Temporizador que arranca
como impulso prolongado

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1612

AWL

Explicación

A "Tag_StartInput"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

L S5T#10s

// Cargar tiempo (10 s)

SE "MyTimer"

// Arrancar temporizador como impulso prolongado cuando haya un flanco de señal ascendente en el operando
"Tag_StartInput" o en el operando "Tag_EnableInput" y
el operando "Tag_StartInput" devuelva el estado lógico "1".

A "Tag_Reset"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

R "MyTimer"

// Inicializar el temporizador si el RLO es "1" y detener el tiempo.

A "MyTimer"

// Consultar si el estado del temporizador es "1".

= "Tag_TimerStatus"

// Asignar el estado del temporizador al operando

L "MyTimer"

// Cargar el valor actual del temporizador en el acumulador 1.

T "Tag_TimerValue"

// Transferir el valor actual del temporizador al operando "Tag_TimerValue".

LC "MyTimer"

// Cargar el valor actual del temporizador codificado
en BCD en el acumulador 1.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

T "Tag_TimerValue_BCD"

// Transferir el valor del temporizador codificado en
BCD al operando "Tag_TimerValue_BCD".

La figura siguiente muestra el cronograma del ejemplo:
$UUDQFDU

ಯ7DJB6WDUW,QSXWಯ

'HVDFWLYDU

ಯ7DJB5HVHWಯ

7HPSRUL]DGRU
6DOLGD

W
ಯ7DJB7LPHU6WDWXVಯ

&DUJDUWHPSRUL]DGRU
//&
W WLHPSRSURJUDPDGR

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplos de programación AWL (Página 8102)
Bases de AWL (Página 8065)

SD: Arrancar temporizador como retardo a la conexión
Descripción
La instrucción "Arrancar temporizador como retardo a la conexión" arranca un temporizador
programado al detectarse el estado lógico "1" en la entrada de arranque. Mientras se
mantenga el estado lógico "1", el temporizador contará el tiempo indicado en el acumulador 1.
Una vez transcurrido el tiempo y si el estado lógico en la entrada de arranque sigue siendo "1",
la consulta del estado del temporizador también dará como resultado "1". Si la señal de la
entrada de arranque es "0", el temporizador se inicializa. En ese caso, la consulta del estado
del temporizador devuelve el estado lógico "0". En cuanto la señal en la entrada de arranque
vuelve a cambiar a "1", el temporizador vuelve a contar el tiempo.
El estado lógico de la salida del temporizador es idéntico al de la entrada de arranque. La
entrada de arranque está interconectada directamente con la salida y no tiene relación con el
temporizador.
El tiempo en el acumulador 1 se compone internamente de un valor de tiempo y una base de
tiempo. Cuando se inicia la instrucción, el valor de tiempo programado se cuenta hacia atrás
hasta cero.
En el acumulador 1 debe haber una duración válida en formato S5TIME, aunque al procesar
la instrucción no arranque el temporizador. Si el acumulador 1 no tiene ningún valor BCD válido

Programación del PLC
Manual de programación y manejo, 11/2019

1613

Instrucciones
4.1 Instrucciones
y el RLO de la operación lógica precedente devuelve el valor "0", el bit de estado OV se
ajustará a "1". No se inicia ningún tratamiento de errores síncrono. Si el acumulador 1 tiene un
valor BCD válido, el bit de estado OV se ajusta a "0".
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
Encontrará un ejemplo de la estructura de una célula de temporización en: Consulte también
"L: Cargar valor del temporizador".

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Arrancar temporizador como
retardo a la conexión":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Temporiza‐
dor>

Input

TIMER

T

Temporizador que arranca
como retardo a la conexión

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1614

AWL

Explicación

A "Tag_StartInput"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

L S5T#10s

// Cargar tiempo (10 s)

SD "MyTimer"

// Arrancar temporizador como retardo a la conexión
cuando haya un flanco de señal ascendente en el operando "Tag_StartInput" o en el operando "Tag_EnableInput" y el operando "Tag_StartInput" devuelva el estado
lógico "1".

A "Tag_Reset"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

R "MyTimer"

// Inicializar el temporizador si el RLO es "1" y detener el tiempo.

A "MyTimer"

// Consultar si el estado del temporizador es "1"

= "Tag_TimerStatus"

// Asignar el estado del temporizador al operando.

L "MyTimer"

// Cargar el valor actual del temporizador en el acumulador 1.

T "Tag_TimerValue"

// Transferir el valor actual del temporizador al operando "Tag_TimerValue".

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

LC "MyTimer"

// Cargar el valor actual del temporizador codificado
en BCD en el acumulador 1.

T "Tag_TimerValue_BCD"

// Transferir el valor del temporizador codificado en
BCD al operando "Tag_TimerValue_BCD".

La figura siguiente muestra el cronograma del ejemplo:
$UUDQFDU

ಯ7DJB6WDUW,QSXWಯ

'HVDFWLYDU

ಯ7DJB5HVHWಯ

7HPSRUL]DGRU
6DOLGD

W

W

ಯ7DJB7LPHU6WDWXVಯ
W WLHPSRSURJUDPDGR

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
L: Cargar valor del temporizador (Página 1604)
Bases de AWL (Página 8065)

SS: Arrancar temporizador como retardo a la conexión con memoria
Descripción
La instrucción "Arrancar temporizador como retardo a la conexión con memoria" arranca un
temporizador concreto con un flanco de señal ascendente. Cuando se registra un flanco de
señal ascendente, la instrucción se ejecuta y el temporizador arranca. El temporizador termina
con la duración que figura en el acumulador 1, aunque el resultado lógico (RLO) antes de la
instrucción cambie a "0". Cuando el tiempo ha transcurrido, las consultas de si el estado del
temporizador es "1" dan como resultado "1". El estado lógico del resultado lógico actual antes
de la instrucción no influye en el resultado de la consulta.
Con cada flanco ascendente, la instrucción rearranca el temporizador con la duración
programada, aunque este todavía no haya terminado.
La duración en el acumulador 1 se compone de un valor de tiempo y una base de tiempo. Si
se arranca un temporizador concreto con la instrucción "Arrancar temporizador como retardo
a la conexión con memoria", el valor del temporizador se reduce de acuerdo con la base de
tiempo. El temporizador cuenta el tiempo hasta que el valor de contaje decrementa hasta cero.
En el acumulador 1 debe haber una duración válida en formato S5TIME, aunque al procesar
la instrucción no arranque el temporizador. Si el acumulador 1 no tiene ningún valor BCD válido
y el RLO de la operación lógica precedente devuelve el valor "0", el bit de estado OV se pone

Programación del PLC
Manual de programación y manejo, 11/2019

1615

Instrucciones
4.1 Instrucciones
a "1". No se inicia ningún tratamiento de errores síncrono. Si el acumulador 1 tiene un valor
BCD válido, el bit de estado OV se pone a "0".
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
Encontrará un ejemplo de la estructura de una célula de temporización aquí: L: Cargar valor del
temporizador (Página 1604)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Arrancar temporizador como
retardo a la conexión con memoria":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Temporiza‐
dor>

Input

TIMER

T

Temporizador que arranca
como retardo a la conexión
con memoria.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1616

AWL

Explicación

A "Tag_StartInput"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

L S5T#10s

// Cargar tiempo (10 s)

SS "MyTimer"

// Arrancar temporizador como retardo a la conexión
con memoria cuando haya un flanco de señal ascendente
en el operando "Tag_StartInput" o en el operando
"Tag_EnableInput" y el operando "Tag_StartInput" devuelva el estado lógico "1".

A "Tag_Reset"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

R "MyTimer"

// Inicializar el temporizador si el RLO es "1" y detener el tiempo.

A "MyTimer"

// Consultar si el estado del temporizador es "1".

= "Tag_TimerStatus"

// Asignar el estado del temporizador al operando.

L "MyTimer"

// Cargar el valor actual del temporizador en el acumulador 1.

T "Tag_TimerValue"

// Transferir el valor actual del temporizador al operando "Tag_TimerValue".

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

LC "MyTimer"

// Cargar el valor actual del temporizador codificado
en BCD en el acumulador 1.

T "Tag_TimerValue_BCD"

// Transferir el valor del temporizador codificado en
BCD al operando "Tag_TimerValue_BCD".

La figura siguiente muestra el cronograma del ejemplo:
$UUDQFDU

ಯ7DJB6WDUW,QSXWಯ

'HVDFWLYDU

ಯ7DJB5HVHWಯ

7HPSRUL]DGRU
6DOLGD

W
ಯ7DJB7LPHU6WDWXVಯ
W WLHPSRSURJUDPDGR

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

SF: Arrancar temporizador como retardo a la desconexión
Descripción
La instrucción "Arrancar temporizador como retardo a la desconexión" arranca un
temporizador concreto con un flanco de señal descendente. Cuando se registra un flanco de
señal descendente, la instrucción se ejecuta y el temporizador arranca. El temporizador
termina con la duración que figura en el acumulador 1. Si el resultado lógico (RLO) cambia a
"1" antes de finalizar el tiempo, el temporizador se inicializa. El temporizador solo arranca de
nuevo cuando se registra un flanco de señal descendente al ejecutar la instrucción.
Las consultas del estado del temporizador en "1" dan como resultado "1" si el estado del
resultado lógico al ejecutar la instrucción es "1" o si el temporizador programado está en
marcha. Si el temporizador no cuenta o el RLO está a "0", las consultas de si el estado del
temporizador es "1" dan como resultado "0".
La duración en el acumulador 1 se compone de un valor de tiempo y una base de tiempo. Si
se arranca un temporizador concreto con la instrucción "Arrancar temporizador como retardo
a la desconexión", el valor del temporizador decrementa de acuerdo con la base de tiempo. El
temporizador cuenta el tiempo hasta que el valor de contaje decrementa hasta cero.
En el acumulador 1 debe haber una duración válida en formato S5TIME, aunque al procesar
la instrucción no arranque el temporizador. Si el acumulador 1 no tiene ningún valor BCD válido
y el RLO de la operación lógica precedente devuelve el valor "0", el bit de estado OV se pone

Programación del PLC
Manual de programación y manejo, 11/2019

1617

Instrucciones
4.1 Instrucciones
a "1". No se inicia ningún tratamiento de errores síncrono. Si el acumulador 1 tiene un valor
BCD válido, el bit de estado OV se pone a "0".
Nota
En la célula de temporización, el sistema operativo reduce el valor de tiempo en una unidad
respectivamente, y en un intervalo definido por la base de tiempo, hasta que el valor de tiempo
sea "0". La reducción se realiza de modo asíncrono respecto al programa de usuario. De este
modo el tiempo resultante es menor que el valor de tiempo deseado, como máximo hasta un
intervalo de la base de tiempo.
Encontrará un ejemplo de la estructura de una célula de temporización aquí: L: Cargar valor del
temporizador (Página 1604)

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Arrancar temporizador como
retardo a la desconexión":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Temporiza‐
dor>

Input

TIMER

T

Temporizador que arranca
como retardo a la descone‐
xión

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1618

AWL

Explicación

A "Tag_StartInput"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

L S5T#10s

// Cargar tiempo (10 s)

SF "MyTimer"

// Arrancar temporizador como retardo a la desconexión
cuando haya un flanco de señal descendente en el operando "Tag_StartInput" o en el operando "Tag_EnableInput" y el operando "Tag_StartInput" devuelva el estado
lógico "1".

A "Tag_Reset"

// Consultar si el operando es "1" y combinar el resultado lógicamente con Y con el RLO actual.

R "MyTimer"

// Inicializar el temporizador si el RLO es "1" y detener el tiempo.

A "MyTimer"

// Consultar si el estado del temporizador es "1".

= "Tag_TimerStatus"

// Asignar el estado del temporizador al operando.

L "MyTimer"

// Cargar el valor actual del temporizador en el acumulador 1.

T "Tag_TimerValue"

// Transferir el valor actual del temporizador al operando "Tag_TimerValue".

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

LC "MyTimer"

// Cargar el valor actual del temporizador codificado
en BCD en el acumulador 1.

T "Tag_TimerValue_BCD"

// Transferir el valor del temporizador codificado en
BCD al operando "Tag_TimerValue_BCD".

La figura siguiente muestra el diagrama de tiempo del ejemplo.
$UUDQFDU

ಯ7DJB6WDUW,QSXWಯ

'HVDFWLYDU

ಯ7DJB5HVHWಯ

7HPSRUL]DGRU
W
6DOLGD

W

ಯ7DJB7LPHU6WDWXVಯ
W WLHPSRSURJUDPDGR

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

Contadores
FR: Habilitar contador
Descripción
La instrucción "Habilitar contador" ejecuta las instrucciones "Inicializar contador", "Contador
ascendente" y "Contador descendente" sin que exista actualmente un flanco de señal
ascendente. Durante la ejecución, la instrucción pone la marca de flancos interna al estado
lógico "0". La consulta anterior a la instrucción de contaje correspondiente debe seguir
teniendo el estado lógico "1".
La instrucción "Habilitar contador" se ejecuta si el resultado lógico (RLO) cambia de "0" a "1"
antes de la instrucción.
Para ejecutar una instrucción de contaje no es necesario habilitar un contador.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Habilitar contador":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

COUNTER

C

Contador que se habilita.

Programación del PLC
Manual de programación y manejo, 11/2019

1619

Instrucciones
4.1 Instrucciones
Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input_1"

// Consultar si el estado lógico es "1" y combinar el
resultado lógicamente con Y con el RLO actual.

FR "MyCounter"

// Habilitar contador

A "Tag_Input_2"

// Consultar si el estado lógico es "1" y combinar el
resultado lógicamente con Y con el RLO actual.

CD "MyCounter"

// Decrementar contador

A "MyCounter"

// Consultar estado del contador

= "Tag_Output"

// Asignar el resultado de la consulta al operando.

En el ejemplo, el contador "MyCounter" se habilita cuando el estado lógico del operando
"Tag_Input_1" cambia de "0" a "1". Si el operando "Tag_Input_2" tiene el estado lógico "1", el
valor de contaje decrementa en uno al habilitar el contador. Si el estado lógico del operando
"Tag_Input_2" es "0", el valor de contaje no cambia. El valor de contaje también decrementa
en uno, independientemente de la habilitación del contador, cuando el estado lógico del
operando "Tag_Input_2" cambia de "0" a "1".
La consulta del estado del contador da como resultado "1" si el estado del contador es mayor
que cero. Si el estado del contador es igual a cero, el resultado de la consulta es "0".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

L: Cargar valor de contaje
Descripción
La instrucción "Cargar valor de contaje" transfiere el valor actual de un contador concreto a la
palabra derecha del acumulador 1 en código dual. A continuación, el valor de contaje cargado
está disponible como entero de 16 bits para su posterior procesamiento.
La figura siguiente muestra el funcionamiento de la instrucción:

1620

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

3DODEUDGHFRQWDMH
SDUD
FRQWDGRU&GHOD
PHPRULD

   



9DORUGHFRQWDMH D FRGLILFDGRHQ
ELQDULR
/&

&RQWHQLGRGHOD
SDODEUDGHUHFKD
GHO
DFXPXODGRU
GHVSX«VGHOD
LQVWUXFFLµQGH
FDUJD /&

   
7RGRVಯಯ



9DORUGHFRQWDMH D FRGLILFDGRHQ
ELQDULR

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Cargar valor de contaje":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

COUNTER

C

Contador cuyo valor actual
se carga.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "MyCounter"

// Cargar el valor de contaje actual en el acumulador
1 en código binario.

L "Tag_Value"

// Desplazar el valor de contaje al acumulador 2.
// Cargar el valor del operando "Tag_Value" en el acumulador 1.

>=I

// Consulta sobre si el valor de contaje es mayor o
igual al valor del operando "Tag_Value".

= "Tag_Output"

// Asignar el resultado de la consulta al operando.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

Programación del PLC
Manual de programación y manejo, 11/2019

1621

Instrucciones
4.1 Instrucciones

LC: Cargar valor de contaje codificado en BCD
Descripción
La instrucción "Cargar valor de contaje codificado en BCD" transfiere el valor actual de un
contador concreto en formato BCD a la palabra derecha del acumulador 1. Después, el valor
de contaje cargado está disponible en BCD para su posterior procesamiento.
La figura siguiente muestra el funcionamiento de la instrucción "Cargar valor de contaje
codificado en BCD":
3DODEUDGHFRQWDMH
SDUD
FRQWDGRU&HQOD
PHPRULD

   



9DORUGHFRQWDMH D FRGLILFDGRHQ
ELQDULR
/&&

&RQWHQLGRGHOD
SDODEUDGHUHFKDGHO 
DFXPXODGRU
   
GHVSX«VGHOD
LQVWUXFFLµQGHFDUJD
 &HQWHQDV
'HFHQDV
/&&


 8QLGDGHV

9DORUGHFRQWDMHHQ%&'

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Cargar valor de contaje codificado
en BCD":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

COUNTER

C

Contador cuyo valor actual
se carga.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1622

AWL

Explicación

LC "MyCounter"

// Cargar el valor de contaje actual en el acumulador
1 codificado en BCD.

T "Tag_Output"

// Transferir el valor de contaje actual al operando
"Tag_Output" y guardarlo.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

R: Poner contador a 0
Descripción
La instrucción "Poner contador a 0" pone a "0" el valor de contaje actual de un contador
concreto.
La instrucción solo se ejecuta si el resultado lógico (RLO) previo a la instrucción tiene el estado
lógico "1". Mientras el RLO antes de la instrucción "Poner contador a 0" esté a "1", las consultas
de si el estado del contador es "1" darán como resultado "0".
Al poner un contador a 0, la marca de flancos interna para las instrucciones "Inicializar
contador", "Contador ascendente" y "Contador descendente" no se desactiva.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Poner contador a 0":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

COUNTER

C

Contador cuyo valor de con‐
taje se pone a "0".

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input"

// Consultar si el estado lógico es "1" y combinar el
resultado lógicamente con Y con el RLO actual.

R "MyCounter"

// Poner contador a 0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

Programación del PLC
Manual de programación y manejo, 11/2019

1623

Instrucciones
4.1 Instrucciones

S: Inicializar contador
Descripción
La instrucción "Inicializar contador" pone un contador concreto al valor que se encuentra en el
acumulador 1 en el momento de la consulta.
La instrucción "Inicializar contador" se ejecuta solamente cuando el resultado lógico cambia de
"0" a "1" antes de la instrucción. El flanco de señal ascendente también puede obtenerse
mediante la instrucción "Habilitar contador", que pone a "0" la marca de flancos interna.
Para inicializar un contador debe haber un valor de contaje válido en el acumulador 1. Se
consideran valores de contaje válidos los valores codificados en BCD con tres décadas. Sólo
se admiten valores de contaje positivos, la instrucción de contaje no puede procesar valores
negativos. Si el acumulador 1 cuenta con un valor BCD válido, el bit de estado OV tiene el
estado lógico "0". Si no hay ningún valor BCD válido, el bit de estado OV tiene el estado lógico
"1". No se inicia ningún tratamiento de errores síncrono.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Inicializar contador":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

COUNTER

C

Contador que se inicializa.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input"

// Consultar si el estado lógico es "1" y combinar el
resultado lógicamente con Y con el RLO actual.

L "Tag_CountValue"

// Cargar el valor de contaje en el acumulador 1.

S "MyCounter"

// Poner el contador al valor que se encuentra en el
acumulador 1.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

1624

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

CU: Contador ascendente
Descripción
La instrucción "Contador ascendente" incrementa en uno el valor de contaje actual cuando el
resultado lógico (RLO) antes de la instrucción cambie de "0" a "1". En cada flanco de señal
ascendente, el valor de contaje se sigue incrementando hasta alcanzar el límite superior "999".
Una vez alcanzado el valor límite, el RLO antes de la instrucción ya no influye en el valor de
contaje.
Para ejecutar la instrucción "Contador ascendente" se requiere siempre un flanco de señal
ascendente. El flanco de señal ascendente también puede obtenerse mediante la instrucción
"Habilitar contador", que pone a "0" la marca de flancos interna.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Contador ascendente":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

COUNTER

C

Contador cuyo valor de con‐
taje se incrementa en uno
con un flanco ascendente.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input"

// Consultar si el estado lógico es "1" y combinar el
resultado lógicamente con Y con el RLO actual.

CU "MyCounter"

// Incrementar el valor de contaje en uno con un flanco ascendente.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplos de programación AWL (Página 8102)
Bases de AWL (Página 8065)

Programación del PLC
Manual de programación y manejo, 11/2019

1625

Instrucciones
4.1 Instrucciones

CD: Contador descendente
Descripción
La instrucción "Contador descendente" decrementa en uno el valor de contaje actual cuando
el resultado lógico (RLO) antes de la instrucción cambie de "0" a "1". En cada flanco de señal
ascendente, el valor de contaje sigue decrementando hasta alcanzar el límite inferior "0". Una
vez alcanzado el valor límite, el RLO antes de la instrucción ya no influye en el valor de contaje.
No se cuenta con valores negativos.
Para ejecutar la instrucción "Contador descendente" se requiere siempre un flanco de señal
ascendente. El flanco de señal ascendente también puede obtenerse mediante la instrucción
"Habilitar contador", que pone a "0" la marca de flancos interna.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Contador descendente":
Operando

Declaración

Tipo de datos

Área de memoria

Descripción

<Operando>

Input

COUNTER

C

Contador cuyo valor de con‐
taje se decrementa en uno
con un flanco ascendente.

Encontrará más información sobre los tipos de datos válidos en "Consulte también".

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

A "Tag_Input"

// Consultar si el estado lógico es "1" y combinar el
resultado lógicamente con Y con el RLO actual.

CD "MyCounter"

// Decrementar el valor de contaje en uno con un flanco ascendente.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplos de programación AWL (Página 8102)
Bases de AWL (Página 8065)

1626

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Comparación
? I: Comparación de enteros
Descripción
La instrucción "Comparación de enteros" (16 bits) compara el contenido de la palabra derecha
del acumulador 2 con el contenido de la palabra derecha del acumulador 1. Los contenidos de
los acumuladores 1 y 2 se interpretan como enteros de 16 bits (INT). La instrucción ejecuta la
comparación en función de la función de comparación indicada.
Nota
Los tipos de datos sin signo (p. ej. UINT) no se soportan.
La tabla siguiente muestra las funciones de comparación disponibles y su significado:
Función de comparación

Significado

==I

Comparación de igualdad de enteros

<>I

Comparación de desigualdad de enteros

>I

Comparación de superioridad de enteros

<I

Comparación de inferioridad de enteros

>=I

Comparación de superioridad o igualdad de enteros

<=I

Comparación de inferioridad o igualdad de enteros

El resultado de la comparación influye en el resultado lógico (RLO) así como en los bits de
estado CC 1 y CC 0. Si se cumple la condición de la comparación, el RLO se pone al estado
lógico "1". Si no se cumple la condición de la comparación, el RLO se pone a "0".
La tabla siguiente muestra cómo las distintas funciones de comparación influyen en el RLO:
Función de compara‐
ción

RLO si
ACU 2 > ACU 1

RLO si
ACU 2 = ACU 1

RLO si
ACU 2 < ACU 1

==I

0

1

0

<>I

1

0

1

>I

1

0

0

<I

0

0

1

>=I

1

1

0

<=I

0

1

1

La activación de los bits de estado CC 1 y CC 0 depende de la relación de los dos valores que
intervienen en la comparación.
Los contenidos de los acumuladores 1 y 2 no cambian debido a la ejecución de las funciones
de comparación. Tras ejecutar una función de comparación, es posible evaluar el resultado
lógico con funciones de asignación y salto.

Programación del PLC
Manual de programación y manejo, 11/2019

1627

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input_1"

// Cargar el valor del operando "Tag_Input_1" en el
acumulador 1.

L "Tag_Input_2"

// Desplazar el contenido del acumulador 1 (Tag_Input_1) al acumulador 2.
// Cargar el valor del operando "Tag_Input_2" en el
acumulador 1.

>I

// Comparar si el valor del operando "Tag_Input_1" es
mayor que el valor del operando "Tag_Input_2".

= "Tag_Output"

// Asignar el resultado de la comparación al operando
"Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valores

Tag_Input_1

10

10

5

Tag_Input_2

5

10

10

Tag_Output

1

0

0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

? D: Comparación de enteros dobles
Descripción
La instrucción "Comparación de enteros dobles" (32 bits) compara el contenido del
acumulador 2 (ACU 2) con el contenido del acumulador 1 (ACU 1). Los contenidos de los
acumuladores 1 y 2 se interpretan como enteros de 32 bits (DINT). La instrucción ejecuta la
comparación en función de la función de comparación indicada.
Nota
Los tipos de datos sin signo (p. ej. UDINT) no se soportan.
La tabla siguiente muestra las funciones de comparación disponibles y su significado:

1628

Función de comparación

Significado

==D

Comparación de igualdad de enteros dobles

<>D

Comparación de desigualdad de enteros dobles

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Función de comparación

Significado

>D

Comparación de superioridad de enteros dobles

<D

Comparación de inferioridad de enteros dobles

>=D

Comparación de superioridad o igualdad de enteros dobles

<=D

Comparación de inferioridad o igualdad de enteros dobles

El resultado de la comparación influye en el resultado lógico (RLO) así como en los bits de
estado CC 1 y CC 0. Si se cumple la condición de la comparación, el RLO se pone al estado
lógico "1". Si no se cumple la condición de la comparación, el RLO se pone al estado lógico "0".
La tabla siguiente muestra cómo las distintas funciones de comparación influyen en el RLO:
Función de compara‐
ción

RLO si
ACU 2 > ACU 1

RLO si
ACU 2 = ACU 1

RLO si
ACU 2 < ACU 1

==D

0

1

0

<>D

1

0

1

>D

1

0

0

<D

0

0

1

>=D

1

1

0

<=D

0

1

1

La activación de los bits de estado CC 1 y CC 0 depende de la relación de los dos valores que
intervienen en la comparación.
Los contenidos de los acumuladores 1 y 2 no cambian debido a la ejecución de las funciones
de comparación. Tras ejecutar una función de comparación, es posible evaluar el resultado
lógico con funciones de asignación y salto.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input_1"

// Cargar el valor del operando "Tag_Input_1" en el
acumulador 1.

L "Tag_Input_2"

// Desplazar el contenido del acumulador 1 (Tag_Input_1) al acumulador 2.
// Cargar el valor del operando "Tag_Input_2" en el
acumulador 1.

>D

// Comparar si el valor del operando "Tag_Input_1" es
mayor que el valor del operando "Tag_Input_2".

= "Tag_Output"

// Asignar el resultado de la comparación al operando
"Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valores

Tag_Input_1

150 000

150 000

100 000

Tag_Input_2

100 000

150 000

150 000

Tag_Output

1

0

0

Programación del PLC
Manual de programación y manejo, 11/2019

1629

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

? R: Comparación de números en coma flotante
Descripción
La instrucción "Comparación de números en coma flotante" compara el contenido del
acumulador 2 (ACU 2) con el contenido del acumulador 1 (ACU 1). Los contenidos de los
acumuladores 1 y 2 se interpretan como números en coma flotante. Para ejecutar la
comparación debe haber números en coma flotante válidos en los acumuladores 1 y 2. La
instrucción ejecuta la comparación en función de la función de comparación indicada.
La tabla siguiente muestra las funciones de comparación disponibles y su significado:
Función de comparación

Significado

==R

Comparación de igualdad de números en coma flotante

<>R

Comparación de desigualdad de números en coma flotante

>R

Comparación de superioridad de números en coma flotante

<R

Comparación de inferioridad de números en coma flotante

>=R

Comparación de superioridad o igualdad de números en coma flotante

<=R

Comparación de inferioridad o igualdad de números en coma flotante

El resultado de la comparación influye en el resultado lógico (RLO) así como en los bits de
estado CC 1 y CC 0. Si se cumple la condición de la comparación, el RLO se pone al estado
lógico "1". Si no se cumple la condición de la comparación, el RLO se pone al estado lógico "0".
La tabla siguiente muestra cómo las distintas funciones de comparación influyen en el RLO:
Función de compara‐
ción

RLO si
ACU 2 > ACU 1

RLO si
ACU 2 = ACU 1

RLO si
ACU 2 < ACU 1

==R

0

1

0

<>R

1

0

1

>R

1

0

0

<R

0

0

1

>=R

1

1

0

<=R

0

1

1

La activación de los bits de estado CC 1 y CC 0 depende de la relación de los dos valores que
intervienen en la comparación.
Nota
Si se comparan números en coma flotante no válidos, la CPU pone el resultado lógico a "0" y
los bits de estado CC 0, CC 1, OV y OS a "1".

1630

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Los contenidos de los acumuladores 1 y 2 no cambian debido a la ejecución de las funciones
de comparación. Tras ejecutar una función de comparación, es posible evaluar el resultado
lógico con funciones de asignación y salto.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Input_1"

// Cargar el valor del operando "Tag_Input_1" en el
acumulador 1.

L "Tag_Input_2"

// Desplazar el contenido del acumulador 1 (Tag_Input_1) al acumulador 2.
// Cargar el valor del operando "Tag_Input_2" en el
acumulador 1.

>R

// Comparar si el valor del operando "Tag_Input_1" es
mayor que el valor del operando "Tag_Input_2".

= "Tag_Output"

// Asignar el resultado de la comparación al operando
"Tag_Output".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valores

Tag_Input_1

10 515

10 515

5 232

Tag_Input_2

5 232

10 515

10 515

Tag_Output

1

0

0

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

Funciones matemáticas
Enteros
+I: Sumar enteros (16 bits)
Descripción
La instrucción "Sumar enteros (16 bits)" suma los valores que se encuentran en las palabras
derechas de los acumuladores 1 y 2. La instrucción interpreta dichos valores como enteros de
16 bits.

Programación del PLC
Manual de programación y manejo, 11/2019

1631

Instrucciones
4.1 Instrucciones
La instrucción guarda la suma en la palabra derecha del acumulador 1. La palabra izquierda
del acumulador 1 no cambia.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si la suma es negativa, cero
o positiva. Si el resultado está fuera del rango numérico admisible, los bits de estado OV y OS
se ponen a "1".
El contenido del acumulador 2 no cambia después de ejecutar la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el primer sumando.

L "Tag_Value_2"

// Cargar el segundo sumando.

+I

// Sumar valores

T "Tag_Result"

// Transferir la suma al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplos de programación AWL (Página 8102)
Bases de AWL (Página 8065)

-I: Restar enteros (16 bits)
Descripción
La instrucción "Restar enteros (16 bits)" resta el valor de la palabra derecha del acumulador 1
del valor de la palabra derecha del acumulador 2. La instrucción interpreta los valores de los
acumuladores 1 y 2 como enteros de 16 bits.
La instrucción guarda la diferencia en la palabra derecha del acumulador 1. La palabra
izquierda del acumulador 1 no cambia.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si la diferencia es negativa,
cero o positiva. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
El contenido del acumulador 2 no cambia después de ejecutar la instrucción.

1632

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el primer valor de la resta en el acumulador
1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el segundo valor de la suma en el acumulador
1.

-I

// Restar el valor del acumulador 1 del valor del acumulador 2.

T "Tag_Result"

// Transferir la diferencia al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplos de programación AWL (Página 8102)
Bases de AWL (Página 8065)

*I: Multiplicar enteros (16 bits)
Descripción
La instrucción "Multiplicar enteros (16 bits)" multiplica los valores que se encuentran en las
palabras derechas de los acumuladores 1 y 2. La instrucción interpreta dichos valores como
enteros de 16 bits.
La instrucción guarda el producto en el acumulador 1 como entero de 32 bits (DINT).
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el producto es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
El contenido del acumulador 2 no cambia después de ejecutar la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el multiplicando.

L "Tag_Value_2"

// Cargar el multiplicador.

*I

// Multiplicar valores

T "Tag_Result"

// Transferir el producto al operando "Tag_Result".

Programación del PLC
Manual de programación y manejo, 11/2019

1633

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplos de programación AWL (Página 8102)
Bases de AWL (Página 8065)

/I: Dividir enteros (16 bits)
Descripción
La instrucción "Dividir enteros (16 bits)" divide el valor de la palabra derecha del acumulador
2 por el valor de la palabra derecha del acumulador 1. La instrucción interpreta los valores de
los acumuladores como enteros de 16 bits.
La instrucción da dos resultados: el cociente y el resto de la división. El cociente es el resultado
entero de la división. La instrucción lo guarda en la palabra derecha del acumulador 1. El resto
de la división lo guarda en la palabra izquierda del acumulador 1. Si el dividendo es negativo,
el resto de la división también lo será.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el cociente es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
En caso de dividir entre cero, la instrucción da cero tanto para el cociente como para el resto.
En este caso, los bits de estado CC 0, CC 1, OV y OS se ponen al estado lógico "1".
El contenido del acumulador 2 no cambia después de ejecutar la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el dividendo en el acumulador 1.

L "Tag_Value_2"

// Desplazar el dividendo al acumulador 2.
// Cargar el divisor en el acumulador 1.

/I

// Dividir el valor del acumulador 2 entre el valor
del acumulador 1.

T "Tag_Result"

// Transferir el resultado al operando "Tag_Result".

Antes de la ejecución
La tabla siguiente muestra los contenidos de las palabras derechas de los acumuladores 1 y
2 antes de ejecutar la instrucción "Dividir enteros (16 bits)":

1634

Acumulador

Valor

Acumulador 2

13

Acumulador 1

4

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Después de la ejecución
La tabla siguiente muestra el contenido del acumulador 1 después de ejecutar la instrucción
"Dividir enteros (16 bits)":
Acumulador 1

Valor

Bits 0 a 15
(palabra derecha)

3

Bits 16 a 31
(palabra izquierda)

1

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Ejemplos de programación AWL (Página 8102)
Bases de AWL (Página 8065)

+D: Sumar enteros dobles (32 bits)
Descripción
La instrucción "Sumar enteros dobles (32 bits)" suma los valores que se encuentran en los
acumuladores 1 y 2. La instrucción interpreta dichos valores como enteros de 32 bits. La
instrucción guarda la suma en el acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si la suma es negativa, cero
o positiva. Si el resultado está fuera del rango numérico admisible, los bits de estado OV y OS
se ponen a "1".
El contenido del acumulador 2 no cambia después de ejecutar la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el primer sumando.

L "Tag_Value_2"

// Cargar el segundo sumando.

+D

// Sumar valores

T "Tag_Result"

// Transferir la suma al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

Programación del PLC
Manual de programación y manejo, 11/2019

1635

Instrucciones
4.1 Instrucciones

-D: Restar enteros dobles (32 bits)
Descripción
La instrucción "Restar enteros dobles (32 bits)" resta el valor del acumulador 1 del valor del
acumulador 2. La instrucción interpreta los valores de los acumuladores 1 y 2 como enteros
dobles (32 bits). La instrucción guarda el resultado de la resta en el acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si la diferencia es negativa,
cero o positiva. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
El contenido del acumulador 2 no cambia después de ejecutar la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el primer valor de la resta en el acumulador
1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el segundo valor de la resta en el acumulador 1.

-D

// Restar el valor del acumulador 1 del valor del acumulador 2.

T "Tag_Result"

// Transferir la diferencia al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

*D: Multiplicar enteros dobles (32 bits)
Descripción
La instrucción "Multiplicar enteros dobles (32 bits)" multiplica los valores que se encuentran en
los acumuladores 1 y 2. La instrucción interpreta dichos valores como enteros de 32 bits. La
instrucción guarda el producto en el acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el producto es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
El contenido del acumulador 2 no cambia después de ejecutar la instrucción.

1636

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el multiplicando.

L "Tag_Value_2"

// Cargar el multiplicador.

*D

// Multiplicar valores

T "Tag_Result"

// Transferir el producto al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

/D: Dividir enteros dobles (32 bits)
Descripción
La instrucción "Dividir enteros dobles (32 bits)" divide el valor del acumulador 2 por el valor del
acumulador 1. La instrucción interpreta los valores de los acumuladores 1 y 2 como enteros
dobles (32 bits). La instrucción guarda el resultado entero de la división (cociente) en el
acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el cociente es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
En caso de dividir entre cero, la instrucción da cero para el cociente. En este caso, los bits de
estado CC 0, CC 1, OV y OS se ponen al estado lógico "1".
El contenido del acumulador 2 no cambia después de ejecutar la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el dividendo en el acumulador 1.

L "Tag_Value_2"

// Desplazar el dividendo al acumulador 2.
// Cargar el divisor en el acumulador 1.

/D

// Dividir el valor del acumulador 2 entre el valor
del acumulador 1.

T "Tag_Result"

// Transferir el cociente al operando "Tag_Result".

Programación del PLC
Manual de programación y manejo, 11/2019

1637

Instrucciones
4.1 Instrucciones

Antes de la ejecución
La tabla siguiente muestra los contenidos de los acumuladores 1 y 2 antes de ejecutar la
instrucción "Dividir enteros dobles (32 bits)":
Acumulador

Valor

Acumulador 2

13

Acumulador 1

4

Después de la ejecución
La tabla siguiente muestra el contenido del acumulador 1 después de ejecutar la instrucción
"Dividir enteros dobles (32 bits)":
Acumulador

Valor

Acumulador 1

3

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

+: Sumar constantes
Descripción
La instrucción "Sumar constantes" suma el valor de una constante concreta al contenido del
acumulador 1. El valor de la constante puede indicarse como entero (16 bits) o entero doble (32
bits). La instrucción guarda el resultado en el acumulador 1. Cuando se suman enteros de 16
bits, la instrucción influye solo en la palabra derecha del acumulador 1.
Para ejecutar la suma de un entero de 16 bits como operación DINT, antes de la constante hay
que introducir "L#". La instrucción "Sumar constantes" utiliza números negativos.
La instrucción no influye en los bits de estado.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Sumar constantes":

1638

Parámetro

Tipo de datos Descripción

<Constante>

INT, DINT

Constante que se suma.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1".

+ 25

// Aumentar en 25 el valor del acumulador 1.

T "Tag_Result_1"

// Transferir el contenido del acumulador 1 al operando "Tag_Result_1".

L "Tag_Value_2"

// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en el
acumulador 1.

+ -100

// Reducir en 100 el valor del acumulador 1.

<I

// Consultar si el valor del acumulador 2 es menor que
el valor del acumulador 1.

JC NEXT

// Si el resultado de la consulta es "1", saltar a la
etiqueta NEXT.
// Si el resultado de la consulta es "0", procesar la
instrucción siguiente.

T "Tag_Result_2"

Transferir el contenido del acumulador 1 al operando
"Tag_Result_2".

L "Tag_Value_4"

// Cargar el valor del operando "Tag_Value_4".

+ L#20

// Incrementar en 20 el contenido del acumulador 1.
// La suma se efectúa conforme a un cálculo DINT

T "Tag_Result_3"

// Transferir el contenido del acumulador 1 al operando "Tag_Result_3".

NEXT: L "Tag_Value_5"

// Etiqueta "NEXT"
// Cargar el valor del operando "Tag_Value_5".

+D

// Sumar los valores de los acumuladores 1 y 2.

T "Tag_Result_4"

// Transferir la suma al operando "Tag_Result_4".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

Programación del PLC
Manual de programación y manejo, 11/2019

1639

Instrucciones
4.1 Instrucciones

INC: Incrementar
Descripción
La instrucción "Incrementar" aumenta el valor que se encuentra en el acumulador 1 en el valor
que se indica como parámetro de la instrucción. El valor indicado puede estar comprendido en
un rango de valores de 0 a 255. El incremento solo se realiza en el byte derecho del
acumulador 1. No se lleva a cabo ningún traslado a los bytes que están a la izquierda.
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.
El contenido del acumulador 2 no cambia.
Si el valor del parámetro está fuera del rango de valores, el resultado quedará falsificado o bien
se generará un mensaje de error.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Incrementar":
Parámetro

Formato

Descripción

<Constante>

Entero de 8 bits

Valor que se aumenta.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value"

// Cargar el valor del operando en el acumulador 1.

INC 5

// Aumentar en 5 el valor del acumulador 1.

T "Tag_Result"

// Transferir el contenido del acumulador 1 al operando.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

DEC: Decrementar
Descripción
La instrucción "Decrementar" reduce el valor que se encuentra en el acumulador 1 en el valor
que se indica como parámetro de la instrucción. El valor indicado puede estar comprendido en
un rango de valores de 0 a 255. El valor solo se reduce en el byte derecho del acumulador 1.
No se lleva a cabo ningún traslado a los bytes que están a la izquierda.

1640

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.
El contenido del acumulador 2 no cambia.
Si el valor del parámetro está fuera del rango de valores, el resultado quedará falsificado o bien
se generará un mensaje de error.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Decrementar":
Parámetro

Formato

Descripción

<Constante>

Entero de 8 bits

Valor que se decrementa.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value"

// Cargar el valor del operando en el acumulador 1.

DEC 5

// Decrementar en 5 el valor del acumulador 1.

T "Tag_Result"

// Transferir el contenido del acumulador 1 al operando.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

MOD: Obtener resto de división
Descripción
La instrucción "Obtener resto de división" divide el valor del acumulador 2 entre el valor del
acumulador 1 y guardar el resto de la división.
La instrucción interpreta los valores de los acumuladores 1 y 2 como enteros de 32 bits. La
instrucción guarda el resto de la división en el acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el resto de la división es
negativo, cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de
estado OV y OS se ponen a "1".
En caso de dividir entre cero, la instrucción da cero para el resultado. En este caso, los bits de
estado CC 0, CC 1, OV y OS se ponen al estado lógico "1".
El contenido del acumulador 2 no cambia después de ejecutar la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

1641

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el dividendo en el acumulador 1.

L "Tag_Value_2"

// Desplazar el dividendo al acumulador 2.
// Cargar el divisor en el acumulador 1.

MOD

// Dividir el valor del acumulador 2 entre el valor
del acumulador 1.

T "Tag_Result"

// Transferir el resto de la división al operando
"Tag_Result".

Antes de la ejecución
La tabla siguiente muestra los contenidos de los acumuladores 1 y 2 antes de ejecutar la
instrucción "Obtener resto de división":
Acumulador

Valor

Acumulador 2

13

Acumulador 1

4

Después de la ejecución
La tabla siguiente muestra el contenido del acumulador 1 después de ejecutar la instrucción
"Obtener resto de división":
Acumulador

Valor

Acumulador 1

1

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

Números en coma flotante
+R: Sumar números en coma flotante
Descripción
La instrucción "Sumar números en coma flotante" suma los valores que se encuentran en los
acumuladores 1 y 2. La instrucción interpreta dichos valores como números en coma flotante.
La instrucción guarda la suma en el acumulador 1.

1642

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si la suma es negativa, cero
o positiva. Si el resultado está fuera del rango numérico admisible, los bits de estado OV y OS
se ponen a "1".
Si se introduce un número en coma flotante no válido o el carácter de infinito (+/- ∞), la
instrucción escribe un valor no válido en el acumulador 1 y pone los bits de estado CC 0, CC
1, OV y OS a "1".
El contenido del acumulador 2 no cambia después de ejecutar la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el primer sumando.

L "Tag_Value_2"

// Cargar el segundo sumando.

+R

// Sumar valores

T "Tag_Result"

// Transferir la suma al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

-R: Restar números en coma flotante
Descripción
La instrucción "Restar números en coma flotante" resta el valor del acumulador 1 del valor del
acumulador 2. La instrucción interpreta los valores de los acumuladores 1 y 2 como números
en coma flotante. La instrucción guarda la diferencia en el acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si la diferencia es negativa,
cero o positiva. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
Si se introduce un número en coma flotante no válido o el carácter de infinito (+/- ∞), la
instrucción escribe un valor no válido en el acumulador 1 y pone los bits de estado CC 0, CC
1, OV y OS a "1".
El contenido del acumulador 2 no cambia después de ejecutar la instrucción.

Programación del PLC
Manual de programación y manejo, 11/2019

1643

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el primer valor de la resta en el acumulador
1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el segundo valor de la resta en el acumulador 1.

-R

// Restar el valor del acumulador 1 del valor del acumulador 2.

T "Tag_Result"

// Transferir la diferencia al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

*R: Multiplicar números en coma flotante
Descripción
La instrucción "Multiplicar números en coma flotante" multiplica los valores que se encuentran
en los acumuladores 1 y 2. La instrucción interpreta dichos valores como números en coma
flotante. La instrucción guarda el producto en el acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el producto es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
Si se introduce un número en coma flotante no válido o el carácter de infinito (+/- ∞), la
instrucción escribe un valor no válido en el acumulador 1 y pone los bits de estado CC 0, CC
1, OV y OS a "1".
El contenido del acumulador 2 no cambia después de ejecutar la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1644

AWL

Explicación

L "Tag_Value_1"

// Cargar el multiplicando.

L "Tag_Value_2"

// Cargar el multiplicador.

*R

// Multiplicar valores

T "Tag_Result"

// Transferir el producto al operando "Tag_Result".

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

/R: Dividir números en coma flotante
Descripción
La instrucción "Dividir números en coma flotante" divide el valor del acumulador 2 por el valor
del acumulador 1. La instrucción interpreta los valores de los acumuladores 1 y 2 como
números en coma flotante. La instrucción guarda el resultado entero de la división (cociente)
en el acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el cociente es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
En caso de dividir entre cero, la instrucción da cero para el cociente. En este caso, los bits de
estado CC 0, CC 1, OV y OS se ponen al estado lógico "1".
Si se introduce un número en coma flotante no válido o el carácter de infinito (+/- ∞), la
instrucción escribe un valor no válido en el acumulador 1 y pone los bits de estado CC 0, CC
1, OV y OS a "1".
El contenido del acumulador 2 no cambia después de ejecutar la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el dividendo en el acumulador 1.

L "Tag_Value_2"

// Desplazar el dividendo al acumulador 2.
// Cargar el divisor en el acumulador 1.

/R

// Dividir el valor del acumulador 2 entre el valor
del acumulador 1.

T "Tag_Result"

// Transferir el cociente al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

Programación del PLC
Manual de programación y manejo, 11/2019

1645

Instrucciones
4.1 Instrucciones

ABS: Calcular valor absoluto
Descripción
La instrucción "Calcular valor absoluto" calcula el valor absoluto del valor que se encuentra en
el acumulador 1. La instrucción interpreta el contenido del acumulador 1 como número en
coma flotante y pone el signo de la mantisa a "0". El resultado se guarda en el acumulador 1.
La instrucción "Calcular valor absoluto" no influye en los bits de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value"

// Cargar el número en coma flotante en el acumulador
1.

ABS

// Calcular el valor absoluto

T "Tag_Result"

// Transferir el resultado al operando "Tag_Result".

La tabla siguiente muestra el funcionamiento de la instrucción con valores de operandos
concretos:
Operando

Valor

Tag_Value

-1.5E+02

Tag_Result

1.5E+02

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

Números en coma flotante, avanzado
SQR: Calcular cuadrado
Descripción
La instrucción "Calcular cuadrado" calcula el cuadrado de un número en coma flotante que se
encuentra en el acumulador 1. El resultado se guarda en el acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el resultado es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
Si los números en coma flotante no son válidos, la instrucción pone los bits de estado CC 0, CC
1, OV y OS a "1".

1646

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
La instrucción solo influye en el contenido del acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

SQR

// Calcular el cuadrado
// Guardar el resultado en el acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

*R

// Multiplicar los valores de los acumuladores 1 y 2.
// Guardar el producto en el acumulador 1.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

SQRT: Calcular raíz cuadrada
Descripción
La instrucción "Calcular raíz cuadrada" calcula la raíz cuadrada del número en coma flotante
que se encuentra en el acumulador 1. El resultado se guarda en el acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el resultado es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
Si en el acumulador 1 se introduce un valor inferior a cero o un número en coma flotante no
válido, la instrucción escribe un valor no válido en el acumulador 1 y pone los bits de estado CC
0, CC 1, OV y OS a "1".
Si en el acumulador 1 se encuentra el valor "0", la instrucción devuelve el valor "0".
La instrucción solo influye en el contenido del acumulador 1. El contenido del acumulador 2 no
cambia.

Programación del PLC
Manual de programación y manejo, 11/2019

1647

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

+R

// Sumar los valores de los acumuladores 1 y 2.
// Guardar la suma en el acumulador 1.

SQRT

// Calcular la raíz cuadrada

T "Tag_Result"

// Transferir el resultado (contenido del acumulador
1) al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

EXP: Calcular valor exponencial
Descripción
La instrucción "Calcular valor exponencial" calcula la potencia en base e (e = 2.718282) del
número en coma flotante que se encuentra en el acumulador 1. La instrucción guarda el
resultado en el acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el resultado es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
Si los números en coma flotante no son válidos, la instrucción pone los bits de estado CC 0, CC
1, OV y OS a "1".
La instrucción solo influye en el contenido del acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:

1648

AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

EXP

// Calcular el valor exponencial
// Guardar el resultado en el acumulador 1.

T "Tag_Result"

// Transferir el resultado (contenido del acumulador
1) al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

LN: Calcular logaritmo natural
Descripción
La instrucción "Calcular logaritmo natural" calcula el logaritmo natural en base e (e = 2.718282)
a partir del número en coma flotante que se encuentra en el acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el resultado es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
Si en el acumulador 1 hay un valor inferior o igual a cero, la instrucción escribe un valor no
válido en el acumulador 1 y pone los bits de estado CC 0, CC 1, OV y OS a "1". Si los números
en coma flotante no son válidos, la instrucción pone los bits de estado CC 0, CC 1, OV y OS
también a "1".
La instrucción solo influye en el contenido del acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

LN

// Calcular el logaritmo natural.
// Guardar el resultado en el acumulador 1.

T "Tag_Result"

// Transferir el resultado (contenido del acumulador
1) al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)
Programación del PLC
Manual de programación y manejo, 11/2019

1649

Instrucciones
4.1 Instrucciones

SIN: Calcular valor de seno
Descripción
La instrucción "Calcular valor de seno" calcula el seno del ángulo que se encuentra en el
acumulador 1. El ángulo debe indicarse en radianes y encontrarse en el acumulador 1 en forma
de número en coma flotante. La instrucción guarda el resultado en el acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el resultado es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1". Si los números en coma flotante no son válidos, la instrucción pone los
bits de estado CC 0, CC 1, OV y OS a "1".
La instrucción solo influye en el contenido del acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

SIN

// Calcular el seno
// Guardar el resultado en el acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

*R

// Multiplicar los valores de los acumuladores 1 y 2.
// Guardar el producto en el acumulador 1.

T "Tag_Result"

// Transferir el resultado (contenido del acumulador
1) al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

ASIN: Calcular valor de arcoseno
Descripción
La instrucción "Calcular valor de arcoseno" calcula, a partir del valor que se encuentra en el
acumulador 1, el tamaño del ángulo que corresponde a dicho valor. El valor del acumulador 1
debe encontrarse en forma de número en coma flotante en un rango de valores de "-1" a "1".

1650

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
El resultado de la instrucción se devuelve en radianes y se guarda en el acumulador 1. Según
sea el valor del acumulador 1, el resultado puede encontrarse en un rango de valores de -π/2
a +π/2 (π = 3,14159).
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el resultado es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
Si el valor que está en el acumulador 1 rebasa por exceso el rango admisible, la instrucción
escribe un número en coma flotante no válido en el acumulador 1 y pone los bits de estado CC
0, CC 1, OV y OS a "1". Si los números en coma flotante no son válidos, la instrucción pone los
bits de estado CC 0, CC 1, OV y OS también a "1".
La instrucción solo influye en el contenido del acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

ASIN

// Calcular el arcoseno
// Guardar el resultado en el acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

*R

// Multiplicar los valores de los acumuladores 1 y 2.
// Guardar el producto en el acumulador 1.

T "Tag_Result"

// Transferir el resultado (contenido del acumulador
1) al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

COS: Calcular valor de coseno
Descripción
La instrucción "Calcular valor de coseno" calcula el coseno del ángulo que se encuentra en el
acumulador 1. El tamaño del ángulo debe indicarse en radianes y encontrarse en el
acumulador 1 en forma de número en coma flotante. La instrucción guarda el resultado en el
acumulador 1.

Programación del PLC
Manual de programación y manejo, 11/2019

1651

Instrucciones
4.1 Instrucciones
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el resultado es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1". Si los números en coma flotante no son válidos, la instrucción pone los
bits de estado CC 0, CC 1, OV y OS a "1".
La instrucción solo influye en el contenido del acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

COS

// Calcular el coseno
// Guardar el resultado en el acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

*R

// Multiplicar los valores de los acumuladores 1 y 2.
// Guardar el producto en el acumulador 1.

T "Tag_Result"

// Transferir el resultado (contenido del acumulador
1) al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

ACOS: Calcular valor de arcocoseno
Descripción
La instrucción "Calcular valor de arcocoseno" calcula, a partir del valor que se encuentra en el
acumulador 1, el tamaño del ángulo que corresponde a dicho valor. El valor del acumulador 1
debe encontrarse en forma de número en coma flotante en un rango de valores de "-1" a "1".
El resultado de la instrucción se devuelve en radianes y se guarda en el acumulador 1. Según
sea el valor del acumulador 1, el resultado puede encontrarse en un rango de valores de "0"
a "π" (π = 3,14159).
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el resultado es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
Si el valor que está en el acumulador 1 rebasa por exceso el rango admisible, la instrucción
escribe un número en coma flotante no válido en el acumulador 1 y pone los bits de estado CC

1652

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
0, CC 1, OV y OS a "1". Si los números en coma flotante no son válidos, la instrucción pone los
bits de estado CC 0, CC 1, OV y OS también a "1".
La instrucción solo influye en el contenido del acumulador 1. El contenido del acumulador 2 no
cambia.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

ACOS

// Calcular el arcocoseno
// Guardar el resultado en el acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

*R

// Multiplicar los valores de los acumuladores 1 y 2.
// Guardar el producto en el acumulador 1.

T "Tag_Result"

// Transferir el resultado (contenido del acumulador
1) al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

TAN: Calcular valor de tangente
Descripción
La instrucción "Calcular valor de tangente" calcula la tangente del ángulo que se encuentra en
el acumulador 1. El tamaño del ángulo debe indicarse en radianes y encontrarse en el
acumulador 1 en forma de número en coma flotante. La instrucción guarda el resultado en el
acumulador 1.
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el resultado es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1". Si los números en coma flotante no son válidos, la instrucción pone los
bits de estado CC 0, CC 1, OV y OS a "1".
La instrucción solo influye en el contenido del acumulador 1. El contenido del acumulador 2 no
cambia.

Programación del PLC
Manual de programación y manejo, 11/2019

1653

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

TAN

// Calcular la tangente
// Guardar el resultado en el acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

*R

// Multiplicar los valores de los acumuladores 1 y 2.
// Guardar el producto en el acumulador 1.

T "Tag_Result"

// Transferir el resultado (contenido del acumulador
1) al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

ATAN: Calcular valor de arcotangente
Descripción
La instrucción "Calcular valor de arcotangente" calcula, a partir del valor que se encuentra en
el acumulador 1, el tamaño del ángulo que corresponde a dicho valor. El valor del acumulador
1 debe encontrarse en forma de número en coma flotante.
El resultado de la instrucción se devuelve en radianes y se guarda en el acumulador 1. Según
sea el valor del acumulador 1, el resultado puede encontrarse en un rango de valores de -π/2
a +π/2 (π = 3,14159).
Tras ejecutar la instrucción, los bits de estado CC 0 y CC 1 indican si el resultado es negativo,
cero o positivo. Si el resultado está fuera del rango numérico admisible, los bits de estado OV
y OS se ponen a "1".
Si el valor que está en el acumulador 1 rebasa por exceso el rango admisible, la instrucción
escribe un número en coma flotante no válido en el acumulador 1 y pone los bits de estado CC
0, CC 1, OV y OS a "1". Si los números en coma flotante no son válidos, la instrucción pone los
bits de estado CC 0, CC 1, OV y OS también a "1".
La instrucción solo influye en el contenido del acumulador 1. El contenido del acumulador 2 no
cambia.

1654

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

ATAN

// Calcular la arcotangente
// Guardar el resultado en el acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

*R

// Multiplicar los valores de los acumuladores 1 y 2.
// Guardar el producto en el acumulador 1.

T "Tag_Result"

// Transferir el resultado (contenido del acumulador
1) al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Bases de AWL (Página 8065)

Carga y transferencia
Cargar
L: Cargar
Descripción
La instrucción "Cargar" carga el contenido de un operando concreto en el acumulador 1. El
operando que debe cargarse puede estar direccionado en una de las áreas de memoria
siguientes en forma de byte, palabra o palabra doble:
● Memoria imagen de proceso de las entradas y salidas (I, Q)
● Marcas (M)
● Datos locales temporales (L)
● Bloques de datos (DB, DI)
● Punteros
● Periferia (P)
● Temporizador (T)
● Contador (C)

Programación del PLC
Manual de programación y manejo, 11/2019

1655

Instrucciones
4.1 Instrucciones
El área de memoria del acumulador 1 está organizada por bytes y tiene 32 bits de ancho.
La instrucción escribe el contenido de un operando que se cargará en formato de byte alineado
a la derecha en el acumulador 1. Los bytes restantes del acumulador 1 se rellenan con "0".
La instrucción escribe el contenido de un operando que se cargará en formato de palabra en
la palabra derecha del acumulador 1. El byte con un direccionamiento más alto se transfiere al
byte derecho (bits 0 a 7) del acumulador 1. El byte con un direccionamiento más bajo se
escribe a su izquierda. Los bytes restantes de la palabra izquierda del acumulador 1 se
rellenan con "0".
La instrucción escribe el contenido de un operando que se cargará en formato de palabra doble
en los 32 bits del acumulador 1. El byte con un direccionamiento más alto se transfiere al byte
derecho (bits 0 a 7) del acumulador 1. El byte con el direccionamiento más bajo se escribe en
los bits 24 y 31.
La tabla siguiente muestra a modo de ejemplo cómo el contenido del acumulador 1 se
transforma en formato de byte, palabra y palabra doble al cargar operandos:
Instrucción

Acumulador 1
31 . . .

. . . 24

23 . . .

. . . 16

15 . . .

...8

7...

Cargar un
byte:
L MB10

0000

0000

0000

0000

0000

0000

<MB10>

Cargar una
palabra:
L MW10

0000

0000

0000

0000

<MB10>

<MB11>

Cargar una
palabra do‐
ble:
L MD10

<MB10>

<MB12>

<MB13>

<MB11>

...0

Al cargar el operando indicado, el contenido previo del acumulador 1 se desplaza al
acumulador 2. La instrucción "Cargar" transfiere todo el contenido del acumulador 1 al
acumulador 2. El contenido previo del acumulador 2 se pierde.
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Cargar":

1656

Parámetro

Declaración

Tipo de datos

Área de memoria

<Operando>

Input

BYTE, WORD,
I, Q, PI, M, L, DB,
DWORD, SINT,
DI, T, C, puntero,
INT, DINT, USINT, parámetro
UINT, UDINT, tem‐
porizadores,
REAL, DATE,
TOD, CHAR

Descripción
Operando cuyo contenido se
carga.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

*R

// Multiplicar los valores de los acumuladores 1 y 2.
// Guardar el producto en el acumulador 1.

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en el
acumulador 1.

+R

// Sumar los valores de los acumuladores 1 y 2.
// Guardar la suma en el acumulador 1.

T "Tag_Result"

// Transferir el resultado (contenido del acumulador
1) al operando "Tag_Result".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)
Ejemplos de programación AWL (Página 8102)

L STW: Cargar palabra de estado en acumulador 1
Descripción
La instrucción "Cargar palabra de estado en acumulador 1" carga la palabra de estado en el
acumulador 1. Al ejecutarse, la instrucción escribe los bits de estado en la palabra derecha del
acumulador 1. Los bits restantes del acumulador 1 se rellenan con "0".
La tabla siguiente muestra el contenido del acumulador después de ejecutar la instrucción
"Cargar palabra de estado en acumulador 1":
Acumulador 1
Número de bit

31-9

8

7

6

5

4

3

2

1

0

Contenido

0

BR

CC 1

CC 0

OV

OS

0

0

RLO

0

Programación del PLC
Manual de programación y manejo, 11/2019

1657

Instrucciones
4.1 Instrucciones
Esta instrucción se ejecuta independientemente del estado lógico del bit de estado.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L STW

// Cargar palabra de estado en acumulador 1.

T "Tag_STW"

// Transferir el contenido del acumulador 1 (bits de
estado) al operando "Tag_STW".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

LAR1: Cargar contenido del acumulador 1 en AR1
Descripción
La instrucción "Cargar contenido del acumulador 1 en AR1" carga el contenido del acumulador
1 en el registro de direcciones 1 (AR1). El valor del acumulador 1 debe equivaler al formato de
un puntero de área (POINTER).
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.
Los contenidos de los acumuladores no cambian debido a la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L P#10.0

// Cargar el puntero (P#10.0) en el acumulador 1.

LAR1

// Cargar el contenido del acumulador 1 en el registro
de direcciones 1.

L MW [AR1,P#4.0]

// Cargar MW14 en acumulador 1.

L "Tag_Value"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el contenido del operando "Tag_Value" en el
acumulador 1.

1658

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones
AWL

Explicación

>I

// Comparar si el valor del acumulador 2 es mayor que
el valor del acumulador 1.

A I [AR1,P#2.1]

// Consultar si el estado lógico del bit I12.1 es "1"
y combinar el resultado lógicamente con Y con el RLO
actual.

= "Tag_Output"

// Si la condición se cumple (RLO = "1"), poner el
operando "Tag_Output" a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

LAR1 <D>: Cargar palabra doble o puntero de área en AR1
Descripción
La instrucción "Cargar palabra doble o puntero de área en AR1" carga el contenido de una
palabra doble o de un puntero intraárea o interárea en el registro de direcciones 1 (AR1). El
contenido de la palabra doble debe equivaler al formato de un puntero de área.
El puntero y la palabra doble pueden estar direccionados en una de las áreas de memoria
siguientes:
● Marcas (M)
● Datos locales temporales (L)
● Bloques de datos (DB, DI)
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.
Los contenidos de los acumuladores no cambian debido a la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Cargar palabra doble o puntero de
área en AR1":
Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<D>

Input

DWORD, POIN‐
TER

D, M, L

Operando cuyo contenido se
carga.

Programación del PLC
Manual de programación y manejo, 11/2019

1659

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

LAR1 P#10.0

// Cargar el contenido del puntero intraárea P#10.0 en
el registro de direcciones 1.

L MW [AR1,P#4.0]

// Cargar MW14 en el acumulador 1.

L "Tag_Value"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el contenido del operando "Tag_Value" en el
acumulador 1.

>I

// Comparar si el valor del acumulador 2 es mayor que
el valor del acumulador 1.

A I [AR1,P#2.1]

// Consultar si el estado lógico del bit I12.1 es "1"
y combinar el resultado lógicamente con Y con el RLO
actual.

= "Tag_Output"

// Si la condición se cumple (RLO= "1"), poner el operando "Tag_Output" a "1".

LAR1 MD20

// Cargar el contenido de MD20 (MD20 = P#30.0) en el
registro de direcciones 1.

A I [AR1,P#2.1]

// Consultar si el estado lógico del bit I32.1 es "1"
y combinar el resultado lógicamente con Y con el RLO
actual.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

LAR1 AR2: Cargar contenido del AR2 en AR1
Descripción
La instrucción "Cargar contenido del AR2 en AR1" carga el contenido del registro de
direcciones 2 (AR2) en el registro de direcciones 1 (AR1).
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.
Los contenidos de los acumuladores no cambian debido a la instrucción.

1660

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

LAR2 P#20.0

// Cargar el contenido del puntero intraárea P#20.0 en
el registro de direcciones 2.

LAR1 AR2

// Copiar el contenido del registro de direcciones 2
en el registro de direcciones 1.

L MW [AR1,P#4.0]

// Cargar MW24 en el acumulador 1.

T "Tag_2"

// Transferir el acumulador 1 a "Tag_2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

LAR2: Cargar contenido del acumulador 1 en AR2
Descripción
La instrucción "Cargar contenido del acumulador 1 en AR2" carga el contenido del acumulador
1 en el registro de direcciones 2 (AR2). El valor del acumulador 1 debe equivaler al formato de
un puntero de área (POINTER).
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.
Los contenidos de los acumuladores no cambian debido a la instrucción.

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L P#10.0

// Cargar el puntero (P#10.0) en el acumulador 1.

LAR2

// Cargar el contenido del acumulador 1 en el registro
de direcciones 2.

L MW [AR2,P#4.0]

// Cargar MW14 en el acumulador 1.

L "Tag_Value"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el contenido del operando "Tag_Value" en el
acumulador 1.

Programación del PLC
Manual de programación y manejo, 11/2019

1661

Instrucciones
4.1 Instrucciones
AWL

Explicación

>I

// Comparar si el valor del acumulador 2 es mayor que
el valor del acumulador 1.

A I [AR2,P#2.1]

// Consultar si el estado lógico del bit I12.1 es "1"
y combinar el resultado lógicamente con Y con el RLO
actual.

= "Tag_Output"

// Si la condición se cumple (RLO = "1"), poner el
operando "Tag_Output" a "1".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

LAR2 <D>: Cargar palabra doble o puntero de área en AR2
Descripción
La instrucción "Cargar palabra doble o puntero de área en AR2" carga el contenido de una
palabra doble o de un puntero intraárea o interárea en el registro de direcciones 2 (AR2). El
contenido de la palabra doble debe equivaler al formato de un puntero de área (POINTER).
El puntero y la palabra doble pueden estar direccionados en una de las áreas de memoria
siguientes:
● Marcas (M)
● Datos locales temporales (L)
● Bloques de datos (DB, DI)
La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.
Los contenidos de los acumuladores no cambian debido a la instrucción.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Cargar palabra doble o puntero de
área en AR2":

1662

Parámetro

Declaración

Tipo de datos

Área de memoria

Descripción

<D>

Input

DWORD, POIN‐
TER

D, M, L

Operando cuyo contenido se
carga.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

LAR2 P#10.0

// Cargar el contenido del puntero intraárea P#10.0 en
el registro de direcciones 2

L MW [AR2,P#4.0]

// Cargar MW14 en el acumulador 1.

L "Tag_Value"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el contenido del operando "Tag_Value" en el
acumulador 1.

>I

// Comparar si el valor del acumulador 2 es mayor que
el valor del acumulador 1.

A I [AR2,P#2.1]

// Consultar si el estado lógico del bit I12.1 es "1"
y combinar el resultado lógicamente con Y con el RLO
actual.

= "Tag_Output"

// Si la condición se cumple (RLO = "1"), poner el
operando "Tag_Output" a "1".

LAR2 MD20

// Cargar el contenido de MD20 (MD20 = P#30.0) en el
registro de direcciones 2.

A I [AR2,P#2.1]

// Consultar si el estado lógico del bit I32.1 es "1"
y combinar el resultado lógicamente con Y con el RLO
actual.

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios básicos de la palabra de estado (Página 198)
Añadir instrucciones AWL (Página 8079)
Procesar instrucciones AWL (Página 8098)
Instancias (Página 61)
Consulta y activación de los bits de estado en AWL (Página 199)

Transferir
T: Transferir
Descripción
La instrucción "Transferir" transfiere el contenido del acumulador 1 a un operando concreto por
bytes, palabras o palabras dobles. El contenido del acumulador 1 no cambia. El operando
indicado debe estar direccionado en una de las áreas de memoria siguientes:
● Memoria imagen de proceso de las entradas y salidas (I, Q)
● Marcas (M)

Programación del PLC
Manual de programación y manejo, 11/2019

1663

Instrucciones
4.1 Instrucciones
● Datos locales temporales (L)
● Bloques de datos (DB, DI)
● Periferia (PQ)
El número de bytes que se transferirán depende del formato del operando indicado. Si el
operando está en formato de byte, la instrucción transfiere el contenido de los bits 0 a 7 del
acumulador 1.
Si el operando indicado está en formato de palabra, la instrucción transfiere el contenido de la
palabra que está alineada a la derecha en el acumulador 1. El byte derecho del acumulador 1
se transfiere al byte con un direccionamiento más alto en el operando. Al byte con un
direccionamiento más bajo del operando se transfieren los bits de 8 a 15 del acumulador 1.
Si el operando indicado está en formato de palabra doble, la instrucción transfiere todo el
contenido del acumulador 1. El byte derecho del acumulador 1 se transfiere al byte con el
direccionamiento más alto del operando. Al byte con un direccionamiento más bajo del
operando se transfieren los bits 24 a 31 del acumulador 1.
La tabla siguiente muestra un ejemplo de cómo se transfiere el contenido del acumulador 1 por
bytes, palabras o palabras dobles:
Instrucción

Acumulador 1

Bits

31 . . . . . .
24

23 . . . . . . 16

15 . . . . . . 8

7......0

Contenido del acu‐
mulador 1

Byte (n)

Byte (n+1)

Byte (n+2)

Byte (n+3)

Byte (n)

Byte (n+1)

Byte (n+2)

Byte (n+3)

Transferir un byte

Byte (n)

Transferir una pala‐
bra
Transferir una pala‐
bra doble

Byte (n)

Byte (n+1)

La CPU ejecuta la instrucción independientemente del resultado lógico y los bits de estado. La
instrucción no influye ni en el resultado lógico ni en los bits de estado.

Parámetros
La tabla siguiente muestra los parámetros de la instrucción "Transferir":

1664

Parámetro

Declaración

Tipo de datos

Área de memoria

<Operando>

Output

I, Q, PQ, M, L, DB,
BYTE, WORD,
DI
DWORD, SINT,
INT, DINT, USINT,
UINT, UDINT, tem‐
porizadores,
REAL, DATE,
TOD, CHAR

Descripción
Operando al que se transfie‐
re el contenido del acumula‐
dor 1.

Programación del PLC
Manual de programación y manejo, 11/2019

Instrucciones
4.1 Instrucciones

Ejemplo
El siguiente ejemplo muestra el funcionamiento de la instrucción:
AWL

Explicación

L "Tag_Value_1"

// Cargar el valor del operando "Tag_Value_1" en el
acumulador 1.

L "Tag_Value_2"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_2" en el
acumulador 1.

*R

// Multiplicar los valores de los acumuladores 1 y 2.
// Guardar el producto en el acumulador 1.

T "Tag_Result_1"

// Transferir el producto (contenido del acumulador 1)
al operando "Tag_Result_1".

L "Tag_Value_3"

// Desplazar el contenido del acumulador 1 al acumulador 2.
// Cargar el valor del operando "Tag_Value_3" en el
acumulador 1.

+R

// Sumar los valores de los acumuladores 1 y 2.
// Guardar la suma en el acumulador 1.

T "Tag_Result_2"

// Transferir la suma (contenido del acumulador 1) al
operando "Tag_Result_2".

Consulte también
Vista general de los tipos de datos válidos (Página 241)
Principios b